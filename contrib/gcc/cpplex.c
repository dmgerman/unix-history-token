begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library - lexical analysis.    Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Per Bothner, 1994-95.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987    Broken out to separate file, Zack Weinberg, Mar 2000    Single-pass line tokenization by Neil Booth, April 2000  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_comment
comment|/* MULTIBYTE_CHARS support only works for native compilers.    ??? Ideally what we want is to model widechar support after    the current floating point support.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_undef
undef|#
directive|undef
name|MULTIBYTE_CHARS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|"mbchar.h"
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Tokens with SPELL_STRING store their spelling in the token list,    and it's length in the token->val.name.len.  */
end_comment

begin_enum
enum|enum
name|spell_type
block|{
name|SPELL_OPERATOR
init|=
literal|0
block|,
name|SPELL_CHAR
block|,
name|SPELL_IDENT
block|,
name|SPELL_NUMBER
block|,
name|SPELL_STRING
block|,
name|SPELL_NONE
block|}
enum|;
end_enum

begin_struct
struct|struct
name|token_spelling
block|{
name|enum
name|spell_type
name|category
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
specifier|const
name|digraph_spellings
index|[]
init|=
block|{
literal|U"%:"
block|,
literal|U"%:%:"
block|,
literal|U"<:"
block|,
literal|U":>"
block|,
literal|U"<%"
block|,
literal|U"%>"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OP
parameter_list|(
name|e
parameter_list|,
name|s
parameter_list|)
value|{ SPELL_OPERATOR, U s           },
end_define

begin_define
define|#
directive|define
name|TK
parameter_list|(
name|e
parameter_list|,
name|s
parameter_list|)
value|{ s,              U STRINGX (e) },
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|token_spelling
name|token_spellings
index|[
name|N_TTYPES
index|]
init|=
block|{
name|TTYPE_TABLE
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|OP
end_undef

begin_undef
undef|#
directive|undef
name|TK
end_undef

begin_define
define|#
directive|define
name|TOKEN_SPELL
parameter_list|(
name|token
parameter_list|)
value|(token_spellings[(token)->type].category)
end_define

begin_define
define|#
directive|define
name|TOKEN_NAME
parameter_list|(
name|token
parameter_list|)
value|(token_spellings[(token)->type].name)
end_define

begin_define
define|#
directive|define
name|BACKUP
parameter_list|()
value|do {buffer->cur = buffer->backup_to;} while (0)
end_define

begin_decl_stmt
specifier|static
name|void
name|handle_newline
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cppchar_t
name|skip_escaped_newlines
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cppchar_t
name|get_effective_char
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skip_block_comment
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skip_line_comment
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_column
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skip_whitespace
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cppchar_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_hashnode
modifier|*
name|parse_identifier
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_hashnode
modifier|*
name|parse_identifier_slow
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_number
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_string
operator|*
operator|,
name|cppchar_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unescaped_terminator_p
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_string
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_token
operator|*
operator|,
name|cppchar_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unterminated
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|trigraph_p
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_comment
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_token
operator|*
operator|,
specifier|const
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|name_p
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_read_ucs
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|*
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tokenrun
modifier|*
name|next_tokenrun
name|PARAMS
argument_list|(
operator|(
name|tokenrun
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hex_digit_value
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|_cpp_buff
modifier|*
name|new_buff
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Utility routine:     Compares, the token TOKEN to the NUL-terminated string STRING.    TOKEN must be a CPP_NAME.  Returns 1 for equal, 0 for unequal.  */
end_comment

begin_function
name|int
name|cpp_ideq
parameter_list|(
name|token
parameter_list|,
name|string
parameter_list|)
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NAME
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|ustrcmp
argument_list|(
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|,
operator|(
specifier|const
name|U_CHAR
operator|*
operator|)
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Call when meeting a newline, assumed to be in buffer->cur[-1].    Returns with buffer->cur pointing to the character immediately    following the newline (combination).  */
end_comment

begin_function
specifier|static
name|void
name|handle_newline
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
comment|/* Handle CR-LF and LF-CR.  Most other implementations (e.g. java)      only accept CR-LF; maybe we should fall back to that behaviour?  */
if|if
condition|(
name|buffer
operator|->
name|cur
index|[
operator|-
literal|1
index|]
operator|+
name|buffer
operator|->
name|cur
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|+
literal|'\n'
condition|)
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|buffer
operator|->
name|line_base
operator|=
name|buffer
operator|->
name|cur
expr_stmt|;
name|buffer
operator|->
name|col_adjust
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of skip_escaped_newlines; called when a 3-character    sequence beginning with "??" is encountered.  buffer->cur points to    the second '?'.     Warn if necessary, and returns true if the sequence forms a    trigraph and the trigraph should be honoured.  */
end_comment

begin_function
specifier|static
name|bool
name|trigraph_p
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|cppchar_t
name|from_char
init|=
name|buffer
operator|->
name|cur
index|[
literal|1
index|]
decl_stmt|;
name|bool
name|accept
decl_stmt|;
if|if
condition|(
operator|!
name|_cpp_trigraph_map
index|[
name|from_char
index|]
condition|)
return|return
name|false
return|;
name|accept
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|trigraphs
argument_list|)
expr_stmt|;
comment|/* Don't warn about trigraphs in comments.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_trigraphs
argument_list|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|lexing_comment
condition|)
block|{
if|if
condition|(
name|accept
condition|)
name|cpp_warning_with_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|line
argument_list|,
name|CPP_BUF_COL
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
argument_list|,
literal|"trigraph ??%c converted to %c"
argument_list|,
operator|(
name|int
operator|)
name|from_char
argument_list|,
operator|(
name|int
operator|)
name|_cpp_trigraph_map
index|[
name|from_char
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|buffer
operator|->
name|cur
operator|!=
name|buffer
operator|->
name|last_Wtrigraphs
condition|)
block|{
name|buffer
operator|->
name|last_Wtrigraphs
operator|=
name|buffer
operator|->
name|cur
expr_stmt|;
name|cpp_warning_with_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|line
argument_list|,
name|CPP_BUF_COL
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
argument_list|,
literal|"trigraph ??%c ignored"
argument_list|,
operator|(
name|int
operator|)
name|from_char
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|accept
return|;
block|}
end_function

begin_comment
comment|/* Skips any escaped newlines introduced by '?' or a '\\', assumed to    lie in buffer->cur[-1].  Returns the next byte, which will be in    buffer->cur[-1].  This routine performs preprocessing stages 1 and    2 of the ISO C standard.  */
end_comment

begin_function
specifier|static
name|cppchar_t
name|skip_escaped_newlines
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|cppchar_t
name|next
init|=
name|buffer
operator|->
name|cur
index|[
operator|-
literal|1
index|]
decl_stmt|;
comment|/* Only do this if we apply stages 1 and 2.  */
if|if
condition|(
operator|!
name|buffer
operator|->
name|from_stage3
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|saved_cur
decl_stmt|;
name|cppchar_t
name|next1
decl_stmt|;
do|do
block|{
if|if
condition|(
name|next
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|buffer
operator|->
name|cur
index|[
literal|0
index|]
operator|!=
literal|'?'
operator|||
operator|!
name|trigraph_p
argument_list|(
name|pfile
argument_list|)
condition|)
break|break;
comment|/* Translate the trigraph.  */
name|next
operator|=
name|_cpp_trigraph_map
index|[
name|buffer
operator|->
name|cur
index|[
literal|1
index|]
index|]
expr_stmt|;
name|buffer
operator|->
name|cur
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|'\\'
condition|)
break|break;
block|}
if|if
condition|(
name|buffer
operator|->
name|cur
operator|==
name|buffer
operator|->
name|rlimit
condition|)
break|break;
comment|/* We have a backslash, and room for at least one more 	     character.  Skip horizontal whitespace.  */
name|saved_cur
operator|=
name|buffer
operator|->
name|cur
expr_stmt|;
do|do
name|next1
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
do|while
condition|(
name|is_nvspace
argument_list|(
name|next1
argument_list|)
operator|&&
name|buffer
operator|->
name|cur
operator|<
name|buffer
operator|->
name|rlimit
condition|)
do|;
if|if
condition|(
operator|!
name|is_vspace
argument_list|(
name|next1
argument_list|)
condition|)
block|{
name|buffer
operator|->
name|cur
operator|=
name|saved_cur
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|saved_cur
operator|!=
name|buffer
operator|->
name|cur
operator|-
literal|1
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|lexing_comment
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"backslash and newline separated by space"
argument_list|)
expr_stmt|;
name|handle_newline
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|backup_to
operator|=
name|buffer
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|cur
operator|==
name|buffer
operator|->
name|rlimit
condition|)
block|{
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"backslash-newline at end of file"
argument_list|)
expr_stmt|;
name|next
operator|=
name|EOF
expr_stmt|;
block|}
else|else
name|next
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|==
literal|'\\'
operator|||
name|next
operator|==
literal|'?'
condition|)
do|;
block|}
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* Obtain the next character, after trigraph conversion and skipping    an arbitrarily long string of escaped newlines.  The common case of    no trigraphs or escaped newlines falls through quickly.  On return,    buffer->backup_to points to where to return to if the character is    not to be processed.  */
end_comment

begin_function
specifier|static
name|cppchar_t
name|get_effective_char
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cppchar_t
name|next
decl_stmt|;
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|buffer
operator|->
name|backup_to
operator|=
name|buffer
operator|->
name|cur
expr_stmt|;
name|next
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|next
operator|==
literal|'?'
operator|||
name|next
operator|==
literal|'\\'
argument_list|,
literal|0
argument_list|)
condition|)
name|next
operator|=
name|skip_escaped_newlines
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* Skip a C-style block comment.  We find the end of the comment by    seeing if an asterisk is before every '/' we encounter.  Returns    non-zero if comment terminated by EOF, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|skip_block_comment
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|cppchar_t
name|c
init|=
name|EOF
decl_stmt|,
name|prevc
init|=
name|EOF
decl_stmt|;
name|pfile
operator|->
name|state
operator|.
name|lexing_comment
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|buffer
operator|->
name|cur
operator|!=
name|buffer
operator|->
name|rlimit
condition|)
block|{
name|prevc
operator|=
name|c
operator|,
name|c
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
comment|/* FIXME: For speed, create a new character class of characters 	 of interest inside block comments.  */
if|if
condition|(
name|c
operator|==
literal|'?'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|skip_escaped_newlines
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* People like decorating comments with '*', so check for '/' 	 instead for efficiency.  */
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|prevc
operator|==
literal|'*'
condition|)
break|break;
comment|/* Warn about potential nested comments, but not if the '/' 	     comes immediately before the true comment delimiter. 	     Don't bother to get it right across escaped newlines.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_comments
argument_list|)
operator|&&
name|buffer
operator|->
name|cur
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|buffer
operator|->
name|cur
index|[
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|cpp_warning_with_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|line
argument_list|,
name|CPP_BUF_COL
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"\"/*\" within comment"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_vspace
argument_list|(
name|c
argument_list|)
condition|)
name|handle_newline
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|adjust_column
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|state
operator|.
name|lexing_comment
operator|=
literal|0
expr_stmt|;
return|return
name|c
operator|!=
literal|'/'
operator|||
name|prevc
operator|!=
literal|'*'
return|;
block|}
end_function

begin_comment
comment|/* Skip a C++ line comment, leaving buffer->cur pointing to the    terminating newline.  Handles escaped newlines.  Returns non-zero    if a multiline comment.  */
end_comment

begin_function
specifier|static
name|int
name|skip_line_comment
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|unsigned
name|int
name|orig_line
init|=
name|pfile
operator|->
name|line
decl_stmt|;
name|cppchar_t
name|c
decl_stmt|;
name|pfile
operator|->
name|state
operator|.
name|lexing_comment
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
name|buffer
operator|->
name|cur
operator|==
name|buffer
operator|->
name|rlimit
condition|)
goto|goto
name|at_eof
goto|;
name|c
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'?'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|skip_escaped_newlines
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|is_vspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
comment|/* Step back over the newline, except at EOF.  */
name|buffer
operator|->
name|cur
operator|--
expr_stmt|;
name|at_eof
label|:
name|pfile
operator|->
name|state
operator|.
name|lexing_comment
operator|=
literal|0
expr_stmt|;
return|return
name|orig_line
operator|!=
name|pfile
operator|->
name|line
return|;
block|}
end_function

begin_comment
comment|/* pfile->buffer->cur is one beyond the \t character.  Update    col_adjust so we track the column correctly.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_column
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|unsigned
name|int
name|col
init|=
name|CPP_BUF_COL
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* Zero-based column.  */
comment|/* Round it up to multiple of the tabstop, but subtract 1 since the      tab itself occupies a character position.  */
name|buffer
operator|->
name|col_adjust
operator|+=
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|tabstop
argument_list|)
operator|-
name|col
operator|%
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|tabstop
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Skips whitespace, saving the next non-whitespace character.    Adjusts pfile->col_adjust to account for tabs.  Without this,    tokens might be assigned an incorrect column.  */
end_comment

begin_function
specifier|static
name|int
name|skip_whitespace
parameter_list|(
name|pfile
parameter_list|,
name|c
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cppchar_t
name|c
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|unsigned
name|int
name|warned
init|=
literal|0
decl_stmt|;
do|do
block|{
comment|/* Horizontal space always OK.  */
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|adjust_column
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Just \f \v or \0 left.  */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|buffer
operator|->
name|cur
operator|-
literal|1
operator|==
name|buffer
operator|->
name|rlimit
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"null character(s) ignored"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn_with_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|line
argument_list|,
name|CPP_BUF_COL
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s in preprocessing directive"
argument_list|,
name|c
operator|==
literal|'\f'
condition|?
literal|"form feed"
else|:
literal|"vertical tab"
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
block|}
comment|/* We only want non-vertical space, i.e. ' ' \t \f \v \0.  */
do|while
condition|(
name|is_nvspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|buffer
operator|->
name|cur
operator|--
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* See if the characters of a number token are valid in a name (no    '.', '+' or '-').  */
end_comment

begin_function
specifier|static
name|int
name|name_p
parameter_list|(
name|pfile
parameter_list|,
name|string
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_string
modifier|*
name|string
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string
operator|->
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|is_idchar
argument_list|(
name|string
operator|->
name|text
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse an identifier, skipping embedded backslash-newlines.  This is    a critical inner loop.  The common case is an identifier which has    not been split by backslash-newline, does not contain a dollar    sign, and has already been scanned (roughly 10:1 ratio of    seen:unseen identifiers in normal code; the distribution is    Poisson-like).  Second most common case is a new identifier, not    split and no dollar sign.  The other possibilities are rare and    have been relegated to parse_identifier_slow.  */
end_comment

begin_function
specifier|static
name|cpp_hashnode
modifier|*
name|parse_identifier
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_hashnode
modifier|*
name|result
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|cur
decl_stmt|;
comment|/* Fast-path loop.  Skim over a normal identifier.      N.B. ISIDNUM does not include $.  */
name|cur
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
expr_stmt|;
while|while
condition|(
name|ISIDNUM
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
name|cur
operator|++
expr_stmt|;
comment|/* Check for slow-path cases.  */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'?'
operator|||
operator|*
name|cur
operator|==
literal|'\\'
operator|||
operator|*
name|cur
operator|==
literal|'$'
condition|)
name|result
operator|=
name|parse_identifier_slow
argument_list|(
name|pfile
argument_list|,
name|cur
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|U_CHAR
modifier|*
name|base
init|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|-
literal|1
decl_stmt|;
name|result
operator|=
operator|(
name|cpp_hashnode
operator|*
operator|)
name|ht_lookup
argument_list|(
name|pfile
operator|->
name|hash_table
argument_list|,
name|base
argument_list|,
name|cur
operator|-
name|base
argument_list|,
name|HT_ALLOC
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
block|}
comment|/* Rarely, identifiers require diagnostics when lexed.      XXX Has to be forced out of the fast path.  */
if|if
condition|(
name|__builtin_expect
argument_list|(
operator|(
name|result
operator|->
name|flags
operator|&
name|NODE_DIAGNOSTIC
operator|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* It is allowed to poison the same identifier twice.  */
if|if
condition|(
operator|(
name|result
operator|->
name|flags
operator|&
name|NODE_POISONED
operator|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|poisoned_ok
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"attempt to use poisoned \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the 	 replacement list of a variadic macro.  */
if|if
condition|(
name|result
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n__VA_ARGS__
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|va_args_ok
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"__VA_ARGS__ can only appear in the expansion of a C99 variadic macro"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Slow path.  This handles identifiers which have been split, and    identifiers which contain dollar signs.  The part of the identifier    from PFILE->buffer->cur-1 to CUR has already been scanned.  */
end_comment

begin_function
specifier|static
name|cpp_hashnode
modifier|*
name|parse_identifier_slow
parameter_list|(
name|pfile
parameter_list|,
name|cur
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|cur
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|base
init|=
name|buffer
operator|->
name|cur
operator|-
literal|1
decl_stmt|;
name|struct
name|obstack
modifier|*
name|stack
init|=
operator|&
name|pfile
operator|->
name|hash_table
operator|->
name|stack
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|,
name|saw_dollar
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
comment|/* Copy the part of the token which is known to be okay.  */
name|obstack_grow
argument_list|(
name|stack
argument_list|,
name|base
argument_list|,
name|cur
operator|-
name|base
argument_list|)
expr_stmt|;
comment|/* Now process the part which isn't.  We are looking at one of      '$', '\\', or '?' on entry to this loop.  */
name|c
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
name|buffer
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
do|do
block|{
while|while
condition|(
name|is_idchar
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|obstack_1grow
argument_list|(
name|stack
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
name|saw_dollar
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
block|}
comment|/* Potential escaped newline?  */
name|buffer
operator|->
name|backup_to
operator|=
name|buffer
operator|->
name|cur
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'?'
operator|&&
name|c
operator|!=
literal|'\\'
condition|)
break|break;
name|c
operator|=
name|skip_escaped_newlines
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|is_idchar
argument_list|(
name|c
argument_list|)
condition|)
do|;
comment|/* Step back over the unwanted char.  */
name|BACKUP
argument_list|()
expr_stmt|;
comment|/* $ is not an identifier character in the standard, but is commonly      accepted as an extension.  Don't warn about it in skipped      conditional blocks.  */
if|if
condition|(
name|saw_dollar
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"'$' character(s) in identifier"
argument_list|)
expr_stmt|;
comment|/* Identifiers are null-terminated.  */
name|len
operator|=
name|obstack_object_size
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|stack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|cpp_hashnode
operator|*
operator|)
name|ht_lookup
argument_list|(
name|pfile
operator|->
name|hash_table
argument_list|,
name|obstack_finish
argument_list|(
name|stack
argument_list|)
argument_list|,
name|len
argument_list|,
name|HT_ALLOCED
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a number, beginning with character C, skipping embedded    backslash-newlines.  LEADING_PERIOD is non-zero if there was a "."    before C.  Place the result in NUMBER.  */
end_comment

begin_function
specifier|static
name|void
name|parse_number
parameter_list|(
name|pfile
parameter_list|,
name|number
parameter_list|,
name|c
parameter_list|,
name|leading_period
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_string
modifier|*
name|number
decl_stmt|;
name|cppchar_t
name|c
decl_stmt|;
name|int
name|leading_period
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|dest
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
name|limit
operator|=
name|BUFF_LIMIT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
comment|/* Place a leading period.  */
if|if
condition|(
name|leading_period
condition|)
block|{
if|if
condition|(
name|dest
operator|==
name|limit
condition|)
block|{
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|u_buff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dest
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
name|limit
operator|=
name|BUFF_LIMIT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
do|do
block|{
do|do
block|{
comment|/* Need room for terminating null.  */
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|limit
operator|-
name|dest
argument_list|)
operator|<
literal|2
condition|)
block|{
name|size_t
name|len_so_far
init|=
name|dest
operator|-
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
decl_stmt|;
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|u_buff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dest
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
operator|+
name|len_so_far
expr_stmt|;
name|limit
operator|=
name|BUFF_LIMIT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|is_numchar
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|VALID_SIGN
argument_list|(
name|c
argument_list|,
name|dest
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
do|;
comment|/* Potential escaped newline?  */
name|buffer
operator|->
name|backup_to
operator|=
name|buffer
operator|->
name|cur
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'?'
operator|&&
name|c
operator|!=
literal|'\\'
condition|)
break|break;
name|c
operator|=
name|skip_escaped_newlines
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|is_numchar
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|VALID_SIGN
argument_list|(
name|c
argument_list|,
name|dest
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
do|;
comment|/* Step back over the unwanted char.  */
name|BACKUP
argument_list|()
expr_stmt|;
comment|/* Null-terminate the number.  */
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
name|number
operator|->
name|text
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
name|number
operator|->
name|len
operator|=
name|dest
operator|-
name|number
operator|->
name|text
expr_stmt|;
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
operator|=
name|dest
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of parse_string.  Emits error for unterminated strings.  */
end_comment

begin_function
specifier|static
name|void
name|unterminated
parameter_list|(
name|pfile
parameter_list|,
name|term
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|term
decl_stmt|;
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"missing terminating %c character"
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|==
literal|'\"'
operator|&&
name|pfile
operator|->
name|mls_line
operator|&&
name|pfile
operator|->
name|mls_line
operator|!=
name|pfile
operator|->
name|line
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|mls_line
argument_list|,
name|pfile
operator|->
name|mls_col
argument_list|,
literal|"possible start of unterminated string literal"
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|mls_line
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of parse_string.  */
end_comment

begin_function
specifier|static
name|int
name|unescaped_terminator_p
parameter_list|(
name|pfile
parameter_list|,
name|dest
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|dest
decl_stmt|;
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
comment|/* In #include-style directives, terminators are not escapeable.  */
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|angled_headers
condition|)
return|return
literal|1
return|;
name|start
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
comment|/* An odd number of consecutive backslashes represents an escaped      terminator.  */
for|for
control|(
name|temp
operator|=
name|dest
init|;
name|temp
operator|>
name|start
operator|&&
name|temp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|;
name|temp
operator|--
control|)
empty_stmt|;
return|return
operator|(
operator|(
name|dest
operator|-
name|temp
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parses a string, character constant, or angle-bracketed header file    name.  Handles embedded trigraphs and escaped newlines.  The stored    string is guaranteed NUL-terminated, but it is not guaranteed that    this is the first NUL since embedded NULs are preserved.    Multi-line strings are allowed, but they are deprecated.     When this function returns, buffer->cur points to the next    character to be processed.  */
end_comment

begin_function
specifier|static
name|void
name|parse_string
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|,
name|terminator
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|cppchar_t
name|terminator
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|cppchar_t
name|c
decl_stmt|;
name|bool
name|warned_nulls
init|=
name|false
decl_stmt|,
name|warned_multi
init|=
name|false
decl_stmt|;
name|dest
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
name|limit
operator|=
name|BUFF_LIMIT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* We need room for another char, possibly the terminating NUL.  */
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|limit
operator|-
name|dest
argument_list|)
operator|<
literal|1
condition|)
block|{
name|size_t
name|len_so_far
init|=
name|dest
operator|-
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
decl_stmt|;
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|u_buff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dest
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
operator|+
name|len_so_far
expr_stmt|;
name|limit
operator|=
name|BUFF_LIMIT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
block|}
comment|/* Handle trigraphs, escaped newlines etc.  */
name|c
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'?'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|skip_escaped_newlines
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|terminator
condition|)
block|{
if|if
condition|(
name|unescaped_terminator_p
argument_list|(
name|pfile
argument_list|,
name|dest
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|is_vspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* In assembly language, silently terminate string and 	     character literals at end of line.  This is a kludge 	     around not knowing where comments are.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_ASM
operator|&&
name|terminator
operator|!=
literal|'>'
condition|)
block|{
name|buffer
operator|->
name|cur
operator|--
expr_stmt|;
break|break;
block|}
comment|/* Character constants and header names may not extend over 	     multiple lines.  In Standard C, neither may strings. 	     Unfortunately, we accept multiline strings as an 	     extension, except in #include family directives.  */
if|if
condition|(
name|terminator
operator|!=
literal|'"'
operator|||
name|pfile
operator|->
name|state
operator|.
name|angled_headers
condition|)
block|{
name|unterminated
argument_list|(
name|pfile
argument_list|,
name|terminator
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|cur
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|warned_multi
condition|)
block|{
name|warned_multi
operator|=
name|true
expr_stmt|;
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"multi-line string literals are deprecated"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|mls_line
operator|==
literal|0
condition|)
block|{
name|pfile
operator|->
name|mls_line
operator|=
name|token
operator|->
name|line
expr_stmt|;
name|pfile
operator|->
name|mls_col
operator|=
name|token
operator|->
name|col
expr_stmt|;
block|}
name|handle_newline
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|buffer
operator|->
name|cur
operator|-
literal|1
operator|==
name|buffer
operator|->
name|rlimit
condition|)
block|{
name|unterminated
argument_list|(
name|pfile
argument_list|,
name|terminator
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|cur
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|warned_nulls
condition|)
block|{
name|warned_nulls
operator|=
name|true
expr_stmt|;
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"null character(s) preserved in literal"
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|dest
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|=
name|dest
operator|-
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
operator|=
name|dest
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The stored comment includes the comment start and any terminator.  */
end_comment

begin_function
specifier|static
name|void
name|save_comment
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|,
name|from
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_token
modifier|*
name|token
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|from
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|len
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|-
name|from
operator|+
literal|1
expr_stmt|;
comment|/* + 1 for the initial '/'.  */
comment|/* C++ comments probably (not definitely) have moved past a new      line, which we don't want to save in the comment.  */
if|if
condition|(
name|is_vspace
argument_list|(
name|pfile
operator|->
name|buffer
operator|->
name|cur
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
name|buffer
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CPP_COMMENT
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
operator|=
name|buffer
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
operator|+
literal|1
argument_list|,
name|from
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate COUNT tokens for RUN.  */
end_comment

begin_function
name|void
name|_cpp_init_tokenrun
parameter_list|(
name|run
parameter_list|,
name|count
parameter_list|)
name|tokenrun
modifier|*
name|run
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|{
name|run
operator|->
name|base
operator|=
name|xnewvec
argument_list|(
name|cpp_token
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|run
operator|->
name|limit
operator|=
name|run
operator|->
name|base
operator|+
name|count
expr_stmt|;
name|run
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the next tokenrun, or creates one if there is none.  */
end_comment

begin_function
specifier|static
name|tokenrun
modifier|*
name|next_tokenrun
parameter_list|(
name|run
parameter_list|)
name|tokenrun
modifier|*
name|run
decl_stmt|;
block|{
if|if
condition|(
name|run
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|run
operator|->
name|next
operator|=
name|xnew
argument_list|(
name|tokenrun
argument_list|)
expr_stmt|;
name|run
operator|->
name|next
operator|->
name|prev
operator|=
name|run
expr_stmt|;
name|_cpp_init_tokenrun
argument_list|(
name|run
operator|->
name|next
argument_list|,
literal|250
argument_list|)
expr_stmt|;
block|}
return|return
name|run
operator|->
name|next
return|;
block|}
end_function

begin_comment
comment|/* Allocate a single token that is invalidated at the same time as the    rest of the tokens on the line.  Has its line and col set to the    same as the last lexed token, so that diagnostics appear in the    right place.  */
end_comment

begin_function
name|cpp_token
modifier|*
name|_cpp_temp_token
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_token
modifier|*
name|old
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|old
operator|=
name|pfile
operator|->
name|cur_token
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|cur_token
operator|==
name|pfile
operator|->
name|cur_run
operator|->
name|limit
condition|)
block|{
name|pfile
operator|->
name|cur_run
operator|=
name|next_tokenrun
argument_list|(
name|pfile
operator|->
name|cur_run
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|pfile
operator|->
name|cur_run
operator|->
name|base
expr_stmt|;
block|}
name|result
operator|=
name|pfile
operator|->
name|cur_token
operator|++
expr_stmt|;
name|result
operator|->
name|line
operator|=
name|old
operator|->
name|line
expr_stmt|;
name|result
operator|->
name|col
operator|=
name|old
operator|->
name|col
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Lex a token into RESULT (external interface).  Takes care of issues    like directive handling, token lookahead, multiple include    optimization and skipping.  */
end_comment

begin_function
specifier|const
name|cpp_token
modifier|*
name|_cpp_lex_token
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_token
modifier|*
name|result
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pfile
operator|->
name|cur_token
operator|==
name|pfile
operator|->
name|cur_run
operator|->
name|limit
condition|)
block|{
name|pfile
operator|->
name|cur_run
operator|=
name|next_tokenrun
argument_list|(
name|pfile
operator|->
name|cur_run
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|pfile
operator|->
name|cur_run
operator|->
name|base
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|lookaheads
condition|)
block|{
name|pfile
operator|->
name|lookaheads
operator|--
expr_stmt|;
name|result
operator|=
name|pfile
operator|->
name|cur_token
operator|++
expr_stmt|;
block|}
else|else
name|result
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|flags
operator|&
name|BOL
condition|)
block|{
comment|/* Is this a directive.  If _cpp_handle_directive returns 	     false, it is an assembler #.  */
if|if
condition|(
name|result
operator|->
name|type
operator|==
name|CPP_HASH
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|&&
name|_cpp_handle_directive
argument_list|(
name|pfile
argument_list|,
name|result
operator|->
name|flags
operator|&
name|PREV_WHITE
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|line_change
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
call|(
modifier|*
name|pfile
operator|->
name|cb
operator|.
name|line_change
call|)
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
name|pfile
operator|->
name|state
operator|.
name|parsing_args
argument_list|)
expr_stmt|;
block|}
comment|/* We don't skip tokens in directives.  */
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
break|break;
comment|/* Outside a directive, invalidate controlling macros.  At file 	 EOF, _cpp_lex_direct takes care of popping the buffer, so we never 	 get here and MI optimisation works.  */
name|pfile
operator|->
name|mi_valid
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|||
name|result
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IF_NEXT_IS
parameter_list|(
name|CHAR
parameter_list|,
name|THEN_TYPE
parameter_list|,
name|ELSE_TYPE
parameter_list|)
define|\
value|do {						\     if (get_effective_char (pfile) == CHAR)	\       result->type = THEN_TYPE;			\     else					\       {						\         BACKUP ();				\         result->type = ELSE_TYPE;		\       }						\   } while (0)
end_define

begin_comment
comment|/* Lex a token into pfile->cur_token, which is also incremented, to    get diagnostics pointing to the correct location.     Does not handle issues such as token lookahead, multiple-include    optimisation, directives, skipping etc.  This function is only    suitable for use by _cpp_lex_token, and in special cases like    lex_expansion_token which doesn't care for any of these issues.     When meeting a newline, returns CPP_EOF if parsing a directive,    otherwise returns to the start of the token buffer if permissible.    Returns the location of the lexed token.  */
end_comment

begin_function
name|cpp_token
modifier|*
name|_cpp_lex_direct
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cppchar_t
name|c
decl_stmt|;
name|cpp_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|comment_start
decl_stmt|;
name|cpp_token
modifier|*
name|result
init|=
name|pfile
operator|->
name|cur_token
operator|++
decl_stmt|;
name|fresh_line
label|:
name|buffer
operator|=
name|pfile
operator|->
name|buffer
expr_stmt|;
name|result
operator|->
name|flags
operator|=
name|buffer
operator|->
name|saved_flags
expr_stmt|;
name|buffer
operator|->
name|saved_flags
operator|=
literal|0
expr_stmt|;
name|update_tokens_line
label|:
name|result
operator|->
name|line
operator|=
name|pfile
operator|->
name|line
expr_stmt|;
name|skipped_white
label|:
name|c
operator|=
operator|*
name|buffer
operator|->
name|cur
operator|++
expr_stmt|;
name|result
operator|->
name|col
operator|=
name|CPP_BUF_COLUMN
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|cur
argument_list|)
expr_stmt|;
name|trigraph
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\0'
case|:
name|result
operator|->
name|flags
operator||=
name|PREV_WHITE
expr_stmt|;
if|if
condition|(
name|skip_whitespace
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
condition|)
goto|goto
name|skipped_white
goto|;
comment|/* EOF.  */
name|buffer
operator|->
name|cur
operator|--
expr_stmt|;
name|buffer
operator|->
name|saved_flags
operator|=
name|BOL
expr_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
block|{
if|if
condition|(
name|buffer
operator|->
name|cur
operator|!=
name|buffer
operator|->
name|line_base
condition|)
block|{
comment|/* Non-empty files should end in a newline.  Don't warn 		 for command line and _Pragma buffers.  */
if|if
condition|(
operator|!
name|buffer
operator|->
name|from_stage3
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"no newline at end of file"
argument_list|)
expr_stmt|;
name|handle_newline
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
comment|/* Don't pop the last buffer.  */
if|if
condition|(
name|buffer
operator|->
name|prev
condition|)
block|{
name|unsigned
name|char
name|stop
init|=
name|buffer
operator|->
name|return_at_eof
decl_stmt|;
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stop
condition|)
goto|goto
name|fresh_line
goto|;
block|}
block|}
name|result
operator|->
name|type
operator|=
name|CPP_EOF
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
name|handle_newline
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|saved_flags
operator|=
name|BOL
expr_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|==
literal|2
condition|)
name|buffer
operator|->
name|saved_flags
operator||=
name|PREV_WHITE
expr_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|keep_tokens
condition|)
block|{
name|pfile
operator|->
name|cur_run
operator|=
operator|&
name|pfile
operator|->
name|base_run
expr_stmt|;
name|result
operator|=
name|pfile
operator|->
name|base_run
operator|.
name|base
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|result
operator|+
literal|1
expr_stmt|;
block|}
goto|goto
name|fresh_line
goto|;
block|}
name|result
operator|->
name|type
operator|=
name|CPP_EOF
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'\\'
case|:
comment|/* These could start an escaped newline, or '?' a trigraph.  Let 	 skip_escaped_newlines do all the work.  */
block|{
name|unsigned
name|int
name|line
init|=
name|pfile
operator|->
name|line
decl_stmt|;
name|c
operator|=
name|skip_escaped_newlines
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|pfile
operator|->
name|line
condition|)
block|{
name|buffer
operator|->
name|cur
operator|--
expr_stmt|;
comment|/* We had at least one escaped newline of some sort. 	       Update the token's line and column.  */
goto|goto
name|update_tokens_line
goto|;
block|}
block|}
comment|/* We are either the original '?' or '\\', or a trigraph.  */
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_QUERY
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
goto|goto
name|random_char
goto|;
else|else
goto|goto
name|trigraph
goto|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_NUMBER
expr_stmt|;
name|parse_number
argument_list|(
name|pfile
argument_list|,
operator|&
name|result
operator|->
name|val
operator|.
name|str
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* 'L' may introduce wide characters or strings.  */
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|pos
init|=
name|buffer
operator|->
name|cur
decl_stmt|;
name|c
operator|=
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
name|result
operator|->
name|type
operator|=
operator|(
name|c
operator|==
literal|'"'
condition|?
name|CPP_WSTRING
else|:
name|CPP_WCHAR
operator|)
expr_stmt|;
name|parse_string
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|buffer
operator|->
name|cur
operator|=
name|pos
expr_stmt|;
block|}
comment|/* Fall through.  */
name|start_ident
label|:
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_NAME
expr_stmt|;
name|result
operator|->
name|val
operator|.
name|node
operator|=
name|parse_identifier
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Convert named operators to their proper types.  */
if|if
condition|(
name|result
operator|->
name|val
operator|.
name|node
operator|->
name|flags
operator|&
name|NODE_OPERATOR
condition|)
block|{
name|result
operator|->
name|flags
operator||=
name|NAMED_OP
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|result
operator|->
name|val
operator|.
name|node
operator|->
name|value
operator|.
name|operator
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
name|result
operator|->
name|type
operator|=
name|c
operator|==
literal|'"'
condition|?
name|CPP_STRING
else|:
name|CPP_CHAR
expr_stmt|;
name|parse_string
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|/* A potential block or line comment.  */
name|comment_start
operator|=
name|buffer
operator|->
name|cur
expr_stmt|;
name|c
operator|=
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|skip_block_comment
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
operator|&&
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus_comments
argument_list|)
operator|||
name|CPP_IN_SYSTEM_HEADER
argument_list|(
name|pfile
argument_list|)
operator|)
condition|)
block|{
comment|/* Warn about comments only if pedantically GNUC89, and not 	     in system headers.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_GNUC89
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|buffer
operator|->
name|warned_cplusplus_comments
condition|)
block|{
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"C++ style comments are not allowed in ISO C89"
argument_list|)
expr_stmt|;
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"(this will be reported only once per input file)"
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|warned_cplusplus_comments
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|skip_line_comment
argument_list|(
name|pfile
argument_list|)
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_comments
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"multi-line comment"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
name|result
operator|->
name|type
operator|=
name|CPP_DIV_EQ
expr_stmt|;
break|break;
block|}
else|else
block|{
name|BACKUP
argument_list|()
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_DIV
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|save_comments
condition|)
block|{
name|result
operator|->
name|flags
operator||=
name|PREV_WHITE
expr_stmt|;
goto|goto
name|update_tokens_line
goto|;
block|}
comment|/* Save the comment as a token in its own right.  */
name|save_comment
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
name|comment_start
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|angled_headers
condition|)
block|{
name|result
operator|->
name|type
operator|=
name|CPP_HEADER_NAME
expr_stmt|;
name|parse_string
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_LESS_EQ
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_LSHIFT_EQ
argument_list|,
name|CPP_LSHIFT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_MIN_EQ
argument_list|,
name|CPP_MIN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|digraphs
argument_list|)
condition|)
block|{
name|result
operator|->
name|type
operator|=
name|CPP_OPEN_SQUARE
expr_stmt|;
name|result
operator|->
name|flags
operator||=
name|DIGRAPH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|digraphs
argument_list|)
condition|)
block|{
name|result
operator|->
name|type
operator|=
name|CPP_OPEN_BRACE
expr_stmt|;
name|result
operator|->
name|flags
operator||=
name|DIGRAPH
expr_stmt|;
block|}
else|else
block|{
name|BACKUP
argument_list|()
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_LESS
expr_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
name|c
operator|=
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_GREATER_EQ
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_RSHIFT_EQ
argument_list|,
name|CPP_RSHIFT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_MAX_EQ
argument_list|,
name|CPP_MAX
argument_list|)
expr_stmt|;
else|else
block|{
name|BACKUP
argument_list|()
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_GREATER
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
name|c
operator|=
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_MOD_EQ
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|digraphs
argument_list|)
operator|&&
name|c
operator|==
literal|':'
condition|)
block|{
name|result
operator|->
name|flags
operator||=
name|DIGRAPH
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_HASH
expr_stmt|;
if|if
condition|(
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
operator|==
literal|'%'
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|pos
init|=
name|buffer
operator|->
name|cur
decl_stmt|;
if|if
condition|(
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
operator|==
literal|':'
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_PASTE
expr_stmt|;
else|else
name|buffer
operator|->
name|cur
operator|=
name|pos
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|BACKUP
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|digraphs
argument_list|)
operator|&&
name|c
operator|==
literal|'>'
condition|)
block|{
name|result
operator|->
name|flags
operator||=
name|DIGRAPH
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_CLOSE_BRACE
expr_stmt|;
block|}
else|else
block|{
name|BACKUP
argument_list|()
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_MOD
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_DOT
expr_stmt|;
name|c
operator|=
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|pos
init|=
name|buffer
operator|->
name|cur
decl_stmt|;
if|if
condition|(
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
operator|==
literal|'.'
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_ELLIPSIS
expr_stmt|;
else|else
name|buffer
operator|->
name|cur
operator|=
name|pos
operator|-
literal|1
expr_stmt|;
block|}
comment|/* All known character sets have 0...9 contiguous.  */
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|result
operator|->
name|type
operator|=
name|CPP_NUMBER
expr_stmt|;
name|parse_number
argument_list|(
name|pfile
argument_list|,
operator|&
name|result
operator|->
name|val
operator|.
name|str
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_DOT_STAR
expr_stmt|;
else|else
name|BACKUP
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|c
operator|=
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_PLUS_PLUS
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_PLUS_EQ
expr_stmt|;
else|else
block|{
name|BACKUP
argument_list|()
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_PLUS
expr_stmt|;
block|}
break|break;
case|case
literal|'-'
case|:
name|c
operator|=
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
name|result
operator|->
name|type
operator|=
name|CPP_DEREF
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
block|{
if|if
condition|(
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
operator|==
literal|'*'
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_DEREF_STAR
expr_stmt|;
else|else
name|BACKUP
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_MINUS_MINUS
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_MINUS_EQ
expr_stmt|;
else|else
block|{
name|BACKUP
argument_list|()
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_MINUS
expr_stmt|;
block|}
break|break;
case|case
literal|'&'
case|:
name|c
operator|=
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_AND_AND
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_AND_EQ
expr_stmt|;
else|else
block|{
name|BACKUP
argument_list|()
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_AND
expr_stmt|;
block|}
break|break;
case|case
literal|'|'
case|:
name|c
operator|=
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'|'
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_OR_OR
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_OR_EQ
expr_stmt|;
else|else
block|{
name|BACKUP
argument_list|()
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_OR
expr_stmt|;
block|}
break|break;
case|case
literal|':'
case|:
name|c
operator|=
name|get_effective_char
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
condition|)
name|result
operator|->
name|type
operator|=
name|CPP_SCOPE
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|digraphs
argument_list|)
condition|)
block|{
name|result
operator|->
name|flags
operator||=
name|DIGRAPH
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_CLOSE_SQUARE
expr_stmt|;
block|}
else|else
block|{
name|BACKUP
argument_list|()
expr_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_COLON
expr_stmt|;
block|}
break|break;
case|case
literal|'*'
case|:
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_MULT_EQ
argument_list|,
name|CPP_MULT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_EQ_EQ
argument_list|,
name|CPP_EQ
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_NOT_EQ
argument_list|,
name|CPP_NOT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|IF_NEXT_IS
argument_list|(
literal|'='
argument_list|,
name|CPP_XOR_EQ
argument_list|,
name|CPP_XOR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|IF_NEXT_IS
argument_list|(
literal|'#'
argument_list|,
name|CPP_PASTE
argument_list|,
name|CPP_HASH
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_COMPL
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|result
operator|->
name|type
operator|=
name|CPP_COMMA
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|result
operator|->
name|type
operator|=
name|CPP_OPEN_PAREN
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_CLOSE_PAREN
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|result
operator|->
name|type
operator|=
name|CPP_OPEN_SQUARE
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_CLOSE_SQUARE
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_OPEN_BRACE
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_CLOSE_BRACE
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_SEMICOLON
expr_stmt|;
break|break;
comment|/* @ is a punctuator in Objective C.  */
case|case
literal|'@'
case|:
name|result
operator|->
name|type
operator|=
name|CPP_ATSIGN
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dollars_in_ident
argument_list|)
condition|)
goto|goto
name|start_ident
goto|;
comment|/* Fall through...  */
name|random_char
label|:
default|default:
name|result
operator|->
name|type
operator|=
name|CPP_OTHER
expr_stmt|;
name|result
operator|->
name|val
operator|.
name|c
operator|=
name|c
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* An upper bound on the number of bytes needed to spell TOKEN,    including preceding whitespace.  */
end_comment

begin_function
name|unsigned
name|int
name|cpp_token_len
parameter_list|(
name|token
parameter_list|)
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
block|{
name|unsigned
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|TOKEN_SPELL
argument_list|(
name|token
argument_list|)
condition|)
block|{
default|default:
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SPELL_NUMBER
case|:
case|case
name|SPELL_STRING
case|:
name|len
operator|=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
expr_stmt|;
break|break;
case|case
name|SPELL_IDENT
case|:
name|len
operator|=
name|NODE_LEN
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 1 for whitespace, 4 for comment delimiters.  */
return|return
name|len
operator|+
literal|5
return|;
block|}
end_function

begin_comment
comment|/* Write the spelling of a token TOKEN to BUFFER.  The buffer must    already contain the enough space to hold the token's spelling.    Returns a pointer to the character after the last character    written.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|cpp_spell_token
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|,
name|buffer
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
comment|/* Would be nice to be rid of this...  */
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
switch|switch
condition|(
name|TOKEN_SPELL
argument_list|(
name|token
argument_list|)
condition|)
block|{
case|case
name|SPELL_OPERATOR
case|:
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|spelling
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|DIGRAPH
condition|)
name|spelling
operator|=
name|digraph_spellings
index|[
operator|(
name|int
operator|)
name|token
operator|->
name|type
operator|-
operator|(
name|int
operator|)
name|CPP_FIRST_DIGRAPH
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
goto|goto
name|spell_ident
goto|;
else|else
name|spelling
operator|=
name|TOKEN_NAME
argument_list|(
name|token
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|spelling
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
block|}
break|break;
case|case
name|SPELL_CHAR
case|:
operator|*
name|buffer
operator|++
operator|=
name|token
operator|->
name|val
operator|.
name|c
expr_stmt|;
break|break;
name|spell_ident
label|:
case|case
name|SPELL_IDENT
case|:
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|,
name|NODE_LEN
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|NODE_LEN
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPELL_NUMBER
case|:
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
expr_stmt|;
break|break;
case|case
name|SPELL_STRING
case|:
block|{
name|int
name|left
decl_stmt|,
name|right
decl_stmt|,
name|tag
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_STRING
case|:
name|left
operator|=
literal|'"'
expr_stmt|;
name|right
operator|=
literal|'"'
expr_stmt|;
name|tag
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|CPP_WSTRING
case|:
name|left
operator|=
literal|'"'
expr_stmt|;
name|right
operator|=
literal|'"'
expr_stmt|;
name|tag
operator|=
literal|'L'
expr_stmt|;
break|break;
case|case
name|CPP_CHAR
case|:
name|left
operator|=
literal|'\''
expr_stmt|;
name|right
operator|=
literal|'\''
expr_stmt|;
name|tag
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|CPP_WCHAR
case|:
name|left
operator|=
literal|'\''
expr_stmt|;
name|right
operator|=
literal|'\''
expr_stmt|;
name|tag
operator|=
literal|'L'
expr_stmt|;
break|break;
case|case
name|CPP_HEADER_NAME
case|:
name|left
operator|=
literal|'<'
expr_stmt|;
name|right
operator|=
literal|'>'
expr_stmt|;
name|tag
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|cpp_ice
argument_list|(
name|pfile
argument_list|,
literal|"unknown string token %s\n"
argument_list|,
name|TOKEN_NAME
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
if|if
condition|(
name|tag
condition|)
operator|*
name|buffer
operator|++
operator|=
name|tag
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
name|left
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
name|right
expr_stmt|;
block|}
break|break;
case|case
name|SPELL_NONE
case|:
name|cpp_ice
argument_list|(
name|pfile
argument_list|,
literal|"unspellable token %s"
argument_list|,
name|TOKEN_NAME
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Returns TOKEN spelt as a null-terminated string.  The string is    freed when the reader is destroyed.  Useful for diagnostics.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|cpp_token_as_text
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
block|{
name|unsigned
name|int
name|len
init|=
name|cpp_token_len
argument_list|(
name|token
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
init|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|len
argument_list|)
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|end
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* Used by C front ends, which really should move to using    cpp_token_as_text.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cpp_type2name
parameter_list|(
name|type
parameter_list|)
name|enum
name|cpp_ttype
name|type
decl_stmt|;
block|{
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|token_spellings
index|[
name|type
index|]
operator|.
name|name
return|;
block|}
end_function

begin_comment
comment|/* Writes the spelling of token to FP, without any preceding space.    Separated from cpp_spell_token for efficiency - to avoid stdio    double-buffering.  */
end_comment

begin_function
name|void
name|cpp_output_token
parameter_list|(
name|token
parameter_list|,
name|fp
parameter_list|)
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
switch|switch
condition|(
name|TOKEN_SPELL
argument_list|(
name|token
argument_list|)
condition|)
block|{
case|case
name|SPELL_OPERATOR
case|:
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|spelling
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|DIGRAPH
condition|)
name|spelling
operator|=
name|digraph_spellings
index|[
operator|(
name|int
operator|)
name|token
operator|->
name|type
operator|-
operator|(
name|int
operator|)
name|CPP_FIRST_DIGRAPH
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
goto|goto
name|spell_ident
goto|;
else|else
name|spelling
operator|=
name|TOKEN_NAME
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|spelling
expr_stmt|;
do|do
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|spelling
operator|)
operator|!=
literal|'\0'
condition|)
do|;
block|}
break|break;
case|case
name|SPELL_CHAR
case|:
name|putc
argument_list|(
name|token
operator|->
name|val
operator|.
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
name|spell_ident
label|:
case|case
name|SPELL_IDENT
case|:
name|fwrite
argument_list|(
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NODE_LEN
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPELL_NUMBER
case|:
name|fwrite
argument_list|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPELL_STRING
case|:
block|{
name|int
name|left
decl_stmt|,
name|right
decl_stmt|,
name|tag
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_STRING
case|:
name|left
operator|=
literal|'"'
expr_stmt|;
name|right
operator|=
literal|'"'
expr_stmt|;
name|tag
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|CPP_WSTRING
case|:
name|left
operator|=
literal|'"'
expr_stmt|;
name|right
operator|=
literal|'"'
expr_stmt|;
name|tag
operator|=
literal|'L'
expr_stmt|;
break|break;
case|case
name|CPP_CHAR
case|:
name|left
operator|=
literal|'\''
expr_stmt|;
name|right
operator|=
literal|'\''
expr_stmt|;
name|tag
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|CPP_WCHAR
case|:
name|left
operator|=
literal|'\''
expr_stmt|;
name|right
operator|=
literal|'\''
expr_stmt|;
name|tag
operator|=
literal|'L'
expr_stmt|;
break|break;
case|case
name|CPP_HEADER_NAME
case|:
name|left
operator|=
literal|'<'
expr_stmt|;
name|right
operator|=
literal|'>'
expr_stmt|;
name|tag
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"impossible STRING token %s\n"
argument_list|,
name|TOKEN_NAME
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tag
condition|)
name|putc
argument_list|(
name|tag
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|left
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|right
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPELL_NONE
case|:
comment|/* An error, most probably.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Compare two tokens.  */
end_comment

begin_function
name|int
name|_cpp_equiv_tokens
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|cpp_token
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|b
operator|->
name|type
operator|&&
name|a
operator|->
name|flags
operator|==
name|b
operator|->
name|flags
condition|)
switch|switch
condition|(
name|TOKEN_SPELL
argument_list|(
name|a
argument_list|)
condition|)
block|{
default|default:
comment|/* Keep compiler happy.  */
case|case
name|SPELL_OPERATOR
case|:
return|return
literal|1
return|;
case|case
name|SPELL_CHAR
case|:
return|return
name|a
operator|->
name|val
operator|.
name|c
operator|==
name|b
operator|->
name|val
operator|.
name|c
return|;
comment|/* Character.  */
case|case
name|SPELL_NONE
case|:
return|return
operator|(
name|a
operator|->
name|type
operator|!=
name|CPP_MACRO_ARG
operator|||
name|a
operator|->
name|val
operator|.
name|arg_no
operator|==
name|b
operator|->
name|val
operator|.
name|arg_no
operator|)
return|;
case|case
name|SPELL_IDENT
case|:
return|return
name|a
operator|->
name|val
operator|.
name|node
operator|==
name|b
operator|->
name|val
operator|.
name|node
return|;
case|case
name|SPELL_NUMBER
case|:
case|case
name|SPELL_STRING
case|:
return|return
operator|(
name|a
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|==
name|b
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|a
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|b
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|a
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Returns nonzero if a space should be inserted to avoid an    accidental token paste for output.  For simplicity, it is    conservative, and occasionally advises a space where one is not    needed, e.g. "." and ".2".  */
end_comment

begin_function
name|int
name|cpp_avoid_paste
parameter_list|(
name|pfile
parameter_list|,
name|token1
parameter_list|,
name|token2
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token1
decl_stmt|,
decl|*
name|token2
decl_stmt|;
end_function

begin_block
block|{
name|enum
name|cpp_ttype
name|a
init|=
name|token1
operator|->
name|type
decl_stmt|,
name|b
init|=
name|token2
operator|->
name|type
decl_stmt|;
name|cppchar_t
name|c
decl_stmt|;
if|if
condition|(
name|token1
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
name|a
operator|=
name|CPP_NAME
expr_stmt|;
if|if
condition|(
name|token2
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
name|b
operator|=
name|CPP_NAME
expr_stmt|;
name|c
operator|=
name|EOF
expr_stmt|;
if|if
condition|(
name|token2
operator|->
name|flags
operator|&
name|DIGRAPH
condition|)
name|c
operator|=
name|digraph_spellings
index|[
operator|(
name|int
operator|)
name|b
operator|-
operator|(
name|int
operator|)
name|CPP_FIRST_DIGRAPH
index|]
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|token_spellings
index|[
name|b
index|]
operator|.
name|category
operator|==
name|SPELL_OPERATOR
condition|)
name|c
operator|=
name|token_spellings
index|[
name|b
index|]
operator|.
name|name
index|[
literal|0
index|]
expr_stmt|;
comment|/* Quickly get everything that can paste with an '='.  */
if|if
condition|(
operator|(
name|int
operator|)
name|a
operator|<=
operator|(
name|int
operator|)
name|CPP_LAST_EQ
operator|&&
name|c
operator|==
literal|'='
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|a
condition|)
block|{
case|case
name|CPP_GREATER
case|:
return|return
name|c
operator|==
literal|'>'
operator|||
name|c
operator|==
literal|'?'
return|;
case|case
name|CPP_LESS
case|:
return|return
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'?'
operator|||
name|c
operator|==
literal|'%'
operator|||
name|c
operator|==
literal|':'
return|;
case|case
name|CPP_PLUS
case|:
return|return
name|c
operator|==
literal|'+'
return|;
case|case
name|CPP_MINUS
case|:
return|return
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'>'
return|;
case|case
name|CPP_DIV
case|:
return|return
name|c
operator|==
literal|'/'
operator|||
name|c
operator|==
literal|'*'
return|;
comment|/* Comments.  */
case|case
name|CPP_MOD
case|:
return|return
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|'>'
return|;
case|case
name|CPP_AND
case|:
return|return
name|c
operator|==
literal|'&'
return|;
case|case
name|CPP_OR
case|:
return|return
name|c
operator|==
literal|'|'
return|;
case|case
name|CPP_COLON
case|:
return|return
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|'>'
return|;
case|case
name|CPP_DEREF
case|:
return|return
name|c
operator|==
literal|'*'
return|;
case|case
name|CPP_DOT
case|:
return|return
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'%'
operator|||
name|b
operator|==
name|CPP_NUMBER
return|;
case|case
name|CPP_HASH
case|:
return|return
name|c
operator|==
literal|'#'
operator|||
name|c
operator|==
literal|'%'
return|;
comment|/* Digraph form.  */
case|case
name|CPP_NAME
case|:
return|return
operator|(
operator|(
name|b
operator|==
name|CPP_NUMBER
operator|&&
name|name_p
argument_list|(
name|pfile
argument_list|,
operator|&
name|token2
operator|->
name|val
operator|.
name|str
argument_list|)
operator|)
operator|||
name|b
operator|==
name|CPP_NAME
operator|||
name|b
operator|==
name|CPP_CHAR
operator|||
name|b
operator|==
name|CPP_STRING
operator|)
return|;
comment|/* L */
case|case
name|CPP_NUMBER
case|:
return|return
operator|(
name|b
operator|==
name|CPP_NUMBER
operator|||
name|b
operator|==
name|CPP_NAME
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
operator|)
return|;
case|case
name|CPP_OTHER
case|:
return|return
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|objc
argument_list|)
operator|&&
name|token1
operator|->
name|val
operator|.
name|c
operator|==
literal|'@'
operator|&&
operator|(
name|b
operator|==
name|CPP_NAME
operator|||
name|b
operator|==
name|CPP_STRING
operator|)
operator|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Output all the remaining tokens on the current line, and a newline    character, to FP.  Leading whitespace is removed.  If there are    macros, special token padding is not performed.  */
end_comment

begin_function
name|void
name|cpp_output_line
parameter_list|(
name|pfile
parameter_list|,
name|fp
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|cpp_output_token
argument_list|(
name|token
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the value of a hexadecimal digit.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hex_digit_value
parameter_list|(
name|c
parameter_list|)
name|unsigned
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|hex_p
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|hex_value
argument_list|(
name|c
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a '\uNNNN' or '\UNNNNNNNN' sequence.  Returns 1 to indicate    failure if cpplib is not parsing C++ or C99.  Such failure is    silent, and no variables are updated.  Otherwise returns 0, and    warns if -Wtraditional.     [lex.charset]: The character designated by the universal character    name \UNNNNNNNN is that character whose character short name in    ISO/IEC 10646 is NNNNNNNN; the character designated by the    universal character name \uNNNN is that character whose character    short name in ISO/IEC 10646 is 0000NNNN.  If the hexadecimal value    for a universal character name is less than 0x20 or in the range    0x7F-0x9F (inclusive), or if the universal character name    designates a character in the basic source character set, then the    program is ill-formed.     We assume that wchar_t is Unicode, so we don't need to do any    mapping.  Is this ever wrong?     PC points to the 'u' or 'U', PSTR is points to the byte after PC,    LIMIT is the end of the string or charconst.  PSTR is updated to    point after the UCS on return, and the UCS is written into PC.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_read_ucs
parameter_list|(
name|pfile
parameter_list|,
name|pstr
parameter_list|,
name|limit
parameter_list|,
name|pc
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|pstr
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|limit
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pc
decl_stmt|;
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|*
name|pstr
decl_stmt|;
name|unsigned
name|int
name|code
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|c
init|=
operator|*
name|pc
decl_stmt|,
name|length
decl_stmt|;
comment|/* Only attempt to interpret a UCS for C++ and C99.  */
if|if
condition|(
operator|!
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|||
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"the meaning of '\\%c' varies with -traditional"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|c
operator|==
literal|'u'
condition|?
literal|4
else|:
literal|8
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|limit
operator|-
name|p
argument_list|)
operator|<
name|length
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"incomplete universal-character-name"
argument_list|)
expr_stmt|;
comment|/* Skip to the end to avoid more diagnostics.  */
name|p
operator|=
name|limit
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|length
condition|;
name|length
operator|--
operator|,
name|p
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|code
operator|=
operator|(
name|code
operator|<<
literal|4
operator|)
operator|+
name|hex_digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"non-hex digit '%c' in universal-character-name"
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* We shouldn't skip in case there are multibyte chars.  */
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|TARGET_EBCDIC
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"universal-character-name on EBCDIC target"
argument_list|)
expr_stmt|;
name|code
operator|=
literal|0x3f
expr_stmt|;
comment|/* EBCDIC invalid character */
else|#
directive|else
comment|/* True extended characters are OK.  */
if|if
condition|(
name|code
operator|>=
literal|0xa0
operator|&&
operator|!
operator|(
name|code
operator|&
literal|0x80000000
operator|)
operator|&&
operator|!
operator|(
name|code
operator|>=
literal|0xD800
operator|&&
name|code
operator|<=
literal|0xDFFF
operator|)
condition|)
empty_stmt|;
comment|/* The standard permits $, @ and ` to be specified as UCNs.  We use      hex escapes so that this also works with EBCDIC hosts.  */
elseif|else
if|if
condition|(
name|code
operator|==
literal|0x24
operator|||
name|code
operator|==
literal|0x40
operator|||
name|code
operator|==
literal|0x60
condition|)
empty_stmt|;
comment|/* Don't give another error if one occurred above.  */
elseif|else
if|if
condition|(
name|length
operator|==
literal|0
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"universal-character-name out of range"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|pstr
operator|=
name|p
expr_stmt|;
operator|*
name|pc
operator|=
name|code
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Interpret an escape sequence, and return its value.  PSTR points to    the input pointer, which is just after the backslash.  LIMIT is how    much text we have.  MASK is a bitmask for the precision for the    destination type (char or wchar_t).  TRADITIONAL, if true, does not    interpret escapes that did not exist in traditional C.     Handles all relevant diagnostics.  */
end_comment

begin_function
name|unsigned
name|int
name|cpp_parse_escape
parameter_list|(
name|pfile
parameter_list|,
name|pstr
parameter_list|,
name|limit
parameter_list|,
name|mask
parameter_list|,
name|traditional
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|pstr
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|limit
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|int
name|traditional
decl_stmt|;
block|{
name|int
name|unknown
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|str
init|=
operator|*
name|pstr
decl_stmt|;
name|unsigned
name|int
name|c
init|=
operator|*
name|str
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
case|case
literal|'?'
case|:
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
name|TARGET_BS
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
name|TARGET_FF
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
name|TARGET_NEWLINE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
name|TARGET_CR
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
name|TARGET_TAB
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|c
operator|=
name|TARGET_VT
expr_stmt|;
break|break;
case|case
literal|'('
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
case|case
literal|'%'
case|:
comment|/* '\(', etc, are used at beginning of line to avoid confusing Emacs. 	 '\%' is used to prevent SCCS from getting confused.  */
name|unknown
operator|=
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"the meaning of '\\a' varies with -traditional"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
name|c
operator|=
name|TARGET_BELL
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"non-ISO-standard escape sequence, '\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|TARGET_ESC
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
name|unknown
operator|=
name|maybe_read_ucs
argument_list|(
name|pfile
argument_list|,
operator|&
name|str
argument_list|,
name|limit
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"the meaning of '\\x' varies with -traditional"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|,
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|digits_found
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|str
operator|<
name|limit
condition|)
block|{
name|c
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|str
operator|++
expr_stmt|;
name|overflow
operator||=
name|i
operator|^
operator|(
name|i
operator|<<
literal|4
operator|>>
literal|4
operator|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|<<
literal|4
operator|)
operator|+
name|hex_digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|digits_found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|digits_found
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"\\x used with no following hex digits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflow
operator||
operator|(
name|i
operator|!=
operator|(
name|i
operator|&
name|mask
operator|)
operator|)
condition|)
block|{
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"hex escape sequence out of range"
argument_list|)
expr_stmt|;
name|i
operator|&=
name|mask
expr_stmt|;
block|}
name|c
operator|=
name|i
expr_stmt|;
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
name|unsigned
name|int
name|i
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|str
operator|<
name|limit
operator|&&
operator|++
name|count
operator|<
literal|3
condition|)
block|{
name|c
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'7'
condition|)
break|break;
name|str
operator|++
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|<<
literal|3
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
operator|(
name|i
operator|&
name|mask
operator|)
condition|)
block|{
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"octal escape sequence out of range"
argument_list|)
expr_stmt|;
name|i
operator|&=
name|mask
expr_stmt|;
block|}
name|c
operator|=
name|i
expr_stmt|;
block|}
break|break;
default|default:
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|unknown
condition|)
block|{
if|if
condition|(
name|ISGRAPH
argument_list|(
name|c
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"unknown escape sequence '\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"unknown escape sequence: '\\%03o'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
name|mask
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
operator|*
name|pstr
operator|=
name|str
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_CHAR_TYPE_SIZE
value|CHAR_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_WCHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_WCHAR_TYPE_SIZE
value|WCHAR_TYPE_SIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Interpret a (possibly wide) character constant in TOKEN.    WARN_MULTI warns about multi-character charconsts, if not    TRADITIONAL.  TRADITIONAL also indicates not to interpret escapes    that did not exist in traditional C.  PCHARS_SEEN points to a    variable that is filled in with the number of characters seen.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|cpp_interpret_charconst
parameter_list|(
name|pfile
parameter_list|,
name|token
parameter_list|,
name|warn_multi
parameter_list|,
name|traditional
parameter_list|,
name|pchars_seen
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|int
name|warn_multi
decl_stmt|;
name|int
name|traditional
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pchars_seen
decl_stmt|;
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|str
init|=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|limit
init|=
name|str
operator|+
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
decl_stmt|;
name|unsigned
name|int
name|chars_seen
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|,
name|max_chars
decl_stmt|,
name|c
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|HOST_WIDE_INT
name|result
init|=
literal|0
decl_stmt|;
name|bool
name|unsigned_p
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
operator|(
name|void
operator|)
name|local_mbtowc
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Width in bits.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CHAR
condition|)
block|{
name|width
operator|=
name|MAX_CHAR_TYPE_SIZE
expr_stmt|;
name|unsigned_p
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|signed_char
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
else|else
block|{
name|width
operator|=
name|MAX_WCHAR_TYPE_SIZE
expr_stmt|;
name|unsigned_p
operator|=
name|WCHAR_UNSIGNED
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|mask
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
operator|~
literal|0
expr_stmt|;
name|max_chars
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|/
name|width
expr_stmt|;
while|while
condition|(
name|str
operator|<
name|limit
condition|)
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|wchar_t
name|wc
decl_stmt|;
name|int
name|char_len
decl_stmt|;
name|char_len
operator|=
name|local_mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|str
argument_list|,
name|limit
operator|-
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_len
operator|==
operator|-
literal|1
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"ignoring invalid multibyte character"
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
else|else
block|{
name|str
operator|+=
name|char_len
expr_stmt|;
name|c
operator|=
name|wc
expr_stmt|;
block|}
else|#
directive|else
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|cpp_parse_escape
argument_list|(
name|pfile
argument_list|,
operator|&
name|str
argument_list|,
name|limit
argument_list|,
name|mask
argument_list|,
name|traditional
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAP_CHARACTER
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|MAP_CHARACTER
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Merge character into result; ignore excess chars.  */
if|if
condition|(
operator|++
name|chars_seen
operator|<=
name|max_chars
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|result
operator|=
operator|(
name|result
operator|<<
name|width
operator|)
operator||
operator|(
name|c
operator|&
name|mask
operator|)
expr_stmt|;
else|else
name|result
operator|=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chars_seen
operator|==
literal|0
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"empty character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chars_seen
operator|>
name|max_chars
condition|)
block|{
name|chars_seen
operator|=
name|max_chars
expr_stmt|;
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"character constant too long"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chars_seen
operator|>
literal|1
operator|&&
operator|!
name|traditional
operator|&&
name|warn_multi
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"multi-character character constant"
argument_list|)
expr_stmt|;
comment|/* If relevant type is signed, sign-extend the constant.  */
if|if
condition|(
name|chars_seen
condition|)
block|{
name|unsigned
name|int
name|nbits
init|=
name|chars_seen
operator|*
name|width
decl_stmt|;
name|mask
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|nbits
operator|)
expr_stmt|;
if|if
condition|(
name|unsigned_p
operator|||
operator|(
operator|(
name|result
operator|>>
operator|(
name|nbits
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|result
operator|&=
name|mask
expr_stmt|;
else|else
name|result
operator||=
operator|~
name|mask
expr_stmt|;
block|}
operator|*
name|pchars_seen
operator|=
name|chars_seen
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Memory buffers.  Changing these three constants can have a dramatic    effect on performance.  The values here are reasonable defaults,    but might be tuned.  If you adjust them, be sure to test across a    range of uses of cpplib, including heavy nested function-like macro    expansion.  Also check the change in peak memory usage (NJAMD is a    good tool for this).  */
end_comment

begin_define
define|#
directive|define
name|MIN_BUFF_SIZE
value|8000
end_define

begin_define
define|#
directive|define
name|BUFF_SIZE_UPPER_BOUND
parameter_list|(
name|MIN_SIZE
parameter_list|)
value|(MIN_BUFF_SIZE + (MIN_SIZE) * 3 / 2)
end_define

begin_define
define|#
directive|define
name|EXTENDED_BUFF_SIZE
parameter_list|(
name|BUFF
parameter_list|,
name|MIN_EXTRA
parameter_list|)
define|\
value|(MIN_EXTRA + ((BUFF)->limit - (BUFF)->cur) * 2)
end_define

begin_if
if|#
directive|if
name|MIN_BUFF_SIZE
operator|>
name|BUFF_SIZE_UPPER_BOUND
argument_list|(
literal|0
argument_list|)
end_if

begin_error
error|#
directive|error
error|BUFF_SIZE_UPPER_BOUND must be at least as large as MIN_BUFF_SIZE!
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|dummy
block|{
name|char
name|c
decl_stmt|;
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEFAULT_ALIGNMENT
value|(offsetof (struct dummy, u))
end_define

begin_define
define|#
directive|define
name|CPP_ALIGN
parameter_list|(
name|size
parameter_list|,
name|align
parameter_list|)
value|(((size) + ((align) - 1))& ~((align) - 1))
end_define

begin_comment
comment|/* Create a new allocation buffer.  Place the control block at the end    of the buffer, so that buffer overflows will cause immediate chaos.  */
end_comment

begin_function
specifier|static
name|_cpp_buff
modifier|*
name|new_buff
parameter_list|(
name|len
parameter_list|)
name|size_t
name|len
decl_stmt|;
block|{
name|_cpp_buff
modifier|*
name|result
decl_stmt|;
name|unsigned
name|char
modifier|*
name|base
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|MIN_BUFF_SIZE
condition|)
name|len
operator|=
name|MIN_BUFF_SIZE
expr_stmt|;
name|len
operator|=
name|CPP_ALIGN
argument_list|(
name|len
argument_list|,
name|DEFAULT_ALIGNMENT
argument_list|)
expr_stmt|;
name|base
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
name|_cpp_buff
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|_cpp_buff
operator|*
operator|)
operator|(
name|base
operator|+
name|len
operator|)
expr_stmt|;
name|result
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|result
operator|->
name|cur
operator|=
name|base
expr_stmt|;
name|result
operator|->
name|limit
operator|=
name|base
operator|+
name|len
expr_stmt|;
name|result
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Place a chain of unwanted allocation buffers on the free list.  */
end_comment

begin_function
name|void
name|_cpp_release_buff
parameter_list|(
name|pfile
parameter_list|,
name|buff
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|_cpp_buff
modifier|*
name|buff
decl_stmt|;
block|{
name|_cpp_buff
modifier|*
name|end
init|=
name|buff
decl_stmt|;
while|while
condition|(
name|end
operator|->
name|next
condition|)
name|end
operator|=
name|end
operator|->
name|next
expr_stmt|;
name|end
operator|->
name|next
operator|=
name|pfile
operator|->
name|free_buffs
expr_stmt|;
name|pfile
operator|->
name|free_buffs
operator|=
name|buff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a free buffer of size at least MIN_SIZE.  */
end_comment

begin_function
name|_cpp_buff
modifier|*
name|_cpp_get_buff
parameter_list|(
name|pfile
parameter_list|,
name|min_size
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|size_t
name|min_size
decl_stmt|;
block|{
name|_cpp_buff
modifier|*
name|result
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|pfile
operator|->
name|free_buffs
init|;
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
block|{
name|size_t
name|size
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
return|return
name|new_buff
argument_list|(
name|min_size
argument_list|)
return|;
name|result
operator|=
operator|*
name|p
expr_stmt|;
name|size
operator|=
name|result
operator|->
name|limit
operator|-
name|result
operator|->
name|base
expr_stmt|;
comment|/* Return a buffer that's big enough, but don't waste one that's          way too big.  */
if|if
condition|(
name|size
operator|>=
name|min_size
operator|&&
name|size
operator|<=
name|BUFF_SIZE_UPPER_BOUND
argument_list|(
name|min_size
argument_list|)
condition|)
break|break;
block|}
operator|*
name|p
operator|=
name|result
operator|->
name|next
expr_stmt|;
name|result
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|cur
operator|=
name|result
operator|->
name|base
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Creates a new buffer with enough space to hold the uncommitted    remaining bytes of BUFF, and at least MIN_EXTRA more bytes.  Copies    the excess bytes to the new buffer.  Chains the new buffer after    BUFF, and returns the new buffer.  */
end_comment

begin_function
name|_cpp_buff
modifier|*
name|_cpp_append_extend_buff
parameter_list|(
name|pfile
parameter_list|,
name|buff
parameter_list|,
name|min_extra
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|_cpp_buff
modifier|*
name|buff
decl_stmt|;
name|size_t
name|min_extra
decl_stmt|;
block|{
name|size_t
name|size
init|=
name|EXTENDED_BUFF_SIZE
argument_list|(
name|buff
argument_list|,
name|min_extra
argument_list|)
decl_stmt|;
name|_cpp_buff
modifier|*
name|new_buff
init|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|buff
operator|->
name|next
operator|=
name|new_buff
expr_stmt|;
name|memcpy
argument_list|(
name|new_buff
operator|->
name|base
argument_list|,
name|buff
operator|->
name|cur
argument_list|,
name|BUFF_ROOM
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_buff
return|;
block|}
end_function

begin_comment
comment|/* Creates a new buffer with enough space to hold the uncommitted    remaining bytes of the buffer pointed to by BUFF, and at least    MIN_EXTRA more bytes.  Copies the excess bytes to the new buffer.    Chains the new buffer before the buffer pointed to by BUFF, and    updates the pointer to point to the new buffer.  */
end_comment

begin_function
name|void
name|_cpp_extend_buff
parameter_list|(
name|pfile
parameter_list|,
name|pbuff
parameter_list|,
name|min_extra
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|_cpp_buff
modifier|*
modifier|*
name|pbuff
decl_stmt|;
name|size_t
name|min_extra
decl_stmt|;
block|{
name|_cpp_buff
modifier|*
name|new_buff
decl_stmt|,
modifier|*
name|old_buff
init|=
operator|*
name|pbuff
decl_stmt|;
name|size_t
name|size
init|=
name|EXTENDED_BUFF_SIZE
argument_list|(
name|old_buff
argument_list|,
name|min_extra
argument_list|)
decl_stmt|;
name|new_buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_buff
operator|->
name|base
argument_list|,
name|old_buff
operator|->
name|cur
argument_list|,
name|BUFF_ROOM
argument_list|(
name|old_buff
argument_list|)
argument_list|)
expr_stmt|;
name|new_buff
operator|->
name|next
operator|=
name|old_buff
expr_stmt|;
operator|*
name|pbuff
operator|=
name|new_buff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free a chain of buffers starting at BUFF.  */
end_comment

begin_function
name|void
name|_cpp_free_buff
parameter_list|(
name|buff
parameter_list|)
name|_cpp_buff
modifier|*
name|buff
decl_stmt|;
block|{
name|_cpp_buff
modifier|*
name|next
decl_stmt|;
for|for
control|(
init|;
name|buff
condition|;
name|buff
operator|=
name|next
control|)
block|{
name|next
operator|=
name|buff
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|buff
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate permanent, unaligned storage of length LEN.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|_cpp_unaligned_alloc
parameter_list|(
name|pfile
parameter_list|,
name|len
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|_cpp_buff
modifier|*
name|buff
init|=
name|pfile
operator|->
name|u_buff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|result
init|=
name|buff
operator|->
name|cur
decl_stmt|;
if|if
condition|(
name|len
operator|>
call|(
name|size_t
call|)
argument_list|(
name|buff
operator|->
name|limit
operator|-
name|result
argument_list|)
condition|)
block|{
name|buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buff
operator|->
name|next
operator|=
name|pfile
operator|->
name|u_buff
expr_stmt|;
name|pfile
operator|->
name|u_buff
operator|=
name|buff
expr_stmt|;
name|result
operator|=
name|buff
operator|->
name|cur
expr_stmt|;
block|}
name|buff
operator|->
name|cur
operator|=
name|result
operator|+
name|len
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Allocate permanent, unaligned storage of length LEN from a_buff.    That buffer is used for growing allocations when saving macro    replacement lists in a #define, and when parsing an answer to an    assertion in #assert, #unassert or #if (and therefore possibly    whilst expanding macros).  It therefore must not be used by any    code that they might call: specifically the lexer and the guts of    the macro expander.     All existing other uses clearly fit this restriction: storing    registered pragmas during initialization.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|_cpp_aligned_alloc
parameter_list|(
name|pfile
parameter_list|,
name|len
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|_cpp_buff
modifier|*
name|buff
init|=
name|pfile
operator|->
name|a_buff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|result
init|=
name|buff
operator|->
name|cur
decl_stmt|;
if|if
condition|(
name|len
operator|>
call|(
name|size_t
call|)
argument_list|(
name|buff
operator|->
name|limit
operator|-
name|result
argument_list|)
condition|)
block|{
name|buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buff
operator|->
name|next
operator|=
name|pfile
operator|->
name|a_buff
expr_stmt|;
name|pfile
operator|->
name|a_buff
operator|=
name|buff
expr_stmt|;
name|result
operator|=
name|buff
operator|->
name|cur
expr_stmt|;
block|}
name|buff
operator|->
name|cur
operator|=
name|result
operator|+
name|len
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

