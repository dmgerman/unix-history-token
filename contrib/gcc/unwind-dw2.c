begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF2 exception handling and frame unwind runtime interface routines.    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_include
include|#
directive|include
file|"unwind-pe.h"
end_include

begin_include
include|#
directive|include
file|"unwind-dw2-fde.h"
end_include

begin_include
include|#
directive|include
file|"gthr.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__USING_SJLJ_EXCEPTIONS__
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
end_ifndef

begin_define
define|#
directive|define
name|STACK_GROWS_DOWNWARD
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|STACK_GROWS_DOWNWARD
end_undef

begin_define
define|#
directive|define
name|STACK_GROWS_DOWNWARD
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A target can override (perhaps for backward compatibility) how    many dwarf2 columns are unwound.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_FRAME_REGISTERS
end_ifndef

begin_define
define|#
directive|define
name|DWARF_FRAME_REGISTERS
value|FIRST_PSEUDO_REGISTER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Dwarf frame registers used for pre gcc 3.0 compiled glibc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PRE_GCC3_DWARF_FRAME_REGISTERS
end_ifndef

begin_define
define|#
directive|define
name|PRE_GCC3_DWARF_FRAME_REGISTERS
value|DWARF_FRAME_REGISTERS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the register and unwind state for a particular frame.  */
end_comment

begin_struct
struct|struct
name|_Unwind_Context
block|{
name|void
modifier|*
name|reg
index|[
name|DWARF_FRAME_REGISTERS
operator|+
literal|1
index|]
decl_stmt|;
name|void
modifier|*
name|cfa
decl_stmt|;
name|void
modifier|*
name|ra
decl_stmt|;
name|void
modifier|*
name|lsda
decl_stmt|;
name|struct
name|dwarf_eh_bases
name|bases
decl_stmt|;
name|_Unwind_Word
name|args_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Byte size of every register managed by these routines.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|dwarf_reg_size_table
index|[
name|DWARF_FRAME_REGISTERS
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The result of interpreting the frame unwind info for a frame.    This is all symbolic at this point, as none of the values can    be resolved until the target pc is located.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Each register save state can be described in terms of a CFA slot,      another register, or a location expression.  */
struct|struct
name|frame_state_reg_info
block|{
struct|struct
block|{
union|union
block|{
name|_Unwind_Word
name|reg
decl_stmt|;
name|_Unwind_Sword
name|offset
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|exp
decl_stmt|;
block|}
name|loc
union|;
enum|enum
block|{
name|REG_UNSAVED
block|,
name|REG_SAVED_OFFSET
block|,
name|REG_SAVED_REG
block|,
name|REG_SAVED_EXP
block|,       }
name|how
enum|;
block|}
name|reg
index|[
name|DWARF_FRAME_REGISTERS
operator|+
literal|1
index|]
struct|;
comment|/* Used to implement DW_CFA_remember_state.  */
name|struct
name|frame_state_reg_info
modifier|*
name|prev
decl_stmt|;
block|}
name|regs
struct|;
comment|/* The CFA can be described in terms of a reg+offset or a      location expression.  */
name|_Unwind_Sword
name|cfa_offset
decl_stmt|;
name|_Unwind_Word
name|cfa_reg
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|cfa_exp
decl_stmt|;
enum|enum
block|{
name|CFA_UNSET
block|,
name|CFA_REG_OFFSET
block|,
name|CFA_EXP
block|,   }
name|cfa_how
enum|;
comment|/* The PC described by the current frame state.  */
name|void
modifier|*
name|pc
decl_stmt|;
comment|/* The information we care about from the CIE/FDE.  */
name|_Unwind_Personality_Fn
name|personality
decl_stmt|;
name|_Unwind_Sword
name|data_align
decl_stmt|;
name|_Unwind_Word
name|code_align
decl_stmt|;
name|unsigned
name|char
name|retaddr_column
decl_stmt|;
name|unsigned
name|char
name|fde_encoding
decl_stmt|;
name|unsigned
name|char
name|lsda_encoding
decl_stmt|;
name|unsigned
name|char
name|saw_z
decl_stmt|;
name|void
modifier|*
name|eh_ptr
decl_stmt|;
block|}
name|_Unwind_FrameState
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Read unaligned data from the instruction buffer.  */
end_comment

begin_union
union|union
name|unaligned
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|unsigned
name|u2
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|HI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|u4
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|SI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|u8
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|DI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|signed
name|s2
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|HI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|signed
name|s4
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|SI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|signed
name|s8
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|DI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
union|;
end_union

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|read_pointer
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|read_1u
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|read_1s
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|signed
name|char
operator|*
operator|)
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|read_2u
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|u2
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|read_2s
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|s2
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|read_4u
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|u4
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|read_4s
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|s4
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|read_8u
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|u8
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|read_8s
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|s8
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the value of register REG as saved in CONTEXT.  */
end_comment

begin_function
specifier|inline
name|_Unwind_Word
name|_Unwind_GetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|)
block|{
comment|/* This will segfault if the register hasn't been saved.  */
return|return
operator|*
operator|(
name|_Unwind_Word
operator|*
operator|)
name|context
operator|->
name|reg
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Overwrite the saved value for register REG in CONTEXT with VAL.  */
end_comment

begin_function
specifier|inline
name|void
name|_Unwind_SetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|,
name|_Unwind_Word
name|val
parameter_list|)
block|{
operator|*
operator|(
name|_Unwind_Word
operator|*
operator|)
name|context
operator|->
name|reg
index|[
name|index
index|]
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve the return address for CONTEXT.  */
end_comment

begin_function
specifier|inline
name|_Unwind_Ptr
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|ra
return|;
block|}
end_function

begin_comment
comment|/* Overwrite the return address for CONTEXT with VAL.  */
end_comment

begin_function
specifier|inline
name|void
name|_Unwind_SetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_Ptr
name|val
parameter_list|)
block|{
name|context
operator|->
name|ra
operator|=
operator|(
name|void
operator|*
operator|)
name|val
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|_Unwind_GetLanguageSpecificData
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|context
operator|->
name|lsda
return|;
block|}
end_function

begin_function
name|_Unwind_Ptr
name|_Unwind_GetRegionStart
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|bases
operator|.
name|func
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__ia64__
end_ifndef

begin_function
name|_Unwind_Ptr
name|_Unwind_GetDataRelBase
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|bases
operator|.
name|dbase
return|;
block|}
end_function

begin_function
name|_Unwind_Ptr
name|_Unwind_GetTextRelBase
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|bases
operator|.
name|tbase
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Extract any interesting information from the CIE for the translation    unit F belongs to.  Return a pointer to the byte after the augmentation,    or NULL if we encountered an undecipherable augmentation.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|extract_cie_info
parameter_list|(
name|struct
name|dwarf_cie
modifier|*
name|cie
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|aug
init|=
name|cie
operator|->
name|augmentation
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|aug
operator|+
name|strlen
argument_list|(
name|aug
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|_Unwind_Word
name|utmp
decl_stmt|;
comment|/* g++ v2 "eh" has pointer immediately following augmentation string,      so it must be handled first.  */
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|aug
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
name|fs
operator|->
name|eh_ptr
operator|=
name|read_pointer
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
name|aug
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Immediately following the augmentation are the code and      data alignment and return address column.  */
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|fs
operator|->
name|code_align
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_sleb128
argument_list|(
name|p
argument_list|,
operator|&
name|fs
operator|->
name|data_align
argument_list|)
expr_stmt|;
name|fs
operator|->
name|retaddr_column
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|fs
operator|->
name|lsda_encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
comment|/* If the augmentation starts with 'z', then a uleb128 immediately      follows containing the length of the augmentation field following      the size.  */
if|if
condition|(
operator|*
name|aug
operator|==
literal|'z'
condition|)
block|{
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|p
operator|+
name|utmp
expr_stmt|;
name|fs
operator|->
name|saw_z
operator|=
literal|1
expr_stmt|;
operator|++
name|aug
expr_stmt|;
block|}
comment|/* Iterate over recognized augmentation subsequences.  */
while|while
condition|(
operator|*
name|aug
operator|!=
literal|'\0'
condition|)
block|{
comment|/* "L" indicates a byte showing how the LSDA pointer is encoded.  */
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
block|{
name|fs
operator|->
name|lsda_encoding
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|aug
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* "R" indicates a byte indicating how FDE addresses are encoded.  */
elseif|else
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'R'
condition|)
block|{
name|fs
operator|->
name|fde_encoding
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|aug
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* "P" indicates a personality routine in the CIE augmentation.  */
elseif|else
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'P'
condition|)
block|{
name|p
operator|=
name|read_encoded_value
argument_list|(
name|context
argument_list|,
operator|*
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|,
operator|(
name|_Unwind_Ptr
operator|*
operator|)
operator|&
name|fs
operator|->
name|personality
argument_list|)
expr_stmt|;
name|aug
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Otherwise we have an unknown augmentation string. 	 Bail unless we saw a 'z' prefix.  */
else|else
return|return
name|ret
return|;
block|}
return|return
name|ret
condition|?
name|ret
else|:
name|p
return|;
block|}
end_function

begin_comment
comment|/* Decode a DW_OP stack program.  Return the top of stack.  Push INITIAL    onto the stack to start.  */
end_comment

begin_function
specifier|static
name|_Unwind_Word
name|execute_stack_op
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|op_ptr
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|op_end
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_Word
name|initial
parameter_list|)
block|{
name|_Unwind_Word
name|stack
index|[
literal|64
index|]
decl_stmt|;
comment|/* ??? Assume this is enough.  */
name|int
name|stack_elt
decl_stmt|;
name|stack
index|[
literal|0
index|]
operator|=
name|initial
expr_stmt|;
name|stack_elt
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|op_ptr
operator|<
name|op_end
condition|)
block|{
name|enum
name|dwarf_location_atom
name|op
init|=
operator|*
name|op_ptr
operator|++
decl_stmt|;
name|_Unwind_Word
name|result
decl_stmt|,
name|reg
decl_stmt|,
name|utmp
decl_stmt|;
name|_Unwind_Sword
name|offset
decl_stmt|,
name|stmp
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_lit0
case|:
case|case
name|DW_OP_lit1
case|:
case|case
name|DW_OP_lit2
case|:
case|case
name|DW_OP_lit3
case|:
case|case
name|DW_OP_lit4
case|:
case|case
name|DW_OP_lit5
case|:
case|case
name|DW_OP_lit6
case|:
case|case
name|DW_OP_lit7
case|:
case|case
name|DW_OP_lit8
case|:
case|case
name|DW_OP_lit9
case|:
case|case
name|DW_OP_lit10
case|:
case|case
name|DW_OP_lit11
case|:
case|case
name|DW_OP_lit12
case|:
case|case
name|DW_OP_lit13
case|:
case|case
name|DW_OP_lit14
case|:
case|case
name|DW_OP_lit15
case|:
case|case
name|DW_OP_lit16
case|:
case|case
name|DW_OP_lit17
case|:
case|case
name|DW_OP_lit18
case|:
case|case
name|DW_OP_lit19
case|:
case|case
name|DW_OP_lit20
case|:
case|case
name|DW_OP_lit21
case|:
case|case
name|DW_OP_lit22
case|:
case|case
name|DW_OP_lit23
case|:
case|case
name|DW_OP_lit24
case|:
case|case
name|DW_OP_lit25
case|:
case|case
name|DW_OP_lit26
case|:
case|case
name|DW_OP_lit27
case|:
case|case
name|DW_OP_lit28
case|:
case|case
name|DW_OP_lit29
case|:
case|case
name|DW_OP_lit30
case|:
case|case
name|DW_OP_lit31
case|:
name|result
operator|=
name|op
operator|-
name|DW_OP_lit0
expr_stmt|;
break|break;
case|case
name|DW_OP_addr
case|:
name|result
operator|=
operator|(
name|_Unwind_Word
operator|)
operator|(
name|_Unwind_Ptr
operator|)
name|read_pointer
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
name|result
operator|=
name|read_1u
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const1s
case|:
name|result
operator|=
name|read_1s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
name|result
operator|=
name|read_2u
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const2s
case|:
name|result
operator|=
name|read_2s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
name|result
operator|=
name|read_4u
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const4s
case|:
name|result
operator|=
name|read_4s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
name|result
operator|=
name|read_8u
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_const8s
case|:
name|result
operator|=
name|read_8s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|op_ptr
operator|=
name|read_sleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|stmp
argument_list|)
expr_stmt|;
name|result
operator|=
name|stmp
expr_stmt|;
break|break;
case|case
name|DW_OP_reg0
case|:
case|case
name|DW_OP_reg1
case|:
case|case
name|DW_OP_reg2
case|:
case|case
name|DW_OP_reg3
case|:
case|case
name|DW_OP_reg4
case|:
case|case
name|DW_OP_reg5
case|:
case|case
name|DW_OP_reg6
case|:
case|case
name|DW_OP_reg7
case|:
case|case
name|DW_OP_reg8
case|:
case|case
name|DW_OP_reg9
case|:
case|case
name|DW_OP_reg10
case|:
case|case
name|DW_OP_reg11
case|:
case|case
name|DW_OP_reg12
case|:
case|case
name|DW_OP_reg13
case|:
case|case
name|DW_OP_reg14
case|:
case|case
name|DW_OP_reg15
case|:
case|case
name|DW_OP_reg16
case|:
case|case
name|DW_OP_reg17
case|:
case|case
name|DW_OP_reg18
case|:
case|case
name|DW_OP_reg19
case|:
case|case
name|DW_OP_reg20
case|:
case|case
name|DW_OP_reg21
case|:
case|case
name|DW_OP_reg22
case|:
case|case
name|DW_OP_reg23
case|:
case|case
name|DW_OP_reg24
case|:
case|case
name|DW_OP_reg25
case|:
case|case
name|DW_OP_reg26
case|:
case|case
name|DW_OP_reg27
case|:
case|case
name|DW_OP_reg28
case|:
case|case
name|DW_OP_reg29
case|:
case|case
name|DW_OP_reg30
case|:
case|case
name|DW_OP_reg31
case|:
name|result
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|op
operator|-
name|DW_OP_reg0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|result
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|op_ptr
operator|=
name|read_sleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|result
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|op
operator|-
name|DW_OP_breg0
argument_list|)
operator|+
name|offset
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|op_ptr
operator|=
name|read_sleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|result
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|reg
argument_list|)
operator|+
name|offset
expr_stmt|;
break|break;
case|case
name|DW_OP_dup
case|:
if|if
condition|(
name|stack_elt
operator|<
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|DW_OP_drop
case|:
if|if
condition|(
operator|--
name|stack_elt
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_pick
case|:
name|offset
operator|=
operator|*
name|op_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|stack_elt
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|1
operator|-
name|offset
index|]
expr_stmt|;
break|break;
case|case
name|DW_OP_over
case|:
if|if
condition|(
name|stack_elt
operator|<
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|DW_OP_rot
case|:
block|{
name|_Unwind_Word
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
if|if
condition|(
name|stack_elt
operator|<
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t1
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|1
index|]
expr_stmt|;
name|t2
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|2
index|]
expr_stmt|;
name|t3
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|3
index|]
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|-
literal|1
index|]
operator|=
name|t2
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|-
literal|2
index|]
operator|=
name|t3
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|-
literal|3
index|]
operator|=
name|t1
expr_stmt|;
goto|goto
name|no_push
goto|;
block|}
case|case
name|DW_OP_deref
case|:
case|case
name|DW_OP_deref_size
case|:
case|case
name|DW_OP_abs
case|:
case|case
name|DW_OP_neg
case|:
case|case
name|DW_OP_not
case|:
case|case
name|DW_OP_plus_uconst
case|:
comment|/* Unary operations.  */
if|if
condition|(
operator|--
name|stack_elt
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
index|]
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_deref
case|:
block|{
name|void
modifier|*
name|ptr
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|_Unwind_Ptr
operator|)
name|result
decl_stmt|;
name|result
operator|=
operator|(
name|_Unwind_Ptr
operator|)
name|read_pointer
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_deref_size
case|:
block|{
name|void
modifier|*
name|ptr
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|_Unwind_Ptr
operator|)
name|result
decl_stmt|;
switch|switch
condition|(
operator|*
name|op_ptr
operator|++
condition|)
block|{
case|case
literal|1
case|:
name|result
operator|=
name|read_1u
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|result
operator|=
name|read_2u
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|result
operator|=
name|read_4u
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|result
operator|=
name|read_8u
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_OP_abs
case|:
if|if
condition|(
operator|(
name|_Unwind_Sword
operator|)
name|result
operator|<
literal|0
condition|)
name|result
operator|=
operator|-
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_neg
case|:
name|result
operator|=
operator|-
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_not
case|:
name|result
operator|=
operator|~
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|result
operator|+=
name|utmp
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_and
case|:
case|case
name|DW_OP_div
case|:
case|case
name|DW_OP_minus
case|:
case|case
name|DW_OP_mod
case|:
case|case
name|DW_OP_mul
case|:
case|case
name|DW_OP_or
case|:
case|case
name|DW_OP_plus
case|:
case|case
name|DW_OP_le
case|:
case|case
name|DW_OP_ge
case|:
case|case
name|DW_OP_eq
case|:
case|case
name|DW_OP_lt
case|:
case|case
name|DW_OP_gt
case|:
case|case
name|DW_OP_ne
case|:
block|{
comment|/* Binary operations.  */
name|_Unwind_Word
name|first
decl_stmt|,
name|second
decl_stmt|;
if|if
condition|(
operator|(
name|stack_elt
operator|-=
literal|2
operator|)
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|second
operator|=
name|stack
index|[
name|stack_elt
index|]
expr_stmt|;
name|first
operator|=
name|stack
index|[
name|stack_elt
operator|+
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_and
case|:
name|result
operator|=
name|second
operator|&
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_div
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|second
operator|/
operator|(
name|_Unwind_Sword
operator|)
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_minus
case|:
name|result
operator|=
name|second
operator|-
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_mod
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|second
operator|%
operator|(
name|_Unwind_Sword
operator|)
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_mul
case|:
name|result
operator|=
name|second
operator|*
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_or
case|:
name|result
operator|=
name|second
operator||
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_plus
case|:
name|result
operator|=
name|second
operator|+
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_shl
case|:
name|result
operator|=
name|second
operator|<<
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_shr
case|:
name|result
operator|=
name|second
operator|>>
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_shra
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|second
operator|>>
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_xor
case|:
name|result
operator|=
name|second
operator|^
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_le
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|<=
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_ge
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|>=
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_eq
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|==
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_lt
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|<
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_gt
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|>
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_ne
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|!=
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_OP_skip
case|:
name|offset
operator|=
name|read_2s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
name|op_ptr
operator|+=
name|offset
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_bra
case|:
if|if
condition|(
operator|--
name|stack_elt
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
name|read_2s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|stack
index|[
name|stack_elt
index|]
operator|!=
literal|0
condition|)
name|op_ptr
operator|+=
name|offset
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_nop
case|:
goto|goto
name|no_push
goto|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Most things push a result value.  */
if|if
condition|(
operator|(
name|size_t
operator|)
name|stack_elt
operator|>=
sizeof|sizeof
argument_list|(
name|stack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|stack
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stack
index|[
operator|++
name|stack_elt
index|]
operator|=
name|result
expr_stmt|;
name|no_push
label|:
empty_stmt|;
block|}
comment|/* We were executing this program to get a value.  It should be      at top of stack.  */
if|if
condition|(
operator|--
name|stack_elt
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|stack
index|[
name|stack_elt
index|]
return|;
block|}
end_function

begin_comment
comment|/* Decode DWARF 2 call frame information. Takes pointers the    instruction sequence to decode, current register information and    CIE info, and the PC range to evaluate.  */
end_comment

begin_function
specifier|static
name|void
name|execute_cfa_program
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|insn_ptr
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|insn_end
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|frame_state_reg_info
modifier|*
name|unused_rs
init|=
name|NULL
decl_stmt|;
comment|/* Don't allow remember/restore between CIE and FDE programs.  */
name|fs
operator|->
name|regs
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* The comparison with the return address uses< rather than<= because      we are only interested in the effects of code before the call; for a      noreturn function, the return address may point to unrelated code with      a different stack configuration that we are not interested in.  We      assume that the call itself is unwind info-neutral; if not, or if      there are delay instructions that adjust the stack, these must be      reflected at the point immediately before the call insn.  */
while|while
condition|(
name|insn_ptr
operator|<
name|insn_end
operator|&&
name|fs
operator|->
name|pc
operator|<
name|context
operator|->
name|ra
condition|)
block|{
name|unsigned
name|char
name|insn
init|=
operator|*
name|insn_ptr
operator|++
decl_stmt|;
name|_Unwind_Word
name|reg
decl_stmt|,
name|utmp
decl_stmt|;
name|_Unwind_Sword
name|offset
decl_stmt|,
name|stmp
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xc0
operator|)
operator|==
name|DW_CFA_advance_loc
condition|)
name|fs
operator|->
name|pc
operator|+=
operator|(
name|insn
operator|&
literal|0x3f
operator|)
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xc0
operator|)
operator|==
name|DW_CFA_offset
condition|)
block|{
name|reg
operator|=
name|insn
operator|&
literal|0x3f
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|utmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xc0
operator|)
operator|==
name|DW_CFA_restore
condition|)
block|{
name|reg
operator|=
name|insn
operator|&
literal|0x3f
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_UNSAVED
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|insn
condition|)
block|{
case|case
name|DW_CFA_set_loc
case|:
name|insn_ptr
operator|=
name|read_encoded_value
argument_list|(
name|context
argument_list|,
name|fs
operator|->
name|fde_encoding
argument_list|,
name|insn_ptr
argument_list|,
operator|(
name|_Unwind_Ptr
operator|*
operator|)
operator|&
name|fs
operator|->
name|pc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
name|fs
operator|->
name|pc
operator|+=
name|read_1u
argument_list|(
name|insn_ptr
argument_list|)
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
name|insn_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
name|fs
operator|->
name|pc
operator|+=
name|read_2u
argument_list|(
name|insn_ptr
argument_list|)
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
name|insn_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
name|fs
operator|->
name|pc
operator|+=
name|read_4u
argument_list|(
name|insn_ptr
argument_list|)
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
name|insn_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|utmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_UNSAVED
expr_stmt|;
break|break;
case|case
name|DW_CFA_undefined
case|:
case|case
name|DW_CFA_same_value
case|:
case|case
name|DW_CFA_nop
case|:
break|break;
case|case
name|DW_CFA_register
case|:
block|{
name|_Unwind_Word
name|reg2
decl_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg2
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_REG
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|reg
operator|=
name|reg2
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_remember_state
case|:
block|{
name|struct
name|frame_state_reg_info
modifier|*
name|new_rs
decl_stmt|;
if|if
condition|(
name|unused_rs
condition|)
block|{
name|new_rs
operator|=
name|unused_rs
expr_stmt|;
name|unused_rs
operator|=
name|unused_rs
operator|->
name|prev
expr_stmt|;
block|}
else|else
name|new_rs
operator|=
name|__builtin_alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|frame_state_reg_info
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_rs
operator|=
name|fs
operator|->
name|regs
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|prev
operator|=
name|new_rs
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_restore_state
case|:
block|{
name|struct
name|frame_state_reg_info
modifier|*
name|old_rs
init|=
name|fs
operator|->
name|regs
operator|.
name|prev
decl_stmt|;
name|fs
operator|->
name|regs
operator|=
operator|*
name|old_rs
expr_stmt|;
name|old_rs
operator|->
name|prev
operator|=
name|unused_rs
expr_stmt|;
name|unused_rs
operator|=
name|old_rs
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|utmp
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|utmp
expr_stmt|;
comment|/* cfa_how deliberately not set.  */
break|break;
case|case
name|DW_CFA_def_cfa_expression
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_exp
operator|=
name|insn_ptr
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_EXP
expr_stmt|;
name|insn_ptr
operator|+=
name|utmp
expr_stmt|;
break|break;
case|case
name|DW_CFA_expression
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_EXP
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|exp
operator|=
name|insn_ptr
expr_stmt|;
name|insn_ptr
operator|+=
name|utmp
expr_stmt|;
break|break;
comment|/* From the 2.1 draft.  */
case|case
name|DW_CFA_offset_extended_sf
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_sleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|stmp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|stmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_sf
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_sleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|fs
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
name|insn_ptr
operator|=
name|read_sleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|fs
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
comment|/* cfa_how deliberately not set.  */
break|break;
case|case
name|DW_CFA_GNU_window_save
case|:
comment|/* ??? Hardcoded for SPARC register window configuration.  */
for|for
control|(
name|reg
operator|=
literal|16
init|;
name|reg
operator|<
literal|32
condition|;
operator|++
name|reg
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|reg
operator|-
literal|16
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_GNU_args_size
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|context
operator|->
name|args_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
comment|/* Obsoleted by DW_CFA_offset_extended_sf, but used by 	     older PowerPC code.  */
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|_Unwind_Word
operator|)
name|utmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|_Unwind_Reason_Code
name|uw_frame_state_for
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|dwarf_fde
modifier|*
name|fde
decl_stmt|;
name|struct
name|dwarf_cie
modifier|*
name|cie
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|aug
decl_stmt|,
modifier|*
name|insn
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|memset
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fs
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|args_size
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|lsda
operator|=
literal|0
expr_stmt|;
name|fde
operator|=
name|_Unwind_Find_FDE
argument_list|(
name|context
operator|->
name|ra
operator|-
literal|1
argument_list|,
operator|&
name|context
operator|->
name|bases
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde
operator|==
name|NULL
condition|)
block|{
comment|/* Couldn't find frame unwind info for this function.  Try a 	 target-specific fallback mechanism.  This will necessarily 	 not provide a personality routine or LSDA.  */
ifdef|#
directive|ifdef
name|MD_FALLBACK_FRAME_STATE_FOR
name|MD_FALLBACK_FRAME_STATE_FOR
argument_list|(
name|context
argument_list|,
name|fs
argument_list|,
name|success
argument_list|)
expr_stmt|;
return|return
name|_URC_END_OF_STACK
return|;
name|success
label|:
return|return
name|_URC_NO_REASON
return|;
else|#
directive|else
return|return
name|_URC_END_OF_STACK
return|;
endif|#
directive|endif
block|}
name|fs
operator|->
name|pc
operator|=
name|context
operator|->
name|bases
operator|.
name|func
expr_stmt|;
name|cie
operator|=
name|get_cie
argument_list|(
name|fde
argument_list|)
expr_stmt|;
name|insn
operator|=
name|extract_cie_info
argument_list|(
name|cie
argument_list|,
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL
condition|)
comment|/* CIE contained unknown augmentation.  */
return|return
name|_URC_FATAL_PHASE1_ERROR
return|;
comment|/* First decode all the insns in the CIE.  */
name|end
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|next_fde
argument_list|(
operator|(
expr|struct
name|dwarf_fde
operator|*
operator|)
name|cie
argument_list|)
expr_stmt|;
name|execute_cfa_program
argument_list|(
name|insn
argument_list|,
name|end
argument_list|,
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
comment|/* Locate augmentation for the fde.  */
name|aug
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fde
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|fde
argument_list|)
expr_stmt|;
name|aug
operator|+=
literal|2
operator|*
name|size_of_encoded_value
argument_list|(
name|fs
operator|->
name|fde_encoding
argument_list|)
expr_stmt|;
name|insn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|saw_z
condition|)
block|{
name|_Unwind_Word
name|i
decl_stmt|;
name|aug
operator|=
name|read_uleb128
argument_list|(
name|aug
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|insn
operator|=
name|aug
operator|+
name|i
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|lsda_encoding
operator|!=
name|DW_EH_PE_omit
condition|)
name|aug
operator|=
name|read_encoded_value
argument_list|(
name|context
argument_list|,
name|fs
operator|->
name|lsda_encoding
argument_list|,
name|aug
argument_list|,
operator|(
name|_Unwind_Ptr
operator|*
operator|)
operator|&
name|context
operator|->
name|lsda
argument_list|)
expr_stmt|;
comment|/* Then the insns in the FDE up to our target PC.  */
if|if
condition|(
name|insn
operator|==
name|NULL
condition|)
name|insn
operator|=
name|aug
expr_stmt|;
name|end
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|next_fde
argument_list|(
name|fde
argument_list|)
expr_stmt|;
name|execute_cfa_program
argument_list|(
name|insn
argument_list|,
name|end
argument_list|,
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

begin_escape
end_escape

begin_typedef
typedef|typedef
struct|struct
name|frame_state
block|{
name|void
modifier|*
name|cfa
decl_stmt|;
name|void
modifier|*
name|eh_ptr
decl_stmt|;
name|long
name|cfa_offset
decl_stmt|;
name|long
name|args_size
decl_stmt|;
name|long
name|reg_or_offset
index|[
name|PRE_GCC3_DWARF_FRAME_REGISTERS
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|short
name|cfa_reg
decl_stmt|;
name|unsigned
name|short
name|retaddr_column
decl_stmt|;
name|char
name|saved
index|[
name|PRE_GCC3_DWARF_FRAME_REGISTERS
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|frame_state
typedef|;
end_typedef

begin_function_decl
name|struct
name|frame_state
modifier|*
name|__frame_state_for
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|frame_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called from pre-G++ 3.0 __throw to find the registers to restore for    a given PC_TARGET.  The caller should allocate a local variable of    `struct frame_state' and pass its address to STATE_IN.  */
end_comment

begin_function
name|struct
name|frame_state
modifier|*
name|__frame_state_for
parameter_list|(
name|void
modifier|*
name|pc_target
parameter_list|,
name|struct
name|frame_state
modifier|*
name|state_in
parameter_list|)
block|{
name|struct
name|_Unwind_Context
name|context
decl_stmt|;
name|_Unwind_FrameState
name|fs
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_Unwind_Context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|ra
operator|=
name|pc_target
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|uw_frame_state_for
argument_list|(
operator|&
name|context
argument_list|,
operator|&
name|fs
argument_list|)
operator|!=
name|_URC_NO_REASON
condition|)
return|return
literal|0
return|;
comment|/* We have no way to pass a location expression for the CFA to our      caller.  It wouldn't understand it anyway.  */
if|if
condition|(
name|fs
operator|.
name|cfa_how
operator|==
name|CFA_EXP
condition|)
return|return
literal|0
return|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|PRE_GCC3_DWARF_FRAME_REGISTERS
operator|+
literal|1
condition|;
name|reg
operator|++
control|)
block|{
name|state_in
operator|->
name|saved
index|[
name|reg
index|]
operator|=
name|fs
operator|.
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
expr_stmt|;
switch|switch
condition|(
name|state_in
operator|->
name|saved
index|[
name|reg
index|]
condition|)
block|{
case|case
name|REG_SAVED_REG
case|:
name|state_in
operator|->
name|reg_or_offset
index|[
name|reg
index|]
operator|=
name|fs
operator|.
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|reg
expr_stmt|;
break|break;
case|case
name|REG_SAVED_OFFSET
case|:
name|state_in
operator|->
name|reg_or_offset
index|[
name|reg
index|]
operator|=
name|fs
operator|.
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
expr_stmt|;
break|break;
default|default:
name|state_in
operator|->
name|reg_or_offset
index|[
name|reg
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|state_in
operator|->
name|cfa_offset
operator|=
name|fs
operator|.
name|cfa_offset
expr_stmt|;
name|state_in
operator|->
name|cfa_reg
operator|=
name|fs
operator|.
name|cfa_reg
expr_stmt|;
name|state_in
operator|->
name|retaddr_column
operator|=
name|fs
operator|.
name|retaddr_column
expr_stmt|;
name|state_in
operator|->
name|args_size
operator|=
name|context
operator|.
name|args_size
expr_stmt|;
name|state_in
operator|->
name|eh_ptr
operator|=
name|fs
operator|.
name|eh_ptr
expr_stmt|;
return|return
name|state_in
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|uw_update_context_1
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|_Unwind_Context
name|orig_context
init|=
operator|*
name|context
decl_stmt|;
name|void
modifier|*
name|cfa
decl_stmt|;
name|long
name|i
decl_stmt|;
comment|/* Compute this frame's CFA.  */
switch|switch
condition|(
name|fs
operator|->
name|cfa_how
condition|)
block|{
case|case
name|CFA_REG_OFFSET
case|:
comment|/* Special handling here: Many machines do not use a frame pointer, 	 and track the CFA only through offsets from the stack pointer from 	 one frame to the next.  In this case, the stack pointer is never 	 stored, so it has no saved address in the context.  What we do  	 have is the CFA from the previous stack frame.  */
if|if
condition|(
name|context
operator|->
name|reg
index|[
name|fs
operator|->
name|cfa_reg
index|]
operator|==
name|NULL
condition|)
name|cfa
operator|=
name|context
operator|->
name|cfa
expr_stmt|;
else|else
name|cfa
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|_Unwind_Ptr
operator|)
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|cfa
operator|+=
name|fs
operator|->
name|cfa_offset
expr_stmt|;
break|break;
case|case
name|CFA_EXP
case|:
comment|/* ??? No way of knowing what register number is the stack pointer 	 to do the same sort of handling as above.  Assume that if the 	 CFA calculation is so complicated as to require a stack program 	 that this will not be a problem.  */
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|exp
init|=
name|fs
operator|->
name|cfa_exp
decl_stmt|;
name|_Unwind_Word
name|len
decl_stmt|;
name|exp
operator|=
name|read_uleb128
argument_list|(
name|exp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|cfa
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|_Unwind_Ptr
operator|)
name|execute_stack_op
argument_list|(
name|exp
argument_list|,
name|exp
operator|+
name|len
argument_list|,
name|context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|context
operator|->
name|cfa
operator|=
name|cfa
expr_stmt|;
comment|/* Compute the addresses of all registers saved in this frame.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DWARF_FRAME_REGISTERS
operator|+
literal|1
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|how
condition|)
block|{
case|case
name|REG_UNSAVED
case|:
break|break;
case|case
name|REG_SAVED_OFFSET
case|:
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|=
name|cfa
operator|+
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
expr_stmt|;
break|break;
case|case
name|REG_SAVED_REG
case|:
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|=
name|orig_context
operator|.
name|reg
index|[
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|reg
index|]
expr_stmt|;
break|break;
case|case
name|REG_SAVED_EXP
case|:
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|exp
init|=
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|exp
decl_stmt|;
name|_Unwind_Word
name|len
decl_stmt|;
name|_Unwind_Ptr
name|val
decl_stmt|;
name|exp
operator|=
name|read_uleb128
argument_list|(
name|exp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|val
operator|=
name|execute_stack_op
argument_list|(
name|exp
argument_list|,
name|exp
operator|+
name|len
argument_list|,
operator|&
name|orig_context
argument_list|,
operator|(
name|_Unwind_Ptr
operator|)
name|cfa
argument_list|)
expr_stmt|;
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|val
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uw_update_context
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|uw_update_context_1
argument_list|(
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
comment|/* Compute the return address now, since the return address column      can change from frame to frame.  */
name|context
operator|->
name|ra
operator|=
name|__builtin_extract_return_addr
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|_Unwind_Ptr
operator|)
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|fs
operator|->
name|retaddr_column
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in CONTEXT for top-of-stack.  The only valid registers at this    level will be the return address and the CFA.  */
end_comment

begin_define
define|#
directive|define
name|uw_init_context
parameter_list|(
name|CONTEXT
parameter_list|)
define|\
value|do									   \     {									   \
comment|/* Do any necessary initialization to access arbitrary stack frames. \ 	 On the SPARC, this means flushing the register windows.  */
value|\       __builtin_unwind_init ();						   \       uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),		   \ 			 __builtin_return_address (0));			   \     }									   \   while (0)
end_define

begin_function
specifier|static
name|void
name|uw_init_context_1
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|outer_cfa
parameter_list|,
name|void
modifier|*
name|outer_ra
parameter_list|)
block|{
name|void
modifier|*
name|ra
init|=
name|__builtin_extract_return_addr
argument_list|(
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|_Unwind_FrameState
name|fs
decl_stmt|;
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_Unwind_Context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|ra
operator|=
name|ra
expr_stmt|;
if|if
condition|(
name|uw_frame_state_for
argument_list|(
name|context
argument_list|,
operator|&
name|fs
argument_list|)
operator|!=
name|_URC_NO_REASON
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Force the frame state to use the known cfa value.  */
name|context
operator|->
name|cfa
operator|=
name|outer_cfa
expr_stmt|;
name|fs
operator|.
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
name|fs
operator|.
name|cfa_reg
operator|=
literal|0
expr_stmt|;
name|fs
operator|.
name|cfa_offset
operator|=
literal|0
expr_stmt|;
name|uw_update_context_1
argument_list|(
name|context
argument_list|,
operator|&
name|fs
argument_list|)
expr_stmt|;
comment|/* If the return address column was saved in a register in the      initialization context, then we can't see it in the given      call frame data.  So have the initialization context tell us.  */
name|context
operator|->
name|ra
operator|=
name|__builtin_extract_return_addr
argument_list|(
name|outer_ra
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install TARGET into CURRENT so that we can return to it.  This is a    macro because __builtin_eh_return must be invoked in the context of    our caller.  */
end_comment

begin_define
define|#
directive|define
name|uw_install_context
parameter_list|(
name|CURRENT
parameter_list|,
name|TARGET
parameter_list|)
define|\
value|do									 \     {									 \       long offset = uw_install_context_1 ((CURRENT), (TARGET));		 \       void *handler = __builtin_frob_return_addr ((TARGET)->ra);	 \       __builtin_eh_return (offset, handler);				 \     }									 \   while (0)
end_define

begin_function
specifier|static
specifier|inline
name|void
name|init_dwarf_reg_size_table
parameter_list|(
name|void
parameter_list|)
block|{
name|__builtin_init_dwarf_reg_size_table
argument_list|(
name|dwarf_reg_size_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|uw_install_context_1
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|current
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|target
parameter_list|)
block|{
name|long
name|i
decl_stmt|;
if|#
directive|if
name|__GTHREADS
block|{
specifier|static
name|__gthread_once_t
name|once_regsizes
init|=
name|__GTHREAD_ONCE_INIT
decl_stmt|;
if|if
condition|(
name|__gthread_once
argument_list|(
operator|&
name|once_regsizes
argument_list|,
name|init_dwarf_reg_size_table
argument_list|)
operator|!=
literal|0
operator|||
name|dwarf_reg_size_table
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|init_dwarf_reg_size_table
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|dwarf_reg_size_table
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|init_dwarf_reg_size_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DWARF_FRAME_REGISTERS
condition|;
operator|++
name|i
control|)
block|{
name|void
modifier|*
name|c
init|=
name|current
operator|->
name|reg
index|[
name|i
index|]
decl_stmt|;
name|void
modifier|*
name|t
init|=
name|target
operator|->
name|reg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|&&
name|c
operator|&&
name|t
operator|!=
name|c
condition|)
name|memcpy
argument_list|(
name|c
argument_list|,
name|t
argument_list|,
name|dwarf_reg_size_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* We adjust SP by the difference between CURRENT and TARGET's CFA.  */
if|if
condition|(
name|STACK_GROWS_DOWNWARD
condition|)
return|return
name|target
operator|->
name|cfa
operator|-
name|current
operator|->
name|cfa
operator|+
name|target
operator|->
name|args_size
return|;
else|else
return|return
name|current
operator|->
name|cfa
operator|-
name|target
operator|->
name|cfa
operator|-
name|target
operator|->
name|args_size
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|_Unwind_Ptr
name|uw_identify_context
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|_Unwind_GetIP
argument_list|(
name|context
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"unwind.inc"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USING_SJLJ_EXCEPTIONS */
end_comment

end_unit

