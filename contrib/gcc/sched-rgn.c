begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This pass implements list scheduling within basic blocks.  It is    run twice: (1) after flow analysis, but before register allocation,    and (2) after register allocation.     The first run performs interblock scheduling, moving insns between    different blocks in the same "region", and the second runs only    basic block scheduling.     Interblock motions performed are useful motions and speculative    motions, including speculative loads.  Motions requiring code    duplication are not supported.  The identification of motion type    and the check for validity of speculative motions requires    construction and analysis of the function's control flow graph.     The main entry point for this pass is schedule_insns(), called for    each function.  The work of the scheduler is organized in three    levels: (1) function level: insns are subject to splitting,    control-flow-graph is constructed, regions are computed (after    reload, each region is of one block), (2) region level: control    flow graph attributes required for interblock scheduling are    computed (dominators, reachability, etc.), data dependences and    priorities are computed, and (3) block level: insns in the block    are actually scheduled.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_comment
comment|/* Define when we want to do count REG_DEAD notes before and after scheduling    for sanity checking.  We can't do that when conditional execution is used,    as REG_DEAD exist only for unconditional deaths.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_conditional_execution
argument_list|)
operator|&&
name|defined
argument_list|(
name|ENABLE_CHECKING
argument_list|)
end_if

begin_define
define|#
directive|define
name|CHECK_DEAD_NOTES
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECK_DEAD_NOTES
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_comment
comment|/* Some accessor macros for h_i_d members only used within this file.  */
end_comment

begin_define
define|#
directive|define
name|INSN_REF_COUNT
parameter_list|(
name|INSN
parameter_list|)
value|(h_i_d[INSN_UID (INSN)].ref_count)
end_define

begin_define
define|#
directive|define
name|FED_BY_SPEC_LOAD
parameter_list|(
name|insn
parameter_list|)
value|(h_i_d[INSN_UID (insn)].fed_by_spec_load)
end_define

begin_define
define|#
directive|define
name|IS_LOAD_INSN
parameter_list|(
name|insn
parameter_list|)
value|(h_i_d[INSN_UID (insn)].is_load_insn)
end_define

begin_define
define|#
directive|define
name|MAX_RGN_BLOCKS
value|10
end_define

begin_define
define|#
directive|define
name|MAX_RGN_INSNS
value|100
end_define

begin_comment
comment|/* nr_inter/spec counts interblock/speculative motion for the function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nr_inter
decl_stmt|,
name|nr_spec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Control flow graph edges are kept in circular lists.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|from_block
decl_stmt|;
name|int
name|to_block
decl_stmt|;
name|int
name|next_in
decl_stmt|;
name|int
name|next_out
decl_stmt|;
block|}
name|haifa_edge
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|haifa_edge
modifier|*
name|edge_table
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXT_IN
parameter_list|(
name|edge
parameter_list|)
value|(edge_table[edge].next_in)
end_define

begin_define
define|#
directive|define
name|NEXT_OUT
parameter_list|(
name|edge
parameter_list|)
value|(edge_table[edge].next_out)
end_define

begin_define
define|#
directive|define
name|FROM_BLOCK
parameter_list|(
name|edge
parameter_list|)
value|(edge_table[edge].from_block)
end_define

begin_define
define|#
directive|define
name|TO_BLOCK
parameter_list|(
name|edge
parameter_list|)
value|(edge_table[edge].to_block)
end_define

begin_comment
comment|/* Number of edges in the control flow graph.  (In fact, larger than    that by 1, since edge 0 is unused.)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nr_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Circular list of incoming/outgoing edges of a block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|in_edges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|out_edges
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IN_EDGES
parameter_list|(
name|block
parameter_list|)
value|(in_edges[block])
end_define

begin_define
define|#
directive|define
name|OUT_EDGES
parameter_list|(
name|block
parameter_list|)
value|(out_edges[block])
end_define

begin_decl_stmt
specifier|static
name|int
name|is_cfg_nonregular
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|build_control_flow
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_edge
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A region is the main entity for interblock scheduling: insns    are allowed to move between blocks in the same region, along    control flow graph edges, in the 'up' direction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|rgn_nr_blocks
decl_stmt|;
comment|/* Number of blocks in region.  */
name|int
name|rgn_blocks
decl_stmt|;
comment|/* cblocks in the region (actually index in rgn_bb_table).  */
block|}
name|region
typedef|;
end_typedef

begin_comment
comment|/* Number of regions in the procedure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nr_regions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of region descriptions.  */
end_comment

begin_decl_stmt
specifier|static
name|region
modifier|*
name|rgn_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of lists of regions' blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|rgn_bb_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Topological order of blocks in the region (if b2 is reachable from    b1, block_to_bb[b2]> block_to_bb[b1]).  Note: A basic block is    always referred to by either block or b, while its topological    order name (in the region) is refered to by bb.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|block_to_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of the region containing a block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|containing_rgn
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RGN_NR_BLOCKS
parameter_list|(
name|rgn
parameter_list|)
value|(rgn_table[rgn].rgn_nr_blocks)
end_define

begin_define
define|#
directive|define
name|RGN_BLOCKS
parameter_list|(
name|rgn
parameter_list|)
value|(rgn_table[rgn].rgn_blocks)
end_define

begin_define
define|#
directive|define
name|BLOCK_TO_BB
parameter_list|(
name|block
parameter_list|)
value|(block_to_bb[block])
end_define

begin_define
define|#
directive|define
name|CONTAINING_RGN
parameter_list|(
name|block
parameter_list|)
value|(containing_rgn[block])
end_define

begin_decl_stmt
name|void
name|debug_regions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_single_block_region
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_rgns
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|too_large
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|debug_live
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Blocks of the current region being scheduled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_nr_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The mapping from bb to block.  */
end_comment

begin_define
define|#
directive|define
name|BB_TO_BLOCK
parameter_list|(
name|bb
parameter_list|)
value|(rgn_bb_table[current_blocks + (bb)])
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
modifier|*
name|first_member
decl_stmt|;
comment|/* Pointer to the list start in bitlst_table.  */
name|int
name|nr_members
decl_stmt|;
comment|/* The number of members of the bit list.  */
block|}
name|bitlst
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|bitlst_table_last
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bitlst_table_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|bitlst_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extract_bitlst
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|,
name|bitlst
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target info declarations.     The block currently being scheduled is referred to as the "target" block,    while other blocks in the region from which insns can be moved to the    target are called "source" blocks.  The candidate structure holds info    about such sources: are they valid?  Speculative?  Etc.  */
end_comment

begin_typedef
typedef|typedef
name|bitlst
name|bblst
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
name|is_valid
decl_stmt|;
name|char
name|is_speculative
decl_stmt|;
name|int
name|src_prob
decl_stmt|;
name|bblst
name|split_bbs
decl_stmt|;
name|bblst
name|update_bbs
decl_stmt|;
block|}
name|candidate
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|candidate
modifier|*
name|candidate_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A speculative motion requires checking live information on the path    from 'source' to 'target'.  The split blocks are those to be checked.    After a speculative motion, live information should be modified in    the 'update' blocks.     Lists of split and update blocks for each candidate of the current    target are in array bblst_table.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|bblst_table
decl_stmt|,
name|bblst_size
decl_stmt|,
name|bblst_last
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_VALID
parameter_list|(
name|src
parameter_list|)
value|( candidate_table[src].is_valid )
end_define

begin_define
define|#
directive|define
name|IS_SPECULATIVE
parameter_list|(
name|src
parameter_list|)
value|( candidate_table[src].is_speculative )
end_define

begin_define
define|#
directive|define
name|SRC_PROB
parameter_list|(
name|src
parameter_list|)
value|( candidate_table[src].src_prob )
end_define

begin_comment
comment|/* The bb being currently scheduled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of edges.  */
end_comment

begin_typedef
typedef|typedef
name|bitlst
name|edgelst
typedef|;
end_typedef

begin_comment
comment|/* Target info functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|split_edges
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|edgelst
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_trg_info
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_candidate
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_candidates
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dominators array: dom[i] contains the sbitmap of dominators of    bb i in the region.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|dom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bb 0 is the only region entry.  */
end_comment

begin_define
define|#
directive|define
name|IS_RGN_ENTRY
parameter_list|(
name|bb
parameter_list|)
value|(!bb)
end_define

begin_comment
comment|/* Is bb_src dominated by bb_trg.  */
end_comment

begin_define
define|#
directive|define
name|IS_DOMINATED
parameter_list|(
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
define|\
value|( TEST_BIT (dom[bb_src], bb_trg) )
end_define

begin_comment
comment|/* Probability: Prob[i] is a float in [0, 1] which is the probability    of bb i relative to the region entry.  */
end_comment

begin_decl_stmt
specifier|static
name|float
modifier|*
name|prob
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The probability of bb_src, relative to bb_trg.  Note, that while the    'prob[bb]' is a float in [0, 1], this macro returns an integer    in [0, 100].  */
end_comment

begin_define
define|#
directive|define
name|GET_SRC_PROB
parameter_list|(
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
value|((int) (100.0 * (prob[bb_src] / \ 						      prob[bb_trg])))
end_define

begin_comment
comment|/* Bit-set of edges, where bit i stands for edge i.  */
end_comment

begin_typedef
typedef|typedef
name|sbitmap
name|edgeset
typedef|;
end_typedef

begin_comment
comment|/* Number of edges in the region.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rgn_nr_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of size rgn_nr_edges.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|rgn_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping from each edge in the graph to its number in the rgn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|edge_to_bit
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EDGE_TO_BIT
parameter_list|(
name|edge
parameter_list|)
value|(edge_to_bit[edge])
end_define

begin_comment
comment|/* The split edges of a source bb is different for each target    bb.  In order to compute this efficiently, the 'potential-split edges'    are computed for each bb prior to scheduling a region.  This is actually    the split edges of each bb relative to the region entry.     pot_split[bb] is the set of potential split edges of bb.  */
end_comment

begin_decl_stmt
specifier|static
name|edgeset
modifier|*
name|pot_split
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For every bb, a set of its ancestor edges.  */
end_comment

begin_decl_stmt
specifier|static
name|edgeset
modifier|*
name|ancestor_edges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_dom_prob_ps
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ABS_VALUE
parameter_list|(
name|x
parameter_list|)
value|(((x)<0)?(-(x)):(x))
end_define

begin_define
define|#
directive|define
name|INSN_PROBABILITY
parameter_list|(
name|INSN
parameter_list|)
value|(SRC_PROB (BLOCK_TO_BB (BLOCK_NUM (INSN))))
end_define

begin_define
define|#
directive|define
name|IS_SPECULATIVE_INSN
parameter_list|(
name|INSN
parameter_list|)
value|(IS_SPECULATIVE (BLOCK_TO_BB (BLOCK_NUM (INSN))))
end_define

begin_define
define|#
directive|define
name|INSN_BB
parameter_list|(
name|INSN
parameter_list|)
value|(BLOCK_TO_BB (BLOCK_NUM (INSN)))
end_define

begin_comment
comment|/* Parameters affecting the decision of rank_for_schedule().    ??? Nope.  But MIN_PROBABILITY is used in copmute_trg_info.  */
end_comment

begin_define
define|#
directive|define
name|MIN_DIFF_PRIORITY
value|2
end_define

begin_define
define|#
directive|define
name|MIN_PROBABILITY
value|40
end_define

begin_define
define|#
directive|define
name|MIN_PROB_DIFF
value|10
end_define

begin_comment
comment|/* Speculative scheduling functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|check_live_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_live_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_live
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_live
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_spec_fed
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_pfree
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_conditional_protection
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_conditionally_protected
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|may_trap_exp
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|haifa_classify_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_prisky
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_exception_free
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_branch_dependences
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_block_backward_dependences
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_dependencies
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_regions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_region
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|concat_INSN_LIST
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|concat_insn_mem_list
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|propagate_deps
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|deps
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_pending_lists
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions for construction of the control flow graph.  */
end_comment

begin_comment
comment|/* Return 1 if control flow graph should not be constructed, 0 otherwise.     We decide not to build the control flow graph if there is possibly more    than one entry to the function, if computed branches exist, of if we    have nonlocal gotos.  */
end_comment

begin_function
specifier|static
name|int
name|is_cfg_nonregular
parameter_list|()
block|{
name|int
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
comment|/* If we have a label that could be the target of a nonlocal goto, then      the cfg is not well structured.  */
if|if
condition|(
name|nonlocal_goto_handler_labels
condition|)
return|return
literal|1
return|;
comment|/* If we have any forced labels, then the cfg is not well structured.  */
if|if
condition|(
name|forced_labels
condition|)
return|return
literal|1
return|;
comment|/* If this function has a computed jump, then we consider the cfg      not well structured.  */
if|if
condition|(
name|current_function_has_computed_jump
condition|)
return|return
literal|1
return|;
comment|/* If we have exception handlers, then we consider the cfg not well      structured.  ?!?  We should be able to handle this now that flow.c      computes an accurate cfg for EH.  */
if|if
condition|(
name|exception_handler_labels
condition|)
return|return
literal|1
return|;
comment|/* If we have non-jumping insns which refer to labels, then we consider      the cfg not well structured.  */
comment|/* Check for labels referred to other thn by jumps.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|&&
name|code
operator|!=
name|JUMP_INSN
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|find_reg_note
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
block|}
comment|/* All the tests passed.  Consider the cfg well structured.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build the control flow graph and set nr_edges.     Instead of trying to build a cfg ourselves, we rely on flow to    do it for us.  Stamp out useless code (and bug) duplication.     Return nonzero if an irregularity in the cfg is found which would    prevent cross block scheduling.  */
end_comment

begin_function
specifier|static
name|int
name|build_control_flow
parameter_list|(
name|edge_list
parameter_list|)
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|unreachable
decl_stmt|,
name|num_edges
decl_stmt|;
comment|/* This already accounts for entry/exit edges.  */
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
comment|/* Unreachable loops with more than one basic block are detected      during the DFS traversal in find_rgns.       Unreachable loops with a single block are detected here.  This      test is redundant with the one in find_rgns, but it's much     cheaper to go ahead and catch the trivial case here.  */
name|unreachable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|pred
operator|==
name|NULL
operator|||
operator|(
name|b
operator|->
name|pred
operator|->
name|src
operator|==
name|b
operator|&&
name|b
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
operator|)
condition|)
name|unreachable
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ??? We can kill these soon.  */
name|in_edges
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|out_edges
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|edge_table
operator|=
operator|(
name|haifa_edge
operator|*
operator|)
name|xcalloc
argument_list|(
name|num_edges
argument_list|,
sizeof|sizeof
argument_list|(
name|haifa_edge
argument_list|)
argument_list|)
expr_stmt|;
name|nr_edges
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|new_edge
argument_list|(
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Increment by 1, since edge 0 is unused.  */
name|nr_edges
operator|++
expr_stmt|;
return|return
name|unreachable
return|;
block|}
end_function

begin_comment
comment|/* Record an edge in the control flow graph from SOURCE to TARGET.     In theory, this is redundant with the s_succs computed above, but    we have not converted all of haifa to use information from the    integer lists.  */
end_comment

begin_function
specifier|static
name|void
name|new_edge
parameter_list|(
name|source
parameter_list|,
name|target
parameter_list|)
name|int
name|source
decl_stmt|,
name|target
decl_stmt|;
block|{
name|int
name|e
decl_stmt|,
name|next_edge
decl_stmt|;
name|int
name|curr_edge
decl_stmt|,
name|fst_edge
decl_stmt|;
comment|/* Check for duplicates.  */
name|fst_edge
operator|=
name|curr_edge
operator|=
name|OUT_EDGES
argument_list|(
name|source
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr_edge
condition|)
block|{
if|if
condition|(
name|FROM_BLOCK
argument_list|(
name|curr_edge
argument_list|)
operator|==
name|source
operator|&&
name|TO_BLOCK
argument_list|(
name|curr_edge
argument_list|)
operator|==
name|target
condition|)
block|{
return|return;
block|}
name|curr_edge
operator|=
name|NEXT_OUT
argument_list|(
name|curr_edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst_edge
operator|==
name|curr_edge
condition|)
break|break;
block|}
name|e
operator|=
operator|++
name|nr_edges
expr_stmt|;
name|FROM_BLOCK
argument_list|(
name|e
argument_list|)
operator|=
name|source
expr_stmt|;
name|TO_BLOCK
argument_list|(
name|e
argument_list|)
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|OUT_EDGES
argument_list|(
name|source
argument_list|)
condition|)
block|{
name|next_edge
operator|=
name|NEXT_OUT
argument_list|(
name|OUT_EDGES
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|NEXT_OUT
argument_list|(
name|OUT_EDGES
argument_list|(
name|source
argument_list|)
argument_list|)
operator|=
name|e
expr_stmt|;
name|NEXT_OUT
argument_list|(
name|e
argument_list|)
operator|=
name|next_edge
expr_stmt|;
block|}
else|else
block|{
name|OUT_EDGES
argument_list|(
name|source
argument_list|)
operator|=
name|e
expr_stmt|;
name|NEXT_OUT
argument_list|(
name|e
argument_list|)
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|IN_EDGES
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|next_edge
operator|=
name|NEXT_IN
argument_list|(
name|IN_EDGES
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|NEXT_IN
argument_list|(
name|IN_EDGES
argument_list|(
name|target
argument_list|)
argument_list|)
operator|=
name|e
expr_stmt|;
name|NEXT_IN
argument_list|(
name|e
argument_list|)
operator|=
name|next_edge
expr_stmt|;
block|}
else|else
block|{
name|IN_EDGES
argument_list|(
name|target
argument_list|)
operator|=
name|e
expr_stmt|;
name|NEXT_IN
argument_list|(
name|e
argument_list|)
operator|=
name|e
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Translate a bit-set SET to a list BL of the bit-set members.  */
end_comment

begin_function
specifier|static
name|void
name|extract_bitlst
parameter_list|(
name|set
parameter_list|,
name|bl
parameter_list|)
name|sbitmap
name|set
decl_stmt|;
name|bitlst
modifier|*
name|bl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* bblst table space is reused in each call to extract_bitlst.  */
name|bitlst_table_last
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|first_member
operator|=
operator|&
name|bitlst_table
index|[
name|bitlst_table_last
index|]
expr_stmt|;
name|bl
operator|->
name|nr_members
operator|=
literal|0
expr_stmt|;
comment|/* Iterate over each word in the bitset.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|set
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{     bitlst_table[bitlst_table_last++] = i;     (bl->nr_members)++;   }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Functions for the construction of regions.  */
end_comment

begin_comment
comment|/* Print the regions, for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
name|void
name|debug_regions
parameter_list|()
block|{
name|int
name|rgn
decl_stmt|,
name|bb
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n;;   ------------ REGIONS ----------\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\trgn %d nr_blocks %d:\n"
argument_list|,
name|rgn
argument_list|,
name|rgn_table
index|[
name|rgn
index|]
operator|.
name|rgn_nr_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\tbb/block: "
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|rgn_table
index|[
name|rgn
index|]
operator|.
name|rgn_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|current_blocks
operator|=
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|!=
name|BLOCK_TO_BB
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" %d/%d "
argument_list|,
name|bb
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a single block region for each basic block in the function.    This allows for using the same code for interblock and basic block    scheduling.  */
end_comment

begin_function
specifier|static
name|void
name|find_single_block_region
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|rgn_bb_table
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|RGN_NR_BLOCKS
argument_list|(
name|i
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RGN_BLOCKS
argument_list|(
name|i
argument_list|)
operator|=
name|i
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|i
argument_list|)
operator|=
name|i
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|nr_regions
operator|=
name|n_basic_blocks
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update number of blocks and the estimate for number of insns    in the region.  Return 1 if the region is "too large" for interblock    scheduling (compile time considerations), otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|too_large
parameter_list|(
name|block
parameter_list|,
name|num_bbs
parameter_list|,
name|num_insns
parameter_list|)
name|int
name|block
decl_stmt|,
decl|*
name|num_bbs
decl_stmt|,
modifier|*
name|num_insns
decl_stmt|;
end_function

begin_block
block|{
operator|(
operator|*
name|num_bbs
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|num_insns
operator|)
operator|+=
operator|(
name|INSN_LUID
argument_list|(
name|BLOCK_END
argument_list|(
name|block
argument_list|)
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|block
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|num_bbs
operator|>
name|MAX_RGN_BLOCKS
operator|)
operator|||
operator|(
operator|*
name|num_insns
operator|>
name|MAX_RGN_INSNS
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Update_loop_relations(blk, hdr): Check if the loop headed by max_hdr[blk]    is still an inner loop.  Put in max_hdr[blk] the header of the most inner    loop containing blk.  */
end_comment

begin_define
define|#
directive|define
name|UPDATE_LOOP_RELATIONS
parameter_list|(
name|blk
parameter_list|,
name|hdr
parameter_list|)
define|\
value|{                                                                    \   if (max_hdr[blk] == -1)                                            \     max_hdr[blk] = hdr;                                              \   else if (dfs_nr[max_hdr[blk]]> dfs_nr[hdr])                       \          RESET_BIT (inner, hdr);                                     \   else if (dfs_nr[max_hdr[blk]]< dfs_nr[hdr])                       \          {                                                           \             RESET_BIT (inner,max_hdr[blk]);			     \             max_hdr[blk] = hdr;                                      \          }                                                           \ }
end_define

begin_comment
comment|/* Find regions for interblock scheduling.     A region for scheduling can be:       * A loop-free procedure, or       * A reducible inner loop, or       * A basic block not contained in any other region.     ?!? In theory we could build other regions based on extended basic    blocks or reverse extended basic blocks.  Is it worth the trouble?     Loop blocks that form a region are put into the region's block list    in topological order.     This procedure stores its results into the following global (ick) variables       * rgn_nr      * rgn_table      * rgn_bb_table      * block_to_bb      * containing region     We use dominator relationships to avoid making regions out of non-reducible    loops.     This procedure needs to be converted to work on pred/succ lists instead    of edge tables.  That would simplify it somewhat.  */
end_comment

begin_function
specifier|static
name|void
name|find_rgns
parameter_list|(
name|edge_list
parameter_list|,
name|dom
parameter_list|)
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|sbitmap
modifier|*
name|dom
decl_stmt|;
block|{
name|int
modifier|*
name|max_hdr
decl_stmt|,
modifier|*
name|dfs_nr
decl_stmt|,
modifier|*
name|stack
decl_stmt|,
modifier|*
name|degree
decl_stmt|;
name|char
name|no_loops
init|=
literal|1
decl_stmt|;
name|int
name|node
decl_stmt|,
name|child
decl_stmt|,
name|loop_head
decl_stmt|,
name|i
decl_stmt|,
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|sp
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|,
name|current_edge
init|=
name|out_edges
index|[
literal|0
index|]
decl_stmt|;
name|int
name|num_bbs
decl_stmt|,
name|num_insns
decl_stmt|,
name|unreachable
decl_stmt|;
name|int
name|too_large_failure
decl_stmt|;
comment|/* Note if an edge has been passed.  */
name|sbitmap
name|passed
decl_stmt|;
comment|/* Note if a block is a natural loop header.  */
name|sbitmap
name|header
decl_stmt|;
comment|/* Note if a block is an natural inner loop header.  */
name|sbitmap
name|inner
decl_stmt|;
comment|/* Note if a block is in the block queue.  */
name|sbitmap
name|in_queue
decl_stmt|;
comment|/* Note if a block is in the block queue.  */
name|sbitmap
name|in_stack
decl_stmt|;
name|int
name|num_edges
init|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
decl_stmt|;
comment|/* Perform a DFS traversal of the cfg.  Identify loop headers, inner loops      and a mapping from block to its loop header (if the block is contained      in a loop, else -1).       Store results in HEADER, INNER, and MAX_HDR respectively, these will      be used as inputs to the second traversal.       STACK, SP and DFS_NR are only used during the first traversal.  */
comment|/* Allocate and initialize variables for the first traversal.  */
name|max_hdr
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|dfs_nr
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|nr_edges
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|inner
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|header
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|passed
operator|=
name|sbitmap_alloc
argument_list|(
name|nr_edges
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|passed
argument_list|)
expr_stmt|;
name|in_queue
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|in_queue
argument_list|)
expr_stmt|;
name|in_stack
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|in_stack
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|max_hdr
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* DFS traversal to find inner loops in the cfg.  */
name|sp
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|current_edge
operator|==
literal|0
operator|||
name|TEST_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
condition|)
block|{
comment|/* We have reached a leaf node or a node that was already 	     processed.  Pop edges off the stack until we find 	     an edge that has not yet been processed.  */
while|while
condition|(
name|sp
operator|>=
literal|0
operator|&&
operator|(
name|current_edge
operator|==
literal|0
operator|||
name|TEST_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
operator|)
condition|)
block|{
comment|/* Pop entry off the stack.  */
name|current_edge
operator|=
name|stack
index|[
name|sp
operator|--
index|]
expr_stmt|;
name|node
operator|=
name|FROM_BLOCK
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|child
operator|=
name|TO_BLOCK
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|in_stack
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_hdr
index|[
name|child
index|]
operator|>=
literal|0
operator|&&
name|TEST_BIT
argument_list|(
name|in_stack
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
condition|)
name|UPDATE_LOOP_RELATIONS
argument_list|(
name|node
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
expr_stmt|;
name|current_edge
operator|=
name|NEXT_OUT
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
block|}
comment|/* See if have finished the DFS tree traversal.  */
if|if
condition|(
name|sp
operator|<
literal|0
operator|&&
name|TEST_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
condition|)
break|break;
comment|/* Nope, continue the traversal with the popped node.  */
continue|continue;
block|}
comment|/* Process a node.  */
name|node
operator|=
name|FROM_BLOCK
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|child
operator|=
name|TO_BLOCK
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_stack
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|dfs_nr
index|[
name|node
index|]
operator|=
operator|++
name|count
expr_stmt|;
comment|/* If the successor is in the stack, then we've found a loop. 	 Mark the loop, if it is not a natural loop, then it will 	 be rejected during the second traversal.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|in_stack
argument_list|,
name|child
argument_list|)
condition|)
block|{
name|no_loops
operator|=
literal|0
expr_stmt|;
name|SET_BIT
argument_list|(
name|header
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|UPDATE_LOOP_RELATIONS
argument_list|(
name|node
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
expr_stmt|;
name|current_edge
operator|=
name|NEXT_OUT
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the child was already visited, then there is no need to visit 	 it again.  Just update the loop relationships and restart 	 with a new edge.  */
if|if
condition|(
name|dfs_nr
index|[
name|child
index|]
condition|)
block|{
if|if
condition|(
name|max_hdr
index|[
name|child
index|]
operator|>=
literal|0
operator|&&
name|TEST_BIT
argument_list|(
name|in_stack
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
condition|)
name|UPDATE_LOOP_RELATIONS
argument_list|(
name|node
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
expr_stmt|;
name|current_edge
operator|=
name|NEXT_OUT
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Push an entry on the stack and continue DFS traversal.  */
name|stack
index|[
operator|++
name|sp
index|]
operator|=
name|current_edge
expr_stmt|;
name|SET_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
expr_stmt|;
name|current_edge
operator|=
name|OUT_EDGES
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|/* This is temporary until haifa is converted to use rth's new 	 cfg routines which have true entry/exit blocks and the 	 appropriate edges from/to those blocks.  	 Generally we update dfs_nr for a node when we process its 	 out edge.  However, if the node has no out edge then we will 	 not set dfs_nr for that node.  This can confuse the scheduler 	 into thinking that we have unreachable blocks, which in turn 	 disables cross block scheduling.  	 So, if we have a node with no out edges, go ahead and mark it 	 as reachable now.  */
if|if
condition|(
name|current_edge
operator|==
literal|0
condition|)
name|dfs_nr
index|[
name|child
index|]
operator|=
operator|++
name|count
expr_stmt|;
block|}
comment|/* Another check for unreachable blocks.  The earlier test in      is_cfg_nonregular only finds unreachable blocks that do not      form a loop.       The DFS traversal will mark every block that is reachable from      the entry node by placing a nonzero value in dfs_nr.  Thus if      dfs_nr is zero for any block, then it must be unreachable.  */
name|unreachable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dfs_nr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|unreachable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Gross.  To avoid wasting memory, the second pass uses the dfs_nr array      to hold degree counts.  */
name|degree
operator|=
name|dfs_nr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|degree
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|degree
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|++
expr_stmt|;
block|}
comment|/* Do not perform region scheduling if there are any unreachable      blocks.  */
if|if
condition|(
operator|!
name|unreachable
condition|)
block|{
name|int
modifier|*
name|queue
decl_stmt|;
if|if
condition|(
name|no_loops
condition|)
name|SET_BIT
argument_list|(
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Second travsersal:find reducible inner loops and topologically sort 	 block of each region.  */
name|queue
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find blocks which are inner loop headers.  We still have non-reducible 	 loops to consider at this point.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|header
argument_list|,
name|i
argument_list|)
operator|&&
name|TEST_BIT
argument_list|(
name|inner
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Now check that the loop is reducible.  We do this separate 		 from finding inner loops so that we do not find a reducible 		 loop which contains an inner non-reducible loop.  		 A simple way to find reducible/natural loops is to verify 		 that each block in the loop is dominated by the loop 		 header.  		 If there exists a block that is not dominated by the loop 		 header, then the block is reachable from outside the loop 		 and thus the loop is not a natural loop.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_basic_blocks
condition|;
name|j
operator|++
control|)
block|{
comment|/* First identify blocks in the loop, except for the loop 		     entry block.  */
if|if
condition|(
name|i
operator|==
name|max_hdr
index|[
name|j
index|]
operator|&&
name|i
operator|!=
name|j
condition|)
block|{
comment|/* Now verify that the block is dominated by the loop 			 header.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|dom
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* If we exited the loop early, then I is the header of 		 a non-reducible loop and we should quit processing it 		 now.  */
if|if
condition|(
name|j
operator|!=
name|n_basic_blocks
condition|)
continue|continue;
comment|/* I is a header of an inner loop, or block 0 in a subroutine 		 with no loops at all.  */
name|head
operator|=
name|tail
operator|=
operator|-
literal|1
expr_stmt|;
name|too_large_failure
operator|=
literal|0
expr_stmt|;
name|loop_head
operator|=
name|max_hdr
index|[
name|i
index|]
expr_stmt|;
comment|/* Decrease degree of all I's successors for topological 		 ordering.  */
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
operator|--
name|degree
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
expr_stmt|;
comment|/* Estimate # insns, and count # blocks in the region.  */
name|num_bbs
operator|=
literal|1
expr_stmt|;
name|num_insns
operator|=
operator|(
name|INSN_LUID
argument_list|(
name|BLOCK_END
argument_list|(
name|i
argument_list|)
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Find all loop latches (blocks with back edges to the loop 		 header) or all the leaf blocks in the cfg has no loops.  		 Place those blocks into the queue.  */
if|if
condition|(
name|no_loops
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_basic_blocks
condition|;
name|j
operator|++
control|)
comment|/* Leaf nodes have only a single successor which must 		       be EXIT_BLOCK.  */
if|if
condition|(
name|BASIC_BLOCK
argument_list|(
name|j
argument_list|)
operator|->
name|succ
operator|&&
name|BASIC_BLOCK
argument_list|(
name|j
argument_list|)
operator|->
name|succ
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|BASIC_BLOCK
argument_list|(
name|j
argument_list|)
operator|->
name|succ
operator|->
name|succ_next
operator|==
name|NULL
condition|)
block|{
name|queue
index|[
operator|++
name|tail
index|]
operator|=
name|j
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|too_large
argument_list|(
name|j
argument_list|,
operator|&
name|num_bbs
argument_list|,
operator|&
name|num_insns
argument_list|)
condition|)
block|{
name|too_large_failure
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
continue|continue;
name|node
operator|=
name|e
operator|->
name|src
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|max_hdr
index|[
name|node
index|]
operator|==
name|loop_head
operator|&&
name|node
operator|!=
name|i
condition|)
block|{
comment|/* This is a loop latch.  */
name|queue
index|[
operator|++
name|tail
index|]
operator|=
name|node
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|too_large
argument_list|(
name|node
argument_list|,
operator|&
name|num_bbs
argument_list|,
operator|&
name|num_insns
argument_list|)
condition|)
block|{
name|too_large_failure
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Now add all the blocks in the loop to the queue.  	     We know the loop is a natural loop; however the algorithm 	     above will not always mark certain blocks as being in the 	     loop.  Consider: 		node   children 		 a	  b,c 		 b	  c 		 c	  a,d 		 d	  b  	     The algorithm in the DFS traversal may not mark B& D as part 	     of the loop (ie they will not have max_hdr set to A).  	     We know they can not be loop latches (else they would have 	     had max_hdr set since they'd have a backedge to a dominator 	     block).  So we don't need them on the initial queue.  	     We know they are part of the loop because they are dominated 	     by the loop header and can be reached by a backwards walk of 	     the edges starting with nodes on the initial queue.  	     It is safe and desirable to include those nodes in the 	     loop/scheduling region.  To do so we would need to decrease 	     the degree of a node if it is the target of a backedge 	     within the loop itself as the node is placed in the queue.  	     We do not do this because I'm not sure that the actual 	     scheduling code will properly handle this case. ?!? */
while|while
condition|(
name|head
operator|<
name|tail
operator|&&
operator|!
name|too_large_failure
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|child
operator|=
name|queue
index|[
operator|++
name|head
index|]
expr_stmt|;
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|child
argument_list|)
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|node
operator|=
name|e
operator|->
name|src
operator|->
name|index
expr_stmt|;
comment|/* See discussion above about nodes not marked as in 			 this loop during the initial DFS traversal.  */
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|max_hdr
index|[
name|node
index|]
operator|!=
name|loop_head
condition|)
block|{
name|tail
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|in_queue
argument_list|,
name|node
argument_list|)
operator|&&
name|node
operator|!=
name|i
condition|)
block|{
name|queue
index|[
operator|++
name|tail
index|]
operator|=
name|node
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|too_large
argument_list|(
name|node
argument_list|,
operator|&
name|num_bbs
argument_list|,
operator|&
name|num_insns
argument_list|)
condition|)
block|{
name|too_large_failure
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|tail
operator|>=
literal|0
operator|&&
operator|!
name|too_large_failure
condition|)
block|{
comment|/* Place the loop header into list of region blocks.  */
name|degree
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|rgn_bb_table
index|[
name|idx
index|]
operator|=
name|i
expr_stmt|;
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|num_bbs
expr_stmt|;
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|idx
operator|++
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|i
argument_list|)
operator|=
name|nr_regions
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|i
argument_list|)
operator|=
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Remove blocks from queue[] when their in degree 		     becomes zero.  Repeat until no blocks are left on the 		     list.  This produces a topological list of blocks in 		     the region.  */
while|while
condition|(
name|tail
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|head
operator|<
literal|0
condition|)
name|head
operator|=
name|tail
expr_stmt|;
name|child
operator|=
name|queue
index|[
name|head
index|]
expr_stmt|;
if|if
condition|(
name|degree
index|[
name|child
index|]
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|degree
index|[
name|child
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|rgn_bb_table
index|[
name|idx
operator|++
index|]
operator|=
name|child
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|child
argument_list|)
operator|=
operator|++
name|count
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|child
argument_list|)
operator|=
name|nr_regions
expr_stmt|;
name|queue
index|[
name|head
index|]
operator|=
name|queue
index|[
name|tail
operator|--
index|]
expr_stmt|;
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|child
argument_list|)
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
operator|--
name|degree
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
expr_stmt|;
block|}
else|else
operator|--
name|head
expr_stmt|;
block|}
operator|++
name|nr_regions
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
comment|/* Any block that did not end up in a region is placed into a region      by itself.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|degree
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|rgn_bb_table
index|[
name|idx
index|]
operator|=
name|i
expr_stmt|;
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|idx
operator|++
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|i
argument_list|)
operator|=
name|nr_regions
operator|++
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|max_hdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dfs_nr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|passed
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|in_queue
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|in_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions for regions scheduling information.  */
end_comment

begin_comment
comment|/* Compute dominators, probability, and potential-split-edges of bb.    Assume that these values were already computed for bb's predecessors.  */
end_comment

begin_function
specifier|static
name|void
name|compute_dom_prob_ps
parameter_list|(
name|bb
parameter_list|)
name|int
name|bb
decl_stmt|;
block|{
name|int
name|nxt_in_edge
decl_stmt|,
name|fst_in_edge
decl_stmt|,
name|pred
decl_stmt|;
name|int
name|fst_out_edge
decl_stmt|,
name|nxt_out_edge
decl_stmt|,
name|nr_out_edges
decl_stmt|,
name|nr_rgn_out_edges
decl_stmt|;
name|prob
index|[
name|bb
index|]
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|IS_RGN_ENTRY
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prob
index|[
name|bb
index|]
operator|=
literal|1.0
expr_stmt|;
return|return;
block|}
name|fst_in_edge
operator|=
name|nxt_in_edge
operator|=
name|IN_EDGES
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize dom[bb] to '111..1'.  */
name|sbitmap_ones
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
do|do
block|{
name|pred
operator|=
name|FROM_BLOCK
argument_list|(
name|nxt_in_edge
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|,
name|dom
index|[
name|bb
index|]
argument_list|,
name|dom
index|[
name|BLOCK_TO_BB
argument_list|(
name|pred
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|sbitmap_a_or_b
argument_list|(
name|ancestor_edges
index|[
name|bb
index|]
argument_list|,
name|ancestor_edges
index|[
name|bb
index|]
argument_list|,
name|ancestor_edges
index|[
name|BLOCK_TO_BB
argument_list|(
name|pred
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|ancestor_edges
index|[
name|bb
index|]
argument_list|,
name|EDGE_TO_BIT
argument_list|(
name|nxt_in_edge
argument_list|)
argument_list|)
expr_stmt|;
name|nr_out_edges
operator|=
literal|1
expr_stmt|;
name|nr_rgn_out_edges
operator|=
literal|0
expr_stmt|;
name|fst_out_edge
operator|=
name|OUT_EDGES
argument_list|(
name|pred
argument_list|)
expr_stmt|;
name|nxt_out_edge
operator|=
name|NEXT_OUT
argument_list|(
name|fst_out_edge
argument_list|)
expr_stmt|;
name|sbitmap_a_or_b
argument_list|(
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|pot_split
index|[
name|BLOCK_TO_BB
argument_list|(
name|pred
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|EDGE_TO_BIT
argument_list|(
name|fst_out_edge
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The successor doesn't belong in the region?  */
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|TO_BLOCK
argument_list|(
name|fst_out_edge
argument_list|)
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
operator|++
name|nr_rgn_out_edges
expr_stmt|;
while|while
condition|(
name|fst_out_edge
operator|!=
name|nxt_out_edge
condition|)
block|{
operator|++
name|nr_out_edges
expr_stmt|;
comment|/* The successor doesn't belong in the region?  */
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|TO_BLOCK
argument_list|(
name|nxt_out_edge
argument_list|)
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
operator|++
name|nr_rgn_out_edges
expr_stmt|;
name|SET_BIT
argument_list|(
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|EDGE_TO_BIT
argument_list|(
name|nxt_out_edge
argument_list|)
argument_list|)
expr_stmt|;
name|nxt_out_edge
operator|=
name|NEXT_OUT
argument_list|(
name|nxt_out_edge
argument_list|)
expr_stmt|;
block|}
comment|/* Now nr_rgn_out_edges is the number of region-exit edges from          pred, and nr_out_edges will be the number of pred out edges          not leaving the region.  */
name|nr_out_edges
operator|-=
name|nr_rgn_out_edges
expr_stmt|;
if|if
condition|(
name|nr_rgn_out_edges
operator|>
literal|0
condition|)
name|prob
index|[
name|bb
index|]
operator|+=
literal|0.9
operator|*
name|prob
index|[
name|BLOCK_TO_BB
argument_list|(
name|pred
argument_list|)
index|]
operator|/
name|nr_out_edges
expr_stmt|;
else|else
name|prob
index|[
name|bb
index|]
operator|+=
name|prob
index|[
name|BLOCK_TO_BB
argument_list|(
name|pred
argument_list|)
index|]
operator|/
name|nr_out_edges
expr_stmt|;
name|nxt_in_edge
operator|=
name|NEXT_IN
argument_list|(
name|nxt_in_edge
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fst_in_edge
operator|!=
name|nxt_in_edge
condition|)
do|;
name|SET_BIT
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|sbitmap_difference
argument_list|(
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|ancestor_edges
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;  bb_prob(%d, %d) = %3d\n"
argument_list|,
name|bb
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|100.0
operator|*
name|prob
index|[
name|bb
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions for target info.  */
end_comment

begin_comment
comment|/* Compute in BL the list of split-edges of bb_src relatively to bb_trg.    Note that bb_trg dominates bb_src.  */
end_comment

begin_function
specifier|static
name|void
name|split_edges
parameter_list|(
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|,
name|bl
parameter_list|)
name|int
name|bb_src
decl_stmt|;
name|int
name|bb_trg
decl_stmt|;
name|edgelst
modifier|*
name|bl
decl_stmt|;
block|{
name|sbitmap
name|src
init|=
operator|(
name|edgeset
operator|)
name|sbitmap_alloc
argument_list|(
name|pot_split
index|[
name|bb_src
index|]
operator|->
name|n_bits
argument_list|)
decl_stmt|;
name|sbitmap_copy
argument_list|(
name|src
argument_list|,
name|pot_split
index|[
name|bb_src
index|]
argument_list|)
expr_stmt|;
name|sbitmap_difference
argument_list|(
name|src
argument_list|,
name|src
argument_list|,
name|pot_split
index|[
name|bb_trg
index|]
argument_list|)
expr_stmt|;
name|extract_bitlst
argument_list|(
name|src
argument_list|,
name|bl
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the valid candidate-source-blocks for the target block TRG, compute    their probability, and check if they are speculative or not.    For speculative sources, compute their update-blocks and split-blocks.  */
end_comment

begin_function
specifier|static
name|void
name|compute_trg_info
parameter_list|(
name|trg
parameter_list|)
name|int
name|trg
decl_stmt|;
block|{
name|candidate
modifier|*
name|sp
decl_stmt|;
name|edgelst
name|el
decl_stmt|;
name|int
name|check_block
decl_stmt|,
name|update_idx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|fst_edge
decl_stmt|,
name|nxt_edge
decl_stmt|;
comment|/* Define some of the fields for the target bb as well.  */
name|sp
operator|=
name|candidate_table
operator|+
name|trg
expr_stmt|;
name|sp
operator|->
name|is_valid
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|is_speculative
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|src_prob
operator|=
literal|100
expr_stmt|;
for|for
control|(
name|i
operator|=
name|trg
operator|+
literal|1
init|;
name|i
operator|<
name|current_nr_blocks
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|candidate_table
operator|+
name|i
expr_stmt|;
name|sp
operator|->
name|is_valid
operator|=
name|IS_DOMINATED
argument_list|(
name|i
argument_list|,
name|trg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|is_valid
condition|)
block|{
name|sp
operator|->
name|src_prob
operator|=
name|GET_SRC_PROB
argument_list|(
name|i
argument_list|,
name|trg
argument_list|)
expr_stmt|;
name|sp
operator|->
name|is_valid
operator|=
operator|(
name|sp
operator|->
name|src_prob
operator|>=
name|MIN_PROBABILITY
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|is_valid
condition|)
block|{
name|split_edges
argument_list|(
name|i
argument_list|,
name|trg
argument_list|,
operator|&
name|el
argument_list|)
expr_stmt|;
name|sp
operator|->
name|is_speculative
operator|=
operator|(
name|el
operator|.
name|nr_members
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|is_speculative
operator|&&
operator|!
name|flag_schedule_speculative
condition|)
name|sp
operator|->
name|is_valid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|is_valid
condition|)
block|{
name|char
modifier|*
name|update_blocks
decl_stmt|;
comment|/* Compute split blocks and store them in bblst_table. 	     The TO block of every split edge is a split block.  */
name|sp
operator|->
name|split_bbs
operator|.
name|first_member
operator|=
operator|&
name|bblst_table
index|[
name|bblst_last
index|]
expr_stmt|;
name|sp
operator|->
name|split_bbs
operator|.
name|nr_members
operator|=
name|el
operator|.
name|nr_members
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|el
operator|.
name|nr_members
condition|;
name|bblst_last
operator|++
operator|,
name|j
operator|++
control|)
name|bblst_table
index|[
name|bblst_last
index|]
operator|=
name|TO_BLOCK
argument_list|(
name|rgn_edges
index|[
name|el
operator|.
name|first_member
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
name|sp
operator|->
name|update_bbs
operator|.
name|first_member
operator|=
operator|&
name|bblst_table
index|[
name|bblst_last
index|]
expr_stmt|;
comment|/* Compute update blocks and store them in bblst_table. 	     For every split edge, look at the FROM block, and check 	     all out edges.  For each out edge that is not a split edge, 	     add the TO block to the update block list.  This list can end 	     up with a lot of duplicates.  We need to weed them out to avoid 	     overrunning the end of the bblst_table.  */
name|update_blocks
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|update_blocks
argument_list|,
literal|0
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|update_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|el
operator|.
name|nr_members
condition|;
name|j
operator|++
control|)
block|{
name|check_block
operator|=
name|FROM_BLOCK
argument_list|(
name|rgn_edges
index|[
name|el
operator|.
name|first_member
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
name|fst_edge
operator|=
name|nxt_edge
operator|=
name|OUT_EDGES
argument_list|(
name|check_block
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|update_blocks
index|[
name|TO_BLOCK
argument_list|(
name|nxt_edge
argument_list|)
index|]
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|el
operator|.
name|nr_members
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|EDGE_TO_BIT
argument_list|(
name|nxt_edge
argument_list|)
operator|==
name|el
operator|.
name|first_member
index|[
name|k
index|]
condition|)
break|break;
if|if
condition|(
name|k
operator|>=
name|el
operator|.
name|nr_members
condition|)
block|{
name|bblst_table
index|[
name|bblst_last
operator|++
index|]
operator|=
name|TO_BLOCK
argument_list|(
name|nxt_edge
argument_list|)
expr_stmt|;
name|update_blocks
index|[
name|TO_BLOCK
argument_list|(
name|nxt_edge
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
name|update_idx
operator|++
expr_stmt|;
block|}
block|}
name|nxt_edge
operator|=
name|NEXT_OUT
argument_list|(
name|nxt_edge
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fst_edge
operator|!=
name|nxt_edge
condition|)
do|;
block|}
name|sp
operator|->
name|update_bbs
operator|.
name|nr_members
operator|=
name|update_idx
expr_stmt|;
comment|/* Make sure we didn't overrun the end of bblst_table.  */
if|if
condition|(
name|bblst_last
operator|>
name|bblst_size
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|split_bbs
operator|.
name|nr_members
operator|=
name|sp
operator|->
name|update_bbs
operator|.
name|nr_members
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|is_speculative
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|src_prob
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print candidates info, for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
name|void
name|debug_candidate
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|candidate_table
index|[
name|i
index|]
operator|.
name|is_valid
condition|)
return|return;
if|if
condition|(
name|candidate_table
index|[
name|i
index|]
operator|.
name|is_speculative
condition|)
block|{
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"src b %d bb %d speculative \n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"split path: "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|candidate_table
index|[
name|i
index|]
operator|.
name|split_bbs
operator|.
name|nr_members
condition|;
name|j
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|i
index|]
operator|.
name|split_bbs
operator|.
name|first_member
index|[
name|j
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" %d "
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"update path: "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|candidate_table
index|[
name|i
index|]
operator|.
name|update_bbs
operator|.
name|nr_members
condition|;
name|j
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|i
index|]
operator|.
name|update_bbs
operator|.
name|first_member
index|[
name|j
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" %d "
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" src %d equivalent\n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print candidates info, for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
name|void
name|debug_candidates
parameter_list|(
name|trg
parameter_list|)
name|int
name|trg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"----------- candidate table: target: b=%d bb=%d ---\n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|trg
argument_list|)
argument_list|,
name|trg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|trg
operator|+
literal|1
init|;
name|i
operator|<
name|current_nr_blocks
condition|;
name|i
operator|++
control|)
name|debug_candidate
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions for speculative scheduing.  */
end_comment

begin_comment
comment|/* Return 0 if x is a set of a register alive in the beginning of one    of the split-blocks of src, otherwise return 1.  */
end_comment

begin_function
specifier|static
name|int
name|check_live_1
parameter_list|(
name|src
parameter_list|,
name|x
parameter_list|)
name|int
name|src
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|check_live_1
argument_list|(
name|src
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|1
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
comment|/* Global registers are assumed live.  */
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Check for hard registers.  */
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* Check for psuedo registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If x is a set of a register R, mark that R is alive in the beginning    of every update-block of src.  */
end_comment

begin_function
specifier|static
name|void
name|update_live_1
parameter_list|(
name|src
parameter_list|,
name|x
parameter_list|)
name|int
name|src
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|update_live_1
argument_list|(
name|src
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
comment|/* Global registers are always live, so the code below does not apply      to them.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if insn can be speculatively moved from block src to trg,    otherwise return 0.  Called before first insertion of insn to    ready-list or before the scheduling.  */
end_comment

begin_function
specifier|static
name|int
name|check_live
parameter_list|(
name|insn
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|src
decl_stmt|;
block|{
comment|/* Find the registers set by instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|check_live_1
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
operator|!
name|check_live_1
argument_list|(
name|src
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Update the live registers info after insn was moved speculatively from    block src to trg.  */
end_comment

begin_function
specifier|static
name|void
name|update_live
parameter_list|(
name|insn
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|src
decl_stmt|;
block|{
comment|/* Find the registers set by instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|update_live_1
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|update_live_1
argument_list|(
name|src
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Exception Free Loads:     We define five classes of speculative loads: IFREE, IRISKY,    PFREE, PRISKY, and MFREE.     IFREE loads are loads that are proved to be exception-free, just    by examining the load insn.  Examples for such loads are loads    from TOC and loads of global data.     IRISKY loads are loads that are proved to be exception-risky,    just by examining the load insn.  Examples for such loads are    volatile loads and loads from shared memory.     PFREE loads are loads for which we can prove, by examining other    insns, that they are exception-free.  Currently, this class consists    of loads for which we are able to find a "similar load", either in    the target block, or, if only one split-block exists, in that split    block.  Load2 is similar to load1 if both have same single base    register.  We identify only part of the similar loads, by finding    an insn upon which both load1 and load2 have a DEF-USE dependence.     PRISKY loads are loads for which we can prove, by examining other    insns, that they are exception-risky.  Currently we have two proofs for    such loads.  The first proof detects loads that are probably guarded by a    test on the memory address.  This proof is based on the    backward and forward data dependence information for the region.    Let load-insn be the examined load.    Load-insn is PRISKY iff ALL the following hold:     - insn1 is not in the same block as load-insn    - there is a DEF-USE dependence chain (insn1, ..., load-insn)    - test-insn is either a compare or a branch, not in the same block      as load-insn    - load-insn is reachable from test-insn    - there is a DEF-USE dependence chain (insn1, ..., test-insn)     This proof might fail when the compare and the load are fed    by an insn not in the region.  To solve this, we will add to this    group all loads that have no input DEF-USE dependence.     The second proof detects loads that are directly or indirectly    fed by a speculative load.  This proof is affected by the    scheduling process.  We will use the flag  fed_by_spec_load.    Initially, all insns have this flag reset.  After a speculative    motion of an insn, if insn is either a load, or marked as    fed_by_spec_load, we will also mark as fed_by_spec_load every    insn1 for which a DEF-USE dependence (insn, insn1) exists.  A    load which is fed_by_spec_load is also PRISKY.     MFREE (maybe-free) loads are all the remaining loads. They may be    exception-free, but we cannot prove it.     Now, all loads in IFREE and PFREE classes are considered    exception-free, while all loads in IRISKY and PRISKY classes are    considered exception-risky.  As for loads in the MFREE class,    these are considered either exception-free or exception-risky,    depending on whether we are pessimistic or optimistic.  We have    to take the pessimistic approach to assure the safety of    speculative scheduling, but we can take the optimistic approach    by invoking the -fsched_spec_load_dangerous option.  */
end_comment

begin_enum
enum|enum
name|INSN_TRAP_CLASS
block|{
name|TRAP_FREE
init|=
literal|0
block|,
name|IFREE
init|=
literal|1
block|,
name|PFREE_CANDIDATE
init|=
literal|2
block|,
name|PRISKY_CANDIDATE
init|=
literal|3
block|,
name|IRISKY
init|=
literal|4
block|,
name|TRAP_RISKY
init|=
literal|5
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|WORST_CLASS
parameter_list|(
name|class1
parameter_list|,
name|class2
parameter_list|)
define|\
value|((class1> class2) ? class1 : class2)
end_define

begin_comment
comment|/* Non-zero if block bb_to is equal to, or reachable from block bb_from.  */
end_comment

begin_define
define|#
directive|define
name|IS_REACHABLE
parameter_list|(
name|bb_from
parameter_list|,
name|bb_to
parameter_list|)
define|\
value|(bb_from == bb_to                                                       \    || IS_RGN_ENTRY (bb_from)						\    || (TEST_BIT (ancestor_edges[bb_to],                               \                     EDGE_TO_BIT (IN_EDGES (BB_TO_BLOCK (bb_from))))))
end_define

begin_comment
comment|/* Non-zero iff the address is comprised from at most 1 register.  */
end_comment

begin_define
define|#
directive|define
name|CONST_BASED_ADDRESS_P
parameter_list|(
name|x
parameter_list|)
define|\
value|(GET_CODE (x) == REG					\    || ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS   \ 	|| (GET_CODE (x) == LO_SUM))	                \&& (CONSTANT_P (XEXP (x, 0))		\ 	   || CONSTANT_P (XEXP (x, 1)))))
end_define

begin_comment
comment|/* Turns on the fed_by_spec_load flag for insns fed by load_insn.  */
end_comment

begin_function
specifier|static
name|void
name|set_spec_fed
parameter_list|(
name|load_insn
parameter_list|)
name|rtx
name|load_insn
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|load_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|link
argument_list|)
operator|==
name|VOIDmode
condition|)
name|FED_BY_SPEC_LOAD
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_spec_fed */
end_comment

begin_comment
comment|/* On the path from the insn to load_insn_bb, find a conditional branch depending on insn, that guards the speculative load.  */
end_comment

begin_function
specifier|static
name|int
name|find_conditional_protection
parameter_list|(
name|insn
parameter_list|,
name|load_insn_bb
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|load_insn_bb
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Iterate through DEF-USE forward dependences.  */
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|CONTAINING_RGN
argument_list|(
name|BLOCK_NUM
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|load_insn_bb
argument_list|)
argument_list|)
operator|)
operator|&&
name|IS_REACHABLE
argument_list|(
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|,
name|load_insn_bb
argument_list|)
operator|&&
name|load_insn_bb
operator|!=
name|INSN_BB
argument_list|(
name|next
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|link
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|find_conditional_protection
argument_list|(
name|next
argument_list|,
name|load_insn_bb
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* find_conditional_protection */
end_comment

begin_comment
comment|/* Returns 1 if the same insn1 that participates in the computation    of load_insn's address is feeding a conditional branch that is    guarding on load_insn. This is true if we find a the two DEF-USE    chains:    insn1 -> ... -> conditional-branch    insn1 -> ... -> load_insn,    and if a flow path exist:    insn1 -> ... -> conditional-branch -> ... -> load_insn,    and if insn1 is on the path    region-entry -> ... -> bb_trg -> ... load_insn.     Locate insn1 by climbing on LOG_LINKS from load_insn.    Locate the branch by following INSN_DEPEND from insn1.  */
end_comment

begin_function
specifier|static
name|int
name|is_conditionally_protected
parameter_list|(
name|load_insn
parameter_list|,
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
name|rtx
name|load_insn
decl_stmt|;
name|int
name|bb_src
decl_stmt|,
name|bb_trg
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|load_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn1
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Must be a DEF-USE dependence upon non-branch.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|link
argument_list|)
operator|!=
name|VOIDmode
operator|||
name|GET_CODE
argument_list|(
name|insn1
argument_list|)
operator|==
name|JUMP_INSN
condition|)
continue|continue;
comment|/* Must exist a path: region-entry -> ... -> bb_trg -> ... load_insn.  */
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
operator|==
name|bb_src
operator|||
operator|(
name|CONTAINING_RGN
argument_list|(
name|BLOCK_NUM
argument_list|(
name|insn1
argument_list|)
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb_src
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_REACHABLE
argument_list|(
name|bb_trg
argument_list|,
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
argument_list|)
operator|&&
operator|!
name|IS_REACHABLE
argument_list|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
argument_list|,
name|bb_trg
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Now search for the conditional-branch.  */
if|if
condition|(
name|find_conditional_protection
argument_list|(
name|insn1
argument_list|,
name|bb_src
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Recursive step: search another insn1, "above" current insn1.  */
return|return
name|is_conditionally_protected
argument_list|(
name|insn1
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
return|;
block|}
comment|/* The chain does not exist.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* is_conditionally_protected */
end_comment

begin_comment
comment|/* Returns 1 if a clue for "similar load" 'insn2' is found, and hence    load_insn can move speculatively from bb_src to bb_trg.  All the    following must hold:     (1) both loads have 1 base register (PFREE_CANDIDATEs).    (2) load_insn and load1 have a def-use dependence upon    the same insn 'insn1'.    (3) either load2 is in bb_trg, or:    - there's only one split-block, and    - load1 is on the escape path, and     From all these we can conclude that the two loads access memory    addresses that differ at most by a constant, and hence if moving    load_insn would cause an exception, it would have been caused by    load2 anyhow.  */
end_comment

begin_function
specifier|static
name|int
name|is_pfree
parameter_list|(
name|load_insn
parameter_list|,
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
name|rtx
name|load_insn
decl_stmt|;
name|int
name|bb_src
decl_stmt|,
name|bb_trg
decl_stmt|;
block|{
name|rtx
name|back_link
decl_stmt|;
name|candidate
modifier|*
name|candp
init|=
name|candidate_table
operator|+
name|bb_src
decl_stmt|;
if|if
condition|(
name|candp
operator|->
name|split_bbs
operator|.
name|nr_members
operator|!=
literal|1
condition|)
comment|/* Must have exactly one escape block.  */
return|return
literal|0
return|;
for|for
control|(
name|back_link
operator|=
name|LOG_LINKS
argument_list|(
name|load_insn
argument_list|)
init|;
name|back_link
condition|;
name|back_link
operator|=
name|XEXP
argument_list|(
name|back_link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn1
init|=
name|XEXP
argument_list|(
name|back_link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|back_link
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* Found a DEF-USE dependence (insn1, load_insn).  */
name|rtx
name|fore_link
decl_stmt|;
for|for
control|(
name|fore_link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn1
argument_list|)
init|;
name|fore_link
condition|;
name|fore_link
operator|=
name|XEXP
argument_list|(
name|fore_link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn2
init|=
name|XEXP
argument_list|(
name|fore_link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|fore_link
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* Found a DEF-USE dependence (insn1, insn2).  */
if|if
condition|(
name|haifa_classify_insn
argument_list|(
name|insn2
argument_list|)
operator|!=
name|PFREE_CANDIDATE
condition|)
comment|/* insn2 not guaranteed to be a 1 base reg load.  */
continue|continue;
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn2
argument_list|)
operator|==
name|bb_trg
condition|)
comment|/* insn2 is the similar load, in the target block.  */
return|return
literal|1
return|;
if|if
condition|(
operator|*
operator|(
name|candp
operator|->
name|split_bbs
operator|.
name|first_member
operator|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn2
argument_list|)
condition|)
comment|/* insn2 is a similar load, in a split-block.  */
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
comment|/* Couldn't find a similar load.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* is_pfree */
end_comment

begin_comment
comment|/* Returns a class that insn with GET_DEST(insn)=x may belong to,    as found by analyzing insn's expression.  */
end_comment

begin_function
specifier|static
name|int
name|may_trap_exp
parameter_list|(
name|x
parameter_list|,
name|is_store
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|is_store
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|TRAP_FREE
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_store
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|TRAP_RISKY
return|;
else|else
return|return
name|TRAP_FREE
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
comment|/* The insn uses memory:  a volatile load.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|IRISKY
return|;
comment|/* An exception-free load.  */
if|if
condition|(
operator|!
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|IFREE
return|;
comment|/* A load with 1 base register, to be further checked.  */
if|if
condition|(
name|CONST_BASED_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|PFREE_CANDIDATE
return|;
comment|/* No info on the load, to be further checked.  */
return|return
name|PRISKY_CANDIDATE
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|insn_class
init|=
name|TRAP_FREE
decl_stmt|;
comment|/* Neither store nor load, check if it may cause a trap.  */
if|if
condition|(
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|TRAP_RISKY
return|;
comment|/* Recursive step: walk the insn...  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|int
name|tmp_class
init|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|is_store
argument_list|)
decl_stmt|;
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|tmp_class
init|=
name|may_trap_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|is_store
argument_list|)
decl_stmt|;
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
return|return
name|insn_class
return|;
block|}
block|}
end_function

begin_comment
comment|/* Classifies insn for the purpose of verifying that it can be    moved speculatively, by examining it's patterns, returning:    TRAP_RISKY: store, or risky non-load insn (e.g. division by variable).    TRAP_FREE: non-load insn.    IFREE: load from a globaly safe location.    IRISKY: volatile load.    PFREE_CANDIDATE, PRISKY_CANDIDATE: load that need to be checked for    being either PFREE or PRISKY.  */
end_comment

begin_function
specifier|static
name|int
name|haifa_classify_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|tmp_class
init|=
name|TRAP_FREE
decl_stmt|;
name|int
name|insn_class
init|=
name|TRAP_FREE
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CLOBBER
case|:
comment|/* Test if it is a 'store'.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
comment|/* Test if it is a store.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_class
operator|==
name|TRAP_RISKY
condition|)
break|break;
comment|/* Test if it is a load.  */
name|tmp_class
operator|=
name|WORST_CLASS
argument_list|(
name|tmp_class
argument_list|,
name|may_trap_exp
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXEC
case|:
case|case
name|TRAP_IF
case|:
name|tmp_class
operator|=
name|TRAP_RISKY
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
block|}
else|else
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CLOBBER
case|:
comment|/* Test if it is a 'store'.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
comment|/* Test if it is a store.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_class
operator|==
name|TRAP_RISKY
condition|)
break|break;
comment|/* Test if it is a load.  */
name|tmp_class
operator|=
name|WORST_CLASS
argument_list|(
name|tmp_class
argument_list|,
name|may_trap_exp
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXEC
case|:
case|case
name|TRAP_IF
case|:
name|tmp_class
operator|=
name|TRAP_RISKY
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|insn_class
operator|=
name|tmp_class
expr_stmt|;
block|}
return|return
name|insn_class
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if load_insn is prisky (i.e. if load_insn is fed by    a load moved speculatively, or if load_insn is protected by    a compare on load_insn's address).  */
end_comment

begin_function
specifier|static
name|int
name|is_prisky
parameter_list|(
name|load_insn
parameter_list|,
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
name|rtx
name|load_insn
decl_stmt|;
name|int
name|bb_src
decl_stmt|,
name|bb_trg
decl_stmt|;
block|{
if|if
condition|(
name|FED_BY_SPEC_LOAD
argument_list|(
name|load_insn
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|LOG_LINKS
argument_list|(
name|load_insn
argument_list|)
operator|==
name|NULL
condition|)
comment|/* Dependence may 'hide' out of the region.  */
return|return
literal|1
return|;
if|if
condition|(
name|is_conditionally_protected
argument_list|(
name|load_insn
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insn is a candidate to be moved speculatively from bb_src to bb_trg.    Return 1 if insn is exception-free (and the motion is valid)    and 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|is_exception_free
parameter_list|(
name|insn
parameter_list|,
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|bb_src
decl_stmt|,
name|bb_trg
decl_stmt|;
block|{
name|int
name|insn_class
init|=
name|haifa_classify_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Handle non-load insns.  */
switch|switch
condition|(
name|insn_class
condition|)
block|{
case|case
name|TRAP_FREE
case|:
return|return
literal|1
return|;
case|case
name|TRAP_RISKY
case|:
return|return
literal|0
return|;
default|default:
empty_stmt|;
block|}
comment|/* Handle loads.  */
if|if
condition|(
operator|!
name|flag_schedule_speculative_load
condition|)
return|return
literal|0
return|;
name|IS_LOAD_INSN
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|insn_class
condition|)
block|{
case|case
name|IFREE
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|IRISKY
case|:
return|return
literal|0
return|;
case|case
name|PFREE_CANDIDATE
case|:
if|if
condition|(
name|is_pfree
argument_list|(
name|insn
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Don't 'break' here: PFREE-candidate is also PRISKY-candidate.  */
case|case
name|PRISKY_CANDIDATE
case|:
if|if
condition|(
operator|!
name|flag_schedule_speculative_load_dangerous
operator|||
name|is_prisky
argument_list|(
name|insn
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|flag_schedule_speculative_load_dangerous
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The number of insns from the current block scheduled so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sched_target_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of insns from the current block to be scheduled in total.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of insns from the entire region scheduled so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sched_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the last scheduled insn was a jump.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_was_jump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implementations of the sched_info functions for region scheduling.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_ready_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ready_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_schedule_ready_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|new_ready
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|schedule_more_p
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rgn_print_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rgn_rank
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|contributes_to_priority
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_jump_reg_dependencies
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|regset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return nonzero if there are more insns that should be scheduled.  */
end_comment

begin_function
specifier|static
name|int
name|schedule_more_p
parameter_list|()
block|{
return|return
operator|!
name|last_was_jump
operator|&&
name|sched_target_n_insns
operator|<
name|target_n_insns
return|;
block|}
end_function

begin_comment
comment|/* Add all insns that are initially ready to the ready list READY.  Called    once before scheduling a set of insns.  */
end_comment

begin_function
specifier|static
name|void
name|init_ready_list
parameter_list|(
name|ready
parameter_list|)
name|struct
name|ready_list
modifier|*
name|ready
decl_stmt|;
block|{
name|rtx
name|prev_head
init|=
name|current_sched_info
operator|->
name|prev_head
decl_stmt|;
name|rtx
name|next_tail
init|=
name|current_sched_info
operator|->
name|next_tail
decl_stmt|;
name|int
name|bb_src
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|target_n_insns
operator|=
literal|0
expr_stmt|;
name|sched_target_n_insns
operator|=
literal|0
expr_stmt|;
name|sched_n_insns
operator|=
literal|0
expr_stmt|;
name|last_was_jump
operator|=
literal|0
expr_stmt|;
comment|/* Print debugging information.  */
if|if
condition|(
name|sched_verbose
operator|>=
literal|5
condition|)
name|debug_dependencies
argument_list|()
expr_stmt|;
comment|/* Prepare current target block info.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|candidate_table
operator|=
operator|(
name|candidate
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|bblst_last
operator|=
literal|0
expr_stmt|;
comment|/* bblst_table holds split blocks and update blocks for each block after 	 the current one in the region.  split blocks and update blocks are 	 the TO blocks of region edges, so there can be at most rgn_nr_edges 	 of them.  */
name|bblst_size
operator|=
operator|(
name|current_nr_blocks
operator|-
name|target_bb
operator|)
operator|*
name|rgn_nr_edges
expr_stmt|;
name|bblst_table
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|bblst_size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bitlst_table_last
operator|=
literal|0
expr_stmt|;
name|bitlst_table_size
operator|=
name|rgn_nr_edges
expr_stmt|;
name|bitlst_table
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|rgn_nr_edges
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|compute_trg_info
argument_list|(
name|target_bb
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize ready list with all 'ready' insns in target block.      Count number of insns in the target block being scheduled.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|SCHED_GROUP_P
argument_list|(
name|next
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|INSN_P
argument_list|(
name|next
argument_list|)
operator|)
condition|)
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|target_n_insns
operator|++
expr_stmt|;
block|}
comment|/* Add to ready list all 'ready' insns in valid source blocks.      For speculative insns, check-live, exception-free, and      issue-delay.  */
for|for
control|(
name|bb_src
operator|=
name|target_bb
operator|+
literal|1
init|;
name|bb_src
operator|<
name|current_nr_blocks
condition|;
name|bb_src
operator|++
control|)
if|if
condition|(
name|IS_VALID
argument_list|(
name|bb_src
argument_list|)
condition|)
block|{
name|rtx
name|src_head
decl_stmt|;
name|rtx
name|src_next_tail
decl_stmt|;
name|rtx
name|tail
decl_stmt|,
name|head
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb_src
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|src_next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|src_head
operator|=
name|head
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|src_head
init|;
name|insn
operator|!=
name|src_next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|!
name|IS_SPECULATIVE_INSN
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|insn_issue_delay
argument_list|(
name|insn
argument_list|)
operator|<=
literal|3
operator|&&
name|check_live
argument_list|(
name|insn
argument_list|,
name|bb_src
argument_list|)
operator|&&
name|is_exception_free
argument_list|(
name|insn
argument_list|,
name|bb_src
argument_list|,
name|target_bb
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|next
decl_stmt|;
comment|/* Note that we haven't squirreled away the notes for 		   blocks other than the current.  So if this is a 		   speculative insn, NEXT might otherwise be a note.  */
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|next
operator|||
name|SCHED_GROUP_P
argument_list|(
name|next
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|INSN_P
argument_list|(
name|next
argument_list|)
operator|)
condition|)
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called after taking INSN from the ready list.  Returns nonzero if this    insn can be scheduled, nonzero if we should silently discard it.  */
end_comment

begin_function
specifier|static
name|int
name|can_schedule_ready_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|last_was_jump
operator|=
literal|1
expr_stmt|;
comment|/* An interblock motion?  */
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn
argument_list|)
operator|!=
name|target_bb
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|basic_block
name|b1
decl_stmt|;
if|if
condition|(
name|IS_SPECULATIVE_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|check_live
argument_list|(
name|insn
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|update_live
argument_list|(
name|insn
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For speculative load, mark insns fed by it.  */
if|if
condition|(
name|IS_LOAD_INSN
argument_list|(
name|insn
argument_list|)
operator|||
name|FED_BY_SPEC_LOAD
argument_list|(
name|insn
argument_list|)
condition|)
name|set_spec_fed
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|nr_spec
operator|++
expr_stmt|;
block|}
name|nr_inter
operator|++
expr_stmt|;
comment|/* Find the beginning of the scheduling group.  */
comment|/* ??? Ought to update basic block here, but later bits of 	 schedule_block assumes the original insn block is 	 still intact.  */
name|temp
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|temp
argument_list|)
condition|)
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Update source block boundaries.  */
name|b1
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|b1
operator|->
name|head
operator|&&
name|insn
operator|==
name|b1
operator|->
name|end
condition|)
block|{
comment|/* We moved all the insns in the basic block. 	     Emit a note after the last insn and update the 	     begin/end boundaries to point to the note.  */
name|rtx
name|note
init|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|b1
operator|->
name|head
operator|=
name|note
expr_stmt|;
name|b1
operator|->
name|end
operator|=
name|note
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
name|b1
operator|->
name|end
condition|)
block|{
comment|/* We took insns from the end of the basic block, 	     so update the end of block boundary so that it 	     points to the first insn we did not move.  */
name|b1
operator|->
name|end
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp
operator|==
name|b1
operator|->
name|head
condition|)
block|{
comment|/* We took insns from the start of the basic block, 	     so update the start of block boundary so that 	     it points to the first insn we did not move.  */
name|b1
operator|->
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* In block motion.  */
name|sched_target_n_insns
operator|++
expr_stmt|;
block|}
name|sched_n_insns
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Called after INSN has all its dependencies resolved.  Return nonzero    if it should be moved to the ready list or the queue, or zero if we    should silently discard it.  */
end_comment

begin_function
specifier|static
name|int
name|new_ready
parameter_list|(
name|next
parameter_list|)
name|rtx
name|next
decl_stmt|;
block|{
comment|/* For speculative insns, before inserting to ready/queue,      check live, exception-free, and issue-delay.  */
if|if
condition|(
name|INSN_BB
argument_list|(
name|next
argument_list|)
operator|!=
name|target_bb
operator|&&
operator|(
operator|!
name|IS_VALID
argument_list|(
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|)
operator|||
name|CANT_MOVE
argument_list|(
name|next
argument_list|)
operator|||
operator|(
name|IS_SPECULATIVE_INSN
argument_list|(
name|next
argument_list|)
operator|&&
operator|(
name|insn_issue_delay
argument_list|(
name|next
argument_list|)
operator|>
literal|3
operator|||
operator|!
name|check_live
argument_list|(
name|next
argument_list|,
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|)
operator|||
operator|!
name|is_exception_free
argument_list|(
name|next
argument_list|,
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|,
name|target_bb
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a string that contains the insn uid and optionally anything else    necessary to identify this insn in an output.  It's valid to use a    static buffer for this.  The ALIGNED parameter should cause the string    to be formatted so that multiple output lines will line up nicely.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rgn_print_insn
parameter_list|(
name|insn
parameter_list|,
name|aligned
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|aligned
decl_stmt|;
block|{
specifier|static
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|aligned
condition|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"b%3d: i%4d"
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
operator|&&
name|INSN_BB
argument_list|(
name|insn
argument_list|)
operator|!=
name|target_bb
condition|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%d/b%d"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%d"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Compare priority of two insns.  Return a positive number if the second    insn is to be preferred for scheduling, and a negative one if the first    is to be preferred.  Zero if they are equally good.  */
end_comment

begin_function
specifier|static
name|int
name|rgn_rank
parameter_list|(
name|insn1
parameter_list|,
name|insn2
parameter_list|)
name|rtx
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
block|{
comment|/* Some comparison make sense in interblock scheduling only.  */
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
operator|!=
name|INSN_BB
argument_list|(
name|insn2
argument_list|)
condition|)
block|{
name|int
name|spec_val
decl_stmt|,
name|prob_val
decl_stmt|;
comment|/* Prefer an inblock motion on an interblock motion.  */
if|if
condition|(
operator|(
name|INSN_BB
argument_list|(
name|insn2
argument_list|)
operator|==
name|target_bb
operator|)
operator|&&
operator|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
operator|!=
name|target_bb
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
operator|==
name|target_bb
operator|)
operator|&&
operator|(
name|INSN_BB
argument_list|(
name|insn2
argument_list|)
operator|!=
name|target_bb
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Prefer a useful motion on a speculative one.  */
name|spec_val
operator|=
name|IS_SPECULATIVE_INSN
argument_list|(
name|insn1
argument_list|)
operator|-
name|IS_SPECULATIVE_INSN
argument_list|(
name|insn2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_val
condition|)
return|return
name|spec_val
return|;
comment|/* Prefer a more probable (speculative) insn.  */
name|prob_val
operator|=
name|INSN_PROBABILITY
argument_list|(
name|insn2
argument_list|)
operator|-
name|INSN_PROBABILITY
argument_list|(
name|insn1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prob_val
condition|)
return|return
name|prob_val
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* NEXT is an instruction that depends on INSN (a backward dependence);    return nonzero if we should include this dependence in priority    calculations.  */
end_comment

begin_function
specifier|static
name|int
name|contributes_to_priority
parameter_list|(
name|next
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|next
decl_stmt|,
name|insn
decl_stmt|;
block|{
return|return
name|BLOCK_NUM
argument_list|(
name|next
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* INSN is a JUMP_INSN.  Store the set of registers that must be considered    to be set by this jump in SET.  */
end_comment

begin_function
specifier|static
name|void
name|compute_jump_reg_dependencies
parameter_list|(
name|insn
parameter_list|,
name|set
parameter_list|)
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|regset
name|set
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Nothing to do here, since we postprocess jumps in      add_branch_dependences.  */
block|}
end_function

begin_comment
comment|/* Used in schedule_insns to initialize current_sched_info for scheduling    regions (or single basic blocks).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sched_info
name|region_sched_info
init|=
block|{
name|init_ready_list
block|,
name|can_schedule_ready_p
block|,
name|schedule_more_p
block|,
name|new_ready
block|,
name|rgn_rank
block|,
name|rgn_print_insn
block|,
name|contributes_to_priority
block|,
name|compute_jump_reg_dependencies
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add dependences so that branches are scheduled to run last in their    block.  */
end_comment

begin_function
specifier|static
name|void
name|add_branch_dependences
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|;
comment|/* For all branches, calls, uses, clobbers, and cc0 setters, force them      to remain in order at the end of the block by adding dependencies and      giving the last a high priority.  There may be notes present, and      prev_head may also be a note.       Branches must obviously remain at the end.  Calls should remain at the      end since moving them results in worse register allocation.  Uses remain      at the end to ensure proper register allocation.  cc0 setters remaim      at the end because they can't be moved away from their cc0 user.  */
name|insn
operator|=
name|tail
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
endif|#
directive|endif
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
if|if
condition|(
name|last
operator|!=
literal|0
operator|&&
operator|!
name|find_insn_list
argument_list|(
name|insn
argument_list|,
name|LOG_LINKS
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
name|add_dependence
argument_list|(
name|last
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|++
expr_stmt|;
block|}
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
comment|/* Skip over insns that are part of a group. 	     Make each insn explicitly depend on the previous insn. 	     This ensures that only the group header will ever enter 	     the ready queue (and, when scheduled, will automatically 	     schedule the SCHED_GROUP_P block).  */
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|temp
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|insn
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* Don't overrun the bounds of the basic block.  */
if|if
condition|(
name|insn
operator|==
name|head
condition|)
break|break;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure these insns are scheduled last in their block.  */
name|insn
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|insn
operator|!=
literal|0
condition|)
while|while
condition|(
name|insn
operator|!=
name|head
condition|)
block|{
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|add_dependence
argument_list|(
name|last
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Skip over insns that are part of a group.  */
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Data structures for the computation of data dependences in a regions.  We    keep one `deps' structure for every basic block.  Before analyzing the    data dependences for a bb, its variables are initialized as a function of    the variables of its predecessors.  When the analysis for a bb completes,    we save the contents to the corresponding bb_deps[bb] variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|deps
modifier|*
name|bb_deps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Duplicate the INSN_LIST elements of COPY and prepend them to OLD.  */
end_comment

begin_function
specifier|static
name|rtx
name|concat_INSN_LIST
parameter_list|(
name|copy
parameter_list|,
name|old
parameter_list|)
name|rtx
name|copy
decl_stmt|,
name|old
decl_stmt|;
block|{
name|rtx
name|new
init|=
name|old
decl_stmt|;
for|for
control|(
init|;
name|copy
condition|;
name|copy
operator|=
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
control|)
name|new
operator|=
name|alloc_INSN_LIST
argument_list|(
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|concat_insn_mem_list
parameter_list|(
name|copy_insns
parameter_list|,
name|copy_mems
parameter_list|,
name|old_insns_p
parameter_list|,
name|old_mems_p
parameter_list|)
name|rtx
name|copy_insns
decl_stmt|,
name|copy_mems
decl_stmt|;
name|rtx
modifier|*
name|old_insns_p
decl_stmt|,
decl|*
name|old_mems_p
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|new_insns
init|=
operator|*
name|old_insns_p
decl_stmt|;
name|rtx
name|new_mems
init|=
operator|*
name|old_mems_p
decl_stmt|;
while|while
condition|(
name|copy_insns
condition|)
block|{
name|new_insns
operator|=
name|alloc_INSN_LIST
argument_list|(
name|XEXP
argument_list|(
name|copy_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_insns
argument_list|)
expr_stmt|;
name|new_mems
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|copy_mems
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_mems
argument_list|)
expr_stmt|;
name|copy_insns
operator|=
name|XEXP
argument_list|(
name|copy_insns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|copy_mems
operator|=
name|XEXP
argument_list|(
name|copy_mems
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|old_insns_p
operator|=
name|new_insns
expr_stmt|;
operator|*
name|old_mems_p
operator|=
name|new_mems
expr_stmt|;
block|}
end_block

begin_comment
comment|/* After computing the dependencies for block BB, propagate the dependencies    found in TMP_DEPS to the successors of the block.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_deps
parameter_list|(
name|bb
parameter_list|,
name|pred_deps
parameter_list|)
name|int
name|bb
decl_stmt|;
name|struct
name|deps
modifier|*
name|pred_deps
decl_stmt|;
block|{
name|int
name|b
init|=
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|int
name|e
decl_stmt|,
name|first_edge
decl_stmt|;
comment|/* bb's structures are inherited by its successors.  */
name|first_edge
operator|=
name|e
operator|=
name|OUT_EDGES
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|>
literal|0
condition|)
do|do
block|{
name|int
name|b_succ
init|=
name|TO_BLOCK
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|int
name|bb_succ
init|=
name|BLOCK_TO_BB
argument_list|(
name|b_succ
argument_list|)
decl_stmt|;
name|struct
name|deps
modifier|*
name|succ_deps
init|=
name|bb_deps
operator|+
name|bb_succ
decl_stmt|;
name|int
name|reg
decl_stmt|;
comment|/* Only bbs "below" bb, in the same region, are interesting.  */
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|b
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|b_succ
argument_list|)
operator|||
name|bb_succ
operator|<=
name|bb
condition|)
block|{
name|e
operator|=
name|NEXT_OUT
argument_list|(
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* The reg_last lists are inherited by bb_succ.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&pred_deps->reg_last_in_use
argument_list|,
literal|0
argument_list|,
argument|reg
argument_list|,
argument|{ 	    struct deps_reg *pred_rl =&pred_deps->reg_last[reg]; 	    struct deps_reg *succ_rl =&succ_deps->reg_last[reg];  	    succ_rl->uses = concat_INSN_LIST (pred_rl->uses, succ_rl->uses); 	    succ_rl->sets = concat_INSN_LIST (pred_rl->sets, succ_rl->sets); 	    succ_rl->clobbers = concat_INSN_LIST (pred_rl->clobbers, 						  succ_rl->clobbers); 	    succ_rl->uses_length += pred_rl->uses_length; 	    succ_rl->clobbers_length += pred_rl->clobbers_length; 	  }
argument_list|)
empty_stmt|;
name|IOR_REG_SET
argument_list|(
operator|&
name|succ_deps
operator|->
name|reg_last_in_use
argument_list|,
operator|&
name|pred_deps
operator|->
name|reg_last_in_use
argument_list|)
expr_stmt|;
comment|/* Mem read/write lists are inherited by bb_succ.  */
name|concat_insn_mem_list
argument_list|(
name|pred_deps
operator|->
name|pending_read_insns
argument_list|,
name|pred_deps
operator|->
name|pending_read_mems
argument_list|,
operator|&
name|succ_deps
operator|->
name|pending_read_insns
argument_list|,
operator|&
name|succ_deps
operator|->
name|pending_read_mems
argument_list|)
expr_stmt|;
name|concat_insn_mem_list
argument_list|(
name|pred_deps
operator|->
name|pending_write_insns
argument_list|,
name|pred_deps
operator|->
name|pending_write_mems
argument_list|,
operator|&
name|succ_deps
operator|->
name|pending_write_insns
argument_list|,
operator|&
name|succ_deps
operator|->
name|pending_write_mems
argument_list|)
expr_stmt|;
name|succ_deps
operator|->
name|last_pending_memory_flush
operator|=
name|concat_INSN_LIST
argument_list|(
name|pred_deps
operator|->
name|last_pending_memory_flush
argument_list|,
name|succ_deps
operator|->
name|last_pending_memory_flush
argument_list|)
expr_stmt|;
name|succ_deps
operator|->
name|pending_lists_length
operator|+=
name|pred_deps
operator|->
name|pending_lists_length
expr_stmt|;
name|succ_deps
operator|->
name|pending_flush_length
operator|+=
name|pred_deps
operator|->
name|pending_flush_length
expr_stmt|;
comment|/* last_function_call is inherited by bb_succ.  */
name|succ_deps
operator|->
name|last_function_call
operator|=
name|concat_INSN_LIST
argument_list|(
name|pred_deps
operator|->
name|last_function_call
argument_list|,
name|succ_deps
operator|->
name|last_function_call
argument_list|)
expr_stmt|;
comment|/* sched_before_next_call is inherited by bb_succ.  */
name|succ_deps
operator|->
name|sched_before_next_call
operator|=
name|concat_INSN_LIST
argument_list|(
name|pred_deps
operator|->
name|sched_before_next_call
argument_list|,
name|succ_deps
operator|->
name|sched_before_next_call
argument_list|)
expr_stmt|;
name|e
operator|=
name|NEXT_OUT
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|e
operator|!=
name|first_edge
condition|)
do|;
comment|/* These lists should point to the right place, for correct      freeing later.  */
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_read_insns
operator|=
name|pred_deps
operator|->
name|pending_read_insns
expr_stmt|;
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_read_mems
operator|=
name|pred_deps
operator|->
name|pending_read_mems
expr_stmt|;
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_write_insns
operator|=
name|pred_deps
operator|->
name|pending_write_insns
expr_stmt|;
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_write_mems
operator|=
name|pred_deps
operator|->
name|pending_write_mems
expr_stmt|;
comment|/* Can't allow these to be freed twice.  */
name|pred_deps
operator|->
name|pending_read_insns
operator|=
literal|0
expr_stmt|;
name|pred_deps
operator|->
name|pending_read_mems
operator|=
literal|0
expr_stmt|;
name|pred_deps
operator|->
name|pending_write_insns
operator|=
literal|0
expr_stmt|;
name|pred_deps
operator|->
name|pending_write_mems
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute backward dependences inside bb.  In a multiple blocks region:    (1) a bb is analyzed after its predecessors, and (2) the lists in    effect at the end of bb (after analyzing for bb) are inherited by    bb's successrs.     Specifically for reg-reg data dependences, the block insns are    scanned by sched_analyze () top-to-bottom.  Two lists are    maintained by sched_analyze (): reg_last[].sets for register DEFs,    and reg_last[].uses for register USEs.     When analysis is completed for bb, we update for its successors:    ;  - DEFS[succ] = Union (DEFS [succ], DEFS [bb])    ;  - USES[succ] = Union (USES [succ], DEFS [bb])     The mechanism for computing mem-mem data dependence is very    similar, and the result is interblock dependences in the region.  */
end_comment

begin_function
specifier|static
name|void
name|compute_block_backward_dependences
parameter_list|(
name|bb
parameter_list|)
name|int
name|bb
decl_stmt|;
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|struct
name|deps
name|tmp_deps
decl_stmt|;
name|tmp_deps
operator|=
name|bb_deps
index|[
name|bb
index|]
expr_stmt|;
comment|/* Do the analysis for this block.  */
name|get_block_head_tail
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|sched_analyze
argument_list|(
operator|&
name|tmp_deps
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|add_branch_dependences
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
name|propagate_deps
argument_list|(
name|bb
argument_list|,
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
comment|/* Free up the INSN_LISTs.  */
name|free_deps
argument_list|(
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove all INSN_LISTs and EXPR_LISTs from the pending lists and add    them to the unused_*_list variables, so that they can be reused.  */
end_comment

begin_function
specifier|static
name|void
name|free_pending_lists
parameter_list|()
block|{
name|int
name|bb
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|free_INSN_LIST_list
argument_list|(
operator|&
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_read_insns
argument_list|)
expr_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_write_insns
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_read_mems
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|bb_deps
index|[
name|bb
index|]
operator|.
name|pending_write_mems
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print dependences for debugging, callable from debugger.  */
end_comment

begin_function
name|void
name|debug_dependencies
parameter_list|()
block|{
name|int
name|bb
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   --------------- forward dependences: ------------ \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
if|if
condition|(
literal|1
condition|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n;;   --- Region Dependences --- b %d bb %d \n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   %7s%6s%6s%6s%6s%6s%11s%6s\n"
argument_list|,
literal|"insn"
argument_list|,
literal|"code"
argument_list|,
literal|"bb"
argument_list|,
literal|"dep"
argument_list|,
literal|"prio"
argument_list|,
literal|"cost"
argument_list|,
literal|"blockage"
argument_list|,
literal|"units"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   %7s%6s%6s%6s%6s%6s%11s%6s\n"
argument_list|,
literal|"----"
argument_list|,
literal|"----"
argument_list|,
literal|"--"
argument_list|,
literal|"---"
argument_list|,
literal|"----"
argument_list|,
literal|"----"
argument_list|,
literal|"--------"
argument_list|,
literal|"-----"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|range
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|n
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   %6d "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|n
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"%s\n"
argument_list|,
name|GET_NOTE_INSN_NAME
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"line %d, file %s\n"
argument_list|,
name|n
argument_list|,
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" {%s}\n"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|unit
operator|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|range
operator|=
operator|(
name|unit
operator|<
literal|0
operator|||
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   %s%5d%6d%6d%6d%6d%6d  %3d -%3d   "
argument_list|,
operator|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|?
literal|"+"
else|:
literal|" "
operator|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn_cost
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|MIN_BLOCKAGE_COST
argument_list|(
name|range
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|MAX_BLOCKAGE_COST
argument_list|(
name|range
argument_list|)
argument_list|)
expr_stmt|;
name|insn_print_units
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\t: "
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"%d "
argument_list|,
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Schedule a region.  A region is either an inner loop, a loop-free    subroutine, or a single basic block.  Each bb in the region is    scheduled after its flow predecessors.  */
end_comment

begin_function
specifier|static
name|void
name|schedule_region
parameter_list|(
name|rgn
parameter_list|)
name|int
name|rgn
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
name|int
name|rgn_n_insns
init|=
literal|0
decl_stmt|;
name|int
name|sched_rgn_n_insns
init|=
literal|0
decl_stmt|;
comment|/* Set variables for the current region.  */
name|current_nr_blocks
operator|=
name|RGN_NR_BLOCKS
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
name|current_blocks
operator|=
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
name|init_deps_global
argument_list|()
expr_stmt|;
comment|/* Initializations for region data dependence analyisis.  */
name|bb_deps
operator|=
operator|(
expr|struct
name|deps
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|deps
argument_list|)
operator|*
name|current_nr_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
name|init_deps
argument_list|(
name|bb_deps
operator|+
name|bb
argument_list|)
expr_stmt|;
comment|/* Compute LOG_LINKS.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
name|compute_block_backward_dependences
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Compute INSN_DEPEND.  */
for|for
control|(
name|bb
operator|=
name|current_nr_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|compute_forward_dependences
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* Set priorities.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|rgn_n_insns
operator|+=
name|set_priorities
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* Compute interblock info: probabilities, split-edges, dominators, etc.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|prob
operator|=
operator|(
name|float
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|current_nr_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
name|dom
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|current_nr_blocks
argument_list|,
name|current_nr_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|dom
argument_list|,
name|current_nr_blocks
argument_list|)
expr_stmt|;
comment|/* Edge to bit.  */
name|rgn_nr_edges
operator|=
literal|0
expr_stmt|;
name|edge_to_bit
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|nr_edges
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nr_edges
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|FROM_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|rgn
condition|)
name|EDGE_TO_BIT
argument_list|(
name|i
argument_list|)
operator|=
name|rgn_nr_edges
operator|++
expr_stmt|;
name|rgn_edges
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|rgn_nr_edges
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|rgn_nr_edges
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nr_edges
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|FROM_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
operator|(
name|rgn
operator|)
condition|)
name|rgn_edges
index|[
name|rgn_nr_edges
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* Split edges.  */
name|pot_split
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|current_nr_blocks
argument_list|,
name|rgn_nr_edges
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|pot_split
argument_list|,
name|current_nr_blocks
argument_list|)
expr_stmt|;
name|ancestor_edges
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|current_nr_blocks
argument_list|,
name|rgn_nr_edges
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ancestor_edges
argument_list|,
name|current_nr_blocks
argument_list|)
expr_stmt|;
comment|/* Compute probabilities, dominators, split_edges.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
name|compute_dom_prob_ps
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
comment|/* Now we can schedule all blocks.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|b
init|=
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|b
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_real_insns_p
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
condition|)
continue|continue;
name|current_sched_info
operator|->
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|save_line_notes
argument_list|(
name|b
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|rm_line_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* rm_other_notes only removes notes which are _inside_ the 	 block---that is, it won't remove notes before the first real insn  	 or after the last real insn of the block.  So if the first insn 	 has a REG_SAVE_NOTE which would otherwise be emitted before the 	 insn, it is redundant with the note before the start of the 	 block, and so we have to take it out.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|head
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_SAVE_NOTE
condition|)
block|{
name|remove_note
argument_list|(
name|head
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|head
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove remaining note insns from the block, save them in 	 note_list.  These notes are restored at the end of 	 schedule_block ().  */
name|rm_other_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|target_bb
operator|=
name|bb
expr_stmt|;
name|current_sched_info
operator|->
name|queue_must_finish_empty
operator|=
name|current_nr_blocks
operator|>
literal|1
operator|&&
operator|!
name|flag_schedule_interblock
expr_stmt|;
name|schedule_block
argument_list|(
name|b
argument_list|,
name|rgn_n_insns
argument_list|)
expr_stmt|;
name|sched_rgn_n_insns
operator|+=
name|sched_n_insns
expr_stmt|;
comment|/* Update target block boundaries.  */
if|if
condition|(
name|head
operator|==
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
condition|)
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|current_sched_info
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|=
name|current_sched_info
operator|->
name|tail
expr_stmt|;
comment|/* Clean up.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|candidate_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bblst_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bitlst_table
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Sanity check: verify that all region insns were scheduled.  */
if|if
condition|(
name|sched_rgn_n_insns
operator|!=
name|rgn_n_insns
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Restore line notes.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|restore_line_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Done with this region.  */
name|free_pending_lists
argument_list|()
expr_stmt|;
name|finish_deps_global
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|bb_deps
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|prob
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|dom
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|pot_split
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|ancestor_edges
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edge_to_bit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rgn_edges
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Indexed by region, holds the number of death notes found in that region.    Used for consistency checks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|deaths_in_region
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize data structures for region scheduling.  */
end_comment

begin_function
specifier|static
name|void
name|init_regions
parameter_list|()
block|{
name|sbitmap
name|blocks
decl_stmt|;
name|int
name|rgn
decl_stmt|;
name|nr_regions
operator|=
literal|0
expr_stmt|;
name|rgn_table
operator|=
operator|(
name|region
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
name|rgn_bb_table
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|block_to_bb
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|containing_rgn
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute regions for scheduling.  */
if|if
condition|(
name|reload_completed
operator|||
name|n_basic_blocks
operator|==
literal|1
operator|||
operator|!
name|flag_schedule_interblock
condition|)
block|{
name|find_single_block_region
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Verify that a 'good' control flow graph can be built.  */
if|if
condition|(
name|is_cfg_nonregular
argument_list|()
condition|)
block|{
name|find_single_block_region
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sbitmap
modifier|*
name|dom
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|dom
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* The scheduler runs after flow; therefore, we can't blindly call 	     back into find_basic_blocks since doing so could invalidate the 	     info in global_live_at_start.  	     Consider a block consisting entirely of dead stores; after life 	     analysis it would be a block of NOTE_INSN_DELETED notes.  If 	     we call find_basic_blocks again, then the block would be removed 	     entirely and invalidate our the register live information.  	     We could (should?) recompute register live information.  Doing 	     so may even be beneficial.  */
name|edge_list
operator|=
name|create_edge_list
argument_list|()
expr_stmt|;
comment|/* Compute the dominators and post dominators.  */
name|calculate_dominance_info
argument_list|(
name|NULL
argument_list|,
name|dom
argument_list|,
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* build_control_flow will return nonzero if it detects unreachable 	     blocks or any other irregularity with the cfg which prevents 	     cross block scheduling.  */
if|if
condition|(
name|build_control_flow
argument_list|(
name|edge_list
argument_list|)
operator|!=
literal|0
condition|)
name|find_single_block_region
argument_list|()
expr_stmt|;
else|else
name|find_rgns
argument_list|(
name|edge_list
argument_list|,
name|dom
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|3
condition|)
name|debug_regions
argument_list|()
expr_stmt|;
comment|/* We are done with flow's edge list.  */
name|free_edge_list
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
comment|/* For now.  This will move as more and more of haifa is converted 	     to using the cfg code in flow.c.  */
name|free
argument_list|(
name|dom
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CHECK_DEAD_NOTES
condition|)
block|{
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|deaths_in_region
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nr_regions
argument_list|)
expr_stmt|;
comment|/* Remove all death notes from the subroutine.  */
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
block|{
name|int
name|b
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|RGN_NR_BLOCKS
argument_list|(
name|rgn
argument_list|)
operator|-
literal|1
init|;
name|b
operator|>=
literal|0
condition|;
operator|--
name|b
control|)
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|rgn_bb_table
index|[
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
operator|+
name|b
index|]
argument_list|)
expr_stmt|;
name|deaths_in_region
index|[
name|rgn
index|]
operator|=
name|count_or_remove_death_notes
argument_list|(
name|blocks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
else|else
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The one entry point in this file.  DUMP_FILE is the dump file for    this pass.  */
end_comment

begin_function
name|void
name|schedule_insns
parameter_list|(
name|dump_file
parameter_list|)
name|FILE
modifier|*
name|dump_file
decl_stmt|;
block|{
name|sbitmap
name|large_region_blocks
decl_stmt|,
name|blocks
decl_stmt|;
name|int
name|rgn
decl_stmt|;
name|int
name|any_large_regions
decl_stmt|;
comment|/* Taking care of this degenerate case makes the rest of      this code simpler.  */
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return;
name|scope_to_insns_initialize
argument_list|()
expr_stmt|;
name|nr_inter
operator|=
literal|0
expr_stmt|;
name|nr_spec
operator|=
literal|0
expr_stmt|;
name|sched_init
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|init_regions
argument_list|()
expr_stmt|;
name|current_sched_info
operator|=
operator|&
name|region_sched_info
expr_stmt|;
comment|/* Schedule every region in the subroutine.  */
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
name|schedule_region
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
comment|/* Update life analysis for the subroutine.  Do single block regions      first so that we can verify that live_at_start didn't change.  Then      do all other blocks.  */
comment|/* ??? There is an outside possibility that update_life_info, or more      to the point propagate_block, could get called with non-zero flags      more than once for one basic block.  This would be kinda bad if it      were to happen, since REG_INFO would be accumulated twice for the      block, and we'd have twice the REG_DEAD notes.       I'm fairly certain that this _shouldn't_ happen, since I don't think      that live_at_start should change at region heads.  Not sure what the      best way to test for this kind of thing...  */
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|compute_bb_for_insn
argument_list|(
name|get_max_uid
argument_list|()
argument_list|)
expr_stmt|;
name|any_large_regions
operator|=
literal|0
expr_stmt|;
name|large_region_blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|large_region_blocks
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
comment|/* Update life information.  For regions consisting of multiple blocks      we've possibly done interblock scheduling that affects global liveness.      For regions consisting of single blocks we need to do only local      liveness.  */
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
if|if
condition|(
name|RGN_NR_BLOCKS
argument_list|(
name|rgn
argument_list|)
operator|>
literal|1
condition|)
name|any_large_regions
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|rgn_bb_table
index|[
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|large_region_blocks
argument_list|,
name|rgn_bb_table
index|[
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Don't update reg info after reload, since that affects      regs_ever_live, which should not change after reload.  */
name|update_life_info
argument_list|(
name|blocks
argument_list|,
name|UPDATE_LIFE_LOCAL
argument_list|,
operator|(
name|reload_completed
condition|?
name|PROP_DEATH_NOTES
else|:
name|PROP_DEATH_NOTES
operator||
name|PROP_REG_INFO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|any_large_regions
condition|)
block|{
name|update_life_info
argument_list|(
name|large_region_blocks
argument_list|,
name|UPDATE_LIFE_GLOBAL
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_REG_INFO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CHECK_DEAD_NOTES
condition|)
block|{
comment|/* Verify the counts of basic block notes in single the basic block          regions.  */
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
if|if
condition|(
name|RGN_NR_BLOCKS
argument_list|(
name|rgn
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|rgn_bb_table
index|[
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|deaths_in_region
index|[
name|rgn
index|]
operator|!=
name|count_or_remove_death_notes
argument_list|(
name|blocks
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|deaths_in_region
argument_list|)
expr_stmt|;
block|}
comment|/* Reposition the prologue and epilogue notes in case we moved the      prologue/epilogue insns.  */
if|if
condition|(
name|reload_completed
condition|)
name|reposition_prologue_and_epilogue_notes
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Delete redundant line notes.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|rm_redundant_line_notes
argument_list|()
expr_stmt|;
name|scope_to_insns_finalize
argument_list|()
expr_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|==
literal|0
operator|&&
name|flag_schedule_interblock
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n;; Procedure interblock/speculative motions == %d/%d \n"
argument_list|,
name|nr_inter
argument_list|,
name|nr_spec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nr_inter
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|rgn_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rgn_bb_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|block_to_bb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|containing_rgn
argument_list|)
expr_stmt|;
name|sched_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|edge_table
condition|)
block|{
name|free
argument_list|(
name|edge_table
argument_list|)
expr_stmt|;
name|edge_table
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|in_edges
condition|)
block|{
name|free
argument_list|(
name|in_edges
argument_list|)
expr_stmt|;
name|in_edges
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|out_edges
condition|)
block|{
name|free
argument_list|(
name|out_edges
argument_list|)
expr_stmt|;
name|out_edges
operator|=
name|NULL
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|large_region_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

