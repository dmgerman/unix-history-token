begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Part of CPP library.  (Macro and #define handling.)    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Per Bothner, 1994.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_struct
struct|struct
name|cpp_macro
block|{
name|cpp_hashnode
modifier|*
modifier|*
name|params
decl_stmt|;
comment|/* Parameters, if any.  */
name|cpp_token
modifier|*
name|expansion
decl_stmt|;
comment|/* First token of replacement list.  */
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* Starting line number.  */
name|unsigned
name|int
name|count
decl_stmt|;
comment|/* Number of tokens in expansion.  */
name|unsigned
name|short
name|paramc
decl_stmt|;
comment|/* Number of parameters.  */
name|unsigned
name|int
name|fun_like
range|:
literal|1
decl_stmt|;
comment|/* If a function-like macro.  */
name|unsigned
name|int
name|variadic
range|:
literal|1
decl_stmt|;
comment|/* If a variadic macro.  */
name|unsigned
name|int
name|syshdr
range|:
literal|1
decl_stmt|;
comment|/* If macro defined in system header.  */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|macro_arg
name|macro_arg
typedef|;
end_typedef

begin_struct
struct|struct
name|macro_arg
block|{
specifier|const
name|cpp_token
modifier|*
modifier|*
name|first
decl_stmt|;
comment|/* First token in unexpanded argument.  */
specifier|const
name|cpp_token
modifier|*
modifier|*
name|expanded
decl_stmt|;
comment|/* Macro-expanded argument.  */
specifier|const
name|cpp_token
modifier|*
name|stringified
decl_stmt|;
comment|/* Stringified argument.  */
name|unsigned
name|int
name|count
decl_stmt|;
comment|/* # of tokens in argument.  */
name|unsigned
name|int
name|expanded_count
decl_stmt|;
comment|/* # of tokens in expanded argument.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Macro expansion.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enter_macro_context
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|builtin_macro
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_token_context
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_hashnode
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_ptoken_context
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_hashnode
operator|*
operator|,
name|_cpp_buff
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|_cpp_buff
modifier|*
name|collect_args
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_context
modifier|*
name|next_context
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cpp_token
modifier|*
name|padding_token
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_arg
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|macro_arg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|quote_string
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cpp_token
modifier|*
name|new_string_token
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cpp_token
modifier|*
name|new_number_token
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cpp_token
modifier|*
name|stringify_arg
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|macro_arg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|paste_all_tokens
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|paste_tokens
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_args
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_hashnode
operator|*
operator|,
name|macro_arg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|_cpp_buff
modifier|*
name|funlike_invocation_p
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #define directive parsing and handling.  */
end_comment

begin_decl_stmt
specifier|static
name|cpp_token
modifier|*
name|alloc_expansion_token
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_macro
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_token
modifier|*
name|lex_expansion_token
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_macro
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|warn_of_redefinition
name|PARAMS
argument_list|(
operator|(
specifier|const
name|cpp_hashnode
operator|*
operator|,
specifier|const
name|cpp_macro
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|save_parameter
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_macro
operator|*
operator|,
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_params
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_macro
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_trad_stringification
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_macro
operator|*
operator|,
specifier|const
name|cpp_string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocates and returns a CPP_STRING token, containing TEXT of length    LEN, after null-terminating it.  TEXT must be in permanent storage.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|new_string_token
parameter_list|(
name|pfile
parameter_list|,
name|text
parameter_list|,
name|len
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|char
modifier|*
name|text
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
name|cpp_token
modifier|*
name|token
init|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|text
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CPP_STRING
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
operator|=
name|text
expr_stmt|;
name|token
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Allocates and returns a CPP_NUMBER token evaluating to NUMBER.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|new_number_token
parameter_list|(
name|pfile
parameter_list|,
name|number
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|number
decl_stmt|;
block|{
name|cpp_token
modifier|*
name|token
init|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
comment|/* 21 bytes holds all NUL-terminated unsigned 64-bit numbers.  */
name|unsigned
name|char
modifier|*
name|buf
init|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
literal|21
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|"%u"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CPP_NUMBER
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
operator|=
name|buf
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|=
name|ustrlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|token
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|token
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|monthnames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle builtin macros like __FILE__, and push the resulting token    on the context stack.  Also handles _Pragma, for which no new token    is created.  Returns 1 if it generates a new token context, 0 to    return the token to the caller.  */
end_comment

begin_function
specifier|static
name|int
name|builtin_macro
parameter_list|(
name|pfile
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|value
operator|.
name|builtin
condition|)
block|{
default|default:
name|cpp_ice
argument_list|(
name|pfile
argument_list|,
literal|"invalid built-in macro \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BT_FILE
case|:
case|case
name|BT_BASE_FILE
case|:
block|{
name|unsigned
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
specifier|const
name|struct
name|line_map
modifier|*
name|map
init|=
name|pfile
operator|->
name|map
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|value
operator|.
name|builtin
operator|==
name|BT_BASE_FILE
condition|)
while|while
condition|(
operator|!
name|MAIN_FILE_P
argument_list|(
name|map
argument_list|)
condition|)
name|map
operator|=
name|INCLUDED_FROM
argument_list|(
operator|&
name|pfile
operator|->
name|line_maps
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|name
operator|=
name|map
operator|->
name|to_file
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|buf
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|len
operator|*
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|quote_string
argument_list|(
name|buf
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|name
argument_list|,
name|len
argument_list|)
operator|-
name|buf
expr_stmt|;
name|result
operator|=
name|new_string_token
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BT_INCLUDE_LEVEL
case|:
comment|/* The line map depth counts the primary source as level 1, but 	 historically __INCLUDE_DEPTH__ has called the primary source 	 level 0.  */
name|result
operator|=
name|new_number_token
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|line_maps
operator|.
name|depth
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT_SPECLINE
case|:
comment|/* If __LINE__ is embedded in a macro, it must expand to the 	 line of the macro's invocation, not its definition. 	 Otherwise things like assert() will not work properly.  */
name|result
operator|=
name|new_number_token
argument_list|(
name|pfile
argument_list|,
name|SOURCE_LINE
argument_list|(
name|pfile
operator|->
name|map
argument_list|,
name|pfile
operator|->
name|cur_token
index|[
operator|-
literal|1
index|]
operator|.
name|line
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT_STDC
case|:
block|{
name|int
name|stdc
init|=
operator|(
operator|!
name|CPP_IN_SYSTEM_HEADER
argument_list|(
name|pfile
argument_list|)
operator|||
name|pfile
operator|->
name|spec_nodes
operator|.
name|n__STRICT_ANSI__
operator|->
name|type
operator|!=
name|NT_VOID
operator|)
decl_stmt|;
name|result
operator|=
name|new_number_token
argument_list|(
name|pfile
argument_list|,
name|stdc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BT_DATE
case|:
case|case
name|BT_TIME
case|:
if|if
condition|(
name|pfile
operator|->
name|date
operator|.
name|type
operator|==
name|CPP_EOF
condition|)
block|{
comment|/* Allocate __DATE__ and __TIME__ strings from permanent 	     storage.  We only do this once, and don't generate them 	     at init time, because time() and localtime() are very 	     slow on some systems.  */
name|time_t
name|tt
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|tb
init|=
name|localtime
argument_list|(
operator|&
name|tt
argument_list|)
decl_stmt|;
name|pfile
operator|->
name|date
operator|.
name|val
operator|.
name|str
operator|.
name|text
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
literal|"Oct 11 1347"
argument_list|)
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|date
operator|.
name|val
operator|.
name|str
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
literal|"Oct 11 1347"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|pfile
operator|->
name|date
operator|.
name|type
operator|=
name|CPP_STRING
expr_stmt|;
name|pfile
operator|->
name|date
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pfile
operator|->
name|date
operator|.
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
literal|"%s %2d %4d"
argument_list|,
name|monthnames
index|[
name|tb
operator|->
name|tm_mon
index|]
argument_list|,
name|tb
operator|->
name|tm_mday
argument_list|,
name|tb
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|time
operator|.
name|val
operator|.
name|str
operator|.
name|text
operator|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
literal|"12:34:56"
argument_list|)
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|time
operator|.
name|val
operator|.
name|str
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
literal|"12:34:56"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|pfile
operator|->
name|time
operator|.
name|type
operator|=
name|CPP_STRING
expr_stmt|;
name|pfile
operator|->
name|time
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pfile
operator|->
name|time
operator|.
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
literal|"%02d:%02d:%02d"
argument_list|,
name|tb
operator|->
name|tm_hour
argument_list|,
name|tb
operator|->
name|tm_min
argument_list|,
name|tb
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|value
operator|.
name|builtin
operator|==
name|BT_DATE
condition|)
name|result
operator|=
operator|&
name|pfile
operator|->
name|date
expr_stmt|;
else|else
name|result
operator|=
operator|&
name|pfile
operator|->
name|time
expr_stmt|;
break|break;
case|case
name|BT_PRAGMA
case|:
comment|/* Don't interpret _Pragma within directives.  The standard is          not clear on this, but to me this makes most sense.  */
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
return|return
literal|0
return|;
name|_cpp_do__Pragma
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|push_token_context
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Copies SRC, of length LEN, to DEST, adding backslashes before all    backslashes and double quotes.  Non-printable characters are    converted to octal.  DEST must be of sufficient size.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|quote_string
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
name|U_CHAR
modifier|*
name|dest
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|src
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|U_CHAR
name|c
init|=
operator|*
name|src
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
operator|*
name|dest
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dest
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dest
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Convert a token sequence ARG to a single string token according to    the rules of the ISO C #-operator.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|stringify_arg
parameter_list|(
name|pfile
parameter_list|,
name|arg
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|macro_arg
modifier|*
name|arg
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|dest
init|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|escape_it
decl_stmt|,
name|backslash_count
init|=
literal|0
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Loop, reading in the argument's tokens.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arg
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|arg
operator|->
name|first
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
block|{
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
name|source
operator|=
name|token
operator|->
name|val
operator|.
name|source
expr_stmt|;
continue|continue;
block|}
name|escape_it
operator|=
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_WSTRING
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CHAR
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_WCHAR
operator|)
expr_stmt|;
comment|/* Room for each char being written in octal, initial space and 	 final NUL.  */
name|len
operator|=
name|cpp_token_len
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_it
condition|)
name|len
operator|*=
literal|4
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|BUFF_LIMIT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
operator|-
name|dest
argument_list|)
operator|<
name|len
condition|)
block|{
name|size_t
name|len_so_far
init|=
name|dest
operator|-
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
decl_stmt|;
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|u_buff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dest
operator|=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
operator|+
name|len_so_far
expr_stmt|;
block|}
comment|/* Leading white space?  */
if|if
condition|(
name|dest
operator|!=
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
condition|)
block|{
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
name|source
operator|=
name|token
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
operator|*
name|dest
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|source
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|escape_it
condition|)
block|{
name|_cpp_buff
modifier|*
name|buff
init|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|BUFF_FRONT
argument_list|(
name|buff
argument_list|)
decl_stmt|;
name|len
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
name|buf
argument_list|)
operator|-
name|buf
expr_stmt|;
name|dest
operator|=
name|quote_string
argument_list|(
name|dest
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|_cpp_release_buff
argument_list|(
name|pfile
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
else|else
name|dest
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OTHER
operator|&&
name|token
operator|->
name|val
operator|.
name|c
operator|==
literal|'\\'
condition|)
name|backslash_count
operator|++
expr_stmt|;
else|else
name|backslash_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ignore the final \ of invalid string literals.  */
if|if
condition|(
name|backslash_count
operator|&
literal|1
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"invalid string literal, ignoring final '\\'"
argument_list|)
expr_stmt|;
name|dest
operator|--
expr_stmt|;
block|}
comment|/* Commit the memory, including NUL, and return the token.  */
name|len
operator|=
name|dest
operator|-
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
expr_stmt|;
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|u_buff
argument_list|)
operator|=
name|dest
operator|+
literal|1
expr_stmt|;
return|return
name|new_string_token
argument_list|(
name|pfile
argument_list|,
name|dest
operator|-
name|len
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Try to paste two tokens.  On success, return non-zero.  In any    case, PLHS is updated to point to the pasted token, which is    guaranteed to not have the PASTE_LEFT flag set.  */
end_comment

begin_function
specifier|static
name|bool
name|paste_tokens
parameter_list|(
name|pfile
parameter_list|,
name|plhs
parameter_list|,
name|rhs
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
modifier|*
name|plhs
decl_stmt|,
decl|*
name|rhs
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|lhs
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|bool
name|valid
decl_stmt|;
name|lhs
operator|=
operator|*
name|plhs
expr_stmt|;
name|len
operator|=
name|cpp_token_len
argument_list|(
name|lhs
argument_list|)
operator|+
name|cpp_token_len
argument_list|(
name|rhs
argument_list|)
operator|+
literal|1
expr_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|end
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|lhs
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Avoid comment headers, since they are still processed in stage 3.      It is simpler to insert a space here, rather than modifying the      lexer to ignore comments in some circumstances.  Simply returning      false doesn't work, since we want to clear the PASTE_LEFT flag.  */
if|if
condition|(
name|lhs
operator|->
name|type
operator|==
name|CPP_DIV
operator|&&
operator|(
name|rhs
operator|->
name|type
operator|==
name|CPP_MULT
operator|||
name|rhs
operator|->
name|type
operator|==
name|CPP_DIV
operator|)
condition|)
operator|*
name|end
operator|++
operator|=
literal|' '
expr_stmt|;
name|end
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|rhs
argument_list|,
name|end
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|end
operator|-
name|buf
argument_list|,
comment|/* from_stage3 */
name|true
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Tweak the column number the lexer will report.  */
name|pfile
operator|->
name|buffer
operator|->
name|col_adjust
operator|=
name|pfile
operator|->
name|cur_token
index|[
operator|-
literal|1
index|]
operator|.
name|col
operator|-
literal|1
expr_stmt|;
comment|/* We don't want a leading # to be interpreted as a directive.  */
name|pfile
operator|->
name|buffer
operator|->
name|saved_flags
operator|=
literal|0
expr_stmt|;
comment|/* Set pfile->cur_token as required by _cpp_lex_direct.  */
name|pfile
operator|->
name|cur_token
operator|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
operator|*
name|plhs
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|valid
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|==
name|pfile
operator|->
name|buffer
operator|->
name|rlimit
expr_stmt|;
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|valid
return|;
block|}
end_block

begin_comment
comment|/* Handles an arbitrarily long sequence of ## operators, with initial    operand LHS.  This implementation is left-associative,    non-recursive, and finishes a paste before handling succeeding    ones.  If a paste fails, we back up to the RHS of the failing ##    operator before pushing the context containing the result of prior    successful pastes, with the effect that the RHS appears in the    output stream after the pasted LHS normally.  */
end_comment

begin_function
specifier|static
name|void
name|paste_all_tokens
parameter_list|(
name|pfile
parameter_list|,
name|lhs
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|lhs
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|rhs
decl_stmt|;
name|cpp_context
modifier|*
name|context
init|=
name|pfile
operator|->
name|context
decl_stmt|;
do|do
block|{
comment|/* Take the token directly from the current context.  We can do 	 this, because we are in the replacement list of either an 	 object-like macro, or a function-like macro with arguments 	 inserted.  In either case, the constraints to #define 	 guarantee we have at least one more token.  */
if|if
condition|(
name|context
operator|->
name|direct_p
condition|)
name|rhs
operator|=
name|context
operator|->
name|first
operator|.
name|token
operator|++
expr_stmt|;
else|else
name|rhs
operator|=
operator|*
name|context
operator|->
name|first
operator|.
name|ptoken
operator|++
expr_stmt|;
if|if
condition|(
name|rhs
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|paste_tokens
argument_list|(
name|pfile
argument_list|,
operator|&
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Mandatory warning for all apart from assembler.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|!=
name|CLK_ASM
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"pasting \"%s\" and \"%s\" does not give a valid preprocessing token"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|lhs
argument_list|)
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|rhs
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
do|;
comment|/* Put the resulting token in its own context.  */
name|push_token_context
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|lhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reads and returns the arguments to a function-like macro    invocation.  Assumes the opening parenthesis has been processed.    If there is an error, emits an appropriate diagnostic and returns    NULL.  Each argument is terminated by a CPP_EOF token, for the    future benefit of expand_arg().  */
end_comment

begin_function
specifier|static
name|_cpp_buff
modifier|*
name|collect_args
parameter_list|(
name|pfile
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
name|_cpp_buff
modifier|*
name|buff
decl_stmt|,
modifier|*
name|base_buff
decl_stmt|;
name|cpp_macro
modifier|*
name|macro
decl_stmt|;
name|macro_arg
modifier|*
name|args
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|unsigned
name|int
name|argc
decl_stmt|;
name|bool
name|error
init|=
name|false
decl_stmt|;
name|macro
operator|=
name|node
operator|->
name|value
operator|.
name|macro
expr_stmt|;
if|if
condition|(
name|macro
operator|->
name|paramc
condition|)
name|argc
operator|=
name|macro
operator|->
name|paramc
expr_stmt|;
else|else
name|argc
operator|=
literal|1
expr_stmt|;
name|buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|argc
operator|*
operator|(
literal|50
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|macro_arg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|base_buff
operator|=
name|buff
expr_stmt|;
name|args
operator|=
operator|(
name|macro_arg
operator|*
operator|)
name|buff
operator|->
name|base
expr_stmt|;
name|memset
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|macro_arg
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|->
name|cur
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|args
index|[
name|argc
index|]
expr_stmt|;
name|arg
operator|=
name|args
operator|,
name|argc
operator|=
literal|0
expr_stmt|;
comment|/* Collect the tokens making up each argument.  We don't yet know      how many arguments have been supplied, whether too many or too      few.  Hence the slightly bizarre usage of "argc" and "arg".  */
do|do
block|{
name|unsigned
name|int
name|paren_depth
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|ntokens
init|=
literal|0
decl_stmt|;
name|argc
operator|++
expr_stmt|;
name|arg
operator|->
name|first
operator|=
operator|(
specifier|const
name|cpp_token
operator|*
operator|*
operator|)
name|buff
operator|->
name|cur
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Require space for 2 new tokens (including a CPP_EOF).  */
if|if
condition|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|arg
operator|->
name|first
index|[
name|ntokens
operator|+
literal|2
index|]
operator|>
name|buff
operator|->
name|limit
condition|)
block|{
name|buff
operator|=
name|_cpp_append_extend_buff
argument_list|(
name|pfile
argument_list|,
name|buff
argument_list|,
literal|1000
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|->
name|first
operator|=
operator|(
specifier|const
name|cpp_token
operator|*
operator|*
operator|)
name|buff
operator|->
name|cur
expr_stmt|;
block|}
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
block|{
comment|/* Drop leading padding.  */
if|if
condition|(
name|ntokens
operator|==
literal|0
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
name|paren_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
condition|)
block|{
if|if
condition|(
name|paren_depth
operator|--
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
condition|)
block|{
comment|/* A comma does not terminate an argument within 		 parentheses or as part of a variable argument.  */
if|if
condition|(
name|paren_depth
operator|==
literal|0
operator|&&
operator|!
operator|(
name|macro
operator|->
name|variadic
operator|&&
name|argc
operator|==
name|macro
operator|->
name|paramc
operator|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
operator|||
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_HASH
operator|&&
name|token
operator|->
name|flags
operator|&
name|BOL
operator|)
condition|)
break|break;
name|arg
operator|->
name|first
index|[
name|ntokens
operator|++
index|]
operator|=
name|token
expr_stmt|;
block|}
comment|/* Drop trailing padding.  */
while|while
condition|(
name|ntokens
operator|>
literal|0
operator|&&
name|arg
operator|->
name|first
index|[
name|ntokens
operator|-
literal|1
index|]
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
name|ntokens
operator|--
expr_stmt|;
name|arg
operator|->
name|count
operator|=
name|ntokens
expr_stmt|;
name|arg
operator|->
name|first
index|[
name|ntokens
index|]
operator|=
operator|&
name|pfile
operator|->
name|eof
expr_stmt|;
comment|/* Terminate the argument.  Excess arguments loop back and 	 overwrite the final legitimate argument, before failing.  */
if|if
condition|(
name|argc
operator|<=
name|macro
operator|->
name|paramc
condition|)
block|{
name|buff
operator|->
name|cur
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|arg
operator|->
name|first
index|[
name|ntokens
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
name|macro
operator|->
name|paramc
condition|)
name|arg
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_CLOSE_PAREN
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
operator|&&
name|token
operator|->
name|type
operator|!=
name|CPP_HASH
condition|)
do|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_HASH
condition|)
block|{
name|bool
name|step_back
init|=
name|false
decl_stmt|;
comment|/* 6.10.3 paragraph 11: If there are sequences of preprocessing 	 tokens within the list of arguments that would otherwise act 	 as preprocessing directives, the behavior is undefined.  	 This implementation will report a hard error, terminate the 	 macro invocation, and proceed to process the directive.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_HASH
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"directives may not be used inside a macro argument"
argument_list|)
expr_stmt|;
name|step_back
operator|=
name|true
expr_stmt|;
block|}
else|else
name|step_back
operator|=
operator|(
name|pfile
operator|->
name|context
operator|->
name|prev
operator|||
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|)
expr_stmt|;
comment|/* We still need the CPP_EOF to end directives, and to end 	 pre-expansion of a macro argument.  Step back is not 	 unconditional, since we don't want to return a CPP_EOF to our 	 callers at the end of an -include-d file.  */
if|if
condition|(
name|step_back
condition|)
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"unterminated argument list invoking macro \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|<
name|macro
operator|->
name|paramc
condition|)
block|{
comment|/* As an extension, a rest argument is allowed to not appear in 	 the invocation at all. 	 e.g. #define debug(format, args...) something 	 debug("string"); 	  	 This is exactly the same as if there had been an empty rest 	 argument - debug("string", ).  */
if|if
condition|(
name|argc
operator|+
literal|1
operator|==
name|macro
operator|->
name|paramc
operator|&&
name|macro
operator|->
name|variadic
condition|)
block|{
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|macro
operator|->
name|syshdr
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ISO C99 requires rest arguments to be used"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro \"%s\" requires %u arguments, but only %u given"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|macro
operator|->
name|paramc
argument_list|,
name|argc
argument_list|)
expr_stmt|;
name|error
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
name|macro
operator|->
name|paramc
condition|)
block|{
comment|/* Empty argument to a macro taking no arguments is OK.  */
if|if
condition|(
name|argc
operator|!=
literal|1
operator|||
name|arg
operator|->
name|count
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro \"%s\" passed %u arguments, but takes just %u"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|argc
argument_list|,
name|macro
operator|->
name|paramc
argument_list|)
expr_stmt|;
name|error
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|error
condition|)
return|return
name|base_buff
return|;
name|_cpp_release_buff
argument_list|(
name|pfile
argument_list|,
name|base_buff
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Search for an opening parenthesis to the macro of NODE, in such a    way that, if none is found, we don't lose the information in any    intervening padding tokens.  If we find the parenthesis, collect    the arguments and return the buffer containing them.  */
end_comment

begin_function
specifier|static
name|_cpp_buff
modifier|*
name|funlike_invocation_p
parameter_list|(
name|pfile
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|,
modifier|*
name|padding
init|=
name|NULL
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_PADDING
condition|)
break|break;
if|if
condition|(
name|padding
operator|==
name|NULL
operator|||
operator|(
operator|!
operator|(
name|padding
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
operator|&&
name|token
operator|->
name|val
operator|.
name|source
operator|==
name|NULL
operator|)
condition|)
name|padding
operator|=
name|token
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
condition|)
block|{
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|=
literal|2
expr_stmt|;
return|return
name|collect_args
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/* Back up.  We may have skipped padding, in which case backing up      more than one token when expanding macros is in general too      difficult.  We re-insert it in its own context.  */
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|padding
condition|)
name|push_token_context
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|padding
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Push the context of a macro with hash entry NODE onto the context    stack.  If we can successfully expand the macro, we push a context    containing its yet-to-be-rescanned replacement list and return one.    Otherwise, we don't push a context and return zero.  */
end_comment

begin_function
specifier|static
name|int
name|enter_macro_context
parameter_list|(
name|pfile
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
comment|/* The presence of a macro invalidates a file's controlling macro.  */
name|pfile
operator|->
name|mi_valid
operator|=
name|false
expr_stmt|;
comment|/* Handle standard macros.  */
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
condition|)
block|{
name|cpp_macro
modifier|*
name|macro
init|=
name|node
operator|->
name|value
operator|.
name|macro
decl_stmt|;
if|if
condition|(
name|macro
operator|->
name|fun_like
condition|)
block|{
name|_cpp_buff
modifier|*
name|buff
decl_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
name|pfile
operator|->
name|keep_tokens
operator|++
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|=
literal|1
expr_stmt|;
name|buff
operator|=
name|funlike_invocation_p
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|parsing_args
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|keep_tokens
operator|--
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|node
operator|->
name|value
operator|.
name|macro
operator|->
name|syshdr
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"function-like macro \"%s\" must be used with arguments in traditional C"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|node
operator|->
name|value
operator|.
name|macro
operator|->
name|paramc
operator|>
literal|0
condition|)
name|replace_args
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|,
operator|(
name|macro_arg
operator|*
operator|)
name|buff
operator|->
name|base
argument_list|)
expr_stmt|;
name|_cpp_release_buff
argument_list|(
name|pfile
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
comment|/* Disable the macro within its expansion.  */
name|node
operator|->
name|flags
operator||=
name|NODE_DISABLED
expr_stmt|;
if|if
condition|(
name|macro
operator|->
name|paramc
operator|==
literal|0
condition|)
name|push_token_context
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|,
name|macro
operator|->
name|expansion
argument_list|,
name|macro
operator|->
name|count
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Handle built-in macros and the _Pragma operator.  */
return|return
name|builtin_macro
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Replace the parameters in a function-like macro of NODE with the    actual ARGS, and place the result in a newly pushed token context.    Expand each argument before replacing, unless it is operated upon    by the # or ## operators.  */
end_comment

begin_function
specifier|static
name|void
name|replace_args
parameter_list|(
name|pfile
parameter_list|,
name|node
parameter_list|,
name|args
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|macro_arg
modifier|*
name|args
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|total
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|src
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
modifier|*
name|dest
decl_stmt|,
modifier|*
modifier|*
name|first
decl_stmt|;
name|macro_arg
modifier|*
name|arg
decl_stmt|;
name|_cpp_buff
modifier|*
name|buff
decl_stmt|;
name|cpp_macro
modifier|*
name|macro
decl_stmt|;
comment|/* First, fully macro-expand arguments, calculating the number of      tokens in the final expansion as we go.  The ordering of the if      statements below is subtle; we must handle stringification before      pasting.  */
name|macro
operator|=
name|node
operator|->
name|value
operator|.
name|macro
expr_stmt|;
name|total
operator|=
name|macro
operator|->
name|count
expr_stmt|;
name|limit
operator|=
name|macro
operator|->
name|expansion
operator|+
name|macro
operator|->
name|count
expr_stmt|;
for|for
control|(
name|src
operator|=
name|macro
operator|->
name|expansion
init|;
name|src
operator|<
name|limit
condition|;
name|src
operator|++
control|)
if|if
condition|(
name|src
operator|->
name|type
operator|==
name|CPP_MACRO_ARG
condition|)
block|{
comment|/* Leading and trailing padding tokens.  */
name|total
operator|+=
literal|2
expr_stmt|;
comment|/* We have an argument.  If it is not being stringified or 	   pasted it is macro-replaced before insertion.  */
name|arg
operator|=
operator|&
name|args
index|[
name|src
operator|->
name|val
operator|.
name|arg_no
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|STRINGIFY_ARG
condition|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|stringified
condition|)
name|arg
operator|->
name|stringified
operator|=
name|stringify_arg
argument_list|(
name|pfile
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|src
operator|->
name|flags
operator|&
name|PASTE_LEFT
operator|)
operator|||
operator|(
name|src
operator|>
name|macro
operator|->
name|expansion
operator|&&
operator|(
name|src
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|PASTE_LEFT
operator|)
operator|)
condition|)
name|total
operator|+=
name|arg
operator|->
name|count
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|expanded
condition|)
name|expand_arg
argument_list|(
name|pfile
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|total
operator|+=
name|arg
operator|->
name|expanded_count
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now allocate space for the expansion, copy the tokens and replace      the arguments.  */
name|buff
operator|=
name|_cpp_get_buff
argument_list|(
name|pfile
argument_list|,
name|total
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
operator|(
specifier|const
name|cpp_token
operator|*
operator|*
operator|)
name|buff
operator|->
name|base
expr_stmt|;
name|dest
operator|=
name|first
expr_stmt|;
for|for
control|(
name|src
operator|=
name|macro
operator|->
name|expansion
init|;
name|src
operator|<
name|limit
condition|;
name|src
operator|++
control|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
modifier|*
name|from
decl_stmt|,
modifier|*
modifier|*
name|paste_flag
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|type
operator|!=
name|CPP_MACRO_ARG
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
name|src
expr_stmt|;
continue|continue;
block|}
name|paste_flag
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
operator|&
name|args
index|[
name|src
operator|->
name|val
operator|.
name|arg_no
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|STRINGIFY_ARG
condition|)
name|count
operator|=
literal|1
operator|,
name|from
operator|=
operator|&
name|arg
operator|->
name|stringified
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
name|count
operator|=
name|arg
operator|->
name|count
operator|,
name|from
operator|=
name|arg
operator|->
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|!=
name|macro
operator|->
name|expansion
operator|&&
operator|(
name|src
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|PASTE_LEFT
operator|)
condition|)
block|{
name|count
operator|=
name|arg
operator|->
name|count
operator|,
name|from
operator|=
name|arg
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|dest
operator|!=
name|first
condition|)
block|{
comment|/* GCC has special semantics for , ## b where b is a 		 varargs parameter: the comma disappears if b was 		 given no actual arguments (not merely if b is an 		 empty argument); otherwise the paste flag is removed.  */
if|if
condition|(
name|dest
index|[
operator|-
literal|1
index|]
operator|->
name|type
operator|==
name|CPP_COMMA
operator|&&
name|macro
operator|->
name|variadic
operator|&&
name|src
operator|->
name|val
operator|.
name|arg_no
operator|==
name|macro
operator|->
name|paramc
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|dest
operator|--
expr_stmt|;
else|else
name|paste_flag
operator|=
name|dest
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Remove the paste flag if the RHS is a placemarker.  */
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|paste_flag
operator|=
name|dest
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|count
operator|=
name|arg
operator|->
name|expanded_count
operator|,
name|from
operator|=
name|arg
operator|->
name|expanded
expr_stmt|;
comment|/* Padding on the left of an argument (unless RHS of ##).  */
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|&&
name|src
operator|!=
name|macro
operator|->
name|expansion
operator|&&
operator|!
operator|(
name|src
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|PASTE_LEFT
operator|)
condition|)
operator|*
name|dest
operator|++
operator|=
name|padding_token
argument_list|(
name|pfile
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|from
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|count
expr_stmt|;
comment|/* With a non-empty argument on the LHS of ##, the last 	     token should be flagged PASTE_LEFT.  */
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
name|paste_flag
operator|=
name|dest
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Avoid paste on RHS (even case count == 0).  */
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|&&
operator|!
operator|(
name|src
operator|->
name|flags
operator|&
name|PASTE_LEFT
operator|)
condition|)
operator|*
name|dest
operator|++
operator|=
operator|&
name|pfile
operator|->
name|avoid_paste
expr_stmt|;
comment|/* Add a new paste flag, or remove an unwanted one.  */
if|if
condition|(
name|paste_flag
condition|)
block|{
name|cpp_token
modifier|*
name|token
init|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|token
operator|->
name|type
operator|=
operator|(
operator|*
name|paste_flag
operator|)
operator|->
name|type
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|str
operator|=
operator|(
operator|*
name|paste_flag
operator|)
operator|->
name|val
operator|.
name|str
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
name|token
operator|->
name|flags
operator|=
operator|(
operator|*
name|paste_flag
operator|)
operator|->
name|flags
operator||
name|PASTE_LEFT
expr_stmt|;
else|else
name|token
operator|->
name|flags
operator|=
operator|(
operator|*
name|paste_flag
operator|)
operator|->
name|flags
operator|&
operator|~
name|PASTE_LEFT
expr_stmt|;
operator|*
name|paste_flag
operator|=
name|token
expr_stmt|;
block|}
block|}
comment|/* Free the expanded arguments.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|paramc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|expanded
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|expanded
argument_list|)
expr_stmt|;
name|push_ptoken_context
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|,
name|buff
argument_list|,
name|first
argument_list|,
name|dest
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a special padding token, with padding inherited from SOURCE.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|padding_token
parameter_list|(
name|pfile
parameter_list|,
name|source
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|source
decl_stmt|;
block|{
name|cpp_token
modifier|*
name|result
init|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|result
operator|->
name|type
operator|=
name|CPP_PADDING
expr_stmt|;
name|result
operator|->
name|val
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|result
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Get a new uninitialized context.  Create a new one if we cannot    re-use an old one.  */
end_comment

begin_function
specifier|static
name|cpp_context
modifier|*
name|next_context
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_context
modifier|*
name|result
init|=
name|pfile
operator|->
name|context
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|xnew
argument_list|(
name|cpp_context
argument_list|)
expr_stmt|;
name|result
operator|->
name|prev
operator|=
name|pfile
operator|->
name|context
expr_stmt|;
name|result
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|context
operator|->
name|next
operator|=
name|result
expr_stmt|;
block|}
name|pfile
operator|->
name|context
operator|=
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Push a list of pointers to tokens.  */
end_comment

begin_function
specifier|static
name|void
name|push_ptoken_context
parameter_list|(
name|pfile
parameter_list|,
name|macro
parameter_list|,
name|buff
parameter_list|,
name|first
parameter_list|,
name|count
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_hashnode
modifier|*
name|macro
decl_stmt|;
name|_cpp_buff
modifier|*
name|buff
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
modifier|*
name|first
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|{
name|cpp_context
modifier|*
name|context
init|=
name|next_context
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|context
operator|->
name|direct_p
operator|=
name|false
expr_stmt|;
name|context
operator|->
name|macro
operator|=
name|macro
expr_stmt|;
name|context
operator|->
name|buff
operator|=
name|buff
expr_stmt|;
name|context
operator|->
name|first
operator|.
name|ptoken
operator|=
name|first
expr_stmt|;
name|context
operator|->
name|last
operator|.
name|ptoken
operator|=
name|first
operator|+
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a list of tokens.  */
end_comment

begin_function
specifier|static
name|void
name|push_token_context
parameter_list|(
name|pfile
parameter_list|,
name|macro
parameter_list|,
name|first
parameter_list|,
name|count
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_hashnode
modifier|*
name|macro
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|first
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|{
name|cpp_context
modifier|*
name|context
init|=
name|next_context
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|context
operator|->
name|direct_p
operator|=
name|true
expr_stmt|;
name|context
operator|->
name|macro
operator|=
name|macro
expr_stmt|;
name|context
operator|->
name|buff
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|first
operator|.
name|token
operator|=
name|first
expr_stmt|;
name|context
operator|->
name|last
operator|.
name|token
operator|=
name|first
operator|+
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an argument ARG before replacing parameters in a    function-like macro.  This works by pushing a context with the    argument's tokens, and then expanding that into a temporary buffer    as if it were a normal part of the token stream.  collect_args()    has terminated the argument's tokens with a CPP_EOF so that we know    when we have fully expanded the argument.  */
end_comment

begin_function
specifier|static
name|void
name|expand_arg
parameter_list|(
name|pfile
parameter_list|,
name|arg
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|macro_arg
modifier|*
name|arg
decl_stmt|;
block|{
name|unsigned
name|int
name|capacity
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|count
operator|==
literal|0
condition|)
return|return;
comment|/* Loop, reading in the arguments.  */
name|capacity
operator|=
literal|256
expr_stmt|;
name|arg
operator|->
name|expanded
operator|=
operator|(
specifier|const
name|cpp_token
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|capacity
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|push_ptoken_context
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|arg
operator|->
name|first
argument_list|,
name|arg
operator|->
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|expanded_count
operator|+
literal|1
operator|>=
name|capacity
condition|)
block|{
name|capacity
operator|*=
literal|2
expr_stmt|;
name|arg
operator|->
name|expanded
operator|=
operator|(
specifier|const
name|cpp_token
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|arg
operator|->
name|expanded
argument_list|,
name|capacity
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
name|arg
operator|->
name|expanded
index|[
name|arg
operator|->
name|expanded_count
operator|++
index|]
operator|=
name|token
expr_stmt|;
block|}
name|_cpp_pop_context
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the current context off the stack, re-enabling the macro if the    context represented a macro's replacement list.  The context    structure is not freed so that we can re-use it later.  */
end_comment

begin_function
name|void
name|_cpp_pop_context
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_context
modifier|*
name|context
init|=
name|pfile
operator|->
name|context
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|macro
condition|)
name|context
operator|->
name|macro
operator|->
name|flags
operator|&=
operator|~
name|NODE_DISABLED
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|buff
condition|)
name|_cpp_release_buff
argument_list|(
name|pfile
argument_list|,
name|context
operator|->
name|buff
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|context
operator|=
name|context
operator|->
name|prev
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Eternal routine to get a token.  Also used nearly everywhere    internally, except for places where we know we can safely call    the lexer directly, such as lexing a directive name.     Macro expansions and directives are transparently handled,    including entering included files.  Thus tokens are post-macro    expansion, and after any intervening directives.  External callers    see CPP_EOF only at EOF.  Internal callers also see it when meeting    a directive inside a macro call, when at the end of a directive and    state.in_directive is still 1, and at the end of argument    pre-expansion.  */
end_comment

begin_function
specifier|const
name|cpp_token
modifier|*
name|cpp_get_token
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|result
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|cpp_context
modifier|*
name|context
init|=
name|pfile
operator|->
name|context
decl_stmt|;
comment|/* Context->prev == 0<=> base context.  */
if|if
condition|(
operator|!
name|context
operator|->
name|prev
condition|)
name|result
operator|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|context
operator|->
name|first
operator|.
name|token
operator|!=
name|context
operator|->
name|last
operator|.
name|token
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|direct_p
condition|)
name|result
operator|=
name|context
operator|->
name|first
operator|.
name|token
operator|++
expr_stmt|;
else|else
name|result
operator|=
operator|*
name|context
operator|->
name|first
operator|.
name|ptoken
operator|++
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
block|{
name|paste_all_tokens
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
continue|continue;
return|return
name|padding_token
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|_cpp_pop_context
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
continue|continue;
return|return
operator|&
name|pfile
operator|->
name|avoid_paste
return|;
block|}
if|if
condition|(
name|result
operator|->
name|type
operator|!=
name|CPP_NAME
condition|)
break|break;
name|node
operator|=
name|result
operator|->
name|val
operator|.
name|node
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|!=
name|NT_MACRO
operator|||
operator|(
name|result
operator|->
name|flags
operator|&
name|NO_EXPAND
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_DISABLED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|&&
name|enter_macro_context
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|in_directive
condition|)
continue|continue;
return|return
name|padding_token
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* Flag this token as always unexpandable.  FIXME: move this 	     to collect_args()?.  */
name|cpp_token
modifier|*
name|t
init|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|t
operator|->
name|type
operator|=
name|result
operator|->
name|type
expr_stmt|;
name|t
operator|->
name|flags
operator|=
name|result
operator|->
name|flags
operator||
name|NO_EXPAND
expr_stmt|;
name|t
operator|->
name|val
operator|.
name|str
operator|=
name|result
operator|->
name|val
operator|.
name|str
expr_stmt|;
name|result
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns true if we're expanding an object-like macro that was    defined in a system header.  Just checks the macro at the top of    the stack.  Used for diagnostic suppression.  */
end_comment

begin_function
name|int
name|cpp_sys_macro_p
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_hashnode
modifier|*
name|node
init|=
name|pfile
operator|->
name|context
operator|->
name|macro
decl_stmt|;
return|return
name|node
operator|&&
name|node
operator|->
name|value
operator|.
name|macro
operator|&&
name|node
operator|->
name|value
operator|.
name|macro
operator|->
name|syshdr
return|;
block|}
end_function

begin_comment
comment|/* Read each token in, until EOF.  Directives are transparently    processed.  */
end_comment

begin_function
name|void
name|cpp_scan_nooutput
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
while|while
condition|(
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Step back one (or more) tokens.  Can only step mack more than 1 if    they are from the lexer, and not from macro expansion.  */
end_comment

begin_function
name|void
name|_cpp_backup_tokens
parameter_list|(
name|pfile
parameter_list|,
name|count
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|pfile
operator|->
name|context
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
name|pfile
operator|->
name|lookaheads
operator|+=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|pfile
operator|->
name|cur_token
operator|--
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|cur_token
operator|==
name|pfile
operator|->
name|cur_run
operator|->
name|base
comment|/* Possible with -fpreprocessed and no leading #line.  */
operator|&&
name|pfile
operator|->
name|cur_run
operator|->
name|prev
operator|!=
name|NULL
condition|)
block|{
name|pfile
operator|->
name|cur_run
operator|=
name|pfile
operator|->
name|cur_run
operator|->
name|prev
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|pfile
operator|->
name|cur_run
operator|->
name|limit
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|context
operator|->
name|direct_p
condition|)
name|pfile
operator|->
name|context
operator|->
name|first
operator|.
name|token
operator|--
expr_stmt|;
else|else
name|pfile
operator|->
name|context
operator|->
name|first
operator|.
name|ptoken
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* #define directive parsing and handling.  */
end_comment

begin_comment
comment|/* Returns non-zero if a macro redefinition warning is required.  */
end_comment

begin_function
specifier|static
name|int
name|warn_of_redefinition
parameter_list|(
name|node
parameter_list|,
name|macro2
parameter_list|)
specifier|const
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
specifier|const
name|cpp_macro
modifier|*
name|macro2
decl_stmt|;
block|{
specifier|const
name|cpp_macro
modifier|*
name|macro1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Some redefinitions need to be warned about regardless.  */
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|NODE_WARN
condition|)
return|return
literal|1
return|;
comment|/* Redefinition of a macro is allowed if and only if the old and new      definitions are the same.  (6.10.3 paragraph 2).  */
name|macro1
operator|=
name|node
operator|->
name|value
operator|.
name|macro
expr_stmt|;
comment|/* The quick failures.  */
if|if
condition|(
name|macro1
operator|->
name|count
operator|!=
name|macro2
operator|->
name|count
operator|||
name|macro1
operator|->
name|paramc
operator|!=
name|macro2
operator|->
name|paramc
operator|||
name|macro1
operator|->
name|fun_like
operator|!=
name|macro2
operator|->
name|fun_like
operator|||
name|macro1
operator|->
name|variadic
operator|!=
name|macro2
operator|->
name|variadic
condition|)
return|return
literal|1
return|;
comment|/* Check each token.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro1
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|_cpp_equiv_tokens
argument_list|(
operator|&
name|macro1
operator|->
name|expansion
index|[
name|i
index|]
argument_list|,
operator|&
name|macro2
operator|->
name|expansion
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Check parameter spellings.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro1
operator|->
name|paramc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|macro1
operator|->
name|params
index|[
name|i
index|]
operator|!=
name|macro2
operator|->
name|params
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free the definition of hashnode H.  */
end_comment

begin_function
name|void
name|_cpp_free_definition
parameter_list|(
name|h
parameter_list|)
name|cpp_hashnode
modifier|*
name|h
decl_stmt|;
block|{
comment|/* Macros and assertions no longer have anything to free.  */
name|h
operator|->
name|type
operator|=
name|NT_VOID
expr_stmt|;
comment|/* Clear builtin flag in case of redefinition.  */
name|h
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NODE_BUILTIN
operator||
name|NODE_DISABLED
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save parameter NODE to the parameter list of macro MACRO.  Returns    zero on success, non-zero if the parameter is a duplicate.  */
end_comment

begin_function
specifier|static
name|int
name|save_parameter
parameter_list|(
name|pfile
parameter_list|,
name|macro
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_macro
modifier|*
name|macro
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
comment|/* Constraint 6.10.3.6 - duplicate parameter names.  */
if|if
condition|(
name|node
operator|->
name|arg_index
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"duplicate macro parameter \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|BUFF_ROOM
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|<
operator|(
name|macro
operator|->
name|paramc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|cpp_hashnode
operator|*
argument_list|)
condition|)
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|a_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_hashnode
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|cpp_hashnode
operator|*
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|)
index|[
name|macro
operator|->
name|paramc
operator|++
index|]
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|arg_index
operator|=
name|macro
operator|->
name|paramc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check the syntax of the parameters in a MACRO definition.  */
end_comment

begin_function
specifier|static
name|int
name|parse_params
parameter_list|(
name|pfile
parameter_list|,
name|macro
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_macro
modifier|*
name|macro
decl_stmt|;
block|{
name|unsigned
name|int
name|prev_ident
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
default|default:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"\"%s\" may not appear in macro parameter list"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CPP_NAME
case|:
if|if
condition|(
name|prev_ident
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro parameters must be comma-separated"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|prev_ident
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|save_parameter
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|,
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
condition|)
return|return
literal|0
return|;
continue|continue;
case|case
name|CPP_CLOSE_PAREN
case|:
if|if
condition|(
name|prev_ident
operator|||
name|macro
operator|->
name|paramc
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Fall through to pick up the error.  */
case|case
name|CPP_COMMA
case|:
if|if
condition|(
operator|!
name|prev_ident
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"parameter name missing"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|prev_ident
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|CPP_ELLIPSIS
case|:
name|macro
operator|->
name|variadic
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|prev_ident
condition|)
block|{
name|save_parameter
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|,
name|pfile
operator|->
name|spec_nodes
operator|.
name|n__VA_ARGS__
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|va_args_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pedantic
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"anonymous variadic macros were introduced in C99"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|pedantic
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ISO C does not permit named variadic macros"
argument_list|)
expr_stmt|;
comment|/* We're at the end, and just expect a closing parenthesis.  */
name|token
operator|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
condition|)
return|return
literal|1
return|;
comment|/* Fall through.  */
case|case
name|CPP_EOF
case|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"missing ')' in macro parameter list"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Allocate room for a token from a macro's replacement list.  */
end_comment

begin_function
specifier|static
name|cpp_token
modifier|*
name|alloc_expansion_token
parameter_list|(
name|pfile
parameter_list|,
name|macro
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_macro
modifier|*
name|macro
decl_stmt|;
block|{
if|if
condition|(
name|BUFF_ROOM
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|<
operator|(
name|macro
operator|->
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
argument_list|)
condition|)
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|a_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_token
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
operator|(
name|cpp_token
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|)
index|[
name|macro
operator|->
name|count
operator|++
index|]
return|;
block|}
end_function

begin_comment
comment|/* Lex a token from the expansion of MACRO, but mark parameters as we    find them and warn of traditional stringification.  */
end_comment

begin_function
specifier|static
name|cpp_token
modifier|*
name|lex_expansion_token
parameter_list|(
name|pfile
parameter_list|,
name|macro
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_macro
modifier|*
name|macro
decl_stmt|;
block|{
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|alloc_expansion_token
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
name|token
operator|=
name|_cpp_lex_direct
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Is this a parameter?  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
name|token
operator|->
name|val
operator|.
name|node
operator|->
name|arg_index
condition|)
block|{
name|token
operator|->
name|type
operator|=
name|CPP_MACRO_ARG
expr_stmt|;
name|token
operator|->
name|val
operator|.
name|arg_no
operator|=
name|token
operator|->
name|val
operator|.
name|node
operator|->
name|arg_index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|macro
operator|->
name|paramc
operator|>
literal|0
operator|&&
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CHAR
operator|)
condition|)
name|check_trad_stringification
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|,
operator|&
name|token
operator|->
name|val
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* Parse a macro and save its expansion.  Returns non-zero on success.  */
end_comment

begin_function
name|int
name|_cpp_create_definition
parameter_list|(
name|pfile
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
name|cpp_macro
modifier|*
name|macro
decl_stmt|;
name|cpp_token
modifier|*
name|token
decl_stmt|,
modifier|*
name|saved_cur_token
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|ctoken
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|ok
init|=
literal|1
decl_stmt|;
name|macro
operator|=
operator|(
name|cpp_macro
operator|*
operator|)
name|_cpp_aligned_alloc
argument_list|(
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_macro
argument_list|)
argument_list|)
expr_stmt|;
name|macro
operator|->
name|line
operator|=
name|pfile
operator|->
name|directive_line
expr_stmt|;
name|macro
operator|->
name|params
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|paramc
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|variadic
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|fun_like
operator|=
literal|0
expr_stmt|;
comment|/* Get the first token of the expansion (or the '(' of a      function-like macro).  */
name|ctoken
operator|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctoken
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
operator|&&
operator|!
operator|(
name|ctoken
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
condition|)
block|{
name|ok
operator|=
name|parse_params
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
name|macro
operator|->
name|params
operator|=
operator|(
name|cpp_hashnode
operator|*
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
goto|goto
name|cleanup2
goto|;
comment|/* Success.  Commit the parameter array.  */
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
operator|&
name|macro
operator|->
name|params
index|[
name|macro
operator|->
name|paramc
index|]
expr_stmt|;
name|macro
operator|->
name|fun_like
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctoken
operator|->
name|type
operator|!=
name|CPP_EOF
operator|&&
operator|!
operator|(
name|ctoken
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ISO C requires whitespace after the macro name"
argument_list|)
expr_stmt|;
name|saved_cur_token
operator|=
name|pfile
operator|->
name|cur_token
expr_stmt|;
if|if
condition|(
name|macro
operator|->
name|fun_like
condition|)
name|token
operator|=
name|lex_expansion_token
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
else|else
block|{
name|token
operator|=
name|alloc_expansion_token
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
operator|*
name|token
operator|=
operator|*
name|ctoken
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Check the stringifying # constraint 6.10.3.2.1 of 	 function-like macros when lexing the subsequent token.  */
if|if
condition|(
name|macro
operator|->
name|count
operator|>
literal|1
operator|&&
name|token
index|[
operator|-
literal|1
index|]
operator|.
name|type
operator|==
name|CPP_HASH
operator|&&
name|macro
operator|->
name|fun_like
condition|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_MACRO_ARG
condition|)
block|{
name|token
operator|->
name|flags
operator|&=
operator|~
name|PREV_WHITE
expr_stmt|;
name|token
operator|->
name|flags
operator||=
name|STRINGIFY_ARG
expr_stmt|;
name|token
operator|->
name|flags
operator||=
name|token
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|PREV_WHITE
expr_stmt|;
name|token
index|[
operator|-
literal|1
index|]
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
name|macro
operator|->
name|count
operator|--
expr_stmt|;
block|}
comment|/* Let assembler get away with murder.  */
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|!=
name|CLK_ASM
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"'#' is not followed by a macro parameter"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup1
goto|;
block|}
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
comment|/* Paste operator constraint 6.10.3.3.1.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PASTE
condition|)
block|{
comment|/* Token-paste ##, can appear in both object-like and 	     function-like macros, but not at the ends.  */
if|if
condition|(
operator|--
name|macro
operator|->
name|count
operator|>
literal|0
condition|)
name|token
operator|=
name|lex_expansion_token
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro
operator|->
name|count
operator|==
literal|0
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"'##' cannot appear at either end of a macro expansion"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup1
goto|;
block|}
name|token
index|[
operator|-
literal|1
index|]
operator|.
name|flags
operator||=
name|PASTE_LEFT
expr_stmt|;
block|}
name|token
operator|=
name|lex_expansion_token
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|)
expr_stmt|;
block|}
name|macro
operator|->
name|expansion
operator|=
operator|(
name|cpp_token
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
expr_stmt|;
comment|/* Don't count the CPP_EOF.  */
name|macro
operator|->
name|count
operator|--
expr_stmt|;
comment|/* Clear whitespace on first token for warn_of_redefinition().  */
if|if
condition|(
name|macro
operator|->
name|count
condition|)
name|macro
operator|->
name|expansion
index|[
literal|0
index|]
operator|.
name|flags
operator|&=
operator|~
name|PREV_WHITE
expr_stmt|;
comment|/* Commit the memory.  */
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
operator|&
name|macro
operator|->
name|expansion
index|[
name|macro
operator|->
name|count
index|]
expr_stmt|;
comment|/* Implement the macro-defined-to-itself optimisation.  */
if|if
condition|(
name|macro
operator|->
name|count
operator|==
literal|1
operator|&&
operator|!
name|macro
operator|->
name|fun_like
operator|&&
name|macro
operator|->
name|expansion
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|CPP_NAME
operator|&&
name|macro
operator|->
name|expansion
index|[
literal|0
index|]
operator|.
name|val
operator|.
name|node
operator|==
name|node
condition|)
name|node
operator|->
name|flags
operator||=
name|NODE_DISABLED
expr_stmt|;
comment|/* To suppress some diagnostics.  */
name|macro
operator|->
name|syshdr
operator|=
name|pfile
operator|->
name|map
operator|->
name|sysp
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|!=
name|NT_VOID
condition|)
block|{
if|if
condition|(
name|warn_of_redefinition
argument_list|(
name|node
argument_list|,
name|macro
argument_list|)
condition|)
block|{
name|cpp_pedwarn_with_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|,
literal|0
argument_list|,
literal|"\"%s\" redefined"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|NT_MACRO
operator|&&
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
condition|)
name|cpp_pedwarn_with_line
argument_list|(
name|pfile
argument_list|,
name|node
operator|->
name|value
operator|.
name|macro
operator|->
name|line
argument_list|,
literal|0
argument_list|,
literal|"this is the location of the previous definition"
argument_list|)
expr_stmt|;
block|}
name|_cpp_free_definition
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* Enter definition in hash table.  */
name|node
operator|->
name|type
operator|=
name|NT_MACRO
expr_stmt|;
name|node
operator|->
name|value
operator|.
name|macro
operator|=
name|macro
expr_stmt|;
if|if
condition|(
operator|!
name|ustrncmp
argument_list|(
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|DSC
argument_list|(
literal|"__STDC_"
argument_list|)
argument_list|)
condition|)
name|node
operator|->
name|flags
operator||=
name|NODE_WARN
expr_stmt|;
name|cleanup1
label|:
comment|/* Set type for SEEN_EOL() in cpplib.c, restore the lexer position.  */
name|saved_cur_token
index|[
operator|-
literal|1
index|]
operator|.
name|type
operator|=
name|pfile
operator|->
name|cur_token
index|[
operator|-
literal|1
index|]
operator|.
name|type
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|saved_cur_token
expr_stmt|;
name|cleanup2
label|:
comment|/* Stop the lexer accepting __VA_ARGS__.  */
name|pfile
operator|->
name|state
operator|.
name|va_args_ok
operator|=
literal|0
expr_stmt|;
comment|/* Clear the fast argument lookup indices.  */
for|for
control|(
name|i
operator|=
name|macro
operator|->
name|paramc
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
name|macro
operator|->
name|params
index|[
name|i
index|]
operator|->
name|arg_index
operator|=
literal|0
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Warn if a token in STRING matches one of a function-like MACRO's    parameters.  */
end_comment

begin_function
specifier|static
name|void
name|check_trad_stringification
parameter_list|(
name|pfile
parameter_list|,
name|macro
parameter_list|,
name|string
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_macro
modifier|*
name|macro
decl_stmt|;
specifier|const
name|cpp_string
modifier|*
name|string
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|limit
init|=
name|string
operator|->
name|text
operator|+
name|string
operator|->
name|len
decl_stmt|;
comment|/* Loop over the string.  */
for|for
control|(
name|p
operator|=
name|string
operator|->
name|text
init|;
name|p
operator|<
name|limit
condition|;
name|p
operator|=
name|q
control|)
block|{
comment|/* Find the start of an identifier.  */
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
operator|!
name|is_idstart
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Find the end of the identifier.  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
operator|<
name|limit
operator|&&
name|is_idchar
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|q
operator|++
expr_stmt|;
name|len
operator|=
name|q
operator|-
name|p
expr_stmt|;
comment|/* Loop over the function macro arguments to see if the 	 identifier inside the string matches one of them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|paramc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|cpp_hashnode
modifier|*
name|node
init|=
name|macro
operator|->
name|params
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|NODE_LEN
argument_list|(
name|node
argument_list|)
operator|==
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"macro argument \"%s\" would be stringified with -traditional"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Returns the name, arguments and expansion of a macro, in a format    suitable to be read back in again, and therefore also for DWARF 2    debugging info.  e.g. "PASTE(X, Y) X ## Y", or "MACNAME EXPANSION".    Caller is expected to generate the "#define" bit if needed.  The    returned text is temporary, and automatically freed later.  */
end_comment

begin_function
specifier|const
name|unsigned
name|char
modifier|*
name|cpp_macro_definition
parameter_list|(
name|pfile
parameter_list|,
name|node
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|cpp_macro
modifier|*
name|macro
init|=
name|node
operator|->
name|value
operator|.
name|macro
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|!=
name|NT_MACRO
operator|||
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
condition|)
block|{
name|cpp_ice
argument_list|(
name|pfile
argument_list|,
literal|"invalid hash type %d in cpp_macro_definition"
argument_list|,
name|node
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Calculate length.  */
name|len
operator|=
name|NODE_LEN
argument_list|(
name|node
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* ' ' */
if|if
condition|(
name|macro
operator|->
name|fun_like
condition|)
block|{
name|len
operator|+=
literal|3
expr_stmt|;
comment|/* "()" plus possible final "." of named 			   varargs (we have + 2 below).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|paramc
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|NODE_LEN
argument_list|(
name|macro
operator|->
name|params
index|[
name|i
index|]
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* ", " */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|cpp_token
modifier|*
name|token
init|=
operator|&
name|macro
operator|->
name|expansion
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_MACRO_ARG
condition|)
name|len
operator|+=
name|NODE_LEN
argument_list|(
name|macro
operator|->
name|params
index|[
name|token
operator|->
name|val
operator|.
name|arg_no
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|len
operator|+=
name|cpp_token_len
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|/* Includes room for ' '.  */
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|STRINGIFY_ARG
condition|)
name|len
operator|++
expr_stmt|;
comment|/* "#" */
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
name|len
operator|+=
literal|3
expr_stmt|;
comment|/* " ##" */
block|}
if|if
condition|(
name|len
operator|>
name|pfile
operator|->
name|macro_buffer_len
condition|)
block|{
name|pfile
operator|->
name|macro_buffer
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|pfile
operator|->
name|macro_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|macro_buffer_len
operator|=
name|len
expr_stmt|;
block|}
comment|/* Fill in the buffer.  Start with the macro name.  */
name|buffer
operator|=
name|pfile
operator|->
name|macro_buffer
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|NODE_LEN
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|NODE_LEN
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Parameter names.  */
if|if
condition|(
name|macro
operator|->
name|fun_like
condition|)
block|{
operator|*
name|buffer
operator|++
operator|=
literal|'('
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|paramc
condition|;
name|i
operator|++
control|)
block|{
name|cpp_hashnode
modifier|*
name|param
init|=
name|macro
operator|->
name|params
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|param
operator|!=
name|pfile
operator|->
name|spec_nodes
operator|.
name|n__VA_ARGS__
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|NODE_NAME
argument_list|(
name|param
argument_list|)
argument_list|,
name|NODE_LEN
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|NODE_LEN
argument_list|(
name|param
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|macro
operator|->
name|paramc
condition|)
operator|*
name|buffer
operator|++
operator|=
literal|','
operator|,
operator|*
name|buffer
operator|++
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
name|macro
operator|->
name|variadic
condition|)
operator|*
name|buffer
operator|++
operator|=
literal|'.'
operator|,
operator|*
name|buffer
operator|++
operator|=
literal|'.'
operator|,
operator|*
name|buffer
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|buffer
operator|++
operator|=
literal|')'
expr_stmt|;
block|}
comment|/* Expansion tokens.  */
if|if
condition|(
name|macro
operator|->
name|count
condition|)
block|{
operator|*
name|buffer
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macro
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|cpp_token
modifier|*
name|token
init|=
operator|&
name|macro
operator|->
name|expansion
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
operator|*
name|buffer
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|STRINGIFY_ARG
condition|)
operator|*
name|buffer
operator|++
operator|=
literal|'#'
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_MACRO_ARG
condition|)
block|{
name|len
operator|=
name|NODE_LEN
argument_list|(
name|macro
operator|->
name|params
index|[
name|token
operator|->
name|val
operator|.
name|arg_no
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|NODE_NAME
argument_list|(
name|macro
operator|->
name|params
index|[
name|token
operator|->
name|val
operator|.
name|arg_no
operator|-
literal|1
index|]
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|len
expr_stmt|;
block|}
else|else
name|buffer
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PASTE_LEFT
condition|)
block|{
operator|*
name|buffer
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
literal|'#'
expr_stmt|;
comment|/* Next has PREV_WHITE; see _cpp_create_definition.  */
block|}
block|}
block|}
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
return|return
name|pfile
operator|->
name|macro_buffer
return|;
block|}
end_function

end_unit

