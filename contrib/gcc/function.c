begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expands front end tree to back end RTL for GCC.    Copyright (C) 1987, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* This file handles the generation of rtl code from tree structure    at the level of the function as a whole.    It creates the rtl expressions for parameters and auto variables    and has full responsibility for allocating stack slots.     `expand_function_start' is called at the beginning of a function,    before the function body is parsed, and `expand_function_end' is    called after parsing the body.     Call `assign_stack_local' to allocate a stack slot for a local variable.    This is usually done during the RTL generation for the function body,    but it can also be done in the reload pass when a pseudo-register does    not get a hard register.     Call `put_var_into_stack' when you learn, belatedly, that a variable    previously given a pseudo-register must in fact go in the stack.    This function changes the DECL_RTL to be a stack slot instead of a reg    then scans all the RTL instructions so far generated to correct them.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TRAMPOLINE_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|TRAMPOLINE_ALIGNMENT
value|FUNCTION_BOUNDARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOCAL_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|LOCAL_ALIGNMENT
parameter_list|(
name|TYPE
parameter_list|,
name|ALIGNMENT
parameter_list|)
value|ALIGNMENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_ALIGNMENT_NEEDED
end_ifndef

begin_define
define|#
directive|define
name|STACK_ALIGNMENT_NEEDED
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STACK_BYTES
value|(STACK_BOUNDARY / BITS_PER_UNIT)
end_define

begin_comment
comment|/* Some systems use __main in a way incompatible with its use in gcc, in these    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to    give the same symbol without quotes for an alternative entry point.  You    must define both, or neither.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME__MAIN
end_ifndef

begin_define
define|#
directive|define
name|NAME__MAIN
value|"__main"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Round a value to the lowest integer less than it that is a multiple of    the required alignment.  Avoid using division in case the value is    negative.  Assume the alignment is a power of two.  */
end_comment

begin_define
define|#
directive|define
name|FLOOR_ROUND
parameter_list|(
name|VALUE
parameter_list|,
name|ALIGN
parameter_list|)
value|((VALUE)& ~((ALIGN) - 1))
end_define

begin_comment
comment|/* Similar, but round to the next highest integer that meets the    alignment.  */
end_comment

begin_define
define|#
directive|define
name|CEIL_ROUND
parameter_list|(
name|VALUE
parameter_list|,
name|ALIGN
parameter_list|)
value|(((VALUE) + (ALIGN) - 1)& ~((ALIGN)- 1))
end_define

begin_comment
comment|/* NEED_SEPARATE_AP means that we cannot derive ap from the value of fp    during rtl generation.  If they are different register numbers, this is    always true.  It may also be true if    FIRST_PARM_OFFSET - STARTING_FRAME_OFFSET is not a constant during rtl    generation.  See fix_lexical_addr for details.  */
end_comment

begin_if
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
end_if

begin_define
define|#
directive|define
name|NEED_SEPARATE_AP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if function being compiled doesn't contain any calls    (ignoring the prologue and epilogue).  This is set prior to    local register allocation and is valid for the remaining    compiler passes.  */
end_comment

begin_decl_stmt
name|int
name|current_function_is_leaf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled doesn't contain any instructions    that can throw an exception.  This is set prior to final.  */
end_comment

begin_decl_stmt
name|int
name|current_function_nothrow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled doesn't modify the stack pointer    (ignoring the prologue and epilogue).  This is only valid after    life_analysis has run.  */
end_comment

begin_decl_stmt
name|int
name|current_function_sp_is_unchanging
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the function being compiled is a leaf function which only    uses leaf registers.  This is valid after reload (specifically after    sched2) and is useful only if the port defines LEAF_REGISTERS.  */
end_comment

begin_decl_stmt
name|int
name|current_function_uses_only_leaf_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero once virtual register instantiation has been done.    assign_stack_local uses frame_pointer_rtx when this is nonzero.    calls.c:emit_library_call_value_1 uses it to set up    post-instantiation libcalls.  */
end_comment

begin_decl_stmt
name|int
name|virtuals_instantiated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if at least one trampoline has been created.  */
end_comment

begin_decl_stmt
name|int
name|trampolines_created
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign unique numbers to labels generated for profiling, debugging, etc.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|funcdef_no
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* These variables hold pointers to functions to create and destroy    target specific, per-function data structures.  */
end_comment

begin_function_decl
name|struct
name|machine_function
modifier|*
function_decl|(
modifier|*
name|init_machine_status
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The FUNCTION_DECL for an inline function currently being expanded.  */
end_comment

begin_decl_stmt
name|tree
name|inline_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The currently compiled function.  */
end_comment

begin_decl_stmt
name|struct
name|function
modifier|*
name|cfun
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These arrays record the INSN_UIDs of the prologue and epilogue insns.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|varray_type
name|prologue
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|varray_type
name|epilogue
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Array of INSN_UIDs to hold the INSN_UIDs for each sibcall epilogue    in this function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|varray_type
name|sibcall_epilogue
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* In order to evaluate some expressions, such as function calls returning    structures in memory, we need to temporarily allocate stack locations.    We record each allocated temporary in the following structure.     Associated with each temporary slot is a nesting level.  When we pop up    one level, all temporaries associated with the previous level are freed.    Normally, all temporaries are freed after the execution of the statement    in which they were created.  However, if we are inside a ({...}) grouping,    the result may be in a temporary and hence must be preserved.  If the    result could be in a temporary, we preserve it if we can determine which    one it is in.  If we cannot determine which temporary may contain the    result, all temporaries are preserved.  A temporary is preserved by    pretending it was allocated at the previous nesting level.     Automatic variables are also assigned temporary slots, at the nesting    level where they are defined.  They are marked a "kept" so that    free_temp_slots will not free them.  */
end_comment

begin_decl_stmt
name|struct
name|temp_slot
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Points to next temporary slot.  */
name|struct
name|temp_slot
modifier|*
name|next
decl_stmt|;
comment|/* The rtx to used to reference the slot.  */
name|rtx
name|slot
decl_stmt|;
comment|/* The rtx used to represent the address if not the address of the      slot above.  May be an EXPR_LIST if multiple addresses exist.  */
name|rtx
name|address
decl_stmt|;
comment|/* The alignment (in bits) of the slot.  */
name|unsigned
name|int
name|align
decl_stmt|;
comment|/* The size, in units, of the slot.  */
name|HOST_WIDE_INT
name|size
decl_stmt|;
comment|/* The type of the object in the slot, or zero if it doesn't correspond      to a type.  We use this to determine whether a slot can be reused.      It can be reused if objects of the type of the new slot will always      conflict with objects of the type of the old slot.  */
name|tree
name|type
decl_stmt|;
comment|/* The value of `sequence_rtl_expr' when this temporary is allocated.  */
name|tree
name|rtl_expr
decl_stmt|;
comment|/* Nonzero if this temporary is currently in use.  */
name|char
name|in_use
decl_stmt|;
comment|/* Nonzero if this temporary has its address taken.  */
name|char
name|addr_taken
decl_stmt|;
comment|/* Nesting level at which this slot is being used.  */
name|int
name|level
decl_stmt|;
comment|/* Nonzero if this should survive a call to free_temp_slots.  */
name|int
name|keep
decl_stmt|;
comment|/* The offset of the slot from the frame_pointer, including extra space      for alignment.  This info is for combine_temp_slots.  */
name|HOST_WIDE_INT
name|base_offset
decl_stmt|;
comment|/* The size of the slot, including extra space for alignment.  This      info is for combine_temp_slots.  */
name|HOST_WIDE_INT
name|full_size
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_comment
comment|/* This structure is used to record MEMs or pseudos used to replace VAR, any    SUBREGs of VAR, and any MEMs containing VAR as an address.  We need to    maintain this list in case two operands of an insn were required to match;    in that case we must ensure we use the same replacement.  */
end_comment

begin_decl_stmt
name|struct
name|fixup_replacement
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|rtx
name|old
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|struct
name|fixup_replacement
modifier|*
name|next
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|insns_for_mem_entry
block|{
comment|/* A MEM.  */
name|rtx
name|key
decl_stmt|;
comment|/* These are the INSNs which reference the MEM.  */
name|rtx
name|insns
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|assign_stack_local_1
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|,
name|struct
name|function
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|temp_slot
modifier|*
name|find_temp_slot_from_address
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|put_reg_into_stack
parameter_list|(
name|struct
name|function
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|tree
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|schedule_fixup_var_refs
parameter_list|(
name|struct
name|function
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|tree
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_var_refs
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|fixup_replacement
modifier|*
name|find_fixup_replacement
parameter_list|(
name|struct
name|fixup_replacement
modifier|*
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_var_refs_insns
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_var_refs_insns_with_hash
parameter_list|(
name|htab_t
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_var_refs_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_var_refs_1
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|fixup_replacement
modifier|*
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|fixup_memory_subreg
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|walk_fixup_memory_subreg
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|fixup_stack_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|optimize_bit_field
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|instantiate_decls
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|instantiate_decls_1
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|instantiate_decl
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|instantiate_new_reg
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|instantiate_virtual_regs_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_handlers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_to_arg_alignment
parameter_list|(
name|struct
name|args_size
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|args_size
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_below
parameter_list|(
name|struct
name|args_size
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|round_trampoline_addr
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|adjust_trampoline_addr
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
modifier|*
name|identify_blocks_1
parameter_list|(
name|rtx
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reorder_blocks_0
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reorder_blocks_1
parameter_list|(
name|rtx
parameter_list|,
name|tree
parameter_list|,
name|varray_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reorder_fix_fragments
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|blocks_nreverse
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|all_blocks
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
modifier|*
name|get_block_vector
parameter_list|(
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|tree
name|debug_find_var_in_block_tree
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We always define `record_insns' even if its not used so that we    can always export `prologue_epilogue_contains'.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|record_insns
argument_list|(
name|rtx
argument_list|,
name|varray_type
operator|*
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|contains
parameter_list|(
name|rtx
parameter_list|,
name|varray_type
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_return
end_ifdef

begin_function_decl
specifier|static
name|void
name|emit_return_into_block
parameter_list|(
name|basic_block
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|put_addressof_into_stack
parameter_list|(
name|rtx
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|purge_addressof_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|purge_single_hard_subreg_set
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
operator|&&
name|defined
argument_list|(
name|INCOMING_RETURN_ADDR_RTX
argument_list|)
end_if

begin_function_decl
specifier|static
name|rtx
name|keep_stack_depressed
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|is_addressof
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|insns_for_mem_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insns_for_mem_comp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insns_for_mem_walk
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_insns_for_mem
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prepare_function_start
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_clobber_return_reg
parameter_list|(
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_use_return_reg
parameter_list|(
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|instantiate_virtual_regs_lossage
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|split_complex_args
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|set_insn_locators
argument_list|(
name|rtx
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Pointer to chain of `struct function' for containing functions.  */
end_comment

begin_decl_stmt
name|struct
name|function
modifier|*
name|outer_function_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of insns that were postponed by purge_addressof_1.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|postponed_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a function decl for a containing function,    return the `struct function' for it.  */
end_comment

begin_function
name|struct
name|function
modifier|*
name|find_function_data
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|function
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|outer_function_chain
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|outer
control|)
if|if
condition|(
name|p
operator|->
name|decl
operator|==
name|decl
condition|)
return|return
name|p
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the current context for compilation of a nested function.    This is called from language-specific code.  The caller should use    the enter_nested langhook to save any language-specific state,    since this function knows only about language-independent    variables.  */
end_comment

begin_function
name|void
name|push_function_context_to
parameter_list|(
name|tree
name|context
parameter_list|)
block|{
name|struct
name|function
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|context
operator|==
name|current_function_decl
condition|)
name|cfun
operator|->
name|contains_functions
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|struct
name|function
modifier|*
name|containing
init|=
name|find_function_data
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|containing
operator|->
name|contains_functions
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cfun
operator|==
literal|0
condition|)
name|init_dummy_function_start
argument_list|()
expr_stmt|;
name|p
operator|=
name|cfun
expr_stmt|;
name|p
operator|->
name|outer
operator|=
name|outer_function_chain
expr_stmt|;
name|outer_function_chain
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|fixup_var_refs_queue
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|function
operator|.
name|enter_nested
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cfun
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_function_context
parameter_list|(
name|void
parameter_list|)
block|{
name|push_function_context_to
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the last saved context, at the end of a nested function.    This function is called from language-specific code.  */
end_comment

begin_function
name|void
name|pop_function_context_from
parameter_list|(
name|tree
name|context
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|function
modifier|*
name|p
init|=
name|outer_function_chain
decl_stmt|;
name|struct
name|var_refs_queue
modifier|*
name|queue
decl_stmt|;
name|cfun
operator|=
name|p
expr_stmt|;
name|outer_function_chain
operator|=
name|p
operator|->
name|outer
expr_stmt|;
name|current_function_decl
operator|=
name|p
operator|->
name|decl
expr_stmt|;
name|reg_renumber
operator|=
literal|0
expr_stmt|;
name|restore_emit_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|function
operator|.
name|leave_nested
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Finish doing put_var_into_stack for any of our variables which became      addressable during the nested function.  If only one entry has to be      fixed up, just do that one.  Otherwise, first make a list of MEMs that      are not to be unshared.  */
if|if
condition|(
name|p
operator|->
name|fixup_var_refs_queue
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|fixup_var_refs_queue
operator|->
name|next
operator|==
literal|0
condition|)
name|fixup_var_refs
argument_list|(
name|p
operator|->
name|fixup_var_refs_queue
operator|->
name|modified
argument_list|,
name|p
operator|->
name|fixup_var_refs_queue
operator|->
name|promoted_mode
argument_list|,
name|p
operator|->
name|fixup_var_refs_queue
operator|->
name|unsignedp
argument_list|,
name|p
operator|->
name|fixup_var_refs_queue
operator|->
name|modified
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|list
init|=
literal|0
decl_stmt|;
for|for
control|(
name|queue
operator|=
name|p
operator|->
name|fixup_var_refs_queue
init|;
name|queue
condition|;
name|queue
operator|=
name|queue
operator|->
name|next
control|)
name|list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|queue
operator|->
name|modified
argument_list|,
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|queue
operator|=
name|p
operator|->
name|fixup_var_refs_queue
init|;
name|queue
condition|;
name|queue
operator|=
name|queue
operator|->
name|next
control|)
name|fixup_var_refs
argument_list|(
name|queue
operator|->
name|modified
argument_list|,
name|queue
operator|->
name|promoted_mode
argument_list|,
name|queue
operator|->
name|unsignedp
argument_list|,
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|fixup_var_refs_queue
operator|=
literal|0
expr_stmt|;
comment|/* Reset variables that have known state during rtx generation.  */
name|rtx_equal_function_value_matters
operator|=
literal|1
expr_stmt|;
name|virtuals_instantiated
operator|=
literal|0
expr_stmt|;
name|generating_concat_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_function_context
parameter_list|(
name|void
parameter_list|)
block|{
name|pop_function_context_from
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out all parts of the state in F that can safely be discarded    after the function has been parsed, but not compiled, to let    garbage collection reclaim the memory.  */
end_comment

begin_function
name|void
name|free_after_parsing
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
comment|/* f->expr->forced_labels is used by code generation.  */
comment|/* f->emit->regno_reg_rtx is used by code generation.  */
comment|/* f->varasm is used by code generation.  */
comment|/* f->eh->eh_return_stub_label is used by code generation.  */
call|(
modifier|*
name|lang_hooks
operator|.
name|function
operator|.
name|final
call|)
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|stmt
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out all parts of the state in F that can safely be discarded    after the function has been compiled, to let garbage collection    reclaim the memory.  */
end_comment

begin_function
name|void
name|free_after_compilation
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|f
operator|->
name|eh
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|expr
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|emit
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|varasm
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|machine
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_temp_slots
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|arg_offset_rtx
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|return_rtx
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|internal_arg_pointer
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_nonlocal_labels
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_nonlocal_goto_handler_slots
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_nonlocal_goto_handler_labels
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_nonlocal_goto_stack_level
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_cleanup_label
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_return_label
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_naked_return_label
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|computed_goto_common_label
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|computed_goto_common_reg
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_save_expr_regs
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_stack_slot_list
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_rtl_expr_chain
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_tail_recursion_label
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_tail_recursion_reentry
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_arg_pointer_save_area
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_clobber_return_insn
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_context_display
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_trampoline_list
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_parm_birth_insn
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_last_parm_insn
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_parm_reg_stack_loc
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|fixup_var_refs_queue
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|original_arg_vector
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|original_decl_initial
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|inl_last_parm_insn
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|epilogue_delay_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate fixed slots in the stack frame of the current function.  */
end_comment

begin_comment
comment|/* Return size needed for stack frame based on slots so far allocated in    function F.    This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;    the caller may have to do that.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|get_func_frame_size
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
return|return
operator|-
name|f
operator|->
name|x_frame_offset
return|;
else|#
directive|else
return|return
name|f
operator|->
name|x_frame_offset
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return size needed for stack frame based on slots so far allocated.    This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;    the caller may have to do that.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|get_frame_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|get_func_frame_size
argument_list|(
name|cfun
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a stack slot of SIZE bytes and return a MEM rtx for it    with machine mode MODE.     ALIGN controls the amount of alignment for the address of the slot:    0 means according to MODE,    -1 means use BIGGEST_ALIGNMENT and round size to multiple of that,    -2 means use BITS_PER_UNIT,    positive specifies alignment boundary in bits.     We do not round to stack_boundary here.     FUNCTION specifies the function to allocate in.  */
end_comment

begin_function
specifier|static
name|rtx
name|assign_stack_local_1
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|align
parameter_list|,
name|struct
name|function
modifier|*
name|function
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|bigend_correction
init|=
literal|0
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|int
name|frame_off
decl_stmt|,
name|frame_alignment
decl_stmt|,
name|frame_phase
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|0
condition|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
else|else
name|alignment
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Allow the target to (possibly) increase the alignment of this 	 stack slot.  */
name|type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|alignment
operator|=
name|LOCAL_ALIGNMENT
argument_list|(
name|type
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|alignment
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|==
operator|-
literal|1
condition|)
block|{
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|size
operator|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|==
operator|-
literal|2
condition|)
name|alignment
operator|=
literal|1
expr_stmt|;
comment|/* BITS_PER_UNIT / BITS_PER_UNIT */
else|else
name|alignment
operator|=
name|align
operator|/
name|BITS_PER_UNIT
expr_stmt|;
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|function
operator|->
name|x_frame_offset
operator|-=
name|size
expr_stmt|;
endif|#
directive|endif
comment|/* Ignore alignment we can't do with expected alignment of the boundary.  */
if|if
condition|(
name|alignment
operator|*
name|BITS_PER_UNIT
operator|>
name|PREFERRED_STACK_BOUNDARY
condition|)
name|alignment
operator|=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|function
operator|->
name|stack_alignment_needed
operator|<
name|alignment
operator|*
name|BITS_PER_UNIT
condition|)
name|function
operator|->
name|stack_alignment_needed
operator|=
name|alignment
operator|*
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Calculate how many bytes the start of local variables is off from      stack alignment.  */
name|frame_alignment
operator|=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|frame_off
operator|=
name|STARTING_FRAME_OFFSET
operator|%
name|frame_alignment
expr_stmt|;
name|frame_phase
operator|=
name|frame_off
condition|?
name|frame_alignment
operator|-
name|frame_off
else|:
literal|0
expr_stmt|;
comment|/* Round the frame offset to the specified alignment.  The default is      to always honor requests to align the stack but a port may choose to      do its own stack alignment by defining STACK_ALIGNMENT_NEEDED.  */
if|if
condition|(
name|STACK_ALIGNMENT_NEEDED
operator|||
name|mode
operator|!=
name|BLKmode
operator|||
name|size
operator|!=
literal|0
condition|)
block|{
comment|/*  We must be careful here, since FRAME_OFFSET might be negative and 	  division with a negative dividend isn't as well defined as we might 	  like.  So we instead assume that ALIGNMENT is a power of two and 	  use logical operations which are unambiguous.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|function
operator|->
name|x_frame_offset
operator|=
operator|(
name|FLOOR_ROUND
argument_list|(
name|function
operator|->
name|x_frame_offset
operator|-
name|frame_phase
argument_list|,
name|alignment
argument_list|)
operator|+
name|frame_phase
operator|)
expr_stmt|;
else|#
directive|else
name|function
operator|->
name|x_frame_offset
operator|=
operator|(
name|CEIL_ROUND
argument_list|(
name|function
operator|->
name|x_frame_offset
operator|-
name|frame_phase
argument_list|,
name|alignment
argument_list|)
operator|+
name|frame_phase
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* On a big-endian machine, if we are allocating more space than we will use,      use the least significant bytes of those that are allocated.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
name|bigend_correction
operator|=
name|size
operator|-
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* If we have already instantiated virtual registers, return the actual      address relative to the frame pointer.  */
if|if
condition|(
name|function
operator|==
name|cfun
operator|&&
name|virtuals_instantiated
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|trunc_int_for_mode
argument_list|(
name|frame_offset
operator|+
name|bigend_correction
operator|+
name|STARTING_FRAME_OFFSET
argument_list|,
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|plus_constant
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|trunc_int_for_mode
argument_list|(
name|function
operator|->
name|x_frame_offset
operator|+
name|bigend_correction
argument_list|,
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FRAME_GROWS_DOWNWARD
name|function
operator|->
name|x_frame_offset
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|function
operator|->
name|x_stack_slot_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|function
operator|->
name|x_stack_slot_list
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Wrapper around assign_stack_local_1;  assign a local stack slot for the    current function.  */
end_comment

begin_function
name|rtx
name|assign_stack_local
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
return|return
name|assign_stack_local_1
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|cfun
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a temporary stack slot and record it for possible later    reuse.     MODE is the machine mode to be given to the returned rtx.     SIZE is the size in units of the space required.  We do no rounding here    since assign_stack_local will do any required rounding.     KEEP is 1 if this slot is to be retained after a call to    free_temp_slots.  Automatic variables for a block are allocated    with this flag.  KEEP is 2 if we allocate a longer term temporary,    whose lifetime is controlled by CLEANUP_POINT_EXPRs.  KEEP is 3    if we are to allocate something at an inner level to be treated as    a variable in the block (e.g., a SAVE_EXPR).     TYPE is the type that will be used for the stack slot.  */
end_comment

begin_function
name|rtx
name|assign_stack_temp_for_type
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|keep
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|unsigned
name|int
name|align
decl_stmt|;
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|,
modifier|*
name|best_p
init|=
literal|0
decl_stmt|;
name|rtx
name|slot
decl_stmt|;
comment|/* If SIZE is -1 it means that somebody tried to allocate a temporary      of a variable size.  */
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|align
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
else|else
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|align
operator|=
name|LOCAL_ALIGNMENT
argument_list|(
name|type
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Try to find an available, already-allocated temporary of the proper      mode which meets the size and alignment requirements.  Choose the      smallest one with the closest alignment.  */
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|align
operator|>=
name|align
operator|&&
name|p
operator|->
name|size
operator|>=
name|size
operator|&&
name|GET_MODE
argument_list|(
name|p
operator|->
name|slot
argument_list|)
operator|==
name|mode
operator|&&
operator|!
name|p
operator|->
name|in_use
operator|&&
name|objects_must_conflict_p
argument_list|(
name|p
operator|->
name|type
argument_list|,
name|type
argument_list|)
operator|&&
operator|(
name|best_p
operator|==
literal|0
operator|||
name|best_p
operator|->
name|size
operator|>
name|p
operator|->
name|size
operator|||
operator|(
name|best_p
operator|->
name|size
operator|==
name|p
operator|->
name|size
operator|&&
name|best_p
operator|->
name|align
operator|>
name|p
operator|->
name|align
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|align
operator|==
name|align
operator|&&
name|p
operator|->
name|size
operator|==
name|size
condition|)
block|{
name|best_p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|best_p
operator|=
name|p
expr_stmt|;
block|}
comment|/* Make our best, if any, the one to use.  */
if|if
condition|(
name|best_p
condition|)
block|{
comment|/* If there are enough aligned bytes left over, make them into a new 	 temp_slot so that the extra bytes don't get wasted.  Do this only 	 for BLKmode slots, so that we can be sure of the alignment.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|best_p
operator|->
name|slot
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|int
name|alignment
init|=
name|best_p
operator|->
name|align
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|rounded_size
init|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
if|if
condition|(
name|best_p
operator|->
name|size
operator|-
name|rounded_size
operator|>=
name|alignment
condition|)
block|{
name|p
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_slot
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|in_use
operator|=
name|p
operator|->
name|addr_taken
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|best_p
operator|->
name|size
operator|-
name|rounded_size
expr_stmt|;
name|p
operator|->
name|base_offset
operator|=
name|best_p
operator|->
name|base_offset
operator|+
name|rounded_size
expr_stmt|;
name|p
operator|->
name|full_size
operator|=
name|best_p
operator|->
name|full_size
operator|-
name|rounded_size
expr_stmt|;
name|p
operator|->
name|slot
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|best_p
operator|->
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rounded_size
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|align
operator|=
name|best_p
operator|->
name|align
expr_stmt|;
name|p
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rtl_expr
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|best_p
operator|->
name|type
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|temp_slots
expr_stmt|;
name|temp_slots
operator|=
name|p
expr_stmt|;
name|stack_slot_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|p
operator|->
name|slot
argument_list|,
name|stack_slot_list
argument_list|)
expr_stmt|;
name|best_p
operator|->
name|size
operator|=
name|rounded_size
expr_stmt|;
name|best_p
operator|->
name|full_size
operator|=
name|rounded_size
expr_stmt|;
block|}
block|}
name|p
operator|=
name|best_p
expr_stmt|;
block|}
comment|/* If we still didn't find one, make a new temporary.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|frame_offset_old
init|=
name|frame_offset
decl_stmt|;
name|p
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_slot
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are passing an explicit alignment request to assign_stack_local. 	 One side effect of that is assign_stack_local will not round SIZE 	 to ensure the frame offset remains suitably aligned.  	 So for requests which depended on the rounding of SIZE, we go ahead 	 and round it now.  We also make sure ALIGNMENT is at least 	 BIGGEST_ALIGNMENT.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|align
operator|<
name|BIGGEST_ALIGNMENT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p
operator|->
name|slot
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
operator|(
name|mode
operator|==
name|BLKmode
condition|?
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
operator|(
name|int
operator|)
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
else|:
name|size
operator|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|p
operator|->
name|align
operator|=
name|align
expr_stmt|;
comment|/* The following slot size computation is necessary because we don't 	 know the actual size of the temporary slot until assign_stack_local 	 has performed all the frame alignment and size rounding for the 	 requested temporary.  Note that extra space added for alignment 	 can be either above or below this stack slot depending on which 	 way the frame grows.  We include the extra space if and only if it 	 is above this slot.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|p
operator|->
name|size
operator|=
name|frame_offset_old
operator|-
name|frame_offset
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|size
operator|=
name|size
expr_stmt|;
endif|#
directive|endif
comment|/* Now define the fields used by combine_temp_slots.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|p
operator|->
name|base_offset
operator|=
name|frame_offset
expr_stmt|;
name|p
operator|->
name|full_size
operator|=
name|frame_offset_old
operator|-
name|frame_offset
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|base_offset
operator|=
name|frame_offset_old
expr_stmt|;
name|p
operator|->
name|full_size
operator|=
name|frame_offset
operator|-
name|frame_offset_old
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|temp_slots
expr_stmt|;
name|temp_slots
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|->
name|in_use
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|addr_taken
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rtl_expr
operator|=
name|seq_rtl_expr
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|keep
operator|==
literal|2
condition|)
block|{
name|p
operator|->
name|level
operator|=
name|target_temp_slot_level
expr_stmt|;
name|p
operator|->
name|keep
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keep
operator|==
literal|3
condition|)
block|{
name|p
operator|->
name|level
operator|=
name|var_temp_slot_level
expr_stmt|;
name|p
operator|->
name|keep
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|level
operator|=
name|temp_slot_level
expr_stmt|;
name|p
operator|->
name|keep
operator|=
name|keep
expr_stmt|;
block|}
comment|/* Create a new MEM rtx to avoid clobbering MEM flags of old slots.  */
name|slot
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|p
operator|->
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|stack_slot_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|slot
argument_list|,
name|stack_slot_list
argument_list|)
expr_stmt|;
comment|/* If we know the alias set for the memory that will be used, use      it.  If there's no TYPE, then we don't know anything about the      alias set for the memory.  */
name|set_mem_alias_set
argument_list|(
name|slot
argument_list|,
name|type
condition|?
name|get_alias_set
argument_list|(
name|type
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|slot
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* If a type is specified, set the relevant flags.  */
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
name|RTX_UNCHANGING_P
argument_list|(
name|slot
argument_list|)
operator|=
operator|(
name|lang_hooks
operator|.
name|honor_readonly
operator|&&
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|slot
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|slot
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Allocate a temporary stack slot and record it for possible later    reuse.  First three arguments are same as in preceding function.  */
end_comment

begin_function
name|rtx
name|assign_stack_temp
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|keep
parameter_list|)
block|{
return|return
name|assign_stack_temp_for_type
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
name|keep
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign a temporary.    If TYPE_OR_DECL is a decl, then we are doing it on behalf of the decl    and so that should be used in error messages.  In either case, we    allocate of the given type.    KEEP is as for assign_stack_temp.    MEMORY_REQUIRED is 1 if the result must be addressable stack memory;    it is 0 if a register is OK.    DONT_PROMOTE is 1 if we should not promote values in register    to wider modes.  */
end_comment

begin_function
name|rtx
name|assign_temp
parameter_list|(
name|tree
name|type_or_decl
parameter_list|,
name|int
name|keep
parameter_list|,
name|int
name|memory_required
parameter_list|,
name|int
name|dont_promote
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
ifndef|#
directive|ifndef
name|PROMOTE_FOR_CALL_ONLY
name|int
name|unsignedp
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DECL_P
argument_list|(
name|type_or_decl
argument_list|)
condition|)
name|decl
operator|=
name|type_or_decl
operator|,
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|NULL
operator|,
name|type
operator|=
name|type_or_decl
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PROMOTE_FOR_CALL_ONLY
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
name|memory_required
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* Zero sized arrays are GNU C extension.  Set size to 1 to avoid 	 problems with allocating the stack space.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
comment|/* Unfortunately, we don't yet know how to allocate variable-sized 	 temporaries.  However, sometimes we have a fixed upper limit on 	 the size (which is stored in TYPE_ARRAY_MAX_SIZE) and can use that 	 instead.  This is the case for Chill variable-sized strings.  */
if|if
condition|(
name|size
operator|==
operator|-
literal|1
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_ARRAY_MAX_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|host_integerp
argument_list|(
name|TYPE_ARRAY_MAX_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|size
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_ARRAY_MAX_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The size of the temporary may be too large to fit into an integer.  */
comment|/* ??? Not sure this should happen except for user silliness, so limit 	 this to things that aren't compiler-generated temporaries.  The 	 rest of the time we'll abort in assign_stack_temp_for_type.  */
if|if
condition|(
name|decl
operator|&&
name|size
operator|==
operator|-
literal|1
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"%Jsize of variable '%D' is too large"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
name|tmp
operator|=
name|assign_stack_temp_for_type
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
name|keep
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
ifndef|#
directive|ifndef
name|PROMOTE_FOR_CALL_ONLY
if|if
condition|(
operator|!
name|dont_promote
condition|)
name|mode
operator|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Combine temporary stack slots which are adjacent on the stack.     This allows for better use of already allocated stack space.  This is only    done for BLKmode slots because we can be sure that we won't have alignment    problems in this case.  */
end_comment

begin_function
name|void
name|combine_temp_slots
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|temp_slot
modifier|*
name|prev_p
decl_stmt|,
modifier|*
name|prev_q
decl_stmt|;
name|int
name|num_slots
decl_stmt|;
comment|/* We can't combine slots, because the information about which slot      is in which alias set will be lost.  */
if|if
condition|(
name|flag_strict_aliasing
condition|)
return|return;
comment|/* If there are a lot of temp slots, don't do anything unless      high levels of optimization.  */
if|if
condition|(
operator|!
name|flag_expensive_optimizations
condition|)
for|for
control|(
name|p
operator|=
name|temp_slots
operator|,
name|num_slots
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
operator|,
name|num_slots
operator|++
control|)
if|if
condition|(
name|num_slots
operator|>
literal|100
operator|||
operator|(
name|num_slots
operator|>
literal|10
operator|&&
name|optimize
operator|==
literal|0
operator|)
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|temp_slots
operator|,
name|prev_p
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|prev_p
condition|?
name|prev_p
operator|->
name|next
else|:
name|temp_slots
control|)
block|{
name|int
name|delete_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|in_use
operator|&&
name|GET_MODE
argument_list|(
name|p
operator|->
name|slot
argument_list|)
operator|==
name|BLKmode
condition|)
for|for
control|(
name|q
operator|=
name|p
operator|->
name|next
operator|,
name|prev_q
operator|=
name|p
init|;
name|q
condition|;
name|q
operator|=
name|prev_q
operator|->
name|next
control|)
block|{
name|int
name|delete_q
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|in_use
operator|&&
name|GET_MODE
argument_list|(
name|q
operator|->
name|slot
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|base_offset
operator|+
name|p
operator|->
name|full_size
operator|==
name|q
operator|->
name|base_offset
condition|)
block|{
comment|/* Q comes after P; combine Q into P.  */
name|p
operator|->
name|size
operator|+=
name|q
operator|->
name|size
expr_stmt|;
name|p
operator|->
name|full_size
operator|+=
name|q
operator|->
name|full_size
expr_stmt|;
name|delete_q
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|base_offset
operator|+
name|q
operator|->
name|full_size
operator|==
name|p
operator|->
name|base_offset
condition|)
block|{
comment|/* P comes after Q; combine P into Q.  */
name|q
operator|->
name|size
operator|+=
name|p
operator|->
name|size
expr_stmt|;
name|q
operator|->
name|full_size
operator|+=
name|p
operator|->
name|full_size
expr_stmt|;
name|delete_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Either delete Q or advance past it.  */
if|if
condition|(
name|delete_q
condition|)
name|prev_q
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
else|else
name|prev_q
operator|=
name|q
expr_stmt|;
block|}
comment|/* Either delete P or advance past it.  */
if|if
condition|(
name|delete_p
condition|)
block|{
if|if
condition|(
name|prev_p
condition|)
name|prev_p
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|temp_slots
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
else|else
name|prev_p
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the temp slot corresponding to the object at address X.  */
end_comment

begin_function
specifier|static
name|struct
name|temp_slot
modifier|*
name|find_temp_slot_from_address
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
name|rtx
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|in_use
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|p
operator|->
name|slot
argument_list|,
literal|0
argument_list|)
operator|==
name|x
operator|||
name|p
operator|->
name|address
operator|==
name|x
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
name|p
operator|->
name|base_offset
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|p
operator|->
name|base_offset
operator|+
name|p
operator|->
name|full_size
operator|)
condition|)
return|return
name|p
return|;
elseif|else
if|if
condition|(
name|p
operator|->
name|address
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|p
operator|->
name|address
argument_list|)
operator|==
name|EXPR_LIST
condition|)
for|for
control|(
name|next
operator|=
name|p
operator|->
name|address
init|;
name|next
condition|;
name|next
operator|=
name|XEXP
argument_list|(
name|next
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|)
operator|==
name|x
condition|)
return|return
name|p
return|;
block|}
comment|/* If we have a sum involving a register, see if it points to a temp      slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|p
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|p
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Indicate that NEW is an alternate way of referring to the temp slot    that previously was known by OLD.  */
end_comment

begin_function
name|void
name|update_temp_slot_address
parameter_list|(
name|rtx
name|old
parameter_list|,
name|rtx
name|new
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
condition|)
return|return;
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|old
argument_list|)
expr_stmt|;
comment|/* If we didn't find one, see if both OLD is a PLUS.  If so, and NEW      is a register, see if one operand of the PLUS is a temporary      location.  If so, NEW points into it.  Otherwise, if both OLD and      NEW are a PLUS and if there is a register in common between them.      If so, try a recursive call on those values.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|PLUS
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|REG
condition|)
block|{
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|!=
name|PLUS
condition|)
return|return;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise add an alias for the temp's address.  */
elseif|else
if|if
condition|(
name|p
operator|->
name|address
operator|==
literal|0
condition|)
name|p
operator|->
name|address
operator|=
name|new
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|address
argument_list|)
operator|!=
name|EXPR_LIST
condition|)
name|p
operator|->
name|address
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|p
operator|->
name|address
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|p
operator|->
name|address
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|new
argument_list|,
name|p
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If X could be a reference to a temporary slot, mark the fact that its    address was taken.  */
end_comment

begin_function
name|void
name|mark_temp_addr_taken
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
comment|/* If X is not in memory or is at a constant address, it cannot be in      a temporary slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return;
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
name|p
operator|->
name|addr_taken
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If X could be a reference to a temporary slot, mark that slot as    belonging to the to one level higher than the current level.  If X    matched one of our slots, just mark that one.  Otherwise, we can't    easily predict which it is, so upgrade all of them.  Kept slots    need not be touched.     This is called when an ({...}) construct occurs and a statement    returns a value in memory.  */
end_comment

begin_function
name|void
name|preserve_temp_slots
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
init|=
literal|0
decl_stmt|;
comment|/* If there is no result, we still might have some objects whose address      were taken, so we need to make sure they stay around.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
name|p
operator|->
name|addr_taken
condition|)
name|p
operator|->
name|level
operator|--
expr_stmt|;
return|return;
block|}
comment|/* If X is a register that is being used as a pointer, see if we have      a temporary slot we know it points to.  To be consistent with      the code below, we really should preserve all non-kept slots      if we can't find a match, but that seems to be much too costly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|x
argument_list|)
condition|)
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If X is not in memory or is at a constant address, it cannot be in      a temporary slot, but it can contain something whose address was      taken.  */
if|if
condition|(
name|p
operator|==
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
name|p
operator|->
name|addr_taken
condition|)
name|p
operator|->
name|level
operator|--
expr_stmt|;
return|return;
block|}
comment|/* First see if we can find a match.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
comment|/* Move everything at our level whose address was taken to our new 	 level in case we used its address.  */
name|struct
name|temp_slot
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|level
operator|==
name|temp_slot_level
condition|)
block|{
for|for
control|(
name|q
operator|=
name|temp_slots
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|!=
name|p
operator|&&
name|q
operator|->
name|addr_taken
operator|&&
name|q
operator|->
name|level
operator|==
name|p
operator|->
name|level
condition|)
name|q
operator|->
name|level
operator|--
expr_stmt|;
name|p
operator|->
name|level
operator|--
expr_stmt|;
name|p
operator|->
name|addr_taken
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
comment|/* Otherwise, preserve all non-kept slots at this level.  */
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
operator|!
name|p
operator|->
name|keep
condition|)
name|p
operator|->
name|level
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* X is the result of an RTL_EXPR.  If it is a temporary slot associated    with that RTL_EXPR, promote it into a temporary slot at the present    level so it will not be freed when we free slots made in the    RTL_EXPR.  */
end_comment

begin_function
name|void
name|preserve_rtl_expr_result
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
comment|/* If X is not in memory or is at a constant address, it cannot be in      a temporary slot.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* If we can find a match, move it to our level unless it is already at      an upper level.  */
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
name|p
operator|->
name|level
operator|=
name|MIN
argument_list|(
name|p
operator|->
name|level
argument_list|,
name|temp_slot_level
argument_list|)
expr_stmt|;
name|p
operator|->
name|rtl_expr
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Free all temporaries used so far.  This is normally called at the end    of generating code for a statement.  Don't free any temporaries    currently in use for an RTL_EXPR that hasn't yet been emitted.    We could eventually do better than this since it can be reused while    generating the same RTL_EXPR, but this is complex and probably not    worthwhile.  */
end_comment

begin_function
name|void
name|free_temp_slots
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
operator|!
name|p
operator|->
name|keep
operator|&&
name|p
operator|->
name|rtl_expr
operator|==
literal|0
condition|)
name|p
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
name|combine_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all temporary slots used in T, an RTL_EXPR node.  */
end_comment

begin_function
name|void
name|free_temps_for_rtl_expr
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|rtl_expr
operator|==
name|t
condition|)
block|{
comment|/* If this slot is below the current TEMP_SLOT_LEVEL, then it 	   needs to be preserved.  This can happen if a temporary in 	   the RTL_EXPR was addressed; preserve_temp_slots will move 	   the temporary into a higher level.  */
if|if
condition|(
name|temp_slot_level
operator|<=
name|p
operator|->
name|level
condition|)
name|p
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
else|else
name|p
operator|->
name|rtl_expr
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|combine_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark all temporaries ever allocated in this function as not suitable    for reuse until the current level is exited.  */
end_comment

begin_function
name|void
name|mark_all_temps_used
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|p
operator|->
name|in_use
operator|=
name|p
operator|->
name|keep
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|level
operator|=
name|MIN
argument_list|(
name|p
operator|->
name|level
argument_list|,
name|temp_slot_level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Push deeper into the nesting level for stack temporaries.  */
end_comment

begin_function
name|void
name|push_temp_slots
parameter_list|(
name|void
parameter_list|)
block|{
name|temp_slot_level
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a temporary nesting level.  All slots in use in the current level    are freed.  */
end_comment

begin_function
name|void
name|pop_temp_slots
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
name|p
operator|->
name|rtl_expr
operator|==
literal|0
condition|)
name|p
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
name|combine_temp_slots
argument_list|()
expr_stmt|;
name|temp_slot_level
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize temporary slots.  */
end_comment

begin_function
name|void
name|init_temp_slots
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We have not allocated any temporaries yet.  */
name|temp_slots
operator|=
literal|0
expr_stmt|;
name|temp_slot_level
operator|=
literal|0
expr_stmt|;
name|var_temp_slot_level
operator|=
literal|0
expr_stmt|;
name|target_temp_slot_level
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Retroactively move an auto variable from a register to a stack    slot.  This is done when an address-reference to the variable is    seen.  If RESCAN is true, all previously emitted instructions are    examined and modified to handle the fact that DECL is now    addressable.  */
end_comment

begin_function
name|void
name|put_var_into_stack
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|rescan
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|,
name|decl_mode
decl_stmt|;
name|struct
name|function
modifier|*
name|function
init|=
literal|0
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|bool
name|can_use_addressof_p
decl_stmt|;
name|bool
name|volatile_p
init|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|SAVE_EXPR
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|bool
name|used_p
init|=
operator|(
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|SAVE_EXPR
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|)
operator|)
decl_stmt|;
name|context
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Get the current rtl used for this object and its original mode.  */
name|reg
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SAVE_EXPR
condition|?
name|SAVE_EXPR_RTL
argument_list|(
name|decl
argument_list|)
else|:
name|DECL_RTL_IF_SET
argument_list|(
name|decl
argument_list|)
operator|)
expr_stmt|;
comment|/* No need to do anything if decl has no rtx yet      since in that case caller is setting TREE_ADDRESSABLE      and a stack slot will be assigned when the rtl is made.  */
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
comment|/* Get the declared mode for this object.  */
name|decl_mode
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SAVE_EXPR
condition|?
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the mode it's actually stored in.  */
name|promoted_mode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* If this variable comes from an outer function, find that      function's saved context.  Don't use find_function_data here,      because it might not be in any active function.      FIXME: Is that really supposed to happen?      It does in ObjC at least.  */
if|if
condition|(
name|context
operator|!=
name|current_function_decl
operator|&&
name|context
operator|!=
name|inline_function_decl
condition|)
for|for
control|(
name|function
operator|=
name|outer_function_chain
init|;
name|function
condition|;
name|function
operator|=
name|function
operator|->
name|outer
control|)
if|if
condition|(
name|function
operator|->
name|decl
operator|==
name|context
condition|)
break|break;
comment|/* If this is a variable-sized object or a structure passed by invisible      reference, with a pseudo to address it, put that pseudo into the stack      if the var is non-local.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|SAVE_EXPR
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl_mode
operator|=
name|promoted_mode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* If this variable lives in the current function and we don't need to put it      in the stack for the sake of setjmp or the non-locality, try to keep it in      a register until we know we actually need the address.  */
name|can_use_addressof_p
operator|=
operator|(
name|function
operator|==
literal|0
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|SAVE_EXPR
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|optimize
operator|>
literal|0
comment|/* FIXME make it work for promoted modes too */
operator|&&
name|decl_mode
operator|==
name|promoted_mode
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
operator|&&
operator|!
operator|(
name|NON_SAVING_SETJMP
operator|&&
name|current_function_calls_setjmp
operator|)
endif|#
directive|endif
operator|)
expr_stmt|;
comment|/* If we can't use ADDRESSOF, make sure we see through one we already      generated.  */
if|if
condition|(
operator|!
name|can_use_addressof_p
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now we should have a value that resides in one or more pseudo regs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|can_use_addressof_p
condition|)
name|gen_mem_addressof
argument_list|(
name|reg
argument_list|,
name|decl
argument_list|,
name|rescan
argument_list|)
expr_stmt|;
else|else
name|put_reg_into_stack
argument_list|(
name|function
argument_list|,
name|reg
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl_mode
argument_list|,
literal|0
argument_list|,
name|volatile_p
argument_list|,
name|used_p
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
comment|/* A CONCAT contains two pseudos; put them both in the stack. 	 We do it so they end up consecutive. 	 We fixup references to the parts only after we fixup references 	 to the whole CONCAT, lest we do double fixups for the latter 	 references.  */
name|enum
name|machine_mode
name|part_mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|part_type
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|part_mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|lopart
init|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|hipart
init|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
comment|/* Since part 0 should have a lower address, do it second.  */
name|put_reg_into_stack
argument_list|(
name|function
argument_list|,
name|hipart
argument_list|,
name|part_type
argument_list|,
name|part_mode
argument_list|,
literal|0
argument_list|,
name|volatile_p
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_reg_into_stack
argument_list|(
name|function
argument_list|,
name|lopart
argument_list|,
name|part_type
argument_list|,
name|part_mode
argument_list|,
literal|0
argument_list|,
name|volatile_p
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|put_reg_into_stack
argument_list|(
name|function
argument_list|,
name|lopart
argument_list|,
name|part_type
argument_list|,
name|part_mode
argument_list|,
literal|0
argument_list|,
name|volatile_p
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_reg_into_stack
argument_list|(
name|function
argument_list|,
name|hipart
argument_list|,
name|part_type
argument_list|,
name|part_mode
argument_list|,
literal|0
argument_list|,
name|volatile_p
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Change the CONCAT into a combined MEM for both parts.  */
name|PUT_CODE
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
name|MEM_ATTRS
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* set_mem_attributes uses DECL_RTL to avoid re-generating of          already computed alias sets.  Here we want to re-generate.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|reg
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* The two parts are in memory order already. 	 Use the lower parts address as ours.  */
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Prevent sharing of rtl that might lose.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|used_p
operator|&&
name|rescan
condition|)
block|{
name|schedule_fixup_var_refs
argument_list|(
name|function
argument_list|,
name|reg
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|promoted_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|schedule_fixup_var_refs
argument_list|(
name|function
argument_list|,
name|lopart
argument_list|,
name|part_type
argument_list|,
name|part_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|schedule_fixup_var_refs
argument_list|(
name|function
argument_list|,
name|hipart
argument_list|,
name|part_type
argument_list|,
name|part_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return;
block|}
end_function

begin_comment
comment|/* Subroutine of put_var_into_stack.  This puts a single pseudo reg REG    into the stack frame of FUNCTION (0 means the current function).    TYPE is the user-level data type of the value hold in the register.    DECL_MODE is the machine mode of the user-level data type.    ORIGINAL_REGNO must be set if the real regno is not visible in REG.    VOLATILE_P is true if this is for a "volatile" decl.    USED_P is true if this reg might have already been used in an insn.    CONSECUTIVE_P is true if the stack slot assigned to reg must be    consecutive with the previous stack slot.  */
end_comment

begin_function
specifier|static
name|void
name|put_reg_into_stack
parameter_list|(
name|struct
name|function
modifier|*
name|function
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|tree
name|type
parameter_list|,
name|enum
name|machine_mode
name|decl_mode
parameter_list|,
name|unsigned
name|int
name|original_regno
parameter_list|,
name|bool
name|volatile_p
parameter_list|,
name|bool
name|used_p
parameter_list|,
name|bool
name|consecutive_p
parameter_list|,
name|htab_t
name|ht
parameter_list|)
block|{
name|struct
name|function
modifier|*
name|func
init|=
name|function
condition|?
name|function
else|:
name|cfun
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|original_regno
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|regno
operator|==
literal|0
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|func
operator|->
name|x_max_parm_reg
condition|)
block|{
if|if
condition|(
operator|!
name|func
operator|->
name|x_parm_reg_stack_loc
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new
operator|=
name|func
operator|->
name|x_parm_reg_stack_loc
index|[
name|regno
index|]
expr_stmt|;
block|}
if|if
condition|(
name|new
operator|==
literal|0
condition|)
name|new
operator|=
name|assign_stack_local_1
argument_list|(
name|decl_mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|decl_mode
argument_list|)
argument_list|,
name|consecutive_p
condition|?
operator|-
literal|2
else|:
literal|0
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|reg
argument_list|,
name|decl_mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MEM_ATTRS
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* `volatil' bit means one thing for MEMs, another entirely for REGs.  */
name|MEM_VOLATILE_P
argument_list|(
name|reg
argument_list|)
operator|=
name|volatile_p
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components,      mark it as such for cse and loop optimize.  If we are reusing a      previously generated stack slot, then we need to copy the bit in      case it was set for other reasons.  For instance, it is set for      __builtin_va_alist.  */
if|if
condition|(
name|type
condition|)
block|{
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|reg
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|MEM_IN_STRUCT_P
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|reg
argument_list|,
name|get_alias_set
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used_p
condition|)
name|schedule_fixup_var_refs
argument_list|(
name|function
argument_list|,
name|reg
argument_list|,
name|type
argument_list|,
name|mode
argument_list|,
name|ht
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure that all refs to the variable, previously made    when it was a register, are fixed up to be valid again.    See function above for meaning of arguments.  */
end_comment

begin_function
specifier|static
name|void
name|schedule_fixup_var_refs
parameter_list|(
name|struct
name|function
modifier|*
name|function
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|tree
name|type
parameter_list|,
name|enum
name|machine_mode
name|promoted_mode
parameter_list|,
name|htab_t
name|ht
parameter_list|)
block|{
name|int
name|unsigned_p
init|=
name|type
condition|?
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|function
operator|!=
literal|0
condition|)
block|{
name|struct
name|var_refs_queue
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|var_refs_queue
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|modified
operator|=
name|reg
expr_stmt|;
name|temp
operator|->
name|promoted_mode
operator|=
name|promoted_mode
expr_stmt|;
name|temp
operator|->
name|unsignedp
operator|=
name|unsigned_p
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|function
operator|->
name|fixup_var_refs_queue
expr_stmt|;
name|function
operator|->
name|fixup_var_refs_queue
operator|=
name|temp
expr_stmt|;
block|}
else|else
comment|/* Variable is local; fix it up now.  */
name|fixup_var_refs
argument_list|(
name|reg
argument_list|,
name|promoted_mode
argument_list|,
name|unsigned_p
argument_list|,
name|reg
argument_list|,
name|ht
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|fixup_var_refs
parameter_list|(
name|rtx
name|var
parameter_list|,
name|enum
name|machine_mode
name|promoted_mode
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|rtx
name|may_share
parameter_list|,
name|htab_t
name|ht
parameter_list|)
block|{
name|tree
name|pending
decl_stmt|;
name|rtx
name|first_insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|seq_stack
decl_stmt|;
name|tree
name|rtl_exps
init|=
name|rtl_expr_chain
decl_stmt|;
comment|/* If there's a hash table, it must record all uses of VAR.  */
if|if
condition|(
name|ht
condition|)
block|{
if|if
condition|(
name|stack
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fixup_var_refs_insns_with_hash
argument_list|(
name|ht
argument_list|,
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
name|may_share
argument_list|)
expr_stmt|;
return|return;
block|}
name|fixup_var_refs_insns
argument_list|(
name|first_insn
argument_list|,
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
name|stack
operator|==
literal|0
argument_list|,
name|may_share
argument_list|)
expr_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
block|{
name|push_to_full_sequence
argument_list|(
name|stack
operator|->
name|first
argument_list|,
name|stack
operator|->
name|last
argument_list|)
expr_stmt|;
name|fixup_var_refs_insns
argument_list|(
name|stack
operator|->
name|first
argument_list|,
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
name|stack
operator|->
name|next
operator|!=
literal|0
argument_list|,
name|may_share
argument_list|)
expr_stmt|;
comment|/* Update remembered end of sequence 	 in case we added an insn at the end.  */
name|stack
operator|->
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Scan all waiting RTL_EXPRs too.  */
for|for
control|(
name|pending
operator|=
name|rtl_exps
init|;
name|pending
condition|;
name|pending
operator|=
name|TREE_CHAIN
argument_list|(
name|pending
argument_list|)
control|)
block|{
name|rtx
name|seq
init|=
name|RTL_EXPR_SEQUENCE
argument_list|(
name|TREE_VALUE
argument_list|(
name|pending
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
name|const0_rtx
operator|&&
name|seq
operator|!=
literal|0
condition|)
block|{
name|push_to_sequence
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|fixup_var_refs_insns
argument_list|(
name|seq
argument_list|,
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|may_share
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* REPLACEMENTS is a pointer to a list of the struct fixup_replacement and X is    some part of an insn.  Return a struct fixup_replacement whose OLD    value is equal to X.  Allocate a new structure if no such entry exists.  */
end_comment

begin_function
specifier|static
name|struct
name|fixup_replacement
modifier|*
name|find_fixup_replacement
parameter_list|(
name|struct
name|fixup_replacement
modifier|*
modifier|*
name|replacements
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|fixup_replacement
modifier|*
name|p
decl_stmt|;
comment|/* See if we have already replaced this.  */
for|for
control|(
name|p
operator|=
operator|*
name|replacements
init|;
name|p
operator|!=
literal|0
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|p
operator|->
name|old
argument_list|,
name|x
argument_list|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fixup_replacement
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|old
operator|=
name|x
expr_stmt|;
name|p
operator|->
name|new
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|*
name|replacements
expr_stmt|;
operator|*
name|replacements
operator|=
name|p
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Scan the insn-chain starting with INSN for refs to VAR and fix them    up.  TOPLEVEL is nonzero if this chain is the main chain of insns    for the current function.  MAY_SHARE is either a MEM that is not    to be unshared or a list of them.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_var_refs_insns
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|var
parameter_list|,
name|enum
name|machine_mode
name|promoted_mode
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|int
name|toplevel
parameter_list|,
name|rtx
name|may_share
parameter_list|)
block|{
while|while
condition|(
name|insn
condition|)
block|{
comment|/* fixup_var_refs_insn might modify insn, so save its next          pointer now.  */
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* CALL_PLACEHOLDERs are special; we have to switch into each of 	 the three sequences they (potentially) contain, and process 	 them recursively.  The CALL_INSN itself is not interesting.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Look at the Normal call, sibling call and tail recursion 	     sequences attached to the CALL_PLACEHOLDER.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|seq
init|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
condition|)
block|{
name|push_to_sequence
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|fixup_var_refs_insns
argument_list|(
name|seq
argument_list|,
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|may_share
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|i
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|fixup_var_refs_insn
argument_list|(
name|insn
argument_list|,
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
name|toplevel
argument_list|,
name|may_share
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look up the insns which reference VAR in HT and fix them up.  Other    arguments are the same as fixup_var_refs_insns.     N.B. No need for special processing of CALL_PLACEHOLDERs here,    because the hash table will point straight to the interesting insn    (inside the CALL_PLACEHOLDER).  */
end_comment

begin_function
specifier|static
name|void
name|fixup_var_refs_insns_with_hash
parameter_list|(
name|htab_t
name|ht
parameter_list|,
name|rtx
name|var
parameter_list|,
name|enum
name|machine_mode
name|promoted_mode
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|rtx
name|may_share
parameter_list|)
block|{
name|struct
name|insns_for_mem_entry
name|tmp
decl_stmt|;
name|struct
name|insns_for_mem_entry
modifier|*
name|ime
decl_stmt|;
name|rtx
name|insn_list
decl_stmt|;
name|tmp
operator|.
name|key
operator|=
name|var
expr_stmt|;
name|ime
operator|=
name|htab_find
argument_list|(
name|ht
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|insn_list
operator|=
name|ime
operator|->
name|insns
init|;
name|insn_list
operator|!=
literal|0
condition|;
name|insn_list
operator|=
name|XEXP
argument_list|(
name|insn_list
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|XEXP
argument_list|(
name|insn_list
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|XEXP
argument_list|(
name|insn_list
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|fixup_var_refs_insn
argument_list|(
name|XEXP
argument_list|(
name|insn_list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
literal|1
argument_list|,
name|may_share
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Per-insn processing by fixup_var_refs_insns(_with_hash).  INSN is    the insn under examination, VAR is the variable to fix up    references to, PROMOTED_MODE and UNSIGNEDP describe VAR, and    TOPLEVEL is nonzero if this is the main insn chain for this    function.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_var_refs_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|var
parameter_list|,
name|enum
name|machine_mode
name|promoted_mode
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|int
name|toplevel
parameter_list|,
name|rtx
name|no_share
parameter_list|)
block|{
name|rtx
name|call_dest
init|=
literal|0
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|prev
decl_stmt|,
name|prev_set
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* Remember the notes in case we delete the insn.  */
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If this is a CLOBBER of VAR, delete it.       If it has a REG_LIBCALL note, delete the REG_LIBCALL      and REG_RETVAL notes too.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
operator|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|var
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONCAT
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|var
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|var
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* The REG_LIBCALL note will go away since we are going to 	   turn INSN into a NOTE, so just delete the 	   corresponding REG_RETVAL note.  */
name|remove_note
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|find_reg_note
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* The insn to load VAR from a home in the arglist      is now a no-op.  When we see it, just delete it.      Similarly if this is storing VAR from a register from which      it was loaded in the previous insn.  This will occur      when an ADDRESSOF was made for an arglist slot.  */
elseif|else
if|if
condition|(
name|toplevel
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|var
comment|/* If this represents the result of an insn group, 	      don't delete the insn.  */
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|var
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|prev_set
operator|=
name|single_set
argument_list|(
name|prev
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|var
argument_list|)
operator|)
operator|)
condition|)
block|{
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|fixup_replacement
modifier|*
name|replacements
init|=
literal|0
decl_stmt|;
name|rtx
name|next_insn
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|SMALL_REGISTER_CLASSES
condition|)
block|{
comment|/* If the insn that copies the results of a CALL_INSN 	     into a pseudo now references VAR, we have to use an 	     intermediate pseudo since we want the life of the 	     return value register to be only a single insn.  	     If we don't use an intermediate pseudo, such things as 	     address computations to make the address of VAR valid 	     if it is not can be placed between the CALL_INSN and INSN.  	     To make sure this doesn't happen, we record the destination 	     of the CALL_INSN and see if the next insn uses both that 	     and VAR.  */
if|if
condition|(
name|call_dest
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|reg_mentioned_p
argument_list|(
name|var
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|call_dest
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|call_dest
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|call_dest
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|call_dest
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|call_dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|call_dest
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|call_dest
operator|=
literal|0
expr_stmt|;
block|}
comment|/* See if we have to do anything to INSN now that VAR is in 	 memory.  If it needs to be loaded into a pseudo, use a single 	 pseudo for the entire insn in case there is a MATCH_DUP 	 between two operands.  We pass a pointer to the head of 	 a list of struct fixup_replacements.  If fixup_var_refs_1 	 needs to allocate pseudos or replacement MEMs (for SUBREGs), 	 it will record them in this list.  	 If it allocated a pseudo for any replacement, we copy into 	 it here.  */
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
operator|&
name|replacements
argument_list|,
name|no_share
argument_list|)
expr_stmt|;
comment|/* If this is last_parm_insn, and any instructions were output 	 after it to fix it up, then we must set last_parm_insn to 	 the last such instruction emitted.  */
if|if
condition|(
name|insn
operator|==
name|last_parm_insn
condition|)
name|last_parm_insn
operator|=
name|PREV_INSN
argument_list|(
name|next_insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|replacements
condition|)
block|{
name|struct
name|fixup_replacement
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|replacements
operator|->
name|new
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|insert_before
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* OLD might be a (subreg (mem)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|replacements
operator|->
name|old
argument_list|)
operator|==
name|SUBREG
condition|)
name|replacements
operator|->
name|old
operator|=
name|fixup_memory_subreg
argument_list|(
name|replacements
operator|->
name|old
argument_list|,
name|insn
argument_list|,
name|promoted_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|replacements
operator|->
name|old
operator|=
name|fixup_stack_1
argument_list|(
name|replacements
operator|->
name|old
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insert_before
operator|=
name|insn
expr_stmt|;
comment|/* If we are changing the mode, do a conversion. 		 This might be wasteful, but combine.c will 		 eliminate much of the waste.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|replacements
operator|->
name|new
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|replacements
operator|->
name|old
argument_list|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|convert_move
argument_list|(
name|replacements
operator|->
name|new
argument_list|,
name|replacements
operator|->
name|old
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
else|else
name|seq
operator|=
name|gen_move_insn
argument_list|(
name|replacements
operator|->
name|new
argument_list|,
name|replacements
operator|->
name|old
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
block|}
name|next
operator|=
name|replacements
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|replacements
argument_list|)
expr_stmt|;
name|replacements
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/* Also fix up any invalid exprs in the REG_NOTES of this insn.      But don't touch other insns referred to by reg-notes;      we will get them elsewhere.  */
while|while
condition|(
name|note
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|!=
name|INSN_LIST
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|promoted_mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* VAR is a MEM that used to be a pseudo register with mode PROMOTED_MODE.    See if the rtx expression at *LOC in INSN needs to be changed.     REPLACEMENTS is a pointer to a list head that starts out zero, but may    contain a list of original rtx's and replacements. If we find that we need    to modify this insn by replacing a memory reference with a pseudo or by    making a new MEM to implement a SUBREG, we consult that list to see if    we have already chosen a replacement. If none has already been allocated,    we allocate it and update the list.  fixup_var_refs_insn will copy VAR    or the SUBREG, as appropriate, to the pseudo.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_var_refs_1
parameter_list|(
name|rtx
name|var
parameter_list|,
name|enum
name|machine_mode
name|promoted_mode
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|struct
name|fixup_replacement
modifier|*
modifier|*
name|replacements
parameter_list|,
name|rtx
name|no_share
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|rtx
name|tem
decl_stmt|,
name|tem1
decl_stmt|;
name|struct
name|fixup_replacement
modifier|*
name|replacement
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ADDRESSOF
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|var
condition|)
block|{
comment|/* Prevent sharing of rtl that might lose.  */
name|rtx
name|sub
init|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|var
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|sub
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|y
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|seq
decl_stmt|,
name|new_insn
decl_stmt|;
comment|/* We should be able to replace with a register or all is lost. 		 Note that we can't use validate_change to verify this, since 		 we're not caring for replacing all dups simultaneously.  */
if|if
condition|(
operator|!
name|validate_replace_rtx
argument_list|(
operator|*
name|loc
argument_list|,
name|y
argument_list|,
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Careful!  First try to recognize a direct move of the 		 value, mimicking how things are done in gen_reload wrt 		 PLUS.  Consider what happens when insn is a conditional 		 move instruction and addsi3 clobbers flags.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|new_insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|y
argument_list|,
name|sub
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|new_insn
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* That failed.  Fall back on force_operand and hope.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|sub
operator|=
name|force_operand
argument_list|(
name|sub
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|!=
name|y
condition|)
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|y
argument_list|,
name|sub
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Don't separate setter from user.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|sets_cc0_p
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
case|case
name|MEM
case|:
if|if
condition|(
name|var
operator|==
name|x
condition|)
block|{
comment|/* If we already have a replacement, use it.  Otherwise, 	     try to fix up this address in case it is invalid.  */
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
condition|)
block|{
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
return|return;
block|}
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
operator|=
name|x
operator|=
name|fixup_stack_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Unless we are forcing memory to register or we changed the mode, 	     we can leave things the way they are if the insn is valid.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_force_mem
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|promoted_mode
operator|&&
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|promoted_mode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If X contains VAR, we need to unshare it here so that we update 	 each occurrence separately.  But all identical MEMs in one insn 	 must be replaced with the same rtx because of the possibility of 	 MATCH_DUPs.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|var
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
operator|==
literal|0
condition|)
name|replacement
operator|->
name|new
operator|=
name|copy_most_rtx
argument_list|(
name|x
argument_list|,
name|no_share
argument_list|)
expr_stmt|;
operator|*
name|loc
operator|=
name|x
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REG
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
return|return;
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTRACT
case|:
comment|/* Note that in some cases those types of expressions are altered 	 by optimize_bit_field, and do not survive to get here.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|var
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|var
operator|)
condition|)
block|{
comment|/* Get TEM as a valid MEM in the mode presently in the insn.  	     We don't worry about the possibility of MATCH_DUP here; it 	     is highly unlikely and would be tricky to handle.  */
name|tem
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
operator|==
literal|0
condition|)
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|SUBREG_REG
argument_list|(
name|tem
argument_list|)
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
comment|/* The following code works only if we have a MEM, so we 		     need to handle the subreg here.  We directly substitute 		     it assuming that a subreg must be OK here.  We already 		     scheduled a replacement to copy the mem into the 		     subreg.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|tem
expr_stmt|;
return|return;
block|}
else|else
name|tem
operator|=
name|fixup_memory_subreg
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|,
name|promoted_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|tem
operator|=
name|fixup_stack_1
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Unless we want to load from memory, get TEM into the proper mode 	     for an extract from memory.  This can only be done if the 	     extract is at a constant position and length.  */
if|if
condition|(
operator|!
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wanted_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|machine_mode
name|is_mode
init|=
name|GET_MODE
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|enum
name|machine_mode
name|new_mode
init|=
name|mode_for_extraction
argument_list|(
name|EP_extzv
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_mode
operator|!=
name|MAX_MACHINE_MODE
condition|)
name|wanted_mode
operator|=
name|new_mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
name|enum
name|machine_mode
name|new_mode
init|=
name|mode_for_extraction
argument_list|(
name|EP_extv
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_mode
operator|!=
name|MAX_MACHINE_MODE
condition|)
name|wanted_mode
operator|=
name|new_mode
expr_stmt|;
block|}
comment|/* If we have a narrower mode, we can do something.  */
if|if
condition|(
name|wanted_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
name|pos
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|old_pos
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|rtx
name|newmem
decl_stmt|;
comment|/* If the bytes and bits are counted differently, we 		     must adjust the offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|BITS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
name|pos
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_mode
argument_list|)
expr_stmt|;
name|newmem
operator|=
name|adjust_address_nv
argument_list|(
name|tem
argument_list|,
name|wanted_mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Make the change and see if the insn remains valid.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|newmem
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* Otherwise, restore old position.  XEXP (x, 0) will be 		     restored later.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|old_pos
expr_stmt|;
block|}
block|}
comment|/* If we get here, the bitfield extract insn can't accept a memory 	     reference.  Copy the input into a register.  */
name|tem1
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tem1
argument_list|,
name|tem
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|tem1
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|==
name|var
condition|)
block|{
comment|/* If this is a special SUBREG made because VAR was promoted 	     from a wider mode, replace it with VAR and call ourself 	     recursively, this time saying that the object previously 	     had its current mode (by virtue of the SUBREG).  */
if|if
condition|(
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|var
expr_stmt|;
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|loc
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|,
name|no_share
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this SUBREG makes VAR wider, it has become a paradoxical 	     SUBREG with VAR in memory, but these aren't allowed at this 	     stage of the compilation.  So load VAR into a pseudo and take 	     a SUBREG of that pseudo.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
operator|==
literal|0
condition|)
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|promoted_mode
argument_list|)
expr_stmt|;
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
return|return;
block|}
comment|/* See if we have already found a replacement for this SUBREG. 	     If so, use it.  Otherwise, make a MEM and see if the insn 	     is recognized.  If not, or if we should force MEM into a register, 	     make a pseudo for this SUBREG.  */
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
comment|/* Careful!  We may have just replaced a SUBREG by a MEM, which 		 means that the insn may have become invalid again.  We can't 		 in this case make a new replacement since we already have one 		 and we must deal with MATCH_DUPs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|replacement
operator|->
name|new
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
name|fixup_var_refs_1
argument_list|(
name|replacement
operator|->
name|new
argument_list|,
name|mode
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|,
name|no_share
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|replacement
operator|->
name|new
operator|=
operator|*
name|loc
operator|=
name|fixup_memory_subreg
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|promoted_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_force_mem
operator|&&
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SET
case|:
comment|/* First do special simplification of bit-field references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|optimize_bit_field
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|optimize_bit_field
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For a paradoxical SUBREG inside a ZERO_EXTRACT, load the object 	 into a register and then store it back out.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|var
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
operator|==
literal|0
condition|)
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|var
argument_list|,
name|replacement
operator|->
name|new
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If SET_DEST is now a paradoxical SUBREG, put the result of this 	 insn into a pseudo and store the low part of the pseudo into VAR.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|var
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|var
argument_list|,
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|outerdest
init|=
name|dest
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
condition|)
name|src
operator|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* If VAR does not appear at the top level of the SET 	   just scan the lower levels of the tree.  */
if|if
condition|(
name|src
operator|!=
name|var
operator|&&
name|dest
operator|!=
name|var
condition|)
break|break;
comment|/* We will need to rerecognize this insn.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|outerdest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|dest
operator|==
name|var
operator|&&
name|mode_for_extraction
argument_list|(
name|EP_insv
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
name|MAX_MACHINE_MODE
condition|)
block|{
comment|/* Since this case will return, ensure we fixup all the 	       operands here.  */
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|,
name|no_share
argument_list|)
expr_stmt|;
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|,
name|no_share
argument_list|)
expr_stmt|;
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|,
name|no_share
argument_list|)
expr_stmt|;
name|tem
operator|=
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clean up (SUBREG:SI (MEM:mode ...) 0) 	       that may appear inside a ZERO_EXTRACT. 	       This was legitimate when the MEM was a REG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|tem
argument_list|)
operator|==
name|var
condition|)
name|tem
operator|=
name|fixup_memory_subreg
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|,
name|promoted_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|fixup_stack_1
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wanted_mode
decl_stmt|;
name|enum
name|machine_mode
name|is_mode
init|=
name|GET_MODE
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|wanted_mode
operator|=
name|mode_for_extraction
argument_list|(
name|EP_insv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have a narrower mode, we can do something.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
name|pos
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|old_pos
init|=
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|rtx
name|newmem
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|BITS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
name|pos
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_mode
argument_list|)
expr_stmt|;
name|newmem
operator|=
name|adjust_address_nv
argument_list|(
name|tem
argument_list|,
name|wanted_mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Make the change and see if the insn remains valid.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
operator|=
name|newmem
expr_stmt|;
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* Otherwise, restore old position.  XEXP (x, 0) will be 		       restored later.  */
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
operator|=
name|old_pos
expr_stmt|;
block|}
block|}
comment|/* If we get here, the bit-field store doesn't allow memory 	       or isn't located at a constant position.  Load the value into 	       a register, do the store, and put it back into memory.  */
name|tem1
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tem1
argument_list|,
name|tem
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|tem1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
operator|=
name|tem1
expr_stmt|;
return|return;
block|}
comment|/* STRICT_LOW_PART is a no-op on memory references 	   and it can cause combinations to be unrecognizable, 	   so eliminate it.  */
if|if
condition|(
name|dest
operator|==
name|var
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A valid insn to copy VAR into or out of a register 	   must be left alone, to avoid an infinite loop here. 	   If the reference to VAR is by a subreg, fix that up, 	   since SUBREG is not valid for a memref. 	   Also fix up the address of the stack slot.  	   Note that we must not try to recognize the insn until 	   after we know that we have valid addresses and no 	   (subreg (mem ...) ...) constructs, since these interfere 	   with determining the validity of the insn.  */
if|if
condition|(
operator|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|==
name|var
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|var
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|var
argument_list|)
operator|==
name|promoted_mode
operator|&&
name|x
operator|==
name|single_set
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pat
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* This (subreg VAR) is now a paradoxical subreg.  We need 		   to replace VAR instead of the subreg.  */
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
operator|==
name|NULL_RTX
condition|)
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
block|}
else|else
block|{
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
condition|)
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
operator|=
name|fixup_memory_subreg
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|promoted_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
operator|=
name|fixup_stack_1
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* INSN is not valid, but we know that we want to 	       copy SET_SRC (x) to SET_DEST (x) in some way.  So 	       we generate the move and see whether it requires more 	       than one insn.  If it does, we emit those insns and 	       delete INSN.  Otherwise, we can just replace the pattern 	       of INSN; we have already verified above that INSN has 	       no other function that to do X.  */
name|pat
operator|=
name|gen_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|pat
argument_list|)
operator|!=
name|NULL_RTX
condition|)
block|{
name|last
operator|=
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* INSN might have REG_RETVAL or other important notes, so 		   we need to store the pattern of the last insn in the 		   sequence into INSN similarly to the normal case.  LAST 		   should not have REG_NOTES, but we allow them if INSN has 		   no REG_NOTES.  */
if|if
condition|(
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|last
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|PATTERN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
else|else
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|PATTERN
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|var
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|var
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|var
argument_list|)
operator|==
name|promoted_mode
operator|&&
name|x
operator|==
name|single_set
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pat
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|fixup_memory_subreg
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|promoted_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|fixup_stack_1
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
name|pat
operator|=
name|gen_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|pat
argument_list|)
operator|!=
name|NULL_RTX
condition|)
block|{
name|last
operator|=
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* INSN might have REG_RETVAL or other important notes, so 		   we need to store the pattern of the last insn in the 		   sequence into INSN similarly to the normal case.  LAST 		   should not have REG_NOTES, but we allow them if INSN has 		   no REG_NOTES.  */
if|if
condition|(
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|last
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|PATTERN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
else|else
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|PATTERN
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, storing into VAR must be handled specially 	   by storing into a temporary and copying that into VAR 	   with a new insn after this one.  Note that this case 	   will be used when storing into a promoted scalar since 	   the insn will now have different modes on the input 	   and output and hence will be invalid (except for the case 	   of setting it to a constant, which does not need any 	   change if it is valid).  We generate extra code in that case, 	   but combine.c will eliminate it.  */
if|if
condition|(
name|dest
operator|==
name|var
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|rtx
name|fixeddest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|temp_mode
decl_stmt|;
comment|/* STRICT_LOW_PART can be discarded, around a MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|fixeddest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|fixeddest
operator|=
name|XEXP
argument_list|(
name|fixeddest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert (SUBREG (MEM)) to a MEM in a changed mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|fixeddest
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|fixeddest
operator|=
name|fixup_memory_subreg
argument_list|(
name|fixeddest
argument_list|,
name|insn
argument_list|,
name|promoted_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp_mode
operator|=
name|GET_MODE
argument_list|(
name|fixeddest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fixeddest
operator|=
name|fixup_stack_1
argument_list|(
name|fixeddest
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|temp_mode
operator|=
name|promoted_mode
expr_stmt|;
block|}
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|temp_mode
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|fixeddest
argument_list|,
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|fixeddest
argument_list|)
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
block|}
default|default:
break|break;
block|}
comment|/* Nothing special about this RTX; fix its operands.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|,
name|no_share
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|,
name|no_share
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Previously, X had the form (SUBREG:m1 (REG:PROMOTED_MODE ...)).    The REG  was placed on the stack, so X now has the form (SUBREG:m1    (MEM:m2 ...)).     Return an rtx (MEM:m1 newaddr) which is equivalent.  If any insns    must be emitted to compute NEWADDR, put them before INSN.     UNCRITICAL nonzero means accept paradoxical subregs.    This is used for subregs found inside REG_NOTES.  */
end_comment

begin_function
specifier|static
name|rtx
name|fixup_memory_subreg
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|enum
name|machine_mode
name|promoted_mode
parameter_list|,
name|int
name|uncritical
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|rtx
name|mem
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|seq
decl_stmt|;
comment|/* Paradoxical SUBREGs are usually invalid during RTL generation.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
operator|&&
operator|!
name|uncritical
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
comment|/* If the PROMOTED_MODE is wider than the mode of the MEM, adjust        the offset so that it points to the right location within the        MEM.  */
name|offset
operator|-=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|promoted_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_force_addr
operator|&&
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|)
argument_list|)
condition|)
comment|/* Shortcut if no insns need be emitted.  */
return|return
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|result
operator|=
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Do fixup_memory_subreg on all (SUBREG (MEM ...) ...) contained in X.    Replace subexpressions of X in place.    If X itself is a (SUBREG (MEM ...) ...), return the replacement expression.    Otherwise return X, with its contents possibly altered.     INSN, PROMOTED_MODE and UNCRITICAL are as for    fixup_memory_subreg.  */
end_comment

begin_function
specifier|static
name|rtx
name|walk_fixup_memory_subreg
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|enum
name|machine_mode
name|promoted_mode
parameter_list|,
name|int
name|uncritical
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|fixup_memory_subreg
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|promoted_mode
argument_list|,
name|uncritical
argument_list|)
return|;
comment|/* Nothing special about this RTX; fix its operands.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|promoted_mode
argument_list|,
name|uncritical
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|promoted_mode
argument_list|,
name|uncritical
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For each memory ref within X, if it refers to a stack slot    with an out of range displacement, put the address in a temp register    (emitting new insns before INSN to load these registers)    and alter the memory ref to use that register.    Replace each such MEM rtx with a copy, to avoid clobberage.  */
end_comment

begin_function
specifier|static
name|rtx
name|fixup_stack_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|rtx
name|ad
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we have address of a stack slot but it's not valid 	 (displacement is too large), compute the sum in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|temp
decl_stmt|,
name|seq
decl_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ad
argument_list|)
condition|)
return|return
name|x
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|ad
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|replace_equiv_address
argument_list|(
name|x
argument_list|,
name|temp
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|fixup_stack_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|fixup_stack_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimization: a bit-field instruction whose field    happens to be a byte or halfword in memory    can be changed to a move instruction.     We call here when INSN is an insn to examine or store into a bit-field.    BODY is the SET-rtx to be altered.     EQUIV_MEM is the table `reg_equiv_mem' if that is available; else 0.    (Currently this is called only from function.c, and EQUIV_MEM    is always 0.)  */
end_comment

begin_function
specifier|static
name|void
name|optimize_bit_field
parameter_list|(
name|rtx
name|body
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|equiv_mem
parameter_list|)
block|{
name|rtx
name|bitfield
decl_stmt|;
name|int
name|destflag
decl_stmt|;
name|rtx
name|seq
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|bitfield
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|,
name|destflag
operator|=
literal|1
expr_stmt|;
else|else
name|bitfield
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|,
name|destflag
operator|=
literal|0
expr_stmt|;
comment|/* First check that the field being stored has constant size and position      and is in fact a byte or halfword suitably aligned.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|mode
operator|=
name|mode_for_size
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|BLKmode
operator|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|%
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rtx
name|memref
init|=
literal|0
decl_stmt|;
comment|/* Now check that the containing word is memory, not a register, 	 and that it is safe to change the machine mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|memref
operator|=
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|equiv_mem
operator|!=
literal|0
condition|)
name|memref
operator|=
name|equiv_mem
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|memref
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|equiv_mem
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|memref
operator|=
name|equiv_mem
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|memref
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|memref
argument_list|)
condition|)
block|{
comment|/* Now adjust the address, first for any subreg'ing 	     that we are now getting rid of, 	     and then for which byte of the word is wanted.  */
name|HOST_WIDE_INT
name|offset
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
comment|/* Adjust OFFSET to count bits from low-address byte.  */
if|if
condition|(
name|BITS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|offset
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Adjust OFFSET to count bytes from low-address byte.  */
name|offset
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
operator|(
name|SUBREG_BYTE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|memref
operator|=
name|adjust_address
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Store this memory reference where 	     we found the bit field reference.  */
if|if
condition|(
name|destflag
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|,
name|memref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_BYTE
argument_list|(
name|src
argument_list|)
operator|==
literal|0
condition|)
name|src
operator|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
name|src
operator|=
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
comment|/* This shouldn't happen because anything that didn't have 		   one of these modes should have got converted explicitly 		   and then referenced through a subreg. 		   This is so because the original bit-field was 		   handled by agg_mode and so its tree structure had 		   the same mode that memref now has.  */
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_BYTE
argument_list|(
name|dest
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|,
name|dest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|memref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Convert the mem ref to the destination mode.  */
name|rtx
name|newreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|convert_move
argument_list|(
name|newreg
argument_list|,
name|memref
argument_list|,
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|newreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* See if we can convert this extraction or insertion into 	     a simple move insn.  We might not be able to do so if this 	     was, for example, part of a PARALLEL.  	     If we succeed, write out any needed conversions.  If we fail, 	     it is hard to guess why we failed, so don't do anything 	     special; just let the optimization be suppressed.  */
if|if
condition|(
name|apply_change_group
argument_list|()
operator|&&
name|seq
condition|)
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines are responsible for converting virtual register references    to the actual hard register references once RTL generation is complete.     The following four variables are used for communication between the    routines.  They contain the offsets of the virtual registers from their    respective hard registers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_arg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|var_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dynamic_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|out_arg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cfa_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In most machines, the stack pointer register is equivalent to the bottom    of the stack.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_POINTER_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|STACK_POINTER_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If not defined, pick an appropriate default for the offset of dynamically    allocated memory depending on the value of ACCUMULATE_OUTGOING_ARGS,    REG_PARM_STACK_SPACE, and OUTGOING_REG_PARM_STACK_SPACE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_DYNAMIC_OFFSET
end_ifndef

begin_comment
comment|/* The bottom of the stack points to the actual arguments.  If    REG_PARM_STACK_SPACE is defined, this includes the space for the register    parameters.  However, if OUTGOING_REG_PARM_STACK space is not defined,    stack space for register parameters is not pushed by the caller, but    rather part of the fixed stack areas and hence not included in    `current_function_outgoing_args_size'.  Nevertheless, we must allow    for it when allocating stack dynamic objects.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OUTGOING_REG_PARM_STACK_SPACE
argument_list|)
end_if

begin_define
define|#
directive|define
name|STACK_DYNAMIC_OFFSET
parameter_list|(
name|FNDECL
parameter_list|)
define|\
value|((ACCUMULATE_OUTGOING_ARGS						      \   ? (current_function_outgoing_args_size + REG_PARM_STACK_SPACE (FNDECL)) : 0)\  + (STACK_POINTER_OFFSET))						      \  #else
end_define

begin_define
define|#
directive|define
name|STACK_DYNAMIC_OFFSET
parameter_list|(
name|FNDECL
parameter_list|)
define|\
value|((ACCUMULATE_OUTGOING_ARGS ? current_function_outgoing_args_size : 0)	      \  + (STACK_POINTER_OFFSET))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On most machines, the CFA coincides with the first incoming parm.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARG_POINTER_CFA_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|ARG_POINTER_CFA_OFFSET
parameter_list|(
name|FNDECL
parameter_list|)
value|FIRST_PARM_OFFSET (FNDECL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Build up a (MEM (ADDRESSOF (REG))) rtx for a register REG that just    had its address taken.  DECL is the decl or SAVE_EXPR for the    object stored in the register, for later use if we do need to force    REG into the stack.  REG is overwritten by the MEM like in    put_reg_into_stack.  RESCAN is true if previously emitted    instructions must be rescanned and modified now that the REG has    been transformed.  */
end_comment

begin_function
name|rtx
name|gen_mem_addressof
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|tree
name|decl
parameter_list|,
name|int
name|rescan
parameter_list|)
block|{
name|rtx
name|r
init|=
name|gen_rtx_ADDRESSOF
argument_list|(
name|Pmode
argument_list|,
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|decl
argument_list|)
decl_stmt|;
comment|/* Calculate this before we start messing with decl's RTL.  */
name|HOST_WIDE_INT
name|set
init|=
name|decl
condition|?
name|get_alias_set
argument_list|(
name|decl
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* If the original REG was a user-variable, then so is the REG whose      address is being taken.  Likewise for unchanging.  */
name|REG_USERVAR_P
argument_list|(
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
name|MEM_ATTRS
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|decl_mode
init|=
operator|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|?
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
else|:
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|decl_rtl
init|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SAVE_EXPR
condition|?
name|SAVE_EXPR_RTL
argument_list|(
name|decl
argument_list|)
else|:
name|DECL_RTL_IF_SET
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|PUT_MODE
argument_list|(
name|reg
argument_list|,
name|decl_mode
argument_list|)
expr_stmt|;
comment|/* Clear DECL_RTL momentarily so functions below will work 	 properly, then set it again.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_rtl
operator|==
name|reg
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|reg
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|reg
argument_list|,
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_rtl
operator|==
name|reg
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rescan
operator|&&
operator|(
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
name|fixup_var_refs
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rescan
condition|)
block|{
comment|/* This can only happen during reload.  Clear the same flag bits as 	 reload.  */
name|MEM_VOLATILE_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MEM_ATTRS
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fixup_var_refs
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* If DECL has an RTL that is an ADDRESSOF rtx, put it into the stack.  */
end_comment

begin_function
name|void
name|flush_addressof
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|put_addressof_into_stack
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Force the register pointed to by R, an ADDRESSOF rtx, into the stack.  */
end_comment

begin_function
specifier|static
name|void
name|put_addressof_into_stack
parameter_list|(
name|rtx
name|r
parameter_list|,
name|htab_t
name|ht
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|;
name|bool
name|volatile_p
decl_stmt|,
name|used_p
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|decl
operator|=
name|ADDRESSOF_DECL
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|volatile_p
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|SAVE_EXPR
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|)
expr_stmt|;
name|used_p
operator|=
operator|(
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|NULL_TREE
expr_stmt|;
name|volatile_p
operator|=
name|false
expr_stmt|;
name|used_p
operator|=
name|true
expr_stmt|;
block|}
name|put_reg_into_stack
argument_list|(
literal|0
argument_list|,
name|reg
argument_list|,
name|type
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|ADDRESSOF_REGNO
argument_list|(
name|r
argument_list|)
argument_list|,
name|volatile_p
argument_list|,
name|used_p
argument_list|,
name|false
argument_list|,
name|ht
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List of replacements made below in purge_addressof_1 when creating    bitfield insertions.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|purge_bitfield_addressof_replacements
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of replacements made below in purge_addressof_1 for patterns    (MEM (ADDRESSOF (REG ...))).  The key of the list entry is the    corresponding (ADDRESSOF (REG ...)) and value is a substitution for    the all pattern.  List PURGE_BITFIELD_ADDRESSOF_REPLACEMENTS is not    enough in complex cases, e.g. when some field values can be    extracted by usage MEM with narrower mode.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|purge_addressof_replacements
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper function for purge_addressof.  See if the rtx expression at *LOC    in INSN needs to be changed.  If FORCE, always put any ADDRESSOFs into    the stack.  If the function returns FALSE then the replacement could not    be made.  If MAY_POSTPONE is true and we would not put the addressof    to stack, postpone processing of the insn.  */
end_comment

begin_function
specifier|static
name|bool
name|purge_addressof_1
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|store
parameter_list|,
name|int
name|may_postpone
parameter_list|,
name|htab_t
name|ht
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|bool
name|result
init|=
name|true
decl_stmt|;
name|bool
name|libcall
init|=
name|false
decl_stmt|;
comment|/* Re-start here to avoid recursion in common cases.  */
name|restart
label|:
name|x
operator|=
operator|*
name|loc
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* Is this a libcall?  */
if|if
condition|(
operator|!
name|insn
condition|)
name|libcall
operator|=
name|REG_NOTE_KIND
argument_list|(
operator|*
name|loc
argument_list|)
operator|==
name|REG_RETVAL
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If we don't return in any of the cases below, we will recurse inside      the RTX, which will normally result in any ADDRESSOF being forced into      memory.  */
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|result
operator|=
name|purge_addressof_1
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|force
argument_list|,
literal|1
argument_list|,
name|may_postpone
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|result
operator|&=
name|purge_addressof_1
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|force
argument_list|,
literal|0
argument_list|,
name|may_postpone
argument_list|,
name|ht
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ADDRESSOF
condition|)
block|{
name|rtx
name|sub
decl_stmt|,
name|insns
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
name|put_addressof_into_stack
argument_list|(
name|x
argument_list|,
name|ht
argument_list|)
expr_stmt|;
comment|/* We must create a copy of the rtx because it was created by 	 overwriting a REG rtx which is always shared.  */
name|sub
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|sub
argument_list|,
literal|0
argument_list|)
operator|||
name|validate_replace_rtx
argument_list|(
name|x
argument_list|,
name|sub
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* If SUB is a hard or virtual register, try it as a pseudo-register. 	 Otherwise, perhaps SUB is an expression, so generate code to compute 	 it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|sub
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
name|sub
operator|=
name|copy_to_reg
argument_list|(
name|sub
argument_list|)
expr_stmt|;
else|else
name|sub
operator|=
name|force_operand
argument_list|(
name|sub
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|sub
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|validate_replace_rtx
argument_list|(
name|x
argument_list|,
name|sub
argument_list|,
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
operator|!
name|force
condition|)
block|{
name|rtx
name|sub
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|MEM
condition|)
name|sub
operator|=
name|adjust_address_nv
argument_list|(
name|sub
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|sub
argument_list|)
condition|)
block|{
name|int
name|size_x
decl_stmt|,
name|size_sub
decl_stmt|;
if|if
condition|(
name|may_postpone
condition|)
block|{
comment|/* Postpone for now, so that we do not emit bitfield arithmetics 		 unless there is some benefit from it.  */
if|if
condition|(
operator|!
name|postponed_insns
operator|||
name|XEXP
argument_list|(
name|postponed_insns
argument_list|,
literal|0
argument_list|)
operator|!=
name|insn
condition|)
name|postponed_insns
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|postponed_insns
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|insn
condition|)
block|{
comment|/* When processing REG_NOTES look at the list of 		 replacements done on the insn to find the register that X 		 was replaced by.  */
name|rtx
name|tem
decl_stmt|;
for|for
control|(
name|tem
operator|=
name|purge_bitfield_addressof_replacements
init|;
name|tem
operator|!=
name|NULL_RTX
condition|;
name|tem
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* See comment for purge_addressof_replacements.  */
for|for
control|(
name|tem
operator|=
name|purge_addressof_replacements
init|;
name|tem
operator|!=
name|NULL_RTX
condition|;
name|tem
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|z
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|z
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SUBREG
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* It can happen that the note may speak of things 		       in a wider (or just different) mode than the 		       code did.  This is especially true of 		       REG_RETVAL.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|z
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_BYTE
argument_list|(
name|z
argument_list|)
operator|==
literal|0
condition|)
name|z
operator|=
name|SUBREG_REG
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|z
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* This can occur as a result in invalid 			   pointer casts, e.g. float f; ... 			   *(long long int *)&f. 			   ??? We could emit a warning here, but 			   without a line number that wouldn't be 			   very helpful.  */
name|z
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|z
operator|=
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|z
argument_list|)
expr_stmt|;
operator|*
name|loc
operator|=
name|z
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* When we are processing the REG_NOTES of the last instruction 		 of a libcall, there will be typically no replacements 		 for that insn; the replacements happened before, piecemeal 		 fashion.  OTOH we are not interested in the details of 		 this for the REG_EQUAL note, we want to know the big picture, 		 which can be succinctly described with a simple SUBREG. 		 Note that removing the REG_EQUAL note is not an option 		 on the last insn of a libcall, so we must do a replacement.  */
comment|/* In compile/990107-1.c:7 compiled at -O1 -m1 for sh-elf, 		 we got 		 (mem:DI (addressof:SI (reg/v:DF 160) 159 0x401c8510) 		 [0 S8 A32]), which can be expressed with a simple 		 same-size subreg  */
if|if
condition|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|)
comment|/* Again, invalid pointer casts (as in 		     compile/990203-1.c) can require paradoxical 		     subregs.  */
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|)
operator|&&
name|libcall
operator|)
condition|)
block|{
operator|*
name|loc
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|sub
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* ??? Are there other cases we should handle?  */
comment|/* Sometimes we may not be able to find the replacement.  For 		 example when the original insn was a MEM in a wider mode, 		 and the note is part of a sign extension of a narrowed 		 version of that MEM.  Gcc testcase compile/990829-1.c can 		 generate an example of this situation.  Rather than complain 		 we return false, which will prompt our caller to remove the 		 offending note.  */
return|return
name|false
return|;
block|}
name|size_x
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|size_sub
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do not frob unchanging MEMs.  If a later reference forces the 	     pseudo to the stack, we can wind up with multiple writes to 	     an unchanging memory, which is invalid.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|&&
name|size_x
operator|!=
name|size_sub
condition|)
empty_stmt|;
comment|/* Don't even consider working with paradoxical subregs, 	     or the moral equivalent seen here.  */
elseif|else
if|if
condition|(
name|size_x
operator|<=
name|size_sub
operator|&&
name|int_mode_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
comment|/* Do a bitfield insertion to mirror what would happen 		 in memory.  */
name|rtx
name|val
decl_stmt|,
name|seq
decl_stmt|;
if|if
condition|(
name|store
condition|)
block|{
name|rtx
name|p
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|val
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Discard the current sequence and put the 			 ADDRESSOF on stack.  */
name|end_sequence
argument_list|()
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|compute_insns_for_mem
argument_list|(
name|p
condition|?
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
else|:
name|get_insns
argument_list|()
argument_list|,
name|insn
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|store_bit_field
argument_list|(
name|sub
argument_list|,
name|size_x
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|val
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure to unshare any shared rtl that store_bit_field 		     might have created.  */
name|unshare_all_rtl_again
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|p
operator|=
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|compute_insns_for_mem
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|p
condition|?
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
else|:
name|NULL_RTX
argument_list|,
name|ht
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|p
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|val
operator|=
name|extract_bit_field
argument_list|(
name|sub
argument_list|,
name|size_x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|sub
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Discard the current sequence and put the 			 ADDRESSOF on stack.  */
name|end_sequence
argument_list|()
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|compute_insns_for_mem
argument_list|(
name|p
condition|?
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
else|:
name|get_insns
argument_list|()
argument_list|,
name|insn
argument_list|,
name|ht
argument_list|)
expr_stmt|;
block|}
comment|/* Remember the replacement so that the same one can be done 		 on the REG_NOTES.  */
name|purge_bitfield_addressof_replacements
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|val
argument_list|,
name|purge_bitfield_addressof_replacements
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We replaced with a reg -- all done.  */
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|sub
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Remember the replacement so that the same one can be done 	     on the REG_NOTES.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
for|for
control|(
name|tem
operator|=
name|purge_addressof_replacements
init|;
name|tem
operator|!=
name|NULL_RTX
condition|;
name|tem
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|sub
expr_stmt|;
return|return
name|true
return|;
block|}
name|purge_addressof_replacements
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|purge_addressof_replacements
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
goto|goto
name|restart
goto|;
block|}
block|}
name|give_up
label|:
comment|/* Scan all subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
name|result
operator|&=
name|purge_addressof_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|force
argument_list|,
literal|0
argument_list|,
name|may_postpone
argument_list|,
name|ht
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|result
operator|&=
name|purge_addressof_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|force
argument_list|,
literal|0
argument_list|,
name|may_postpone
argument_list|,
name|ht
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return a hash value for K, a REG.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|insns_for_mem_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|k
parameter_list|)
block|{
comment|/* Use the address of the key for the hash value.  */
name|struct
name|insns_for_mem_entry
modifier|*
name|m
init|=
operator|(
expr|struct
name|insns_for_mem_entry
operator|*
operator|)
name|k
decl_stmt|;
return|return
name|htab_hash_pointer
argument_list|(
name|m
operator|->
name|key
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if K1 and K2 (two REGs) are the same.  */
end_comment

begin_function
specifier|static
name|int
name|insns_for_mem_comp
parameter_list|(
specifier|const
name|void
modifier|*
name|k1
parameter_list|,
specifier|const
name|void
modifier|*
name|k2
parameter_list|)
block|{
name|struct
name|insns_for_mem_entry
modifier|*
name|m1
init|=
operator|(
expr|struct
name|insns_for_mem_entry
operator|*
operator|)
name|k1
decl_stmt|;
name|struct
name|insns_for_mem_entry
modifier|*
name|m2
init|=
operator|(
expr|struct
name|insns_for_mem_entry
operator|*
operator|)
name|k2
decl_stmt|;
return|return
name|m1
operator|->
name|key
operator|==
name|m2
operator|->
name|key
return|;
block|}
end_function

begin_struct
struct|struct
name|insns_for_mem_walk_info
block|{
comment|/* The hash table that we are using to record which INSNs use which      MEMs.  */
name|htab_t
name|ht
decl_stmt|;
comment|/* The INSN we are currently processing.  */
name|rtx
name|insn
decl_stmt|;
comment|/* Zero if we are walking to find ADDRESSOFs, one if we are walking      to find the insns that use the REGs in the ADDRESSOFs.  */
name|int
name|pass
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Called from compute_insns_for_mem via for_each_rtx.  If R is a REG    that might be used in an ADDRESSOF expression, record this INSN in    the hash table given by DATA (which is really a pointer to an    insns_for_mem_walk_info structure).  */
end_comment

begin_function
specifier|static
name|int
name|insns_for_mem_walk
parameter_list|(
name|rtx
modifier|*
name|r
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|insns_for_mem_walk_info
modifier|*
name|ifmwi
init|=
operator|(
expr|struct
name|insns_for_mem_walk_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|insns_for_mem_entry
name|tmp
decl_stmt|;
name|tmp
operator|.
name|insns
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|ifmwi
operator|->
name|pass
operator|==
literal|0
operator|&&
operator|*
name|r
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|r
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|r
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|void
modifier|*
modifier|*
name|e
decl_stmt|;
name|tmp
operator|.
name|key
operator|=
name|XEXP
argument_list|(
operator|*
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e
operator|=
name|htab_find_slot
argument_list|(
name|ifmwi
operator|->
name|ht
argument_list|,
operator|&
name|tmp
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|e
operator|==
name|NULL
condition|)
block|{
operator|*
name|e
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|e
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifmwi
operator|->
name|pass
operator|==
literal|1
operator|&&
operator|*
name|r
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|r
argument_list|)
operator|==
name|REG
condition|)
block|{
name|struct
name|insns_for_mem_entry
modifier|*
name|ifme
decl_stmt|;
name|tmp
operator|.
name|key
operator|=
operator|*
name|r
expr_stmt|;
name|ifme
operator|=
name|htab_find
argument_list|(
name|ifmwi
operator|->
name|ht
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* If we have not already recorded this INSN, do so now.  Since 	 we process the INSNs in order, we know that if we have 	 recorded it it must be at the front of the list.  */
if|if
condition|(
name|ifme
operator|&&
operator|(
operator|!
name|ifme
operator|->
name|insns
operator|||
name|XEXP
argument_list|(
name|ifme
operator|->
name|insns
argument_list|,
literal|0
argument_list|)
operator|!=
name|ifmwi
operator|->
name|insn
operator|)
condition|)
name|ifme
operator|->
name|insns
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|ifmwi
operator|->
name|insn
argument_list|,
name|ifme
operator|->
name|insns
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Walk the INSNS, until we reach LAST_INSN, recording which INSNs use    which REGs in HT.  */
end_comment

begin_function
specifier|static
name|void
name|compute_insns_for_mem
parameter_list|(
name|rtx
name|insns
parameter_list|,
name|rtx
name|last_insn
parameter_list|,
name|htab_t
name|ht
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|insns_for_mem_walk_info
name|ifmwi
decl_stmt|;
name|ifmwi
operator|.
name|ht
operator|=
name|ht
expr_stmt|;
for|for
control|(
name|ifmwi
operator|.
name|pass
operator|=
literal|0
init|;
name|ifmwi
operator|.
name|pass
operator|<
literal|2
condition|;
operator|++
name|ifmwi
operator|.
name|pass
control|)
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
operator|!=
name|last_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|ifmwi
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|insn
argument_list|,
name|insns_for_mem_walk
argument_list|,
operator|&
name|ifmwi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function for purge_addressof called through for_each_rtx.    Returns true iff the rtl is an ADDRESSOF.  */
end_comment

begin_function
specifier|static
name|int
name|is_addressof
parameter_list|(
name|rtx
modifier|*
name|rtl
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|GET_CODE
argument_list|(
operator|*
name|rtl
argument_list|)
operator|==
name|ADDRESSOF
return|;
block|}
end_function

begin_comment
comment|/* Eliminate all occurrences of ADDRESSOF from INSNS.  Elide any remaining    (MEM (ADDRESSOF)) patterns, and force any needed registers into the    stack.  */
end_comment

begin_function
name|void
name|purge_addressof
parameter_list|(
name|rtx
name|insns
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|tmp
decl_stmt|;
name|htab_t
name|ht
decl_stmt|;
comment|/* When we actually purge ADDRESSOFs, we turn REGs into MEMs.  That      requires a fixup pass over the instruction stream to correct      INSNs that depended on the REG being a REG, and not a MEM.  But,      these fixup passes are slow.  Furthermore, most MEMs are not      mentioned in very many instructions.  So, we speed up the process      by pre-calculating which REGs occur in which INSNs; that allows      us to perform the fixup passes much more quickly.  */
name|ht
operator|=
name|htab_create_ggc
argument_list|(
literal|1000
argument_list|,
name|insns_for_mem_hash
argument_list|,
name|insns_for_mem_comp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|compute_insns_for_mem
argument_list|(
name|insns
argument_list|,
name|NULL_RTX
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|postponed_insns
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|purge_addressof_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ht
argument_list|)
condition|)
comment|/* If we could not replace the ADDRESSOFs in the insn, 	     something is wrong.  */
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|purge_addressof_1
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ht
argument_list|)
condition|)
block|{
comment|/* If we could not replace the ADDRESSOFs in the insn's notes, 	       we can just remove the offending notes instead.  */
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
comment|/* If we find a REG_RETVAL note then the insn is a libcall. 		   Such insns must have REG_EQUAL notes as well, in order 		   for later passes of the compiler to work.  So it is not 		   safe to delete the notes here, and instead we abort.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_RETVAL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|for_each_rtx
argument_list|(
operator|&
name|note
argument_list|,
name|is_addressof
argument_list|,
name|NULL
argument_list|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Process the postponed insns.  */
while|while
condition|(
name|postponed_insns
condition|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|postponed_insns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|postponed_insns
expr_stmt|;
name|postponed_insns
operator|=
name|XEXP
argument_list|(
name|postponed_insns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_INSN_LIST_node
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|purge_addressof_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ht
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Clean up.  */
name|purge_bitfield_addressof_replacements
operator|=
literal|0
expr_stmt|;
name|purge_addressof_replacements
operator|=
literal|0
expr_stmt|;
comment|/* REGs are shared.  purge_addressof will destructively replace a REG      with a MEM, which creates shared MEMs.       Unfortunately, the children of put_reg_into_stack assume that MEMs      referring to the same stack slot are shared (fixup_var_refs and      the associated hash table code).       So, we have to do another unsharing pass after we have flushed any      REGs that had their address taken into the stack.       It may be worth tracking whether or not we converted any REGs into      MEMs to avoid this overhead when it is not needed.  */
name|unshare_all_rtl_again
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a SET of a hard subreg to a set of the appropriate hard    register.  A subroutine of purge_hard_subreg_sets.  */
end_comment

begin_function
specifier|static
name|void
name|purge_single_hard_subreg_set
parameter_list|(
name|rtx
name|pattern
parameter_list|)
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|offset
operator|=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|offset
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
operator|=
name|reg
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Eliminate all occurrences of SETs of hard subregs from INSNS.  The    only such SETs that we expect to see are those left in because    integrate can't handle sets of parts of a return value register.     We don't use alter_subreg because we only want to eliminate subregs    of hard registers.  */
end_comment

begin_function
name|void
name|purge_hard_subreg_sets
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pattern
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|purge_single_hard_subreg_set
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|rtx
name|inner_pattern
init|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner_pattern
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|inner_pattern
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|purge_single_hard_subreg_set
argument_list|(
name|inner_pattern
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pass through the INSNS of function FNDECL and convert virtual register    references to hard register references.  */
end_comment

begin_function
name|void
name|instantiate_virtual_regs
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|rtx
name|insns
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Compute the offsets to use for this function.  */
name|in_arg_offset
operator|=
name|FIRST_PARM_OFFSET
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|var_offset
operator|=
name|STARTING_FRAME_OFFSET
expr_stmt|;
name|dynamic_offset
operator|=
name|STACK_DYNAMIC_OFFSET
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|out_arg_offset
operator|=
name|STACK_POINTER_OFFSET
expr_stmt|;
name|cfa_offset
operator|=
name|ARG_POINTER_CFA_OFFSET
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Scan all variables and parameters of this function.  For each that is      in memory, instantiate all virtual registers if the result is a valid      address.  If not, we do it later.  That will handle most uses of virtual      regs on many machines.  */
name|instantiate_decls
argument_list|(
name|fndecl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize recognition, indicating that volatile is OK.  */
name|init_recog
argument_list|()
expr_stmt|;
comment|/* Scan through all the insns, instantiating every virtual register still      present.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Instantiate any virtual registers in CALL_INSN_FUNCTION_USAGE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Past this point all ASM statements should match.  Verify that 	   to avoid failures later in the compilation process.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|check_asm_operands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|instantiate_virtual_regs_lossage
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Instantiate the stack slots for the parm registers, for later use in      addressof elimination.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_parm_reg
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|parm_reg_stack_loc
index|[
name|i
index|]
condition|)
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|parm_reg_stack_loc
index|[
name|i
index|]
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now instantiate the remaining register equivalences for debugging info.      These will not be valid addresses.  */
name|instantiate_decls
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Indicate that, from now on, assign_stack_local should use      frame_pointer_rtx.  */
name|virtuals_instantiated
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan all decls in FNDECL (both variables and parameters) and instantiate    all virtual registers in their DECL_RTL's.     If VALID_ONLY, do this only if the resulting address is still valid.    Otherwise, always do it.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decls
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|int
name|valid_only
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Process all parameters of the function.  */
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|size_rtl
decl_stmt|;
name|instantiate_decl
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|size
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
comment|/* If the parameter was promoted, then the incoming RTL mode may be 	 larger than the declared type size.  We must use the larger of 	 the two sizes.  */
name|size_rtl
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|MAX
argument_list|(
name|size_rtl
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|instantiate_decl
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|size
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
block|}
comment|/* Now process all variables defined in the function or its subblocks.  */
name|instantiate_decls_1
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of instantiate_decls: Process all decls in the given    BLOCK node and all its subblocks.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decls_1
parameter_list|(
name|tree
name|let
parameter_list|,
name|int
name|valid_only
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|t
argument_list|)
condition|)
name|instantiate_decl
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
comment|/* Process all subblocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|instantiate_decls_1
argument_list|(
name|t
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of the preceding procedures: Given RTL representing a    decl and the size of the object, do any instantiation required.     If VALID_ONLY is nonzero, it means that the RTL should only be    changed if the new address is valid.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decl
parameter_list|(
name|rtx
name|x
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|valid_only
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
comment|/* If this is a CONCAT, recurse for the pieces.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|instantiate_decl
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
operator|/
literal|2
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
name|instantiate_decl
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|size
operator|/
literal|2
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is not a MEM, no need to do anything.  Similarly if the      address is a constant or a register that is not a virtual register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
name|addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|<
name|FIRST_VIRTUAL_REGISTER
operator|||
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
condition|)
return|return;
comment|/* If we should only do this if the address is valid, copy the address.      We need to do this so we can undo any changes that might make the      address invalid.  This copy is unfortunate, but probably can't be      avoided.  */
if|if
condition|(
name|valid_only
condition|)
name|addr
operator|=
name|copy_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|addr
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_only
operator|&&
name|size
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|decl_size
init|=
name|size
decl_stmt|;
comment|/* Now verify that the resulting address is valid for every integer or 	 floating-point mode up to and including SIZE bytes long.  We do this 	 since the object might be accessed in any mode and frame addresses 	 are shared.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|decl_size
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
return|return;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|decl_size
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
return|return;
block|}
comment|/* Put back the address now that we have updated it and we either know      it is valid or we don't care whether it is valid.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a piece of RTX and a pointer to a HOST_WIDE_INT, if the RTX    is a virtual register, return the equivalent hard register and set the    offset indirectly through the pointer.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|instantiate_new_reg
parameter_list|(
name|rtx
name|x
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|poffset
parameter_list|)
block|{
name|rtx
name|new
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|virtual_incoming_args_rtx
condition|)
name|new
operator|=
name|arg_pointer_rtx
operator|,
name|offset
operator|=
name|in_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_stack_vars_rtx
condition|)
name|new
operator|=
name|frame_pointer_rtx
operator|,
name|offset
operator|=
name|var_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_stack_dynamic_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|dynamic_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_outgoing_args_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|out_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_cfa_rtx
condition|)
name|new
operator|=
name|arg_pointer_rtx
operator|,
name|offset
operator|=
name|cfa_offset
expr_stmt|;
else|else
return|return
literal|0
return|;
operator|*
name|poffset
operator|=
name|offset
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when instantiate_virtual_regs has failed to update the instruction.    Usually this means that non-matching instruction has been emit, however for    asm statements it may be the problem in the constraints.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_virtual_regs_lossage
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"impossible constraint in `asm'"
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a piece of rtx and an optional pointer to the    containing object, instantiate any virtual registers present in it.     If EXTRA_INSNS, we always do the replacement and generate    any extra insns before OBJECT.  If it zero, we do nothing if replacement    is not valid.     Return 1 if we either had nothing to do or if we were able to do the    needed replacement.  Return 0 otherwise; we only return zero if    EXTRA_INSNS is zero.     We first try some simple transformations to avoid the creation of extra    pseudos.  */
end_comment

begin_function
specifier|static
name|int
name|instantiate_virtual_regs_1
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|rtx
name|object
parameter_list|,
name|int
name|extra_insns
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Re-start here to avoid recursion in common cases.  */
name|restart
label|:
name|x
operator|=
operator|*
name|loc
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* We may have detected and deleted invalid asm statements.  */
if|if
condition|(
name|object
operator|&&
name|INSN_P
argument_list|(
name|object
argument_list|)
operator|&&
name|INSN_DELETED_P
argument_list|(
name|object
argument_list|)
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Check for some special cases.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|RETURN
case|:
return|return
literal|1
return|;
case|case
name|SET
case|:
comment|/* We are allowed to set the virtual registers.  This means that 	 the actual register should receive the source minus the 	 appropriate offset.  This is used, for example, in the handling 	 of non-local gotos.  */
if|if
condition|(
operator|(
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* We are setting the register, not using it, so the relevant 	     offset is the negative of the offset to use were we using 	     the register.  */
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|src
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The only valid sources here are PLUS or REG.  Just do 	     the simplest possible thing to handle them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PLUS
condition|)
block|{
name|instantiate_virtual_regs_lossage
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
condition|)
name|temp
operator|=
name|force_operand
argument_list|(
name|src
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|src
expr_stmt|;
name|temp
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|offset
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|new
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|extra_insns
condition|)
name|instantiate_virtual_regs_lossage
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|PLUS
case|:
comment|/* Handle special case of virtual register plus constant.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|old
decl_stmt|,
name|new_offset
decl_stmt|;
comment|/* Check for (plus (plus VIRT foo) (const_int)) first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
operator|(
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
condition|)
block|{
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
comment|/* If we have (plus (subreg (virtual-reg)) (const_int)), we know 	     we can commute the PLUS and SUBREG because pointers into the 	     frame are well-behaved.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|ptr_mode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
literal|0
operator|!=
operator|(
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
operator|&&
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|plus_constant
argument_list|(
name|gen_lowpart
argument_list|(
name|ptr_mode
argument_list|,
name|new
argument_list|)
argument_list|,
name|offset
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|(
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We know the second operand is a constant.  Unless the 		 first operand is a REG (which has been already checked), 		 it needs to be checked.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
return|return
literal|1
return|;
block|}
name|new_offset
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* If the new constant is zero, try to replace the sum with just 	     the register.  */
if|if
condition|(
name|new_offset
operator|==
name|const0_rtx
operator|&&
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Next try to replace the register and new offset. 	     There are two changes to validate here and we can't assume that 	     in the case of old offset equals new just changing the register 	     will yield a valid insn.  In the interests of a little efficiency, 	     however, we only call validate change once (we don't queue up the 	     changes and then call apply_change_group).  */
name|old
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|?
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
else|:
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|new
operator|,
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new_offset
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|extra_insns
condition|)
block|{
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|old
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Otherwise copy the new constant into a register and replace 		 constant with that register.  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
condition|)
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|new_offset
argument_list|)
argument_list|,
name|object
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If that didn't work, replace this expression with a 		     register containing the sum.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|old
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|,
name|new_offset
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|force_operand
argument_list|(
name|new
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|validate_replace_rtx
argument_list|(
name|x
argument_list|,
name|temp
argument_list|,
name|object
argument_list|)
condition|)
block|{
name|instantiate_virtual_regs_lossage
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/* Fall through to generic two-operand expression case.  */
case|case
name|EXPR_LIST
case|:
case|case
name|CALL
case|:
case|case
name|COMPARE
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ROTATERT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|MEM
case|:
comment|/* Most cases of MEM that convert to valid addresses have already been 	 handled by our scan of decls.  The only special handling we 	 need here is to make a copy of the rtx to ensure it isn't being 	 shared if we have to change it to a pseudo.  	 If the rtx is a simple reference to an address via a virtual register, 	 it can potentially be shared.  In such cases, first try to make it 	 a valid address, which can also be shared.  Otherwise, copy it and 	 proceed normally.  	 First check for common cases that need no processing.  These are 	 usually due to instantiation already being done on a previous instance 	 of a shared rtx.  */
name|temp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|temp
argument_list|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|temp
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|||
name|temp
operator|==
name|hard_frame_pointer_rtx
endif|#
directive|endif
operator|||
name|temp
operator|==
name|frame_pointer_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|hard_frame_pointer_rtx
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|temp
operator|==
name|virtual_stack_vars_rtx
operator|||
name|temp
operator|==
name|virtual_incoming_args_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
operator|)
operator|)
condition|)
block|{
comment|/* This MEM may be shared.  If the substitution can be done without 	     the need to generate new pseudos, we want to do it in place 	     so all copies of the shared rtx benefit.  The call below will 	     only make substitutions if the resulting address is still 	     valid.  	     Note that we cannot pass X as the object in the recursive call 	     since the insn being processed may not allow all valid 	     addresses.  However, if we were not passed on object, we can 	     only modify X without copying it if X will have a valid 	     address.  	     ??? Also note that this can still lose if OBJECT is an insn that 	     has less restrictions on an address that some other insn. 	     In that case, we will modify the shared address.  This case 	     doesn't seem very likely, though.  One case where this could 	     happen is in the case of a USE or CLOBBER reference, but we 	     take care of that below.  */
if|if
condition|(
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|object
condition|?
name|object
else|:
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise make a copy and process that copy.  We copy the entire 	     RTL expression since it might be a PLUS which could also be 	     shared.  */
operator|*
name|loc
operator|=
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through to generic unary operation case.  */
case|case
name|PREFETCH
case|:
case|case
name|SUBREG
case|:
case|case
name|STRICT_LOW_PART
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
case|case
name|CLZ
case|:
case|case
name|CTZ
case|:
case|case
name|POPCOUNT
case|:
case|case
name|PARITY
case|:
comment|/* These case either have just one operand or we know that we need not 	 check the rest of the operands.  */
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
comment|/* If the operand is a MEM, see if the change is a valid MEM.  If not, 	 go ahead and make the invalid one, but do it to a copy.  For a REG, 	 just make the recursive call, since there's no chance of a problem.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|object
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|REG
case|:
comment|/* Try to replace with a PLUS.  If that doesn't work, compute the sum 	 in front of this insn and substitute the temporary.  */
if|if
condition|(
operator|(
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|x
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|temp
operator|=
name|plus_constant
argument_list|(
name|new
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|extra_insns
condition|)
return|return
literal|0
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|force_operand
argument_list|(
name|temp
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|validate_replace_rtx
argument_list|(
name|x
argument_list|,
name|temp
argument_list|,
name|object
argument_list|)
condition|)
name|instantiate_virtual_regs_lossage
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
case|case
name|ADDRESSOF
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* If we have a (addressof (mem ..)), do any instantiation inside 	     since we know we'll be making the inside valid when we finally 	     remove the ADDRESSOF.  */
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Scan all subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
operator|!
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimization: assuming this function does not receive nonlocal gotos,    delete the handlers for such, as well as the insns to establish    and disestablish them.  */
end_comment

begin_function
specifier|static
name|void
name|delete_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Delete the handler by turning off the flag that would 	 prevent jump_optimize from deleting it. 	 Also permit deletion of the nonlocal labels themselves 	 if nothing local refers to them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|tree
name|t
decl_stmt|,
name|last_t
decl_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Remove it from the nonlocal_label list, to avoid confusing 	     flow.  */
for|for
control|(
name|t
operator|=
name|nonlocal_labels
operator|,
name|last_t
operator|=
literal|0
init|;
name|t
condition|;
name|last_t
operator|=
name|t
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|insn
condition|)
break|break;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
operator|!
name|last_t
condition|)
name|nonlocal_labels
operator|=
name|TREE_CHAIN
argument_list|(
name|nonlocal_labels
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|last_t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
block|{
name|int
name|can_delete
init|=
literal|0
decl_stmt|;
name|rtx
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|nonlocal_goto_handler_slots
init|;
name|t
operator|!=
literal|0
condition|;
name|t
operator|=
name|XEXP
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|t
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|can_delete
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|can_delete
operator|||
operator|(
name|nonlocal_goto_stack_level
operator|!=
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|nonlocal_goto_stack_level
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the first insn following those generated by `assign_parms'.  */
end_comment

begin_function
name|rtx
name|get_first_nonparm_insn
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|last_parm_insn
condition|)
return|return
name|NEXT_INSN
argument_list|(
name|last_parm_insn
argument_list|)
return|;
return|return
name|get_insns
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXP is an aggregate type (or a value with aggregate type).    This means a type for which function calls must pass an address to the    function or get an address back from the function.    EXP may be a type node or an expression (whose type is tested).  */
end_comment

begin_function
name|int
name|aggregate_value_p
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|fntype
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|,
name|nregs
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|tree
name|type
init|=
operator|(
name|TYPE_P
argument_list|(
name|exp
argument_list|)
operator|)
condition|?
name|exp
else|:
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|fntype
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
name|fntype
operator|=
name|get_callee_fndecl
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|fntype
condition|?
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|fntype
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* We don't expect other rtl types here.  */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|return_in_memory
argument_list|(
name|type
argument_list|,
name|fntype
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Types that are TREE_ADDRESSABLE must be constructed in memory,      and thus can't be returned in registers.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flag_pcc_struct_return
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Make sure we have suitable call-clobbered regs to return      the value in; if not, we must return it in memory.  */
name|reg
operator|=
name|hard_function_value
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have something other than a REG (e.g. a PARALLEL), then assume      it is OK.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|regno
operator|+
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign RTL expressions to the function's parameters.    This may involve copying them into registers and using    those registers as the RTL for them.  */
end_comment

begin_function
name|void
name|assign_parms
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|parm
decl_stmt|;
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
comment|/* Total space needed so far for args on the stack,      given as a constant and a tree-expression.  */
name|struct
name|args_size
name|stack_args_size
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|fnargs
init|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|,
name|orig_fnargs
decl_stmt|;
comment|/* This is used for the arg pointer when referring to stack args.  */
name|rtx
name|internal_arg_pointer
decl_stmt|;
comment|/* This is a dummy PARM_DECL that we used for the function result if      the function returns a structure.  */
name|tree
name|function_result_decl
init|=
literal|0
decl_stmt|;
name|int
name|varargs_setup
init|=
literal|0
decl_stmt|;
name|int
name|reg_parm_stack_space
name|ATTRIBUTE_UNUSED
init|=
literal|0
decl_stmt|;
name|rtx
name|conversion_insns
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if function takes extra anonymous args.      This means the last named arg must be on the stack      right before the anonymous ones.  */
name|int
name|stdarg
init|=
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
decl_stmt|;
name|current_function_stdarg
operator|=
name|stdarg
expr_stmt|;
comment|/* If the reg that the virtual arg pointer will be translated into is      not a fixed reg or is the stack pointer, make a copy of the virtual      arg pointer, and address parms via the copy.  The frame pointer is      considered fixed even though it is not marked as such.       The second time through, simply use ap to avoid generating rtx.  */
if|if
condition|(
operator|(
name|ARG_POINTER_REGNUM
operator|==
name|STACK_POINTER_REGNUM
operator|||
operator|!
operator|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|||
name|ARG_POINTER_REGNUM
operator|==
name|FRAME_POINTER_REGNUM
operator|)
operator|)
condition|)
name|internal_arg_pointer
operator|=
name|copy_to_reg
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
else|else
name|internal_arg_pointer
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
name|current_function_internal_arg_pointer
operator|=
name|internal_arg_pointer
expr_stmt|;
name|stack_args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|stack_args_size
operator|.
name|var
operator|=
literal|0
expr_stmt|;
comment|/* If struct value address is treated as the first argument, make it so.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|fndecl
argument_list|)
operator|&&
operator|!
name|current_function_returns_pcc_struct
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
decl_stmt|;
name|function_result_decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|function_result_decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|function_result_decl
argument_list|)
operator|=
name|fnargs
expr_stmt|;
name|fnargs
operator|=
name|function_result_decl
expr_stmt|;
block|}
name|orig_fnargs
operator|=
name|fnargs
expr_stmt|;
name|max_parm_reg
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
expr_stmt|;
name|parm_reg_stack_loc
operator|=
name|ggc_alloc_cleared
argument_list|(
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the target wants to split complex arguments into scalars, do so.  */
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
condition|)
name|fnargs
operator|=
name|split_complex_args
argument_list|(
name|fnargs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|MAYBE_REG_PARM_STACK_SPACE
expr_stmt|;
else|#
directive|else
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INIT_CUMULATIVE_INCOMING_ARGS
name|INIT_CUMULATIVE_INCOMING_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|fntype
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|#
directive|else
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|fntype
argument_list|,
name|NULL_RTX
argument_list|,
name|fndecl
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We haven't yet found an argument that we must push and pretend the      caller did.  */
name|current_function_pretend_args_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|fnargs
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|rtx
name|entry_parm
decl_stmt|;
name|rtx
name|stack_parm
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|,
name|passed_mode
decl_stmt|;
name|enum
name|machine_mode
name|nominal_mode
decl_stmt|,
name|promoted_nominal_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|struct
name|locate_and_pad_arg_data
name|locate
decl_stmt|;
name|int
name|passed_pointer
init|=
literal|0
decl_stmt|;
name|int
name|did_conversion
init|=
literal|0
decl_stmt|;
name|tree
name|passed_type
init|=
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|nominal_type
init|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|int
name|last_named
init|=
literal|0
decl_stmt|,
name|named_arg
decl_stmt|;
name|int
name|in_regs
decl_stmt|;
name|int
name|partial
init|=
literal|0
decl_stmt|;
name|int
name|pretend_bytes
init|=
literal|0
decl_stmt|;
comment|/* Set LAST_NAMED if this is last named arg before last 	 anonymous args.  */
if|if
condition|(
name|stdarg
condition|)
block|{
name|tree
name|tem
decl_stmt|;
for|for
control|(
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
condition|)
break|break;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|last_named
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set NAMED_ARG if this arg should be treated as a named arg.  For 	 most machines, if this is a varargs/stdarg function, then we treat 	 the last named arg as if it were anonymous too.  */
name|named_arg
operator|=
name|targetm
operator|.
name|calls
operator|.
name|strict_argument_naming
argument_list|(
operator|&
name|args_so_far
argument_list|)
condition|?
literal|1
else|:
operator|!
name|last_named
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|error_mark_node
comment|/* This can happen after weird syntax errors 	     or if an enum type is defined among the parms.  */
operator|||
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
operator|||
name|passed_type
operator|==
name|NULL
condition|)
block|{
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Find mode of arg as it is passed, and mode of arg 	 as it should be during execution of this function.  */
name|passed_mode
operator|=
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
expr_stmt|;
name|nominal_mode
operator|=
name|TYPE_MODE
argument_list|(
name|nominal_type
argument_list|)
expr_stmt|;
comment|/* If the parm's mode is VOID, its value doesn't matter, 	 and avoid the usual things like emit_move_insn that could crash.  */
if|if
condition|(
name|nominal_mode
operator|==
name|VOIDmode
condition|)
block|{
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the parm is to be passed as a transparent union, use the 	 type of the first field for the tests below.  We have already 	 verified that the modes are the same.  */
if|if
condition|(
name|DECL_TRANSPARENT_UNION
argument_list|(
name|parm
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|passed_type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|passed_type
argument_list|)
operator|)
condition|)
name|passed_type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|passed_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if this arg was passed by invisible reference.  It is if 	 it is an object whose size depends on the contents of the 	 object itself or if the machine requires these objects be passed 	 that way.  */
if|if
condition|(
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|TYPE_SIZE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|passed_type
argument_list|)
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PASS_BY_REFERENCE
operator|||
name|FUNCTION_ARG_PASS_BY_REFERENCE
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|passed_type
argument_list|,
name|named_arg
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|passed_type
operator|=
name|nominal_type
operator|=
name|build_pointer_type
argument_list|(
name|passed_type
argument_list|)
expr_stmt|;
name|passed_pointer
operator|=
literal|1
expr_stmt|;
name|passed_mode
operator|=
name|nominal_mode
operator|=
name|Pmode
expr_stmt|;
block|}
comment|/* See if the frontend wants to pass this by invisible reference.  */
elseif|else
if|if
condition|(
name|passed_type
operator|!=
name|nominal_type
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|passed_type
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|passed_type
argument_list|)
operator|==
name|nominal_type
condition|)
block|{
name|nominal_type
operator|=
name|passed_type
expr_stmt|;
name|passed_pointer
operator|=
literal|1
expr_stmt|;
name|passed_mode
operator|=
name|nominal_mode
operator|=
name|Pmode
expr_stmt|;
block|}
name|promoted_mode
operator|=
name|passed_mode
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|promote_function_args
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Compute the mode in which the arg is actually extended to.  */
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|passed_type
argument_list|)
expr_stmt|;
name|promoted_mode
operator|=
name|promote_mode
argument_list|(
name|passed_type
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Let machine desc say which reg (if any) the parm arrives in. 	 0 means it arrives on the stack.  */
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
name|entry_parm
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
name|named_arg
argument_list|)
expr_stmt|;
else|#
directive|else
name|entry_parm
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
name|named_arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry_parm
operator|==
literal|0
condition|)
name|promoted_mode
operator|=
name|passed_mode
expr_stmt|;
comment|/* If this is the last named parameter, do any required setup for 	 varargs or stdargs.  We need to know about the case of this being an 	 addressable type, in which case we skip the registers it 	 would have arrived in.  	 For stdargs, LAST_NAMED will be set for two parameters, the one that 	 is actually the last named, and the dummy parameter.  We only 	 want to do this action once.  	 Also, indicate when RTL generation is to be suppressed.  */
if|if
condition|(
name|last_named
operator|&&
operator|!
name|varargs_setup
condition|)
block|{
name|int
name|varargs_pretend_bytes
init|=
literal|0
decl_stmt|;
name|targetm
operator|.
name|calls
operator|.
name|setup_incoming_varargs
argument_list|(
operator|&
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
operator|&
name|varargs_pretend_bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|varargs_setup
operator|=
literal|1
expr_stmt|;
comment|/* If the back-end has requested extra stack space, record how 	     much is needed.  Do not change pretend_args_size otherwise 	     since it may be nonzero from an earlier partial argument.  */
if|if
condition|(
name|varargs_pretend_bytes
operator|>
literal|0
condition|)
name|current_function_pretend_args_size
operator|=
name|varargs_pretend_bytes
expr_stmt|;
block|}
comment|/* Determine parm's home in the stack, 	 in case it arrives in the stack or we should pretend it did.  	 Compute the stack position and rtx where the argument arrives 	 and its size.  	 There is one complexity here:  If this was a parameter that would 	 have been passed in registers, but wasn't only because it is 	 __builtin_va_alist, we want locate_and_pad_parm to treat it as if 	 it came in a register so that REG_PARM_STACK_SPACE isn't skipped. 	 In this case, we call FUNCTION_ARG with NAMED set to 1 instead of 	 0 as it was the previous time.  */
name|in_regs
operator|=
name|entry_parm
operator|!=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
name|in_regs
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|in_regs
operator|&&
operator|!
name|named_arg
condition|)
block|{
name|int
name|pretend_named
init|=
name|targetm
operator|.
name|calls
operator|.
name|pretend_outgoing_varargs_named
argument_list|(
operator|&
name|args_so_far
argument_list|)
decl_stmt|;
if|if
condition|(
name|pretend_named
condition|)
block|{
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
name|in_regs
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
name|pretend_named
argument_list|)
operator|!=
literal|0
expr_stmt|;
else|#
directive|else
name|in_regs
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
name|pretend_named
argument_list|)
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* If this parameter was passed both in registers and in the stack, 	 use the copy on the stack.  */
if|if
condition|(
name|MUST_PASS_IN_STACK
argument_list|(
name|promoted_mode
argument_list|,
name|passed_type
argument_list|)
condition|)
name|entry_parm
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
if|if
condition|(
name|entry_parm
condition|)
block|{
name|partial
operator|=
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
name|named_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|partial
ifndef|#
directive|ifndef
name|MAYBE_REG_PARM_STACK_SPACE
comment|/* The caller might already have allocated stack space 		 for the register parameters.  */
operator|&&
name|reg_parm_stack_space
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
comment|/* Part of this argument is passed in registers and part 		 is passed on the stack.  Ask the prologue code to extend 		 the stack part so that we can recreate the full value.  		 PRETEND_BYTES is the size of the registers we need to store. 		 CURRENT_FUNCTION_PRETEND_ARGS_SIZE is the amount of extra 		 stack space that the prologue should allocate.  		 Internally, gcc assumes that the argument pointer is 		 aligned to STACK_BOUNDARY bits.  This is used both for 		 alignment optimizations (see init_emit) and to locate 		 arguments that are aligned to more than PARM_BOUNDARY 		 bits.  We must preserve this invariant by rounding 		 CURRENT_FUNCTION_PRETEND_ARGS_SIZE up to a stack 		 boundary.  */
name|pretend_bytes
operator|=
name|partial
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|current_function_pretend_args_size
operator|=
name|CEIL_ROUND
argument_list|(
name|pretend_bytes
argument_list|,
name|STACK_BYTES
argument_list|)
expr_stmt|;
comment|/* If PRETEND_BYTES != CURRENT_FUNCTION_PRETEND_ARGS_SIZE, 		 insert the padding before the start of the first pretend 		 argument.  */
name|stack_args_size
operator|.
name|constant
operator|=
operator|(
name|current_function_pretend_args_size
operator|-
name|pretend_bytes
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|locate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|locate
argument_list|)
argument_list|)
expr_stmt|;
name|locate_and_pad_parm
argument_list|(
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
name|in_regs
argument_list|,
name|entry_parm
condition|?
name|partial
else|:
literal|0
argument_list|,
name|fndecl
argument_list|,
operator|&
name|stack_args_size
argument_list|,
operator|&
name|locate
argument_list|)
expr_stmt|;
block|{
name|rtx
name|offset_rtx
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|,
name|boundary
decl_stmt|;
comment|/* If we're passing this arg using a reg, make its stack home 	   the aligned stack slot.  */
if|if
condition|(
name|entry_parm
condition|)
name|offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|locate
operator|.
name|slot_offset
argument_list|)
expr_stmt|;
else|else
name|offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|locate
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_rtx
operator|==
name|const0_rtx
condition|)
name|stack_parm
operator|=
name|gen_rtx_MEM
argument_list|(
name|promoted_mode
argument_list|,
name|internal_arg_pointer
argument_list|)
expr_stmt|;
else|else
name|stack_parm
operator|=
name|gen_rtx_MEM
argument_list|(
name|promoted_mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|internal_arg_pointer
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|stack_parm
argument_list|,
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|boundary
operator|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|promoted_mode
argument_list|,
name|passed_type
argument_list|)
expr_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
comment|/* If we're padding upward, we know that the alignment of the slot 	   is FUNCTION_ARG_BOUNDARY.  If we're using slot_offset, we're 	   intentionally forcing upward padding.  Otherwise we have to come 	   up with a guess at the alignment based on OFFSET_RTX.  */
if|if
condition|(
name|locate
operator|.
name|where_pad
operator|==
name|upward
operator|||
name|entry_parm
condition|)
name|align
operator|=
name|boundary
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|align
operator|=
name|INTVAL
argument_list|(
name|offset_rtx
argument_list|)
operator|*
name|BITS_PER_UNIT
operator||
name|boundary
expr_stmt|;
name|align
operator|=
name|align
operator|&
operator|-
name|align
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|0
condition|)
name|set_mem_align
argument_list|(
name|stack_parm
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_parm
condition|)
name|set_reg_attrs_for_parm
argument_list|(
name|entry_parm
argument_list|,
name|stack_parm
argument_list|)
expr_stmt|;
block|}
comment|/* If this parm was passed part in regs and part in memory, 	 pretend it arrived entirely in memory 	 by pushing the register-part onto the stack.  	 In the special case of a DImode or DFmode that is split, 	 we could put it together in a pseudoreg directly, 	 but for now that's not worth bothering with.  */
if|if
condition|(
name|partial
condition|)
block|{
comment|/* Handle calls that pass values in multiple non-contiguous 	     locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_store
argument_list|(
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|entry_parm
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|move_block_from_reg
argument_list|(
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|partial
argument_list|)
expr_stmt|;
name|entry_parm
operator|=
name|stack_parm
expr_stmt|;
block|}
comment|/* If we didn't decide this parm came in a register, 	 by default it came on the stack.  */
if|if
condition|(
name|entry_parm
operator|==
literal|0
condition|)
name|entry_parm
operator|=
name|stack_parm
expr_stmt|;
comment|/* Record permanently how this parm was passed.  */
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|entry_parm
expr_stmt|;
comment|/* If there is actually space on the stack for this parm, 	 count it in stack_args_size; otherwise set stack_parm to 0 	 to indicate there is no preallocated stack slot for the parm.  */
if|if
condition|(
name|entry_parm
operator|==
name|stack_parm
operator|||
operator|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_RTX
operator|)
if|#
directive|if
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MAYBE_REG_PARM_STACK_SPACE
argument_list|)
comment|/* On some machines, even if a parm value arrives in a register 	     there is still an (uninitialized) stack slot allocated for it.  	     ??? When MAYBE_REG_PARM_STACK_SPACE is defined, we can't tell 	     whether this parameter already has a stack slot allocated, 	     because an arg block exists only if current_function_args_size 	     is larger than some threshold, and we haven't calculated that 	     yet.  So, for now, we just assume that stack slots never exist 	     in this case.  */
operator|||
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
operator|>
literal|0
endif|#
directive|endif
condition|)
block|{
name|stack_args_size
operator|.
name|constant
operator|+=
name|pretend_bytes
operator|+
name|locate
operator|.
name|size
operator|.
name|constant
expr_stmt|;
if|if
condition|(
name|locate
operator|.
name|size
operator|.
name|var
condition|)
name|ADD_PARM_SIZE
argument_list|(
name|stack_args_size
argument_list|,
name|locate
operator|.
name|size
operator|.
name|var
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* No stack slot was pushed for this parm.  */
name|stack_parm
operator|=
literal|0
expr_stmt|;
comment|/* Update info on where next arg arrives in registers.  */
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
name|named_arg
argument_list|)
expr_stmt|;
comment|/* If we can't trust the parm stack slot to be aligned enough 	 for its ultimate type, don't use that slot after entry. 	 We'll make another stack slot, if we need one.  */
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|stack_parm
operator|&&
name|GET_MODE_ALIGNMENT
argument_list|(
name|nominal_mode
argument_list|)
operator|>
name|MEM_ALIGN
argument_list|(
name|stack_parm
argument_list|)
condition|)
name|stack_parm
operator|=
literal|0
expr_stmt|;
comment|/* If parm was passed in memory, and we need to convert it on entry, 	 don't store it back in that same slot.  */
if|if
condition|(
name|entry_parm
operator|==
name|stack_parm
operator|&&
name|nominal_mode
operator|!=
name|BLKmode
operator|&&
name|nominal_mode
operator|!=
name|passed_mode
condition|)
name|stack_parm
operator|=
literal|0
expr_stmt|;
comment|/* When an argument is passed in multiple locations, we can't 	 make use of this information, but we can save some copying if 	 the whole argument is passed in a single register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|nominal_mode
operator|!=
name|BLKmode
operator|&&
name|passed_mode
operator|!=
name|BLKmode
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|XVECLEN
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|passed_mode
operator|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|entry_parm
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|entry_parm
expr_stmt|;
break|break;
block|}
block|}
comment|/* ENTRY_PARM is an RTX for the parameter as it arrives, 	 in the mode in which it arrives. 	 STACK_PARM is an RTX for a stack slot where the parameter can live 	 during the function (in case we want to put it there). 	 STACK_PARM is 0 if no stack slot was pushed for it.  	 Now output code if necessary to convert ENTRY_PARM to 	 the type in which this function declares it, 	 and store that result in an appropriate place, 	 which may be a pseudo reg, may be STACK_PARM, 	 or may be a local stack slot if STACK_PARM is 0.  	 Set DECL_RTL to that place.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|nominal_mode
operator|!=
name|BLKmode
operator|&&
name|XVECLEN
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* Reconstitute objects the size of a register or larger using 	     register operations instead of the stack.  */
name|rtx
name|parmreg
init|=
name|gen_reg_rtx
argument_list|(
name|nominal_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|parmreg
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|parmreg
argument_list|)
decl_stmt|;
name|emit_group_store
argument_list|(
name|parmreg
argument_list|,
name|entry_parm
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|parmreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|max_parm_reg
condition|)
block|{
name|rtx
modifier|*
name|new
decl_stmt|;
name|int
name|old_max_parm_reg
init|=
name|max_parm_reg
decl_stmt|;
comment|/* It's slow to expand this one register at a time, 		     but it's also rare and we need max_parm_reg to be 		     precisely correct.  */
name|max_parm_reg
operator|=
name|regno
operator|+
literal|1
expr_stmt|;
name|new
operator|=
name|ggc_realloc
argument_list|(
name|parm_reg_stack_loc
argument_list|,
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
operator|+
name|old_max_parm_reg
argument_list|,
literal|0
argument_list|,
operator|(
name|max_parm_reg
operator|-
name|old_max_parm_reg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|parm_reg_stack_loc
operator|=
name|new
expr_stmt|;
name|parm_reg_stack_loc
index|[
name|regno
index|]
operator|=
name|stack_parm
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nominal_mode
operator|==
name|BLKmode
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
operator|||
operator|(
name|locate
operator|.
name|where_pad
operator|==
operator|(
name|BYTES_BIG_ENDIAN
condition|?
name|upward
else|:
name|downward
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|promoted_mode
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|)
endif|#
directive|endif
operator|||
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* If a BLKmode arrives in registers, copy it to a stack slot. 	     Handle calls that pass values in multiple non-contiguous 	     locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|size_stored
init|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
comment|/* Note that we will be storing an integral number of words. 		 So we have to be careful to ensure that we allocate an 		 integral number of words.  We do this below in the 		 assign_stack_local if space was not allocated in the argument 		 list.  If it was, this will not work if PARM_BOUNDARY is not 		 a multiple of BITS_PER_WORD.  It isn't clear how to fix this 		 if it becomes a problem.  Exception is when BLKmode arrives 		 with arguments not conforming to word_mode.  */
if|if
condition|(
name|stack_parm
operator|==
literal|0
condition|)
block|{
name|stack_parm
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|size_stored
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|stack_parm
argument_list|,
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|stack_parm
argument_list|,
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|PARM_BOUNDARY
operator|%
name|BITS_PER_WORD
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mem
operator|=
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
expr_stmt|;
comment|/* Handle calls that pass values in multiple non-contiguous 		 locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_store
argument_list|(
name|mem
argument_list|,
name|entry_parm
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* If SIZE is that of a mode no bigger than a word, just use 		 that mode's store operation.  */
elseif|else
if|if
condition|(
name|size
operator|<=
name|UNITS_PER_WORD
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
operator|&&
operator|(
name|size
operator|==
name|UNITS_PER_WORD
operator|||
operator|(
name|BLOCK_REG_PADDING
argument_list|(
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
operator|(
name|BYTES_BIG_ENDIAN
condition|?
name|upward
else|:
name|downward
operator|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Blocks smaller than a word on a BYTES_BIG_ENDIAN 		     machine must be aligned to the left before storing 		     to memory.  Note that the previous test doesn't 		     handle all cases (e.g. SIZE == 3).  */
elseif|else
if|if
condition|(
name|size
operator|!=
name|UNITS_PER_WORD
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
operator|&&
operator|(
name|BLOCK_REG_PADDING
argument_list|(
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|downward
operator|)
else|#
directive|else
operator|&&
name|BYTES_BIG_ENDIAN
endif|#
directive|endif
condition|)
block|{
name|rtx
name|tem
decl_stmt|,
name|x
decl_stmt|;
name|int
name|by
init|=
operator|(
name|UNITS_PER_WORD
operator|-
name|size
operator|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ashl_optab
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|by
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|tem
operator|=
name|change_address
argument_list|(
name|mem
argument_list|,
name|word_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|move_block_from_reg
argument_list|(
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|mem
argument_list|,
name|size_stored
operator|/
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
else|else
name|move_block_from_reg
argument_list|(
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|mem
argument_list|,
name|size_stored
operator|/
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
comment|/* If parm is already bound to register pair, don't change  	     this binding.  */
if|if
condition|(
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|parm
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|stack_parm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
operator|!
name|optimize
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|parm
argument_list|)
operator|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|parm
argument_list|)
comment|/* If -ffloat-store specified, don't put explicit 		     float variables into registers.  */
operator|||
operator|(
name|flag_float_store
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|)
comment|/* Always assign pseudo to structure return or item passed 		  by invisible reference.  */
operator|||
name|passed_pointer
operator|||
name|parm
operator|==
name|function_result_decl
condition|)
block|{
comment|/* Store the parm in a pseudoregister during the function, but we 	     may need to do it in a wider mode.  */
name|rtx
name|parmreg
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|,
name|regnoi
init|=
literal|0
decl_stmt|,
name|regnor
init|=
literal|0
decl_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|promoted_nominal_mode
operator|=
name|promote_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|nominal_mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parmreg
operator|=
name|gen_reg_rtx
argument_list|(
name|promoted_nominal_mode
argument_list|)
expr_stmt|;
name|mark_user_reg
argument_list|(
name|parmreg
argument_list|)
expr_stmt|;
comment|/* If this was an item that we received a pointer to, set DECL_RTL 	     appropriately.  */
if|if
condition|(
name|passed_pointer
condition|)
block|{
name|rtx
name|x
init|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
argument_list|,
name|parmreg
argument_list|)
decl_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|parmreg
argument_list|)
expr_stmt|;
name|maybe_set_unchanging
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the value into the register.  */
if|if
condition|(
name|nominal_mode
operator|!=
name|passed_mode
operator|||
name|promoted_nominal_mode
operator|!=
name|promoted_mode
condition|)
block|{
name|int
name|save_tree_used
decl_stmt|;
comment|/* ENTRY_PARM has been converted to PROMOTED_MODE, its 		 mode, by the caller.  We now have to convert it to 		 NOMINAL_MODE, if different.  However, PARMREG may be in 		 a different mode than NOMINAL_MODE if it is being stored 		 promoted.  		 If ENTRY_PARM is a hard register, it might be in a register 		 not valid for operating in its mode (e.g., an odd-numbered 		 register for a DFmode).  In that case, moves are the only 		 thing valid, so we can't do a convert from there.  This 		 occurs when the calling sequence allow such misaligned 		 usages.  		 In addition, the conversion may involve a call, which could 		 clobber parameters which haven't been copied to pseudo 		 registers yet.  Therefore, we must first copy the parm to 		 a pseudo reg here, and save the conversion until after all 		 parameters have been moved.  */
name|rtx
name|tempreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tempreg
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|tempreg
operator|=
name|convert_to_mode
argument_list|(
name|nominal_mode
argument_list|,
name|tempreg
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tempreg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|tempreg
argument_list|)
operator|==
name|nominal_mode
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|tempreg
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|nominal_mode
operator|==
name|passed_mode
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|tempreg
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tempreg
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The argument is already sign/zero extended, so note it 		     into the subreg.  */
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|tempreg
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_SET
argument_list|(
name|tempreg
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
comment|/* TREE_USED gets set erroneously during expand_assignment.  */
name|save_tree_used
operator|=
name|TREE_USED
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|parm
argument_list|,
name|make_tree
argument_list|(
name|nominal_type
argument_list|,
name|tempreg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|parm
argument_list|)
operator|=
name|save_tree_used
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|did_conversion
operator|=
literal|1
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we were passed a pointer but the actual value 	     can safely live in a register, put it in one.  */
if|if
condition|(
name|passed_pointer
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|BLKmode
comment|/* If by-reference argument was promoted, demote it.  */
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|||
operator|!
operator|(
operator|(
operator|!
name|optimize
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|parm
argument_list|)
operator|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|parm
argument_list|)
comment|/* If -ffloat-store specified, don't put explicit 			   float variables into registers.  */
operator|||
operator|(
name|flag_float_store
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* We can't use nominal_mode, because it will have been set to 		 Pmode above.  We must use the actual mode of the parm.  */
name|parmreg
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mark_user_reg
argument_list|(
name|parmreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|parmreg
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tempreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsigned_p
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tempreg
argument_list|,
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|convert_to_mode
argument_list|(
name|GET_MODE
argument_list|(
name|parmreg
argument_list|)
argument_list|,
name|tempreg
argument_list|,
name|unsigned_p
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|did_conversion
operator|=
literal|1
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|parmreg
argument_list|)
expr_stmt|;
comment|/* STACK_PARM is the pointer, not the parm, and PARMREG is 		 now the parm.  */
name|stack_parm
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FUNCTION_ARG_CALLEE_COPIES
comment|/* If we are passed an arg by reference and it is our responsibility 	     to make a copy, do it now. 	     PASSED_TYPE and PASSED mode now refer to the pointer, not the 	     original argument, so we must recreate them in the call to 	     FUNCTION_ARG_CALLEE_COPIES.  */
comment|/* ??? Later add code to handle the case that if the argument isn't 	     modified, don't do the copy.  */
elseif|else
if|if
condition|(
name|passed_pointer
operator|&&
name|FUNCTION_ARG_CALLEE_COPIES
argument_list|(
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|passed_type
argument_list|)
argument_list|,
name|named_arg
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|copy
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|passed_type
argument_list|)
decl_stmt|;
comment|/* This sequence may involve a library call perhaps clobbering 		 registers that haven't been copied to pseudos yet.  */
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
comment|/* This is a variable sized object.  */
name|copy
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|allocate_dynamic_stack_space
argument_list|(
name|expr_size
argument_list|(
name|parm
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|copy
operator|=
name|assign_stack_temp
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|copy
argument_list|,
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|parm
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|did_conversion
operator|=
literal|1
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FUNCTION_ARG_CALLEE_COPIES */
comment|/* In any case, record the parm's desired stack location 	     in case we later discover it must live in the stack.  	     If it is a COMPLEX value, store the stack location for both 	     halves.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|parmreg
argument_list|)
operator|==
name|CONCAT
condition|)
name|regno
operator|=
name|MAX
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|parmreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|parmreg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|regno
operator|=
name|REGNO
argument_list|(
name|parmreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|max_parm_reg
condition|)
block|{
name|rtx
modifier|*
name|new
decl_stmt|;
name|int
name|old_max_parm_reg
init|=
name|max_parm_reg
decl_stmt|;
comment|/* It's slow to expand this one register at a time, 		 but it's also rare and we need max_parm_reg to be 		 precisely correct.  */
name|max_parm_reg
operator|=
name|regno
operator|+
literal|1
expr_stmt|;
name|new
operator|=
name|ggc_realloc
argument_list|(
name|parm_reg_stack_loc
argument_list|,
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
operator|+
name|old_max_parm_reg
argument_list|,
literal|0
argument_list|,
operator|(
name|max_parm_reg
operator|-
name|old_max_parm_reg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|parm_reg_stack_loc
operator|=
name|new
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|parmreg
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|enum
name|machine_mode
name|submode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|parmreg
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|regnor
operator|=
name|REGNO
argument_list|(
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|parmreg
argument_list|)
argument_list|)
expr_stmt|;
name|regnoi
operator|=
name|REGNO
argument_list|(
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|parmreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_parm
operator|!=
literal|0
condition|)
block|{
name|parm_reg_stack_loc
index|[
name|regnor
index|]
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|stack_parm
argument_list|)
expr_stmt|;
name|parm_reg_stack_loc
index|[
name|regnoi
index|]
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|stack_parm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parm_reg_stack_loc
index|[
name|regnor
index|]
operator|=
literal|0
expr_stmt|;
name|parm_reg_stack_loc
index|[
name|regnoi
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|parm_reg_stack_loc
index|[
name|REGNO
argument_list|(
name|parmreg
argument_list|)
index|]
operator|=
name|stack_parm
expr_stmt|;
comment|/* Mark the register as eliminable if we did no conversion 	     and it was copied from memory at a fixed offset, 	     and the arg pointer was not copied to a pseudo-reg. 	     If the arg pointer is a pseudo reg or the offset formed 	     an invalid address, such memory-equivalences 	     as we make here would screw up life analysis for it.  */
if|if
condition|(
name|nominal_mode
operator|==
name|passed_mode
operator|&&
operator|!
name|did_conversion
operator|&&
name|stack_parm
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|stack_parm
argument_list|)
operator|==
name|MEM
operator|&&
name|locate
operator|.
name|offset
operator|.
name|var
operator|==
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|XEXP
argument_list|(
name|stack_parm
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|linsn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|sinsn
decl_stmt|,
name|set
decl_stmt|;
comment|/* Mark complex types separately.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|parmreg
argument_list|)
operator|==
name|CONCAT
condition|)
comment|/* Scan backwards for the set of the real and 		   imaginary parts.  */
for|for
control|(
name|sinsn
operator|=
name|linsn
init|;
name|sinsn
operator|!=
literal|0
condition|;
name|sinsn
operator|=
name|prev_nonnote_insn
argument_list|(
name|sinsn
argument_list|)
control|)
block|{
name|set
operator|=
name|single_set
argument_list|(
name|sinsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|regno_reg_rtx
index|[
name|regnoi
index|]
condition|)
name|REG_NOTES
argument_list|(
name|sinsn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|parm_reg_stack_loc
index|[
name|regnoi
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|sinsn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|regno_reg_rtx
index|[
name|regnor
index|]
condition|)
name|REG_NOTES
argument_list|(
name|sinsn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|parm_reg_stack_loc
index|[
name|regnor
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|sinsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|linsn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|parmreg
condition|)
name|REG_NOTES
argument_list|(
name|linsn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|stack_parm
argument_list|,
name|REG_NOTES
argument_list|(
name|linsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For pointer data type, suggest pointer register.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|parmreg
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If something wants our address, try to use ADDRESSOF.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
comment|/* If we end up putting something into the stack, 		 fixup_var_refs_insns will need to make a pass over 		 all the instructions.  It looks through the pending 		 sequences -- but it can't see the ones in the 		 CONVERSION_INSNS, if they're not on the sequence 		 stack.  So, we go back to that sequence, just so that 		 the fixups will happen.  */
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|put_var_into_stack
argument_list|(
name|parm
argument_list|,
comment|/*rescan=*/
name|true
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Value must be stored in the stack slot STACK_PARM 	     during function execution.  */
if|if
condition|(
name|promoted_mode
operator|!=
name|nominal_mode
condition|)
block|{
comment|/* Conversion is required.  */
name|rtx
name|tempreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tempreg
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|entry_parm
operator|=
name|convert_to_mode
argument_list|(
name|nominal_mode
argument_list|,
name|tempreg
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_parm
condition|)
comment|/* ??? This may need a big-endian conversion on sparc64.  */
name|stack_parm
operator|=
name|adjust_address
argument_list|(
name|stack_parm
argument_list|,
name|nominal_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|did_conversion
operator|=
literal|1
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|entry_parm
operator|!=
name|stack_parm
condition|)
block|{
if|if
condition|(
name|stack_parm
operator|==
literal|0
condition|)
block|{
name|stack_parm
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|stack_parm
argument_list|,
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|promoted_mode
operator|!=
name|nominal_mode
condition|)
block|{
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|stack_parm
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
operator|&&
name|fnargs
operator|!=
name|orig_fnargs
condition|)
block|{
for|for
control|(
name|parm
operator|=
name|orig_fnargs
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|real
decl_stmt|,
name|imag
decl_stmt|;
name|enum
name|machine_mode
name|inner
init|=
name|GET_MODE_INNER
argument_list|(
name|DECL_MODE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|real
operator|=
name|DECL_RTL
argument_list|(
name|fnargs
argument_list|)
expr_stmt|;
name|imag
operator|=
name|DECL_RTL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|fnargs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
operator|!=
name|GET_MODE
argument_list|(
name|real
argument_list|)
condition|)
block|{
name|real
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|inner
argument_list|,
name|real
argument_list|)
expr_stmt|;
name|imag
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|inner
argument_list|,
name|imag
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|gen_rtx_CONCAT
argument_list|(
name|DECL_MODE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|real
argument_list|,
name|imag
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|real
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|fnargs
argument_list|)
expr_stmt|;
name|imag
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|fnargs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
operator|!=
name|GET_MODE
argument_list|(
name|real
argument_list|)
condition|)
block|{
name|real
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|inner
argument_list|,
name|real
argument_list|)
expr_stmt|;
name|imag
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|inner
argument_list|,
name|imag
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|gen_rtx_CONCAT
argument_list|(
name|DECL_MODE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|real
argument_list|,
name|imag
argument_list|)
expr_stmt|;
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|fnargs
operator|=
name|TREE_CHAIN
argument_list|(
name|fnargs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|DECL_RTL
argument_list|(
name|fnargs
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|fnargs
argument_list|)
expr_stmt|;
block|}
name|fnargs
operator|=
name|TREE_CHAIN
argument_list|(
name|fnargs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output all parameter conversion instructions (possibly including calls)      now that all parameters have been copied out of hard registers.  */
name|emit_insn
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
comment|/* If we are receiving a struct value address as the first argument, set up      the RTL for the function result. As this might require code to convert      the transmitted address to Pmode, we do this here to ensure that possible      preliminary conversions of the address have been emitted already.  */
if|if
condition|(
name|function_result_decl
condition|)
block|{
name|tree
name|result
init|=
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|DECL_RTL
argument_list|(
name|function_result_decl
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|result
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|result
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|last_parm_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|current_function_args_size
operator|=
name|stack_args_size
operator|.
name|constant
expr_stmt|;
comment|/* Adjust function incoming argument size for alignment and      minimum length.  */
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
ifndef|#
directive|ifndef
name|MAYBE_REG_PARM_STACK_SPACE
name|current_function_args_size
operator|=
name|MAX
argument_list|(
name|current_function_args_size
argument_list|,
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|current_function_args_size
operator|=
operator|(
operator|(
name|current_function_args_size
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|)
operator|*
name|STACK_BYTES
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|current_function_arg_offset_rtx
operator|=
operator|(
name|stack_args_size
operator|.
name|var
operator|==
literal|0
condition|?
name|GEN_INT
argument_list|(
operator|-
name|stack_args_size
operator|.
name|constant
argument_list|)
else|:
name|expand_expr
argument_list|(
name|size_diffop
argument_list|(
name|stack_args_size
operator|.
name|var
argument_list|,
name|size_int
argument_list|(
operator|-
name|stack_args_size
operator|.
name|constant
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|current_function_arg_offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|stack_args_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See how many bytes, if any, of its args a function should try to pop      on return.  */
name|current_function_pops_args
operator|=
name|RETURN_POPS_ARGS
argument_list|(
name|fndecl
argument_list|,
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|current_function_args_size
argument_list|)
expr_stmt|;
comment|/* For stdarg.h function, save info about      regs and stack space used by the named args.  */
name|current_function_args_info
operator|=
name|args_so_far
expr_stmt|;
comment|/* Set the rtx used for the function return value.  Put this in its      own variable so any optimizers that need this information don't have      to include tree.h.  Do this here so it gets done when an inlined      function gets output.  */
name|current_function_return_rtx
operator|=
operator|(
name|DECL_RTL_SET_P
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|?
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
else|:
name|NULL_RTX
operator|)
expr_stmt|;
comment|/* If scalar return value was computed in a pseudo-reg, or was a named      return value that got dumped to the stack, copy that to the hard      return register.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|decl_result
init|=
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|rtx
name|decl_rtl
init|=
name|DECL_RTL
argument_list|(
name|decl_result
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|decl_rtl
argument_list|)
condition|?
name|REGNO
argument_list|(
name|decl_rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
else|:
name|DECL_REGISTER
argument_list|(
name|decl_result
argument_list|)
condition|)
block|{
name|rtx
name|real_decl_rtl
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|real_decl_rtl
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|#
directive|else
name|real_decl_rtl
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REG_FUNCTION_VALUE_P
argument_list|(
name|real_decl_rtl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The delay slot scheduler assumes that current_function_return_rtx 	     holds the hard register containing the return value, not a 	     temporary pseudo.  */
name|current_function_return_rtx
operator|=
name|real_decl_rtl
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If ARGS contains entries with complex types, split the entry into two    entries of the component type.  Return a new list of substitutions are    needed, else the old list.  */
end_comment

begin_function
specifier|static
name|tree
name|split_complex_args
parameter_list|(
name|tree
name|args
parameter_list|)
block|{
name|tree
name|p
decl_stmt|;
comment|/* Before allocating memory, check for the common case of no complex.  */
for|for
control|(
name|p
operator|=
name|args
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
argument_list|(
name|type
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
return|return
name|args
return|;
name|found
label|:
name|args
operator|=
name|copy_list
argument_list|(
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|args
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|subtype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Rewrite the PARM_DECL's type with its component.  */
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
operator|=
name|subtype
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|p
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|p
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|p
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|p
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|layout_decl
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Build a second synthetic decl.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Splice it in; skip the new decl.  */
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|decl
expr_stmt|;
name|p
operator|=
name|decl
expr_stmt|;
block|}
block|}
return|return
name|args
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Indicate whether REGNO is an incoming argument to the current function    that was promoted to a wider mode.  If so, return the RTX for the    register (to get its mode).  PMODE and PUNSIGNEDP are set to the mode    that REGNO is promoted from and whether the promotion was signed or    unsigned.  */
end_comment

begin_function
name|rtx
name|promoted_input_arg
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|pmode
parameter_list|,
name|int
modifier|*
name|punsignedp
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|regno
operator|&&
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|mode
operator|=
name|promote_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
name|mode
operator|!=
name|DECL_MODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
operator|*
name|pmode
operator|=
name|DECL_MODE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|unsignedp
expr_stmt|;
return|return
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the size and offset from the start of the stacked arguments for a    parm passed in mode PASSED_MODE and with type TYPE.     INITIAL_OFFSET_PTR points to the current offset into the stacked    arguments.     The starting offset and size for this parm are returned in    LOCATE->OFFSET and LOCATE->SIZE, respectively.  When IN_REGS is    nonzero, the offset is that of stack slot, which is returned in    LOCATE->SLOT_OFFSET.  LOCATE->ALIGNMENT_PAD is the amount of    padding required from the initial offset ptr to the stack slot.     IN_REGS is nonzero if the argument will be passed in registers.  It will    never be set if REG_PARM_STACK_SPACE is not defined.     FNDECL is the function in which the argument was defined.     There are two types of rounding that are done.  The first, controlled by    FUNCTION_ARG_BOUNDARY, forces the offset from the start of the argument    list to be aligned to the specific boundary (in bits).  This rounding    affects the initial and starting offsets, but not the argument size.     The second, controlled by FUNCTION_ARG_PADDING and PARM_BOUNDARY,    optionally rounds the size of the parm to PARM_BOUNDARY.  The    initial offset is not affected by this rounding, while the size always    is and the starting offset may be.  */
end_comment

begin_comment
comment|/*  LOCATE->OFFSET will be negative for ARGS_GROW_DOWNWARD case;     INITIAL_OFFSET_PTR is positive because locate_and_pad_parm's     callers pass in the total size of args so far as     INITIAL_OFFSET_PTR.  LOCATE->SIZE is always positive.  */
end_comment

begin_function
name|void
name|locate_and_pad_parm
parameter_list|(
name|enum
name|machine_mode
name|passed_mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|in_regs
parameter_list|,
name|int
name|partial
parameter_list|,
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|args_size
modifier|*
name|initial_offset_ptr
parameter_list|,
name|struct
name|locate_and_pad_arg_data
modifier|*
name|locate
parameter_list|)
block|{
name|tree
name|sizetree
decl_stmt|;
name|enum
name|direction
name|where_pad
decl_stmt|;
name|int
name|boundary
decl_stmt|;
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
name|int
name|part_size_in_regs
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|MAYBE_REG_PARM_STACK_SPACE
expr_stmt|;
else|#
directive|else
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we have found a stack parm before we reach the end of the      area reserved for registers, skip that area.  */
if|if
condition|(
operator|!
name|in_regs
condition|)
block|{
if|if
condition|(
name|reg_parm_stack_space
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
block|{
name|initial_offset_ptr
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|ARGS_SIZE_TREE
argument_list|(
operator|*
name|initial_offset_ptr
argument_list|)
argument_list|,
name|ssize_int
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
name|initial_offset_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|initial_offset_ptr
operator|->
name|constant
operator|<
name|reg_parm_stack_space
condition|)
name|initial_offset_ptr
operator|->
name|constant
operator|=
name|reg_parm_stack_space
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* REG_PARM_STACK_SPACE */
name|part_size_in_regs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_parm_stack_space
operator|==
literal|0
condition|)
name|part_size_in_regs
operator|=
operator|(
operator|(
name|partial
operator|*
name|UNITS_PER_WORD
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|sizetree
operator|=
name|type
condition|?
name|size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|size_int
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|passed_mode
argument_list|)
argument_list|)
expr_stmt|;
name|where_pad
operator|=
name|FUNCTION_ARG_PADDING
argument_list|(
name|passed_mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|boundary
operator|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|passed_mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|locate
operator|->
name|where_pad
operator|=
name|where_pad
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|locate
operator|->
name|slot_offset
operator|.
name|constant
operator|=
operator|-
name|initial_offset_ptr
operator|->
name|constant
expr_stmt|;
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
name|locate
operator|->
name|slot_offset
operator|.
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|0
argument_list|)
argument_list|,
name|initial_offset_ptr
operator|->
name|var
argument_list|)
expr_stmt|;
block|{
name|tree
name|s2
init|=
name|sizetree
decl_stmt|;
if|if
condition|(
name|where_pad
operator|!=
name|none
operator|&&
operator|(
operator|!
name|host_integerp
argument_list|(
name|sizetree
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|tree_low_cst
argument_list|(
name|sizetree
argument_list|,
literal|1
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
operator|)
condition|)
name|s2
operator|=
name|round_up
argument_list|(
name|s2
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|SUB_PARM_SIZE
argument_list|(
name|locate
operator|->
name|slot_offset
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
name|locate
operator|->
name|slot_offset
operator|.
name|constant
operator|+=
name|part_size_in_regs
expr_stmt|;
if|if
condition|(
operator|!
name|in_regs
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
operator|||
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
operator|>
literal|0
endif|#
directive|endif
condition|)
name|pad_to_arg_alignment
argument_list|(
operator|&
name|locate
operator|->
name|slot_offset
argument_list|,
name|boundary
argument_list|,
operator|&
name|locate
operator|->
name|alignment_pad
argument_list|)
expr_stmt|;
name|locate
operator|->
name|size
operator|.
name|constant
operator|=
operator|(
operator|-
name|initial_offset_ptr
operator|->
name|constant
operator|-
name|locate
operator|->
name|slot_offset
operator|.
name|constant
operator|)
expr_stmt|;
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
name|locate
operator|->
name|size
operator|.
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|0
argument_list|)
argument_list|,
name|initial_offset_ptr
operator|->
name|var
argument_list|)
argument_list|,
name|locate
operator|->
name|slot_offset
operator|.
name|var
argument_list|)
expr_stmt|;
comment|/* Pad_below needs the pre-rounded size to know how much to pad      below.  */
name|locate
operator|->
name|offset
operator|=
name|locate
operator|->
name|slot_offset
expr_stmt|;
if|if
condition|(
name|where_pad
operator|==
name|downward
condition|)
name|pad_below
argument_list|(
operator|&
name|locate
operator|->
name|offset
argument_list|,
name|passed_mode
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !ARGS_GROW_DOWNWARD */
if|if
condition|(
operator|!
name|in_regs
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
operator|||
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
operator|>
literal|0
endif|#
directive|endif
condition|)
name|pad_to_arg_alignment
argument_list|(
name|initial_offset_ptr
argument_list|,
name|boundary
argument_list|,
operator|&
name|locate
operator|->
name|alignment_pad
argument_list|)
expr_stmt|;
name|locate
operator|->
name|slot_offset
operator|=
operator|*
name|initial_offset_ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|passed_mode
operator|!=
name|BLKmode
condition|)
name|sizetree
operator|=
name|size_int
argument_list|(
name|PUSH_ROUNDING
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Pad_below needs the pre-rounded size to know how much to pad below      so this must be done before rounding up.  */
name|locate
operator|->
name|offset
operator|=
name|locate
operator|->
name|slot_offset
expr_stmt|;
if|if
condition|(
name|where_pad
operator|==
name|downward
condition|)
name|pad_below
argument_list|(
operator|&
name|locate
operator|->
name|offset
argument_list|,
name|passed_mode
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
if|if
condition|(
name|where_pad
operator|!=
name|none
operator|&&
operator|(
operator|!
name|host_integerp
argument_list|(
name|sizetree
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|tree_low_cst
argument_list|(
name|sizetree
argument_list|,
literal|1
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
operator|)
condition|)
name|sizetree
operator|=
name|round_up
argument_list|(
name|sizetree
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ADD_PARM_SIZE
argument_list|(
name|locate
operator|->
name|size
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
name|locate
operator|->
name|size
operator|.
name|constant
operator|-=
name|part_size_in_regs
expr_stmt|;
endif|#
directive|endif
comment|/* ARGS_GROW_DOWNWARD */
block|}
end_function

begin_comment
comment|/* Round the stack offset in *OFFSET_PTR up to a multiple of BOUNDARY.    BOUNDARY is measured in bits, but must be a multiple of a storage unit.  */
end_comment

begin_function
specifier|static
name|void
name|pad_to_arg_alignment
parameter_list|(
name|struct
name|args_size
modifier|*
name|offset_ptr
parameter_list|,
name|int
name|boundary
parameter_list|,
name|struct
name|args_size
modifier|*
name|alignment_pad
parameter_list|)
block|{
name|tree
name|save_var
init|=
name|NULL_TREE
decl_stmt|;
name|HOST_WIDE_INT
name|save_constant
init|=
literal|0
decl_stmt|;
name|int
name|boundary_in_bytes
init|=
name|boundary
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|sp_offset
init|=
name|STACK_POINTER_OFFSET
decl_stmt|;
ifdef|#
directive|ifdef
name|SPARC_STACK_BOUNDARY_HACK
comment|/* The sparc port has a bug.  It sometimes claims a STACK_BOUNDARY      higher than the real alignment of %sp.  However, when it does this,      the alignment of %sp+STACK_POINTER_OFFSET will be STACK_BOUNDARY.      This is a temporary hack while the sparc port is fixed.  */
if|if
condition|(
name|SPARC_STACK_BOUNDARY_HACK
condition|)
name|sp_offset
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|boundary
operator|>
name|PARM_BOUNDARY
operator|&&
name|boundary
operator|>
name|STACK_BOUNDARY
condition|)
block|{
name|save_var
operator|=
name|offset_ptr
operator|->
name|var
expr_stmt|;
name|save_constant
operator|=
name|offset_ptr
operator|->
name|constant
expr_stmt|;
block|}
name|alignment_pad
operator|->
name|var
operator|=
name|NULL_TREE
expr_stmt|;
name|alignment_pad
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|boundary
operator|>
name|BITS_PER_UNIT
condition|)
block|{
if|if
condition|(
name|offset_ptr
operator|->
name|var
condition|)
block|{
name|tree
name|sp_offset_tree
init|=
name|ssize_int
argument_list|(
name|sp_offset
argument_list|)
decl_stmt|;
name|tree
name|offset
init|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ARGS_SIZE_TREE
argument_list|(
operator|*
name|offset_ptr
argument_list|)
argument_list|,
name|sp_offset_tree
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|tree
name|rounded
init|=
name|round_down
argument_list|(
name|offset
argument_list|,
name|boundary
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
else|#
directive|else
name|tree
name|rounded
init|=
name|round_up
argument_list|(
name|offset
argument_list|,
name|boundary
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|offset_ptr
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|rounded
argument_list|,
name|sp_offset_tree
argument_list|)
expr_stmt|;
comment|/* ARGS_SIZE_TREE includes constant term.  */
name|offset_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|boundary
operator|>
name|PARM_BOUNDARY
operator|&&
name|boundary
operator|>
name|STACK_BOUNDARY
condition|)
name|alignment_pad
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset_ptr
operator|->
name|var
argument_list|,
name|save_var
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset_ptr
operator|->
name|constant
operator|=
operator|-
name|sp_offset
operator|+
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|FLOOR_ROUND
argument_list|(
name|offset_ptr
operator|->
name|constant
operator|+
name|sp_offset
argument_list|,
name|boundary_in_bytes
argument_list|)
expr_stmt|;
else|#
directive|else
name|CEIL_ROUND
argument_list|(
name|offset_ptr
operator|->
name|constant
operator|+
name|sp_offset
argument_list|,
name|boundary_in_bytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|boundary
operator|>
name|PARM_BOUNDARY
operator|&&
name|boundary
operator|>
name|STACK_BOUNDARY
condition|)
name|alignment_pad
operator|->
name|constant
operator|=
name|offset_ptr
operator|->
name|constant
operator|-
name|save_constant
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pad_below
parameter_list|(
name|struct
name|args_size
modifier|*
name|offset_ptr
parameter_list|,
name|enum
name|machine_mode
name|passed_mode
parameter_list|,
name|tree
name|sizetree
parameter_list|)
block|{
if|if
condition|(
name|passed_mode
operator|!=
name|BLKmode
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|passed_mode
argument_list|)
operator|%
name|PARM_BOUNDARY
condition|)
name|offset_ptr
operator|->
name|constant
operator|+=
operator|(
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|passed_mode
argument_list|)
operator|+
name|PARM_BOUNDARY
operator|-
literal|1
operator|)
operator|/
name|PARM_BOUNDARY
operator|*
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|passed_mode
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sizetree
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
condition|)
block|{
comment|/* Round the size up to multiple of PARM_BOUNDARY bits.  */
name|tree
name|s2
init|=
name|round_up
argument_list|(
name|sizetree
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
comment|/* Add it in.  */
name|ADD_PARM_SIZE
argument_list|(
operator|*
name|offset_ptr
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|SUB_PARM_SIZE
argument_list|(
operator|*
name|offset_ptr
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk the tree of blocks describing the binding levels within a function    and warn about uninitialized variables.    This is done after calling flow_analysis and before global_alloc    clobbers the pseudo-regs to hard regs.  */
end_comment

begin_function
name|void
name|uninitialized_vars_warning
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|sub
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
if|if
condition|(
name|warn_uninitialized
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
comment|/* These warnings are unreliable for and aggregates 	     because assigning the fields one by one can fail to convince 	     flow.c that the entire aggregate was initialized. 	     Unions are troublesome because members may be shorter.  */
operator|&&
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
comment|/* Global optimizations can make it difficult to determine if a 	     particular variable has been initialized.  However, a VAR_DECL 	     with a nonzero DECL_INITIAL had an initializer, so do not 	     claim it is potentially uninitialized.  	     When the DECL_INITIAL is NULL call the language hook to tell us 	     if we want to warn.  */
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|lang_hooks
operator|.
name|decl_uninit
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|regno_uninitialized
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%J'%D' might be used uninitialized in this function"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|regno_clobbered_at_setjmp
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jvariable '%D' might be clobbered by `longjmp' or `vfork'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sub
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|sub
condition|;
name|sub
operator|=
name|TREE_CHAIN
argument_list|(
name|sub
argument_list|)
control|)
name|uninitialized_vars_warning
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do the appropriate part of uninitialized_vars_warning    but for arguments instead of local variables.  */
end_comment

begin_function
name|void
name|setjmp_args_warning
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|regno_clobbered_at_setjmp
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jargument '%D' might be clobbered by `longjmp' or `vfork'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If this function call setjmp, put all vars into the stack    unless they were declared `register'.  */
end_comment

begin_function
name|void
name|setjmp_protect
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|sub
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
operator|)
operator|)
comment|/* If this variable came from an inline function, it must be 	   that its life doesn't overlap the setjmp.  If there was a 	   setjmp in the function, it would already be in memory.  We 	   must exclude such variable because their DECL_RTL might be 	   set to strange things such as virtual_stack_vars_rtx.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
comment|/* If longjmp doesn't restore the registers, 	       don't put anything in them.  */
name|NON_SAVING_SETJMP
operator|||
endif|#
directive|endif
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|put_var_into_stack
argument_list|(
name|decl
argument_list|,
comment|/*rescan=*/
name|true
argument_list|)
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|sub
condition|;
name|sub
operator|=
name|TREE_CHAIN
argument_list|(
name|sub
argument_list|)
control|)
name|setjmp_protect
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like the previous function, but for args instead of local variables.  */
end_comment

begin_function
name|void
name|setjmp_protect_args
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
operator|)
operator|)
operator|&&
operator|(
comment|/* If longjmp doesn't restore the registers, 	       don't put anything in them.  */
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
name|NON_SAVING_SETJMP
operator|||
endif|#
directive|endif
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|put_var_into_stack
argument_list|(
name|decl
argument_list|,
comment|/*rescan=*/
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the context-pointer register corresponding to DECL,    or 0 if it does not need one.  */
end_comment

begin_function
name|rtx
name|lookup_static_chain
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|link
decl_stmt|;
if|if
condition|(
name|context
operator|==
literal|0
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* We treat inline_function_decl as an alias for the current function      because that is the inline function whose vars, types, etc.      are being merged into the current function.      See expand_inline_function.  */
if|if
condition|(
name|context
operator|==
name|current_function_decl
operator|||
name|context
operator|==
name|inline_function_decl
condition|)
return|return
name|virtual_stack_vars_rtx
return|;
for|for
control|(
name|link
operator|=
name|context_display
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|context
condition|)
return|return
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a stack slot address ADDR for variable VAR    (from a containing function)    into an address valid in this function (using a static chain).  */
end_comment

begin_function
name|rtx
name|fix_lexical_addr
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|rtx
name|basereg
decl_stmt|;
name|HOST_WIDE_INT
name|displacement
decl_stmt|;
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|struct
name|function
modifier|*
name|fp
decl_stmt|;
name|rtx
name|base
init|=
literal|0
decl_stmt|;
comment|/* If this is the present function, we need not do anything.  */
if|if
condition|(
name|context
operator|==
name|current_function_decl
operator|||
name|context
operator|==
name|inline_function_decl
condition|)
return|return
name|addr
return|;
name|fp
operator|=
name|find_function_data
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Decode given address as base reg plus displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|addr
operator|,
name|displacement
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|basereg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|,
name|displacement
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* We accept vars reached via the containing function's      incoming arg pointer and via its stack variables pointer.  */
if|if
condition|(
name|basereg
operator|==
name|fp
operator|->
name|internal_arg_pointer
condition|)
block|{
comment|/* If reached via arg pointer, get the arg pointer value 	 out of that function's stack frame.  	 There are two cases:  If a separate ap is needed, allocate a 	 slot in the outer function for it and dereference it that way. 	 This is correct even if the real ap is actually a pseudo. 	 Otherwise, just adjust the offset from the frame pointer to 	 compensate.  */
ifdef|#
directive|ifdef
name|NEED_SEPARATE_AP
name|rtx
name|addr
decl_stmt|;
name|addr
operator|=
name|get_arg_pointer_save_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|base
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|base
operator|=
name|copy_to_reg
argument_list|(
name|base
argument_list|)
expr_stmt|;
else|#
directive|else
name|displacement
operator|+=
operator|(
name|FIRST_PARM_OFFSET
argument_list|(
name|context
argument_list|)
operator|-
name|STARTING_FRAME_OFFSET
operator|)
expr_stmt|;
name|base
operator|=
name|lookup_static_chain
argument_list|(
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|basereg
operator|==
name|virtual_stack_vars_rtx
condition|)
block|{
comment|/* This is the same code as lookup_static_chain, duplicated here to 	 avoid an extra call to decl_function_context.  */
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|context_display
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|context
condition|)
block|{
name|base
operator|=
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Use same offset, relative to appropriate static chain or argument      pointer.  */
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|displacement
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the address of the trampoline for entering nested fn FUNCTION.    If necessary, allocate a trampoline (in the stack frame)    and emit rtl to initialize its contents (at entry to this function).  */
end_comment

begin_function
name|rtx
name|trampoline_address
parameter_list|(
name|tree
name|function
parameter_list|)
block|{
name|tree
name|link
decl_stmt|;
name|tree
name|rtlexp
decl_stmt|;
name|rtx
name|tramp
decl_stmt|;
name|struct
name|function
modifier|*
name|fp
decl_stmt|;
name|tree
name|fn_context
decl_stmt|;
comment|/* Find an existing trampoline and return it.  */
for|for
control|(
name|link
operator|=
name|trampoline_list
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|function
condition|)
return|return
name|adjust_trampoline_addr
argument_list|(
name|XEXP
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
for|for
control|(
name|fp
operator|=
name|outer_function_chain
init|;
name|fp
condition|;
name|fp
operator|=
name|fp
operator|->
name|outer
control|)
for|for
control|(
name|link
operator|=
name|fp
operator|->
name|x_trampoline_list
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|function
condition|)
block|{
name|tramp
operator|=
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|adjust_trampoline_addr
argument_list|(
name|tramp
argument_list|)
return|;
block|}
comment|/* None exists; we must make one.  */
comment|/* Find the `struct function' for the function containing FUNCTION.  */
name|fp
operator|=
literal|0
expr_stmt|;
name|fn_context
operator|=
name|decl_function_context
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_context
operator|!=
name|current_function_decl
operator|&&
name|fn_context
operator|!=
name|inline_function_decl
condition|)
name|fp
operator|=
name|find_function_data
argument_list|(
name|fn_context
argument_list|)
expr_stmt|;
comment|/* Allocate run-time space for this trampoline.  */
comment|/* If rounding needed, allocate extra space      to ensure we have TRAMPOLINE_SIZE bytes left after rounding up.  */
define|#
directive|define
name|TRAMPOLINE_REAL_SIZE
define|\
value|(TRAMPOLINE_SIZE + (TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT) - 1)
name|tramp
operator|=
name|assign_stack_local_1
argument_list|(
name|BLKmode
argument_list|,
name|TRAMPOLINE_REAL_SIZE
argument_list|,
literal|0
argument_list|,
name|fp
condition|?
name|fp
else|:
name|cfun
argument_list|)
expr_stmt|;
comment|/* Record the trampoline for reuse and note it for later initialization      by expand_function_end.  */
if|if
condition|(
name|fp
operator|!=
literal|0
condition|)
block|{
name|rtlexp
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|rtlexp
argument_list|)
operator|=
name|tramp
expr_stmt|;
name|fp
operator|->
name|x_trampoline_list
operator|=
name|tree_cons
argument_list|(
name|function
argument_list|,
name|rtlexp
argument_list|,
name|fp
operator|->
name|x_trampoline_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make the RTL_EXPR node temporary, not momentary, so that the 	 trampoline_list doesn't become garbage.  */
name|rtlexp
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|rtlexp
argument_list|)
operator|=
name|tramp
expr_stmt|;
name|trampoline_list
operator|=
name|tree_cons
argument_list|(
name|function
argument_list|,
name|rtlexp
argument_list|,
name|trampoline_list
argument_list|)
expr_stmt|;
block|}
name|tramp
operator|=
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|tramp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|adjust_trampoline_addr
argument_list|(
name|tramp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a trampoline address,    round it to multiple of TRAMPOLINE_ALIGNMENT.  */
end_comment

begin_function
specifier|static
name|rtx
name|round_trampoline_addr
parameter_list|(
name|rtx
name|tramp
parameter_list|)
block|{
comment|/* Round address up to desired boundary.  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|addend
init|=
name|GEN_INT
argument_list|(
name|TRAMPOLINE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|mask
init|=
name|GEN_INT
argument_list|(
operator|-
name|TRAMPOLINE_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
name|temp
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|tramp
argument_list|,
name|addend
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|tramp
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|AND
argument_list|,
name|temp
argument_list|,
name|mask
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|tramp
return|;
block|}
end_function

begin_comment
comment|/* Given a trampoline address, round it then apply any    platform-specific adjustments so that the result can be used for a    function call .  */
end_comment

begin_function
specifier|static
name|rtx
name|adjust_trampoline_addr
parameter_list|(
name|rtx
name|tramp
parameter_list|)
block|{
name|tramp
operator|=
name|round_trampoline_addr
argument_list|(
name|tramp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRAMPOLINE_ADJUST_ADDRESS
name|TRAMPOLINE_ADJUST_ADDRESS
argument_list|(
name|tramp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tramp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Put all this function's BLOCK nodes including those that are chained    onto the first block into a vector, and return it.    Also store in each NOTE for the beginning or end of a block    the index of that block in the vector.    The arguments are BLOCK, the chain of top-level blocks of the function,    and INSNS, the insn chain of the function.  */
end_comment

begin_function
name|void
name|identify_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n_blocks
decl_stmt|;
name|tree
modifier|*
name|block_vector
decl_stmt|,
modifier|*
name|last_block_vector
decl_stmt|;
name|tree
modifier|*
name|block_stack
decl_stmt|;
name|tree
name|block
init|=
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|0
condition|)
return|return;
comment|/* Fill the BLOCK_VECTOR with all of the BLOCKs in this function, in      depth-first order.  */
name|block_vector
operator|=
name|get_block_vector
argument_list|(
name|block
argument_list|,
operator|&
name|n_blocks
argument_list|)
expr_stmt|;
name|block_stack
operator|=
name|xmalloc
argument_list|(
name|n_blocks
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|last_block_vector
operator|=
name|identify_blocks_1
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|block_vector
operator|+
literal|1
argument_list|,
name|block_vector
operator|+
name|n_blocks
argument_list|,
name|block_stack
argument_list|)
expr_stmt|;
comment|/* If we didn't use all of the subblocks, we've misplaced block notes.  */
comment|/* ??? This appears to happen all the time.  Latent bugs elsewhere?  */
if|if
condition|(
literal|0
operator|&&
name|last_block_vector
operator|!=
name|block_vector
operator|+
name|n_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|block_vector
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|block_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of identify_blocks.  Do the block substitution on the    insn chain beginning with INSNS.  Recurse for CALL_PLACEHOLDER chains.     BLOCK_STACK is pushed and popped for each BLOCK_BEGIN/BLOCK_END pair.    BLOCK_VECTOR is incremented for each block seen.  */
end_comment

begin_function
specifier|static
name|tree
modifier|*
name|identify_blocks_1
parameter_list|(
name|rtx
name|insns
parameter_list|,
name|tree
modifier|*
name|block_vector
parameter_list|,
name|tree
modifier|*
name|end_block_vector
parameter_list|,
name|tree
modifier|*
name|orig_block_stack
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|tree
modifier|*
name|block_stack
init|=
name|orig_block_stack
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
block|{
name|tree
name|b
decl_stmt|;
comment|/* If there are more block notes than BLOCKs, something 		 is badly wrong.  */
if|if
condition|(
name|block_vector
operator|==
name|end_block_vector
condition|)
name|abort
argument_list|()
expr_stmt|;
name|b
operator|=
operator|*
name|block_vector
operator|++
expr_stmt|;
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
operator|=
name|b
expr_stmt|;
operator|*
name|block_stack
operator|++
operator|=
name|b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
condition|)
block|{
comment|/* If there are more NOTE_INSN_BLOCK_ENDs than 		 NOTE_INSN_BLOCK_BEGs, something is badly wrong.  */
if|if
condition|(
name|block_stack
operator|==
name|orig_block_stack
condition|)
name|abort
argument_list|()
expr_stmt|;
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
operator|=
operator|*
operator|--
name|block_stack
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
name|rtx
name|cp
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|block_vector
operator|=
name|identify_blocks_1
argument_list|(
name|XEXP
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|block_vector
argument_list|,
name|end_block_vector
argument_list|,
name|block_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
condition|)
name|block_vector
operator|=
name|identify_blocks_1
argument_list|(
name|XEXP
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|block_vector
argument_list|,
name|end_block_vector
argument_list|,
name|block_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
condition|)
name|block_vector
operator|=
name|identify_blocks_1
argument_list|(
name|XEXP
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|block_vector
argument_list|,
name|end_block_vector
argument_list|,
name|block_stack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there are more NOTE_INSN_BLOCK_BEGINs than NOTE_INSN_BLOCK_ENDs,      something is badly wrong.  */
if|if
condition|(
name|block_stack
operator|!=
name|orig_block_stack
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|block_vector
return|;
block|}
end_function

begin_comment
comment|/* Identify BLOCKs referenced by more than one NOTE_INSN_BLOCK_{BEG,END},    and create duplicate blocks.  */
end_comment

begin_comment
comment|/* ??? Need an option to either create block fragments or to create    abstract origin duplicates of a source block.  It really depends    on what optimization has been performed.  */
end_comment

begin_function
name|void
name|reorder_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|block
init|=
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|varray_type
name|block_stack
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL_TREE
condition|)
return|return;
name|VARRAY_TREE_INIT
argument_list|(
name|block_stack
argument_list|,
literal|10
argument_list|,
literal|"block_stack"
argument_list|)
expr_stmt|;
comment|/* Reset the TREE_ASM_WRITTEN bit for all blocks.  */
name|reorder_blocks_0
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|/* Prune the old trees away, so that they don't get in the way.  */
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Recreate the block tree from the note nesting.  */
name|reorder_blocks_1
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|block
argument_list|,
operator|&
name|block_stack
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|blocks_nreverse
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove deleted blocks from the block fragment chains.  */
name|reorder_fix_fragments
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for reorder_blocks.  Reset TREE_ASM_WRITTEN.  */
end_comment

begin_function
specifier|static
name|void
name|reorder_blocks_0
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
while|while
condition|(
name|block
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|reorder_blocks_0
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|reorder_blocks_1
parameter_list|(
name|rtx
name|insns
parameter_list|,
name|tree
name|current_block
parameter_list|,
name|varray_type
modifier|*
name|p_block_stack
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
block|{
name|tree
name|block
init|=
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If we have seen this block before, that means it now 		 spans multiple address regions.  Create a new fragment.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|tree
name|new_block
init|=
name|copy_node
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|tree
name|origin
decl_stmt|;
name|origin
operator|=
operator|(
name|BLOCK_FRAGMENT_ORIGIN
argument_list|(
name|block
argument_list|)
condition|?
name|BLOCK_FRAGMENT_ORIGIN
argument_list|(
name|block
argument_list|)
else|:
name|block
operator|)
expr_stmt|;
name|BLOCK_FRAGMENT_ORIGIN
argument_list|(
name|new_block
argument_list|)
operator|=
name|origin
expr_stmt|;
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|new_block
argument_list|)
operator|=
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|origin
argument_list|)
expr_stmt|;
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|origin
argument_list|)
operator|=
name|new_block
expr_stmt|;
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
operator|=
name|new_block
expr_stmt|;
name|block
operator|=
name|new_block
expr_stmt|;
block|}
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* When there's only one block for the entire function, 		 current_block == block and we mustn't do this, it 		 will cause infinite recursion.  */
if|if
condition|(
name|block
operator|!=
name|current_block
condition|)
block|{
name|BLOCK_SUPERCONTEXT
argument_list|(
name|block
argument_list|)
operator|=
name|current_block
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
operator|=
name|block
expr_stmt|;
name|current_block
operator|=
name|block
expr_stmt|;
block|}
name|VARRAY_PUSH_TREE
argument_list|(
operator|*
name|p_block_stack
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
condition|)
block|{
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
operator|=
name|VARRAY_TOP_TREE
argument_list|(
operator|*
name|p_block_stack
argument_list|)
expr_stmt|;
name|VARRAY_POP
argument_list|(
operator|*
name|p_block_stack
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
operator|=
name|blocks_nreverse
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
argument_list|)
expr_stmt|;
name|current_block
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|current_block
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
name|rtx
name|cp
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|reorder_blocks_1
argument_list|(
name|XEXP
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|current_block
argument_list|,
name|p_block_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
condition|)
name|reorder_blocks_1
argument_list|(
name|XEXP
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|current_block
argument_list|,
name|p_block_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
condition|)
name|reorder_blocks_1
argument_list|(
name|XEXP
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|current_block
argument_list|,
name|p_block_stack
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Rationalize BLOCK_FRAGMENT_ORIGIN.  If an origin block no longer    appears in the block tree, select one of the fragments to become    the new origin block.  */
end_comment

begin_function
specifier|static
name|void
name|reorder_fix_fragments
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
while|while
condition|(
name|block
condition|)
block|{
name|tree
name|dup_origin
init|=
name|BLOCK_FRAGMENT_ORIGIN
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|tree
name|new_origin
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|dup_origin
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|dup_origin
argument_list|)
condition|)
block|{
name|new_origin
operator|=
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|dup_origin
argument_list|)
expr_stmt|;
comment|/* Find the first of the remaining fragments.  There must 		 be at least one -- the current block.  */
while|while
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|new_origin
argument_list|)
condition|)
name|new_origin
operator|=
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|new_origin
argument_list|)
expr_stmt|;
name|BLOCK_FRAGMENT_ORIGIN
argument_list|(
name|new_origin
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|dup_origin
condition|)
name|new_origin
operator|=
name|block
expr_stmt|;
comment|/* Re-root the rest of the fragments to the new origin.  In the 	 case that DUP_ORIGIN was null, that means BLOCK was the origin 	 of a chain of fragments and we want to remove those fragments 	 that didn't make it to the output.  */
if|if
condition|(
name|new_origin
condition|)
block|{
name|tree
modifier|*
name|pp
init|=
operator|&
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|new_origin
argument_list|)
decl_stmt|;
name|tree
name|chain
init|=
operator|*
name|pp
decl_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|BLOCK_FRAGMENT_ORIGIN
argument_list|(
name|chain
argument_list|)
operator|=
name|new_origin
expr_stmt|;
operator|*
name|pp
operator|=
name|chain
expr_stmt|;
name|pp
operator|=
operator|&
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|reorder_fix_fragments
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reverse the order of elements in the chain T of blocks,    and return the new head of the chain (old last element).  */
end_comment

begin_function
specifier|static
name|tree
name|blocks_nreverse
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|decl
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|t
init|;
name|decl
condition|;
name|decl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|BLOCK_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|decl
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Count the subblocks of the list starting with BLOCK.  If VECTOR is    non-NULL, list them all into VECTOR, in a depth-first preorder    traversal of the block tree.  Also clear TREE_ASM_WRITTEN in all    blocks.  */
end_comment

begin_function
specifier|static
name|int
name|all_blocks
parameter_list|(
name|tree
name|block
parameter_list|,
name|tree
modifier|*
name|vector
parameter_list|)
block|{
name|int
name|n_blocks
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|block
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Record this block.  */
if|if
condition|(
name|vector
condition|)
name|vector
index|[
name|n_blocks
index|]
operator|=
name|block
expr_stmt|;
operator|++
name|n_blocks
expr_stmt|;
comment|/* Record the subblocks, and their subblocks...  */
name|n_blocks
operator|+=
name|all_blocks
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|vector
condition|?
name|vector
operator|+
name|n_blocks
else|:
literal|0
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
return|return
name|n_blocks
return|;
block|}
end_function

begin_comment
comment|/* Return a vector containing all the blocks rooted at BLOCK.  The    number of elements in the vector is stored in N_BLOCKS_P.  The    vector is dynamically allocated; it is the caller's responsibility    to call `free' on the pointer returned.  */
end_comment

begin_function
specifier|static
name|tree
modifier|*
name|get_block_vector
parameter_list|(
name|tree
name|block
parameter_list|,
name|int
modifier|*
name|n_blocks_p
parameter_list|)
block|{
name|tree
modifier|*
name|block_vector
decl_stmt|;
operator|*
name|n_blocks_p
operator|=
name|all_blocks
argument_list|(
name|block
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|block_vector
operator|=
name|xmalloc
argument_list|(
operator|*
name|n_blocks_p
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|all_blocks
argument_list|(
name|block
argument_list|,
name|block_vector
argument_list|)
expr_stmt|;
return|return
name|block_vector
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|next_block_index
operator|=
literal|2
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set BLOCK_NUMBER for all the blocks in FN.  */
end_comment

begin_function
name|void
name|number_blocks
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_blocks
decl_stmt|;
name|tree
modifier|*
name|block_vector
decl_stmt|;
comment|/* For SDB and XCOFF debugging output, we start numbering the blocks      from 1 within each function, rather than keeping a running      count.  */
if|#
directive|if
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|next_block_index
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|block_vector
operator|=
name|get_block_vector
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
argument_list|,
operator|&
name|n_blocks
argument_list|)
expr_stmt|;
comment|/* The top-level BLOCK isn't numbered at all.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_blocks
condition|;
operator|++
name|i
control|)
comment|/* We number the blocks from two.  */
name|BLOCK_NUMBER
argument_list|(
name|block_vector
index|[
name|i
index|]
argument_list|)
operator|=
name|next_block_index
operator|++
expr_stmt|;
name|free
argument_list|(
name|block_vector
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* If VAR is present in a subblock of BLOCK, return the subblock.  */
end_comment

begin_function
name|tree
name|debug_find_var_in_block_tree
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|block
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|t
operator|==
name|var
condition|)
return|return
name|block
return|;
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|ret
init|=
name|debug_find_var_in_block_tree
argument_list|(
name|var
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a function structure for FNDECL and set its contents    to the defaults.  */
end_comment

begin_function
name|void
name|allocate_struct_function
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|cfun
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|max_parm_reg
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
expr_stmt|;
name|cfun
operator|->
name|stack_alignment_needed
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|cfun
operator|->
name|preferred_stack_boundary
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|current_function_funcdef_no
operator|=
name|funcdef_no
operator|++
expr_stmt|;
name|cfun
operator|->
name|function_frequency
operator|=
name|FUNCTION_FREQUENCY_NORMAL
expr_stmt|;
name|init_stmt_for_function
argument_list|()
expr_stmt|;
name|init_eh_for_function
argument_list|()
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|function
operator|.
name|init
call|)
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_machine_status
condition|)
name|cfun
operator|->
name|machine
operator|=
call|(
modifier|*
name|init_machine_status
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|NULL
condition|)
return|return;
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|cfun
expr_stmt|;
name|cfun
operator|->
name|decl
operator|=
name|fndecl
expr_stmt|;
name|result
operator|=
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|result
argument_list|,
name|fndecl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
name|current_function_returns_pcc_struct
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|current_function_returns_struct
operator|=
literal|1
expr_stmt|;
block|}
name|current_function_returns_pointer
operator|=
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_needs_context
operator|=
operator|(
name|decl_function_context
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|current_function_decl
argument_list|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset cfun, and other non-struct-function variables to defaults as    appropriate for emitting rtl at the start of a function.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_function_start
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
if|if
condition|(
name|fndecl
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
condition|)
name|cfun
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|allocate_struct_function
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|init_emit
argument_list|()
expr_stmt|;
name|init_varasm_status
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|init_expr
argument_list|()
expr_stmt|;
name|cse_not_expected
operator|=
operator|!
name|optimize
expr_stmt|;
comment|/* Caller save not needed yet.  */
name|caller_save_needed
operator|=
literal|0
expr_stmt|;
comment|/* We haven't done register allocation yet.  */
name|reg_renumber
operator|=
literal|0
expr_stmt|;
comment|/* Indicate that we need to distinguish between the return value of the      present function and the return value of a function being called.  */
name|rtx_equal_function_value_matters
operator|=
literal|1
expr_stmt|;
comment|/* Indicate that we have not instantiated virtual registers yet.  */
name|virtuals_instantiated
operator|=
literal|0
expr_stmt|;
comment|/* Indicate that we want CONCATs now.  */
name|generating_concat_p
operator|=
literal|1
expr_stmt|;
comment|/* Indicate we have no need of a frame pointer yet.  */
name|frame_pointer_needed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the rtl expansion mechanism so that we can do simple things    like generate sequences.  This is used to provide a context during global    initialization of some passes.  */
end_comment

begin_function
name|void
name|init_dummy_function_start
parameter_list|(
name|void
parameter_list|)
block|{
name|prepare_function_start
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the start of the function SUBR (a FUNCTION_DECL tree node)    and initialize static variables for generating RTL for the statements    of the function.  */
end_comment

begin_function
name|void
name|init_function_start
parameter_list|(
name|tree
name|subr
parameter_list|)
block|{
name|prepare_function_start
argument_list|(
name|subr
argument_list|)
expr_stmt|;
comment|/* Within function body, compute a type's size as soon it is laid out.  */
name|immediate_size_expand
operator|++
expr_stmt|;
comment|/* Prevent ever trying to delete the first instruction of a      function.  Also tell final how to output a linenum before the      function prologue.  Note linenums could be missing, e.g. when      compiling a Java .class file.  */
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|subr
argument_list|)
condition|)
name|emit_line_note
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|subr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure first insn is a note even if we don't want linenums.      This makes sure the first insn will never be deleted.      Also, final expects a note to appear there.  */
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Warn if this value is an aggregate type,      regardless of which calling convention we are using for it.  */
if|if
condition|(
name|warn_aggregate_return
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function returns an aggregate"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure all values used by the optimization passes have sane    defaults.  */
end_comment

begin_function
name|void
name|init_function_for_compilation
parameter_list|(
name|void
parameter_list|)
block|{
name|reg_renumber
operator|=
literal|0
expr_stmt|;
comment|/* No prologue/epilogue insns yet.  */
name|VARRAY_GROW
argument_list|(
name|prologue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|epilogue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|sibcall_epilogue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a call to __main at the beginning of a possible main function.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INIT_SECTION_ASM_OP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|INVOKE__main
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|HAS_INIT_SECTION
end_undef

begin_define
define|#
directive|define
name|HAS_INIT_SECTION
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|expand_main_function
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN
if|if
condition|(
name|FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN
condition|)
block|{
name|int
name|align
init|=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Forcibly align the stack.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|AND
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|align
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
else|#
directive|else
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|align
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|AND
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|align
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tmp
operator|!=
name|stack_pointer_rtx
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Enlist allocate_dynamic_stack_space to pick up the pieces.  */
name|tmp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|allocate_dynamic_stack_space
argument_list|(
name|tmp
argument_list|,
name|NULL_RTX
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|get_last_insn
argument_list|()
init|;
name|tmp
condition|;
name|tmp
operator|=
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|tmp
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
break|break;
if|if
condition|(
name|tmp
condition|)
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|HAS_INIT_SECTION
name|emit_library_call
argument_list|(
name|init_one_libfunc
argument_list|(
name|NAME__MAIN
argument_list|)
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The PENDING_SIZES represent the sizes of variable-sized types.    Create RTL for the various sizes now (using temporary variables),    so that we can refer to the sizes from the RTL we are generating    for the current function.  The PENDING_SIZES are a TREE_LIST.  The    TREE_VALUE of each node is a SAVE_EXPR.  */
end_comment

begin_function
name|void
name|expand_pending_sizes
parameter_list|(
name|tree
name|pending_sizes
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
comment|/* Evaluate now the sizes of any types declared among the arguments.  */
for|for
control|(
name|tem
operator|=
name|pending_sizes
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
block|{
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Flush the queue in case this parameter declaration has 	 side-effects.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Start the RTL for a new function, and set variables used for    emitting RTL.    SUBR is the FUNCTION_DECL node.    PARMS_HAVE_CLEANUPS is nonzero if there are cleanups associated with    the function's parameters, which must be run at any return statement.  */
end_comment

begin_function
name|void
name|expand_function_start
parameter_list|(
name|tree
name|subr
parameter_list|,
name|int
name|parms_have_cleanups
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
name|rtx
name|last_ptr
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Make sure volatile mem refs aren't considered      valid operands of arithmetic insns.  */
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
name|current_function_instrument_entry_exit
operator|=
operator|(
name|flag_instrument_function_entry_exit
operator|&&
operator|!
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|subr
argument_list|)
operator|)
expr_stmt|;
name|current_function_profile
operator|=
operator|(
name|profile_flag
operator|&&
operator|!
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|subr
argument_list|)
operator|)
expr_stmt|;
name|current_function_limit_stack
operator|=
operator|(
name|stack_limit_rtx
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|DECL_NO_LIMIT_STACK
argument_list|(
name|subr
argument_list|)
operator|)
expr_stmt|;
comment|/* If function gets a static chain arg, store it in the stack frame.      Do this first, so it gets the first stack slot offset.  */
if|if
condition|(
name|current_function_needs_context
condition|)
block|{
name|last_ptr
operator|=
name|assign_stack_local
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Delay copying static chain if it is not a register to avoid 	 conflicts with regs used for parameters.  */
if|if
condition|(
operator|!
name|SMALL_REGISTER_CLASSES
operator|||
name|GET_CODE
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
operator|==
name|REG
condition|)
name|emit_move_insn
argument_list|(
name|last_ptr
argument_list|,
name|static_chain_incoming_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* If the parameters of this function need cleaning up, get a label      for the beginning of the code which executes those cleanups.  This must      be done before doing anything with return_label.  */
if|if
condition|(
name|parms_have_cleanups
condition|)
name|cleanup_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
else|else
name|cleanup_label
operator|=
literal|0
expr_stmt|;
comment|/* Make the label for return statements to jump to.  Do not special      case machines with special return instructions -- they will be      handled later during jump, ifcvt, or epilogue creation.  */
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Initialize rtx used to return the value.  */
comment|/* Do this before assign_parms so that we copy the struct value address      before any library calls that assign parms might generate.  */
comment|/* Decide whether to return the value in memory or in a register.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
name|subr
argument_list|)
condition|)
block|{
comment|/* Returning something that won't go in a register.  */
name|rtx
name|value_address
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
if|if
condition|(
name|current_function_returns_pcc_struct
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|value_address
operator|=
name|assemble_static_space
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|rtx
name|sv
init|=
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|TREE_TYPE
argument_list|(
name|subr
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Expect to be passed the address of a place to store the value. 	     If it is passed as an argument, assign_parms will take care of 	     it.  */
if|if
condition|(
name|sv
condition|)
block|{
name|value_address
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|value_address
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value_address
condition|)
block|{
name|rtx
name|x
init|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|value_address
argument_list|)
decl_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
comment|/* If return mode is void, this decl rtl should not be used.  */
name|SET_DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Compute the return values into a pseudo reg, which we will copy 	 into the true return register after the cleanups are done.  */
comment|/* In order to figure out what mode to use for the pseudo, we 	 figure out what the mode of the eventual return register will 	 actually be, and use that.  */
name|rtx
name|hard_reg
init|=
name|hard_function_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|subr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Structures that are returned in registers are not aggregate_value_p, 	 so we may see a PARALLEL or a REG.  */
if|if
condition|(
name|REG_P
argument_list|(
name|hard_reg
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|hard_reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|hard_reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|SET_DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
name|gen_group_rtx
argument_list|(
name|hard_reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Set DECL_REGISTER flag so that expand_function_end will copy the 	 result to the real return register(s).  */
name|DECL_REGISTER
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Initialize rtx for parameters and local variables.      In some cases this requires emitting insns.  */
name|assign_parms
argument_list|(
name|subr
argument_list|)
expr_stmt|;
comment|/* Copy the static chain now if it wasn't a register.  The delay is to      avoid conflicts with the parameter passing registers.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|current_function_needs_context
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
operator|!=
name|REG
condition|)
name|emit_move_insn
argument_list|(
name|last_ptr
argument_list|,
name|static_chain_incoming_rtx
argument_list|)
expr_stmt|;
comment|/* The following was moved from init_function_start.      The move is supposed to make sdb output more accurate.  */
comment|/* Indicate the beginning of the function body,      as opposed to parm setup.  */
name|emit_note
argument_list|(
name|NOTE_INSN_FUNCTION_BEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|NOTE
condition|)
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|parm_birth_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|context_display
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_function_needs_context
condition|)
block|{
comment|/* Fetch static chain values for containing functions.  */
name|tem
operator|=
name|decl_function_context
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* Copy the static chain pointer into a pseudo.  If we have 	 small register classes, copy the value from memory if 	 static_chain_incoming_rtx is a REG.  */
if|if
condition|(
name|tem
condition|)
block|{
comment|/* If the static chain originally came in a register, put it back 	     there, then move it out in the next insn.  The reason for 	     this peculiar code is to satisfy function integration.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|GET_CODE
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
operator|==
name|REG
condition|)
name|emit_move_insn
argument_list|(
name|static_chain_incoming_rtx
argument_list|,
name|last_ptr
argument_list|)
expr_stmt|;
name|last_ptr
operator|=
name|copy_to_reg
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|tem
condition|)
block|{
name|tree
name|rtlexp
init|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
decl_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|rtlexp
argument_list|)
operator|=
name|last_ptr
expr_stmt|;
name|context_display
operator|=
name|tree_cons
argument_list|(
name|tem
argument_list|,
name|rtlexp
argument_list|,
name|context_display
argument_list|)
expr_stmt|;
name|tem
operator|=
name|decl_function_context
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
break|break;
comment|/* Chain through stack frames, assuming pointer to next lexical frame 	     is found at the place we always store it.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|last_ptr
operator|=
name|plus_constant
argument_list|(
name|last_ptr
argument_list|,
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|last_ptr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|last_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|last_ptr
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|last_ptr
operator|=
name|copy_to_reg
argument_list|(
name|last_ptr
argument_list|)
expr_stmt|;
comment|/* If we are not optimizing, ensure that we know that this 	     piece of context is live over the entire function.  */
if|if
condition|(
operator|!
name|optimize
condition|)
name|save_expr_regs
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|last_ptr
argument_list|,
name|save_expr_regs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_function_instrument_entry_exit
condition|)
block|{
name|rtx
name|fun
init|=
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|fun
argument_list|)
operator|==
name|MEM
condition|)
name|fun
operator|=
name|XEXP
argument_list|(
name|fun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|emit_library_call
argument_list|(
name|profile_function_entry_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|2
argument_list|,
name|fun
argument_list|,
name|Pmode
argument_list|,
name|expand_builtin_return_addr
argument_list|(
name|BUILT_IN_RETURN_ADDRESS
argument_list|,
literal|0
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_profile
condition|)
block|{
ifdef|#
directive|ifdef
name|PROFILE_HOOK
name|PROFILE_HOOK
argument_list|(
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* After the display initializations is where the tail-recursion label      should go, if we end up needing one.   Ensure we have a NOTE here      since some things (like trampolines) get placed before this.  */
name|tail_recursion_reentry
operator|=
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Evaluate now the sizes of any types declared among the arguments.  */
name|expand_pending_sizes
argument_list|(
name|nreverse
argument_list|(
name|get_pending_sizes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure there is a line number after the function entry setup code.  */
name|force_next_line_note
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Undo the effects of init_dummy_function_start.  */
end_comment

begin_function
name|void
name|expand_dummy_function_end
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* End any sequences that failed to be closed due to syntax errors.  */
while|while
condition|(
name|in_sequence_p
argument_list|()
condition|)
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Outside function body, can't compute type's actual size      until next function's body starts.  */
name|free_after_parsing
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|free_after_compilation
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|cfun
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call DOIT for each hard register used as a return value from    the current function.  */
end_comment

begin_function
name|void
name|diddle_return_value
parameter_list|(
name|void
function_decl|(
modifier|*
name|doit
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rtx
name|outgoing
init|=
name|current_function_return_rtx
decl_stmt|;
if|if
condition|(
operator|!
name|outgoing
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|outgoing
argument_list|)
operator|==
name|REG
condition|)
call|(
modifier|*
name|doit
call|)
argument_list|(
name|outgoing
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|outgoing
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|outgoing
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|outgoing
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
call|(
modifier|*
name|doit
call|)
argument_list|(
name|x
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_clobber_return_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|void
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clobber_return_register
parameter_list|(
name|void
parameter_list|)
block|{
name|diddle_return_value
argument_list|(
name|do_clobber_return_reg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* In case we do use pseudo to return value, clobber it too.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|decl_result
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|rtx
name|decl_rtl
init|=
name|DECL_RTL
argument_list|(
name|decl_result
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|decl_rtl
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|decl_rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|do_clobber_return_reg
argument_list|(
name|decl_rtl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_use_return_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|void
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|use_return_register
parameter_list|(
name|void
parameter_list|)
block|{
name|diddle_return_value
argument_list|(
name|do_use_return_reg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Possibly warn about unused parameters.  */
end_comment

begin_function
name|void
name|do_warn_unused_parameter
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Junused parameter '%D'"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|initial_trampoline
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Generate RTL for the end of the current function.  */
end_comment

begin_function
name|void
name|expand_function_end
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|link
decl_stmt|;
name|rtx
name|clobber_after
decl_stmt|;
name|finish_expr_for_function
argument_list|()
expr_stmt|;
comment|/* If arg_pointer_save_area was referenced only from a nested      function, we will not have initialized it yet.  Do that now.  */
if|if
condition|(
name|arg_pointer_save_area
operator|&&
operator|!
name|cfun
operator|->
name|arg_pointer_save_area_init
condition|)
name|get_arg_pointer_save_area
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
comment|/* Don't put any variables in registers if we call setjmp      on a machine that fails to restore the registers.  */
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|current_function_calls_setjmp
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|setjmp_protect
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|setjmp_protect_args
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initialize any trampolines required by this function.  */
for|for
control|(
name|link
operator|=
name|trampoline_list
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|function
init|=
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|rtx
name|context
name|ATTRIBUTE_UNUSED
init|=
name|lookup_static_chain
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|rtx
name|tramp
init|=
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|TRAMPOLINE_TEMPLATE
name|rtx
name|blktramp
decl_stmt|;
endif|#
directive|endif
name|rtx
name|seq
decl_stmt|;
ifdef|#
directive|ifdef
name|TRAMPOLINE_TEMPLATE
comment|/* First make sure this compilation has a template for 	 initializing trampolines.  */
if|if
condition|(
name|initial_trampoline
operator|==
literal|0
condition|)
block|{
name|initial_trampoline
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|assemble_trampoline_template
argument_list|()
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|initial_trampoline
argument_list|,
name|TRAMPOLINE_ALIGNMENT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Generate insns to initialize the trampoline.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|tramp
operator|=
name|round_trampoline_addr
argument_list|(
name|XEXP
argument_list|(
name|tramp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRAMPOLINE_TEMPLATE
name|blktramp
operator|=
name|replace_equiv_address
argument_list|(
name|initial_trampoline
argument_list|,
name|tramp
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|blktramp
argument_list|,
name|initial_trampoline
argument_list|,
name|GEN_INT
argument_list|(
name|TRAMPOLINE_SIZE
argument_list|)
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|trampolines_created
operator|=
literal|1
expr_stmt|;
name|INITIALIZE_TRAMPOLINE
argument_list|(
name|tramp
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Put those insns at entry to the containing function (this one).  */
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|tail_recursion_reentry
argument_list|)
expr_stmt|;
block|}
comment|/* If we are doing stack checking and this function makes calls,      do a stack probe at the start of the function to ensure we have enough      space for another stack frame.  */
if|if
condition|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|seq
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|probe_stack_range
argument_list|(
name|STACK_CHECK_PROTECT
argument_list|,
name|GEN_INT
argument_list|(
name|STACK_CHECK_MAX_FRAME_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|tail_recursion_reentry
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Possibly warn about unused parameters.      When frontend does unit-at-a-time, the warning is already      issued at finalization time.  */
if|if
condition|(
name|warn_unused_parameter
operator|&&
operator|!
name|lang_hooks
operator|.
name|callgraph
operator|.
name|expand_function
condition|)
name|do_warn_unused_parameter
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* Delete handlers for nonlocal gotos if nothing uses them.  */
if|if
condition|(
name|nonlocal_goto_handler_slots
operator|!=
literal|0
operator|&&
operator|!
name|current_function_has_nonlocal_label
condition|)
name|delete_handlers
argument_list|()
expr_stmt|;
comment|/* End any sequences that failed to be closed due to syntax errors.  */
while|while
condition|(
name|in_sequence_p
argument_list|()
condition|)
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Outside function body, can't compute type's actual size      until next function's body starts.  */
name|immediate_size_expand
operator|--
expr_stmt|;
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* ???  This is a kludge.  We want to ensure that instructions that      may trap are not moved into the epilogue by scheduling, because      we don't always emit unwind information for the epilogue.      However, not all machine descriptions define a blockage insn, so      emit an ASM_INPUT to act as one.  */
if|if
condition|(
name|flag_non_call_exceptions
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the end of the function body.      If control reaches this insn, the function can drop through      without returning a value.  */
name|emit_note
argument_list|(
name|NOTE_INSN_FUNCTION_END
argument_list|)
expr_stmt|;
comment|/* Must mark the last line number note in the function, so that the test      coverage code can avoid counting the last line twice.  This just tells      the code to ignore the immediately following line note, since there      already exists a copy of this note somewhere above.  This line number      note is still needed for debugging though, so we can't delete it.  */
if|if
condition|(
name|flag_test_coverage
condition|)
name|emit_note
argument_list|(
name|NOTE_INSN_REPEATED_LINE_NUMBER
argument_list|)
expr_stmt|;
comment|/* Output a linenumber for the end of the function.      SDB depends on this.  */
name|force_next_line_note
argument_list|()
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
comment|/* Before the return label (if any), clobber the return      registers so that they are not propagated live to the rest of      the function.  This can only happen with functions that drop      through; if there had been a return statement, there would      have either been a return rtx, or a jump to the return label.       We delay actual code generation after the current_function_value_rtx      is computed.  */
name|clobber_after
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Output the label for the actual return from the function,      if one is expected.  This happens either because a function epilogue      is used instead of a return instruction, or because a return was done      with a goto in order to run local cleanups, or because of pcc-style      structure returning.  */
if|if
condition|(
name|return_label
condition|)
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_instrument_entry_exit
condition|)
block|{
name|rtx
name|fun
init|=
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|fun
argument_list|)
operator|==
name|MEM
condition|)
name|fun
operator|=
name|XEXP
argument_list|(
name|fun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|emit_library_call
argument_list|(
name|profile_function_exit_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|2
argument_list|,
name|fun
argument_list|,
name|Pmode
argument_list|,
name|expand_builtin_return_addr
argument_list|(
name|BUILT_IN_RETURN_ADDRESS
argument_list|,
literal|0
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_PROFILER_EPILOGUE
if|if
condition|(
name|current_function_profile
operator|&&
name|TARGET_PROFILER_EPILOGUE
condition|)
block|{
specifier|static
name|rtx
name|mexitcount_libfunc
decl_stmt|;
specifier|static
name|int
name|initialized
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|mexitcount_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|".mexitcount"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Turn this off to prevent erroneous garbage collection.  */
block|initialized = 1;
endif|#
directive|endif
block|}
name|emit_library_call
argument_list|(
name|mexitcount_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Let except.c know where it should emit the call to unregister      the function context for sjlj exceptions.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|USING_SJLJ_EXCEPTIONS
condition|)
name|sjlj_emit_function_exit_after
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If we had calls to alloca, and this machine needs      an accurate stack pointer to exit the function,      insert some code to save and restore the stack pointer.  */
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
operator|&&
name|current_function_calls_alloca
condition|)
block|{
name|rtx
name|tem
init|=
literal|0
decl_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_FUNCTION
argument_list|,
operator|&
name|tem
argument_list|,
name|parm_birth_insn
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_FUNCTION
argument_list|,
name|tem
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* If scalar return value was computed in a pseudo-reg, or was a named      return value that got dumped to the stack, copy that to the hard      return register.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|decl_result
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|rtx
name|decl_rtl
init|=
name|DECL_RTL
argument_list|(
name|decl_result
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|decl_rtl
argument_list|)
condition|?
name|REGNO
argument_list|(
name|decl_rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
else|:
name|DECL_REGISTER
argument_list|(
name|decl_result
argument_list|)
condition|)
block|{
name|rtx
name|real_decl_rtl
init|=
name|current_function_return_rtx
decl_stmt|;
comment|/* This should be set in assign_parms.  */
if|if
condition|(
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|real_decl_rtl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If this is a BLKmode structure being returned in registers, 	     then use the mode computed in expand_return.  Note that if 	     decl_rtl is memory, then its mode may have been changed, 	     but that current_function_return_rtx has not.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|real_decl_rtl
argument_list|)
operator|==
name|BLKmode
condition|)
name|PUT_MODE
argument_list|(
name|real_decl_rtl
argument_list|,
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a named return value dumped decl_return to memory, then 	     we may need to re-do the PROMOTE_MODE signed/unsigned 	     extension.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|real_decl_rtl
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
condition|)
block|{
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|promote_function_return
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|promote_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|real_decl_rtl
argument_list|,
name|decl_rtl
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_decl_rtl
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* If expand_function_start has created a PARALLEL for decl_rtl, 		 move the result to the real return registers.  Otherwise, do 		 a group load from decl_rtl for a named return.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|decl_rtl
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_move
argument_list|(
name|real_decl_rtl
argument_list|,
name|decl_rtl
argument_list|)
expr_stmt|;
else|else
name|emit_group_load
argument_list|(
name|real_decl_rtl
argument_list|,
name|decl_rtl
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|real_decl_rtl
argument_list|,
name|decl_rtl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If returning a structure, arrange to return the address of the value      in a place where debuggers expect to find it.       If returning a structure PCC style,      the caller also depends on this value.      And current_function_returns_pcc_struct is not necessarily set.  */
if|if
condition|(
name|current_function_returns_struct
operator|||
name|current_function_returns_pcc_struct
condition|)
block|{
name|rtx
name|value_address
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|rtx
name|outgoing
init|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|outgoing
init|=
name|FUNCTION_VALUE
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Mark this as a function return value so integrate will delete the 	 assignment and USE below when inlining this function.  */
name|REG_FUNCTION_VALUE_P
argument_list|(
name|outgoing
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The address may be ptr_mode and OUTGOING may be Pmode.  */
name|value_address
operator|=
name|convert_memory_address
argument_list|(
name|GET_MODE
argument_list|(
name|outgoing
argument_list|)
argument_list|,
name|value_address
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|outgoing
argument_list|,
name|value_address
argument_list|)
expr_stmt|;
comment|/* Show return register used to hold result (in this case the address 	 of the result.  */
name|current_function_return_rtx
operator|=
name|outgoing
expr_stmt|;
block|}
comment|/* If this is an implementation of throw, do what's necessary to      communicate between __builtin_eh_return and the epilogue.  */
name|expand_eh_return
argument_list|()
expr_stmt|;
comment|/* Emit the actual code to clobber return register.  */
block|{
name|rtx
name|seq
decl_stmt|,
name|after
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|clobber_return_register
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|after
operator|=
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|clobber_after
argument_list|)
expr_stmt|;
if|if
condition|(
name|clobber_after
operator|!=
name|after
condition|)
name|cfun
operator|->
name|x_clobber_return_insn
operator|=
name|after
expr_stmt|;
block|}
comment|/* Output the label for the naked return from the function, if one is      expected.  This is currently used only by __builtin_return.  */
if|if
condition|(
name|naked_return_label
condition|)
name|emit_label
argument_list|(
name|naked_return_label
argument_list|)
expr_stmt|;
comment|/* ??? This should no longer be necessary since stupid is no longer with      us, but there are some parts of the compiler (eg reload_combine, and      sh mach_dep_reorg) that still try and compute their own lifetime info      instead of using the general framework.  */
name|use_return_register
argument_list|()
expr_stmt|;
comment|/* Fix up any gotos that jumped out to the outermost      binding level of the function.      Must follow emitting RETURN_LABEL.  */
comment|/* If you have any cleanups to do at this point,      and they need to create temporary variables,      then you will lose.  */
name|expand_fixups
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|rtx
name|get_arg_pointer_save_area
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|rtx
name|ret
init|=
name|f
operator|->
name|x_arg_pointer_save_area
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ret
operator|=
name|assign_stack_local_1
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|x_arg_pointer_save_area
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|cfun
operator|&&
operator|!
name|f
operator|->
name|arg_pointer_save_area_init
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
comment|/* Save the arg pointer at the beginning of the function.  The 	 generated stack slot may not be a valid memory address, so we 	 have to check it and fix it if necessary.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|ret
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extend a vector that records the INSN_UIDs of INSNS    (a list of one or more insns).  */
end_comment

begin_function
specifier|static
name|void
name|record_insns
parameter_list|(
name|rtx
name|insns
parameter_list|,
name|varray_type
modifier|*
name|vecp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|insns
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL_RTX
condition|)
block|{
name|len
operator|++
expr_stmt|;
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|VARRAY_SIZE
argument_list|(
operator|*
name|vecp
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
operator|*
name|vecp
argument_list|,
name|i
operator|+
name|len
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|insns
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL_RTX
condition|)
block|{
name|VARRAY_INT
argument_list|(
operator|*
name|vecp
argument_list|,
name|i
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the locator of the insn chain starting at INSN to LOC.  */
end_comment

begin_function
specifier|static
name|void
name|set_insn_locators
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|loc
parameter_list|)
block|{
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|INSN_LOCATOR
argument_list|(
name|insn
argument_list|)
operator|=
name|loc
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine how many INSN_UIDs in VEC are part of INSN.  Because we can    be running after reorg, SEQUENCE rtl is possible.  */
end_comment

begin_function
specifier|static
name|int
name|contains
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|varray_type
name|vec
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
for|for
control|(
name|j
operator|=
name|VARRAY_SIZE
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|VARRAY_INT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
name|VARRAY_SIZE
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|==
name|VARRAY_INT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|prologue_epilogue_contains
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|insn
argument_list|,
name|prologue
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|contains
argument_list|(
name|insn
argument_list|,
name|epilogue
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sibcall_epilogue_contains
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|sibcall_epilogue
condition|)
return|return
name|contains
argument_list|(
name|insn
argument_list|,
name|sibcall_epilogue
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_return
end_ifdef

begin_comment
comment|/* Insert gen_return at the end of block BB.  This also means updating    block_for_insn appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|emit_return_into_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
name|line_note
parameter_list|)
block|{
name|emit_jump_insn_after
argument_list|(
name|gen_return
argument_list|()
argument_list|,
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_note
condition|)
name|emit_note_copy_after
argument_list|(
name|line_note
argument_list|,
name|PREV_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_return */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
operator|&&
name|defined
argument_list|(
name|INCOMING_RETURN_ADDR_RTX
argument_list|)
end_if

begin_comment
comment|/* These functions convert the epilogue into a variant that does not modify the    stack pointer.  This is used in cases where a function returns an object    whose size is not known until it is computed.  The called function leaves the    object on the stack, leaves the stack depressed, and returns a pointer to    the object.     What we need to do is track all modifications and references to the stack    pointer, deleting the modifications and changing the references to point to    the location the stack pointer would have pointed to had the modifications    taken place.     These functions need to be portable so we need to make as few assumptions    about the epilogue as we can.  However, the epilogue basically contains    three things: instructions to reset the stack pointer, instructions to    reload registers, possibly including the frame pointer, and an    instruction to return to the caller.     If we can't be sure of what a relevant epilogue insn is doing, we abort.    We also make no attempt to validate the insns we make since if they are    invalid, we probably can't do anything valid.  The intent is that these    routines get "smarter" as more and more machines start to use them and    they try operating on different epilogues.     We use the following structure to track what the part of the epilogue that    we've already processed has done.  We keep two copies of the SP equivalence,    one for use during the insn we are processing and one for use in the next    insn.  The difference is because one part of a PARALLEL may adjust SP    and the other may use it.  */
end_comment

begin_struct
struct|struct
name|epi_info
block|{
name|rtx
name|sp_equiv_reg
decl_stmt|;
comment|/* REG that SP is set from, perhaps SP.  */
name|HOST_WIDE_INT
name|sp_offset
decl_stmt|;
comment|/* Offset from SP_EQUIV_REG of present SP.  */
name|rtx
name|new_sp_equiv_reg
decl_stmt|;
comment|/* REG to be used at end of insn.  */
name|HOST_WIDE_INT
name|new_sp_offset
decl_stmt|;
comment|/* Offset to be used at end of insn.  */
name|rtx
name|equiv_reg_src
decl_stmt|;
comment|/* If nonzero, the value that SP_EQUIV_REG 				   should be set to once we no longer need 				   its value.  */
name|rtx
name|const_equiv
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
comment|/* Any known constant equivalences 					     for registers.  */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|handle_epilogue_set
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|epi_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_epilogue_consts
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_equiv_load
parameter_list|(
name|struct
name|epi_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Modify INSN, a list of one or more insns that is part of the epilogue, to    no modifications to the stack pointer.  Return the new list of insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|keep_stack_depressed
parameter_list|(
name|rtx
name|insns
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|epi_info
name|info
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
comment|/* If the epilogue is just a single instruction, it must be OK as is.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insns
argument_list|)
operator|==
name|NULL_RTX
condition|)
return|return
name|insns
return|;
comment|/* Otherwise, start a sequence, initialize the information we have, and      process all the insns we were given.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|info
operator|.
name|sp_equiv_reg
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|info
operator|.
name|sp_offset
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|equiv_reg_src
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
name|info
operator|.
name|const_equiv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|insns
expr_stmt|;
name|next
operator|=
name|NULL_RTX
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* If this insn references the register that SP is equivalent to and 	 we have a pending load to that register, we must force out the load 	 first and then indicate we no longer know what SP's equivalent is.  */
if|if
condition|(
name|info
operator|.
name|equiv_reg_src
operator|!=
literal|0
operator|&&
name|reg_referenced_p
argument_list|(
name|info
operator|.
name|sp_equiv_reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|emit_equiv_load
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|sp_equiv_reg
operator|=
literal|0
expr_stmt|;
block|}
name|info
operator|.
name|new_sp_equiv_reg
operator|=
name|info
operator|.
name|sp_equiv_reg
expr_stmt|;
name|info
operator|.
name|new_sp_offset
operator|=
name|info
operator|.
name|sp_offset
expr_stmt|;
comment|/* If this is a (RETURN) and the return address is on the stack, 	 update the address and change to an indirect jump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
block|{
name|rtx
name|retaddr
init|=
name|INCOMING_RETURN_ADDR_RTX
decl_stmt|;
name|rtx
name|base
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|jump_insn
decl_stmt|,
name|jump_set
decl_stmt|;
comment|/* If the return address is in a register, we can emit the insn 	     unchanged.  Otherwise, it must be a MEM and we see what the 	     base register and offset are.  In any case, we have to emit any 	     pending load to the equivalent reg of SP, if any.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|retaddr
argument_list|)
operator|==
name|REG
condition|)
block|{
name|emit_equiv_load
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|retaddr
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|retaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|retaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|,
name|offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|retaddr
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|retaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|retaddr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|retaddr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|retaddr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|retaddr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If the base of the location containing the return pointer 	     is SP, we must update it with the replacement address.  Otherwise, 	     just build the necessary MEM.  */
name|retaddr
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|stack_pointer_rtx
condition|)
name|retaddr
operator|=
name|simplify_replace_rtx
argument_list|(
name|retaddr
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|info
operator|.
name|sp_equiv_reg
argument_list|,
name|info
operator|.
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|retaddr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
comment|/* If there is a pending load to the equivalent register for SP 	     and we reference that register, we must load our address into 	     a scratch register and then do that load.  */
if|if
condition|(
name|info
operator|.
name|equiv_reg_src
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|info
operator|.
name|equiv_reg_src
argument_list|,
name|retaddr
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|Pmode
argument_list|)
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|Pmode
argument_list|)
argument_list|,
name|info
operator|.
name|equiv_reg_src
argument_list|,
name|NULL
argument_list|)
operator|&&
name|info
operator|.
name|const_equiv
index|[
name|regno
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|regno
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
name|retaddr
operator|=
name|reg
expr_stmt|;
block|}
name|emit_equiv_load
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|jump_insn
operator|=
name|emit_jump_insn
argument_list|(
name|gen_indirect_jump
argument_list|(
name|retaddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Show the SET in the above insn is a RETURN.  */
name|jump_set
operator|=
name|single_set
argument_list|(
name|jump_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_set
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|SET_IS_RETURN_P
argument_list|(
name|jump_set
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If SP is not mentioned in the pattern and its equivalent register, if 	 any, is not modified, just emit it.  Otherwise, if neither is set, 	 replace the reference to SP and emit the insn.  If none of those are 	 true, handle each SET individually.  */
elseif|else
if|if
condition|(
operator|!
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|(
name|info
operator|.
name|sp_equiv_reg
operator|==
name|stack_pointer_rtx
operator|||
operator|!
name|reg_set_p
argument_list|(
name|info
operator|.
name|sp_equiv_reg
argument_list|,
name|insn
argument_list|)
operator|)
condition|)
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|reg_set_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|insn
argument_list|)
operator|&&
operator|(
name|info
operator|.
name|sp_equiv_reg
operator|==
name|stack_pointer_rtx
operator|||
operator|!
name|reg_set_p
argument_list|(
name|info
operator|.
name|sp_equiv_reg
argument_list|,
name|insn
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|validate_replace_rtx
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|info
operator|.
name|sp_equiv_reg
argument_list|,
name|info
operator|.
name|sp_offset
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|handle_epilogue_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|handle_epilogue_set
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
else|else
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|info
operator|.
name|sp_equiv_reg
operator|=
name|info
operator|.
name|new_sp_equiv_reg
expr_stmt|;
name|info
operator|.
name|sp_offset
operator|=
name|info
operator|.
name|new_sp_offset
expr_stmt|;
comment|/* Now update any constants this insn sets.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|update_epilogue_consts
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|insns
return|;
block|}
end_function

begin_comment
comment|/* SET is a SET from an insn in the epilogue.  P is a pointer to the epi_info    structure that contains information about what we've seen so far.  We    process this SET by either updating that data or by emitting one or    more insns.  */
end_comment

begin_function
specifier|static
name|void
name|handle_epilogue_set
parameter_list|(
name|rtx
name|set
parameter_list|,
name|struct
name|epi_info
modifier|*
name|p
parameter_list|)
block|{
comment|/* First handle the case where we are setting SP.  Record what it is being      set from.  If unknown, abort.  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|set
argument_list|)
condition|)
block|{
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|p
operator|->
name|new_sp_equiv_reg
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|p
operator|->
name|new_sp_offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|p
operator|->
name|new_sp_offset
operator|=
name|INTVAL
argument_list|(
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|p
operator|->
name|new_sp_equiv_reg
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|,
name|p
operator|->
name|new_sp_offset
operator|=
literal|0
expr_stmt|;
comment|/* If we are adjusting SP, we adjust from the old data.  */
if|if
condition|(
name|p
operator|->
name|new_sp_equiv_reg
operator|==
name|stack_pointer_rtx
condition|)
block|{
name|p
operator|->
name|new_sp_equiv_reg
operator|=
name|p
operator|->
name|sp_equiv_reg
expr_stmt|;
name|p
operator|->
name|new_sp_offset
operator|+=
name|p
operator|->
name|sp_offset
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|new_sp_equiv_reg
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|p
operator|->
name|new_sp_equiv_reg
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Next handle the case where we are setting SP's equivalent register.      If we already have a value to set it to, abort.  We could update, but      there seems little point in handling that case.  Note that we have      to allow for the case where we are setting the register set in      the previous part of a PARALLEL inside a single insn.  But use the      old offset for any updates within this insn.  We must allow for the case      where the register is being set in a different (usually wider) mode than      Pmode).  */
elseif|else
if|if
condition|(
name|p
operator|->
name|new_sp_equiv_reg
operator|!=
literal|0
operator|&&
name|reg_set_p
argument_list|(
name|p
operator|->
name|new_sp_equiv_reg
argument_list|,
name|set
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|equiv_reg_src
operator|!=
literal|0
operator|||
name|GET_CODE
argument_list|(
name|p
operator|->
name|new_sp_equiv_reg
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|>
name|BITS_PER_WORD
operator|||
name|REGNO
argument_list|(
name|p
operator|->
name|new_sp_equiv_reg
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|p
operator|->
name|equiv_reg_src
operator|=
name|simplify_replace_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|p
operator|->
name|sp_equiv_reg
argument_list|,
name|p
operator|->
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, replace any references to SP in the insn to its new value      and emit the insn.  */
else|else
block|{
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|simplify_replace_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|p
operator|->
name|sp_equiv_reg
argument_list|,
name|p
operator|->
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|simplify_replace_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|p
operator|->
name|sp_equiv_reg
argument_list|,
name|p
operator|->
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update the tracking information for registers set to constants.  */
end_comment

begin_function
specifier|static
name|void
name|update_epilogue_consts
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|epi_info
modifier|*
name|p
init|=
operator|(
expr|struct
name|epi_info
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|dest
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an insn to do the load shown in p->equiv_reg_src, if needed.  */
end_comment

begin_function
specifier|static
name|void
name|emit_equiv_load
parameter_list|(
name|struct
name|epi_info
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|equiv_reg_src
operator|!=
literal|0
condition|)
block|{
name|rtx
name|dest
init|=
name|p
operator|->
name|sp_equiv_reg
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|p
operator|->
name|equiv_reg_src
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
condition|)
name|dest
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|p
operator|->
name|equiv_reg_src
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|p
operator|->
name|sp_equiv_reg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|p
operator|->
name|equiv_reg_src
argument_list|)
expr_stmt|;
name|p
operator|->
name|equiv_reg_src
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate the prologue and epilogue RTL if the machine supports it.  Thread    this into place with notes indicating where the prologue ends and where    the epilogue begins.  Update the basic block information when possible.  */
end_comment

begin_function
name|void
name|thread_prologue_and_epilogue_insns
parameter_list|(
name|rtx
name|f
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|inserted
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_sibcall_epilogue
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_return
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_prologue
argument_list|)
name|rtx
name|seq
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_prologue
name|rtx
name|prologue_end
init|=
name|NULL_RTX
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_return
argument_list|)
name|rtx
name|epilogue_end
init|=
name|NULL_RTX
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_prologue
if|if
condition|(
name|HAVE_prologue
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|seq
operator|=
name|gen_prologue
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* Retain a map of the prologue insns.  */
name|record_insns
argument_list|(
name|seq
argument_list|,
operator|&
name|prologue
argument_list|)
expr_stmt|;
name|prologue_end
operator|=
name|emit_note
argument_list|(
name|NOTE_INSN_PROLOGUE_END
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|set_insn_locators
argument_list|(
name|seq
argument_list|,
name|prologue_locator
argument_list|)
expr_stmt|;
comment|/* Can't deal with multiple successors of the entry block          at the moment.  Function should always have at least one          entry point.  */
if|if
condition|(
operator|!
name|ENTRY_BLOCK_PTR
operator|->
name|succ
operator|||
name|ENTRY_BLOCK_PTR
operator|->
name|succ
operator|->
name|succ_next
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|seq
argument_list|,
name|ENTRY_BLOCK_PTR
operator|->
name|succ
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If the exit block has no non-fake predecessors, we don't need      an epilogue.  */
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
goto|goto
name|epilogue_done
goto|;
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|optimize
operator|&&
name|HAVE_return
condition|)
block|{
comment|/* If we're allowed to generate a simple return instruction, 	 then by definition we don't need a full epilogue.  Examine 	 the block that falls through to EXIT.   If it does not 	 contain any code, examine its predecessors and try to 	 emit (conditional) return instructions.  */
name|basic_block
name|last
decl_stmt|;
name|edge
name|e_next
decl_stmt|;
name|rtx
name|label
decl_stmt|;
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
goto|goto
name|epilogue_done
goto|;
name|last
operator|=
name|e
operator|->
name|src
expr_stmt|;
comment|/* Verify that there are no active instructions in the last block.  */
name|label
operator|=
name|BB_END
argument_list|(
name|last
argument_list|)
expr_stmt|;
while|while
condition|(
name|label
operator|&&
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|active_insn_p
argument_list|(
name|label
argument_list|)
condition|)
break|break;
name|label
operator|=
name|PREV_INSN
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BB_HEAD
argument_list|(
name|last
argument_list|)
operator|==
name|label
operator|&&
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|rtx
name|epilogue_line_note
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Locate the line number associated with the closing brace, 	     if we can find one.  */
for|for
control|(
name|seq
operator|=
name|get_last_insn
argument_list|()
init|;
name|seq
operator|&&
operator|!
name|active_insn_p
argument_list|(
name|seq
argument_list|)
condition|;
name|seq
operator|=
name|PREV_INSN
argument_list|(
name|seq
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|seq
argument_list|)
operator|>
literal|0
condition|)
block|{
name|epilogue_line_note
operator|=
name|seq
expr_stmt|;
break|break;
block|}
for|for
control|(
name|e
operator|=
name|last
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e_next
control|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|jump
decl_stmt|;
name|e_next
operator|=
name|e
operator|->
name|pred_next
expr_stmt|;
if|if
condition|(
name|bb
operator|==
name|ENTRY_BLOCK_PTR
condition|)
continue|continue;
name|jump
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|!=
name|JUMP_INSN
operator|)
operator|||
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|!=
name|label
condition|)
continue|continue;
comment|/* If we have an unconditional jump, we can replace that 		 with a simple return instruction.  */
if|if
condition|(
name|simplejump_p
argument_list|(
name|jump
argument_list|)
condition|)
block|{
name|emit_return_into_block
argument_list|(
name|bb
argument_list|,
name|epilogue_line_note
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a conditional jump, we can try to replace 		 that with a conditional return instruction.  */
elseif|else
if|if
condition|(
name|condjump_p
argument_list|(
name|jump
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|jump
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* If this block has only one successor, it both jumps 		     and falls through to the fallthru block, so we can't 		     delete the edge.  */
if|if
condition|(
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|==
name|NULL
condition|)
continue|continue;
block|}
else|else
continue|continue;
comment|/* Fix up the CFG for the successful change we just made.  */
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
block|}
comment|/* Emit a return insn for the exit fallthru block.  Whether 	     this is still reachable will be determined later.  */
name|emit_barrier_after
argument_list|(
name|BB_END
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|emit_return_into_block
argument_list|(
name|last
argument_list|,
name|epilogue_line_note
argument_list|)
expr_stmt|;
name|epilogue_end
operator|=
name|BB_END
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|last
operator|->
name|succ
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
goto|goto
name|epilogue_done
goto|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_epilogue
if|if
condition|(
name|HAVE_epilogue
condition|)
block|{
comment|/* Find the edge that falls through to EXIT.  Other edges may exist 	 due to RETURN instructions, but those don't need epilogues. 	 There really shouldn't be a mixture -- either all should have 	 been converted or none, however...  */
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
goto|goto
name|epilogue_done
goto|;
name|start_sequence
argument_list|()
expr_stmt|;
name|epilogue_end
operator|=
name|emit_note
argument_list|(
name|NOTE_INSN_EPILOGUE_BEG
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_epilogue
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|INCOMING_RETURN_ADDR_RTX
comment|/* If this function returns with the stack depressed and we can support 	 it, massage the epilogue to actually do that.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TYPE_RETURNS_STACK_DEPRESSED
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|seq
operator|=
name|keep_stack_depressed
argument_list|(
name|seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_jump_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* Retain a map of the epilogue insns.  */
name|record_insns
argument_list|(
name|seq
argument_list|,
operator|&
name|epilogue
argument_list|)
expr_stmt|;
name|set_insn_locators
argument_list|(
name|seq
argument_list|,
name|epilogue_locator
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|seq
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|epilogue_done
label|:
if|if
condition|(
name|inserted
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_sibcall_epilogue
comment|/* Emit sibling epilogues before any sibling call sites.  */
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|i
decl_stmt|;
name|rtx
name|newinsn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|||
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sibcall_epilogue
argument_list|()
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Retain a map of the epilogue insns.  Used in life analysis to 	 avoid getting rid of sibcall epilogue insns.  Do this before we 	 actually emit the sequence.  */
name|record_insns
argument_list|(
name|seq
argument_list|,
operator|&
name|sibcall_epilogue
argument_list|)
expr_stmt|;
name|set_insn_locators
argument_list|(
name|seq
argument_list|,
name|epilogue_locator
argument_list|)
expr_stmt|;
name|i
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|newinsn
operator|=
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_prologue
comment|/* This is probably all useless now that we use locators.  */
if|if
condition|(
name|prologue_end
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|prev
decl_stmt|;
comment|/* GDB handles `break f' by setting a breakpoint on the first 	 line note after the prologue.  Which means (1) that if 	 there are line number notes before where we inserted the 	 prologue we should move them, and (2) we should generate a 	 note before the end of the first basic block, if there isn't 	 one already there.  	 ??? This behavior is completely broken when dealing with 	 multiple entry functions.  We simply place the note always 	 into first basic block and let alternate entry points 	 to be missed.        */
for|for
control|(
name|insn
operator|=
name|prologue_end
init|;
name|insn
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Note that we cannot reorder the first insn in the 		 chain, since rest_of_compilation relies on that 		 remaining constant.  */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
break|break;
name|reorder_insns
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
name|prologue_end
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Find the last line number note in the first block.  */
for|for
control|(
name|insn
operator|=
name|BB_END
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
argument_list|)
init|;
name|insn
operator|!=
name|prologue_end
operator|&&
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
break|break;
comment|/* If we didn't find one, make a copy of the first line number 	 we run across.  */
if|if
condition|(
operator|!
name|insn
condition|)
block|{
for|for
control|(
name|insn
operator|=
name|next_active_insn
argument_list|(
name|prologue_end
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
name|emit_note_copy_after
argument_list|(
name|insn
argument_list|,
name|prologue_end
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_epilogue
if|if
condition|(
name|epilogue_end
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
comment|/* Similarly, move any line notes that appear after the epilogue.          There is no need, however, to be quite so anal about the existence 	 of such a note.  Also move the NOTE_INSN_FUNCTION_END and (possibly) 	 NOTE_INSN_FUNCTION_BEG notes, as those can be relevant for debug 	 info generation.  */
for|for
control|(
name|insn
operator|=
name|epilogue_end
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_END
operator|)
condition|)
name|reorder_insns
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
name|PREV_INSN
argument_list|(
name|epilogue_end
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Reposition the prologue-end and epilogue-begin notes after instruction    scheduling and delayed branch scheduling.  */
end_comment

begin_function
name|void
name|reposition_prologue_and_epilogue_notes
parameter_list|(
name|rtx
name|f
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_prologue
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|,
name|note
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|VARRAY_SIZE
argument_list|(
name|prologue
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|last
operator|=
literal|0
operator|,
name|note
operator|=
literal|0
expr_stmt|;
comment|/* Scan from the beginning until we reach the last prologue insn. 	 We apparently can't depend on basic_block_{head,end} after 	 reorg has run.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_PROLOGUE_END
condition|)
name|note
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|contains
argument_list|(
name|insn
argument_list|,
name|prologue
argument_list|)
condition|)
block|{
name|last
operator|=
name|insn
expr_stmt|;
if|if
condition|(
operator|--
name|len
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|last
condition|)
block|{
comment|/* Find the prologue-end note if we haven't already, and 	     move it to just after the last prologue insn.  */
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|note
operator|=
name|last
init|;
operator|(
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
operator|)
condition|;
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_PROLOGUE_END
condition|)
break|break;
block|}
comment|/* Avoid placing note between CODE_LABEL and BASIC_BLOCK note.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|note
argument_list|,
name|note
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|VARRAY_SIZE
argument_list|(
name|epilogue
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|last
operator|=
literal|0
operator|,
name|note
operator|=
literal|0
expr_stmt|;
comment|/* Scan from the end until we reach the first epilogue insn. 	 We apparently can't depend on basic_block_{head,end} after 	 reorg has run.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
name|note
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|contains
argument_list|(
name|insn
argument_list|,
name|epilogue
argument_list|)
condition|)
block|{
name|last
operator|=
name|insn
expr_stmt|;
if|if
condition|(
operator|--
name|len
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|last
condition|)
block|{
comment|/* Find the epilogue-begin note if we haven't already, and 	     move it to just before the first epilogue insn.  */
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|note
operator|=
name|insn
init|;
operator|(
name|note
operator|=
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|)
condition|;
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
break|break;
block|}
if|if
condition|(
name|PREV_INSN
argument_list|(
name|last
argument_list|)
operator|!=
name|note
condition|)
name|reorder_insns
argument_list|(
name|note
argument_list|,
name|note
argument_list|,
name|PREV_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_prologue or HAVE_epilogue */
block|}
end_function

begin_comment
comment|/* Called once, at initialization, to initialize function.c.  */
end_comment

begin_function
name|void
name|init_function_once
parameter_list|(
name|void
parameter_list|)
block|{
name|VARRAY_INT_INIT
argument_list|(
name|prologue
argument_list|,
literal|0
argument_list|,
literal|"prologue"
argument_list|)
expr_stmt|;
name|VARRAY_INT_INIT
argument_list|(
name|epilogue
argument_list|,
literal|0
argument_list|,
literal|"epilogue"
argument_list|)
expr_stmt|;
name|VARRAY_INT_INIT
argument_list|(
name|sibcall_epilogue
argument_list|,
literal|0
argument_list|,
literal|"sibcall_epilogue"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the name of the current function.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|current_function_name
parameter_list|(
name|void
parameter_list|)
block|{
return|return
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|cfun
operator|->
name|decl
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-function.h"
end_include

end_unit

