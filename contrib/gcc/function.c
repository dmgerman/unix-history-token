begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expands front end tree to back end RTL for GNU C-Compiler    Copyright (C) 1987, 88, 89, 91-94, 1995 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file handles the generation of rtl code from tree structure    at the level of the function as a whole.    It creates the rtl expressions for parameters and auto variables    and has full responsibility for allocating stack slots.     `expand_function_start' is called at the beginning of a function,    before the function body is parsed, and `expand_function_end' is    called after parsing the body.     Call `assign_stack_local' to allocate a stack slot for a local variable.    This is usually done during the RTL generation for the function body,    but it can also be done in the reload pass when a pseudo-register does    not get a hard register.     Call `put_var_into_stack' when you learn, belatedly, that a variable    previously given a pseudo-register must in fact go in the stack.    This function changes the DECL_RTL to be a stack slot instead of a reg    then scans all the RTL instructions so far generated to correct them.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bytecode.h"
end_include

begin_comment
comment|/* Some systems use __main in a way incompatible with its use in gcc, in these    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to    give the same symbol without quotes for an alternative entry point.  You    must define both, or neither. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME__MAIN
end_ifndef

begin_define
define|#
directive|define
name|NAME__MAIN
value|"__main"
end_define

begin_define
define|#
directive|define
name|SYMBOL__MAIN
value|__main
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Round a value to the lowest integer less than it that is a multiple of    the required alignment.  Avoid using division in case the value is    negative.  Assume the alignment is a power of two.  */
end_comment

begin_define
define|#
directive|define
name|FLOOR_ROUND
parameter_list|(
name|VALUE
parameter_list|,
name|ALIGN
parameter_list|)
value|((VALUE)& ~((ALIGN) - 1))
end_define

begin_comment
comment|/* Similar, but round to the next highest integer that meets the    alignment.  */
end_comment

begin_define
define|#
directive|define
name|CEIL_ROUND
parameter_list|(
name|VALUE
parameter_list|,
name|ALIGN
parameter_list|)
value|(((VALUE) + (ALIGN) - 1)& ~((ALIGN)- 1))
end_define

begin_comment
comment|/* NEED_SEPARATE_AP means that we cannot derive ap from the value of fp    during rtl generation.  If they are different register numbers, this is    always true.  It may also be true if    FIRST_PARM_OFFSET - STARTING_FRAME_OFFSET is not a constant during rtl    generation.  See fix_lexical_addr for details.  */
end_comment

begin_if
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
end_if

begin_define
define|#
directive|define
name|NEED_SEPARATE_AP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bytes of args popped by function being compiled on its return.    Zero if no bytes are to be popped.    May affect compilation of return insn or of function epilogue.  */
end_comment

begin_decl_stmt
name|int
name|current_function_pops_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled needs to be given an address    where the value should be stored.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_struct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled needs to    return the address of where it has put a structure value.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_pcc_struct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled needs to be passed a static chain.  */
end_comment

begin_decl_stmt
name|int
name|current_function_needs_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled can call setjmp.  */
end_comment

begin_decl_stmt
name|int
name|current_function_calls_setjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled can call longjmp.  */
end_comment

begin_decl_stmt
name|int
name|current_function_calls_longjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled receives nonlocal gotos    from nested functions.  */
end_comment

begin_decl_stmt
name|int
name|current_function_has_nonlocal_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled has nonlocal gotos to parent    function.  */
end_comment

begin_decl_stmt
name|int
name|current_function_has_nonlocal_goto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled contains nested functions.  */
end_comment

begin_decl_stmt
name|int
name|current_function_contains_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled can call alloca,    either as a subroutine or builtin.  */
end_comment

begin_decl_stmt
name|int
name|current_function_calls_alloca
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the current function returns a pointer type */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If some insns can be deferred to the delay slots of the epilogue, the    delay list for them is recorded here.  */
end_comment

begin_decl_stmt
name|rtx
name|current_function_epilogue_delay_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If function's args have a fixed size, this is that size, in bytes.    Otherwise, it is -1.    May affect compilation of return insn or of function epilogue.  */
end_comment

begin_decl_stmt
name|int
name|current_function_args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # bytes the prologue should push and pretend that the caller pushed them.    The prologue must do this, but only if parms can be passed in registers.  */
end_comment

begin_decl_stmt
name|int
name|current_function_pretend_args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is    defined, the needed space is pushed by the prologue. */
end_comment

begin_decl_stmt
name|int
name|current_function_outgoing_args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the offset from the arg pointer to the place where the first    anonymous arg can be found, if there is one.  */
end_comment

begin_decl_stmt
name|rtx
name|current_function_arg_offset_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if current function uses varargs.h or equivalent.    Zero for functions that use stdarg.h.  */
end_comment

begin_decl_stmt
name|int
name|current_function_varargs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if current function uses stdarg.h or equivalent.    Zero for functions that use varargs.h.  */
end_comment

begin_decl_stmt
name|int
name|current_function_stdarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Quantities of various kinds of registers    used for the current function's args.  */
end_comment

begin_decl_stmt
name|CUMULATIVE_ARGS
name|current_function_args_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of function now being compiled.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, an RTL expression for that location at which the current    function returns its result.  Always equal to    DECL_RTL (DECL_RESULT (current_function_decl)), but provided    independently of the tree structures.  */
end_comment

begin_decl_stmt
name|rtx
name|current_function_return_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the current function uses the constant pool.  */
end_comment

begin_decl_stmt
name|int
name|current_function_uses_const_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the current function uses pic_offset_table_rtx.  */
end_comment

begin_decl_stmt
name|int
name|current_function_uses_pic_offset_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The arg pointer hard register, or the pseudo into which it was copied.  */
end_comment

begin_decl_stmt
name|rtx
name|current_function_internal_arg_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FUNCTION_DECL for an inline function currently being expanded.  */
end_comment

begin_decl_stmt
name|tree
name|inline_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of function calls seen so far in current function.  */
end_comment

begin_decl_stmt
name|int
name|function_call_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of TREE_LIST) of LABEL_DECLs for all nonlocal labels    (labels to which there can be nonlocal gotos from nested functions)    in this function.  */
end_comment

begin_decl_stmt
name|tree
name|nonlocal_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RTX for stack slot that holds the current handler for nonlocal gotos.    Zero when function does not have nonlocal labels.  */
end_comment

begin_decl_stmt
name|rtx
name|nonlocal_goto_handler_slot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RTX for stack slot that holds the stack pointer value to restore    for a nonlocal goto.    Zero when function does not have nonlocal labels.  */
end_comment

begin_decl_stmt
name|rtx
name|nonlocal_goto_stack_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label that will go on parm cleanup code, if any.    Jumping to this label runs cleanup code for parameters, if    such code must be run.  Following this code is the logical return label.  */
end_comment

begin_decl_stmt
name|rtx
name|cleanup_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label that will go on function epilogue.    Jumping to this label serves as a "return" instruction    on machines which require execution of the epilogue on all returns.  */
end_comment

begin_decl_stmt
name|rtx
name|return_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.    So we can mark them all live at the end of the function, if nonopt.  */
end_comment

begin_decl_stmt
name|rtx
name|save_expr_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of EXPR_LISTs) of all stack slots in this function.    Made for the sake of unshare_all_rtl.  */
end_comment

begin_decl_stmt
name|rtx
name|stack_slot_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all RTL_EXPRs that have insns in them.  */
end_comment

begin_decl_stmt
name|tree
name|rtl_expr_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label to jump back to for tail recursion, or 0 if we have    not yet needed one for this function.  */
end_comment

begin_decl_stmt
name|rtx
name|tail_recursion_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place after which to insert the tail_recursion_label if we need one.  */
end_comment

begin_decl_stmt
name|rtx
name|tail_recursion_reentry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location at which to save the argument pointer if it will need to be    referenced.  There are two cases where this is done: if nonlocal gotos    exist, or if vars stored at an offset from the argument pointer will be    needed by inner routines.  */
end_comment

begin_decl_stmt
name|rtx
name|arg_pointer_save_area
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset to end of allocated area of stack frame.    If stack grows down, this is the address of the last stack slot allocated.    If stack grows up, this is the address for the next slot.  */
end_comment

begin_decl_stmt
name|int
name|frame_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of TREE_LISTs) of static chains for containing functions.    Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx    in an RTL_EXPR in the TREE_VALUE.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|context_display
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of TREE_LISTs) of trampolines for nested functions.    The trampoline sets up the static chain and jumps to the function.    We supply the trampoline's address when the function's address is requested.     Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx    in an RTL_EXPR in the TREE_VALUE.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|trampoline_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|parm_birth_insn
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Nonzero if a stack slot has been generated whose address is not    actually valid.  It means that the generated rtl must all be scanned    to detect and correct the invalid addresses where they occur.  */
end_comment

begin_endif
unit|static int invalid_stack_slot;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Last insn of those whose job was to put parms into their nominal homes.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_parm_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 + last pseudo register number used for loading a copy    of a parameter of this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_parm_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indexed by REGNO, containing location on stack in which    to put the parm which is nominally in pseudo register REGNO,    if we discover that that parm must go in the stack.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|parm_reg_stack_loc
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Turned off because 0 seems to work just as well.  */
end_comment

begin_comment
comment|/* Cleanup lists are required for binding levels regardless of whether    that binding level has cleanups or not.  This node serves as the    cleanup list whenever an empty list is required.  */
end_comment

begin_endif
unit|static tree empty_cleanup_list;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero once virtual register instantiation has been done.    assign_stack_local uses frame_pointer_rtx when this is nonzero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|virtuals_instantiated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables hold pointers to functions to    save and restore machine-specific data,    in push_function_context and pop_function_context.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|save_machine_status
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|restore_machine_status
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero if we need to distinguish between the return value of this function    and the return value of a function called by this function.  This helps    integrate.c  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|sequence_rtl_expr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|tree
name|bc_runtime_type_code
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|rtx
name|bc_build_calldesc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|bc_emit_trampoline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|bc_end_function
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* In order to evaluate some expressions, such as function calls returning    structures in memory, we need to temporarily allocate stack locations.    We record each allocated temporary in the following structure.     Associated with each temporary slot is a nesting level.  When we pop up    one level, all temporaries associated with the previous level are freed.    Normally, all temporaries are freed after the execution of the statement    in which they were created.  However, if we are inside a ({...}) grouping,    the result may be in a temporary and hence must be preserved.  If the    result could be in a temporary, we preserve it if we can determine which    one it is in.  If we cannot determine which temporary may contain the    result, all temporaries are preserved.  A temporary is preserved by    pretending it was allocated at the previous nesting level.     Automatic variables are also assigned temporary slots, at the nesting    level where they are defined.  They are marked a "kept" so that    free_temp_slots will not free them.  */
end_comment

begin_struct
struct|struct
name|temp_slot
block|{
comment|/* Points to next temporary slot.  */
name|struct
name|temp_slot
modifier|*
name|next
decl_stmt|;
comment|/* The rtx to used to reference the slot. */
name|rtx
name|slot
decl_stmt|;
comment|/* The rtx used to represent the address if not the address of the      slot above.  May be an EXPR_LIST if multiple addresses exist.  */
name|rtx
name|address
decl_stmt|;
comment|/* The size, in units, of the slot.  */
name|int
name|size
decl_stmt|;
comment|/* The value of `sequence_rtl_expr' when this temporary is allocated.  */
name|tree
name|rtl_expr
decl_stmt|;
comment|/* Non-zero if this temporary is currently in use.  */
name|char
name|in_use
decl_stmt|;
comment|/* Non-zero if this temporary has its address taken.  */
name|char
name|addr_taken
decl_stmt|;
comment|/* Nesting level at which this slot is being used.  */
name|int
name|level
decl_stmt|;
comment|/* Non-zero if this should survive a call to free_temp_slots.  */
name|int
name|keep
decl_stmt|;
comment|/* The offset of the slot from the frame_pointer, including extra space      for alignment.  This info is for combine_temp_slots.  */
name|int
name|base_offset
decl_stmt|;
comment|/* The size of the slot, including extra space for alignment.  This      info is for combine_temp_slots.  */
name|int
name|full_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of all temporaries allocated, both available and in use.  */
end_comment

begin_decl_stmt
name|struct
name|temp_slot
modifier|*
name|temp_slots
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current nesting level for temporaries.  */
end_comment

begin_decl_stmt
name|int
name|temp_slot_level
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The FUNCTION_DECL node for the current function.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|this_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callinfo pointer for the current function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|this_function_callinfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The label in the bytecode file of this function's actual bytecode.    Not an rtx.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|this_function_bytecode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The call description vector for the current function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|this_function_calldesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the local variables allocated for the current function.  */
end_comment

begin_decl_stmt
name|int
name|local_vars_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current depth of the bytecode evaluation stack.  */
end_comment

begin_decl_stmt
name|int
name|stack_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum depth of the evaluation stack in this function.  */
end_comment

begin_decl_stmt
name|int
name|max_stack_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current depth in statement expressions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stmt_expr_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used to record MEMs or pseudos used to replace VAR, any    SUBREGs of VAR, and any MEMs containing VAR as an address.  We need to    maintain this list in case two operands of an insn were required to match;    in that case we must ensure we use the same replacement.  */
end_comment

begin_struct
struct|struct
name|fixup_replacement
block|{
name|rtx
name|old
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|struct
name|fixup_replacement
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|temp_slot
modifier|*
name|find_temp_slot_from_address
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|put_reg_into_stack
name|PROTO
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|,
name|rtx
operator|,
name|tree
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_var_refs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fixup_replacement
modifier|*
name|find_fixup_replacement
name|PROTO
argument_list|(
operator|(
expr|struct
name|fixup_replacement
operator|*
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_var_refs_insns
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_var_refs_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|,
expr|struct
name|fixup_replacement
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|fixup_memory_subreg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|walk_fixup_memory_subreg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|fixup_stack_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|optimize_bit_field
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|instantiate_decls
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|instantiate_decls_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|instantiate_decl
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|instantiate_virtual_regs_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_handlers
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pad_to_arg_alignment
name|PROTO
argument_list|(
operator|(
expr|struct
name|args_size
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pad_below
name|PROTO
argument_list|(
operator|(
expr|struct
name|args_size
operator|*
operator|,
expr|enum
name|machine_mode
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|round_down
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|round_trampoline_addr
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|blocks_nreverse
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|all_blocks
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|record_insns
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|contains
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Pointer to chain of `struct function' for containing functions.  */
end_comment

begin_decl_stmt
name|struct
name|function
modifier|*
name|outer_function_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a function decl for a containing function,    return the `struct function' for it.  */
end_comment

begin_function
name|struct
name|function
modifier|*
name|find_function_data
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|struct
name|function
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|outer_function_chain
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|decl
operator|==
name|decl
condition|)
return|return
name|p
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the current context for compilation of a nested function.    This is called from language-specific code.    The caller is responsible for saving any language-specific status,    since this function knows only about language-independent variables.  */
end_comment

begin_function
name|void
name|push_function_context_to
parameter_list|(
name|context
parameter_list|)
name|tree
name|context
decl_stmt|;
block|{
name|struct
name|function
modifier|*
name|p
init|=
operator|(
expr|struct
name|function
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|next
operator|=
name|outer_function_chain
expr_stmt|;
name|outer_function_chain
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|current_function_name
expr_stmt|;
name|p
operator|->
name|decl
operator|=
name|current_function_decl
expr_stmt|;
name|p
operator|->
name|pops_args
operator|=
name|current_function_pops_args
expr_stmt|;
name|p
operator|->
name|returns_struct
operator|=
name|current_function_returns_struct
expr_stmt|;
name|p
operator|->
name|returns_pcc_struct
operator|=
name|current_function_returns_pcc_struct
expr_stmt|;
name|p
operator|->
name|needs_context
operator|=
name|current_function_needs_context
expr_stmt|;
name|p
operator|->
name|calls_setjmp
operator|=
name|current_function_calls_setjmp
expr_stmt|;
name|p
operator|->
name|calls_longjmp
operator|=
name|current_function_calls_longjmp
expr_stmt|;
name|p
operator|->
name|calls_alloca
operator|=
name|current_function_calls_alloca
expr_stmt|;
name|p
operator|->
name|has_nonlocal_label
operator|=
name|current_function_has_nonlocal_label
expr_stmt|;
name|p
operator|->
name|has_nonlocal_goto
operator|=
name|current_function_has_nonlocal_goto
expr_stmt|;
name|p
operator|->
name|contains_functions
operator|=
name|current_function_contains_functions
expr_stmt|;
name|p
operator|->
name|args_size
operator|=
name|current_function_args_size
expr_stmt|;
name|p
operator|->
name|pretend_args_size
operator|=
name|current_function_pretend_args_size
expr_stmt|;
name|p
operator|->
name|arg_offset_rtx
operator|=
name|current_function_arg_offset_rtx
expr_stmt|;
name|p
operator|->
name|varargs
operator|=
name|current_function_varargs
expr_stmt|;
name|p
operator|->
name|stdarg
operator|=
name|current_function_stdarg
expr_stmt|;
name|p
operator|->
name|uses_const_pool
operator|=
name|current_function_uses_const_pool
expr_stmt|;
name|p
operator|->
name|uses_pic_offset_table
operator|=
name|current_function_uses_pic_offset_table
expr_stmt|;
name|p
operator|->
name|internal_arg_pointer
operator|=
name|current_function_internal_arg_pointer
expr_stmt|;
name|p
operator|->
name|max_parm_reg
operator|=
name|max_parm_reg
expr_stmt|;
name|p
operator|->
name|parm_reg_stack_loc
operator|=
name|parm_reg_stack_loc
expr_stmt|;
name|p
operator|->
name|outgoing_args_size
operator|=
name|current_function_outgoing_args_size
expr_stmt|;
name|p
operator|->
name|return_rtx
operator|=
name|current_function_return_rtx
expr_stmt|;
name|p
operator|->
name|nonlocal_goto_handler_slot
operator|=
name|nonlocal_goto_handler_slot
expr_stmt|;
name|p
operator|->
name|nonlocal_goto_stack_level
operator|=
name|nonlocal_goto_stack_level
expr_stmt|;
name|p
operator|->
name|nonlocal_labels
operator|=
name|nonlocal_labels
expr_stmt|;
name|p
operator|->
name|cleanup_label
operator|=
name|cleanup_label
expr_stmt|;
name|p
operator|->
name|return_label
operator|=
name|return_label
expr_stmt|;
name|p
operator|->
name|save_expr_regs
operator|=
name|save_expr_regs
expr_stmt|;
name|p
operator|->
name|stack_slot_list
operator|=
name|stack_slot_list
expr_stmt|;
name|p
operator|->
name|parm_birth_insn
operator|=
name|parm_birth_insn
expr_stmt|;
name|p
operator|->
name|frame_offset
operator|=
name|frame_offset
expr_stmt|;
name|p
operator|->
name|tail_recursion_label
operator|=
name|tail_recursion_label
expr_stmt|;
name|p
operator|->
name|tail_recursion_reentry
operator|=
name|tail_recursion_reentry
expr_stmt|;
name|p
operator|->
name|arg_pointer_save_area
operator|=
name|arg_pointer_save_area
expr_stmt|;
name|p
operator|->
name|rtl_expr_chain
operator|=
name|rtl_expr_chain
expr_stmt|;
name|p
operator|->
name|last_parm_insn
operator|=
name|last_parm_insn
expr_stmt|;
name|p
operator|->
name|context_display
operator|=
name|context_display
expr_stmt|;
name|p
operator|->
name|trampoline_list
operator|=
name|trampoline_list
expr_stmt|;
name|p
operator|->
name|function_call_count
operator|=
name|function_call_count
expr_stmt|;
name|p
operator|->
name|temp_slots
operator|=
name|temp_slots
expr_stmt|;
name|p
operator|->
name|temp_slot_level
operator|=
name|temp_slot_level
expr_stmt|;
name|p
operator|->
name|fixup_var_refs_queue
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|epilogue_delay_list
operator|=
name|current_function_epilogue_delay_list
expr_stmt|;
name|save_tree_status
argument_list|(
name|p
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|save_storage_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|save_emit_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|init_emit
argument_list|()
expr_stmt|;
name|save_expr_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|save_stmt_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|save_varasm_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_machine_status
condition|)
call|(
modifier|*
name|save_machine_status
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_function_context
parameter_list|()
block|{
name|push_function_context_to
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the last saved context, at the end of a nested function.    This function is called from language-specific code.  */
end_comment

begin_function
name|void
name|pop_function_context_from
parameter_list|(
name|context
parameter_list|)
name|tree
name|context
decl_stmt|;
block|{
name|struct
name|function
modifier|*
name|p
init|=
name|outer_function_chain
decl_stmt|;
name|outer_function_chain
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|current_function_contains_functions
operator|=
name|p
operator|->
name|contains_functions
operator|||
name|p
operator|->
name|inline_obstacks
operator|||
name|context
operator|==
name|current_function_decl
expr_stmt|;
name|current_function_name
operator|=
name|p
operator|->
name|name
expr_stmt|;
name|current_function_decl
operator|=
name|p
operator|->
name|decl
expr_stmt|;
name|current_function_pops_args
operator|=
name|p
operator|->
name|pops_args
expr_stmt|;
name|current_function_returns_struct
operator|=
name|p
operator|->
name|returns_struct
expr_stmt|;
name|current_function_returns_pcc_struct
operator|=
name|p
operator|->
name|returns_pcc_struct
expr_stmt|;
name|current_function_needs_context
operator|=
name|p
operator|->
name|needs_context
expr_stmt|;
name|current_function_calls_setjmp
operator|=
name|p
operator|->
name|calls_setjmp
expr_stmt|;
name|current_function_calls_longjmp
operator|=
name|p
operator|->
name|calls_longjmp
expr_stmt|;
name|current_function_calls_alloca
operator|=
name|p
operator|->
name|calls_alloca
expr_stmt|;
name|current_function_has_nonlocal_label
operator|=
name|p
operator|->
name|has_nonlocal_label
expr_stmt|;
name|current_function_has_nonlocal_goto
operator|=
name|p
operator|->
name|has_nonlocal_goto
expr_stmt|;
name|current_function_args_size
operator|=
name|p
operator|->
name|args_size
expr_stmt|;
name|current_function_pretend_args_size
operator|=
name|p
operator|->
name|pretend_args_size
expr_stmt|;
name|current_function_arg_offset_rtx
operator|=
name|p
operator|->
name|arg_offset_rtx
expr_stmt|;
name|current_function_varargs
operator|=
name|p
operator|->
name|varargs
expr_stmt|;
name|current_function_stdarg
operator|=
name|p
operator|->
name|stdarg
expr_stmt|;
name|current_function_uses_const_pool
operator|=
name|p
operator|->
name|uses_const_pool
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
name|p
operator|->
name|uses_pic_offset_table
expr_stmt|;
name|current_function_internal_arg_pointer
operator|=
name|p
operator|->
name|internal_arg_pointer
expr_stmt|;
name|max_parm_reg
operator|=
name|p
operator|->
name|max_parm_reg
expr_stmt|;
name|parm_reg_stack_loc
operator|=
name|p
operator|->
name|parm_reg_stack_loc
expr_stmt|;
name|current_function_outgoing_args_size
operator|=
name|p
operator|->
name|outgoing_args_size
expr_stmt|;
name|current_function_return_rtx
operator|=
name|p
operator|->
name|return_rtx
expr_stmt|;
name|nonlocal_goto_handler_slot
operator|=
name|p
operator|->
name|nonlocal_goto_handler_slot
expr_stmt|;
name|nonlocal_goto_stack_level
operator|=
name|p
operator|->
name|nonlocal_goto_stack_level
expr_stmt|;
name|nonlocal_labels
operator|=
name|p
operator|->
name|nonlocal_labels
expr_stmt|;
name|cleanup_label
operator|=
name|p
operator|->
name|cleanup_label
expr_stmt|;
name|return_label
operator|=
name|p
operator|->
name|return_label
expr_stmt|;
name|save_expr_regs
operator|=
name|p
operator|->
name|save_expr_regs
expr_stmt|;
name|stack_slot_list
operator|=
name|p
operator|->
name|stack_slot_list
expr_stmt|;
name|parm_birth_insn
operator|=
name|p
operator|->
name|parm_birth_insn
expr_stmt|;
name|frame_offset
operator|=
name|p
operator|->
name|frame_offset
expr_stmt|;
name|tail_recursion_label
operator|=
name|p
operator|->
name|tail_recursion_label
expr_stmt|;
name|tail_recursion_reentry
operator|=
name|p
operator|->
name|tail_recursion_reentry
expr_stmt|;
name|arg_pointer_save_area
operator|=
name|p
operator|->
name|arg_pointer_save_area
expr_stmt|;
name|rtl_expr_chain
operator|=
name|p
operator|->
name|rtl_expr_chain
expr_stmt|;
name|last_parm_insn
operator|=
name|p
operator|->
name|last_parm_insn
expr_stmt|;
name|context_display
operator|=
name|p
operator|->
name|context_display
expr_stmt|;
name|trampoline_list
operator|=
name|p
operator|->
name|trampoline_list
expr_stmt|;
name|function_call_count
operator|=
name|p
operator|->
name|function_call_count
expr_stmt|;
name|temp_slots
operator|=
name|p
operator|->
name|temp_slots
expr_stmt|;
name|temp_slot_level
operator|=
name|p
operator|->
name|temp_slot_level
expr_stmt|;
name|current_function_epilogue_delay_list
operator|=
name|p
operator|->
name|epilogue_delay_list
expr_stmt|;
name|reg_renumber
operator|=
literal|0
expr_stmt|;
name|restore_tree_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|restore_storage_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|restore_expr_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|restore_emit_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|restore_stmt_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|restore_varasm_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_machine_status
condition|)
call|(
modifier|*
name|restore_machine_status
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Finish doing put_var_into_stack for any of our variables      which became addressable during the nested function.  */
block|{
name|struct
name|var_refs_queue
modifier|*
name|queue
init|=
name|p
operator|->
name|fixup_var_refs_queue
decl_stmt|;
for|for
control|(
init|;
name|queue
condition|;
name|queue
operator|=
name|queue
operator|->
name|next
control|)
name|fixup_var_refs
argument_list|(
name|queue
operator|->
name|modified
argument_list|,
name|queue
operator|->
name|promoted_mode
argument_list|,
name|queue
operator|->
name|unsignedp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Reset variables that have known state during rtx generation.  */
name|rtx_equal_function_value_matters
operator|=
literal|1
expr_stmt|;
name|virtuals_instantiated
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_function_context
parameter_list|()
block|{
name|pop_function_context_from
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate fixed slots in the stack frame of the current function.  */
end_comment

begin_comment
comment|/* Return size needed for stack frame based on slots so far allocated.    This size counts from zero.  It is not rounded to STACK_BOUNDARY;    the caller may have to do that.  */
end_comment

begin_function
name|int
name|get_frame_size
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
return|return
operator|-
name|frame_offset
return|;
else|#
directive|else
return|return
name|frame_offset
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Allocate a stack slot of SIZE bytes and return a MEM rtx for it    with machine mode MODE.        ALIGN controls the amount of alignment for the address of the slot:    0 means according to MODE,    -1 means use BIGGEST_ALIGNMENT and round size to multiple of that,    positive specifies alignment boundary in bits.     We do not round to stack_boundary here.  */
end_comment

begin_function
name|rtx
name|assign_stack_local
parameter_list|(
name|mode
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|bigend_correction
init|=
literal|0
decl_stmt|;
name|int
name|alignment
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|0
condition|)
block|{
name|alignment
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|==
operator|-
literal|1
condition|)
block|{
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|size
operator|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
else|else
name|alignment
operator|=
name|align
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Round frame offset to that alignment.      We must be careful here, since FRAME_OFFSET might be negative and      division with a negative dividend isn't as well defined as we might      like.  So we instead assume that ALIGNMENT is a power of two and      use logical operations which are unambiguous.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|frame_offset
operator|=
name|FLOOR_ROUND
argument_list|(
name|frame_offset
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
else|#
directive|else
name|frame_offset
operator|=
name|CEIL_ROUND
argument_list|(
name|frame_offset
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* On a big-endian machine, if we are allocating more space than we will use,      use the least significant bytes of those that are allocated.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
name|bigend_correction
operator|=
name|size
operator|-
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|frame_offset
operator|-=
name|size
expr_stmt|;
endif|#
directive|endif
comment|/* If we have already instantiated virtual registers, return the actual      address relative to the frame pointer.  */
if|if
condition|(
name|virtuals_instantiated
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer_rtx
argument_list|,
operator|(
name|frame_offset
operator|+
name|bigend_correction
operator|+
name|STARTING_FRAME_OFFSET
operator|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|plus_constant
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|frame_offset
operator|+
name|bigend_correction
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FRAME_GROWS_DOWNWARD
name|frame_offset
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|stack_slot_list
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|stack_slot_list
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Assign a stack slot in a containing function.    First three arguments are same as in preceding function.    The last argument specifies the function to allocate in.  */
end_comment

begin_function
name|rtx
name|assign_outer_stack_local
parameter_list|(
name|mode
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|,
name|function
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
name|struct
name|function
modifier|*
name|function
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|bigend_correction
init|=
literal|0
decl_stmt|;
name|int
name|alignment
decl_stmt|;
comment|/* Allocate in the memory associated with the function in whose frame      we are assigning.  */
name|push_obstacks
argument_list|(
name|function
operator|->
name|function_obstack
argument_list|,
name|function
operator|->
name|function_maybepermanent_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|==
literal|0
condition|)
block|{
name|alignment
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|==
operator|-
literal|1
condition|)
block|{
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|size
operator|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
else|else
name|alignment
operator|=
name|align
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Round frame offset to that alignment.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|function
operator|->
name|frame_offset
operator|=
name|FLOOR_ROUND
argument_list|(
name|function
operator|->
name|frame_offset
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
else|#
directive|else
name|function
operator|->
name|frame_offset
operator|=
name|CEIL_ROUND
argument_list|(
name|function
operator|->
name|frame_offset
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* On a big-endian machine, if we are allocating more space than we will use,      use the least significant bytes of those that are allocated.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
name|bigend_correction
operator|=
name|size
operator|-
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|function
operator|->
name|frame_offset
operator|-=
name|size
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|plus_constant
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|function
operator|->
name|frame_offset
operator|+
name|bigend_correction
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FRAME_GROWS_DOWNWARD
name|function
operator|->
name|frame_offset
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|function
operator|->
name|stack_slot_list
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|function
operator|->
name|stack_slot_list
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a temporary stack slot and record it for possible later    reuse.     MODE is the machine mode to be given to the returned rtx.     SIZE is the size in units of the space required.  We do no rounding here    since assign_stack_local will do any required rounding.     KEEP is 1 if this slot is to be retained after a call to    free_temp_slots.  Automatic variables for a block are allocated    with this flag.  KEEP is 2, if we allocate a longer term temporary,    whose lifetime is controlled by CLEANUP_POINT_EXPRs.  */
end_comment

begin_function
name|rtx
name|assign_stack_temp
parameter_list|(
name|mode
parameter_list|,
name|size
parameter_list|,
name|keep
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|keep
decl_stmt|;
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|,
modifier|*
name|best_p
init|=
literal|0
decl_stmt|;
comment|/* If SIZE is -1 it means that somebody tried to allocate a temporary      of a variable size.  */
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* First try to find an available, already-allocated temporary that is the      exact size we require.  */
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|size
operator|==
name|size
operator|&&
name|GET_MODE
argument_list|(
name|p
operator|->
name|slot
argument_list|)
operator|==
name|mode
operator|&&
operator|!
name|p
operator|->
name|in_use
condition|)
break|break;
comment|/* If we didn't find, one, try one that is larger than what we want.  We      find the smallest such.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|size
operator|>
name|size
operator|&&
name|GET_MODE
argument_list|(
name|p
operator|->
name|slot
argument_list|)
operator|==
name|mode
operator|&&
operator|!
name|p
operator|->
name|in_use
operator|&&
operator|(
name|best_p
operator|==
literal|0
operator|||
name|best_p
operator|->
name|size
operator|>
name|p
operator|->
name|size
operator|)
condition|)
name|best_p
operator|=
name|p
expr_stmt|;
comment|/* Make our best, if any, the one to use.  */
if|if
condition|(
name|best_p
condition|)
block|{
comment|/* If there are enough aligned bytes left over, make them into a new 	 temp_slot so that the extra bytes don't get wasted.  Do this only 	 for BLKmode slots, so that we can be sure of the alignment.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|best_p
operator|->
name|slot
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|int
name|alignment
init|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|rounded_size
init|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
if|if
condition|(
name|best_p
operator|->
name|size
operator|-
name|rounded_size
operator|>=
name|alignment
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|temp_slot
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_slot
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|in_use
operator|=
name|p
operator|->
name|addr_taken
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|best_p
operator|->
name|size
operator|-
name|rounded_size
expr_stmt|;
name|p
operator|->
name|base_offset
operator|=
name|best_p
operator|->
name|base_offset
operator|+
name|rounded_size
expr_stmt|;
name|p
operator|->
name|full_size
operator|=
name|best_p
operator|->
name|full_size
operator|-
name|rounded_size
expr_stmt|;
name|p
operator|->
name|slot
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|best_p
operator|->
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rounded_size
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rtl_expr
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|temp_slots
expr_stmt|;
name|temp_slots
operator|=
name|p
expr_stmt|;
name|stack_slot_list
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|p
operator|->
name|slot
argument_list|,
name|stack_slot_list
argument_list|)
expr_stmt|;
name|best_p
operator|->
name|size
operator|=
name|rounded_size
expr_stmt|;
name|best_p
operator|->
name|full_size
operator|=
name|rounded_size
expr_stmt|;
block|}
block|}
name|p
operator|=
name|best_p
expr_stmt|;
block|}
comment|/* If we still didn't find one, make a new temporary.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|int
name|frame_offset_old
init|=
name|frame_offset
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|temp_slot
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_slot
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the temp slot mode doesn't indicate the alignment, 	 use the largest possible, so no one will be disappointed.  */
name|p
operator|->
name|slot
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
name|mode
operator|==
name|BLKmode
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* The following slot size computation is necessary because we don't 	 know the actual size of the temporary slot until assign_stack_local 	 has performed all the frame alignment and size rounding for the 	 requested temporary.  Note that extra space added for alignment 	 can be either above or below this stack slot depending on which 	 way the frame grows.  We include the extra space if and only if it 	 is above this slot.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|p
operator|->
name|size
operator|=
name|frame_offset_old
operator|-
name|frame_offset
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|size
operator|=
name|size
expr_stmt|;
endif|#
directive|endif
comment|/* Now define the fields used by combine_temp_slots.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|p
operator|->
name|base_offset
operator|=
name|frame_offset
expr_stmt|;
name|p
operator|->
name|full_size
operator|=
name|frame_offset_old
operator|-
name|frame_offset
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|base_offset
operator|=
name|frame_offset_old
expr_stmt|;
name|p
operator|->
name|full_size
operator|=
name|frame_offset
operator|-
name|frame_offset_old
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|temp_slots
expr_stmt|;
name|temp_slots
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|->
name|in_use
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|addr_taken
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rtl_expr
operator|=
name|sequence_rtl_expr
expr_stmt|;
if|if
condition|(
name|keep
operator|==
literal|2
condition|)
block|{
name|p
operator|->
name|level
operator|=
name|target_temp_slot_level
expr_stmt|;
name|p
operator|->
name|keep
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|level
operator|=
name|temp_slot_level
expr_stmt|;
name|p
operator|->
name|keep
operator|=
name|keep
expr_stmt|;
block|}
return|return
name|p
operator|->
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Combine temporary stack slots which are adjacent on the stack.     This allows for better use of already allocated stack space.  This is only    done for BLKmode slots because we can be sure that we won't have alignment    problems in this case.  */
end_comment

begin_function
name|void
name|combine_temp_slots
parameter_list|()
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|temp_slot
modifier|*
name|prev_p
decl_stmt|,
modifier|*
name|prev_q
decl_stmt|;
comment|/* Determine where to free back to after this function.  */
name|rtx
name|free_pointer
init|=
name|rtx_alloc
argument_list|(
name|CONST_INT
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|temp_slots
operator|,
name|prev_p
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|prev_p
condition|?
name|prev_p
operator|->
name|next
else|:
name|temp_slots
control|)
block|{
name|int
name|delete_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|in_use
operator|&&
name|GET_MODE
argument_list|(
name|p
operator|->
name|slot
argument_list|)
operator|==
name|BLKmode
condition|)
for|for
control|(
name|q
operator|=
name|p
operator|->
name|next
operator|,
name|prev_q
operator|=
name|p
init|;
name|q
condition|;
name|q
operator|=
name|prev_q
operator|->
name|next
control|)
block|{
name|int
name|delete_q
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|in_use
operator|&&
name|GET_MODE
argument_list|(
name|q
operator|->
name|slot
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|base_offset
operator|+
name|p
operator|->
name|full_size
operator|==
name|q
operator|->
name|base_offset
condition|)
block|{
comment|/* Q comes after P; combine Q into P.  */
name|p
operator|->
name|size
operator|+=
name|q
operator|->
name|size
expr_stmt|;
name|p
operator|->
name|full_size
operator|+=
name|q
operator|->
name|full_size
expr_stmt|;
name|delete_q
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|base_offset
operator|+
name|q
operator|->
name|full_size
operator|==
name|p
operator|->
name|base_offset
condition|)
block|{
comment|/* P comes after Q; combine P into Q.  */
name|q
operator|->
name|size
operator|+=
name|p
operator|->
name|size
expr_stmt|;
name|q
operator|->
name|full_size
operator|+=
name|p
operator|->
name|full_size
expr_stmt|;
name|delete_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Either delete Q or advance past it.  */
if|if
condition|(
name|delete_q
condition|)
name|prev_q
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
else|else
name|prev_q
operator|=
name|q
expr_stmt|;
block|}
comment|/* Either delete P or advance past it.  */
if|if
condition|(
name|delete_p
condition|)
block|{
if|if
condition|(
name|prev_p
condition|)
name|prev_p
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|temp_slots
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
else|else
name|prev_p
operator|=
name|p
expr_stmt|;
block|}
comment|/* Free all the RTL made by plus_constant.  */
name|rtx_free
argument_list|(
name|free_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the temp slot corresponding to the object at address X.  */
end_comment

begin_function
specifier|static
name|struct
name|temp_slot
modifier|*
name|find_temp_slot_from_address
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
name|rtx
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|in_use
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|p
operator|->
name|slot
argument_list|,
literal|0
argument_list|)
operator|==
name|x
operator|||
name|p
operator|->
name|address
operator|==
name|x
condition|)
return|return
name|p
return|;
elseif|else
if|if
condition|(
name|p
operator|->
name|address
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|p
operator|->
name|address
argument_list|)
operator|==
name|EXPR_LIST
condition|)
for|for
control|(
name|next
operator|=
name|p
operator|->
name|address
init|;
name|next
condition|;
name|next
operator|=
name|XEXP
argument_list|(
name|next
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|)
operator|==
name|x
condition|)
return|return
name|p
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Indicate that NEW is an alternate way of referring to the temp slot    that previous was known by OLD.  */
end_comment

begin_function
name|void
name|update_temp_slot_address
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|rtx
name|old
decl_stmt|,
name|new
decl_stmt|;
block|{
name|struct
name|temp_slot
modifier|*
name|p
init|=
name|find_temp_slot_from_address
argument_list|(
name|old
argument_list|)
decl_stmt|;
comment|/* If none, return.  Else add NEW as an alias.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|p
operator|->
name|address
operator|==
literal|0
condition|)
name|p
operator|->
name|address
operator|=
name|new
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|address
argument_list|)
operator|!=
name|EXPR_LIST
condition|)
name|p
operator|->
name|address
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|p
operator|->
name|address
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|p
operator|->
name|address
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|new
argument_list|,
name|p
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If X could be a reference to a temporary slot, mark the fact that its    address was taken.  */
end_comment

begin_function
name|void
name|mark_temp_addr_taken
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
comment|/* If X is not in memory or is at a constant address, it cannot be in      a temporary slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return;
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
name|p
operator|->
name|addr_taken
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If X could be a reference to a temporary slot, mark that slot as belonging    to the to one level higher.  If X matched one of our slots, just mark that    one.  Otherwise, we can't easily predict which it is, so upgrade all of    them.  Kept slots need not be touched.     This is called when an ({...}) construct occurs and a statement    returns a value in memory.  */
end_comment

begin_function
name|void
name|preserve_temp_slots
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|temp_slot
modifier|*
name|p
init|=
literal|0
decl_stmt|;
comment|/* If there is no result, we still might have some objects whose address      were taken, so we need to make sure they stay around.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
name|p
operator|->
name|addr_taken
condition|)
name|p
operator|->
name|level
operator|--
expr_stmt|;
return|return;
block|}
comment|/* If X is a register that is being used as a pointer, see if we have      a temporary slot we know it points to.  To be consistent with      the code below, we really should preserve all non-kept slots      if we can't find a match, but that seems to be much too costly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If X is not in memory or is at a constant address, it cannot be in      a temporary slot, but it can contain something whose address was      taken.  */
if|if
condition|(
name|p
operator|==
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
name|p
operator|->
name|addr_taken
condition|)
name|p
operator|->
name|level
operator|--
expr_stmt|;
return|return;
block|}
comment|/* First see if we can find a match.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
comment|/* Move everything at our level whose address was taken to our new 	 level in case we used its address.  */
name|struct
name|temp_slot
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|temp_slots
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|!=
name|p
operator|&&
name|q
operator|->
name|addr_taken
operator|&&
name|q
operator|->
name|level
operator|==
name|p
operator|->
name|level
condition|)
name|q
operator|->
name|level
operator|--
expr_stmt|;
name|p
operator|->
name|level
operator|--
expr_stmt|;
name|p
operator|->
name|addr_taken
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, preserve all non-kept slots at this level.  */
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
operator|!
name|p
operator|->
name|keep
condition|)
name|p
operator|->
name|level
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* X is the result of an RTL_EXPR.  If it is a temporary slot associated    with that RTL_EXPR, promote it into a temporary slot at the present    level so it will not be freed when we free slots made in the    RTL_EXPR.  */
end_comment

begin_function
name|void
name|preserve_rtl_expr_result
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
comment|/* If X is not in memory or is at a constant address, it cannot be in      a temporary slot.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* If we can find a match, move it to our level unless it is already at      an upper level.  */
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
name|p
operator|->
name|level
operator|=
name|MIN
argument_list|(
name|p
operator|->
name|level
argument_list|,
name|temp_slot_level
argument_list|)
expr_stmt|;
name|p
operator|->
name|rtl_expr
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Free all temporaries used so far.  This is normally called at the end    of generating code for a statement.  Don't free any temporaries    currently in use for an RTL_EXPR that hasn't yet been emitted.    We could eventually do better than this since it can be reused while    generating the same RTL_EXPR, but this is complex and probably not    worthwhile.  */
end_comment

begin_function
name|void
name|free_temp_slots
parameter_list|()
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
operator|!
name|p
operator|->
name|keep
operator|&&
name|p
operator|->
name|rtl_expr
operator|==
literal|0
condition|)
name|p
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
name|combine_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all temporary slots used in T, an RTL_EXPR node.  */
end_comment

begin_function
name|void
name|free_temps_for_rtl_expr
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|rtl_expr
operator|==
name|t
condition|)
name|p
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
name|combine_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push deeper into the nesting level for stack temporaries.  */
end_comment

begin_function
name|void
name|push_temp_slots
parameter_list|()
block|{
name|temp_slot_level
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a temporary nesting level.  All slots in use in the current level    are freed.  */
end_comment

begin_function
name|void
name|pop_temp_slots
parameter_list|()
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
name|p
operator|->
name|rtl_expr
operator|==
literal|0
condition|)
name|p
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
name|combine_temp_slots
argument_list|()
expr_stmt|;
name|temp_slot_level
operator|--
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Retroactively move an auto variable from a register to a stack slot.    This is done when an address-reference to the variable is seen.  */
end_comment

begin_function
name|void
name|put_var_into_stack
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|rtx
name|reg
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|,
name|decl_mode
decl_stmt|;
name|struct
name|function
modifier|*
name|function
init|=
literal|0
decl_stmt|;
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
return|return;
name|context
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Get the current rtl used for this object and it's original mode.  */
name|reg
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SAVE_EXPR
condition|?
name|SAVE_EXPR_RTL
argument_list|(
name|decl
argument_list|)
else|:
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* No need to do anything if decl has no rtx yet      since in that case caller is setting TREE_ADDRESSABLE      and a stack slot will be assigned when the rtl is made.  */
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
comment|/* Get the declared mode for this object.  */
name|decl_mode
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SAVE_EXPR
condition|?
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the mode it's actually stored in.  */
name|promoted_mode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* If this variable comes from an outer function,      find that function's saved context.  */
if|if
condition|(
name|context
operator|!=
name|current_function_decl
condition|)
for|for
control|(
name|function
operator|=
name|outer_function_chain
init|;
name|function
condition|;
name|function
operator|=
name|function
operator|->
name|next
control|)
if|if
condition|(
name|function
operator|->
name|decl
operator|==
name|context
condition|)
break|break;
comment|/* If this is a variable-size object with a pseudo to address it,      put that pseudo into the stack, if the var is nonlocal.  */
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl_mode
operator|=
name|promoted_mode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Now we should have a value that resides in one or more pseudo regs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
name|put_reg_into_stack
argument_list|(
name|function
argument_list|,
name|reg
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|promoted_mode
argument_list|,
name|decl_mode
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
comment|/* A CONCAT contains two pseudos; put them both in the stack. 	 We do it so they end up consecutive.  */
name|enum
name|machine_mode
name|part_mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|part_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
comment|/* Since part 0 should have a lower address, do it second.  */
name|put_reg_into_stack
argument_list|(
name|function
argument_list|,
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|part_type
argument_list|,
name|part_mode
argument_list|,
name|part_mode
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|put_reg_into_stack
argument_list|(
name|function
argument_list|,
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|part_type
argument_list|,
name|part_mode
argument_list|,
name|part_mode
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|put_reg_into_stack
argument_list|(
name|function
argument_list|,
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|part_type
argument_list|,
name|part_mode
argument_list|,
name|part_mode
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|put_reg_into_stack
argument_list|(
name|function
argument_list|,
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|part_type
argument_list|,
name|part_mode
argument_list|,
name|part_mode
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Change the CONCAT into a combined MEM for both parts.  */
name|PUT_CODE
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|reg
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The two parts are in memory order already. 	 Use the lower parts address as ours.  */
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Prevent sharing of rtl that might lose.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of put_var_into_stack.  This puts a single pseudo reg REG    into the stack frame of FUNCTION (0 means the current function).    DECL_MODE is the machine mode of the user-level data type.    PROMOTED_MODE is the machine mode of the register.    VOLATILE_P is nonzero if this is for a "volatile" decl.  */
end_comment

begin_function
specifier|static
name|void
name|put_reg_into_stack
parameter_list|(
name|function
parameter_list|,
name|reg
parameter_list|,
name|type
parameter_list|,
name|promoted_mode
parameter_list|,
name|decl_mode
parameter_list|,
name|volatile_p
parameter_list|)
name|struct
name|function
modifier|*
name|function
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|,
name|decl_mode
decl_stmt|;
name|int
name|volatile_p
decl_stmt|;
block|{
name|rtx
name|new
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|function
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|function
operator|->
name|max_parm_reg
condition|)
name|new
operator|=
name|function
operator|->
name|parm_reg_stack_loc
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
name|new
operator|=
name|assign_outer_stack_local
argument_list|(
name|decl_mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|decl_mode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|max_parm_reg
condition|)
name|new
operator|=
name|parm_reg_stack_loc
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
name|new
operator|=
name|assign_stack_local
argument_list|(
name|decl_mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|decl_mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|PUT_MODE
argument_list|(
name|reg
argument_list|,
name|decl_mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* `volatil' bit means one thing for MEMs, another entirely for REGs.  */
name|MEM_VOLATILE_P
argument_list|(
name|reg
argument_list|)
operator|=
name|volatile_p
expr_stmt|;
name|PUT_CODE
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components,      mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|reg
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Now make sure that all refs to the variable, previously made      when it was a register, are fixed up to be valid again.  */
if|if
condition|(
name|function
condition|)
block|{
name|struct
name|var_refs_queue
modifier|*
name|temp
decl_stmt|;
comment|/* Variable is inherited; fix it up when we get back to its function.  */
name|push_obstacks
argument_list|(
name|function
operator|->
name|function_obstack
argument_list|,
name|function
operator|->
name|function_maybepermanent_obstack
argument_list|)
expr_stmt|;
comment|/* See comment in restore_tree_status in tree.c for why this needs to be 	 on saveable obstack.  */
name|temp
operator|=
operator|(
expr|struct
name|var_refs_queue
operator|*
operator|)
name|savealloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|var_refs_queue
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|modified
operator|=
name|reg
expr_stmt|;
name|temp
operator|->
name|promoted_mode
operator|=
name|promoted_mode
expr_stmt|;
name|temp
operator|->
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|function
operator|->
name|fixup_var_refs_queue
expr_stmt|;
name|function
operator|->
name|fixup_var_refs_queue
operator|=
name|temp
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* Variable is local; fix it up now.  */
name|fixup_var_refs
argument_list|(
name|reg
argument_list|,
name|promoted_mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|fixup_var_refs
parameter_list|(
name|var
parameter_list|,
name|promoted_mode
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|var
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|tree
name|pending
decl_stmt|;
name|rtx
name|first_insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|sequence_stack
decl_stmt|;
name|tree
name|rtl_exps
init|=
name|rtl_expr_chain
decl_stmt|;
comment|/* Must scan all insns for stack-refs that exceed the limit.  */
name|fixup_var_refs_insns
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
name|first_insn
argument_list|,
name|stack
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
block|{
name|push_to_sequence
argument_list|(
name|stack
operator|->
name|first
argument_list|)
expr_stmt|;
name|fixup_var_refs_insns
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
name|stack
operator|->
name|first
argument_list|,
name|stack
operator|->
name|next
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Update remembered end of sequence 	 in case we added an insn at the end.  */
name|stack
operator|->
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Scan all waiting RTL_EXPRs too.  */
for|for
control|(
name|pending
operator|=
name|rtl_exps
init|;
name|pending
condition|;
name|pending
operator|=
name|TREE_CHAIN
argument_list|(
name|pending
argument_list|)
control|)
block|{
name|rtx
name|seq
init|=
name|RTL_EXPR_SEQUENCE
argument_list|(
name|TREE_VALUE
argument_list|(
name|pending
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
name|const0_rtx
operator|&&
name|seq
operator|!=
literal|0
condition|)
block|{
name|push_to_sequence
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|fixup_var_refs_insns
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* REPLACEMENTS is a pointer to a list of the struct fixup_replacement and X is    some part of an insn.  Return a struct fixup_replacement whose OLD    value is equal to X.  Allocate a new structure if no such entry exists. */
end_comment

begin_function
specifier|static
name|struct
name|fixup_replacement
modifier|*
name|find_fixup_replacement
parameter_list|(
name|replacements
parameter_list|,
name|x
parameter_list|)
name|struct
name|fixup_replacement
modifier|*
modifier|*
name|replacements
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|fixup_replacement
modifier|*
name|p
decl_stmt|;
comment|/* See if we have already replaced this.  */
for|for
control|(
name|p
operator|=
operator|*
name|replacements
init|;
name|p
operator|&&
name|p
operator|->
name|old
operator|!=
name|x
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|fixup_replacement
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fixup_replacement
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|old
operator|=
name|x
expr_stmt|;
name|p
operator|->
name|new
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|*
name|replacements
expr_stmt|;
operator|*
name|replacements
operator|=
name|p
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Scan the insn-chain starting with INSN for refs to VAR    and fix them up.  TOPLEVEL is nonzero if this chain is the    main chain of insns for the current function.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_var_refs_insns
parameter_list|(
name|var
parameter_list|,
name|promoted_mode
parameter_list|,
name|unsignedp
parameter_list|,
name|insn
parameter_list|,
name|toplevel
parameter_list|)
name|rtx
name|var
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|toplevel
decl_stmt|;
block|{
name|rtx
name|call_dest
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* If this is a CLOBBER of VAR, delete it.  	     If it has a REG_LIBCALL note, delete the REG_LIBCALL 	     and REG_RETVAL notes too.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|var
condition|)
block|{
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* The REG_LIBCALL note will go away since we are going to 		   turn INSN into a NOTE, so just delete the 		   corresponding REG_RETVAL note.  */
name|remove_note
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|find_reg_note
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In unoptimized compilation, we shouldn't call delete_insn 		 except in jump.c doing warnings.  */
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The insn to load VAR from a home in the arglist 	     is now a no-op.  When we see it, just delete it.  */
elseif|else
if|if
condition|(
name|toplevel
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|var
comment|/* If this represents the result of an insn group, 		      don't delete the insn.  */
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|==
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|var
argument_list|)
condition|)
block|{
comment|/* In unoptimized compilation, we shouldn't call delete_insn 		 except in jump.c doing warnings.  */
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|last_parm_insn
condition|)
name|last_parm_insn
operator|=
name|PREV_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|fixup_replacement
modifier|*
name|replacements
init|=
literal|0
decl_stmt|;
name|rtx
name|next_insn
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SMALL_REGISTER_CLASSES
comment|/* If the insn that copies the results of a CALL_INSN 		 into a pseudo now references VAR, we have to use an 		 intermediate pseudo since we want the life of the 		 return value register to be only a single insn.  		 If we don't use an intermediate pseudo, such things as 		 address computations to make the address of VAR valid 		 if it is not can be placed between the CALL_INSN and INSN.  		 To make sure this doesn't happen, we record the destination 		 of the CALL_INSN and see if the next insn uses both that 		 and VAR.  */
if|if
condition|(
name|call_dest
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|reg_mentioned_p
argument_list|(
name|var
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|call_dest
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|call_dest
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|call_dest
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|call_dest
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|call_dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|call_dest
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|call_dest
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* See if we have to do anything to INSN now that VAR is in 		 memory.  If it needs to be loaded into a pseudo, use a single 		 pseudo for the entire insn in case there is a MATCH_DUP 		 between two operands.  We pass a pointer to the head of 		 a list of struct fixup_replacements.  If fixup_var_refs_1 		 needs to allocate pseudos or replacement MEMs (for SUBREGs), 		 it will record them in this list. 		  		 If it allocated a pseudo for any replacement, we copy into 		 it here.  */
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
operator|&
name|replacements
argument_list|)
expr_stmt|;
comment|/* If this is last_parm_insn, and any instructions were output 		 after it to fix it up, then we must set last_parm_insn to 		 the last such instruction emitted.  */
if|if
condition|(
name|insn
operator|==
name|last_parm_insn
condition|)
name|last_parm_insn
operator|=
name|PREV_INSN
argument_list|(
name|next_insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|replacements
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|replacements
operator|->
name|new
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|insert_before
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* OLD might be a (subreg (mem)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|replacements
operator|->
name|old
argument_list|)
operator|==
name|SUBREG
condition|)
name|replacements
operator|->
name|old
operator|=
name|fixup_memory_subreg
argument_list|(
name|replacements
operator|->
name|old
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|replacements
operator|->
name|old
operator|=
name|fixup_stack_1
argument_list|(
name|replacements
operator|->
name|old
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insert_before
operator|=
name|insn
expr_stmt|;
comment|/* If we are changing the mode, do a conversion. 			 This might be wasteful, but combine.c will 			 eliminate much of the waste.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|replacements
operator|->
name|new
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|replacements
operator|->
name|old
argument_list|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|convert_move
argument_list|(
name|replacements
operator|->
name|new
argument_list|,
name|replacements
operator|->
name|old
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
else|else
name|seq
operator|=
name|gen_move_insn
argument_list|(
name|replacements
operator|->
name|new
argument_list|,
name|replacements
operator|->
name|old
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
block|}
name|replacements
operator|=
name|replacements
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Also fix up any invalid exprs in the REG_NOTES of this insn. 	     But don't touch other insns referred to by reg-notes; 	     we will get them elsewhere.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|!=
name|INSN_LIST
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* VAR is a MEM that used to be a pseudo register with mode PROMOTED_MODE.    See if the rtx expression at *LOC in INSN needs to be changed.       REPLACEMENTS is a pointer to a list head that starts out zero, but may    contain a list of original rtx's and replacements. If we find that we need    to modify this insn by replacing a memory reference with a pseudo or by    making a new MEM to implement a SUBREG, we consult that list to see if    we have already chosen a replacement. If none has already been allocated,    we allocate it and update the list.  fixup_var_refs_insns will copy VAR    or the SUBREG, as appropriate, to the pseudo.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_var_refs_1
parameter_list|(
name|var
parameter_list|,
name|promoted_mode
parameter_list|,
name|loc
parameter_list|,
name|insn
parameter_list|,
name|replacements
parameter_list|)
specifier|register
name|rtx
name|var
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|;
specifier|register
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|fixup_replacement
modifier|*
modifier|*
name|replacements
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|rtx
name|tem
decl_stmt|,
name|tem1
decl_stmt|;
name|struct
name|fixup_replacement
modifier|*
name|replacement
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
if|if
condition|(
name|var
operator|==
name|x
condition|)
block|{
comment|/* If we already have a replacement, use it.  Otherwise,  	     try to fix up this address in case it is invalid.  */
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
condition|)
block|{
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
return|return;
block|}
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
operator|=
name|x
operator|=
name|fixup_stack_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Unless we are forcing memory to register or we changed the mode, 	     we can leave things the way they are if the insn is valid.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_force_mem
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|promoted_mode
operator|&&
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|promoted_mode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If X contains VAR, we need to unshare it here so that we update 	 each occurrence separately.  But all identical MEMs in one insn 	 must be replaced with the same rtx because of the possibility of 	 MATCH_DUPs.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|var
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
operator|==
literal|0
condition|)
name|replacement
operator|->
name|new
operator|=
name|copy_most_rtx
argument_list|(
name|x
argument_list|,
name|var
argument_list|)
expr_stmt|;
operator|*
name|loc
operator|=
name|x
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
block|}
break|break;
case|case
name|REG
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
return|return;
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTRACT
case|:
comment|/* Note that in some cases those types of expressions are altered 	 by optimize_bit_field, and do not survive to get here.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|var
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|var
operator|)
condition|)
block|{
comment|/* Get TEM as a valid MEM in the mode presently in the insn.  	     We don't worry about the possibility of MATCH_DUP here; it 	     is highly unlikely and would be tricky to handle.  */
name|tem
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SUBREG
condition|)
name|tem
operator|=
name|fixup_memory_subreg
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fixup_stack_1
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Unless we want to load from memory, get TEM into the proper mode 	     for an extract from memory.  This can only be done if the 	     extract is at a constant position and length.  */
if|if
condition|(
operator|!
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wanted_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|machine_mode
name|is_mode
init|=
name|GET_MODE
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_extzv
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|wanted_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extv
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|wanted_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* If we have a narrower mode, we can do something.  */
if|if
condition|(
name|wanted_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|pos
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|old_pos
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|rtx
name|newmem
decl_stmt|;
comment|/* If the bytes and bits are counted differently, we 		     must adjust the offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|BITS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
name|pos
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_mode
argument_list|)
expr_stmt|;
name|newmem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|wanted_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* Make the change and see if the insn remains valid.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|newmem
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* Otherwise, restore old position.  XEXP (x, 0) will be 		     restored later.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|old_pos
expr_stmt|;
block|}
block|}
comment|/* If we get here, the bitfield extract insn can't accept a memory 	     reference.  Copy the input into a register.  */
name|tem1
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tem1
argument_list|,
name|tem
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|tem1
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|==
name|var
condition|)
block|{
comment|/* If this is a special SUBREG made because VAR was promoted 	     from a wider mode, replace it with VAR and call ourself 	     recursively, this time saying that the object previously 	     had its current mode (by virtue of the SUBREG).  */
if|if
condition|(
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|var
expr_stmt|;
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|loc
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this SUBREG makes VAR wider, it has become a paradoxical 	     SUBREG with VAR in memory, but these aren't allowed at this  	     stage of the compilation.  So load VAR into a pseudo and take 	     a SUBREG of that pseudo.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
operator|==
literal|0
condition|)
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
return|return;
block|}
comment|/* See if we have already found a replacement for this SUBREG. 	     If so, use it.  Otherwise, make a MEM and see if the insn 	     is recognized.  If not, or if we should force MEM into a register, 	     make a pseudo for this SUBREG.  */
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
condition|)
block|{
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
return|return;
block|}
name|replacement
operator|->
name|new
operator|=
operator|*
name|loc
operator|=
name|fixup_memory_subreg
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_force_mem
operator|&&
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SET
case|:
comment|/* First do special simplification of bit-field references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|optimize_bit_field
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|optimize_bit_field
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* If SET_DEST is now a paradoxical SUBREG, put the result of this 	 insn into a pseudo and store the low part of the pseudo into VAR. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|var
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|var
argument_list|,
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|outerdest
init|=
name|dest
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If VAR does not appear at the top level of the SET 	   just scan the lower levels of the tree.  */
if|if
condition|(
name|src
operator|!=
name|var
operator|&&
name|dest
operator|!=
name|var
condition|)
break|break;
comment|/* We will need to rerecognize this insn.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_insv
if|if
condition|(
name|GET_CODE
argument_list|(
name|outerdest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|dest
operator|==
name|var
condition|)
block|{
comment|/* Since this case will return, ensure we fixup all the 	       operands here.  */
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
name|tem
operator|=
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clean up (SUBREG:SI (MEM:mode ...) 0) 	       that may appear inside a ZERO_EXTRACT. 	       This was legitimate when the MEM was a REG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|tem
argument_list|)
operator|==
name|var
condition|)
name|tem
operator|=
name|fixup_memory_subreg
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|fixup_stack_1
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wanted_mode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|0
index|]
decl_stmt|;
name|enum
name|machine_mode
name|is_mode
init|=
name|GET_MODE
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If we have a narrower mode, we can do something.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|pos
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|old_pos
init|=
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|rtx
name|newmem
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|!=
name|BITS_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
name|pos
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_mode
argument_list|)
expr_stmt|;
name|newmem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|wanted_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* Make the change and see if the insn remains valid.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
operator|=
name|newmem
expr_stmt|;
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* Otherwise, restore old position.  XEXP (x, 0) will be 		       restored later.  */
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
operator|=
name|old_pos
expr_stmt|;
block|}
block|}
comment|/* If we get here, the bit-field store doesn't allow memory 	       or isn't located at a constant position.  Load the value into 	       a register, do the store, and put it back into memory.  */
name|tem1
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tem1
argument_list|,
name|tem
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|tem1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
operator|=
name|tem1
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* STRICT_LOW_PART is a no-op on memory references 	   and it can cause combinations to be unrecognizable, 	   so eliminate it.  */
if|if
condition|(
name|dest
operator|==
name|var
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A valid insn to copy VAR into or out of a register 	   must be left alone, to avoid an infinite loop here. 	   If the reference to VAR is by a subreg, fix that up, 	   since SUBREG is not valid for a memref. 	   Also fix up the address of the stack slot.  	   Note that we must not try to recognize the insn until 	   after we know that we have valid addresses and no 	   (subreg (mem ...) ...) constructs, since these interfere 	   with determining the validity of the insn.  */
if|if
condition|(
operator|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|==
name|var
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|var
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
name|x
operator|==
name|single_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|pat
decl_stmt|;
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
condition|)
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
operator|=
name|fixup_memory_subreg
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
operator|=
name|fixup_stack_1
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* INSN is not valid, but we know that we want to 	       copy SET_SRC (x) to SET_DEST (x) in some way.  So 	       we generate the move and see whether it requires more 	       than one insn.  If it does, we emit those insns and 	       delete INSN.  Otherwise, we an just replace the pattern  	       of INSN; we have already verified above that INSN has 	       no other function that to do X.  */
name|pat
operator|=
name|gen_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pat
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|var
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|var
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
name|x
operator|==
name|single_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|fixup_memory_subreg
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|fixup_stack_1
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
name|pat
operator|=
name|gen_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pat
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, storing into VAR must be handled specially 	   by storing into a temporary and copying that into VAR 	   with a new insn after this one.  Note that this case 	   will be used when storing into a promoted scalar since 	   the insn will now have different modes on the input 	   and output and hence will be invalid (except for the case 	   of setting it to a constant, which does not need any 	   change if it is valid).  We generate extra code in that case, 	   but combine.c will eliminate it.  */
if|if
condition|(
name|dest
operator|==
name|var
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|rtx
name|fixeddest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* STRICT_LOW_PART can be discarded, around a MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|fixeddest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|fixeddest
operator|=
name|XEXP
argument_list|(
name|fixeddest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert (SUBREG (MEM)) to a MEM in a changed mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|fixeddest
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|fixeddest
operator|=
name|fixup_memory_subreg
argument_list|(
name|fixeddest
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|promoted_mode
operator|=
name|GET_MODE
argument_list|(
name|fixeddest
argument_list|)
expr_stmt|;
block|}
else|else
name|fixeddest
operator|=
name|fixup_stack_1
argument_list|(
name|fixeddest
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|promoted_mode
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|fixeddest
argument_list|,
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|fixeddest
argument_list|)
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
comment|/* Nothing special about this RTX; fix its operands.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given X, an rtx of the form (SUBREG:m1 (MEM:m2 addr)),    return an rtx (MEM:m1 newaddr) which is equivalent.    If any insns must be emitted to compute NEWADDR, put them before INSN.     UNCRITICAL nonzero means accept paradoxical subregs.    This is used for subregs found inside of ZERO_EXTRACTs and in REG_NOTES. */
end_comment

begin_function
specifier|static
name|rtx
name|fixup_memory_subreg
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|uncritical
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|uncritical
decl_stmt|;
block|{
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|saved
decl_stmt|,
name|result
decl_stmt|;
comment|/* Paradoxical SUBREGs are usually invalid during RTL generation.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|uncritical
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_force_addr
operator|&&
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
comment|/* Shortcut if no insns need be emitted.  */
return|return
name|change_address
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|result
operator|=
name|change_address
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_sequence
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Do fixup_memory_subreg on all (SUBREG (MEM ...) ...) contained in X.    Replace subexpressions of X in place.    If X itself is a (SUBREG (MEM ...) ...), return the replacement expression.    Otherwise return X, with its contents possibly altered.     If any insns must be emitted to compute NEWADDR, put them before INSN.      UNCRITICAL is as in fixup_memory_subreg.  */
end_comment

begin_function
specifier|static
name|rtx
name|walk_fixup_memory_subreg
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|uncritical
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|uncritical
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|fixup_memory_subreg
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|uncritical
argument_list|)
return|;
comment|/* Nothing special about this RTX; fix its operands.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|uncritical
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|uncritical
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For each memory ref within X, if it refers to a stack slot    with an out of range displacement, put the address in a temp register    (emitting new insns before INSN to load these registers)    and alter the memory ref to use that register.    Replace each such MEM rtx with a copy, to avoid clobberage.  */
end_comment

begin_function
specifier|static
name|rtx
name|fixup_stack_1
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|ad
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we have address of a stack slot but it's not valid 	 (displacement is too large), compute the sum in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|||
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|temp
decl_stmt|,
name|seq
decl_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ad
argument_list|)
condition|)
return|return
name|x
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|ad
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|temp
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|fixup_stack_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|fixup_stack_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimization: a bit-field instruction whose field    happens to be a byte or halfword in memory    can be changed to a move instruction.     We call here when INSN is an insn to examine or store into a bit-field.    BODY is the SET-rtx to be altered.     EQUIV_MEM is the table `reg_equiv_mem' if that is available; else 0.    (Currently this is called only from function.c, and EQUIV_MEM    is always 0.)  */
end_comment

begin_function
specifier|static
name|void
name|optimize_bit_field
parameter_list|(
name|body
parameter_list|,
name|insn
parameter_list|,
name|equiv_mem
parameter_list|)
name|rtx
name|body
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|equiv_mem
decl_stmt|;
block|{
specifier|register
name|rtx
name|bitfield
decl_stmt|;
name|int
name|destflag
decl_stmt|;
name|rtx
name|seq
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|bitfield
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|,
name|destflag
operator|=
literal|1
expr_stmt|;
else|else
name|bitfield
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|,
name|destflag
operator|=
literal|0
expr_stmt|;
comment|/* First check that the field being stored has constant size and position      and is in fact a byte or halfword suitably aligned.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|mode
operator|=
name|mode_for_size
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|BLKmode
operator|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|%
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|rtx
name|memref
init|=
literal|0
decl_stmt|;
comment|/* Now check that the containing word is memory, not a register, 	 and that it is safe to change the machine mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|memref
operator|=
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|equiv_mem
operator|!=
literal|0
condition|)
name|memref
operator|=
name|equiv_mem
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|memref
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|equiv_mem
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|memref
operator|=
name|equiv_mem
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|memref
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|memref
argument_list|)
condition|)
block|{
comment|/* Now adjust the address, first for any subreg'ing 	     that we are now getting rid of, 	     and then for which byte of the word is wanted.  */
specifier|register
name|int
name|offset
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
comment|/* Adjust OFFSET to count bits from low-address byte.  */
if|if
condition|(
name|BITS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|offset
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Adjust OFFSET to count bytes from low-address byte.  */
name|offset
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|memref
operator|=
name|change_address
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Store this memory reference where 	     we found the bit field reference.  */
if|if
condition|(
name|destflag
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|,
name|memref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_WORD
argument_list|(
name|src
argument_list|)
operator|==
literal|0
condition|)
name|src
operator|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
name|src
operator|=
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
comment|/* This shouldn't happen because anything that didn't have 		   one of these modes should have got converted explicitly 		   and then referenced through a subreg. 		   This is so because the original bit-field was 		   handled by agg_mode and so its tree structure had 		   the same mode that memref now has.  */
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_WORD
argument_list|(
name|dest
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|,
name|dest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|memref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Convert the mem ref to the destination mode.  */
name|rtx
name|newreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|convert_move
argument_list|(
name|newreg
argument_list|,
name|memref
argument_list|,
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|newreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* See if we can convert this extraction or insertion into 	     a simple move insn.  We might not be able to do so if this 	     was, for example, part of a PARALLEL.  	     If we succeed, write out any needed conversions.  If we fail, 	     it is hard to guess why we failed, so don't do anything 	     special; just let the optimization be suppressed.  */
if|if
condition|(
name|apply_change_group
argument_list|()
operator|&&
name|seq
condition|)
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines are responsible for converting virtual register references    to the actual hard register references once RTL generation is complete.     The following four variables are used for communication between the    routines.  They contain the offsets of the virtual registers from their    respective hard registers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_arg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|var_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dynamic_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|out_arg_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In most machines, the stack pointer register is equivalent to the bottom    of the stack.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_POINTER_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|STACK_POINTER_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If not defined, pick an appropriate default for the offset of dynamically    allocated memory depending on the value of ACCUMULATE_OUTGOING_ARGS,    REG_PARM_STACK_SPACE, and OUTGOING_REG_PARM_STACK_SPACE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_DYNAMIC_OFFSET
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
end_ifdef

begin_comment
comment|/* The bottom of the stack points to the actual arguments.  If    REG_PARM_STACK_SPACE is defined, this includes the space for the register    parameters.  However, if OUTGOING_REG_PARM_STACK space is not defined,    stack space for register parameters is not pushed by the caller, but     rather part of the fixed stack areas and hence not included in    `current_function_outgoing_args_size'.  Nevertheless, we must allow    for it when allocating stack dynamic objects.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OUTGOING_REG_PARM_STACK_SPACE
argument_list|)
end_if

begin_define
define|#
directive|define
name|STACK_DYNAMIC_OFFSET
parameter_list|(
name|FNDECL
parameter_list|)
define|\
value|(current_function_outgoing_args_size	\  + REG_PARM_STACK_SPACE (FNDECL) + (STACK_POINTER_OFFSET))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_DYNAMIC_OFFSET
parameter_list|(
name|FNDECL
parameter_list|)
define|\
value|(current_function_outgoing_args_size + (STACK_POINTER_OFFSET))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_DYNAMIC_OFFSET
parameter_list|(
name|FNDECL
parameter_list|)
value|STACK_POINTER_OFFSET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pass through the INSNS of function FNDECL and convert virtual register    references to hard register references.  */
end_comment

begin_function
name|void
name|instantiate_virtual_regs
parameter_list|(
name|fndecl
parameter_list|,
name|insns
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Compute the offsets to use for this function.  */
name|in_arg_offset
operator|=
name|FIRST_PARM_OFFSET
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|var_offset
operator|=
name|STARTING_FRAME_OFFSET
expr_stmt|;
name|dynamic_offset
operator|=
name|STACK_DYNAMIC_OFFSET
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|out_arg_offset
operator|=
name|STACK_POINTER_OFFSET
expr_stmt|;
comment|/* Scan all variables and parameters of this function.  For each that is      in memory, instantiate all virtual registers if the result is a valid      address.  If not, we do it later.  That will handle most uses of virtual      regs on many machines.  */
name|instantiate_decls
argument_list|(
name|fndecl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize recognition, indicating that volatile is OK.  */
name|init_recog
argument_list|()
expr_stmt|;
comment|/* Scan through all the insns, instantiating every virtual register still      present.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now instantiate the remaining register equivalences for debugging info.      These will not be valid addresses.  */
name|instantiate_decls
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Indicate that, from now on, assign_stack_local should use      frame_pointer_rtx.  */
name|virtuals_instantiated
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan all decls in FNDECL (both variables and parameters) and instantiate    all virtual registers in their DECL_RTL's.     If VALID_ONLY, do this only if the resulting address is still valid.    Otherwise, always do it.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decls
parameter_list|(
name|fndecl
parameter_list|,
name|valid_only
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|int
name|valid_only
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DECL_DEFER_OUTPUT
argument_list|(
name|fndecl
argument_list|)
condition|)
comment|/* When compiling an inline function, the obstack used for        rtl allocation is the maybepermanent_obstack.  Calling        `resume_temporary_allocation' switches us back to that        obstack while we process this function's parameters.  */
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Process all parameters of the function.  */
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|instantiate_decl
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
name|instantiate_decl
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
block|}
comment|/* Now process all variables defined in the function or its subblocks. */
name|instantiate_decls_1
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DECL_DEFER_OUTPUT
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* Save all rtl allocated for this function by raising the 	 high-water mark on the maybepermanent_obstack.  */
name|preserve_data
argument_list|()
expr_stmt|;
comment|/* All further rtl allocation is now done in the current_obstack.  */
name|rtl_in_current_obstack
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of instantiate_decls: Process all decls in the given    BLOCK node and all its subblocks.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decls_1
parameter_list|(
name|let
parameter_list|,
name|valid_only
parameter_list|)
name|tree
name|let
decl_stmt|;
name|int
name|valid_only
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|instantiate_decl
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
comment|/* Process all subblocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|instantiate_decls_1
argument_list|(
name|t
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of the preceding procedures: Given RTL representing a    decl and the size of the object, do any instantiation required.     If VALID_ONLY is non-zero, it means that the RTL should only be    changed if the new address is valid.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decl
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|valid_only
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|valid_only
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* If this is not a MEM, no need to do anything.  Similarly if the      address is a constant or a register that is not a virtual register.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
name|addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|<
name|FIRST_VIRTUAL_REGISTER
operator|||
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
condition|)
return|return;
comment|/* If we should only do this if the address is valid, copy the address.      We need to do this so we can undo any changes that might make the      address invalid.  This copy is unfortunate, but probably can't be      avoided.  */
if|if
condition|(
name|valid_only
condition|)
name|addr
operator|=
name|copy_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|addr
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_only
condition|)
return|return;
comment|/* Now verify that the resulting address is valid for every integer or      floating-point mode up to and including SIZE bytes long.  We do this      since the object might be accessed in any mode and frame addresses      are shared.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|size
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
return|return;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|size
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
return|return;
comment|/* Otherwise, put back the address, now that we have updated it and we      know it is valid.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to a piece of rtx and an optional pointer to the    containing object, instantiate any virtual registers present in it.     If EXTRA_INSNS, we always do the replacement and generate    any extra insns before OBJECT.  If it zero, we do nothing if replacement    is not valid.     Return 1 if we either had nothing to do or if we were able to do the    needed replacement.  Return 0 otherwise; we only return zero if     EXTRA_INSNS is zero.     We first try some simple transformations to avoid the creation of extra    pseudos.  */
end_comment

begin_function
specifier|static
name|int
name|instantiate_virtual_regs_1
parameter_list|(
name|loc
parameter_list|,
name|object
parameter_list|,
name|extra_insns
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|object
decl_stmt|;
name|int
name|extra_insns
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Re-start here to avoid recursion in common cases.  */
name|restart
label|:
name|x
operator|=
operator|*
name|loc
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Check for some special cases.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|RETURN
case|:
return|return
literal|1
return|;
case|case
name|SET
case|:
comment|/* We are allowed to set the virtual registers.  This means that 	 that the actual register should receive the source minus the 	 appropriate offset.  This is used, for example, in the handling 	 of non-local gotos.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|virtual_incoming_args_rtx
condition|)
name|new
operator|=
name|arg_pointer_rtx
operator|,
name|offset
operator|=
operator|-
name|in_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|virtual_stack_vars_rtx
condition|)
name|new
operator|=
name|frame_pointer_rtx
operator|,
name|offset
operator|=
operator|-
name|var_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|virtual_stack_dynamic_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
operator|-
name|dynamic_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
operator|-
name|out_arg_offset
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
comment|/* The only valid sources here are PLUS or REG.  Just do 	     the simplest possible thing to handle them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|temp
operator|=
name|force_operand
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|temp
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|offset
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|new
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|extra_insns
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|PLUS
case|:
comment|/* Handle special case of virtual register plus constant.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|old
decl_stmt|,
name|new_offset
decl_stmt|;
comment|/* Check for (plus (plus VIRT foo) (const_int)) first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|inner
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|==
name|virtual_incoming_args_rtx
condition|)
name|new
operator|=
name|arg_pointer_rtx
operator|,
name|offset
operator|=
name|in_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|==
name|virtual_stack_vars_rtx
condition|)
name|new
operator|=
name|frame_pointer_rtx
operator|,
name|offset
operator|=
name|var_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|==
name|virtual_stack_dynamic_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|dynamic_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|==
name|virtual_outgoing_args_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|out_arg_offset
expr_stmt|;
else|else
block|{
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
condition|)
name|new
operator|=
name|arg_pointer_rtx
operator|,
name|offset
operator|=
name|in_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
condition|)
name|new
operator|=
name|frame_pointer_rtx
operator|,
name|offset
operator|=
name|var_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_dynamic_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|dynamic_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|out_arg_offset
expr_stmt|;
else|else
block|{
comment|/* We know the second operand is a constant.  Unless the 		 first operand is a REG (which has been already checked), 		 it needs to be checked.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
return|return
literal|1
return|;
block|}
name|new_offset
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* If the new constant is zero, try to replace the sum with just 	     the register.  */
if|if
condition|(
name|new_offset
operator|==
name|const0_rtx
operator|&&
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Next try to replace the register and new offset. 	     There are two changes to validate here and we can't assume that 	     in the case of old offset equals new just changing the register 	     will yield a valid insn.  In the interests of a little efficiency, 	     however, we only call validate change once (we don't queue up the 	     changes and then call apply_change_group). */
name|old
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|?
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
else|:
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|new
operator|,
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new_offset
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|extra_insns
condition|)
block|{
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|old
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Otherwise copy the new constant into a register and replace 		 constant with that register.  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
condition|)
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|new_offset
argument_list|)
argument_list|,
name|object
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If that didn't work, replace this expression with a 		     register containing the sum.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|old
expr_stmt|;
name|new
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|new
argument_list|,
name|new_offset
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|force_operand
argument_list|(
name|new
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|validate_replace_rtx
argument_list|(
name|x
argument_list|,
name|temp
argument_list|,
name|object
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/* Fall through to generic two-operand expression case.  */
case|case
name|EXPR_LIST
case|:
case|case
name|CALL
case|:
case|case
name|COMPARE
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ROTATERT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|MEM
case|:
comment|/* Most cases of MEM that convert to valid addresses have already been 	 handled by our scan of regno_reg_rtx.  The only special handling we 	 need here is to make a copy of the rtx to ensure it isn't being 	 shared if we have to change it to a pseudo.   	 If the rtx is a simple reference to an address via a virtual register, 	 it can potentially be shared.  In such cases, first try to make it 	 a valid address, which can also be shared.  Otherwise, copy it and 	 proceed normally.   	 First check for common cases that need no processing.  These are 	 usually due to instantiation already being done on a previous instance 	 of a shared rtx.  */
name|temp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|temp
argument_list|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|temp
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|||
name|temp
operator|==
name|hard_frame_pointer_rtx
endif|#
directive|endif
operator|||
name|temp
operator|==
name|frame_pointer_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|hard_frame_pointer_rtx
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|temp
operator|==
name|virtual_stack_vars_rtx
operator|||
name|temp
operator|==
name|virtual_incoming_args_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
operator|)
operator|)
condition|)
block|{
comment|/* This MEM may be shared.  If the substitution can be done without 	     the need to generate new pseudos, we want to do it in place 	     so all copies of the shared rtx benefit.  The call below will 	     only make substitutions if the resulting address is still 	     valid.  	     Note that we cannot pass X as the object in the recursive call 	     since the insn being processed may not allow all valid 	     addresses.  However, if we were not passed on object, we can 	     only modify X without copying it if X will have a valid 	     address.  	     ??? Also note that this can still lose if OBJECT is an insn that 	     has less restrictions on an address that some other insn. 	     In that case, we will modify the shared address.  This case 	     doesn't seem very likely, though.  */
if|if
condition|(
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|object
condition|?
name|object
else|:
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise make a copy and process that copy.  We copy the entire 	     RTL expression since it might be a PLUS which could also be 	     shared.  */
operator|*
name|loc
operator|=
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through to generic unary operation case.  */
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
case|case
name|SUBREG
case|:
case|case
name|STRICT_LOW_PART
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
comment|/* These case either have just one operand or we know that we need not 	 check the rest of the operands.  */
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|REG
case|:
comment|/* Try to replace with a PLUS.  If that doesn't work, compute the sum 	 in front of this insn and substitute the temporary.  */
if|if
condition|(
name|x
operator|==
name|virtual_incoming_args_rtx
condition|)
name|new
operator|=
name|arg_pointer_rtx
operator|,
name|offset
operator|=
name|in_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_stack_vars_rtx
condition|)
name|new
operator|=
name|frame_pointer_rtx
operator|,
name|offset
operator|=
name|var_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_stack_dynamic_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|dynamic_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_outgoing_args_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|out_arg_offset
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|temp
operator|=
name|plus_constant
argument_list|(
name|new
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|extra_insns
condition|)
return|return
literal|0
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|force_operand
argument_list|(
name|temp
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|validate_replace_rtx
argument_list|(
name|x
argument_list|,
name|temp
argument_list|,
name|object
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/* Scan all subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
operator|!
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimization: assuming this function does not receive nonlocal gotos,    delete the handlers for such, as well as the insns to establish    and disestablish them.  */
end_comment

begin_function
specifier|static
name|void
name|delete_handlers
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Delete the handler by turning off the flag that would 	 prevent jump_optimize from deleting it. 	 Also permit deletion of the nonlocal labels themselves 	 if nothing local refers to them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|tree
name|t
decl_stmt|,
name|last_t
decl_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Remove it from the nonlocal_label list, to avoid confusing 	     flow.  */
for|for
control|(
name|t
operator|=
name|nonlocal_labels
operator|,
name|last_t
operator|=
literal|0
init|;
name|t
condition|;
name|last_t
operator|=
name|t
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|insn
condition|)
break|break;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
operator|!
name|last_t
condition|)
name|nonlocal_labels
operator|=
name|TREE_CHAIN
argument_list|(
name|nonlocal_labels
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|last_t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
operator|(
name|nonlocal_goto_handler_slot
operator|!=
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|nonlocal_goto_handler_slot
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|nonlocal_goto_stack_level
operator|!=
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|nonlocal_goto_stack_level
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a list (chain of EXPR_LIST nodes) for the nonlocal labels    of the current function.  */
end_comment

begin_function
name|rtx
name|nonlocal_label_rtx_list
parameter_list|()
block|{
name|tree
name|t
decl_stmt|;
name|rtx
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|t
operator|=
name|nonlocal_labels
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|x
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|label_rtx
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a USE for any register use in RTL.    This is used with -noreg to mark the extent of lifespan    of any registers used in a user-visible variable's DECL_RTL.  */
end_comment

begin_function
name|void
name|use_variable
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|REG
condition|)
comment|/* This is a register variable.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_VIRTUAL_REGISTER
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
operator|&&
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
operator|!=
name|current_function_internal_arg_pointer
condition|)
comment|/* This is a variable-sized structure.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like use_variable except that it outputs the USEs after INSN    instead of at the end of the insn-chain.  */
end_comment

begin_function
name|void
name|use_variable_after
parameter_list|(
name|rtl
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|rtl
decl_stmt|,
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|REG
condition|)
comment|/* This is a register variable.  */
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|rtl
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_VIRTUAL_REGISTER
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
operator|&&
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
operator|!=
name|current_function_internal_arg_pointer
condition|)
comment|/* This is a variable-sized structure.  */
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|max_parm_reg_num
parameter_list|()
block|{
return|return
name|max_parm_reg
return|;
block|}
end_function

begin_comment
comment|/* Return the first insn following those generated by `assign_parms'.  */
end_comment

begin_function
name|rtx
name|get_first_nonparm_insn
parameter_list|()
block|{
if|if
condition|(
name|last_parm_insn
condition|)
return|return
name|NEXT_INSN
argument_list|(
name|last_parm_insn
argument_list|)
return|;
return|return
name|get_insns
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Return the first NOTE_INSN_BLOCK_BEG note in the function.    Crash if there is none.  */
end_comment

begin_function
name|rtx
name|get_first_block_beg
parameter_list|()
block|{
specifier|register
name|rtx
name|searcher
decl_stmt|;
specifier|register
name|rtx
name|insn
init|=
name|get_first_nonparm_insn
argument_list|()
decl_stmt|;
for|for
control|(
name|searcher
operator|=
name|insn
init|;
name|searcher
condition|;
name|searcher
operator|=
name|NEXT_INSN
argument_list|(
name|searcher
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|searcher
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|searcher
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
return|return
name|searcher
return|;
name|abort
argument_list|()
expr_stmt|;
comment|/* Invalid call to this function.  (See comments above.)  */
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXP is an aggregate type (or a value with aggregate type).    This means a type for which function calls must pass an address to the    function or get an address back from the function.    EXP may be a type node or an expression (whose type is tested).  */
end_comment

begin_function
name|int
name|aggregate_value_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|,
name|nregs
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|type
operator|=
name|exp
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|RETURN_IN_MEMORY
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flag_pcc_struct_return
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Make sure we have suitable call-clobbered regs to return      the value in; if not, we must return it in memory.  */
name|reg
operator|=
name|hard_function_value
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|regno
operator|+
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign RTL expressions to the function's parameters.    This may involve copying them into registers and using    those registers as the RTL for them.     If SECOND_TIME is non-zero it means that this function is being    called a second time.  This is done by integrate.c when a function's    compilation is deferred.  We need to come back here in case the    FUNCTION_ARG macro computes items needed for the rest of the compilation    (such as changing which registers are fixed or caller-saved).  But suppress    writing any insns or setting DECL_RTL of anything in this case.  */
end_comment

begin_function
name|void
name|assign_parms
parameter_list|(
name|fndecl
parameter_list|,
name|second_time
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|int
name|second_time
decl_stmt|;
block|{
specifier|register
name|tree
name|parm
decl_stmt|;
specifier|register
name|rtx
name|entry_parm
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|stack_parm
init|=
literal|0
decl_stmt|;
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|,
name|passed_mode
decl_stmt|;
name|enum
name|machine_mode
name|nominal_mode
decl_stmt|,
name|promoted_nominal_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
comment|/* Total space needed so far for args on the stack,      given as a constant and a tree-expression.  */
name|struct
name|args_size
name|stack_args_size
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|fnargs
init|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
comment|/* This is used for the arg pointer when referring to stack args.  */
name|rtx
name|internal_arg_pointer
decl_stmt|;
comment|/* This is a dummy PARM_DECL that we used for the function result if       the function returns a structure.  */
name|tree
name|function_result_decl
init|=
literal|0
decl_stmt|;
name|int
name|nparmregs
init|=
name|list_length
argument_list|(
name|fnargs
argument_list|)
operator|+
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
decl_stmt|;
name|int
name|varargs_setup
init|=
literal|0
decl_stmt|;
name|rtx
name|conversion_insns
init|=
literal|0
decl_stmt|;
comment|/* FUNCTION_ARG may look at this variable.  Since this is not      expanding a call it will always be zero in this function.  */
name|int
name|current_call_is_indirect
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if the last arg is named `__builtin_va_alist',      which is used on some machines for old-fashioned non-ANSI varargs.h;      this should be stuck onto the stack as if it had arrived there.  */
name|int
name|hide_last_arg
init|=
operator|(
name|current_function_varargs
operator|&&
name|fnargs
operator|&&
operator|(
name|parm
operator|=
name|tree_last
argument_list|(
name|fnargs
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
operator|)
operator|)
decl_stmt|;
comment|/* Nonzero if function takes extra anonymous args.      This means the last named arg must be on the stack      right before the anonymous ones. */
name|int
name|stdarg
init|=
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
decl_stmt|;
name|current_function_stdarg
operator|=
name|stdarg
expr_stmt|;
comment|/* If the reg that the virtual arg pointer will be translated into is      not a fixed reg or is the stack pointer, make a copy of the virtual      arg pointer, and address parms via the copy.  The frame pointer is      considered fixed even though it is not marked as such.       The second time through, simply use ap to avoid generating rtx.  */
if|if
condition|(
operator|(
name|ARG_POINTER_REGNUM
operator|==
name|STACK_POINTER_REGNUM
operator|||
operator|!
operator|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|||
name|ARG_POINTER_REGNUM
operator|==
name|FRAME_POINTER_REGNUM
operator|)
operator|)
operator|&&
operator|!
name|second_time
condition|)
name|internal_arg_pointer
operator|=
name|copy_to_reg
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
else|else
name|internal_arg_pointer
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
name|current_function_internal_arg_pointer
operator|=
name|internal_arg_pointer
expr_stmt|;
name|stack_args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|stack_args_size
operator|.
name|var
operator|=
literal|0
expr_stmt|;
comment|/* If struct value address is treated as the first argument, make it so.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
operator|!
name|current_function_returns_pcc_struct
operator|&&
name|struct_value_incoming_rtx
operator|==
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|function_result_decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|function_result_decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|function_result_decl
argument_list|)
operator|=
name|fnargs
expr_stmt|;
name|fnargs
operator|=
name|function_result_decl
expr_stmt|;
block|}
name|parm_reg_stack_loc
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm_reg_stack_loc
argument_list|,
name|nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_CUMULATIVE_INCOMING_ARGS
name|INIT_CUMULATIVE_INCOMING_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|fntype
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|#
directive|else
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|fntype
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We haven't yet found an argument that we must push and pretend the      caller did.  */
name|current_function_pretend_args_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|fnargs
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|int
name|aggregate
init|=
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|args_size
name|stack_offset
decl_stmt|;
name|struct
name|args_size
name|arg_size
decl_stmt|;
name|int
name|passed_pointer
init|=
literal|0
decl_stmt|;
name|int
name|did_conversion
init|=
literal|0
decl_stmt|;
name|tree
name|passed_type
init|=
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|nominal_type
init|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
comment|/* Set LAST_NAMED if this is last named arg before some 	 anonymous args.  We treat it as if it were anonymous too.  */
name|int
name|last_named
init|=
operator|(
operator|(
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
operator|||
name|DECL_NAME
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stdarg
operator|||
name|current_function_varargs
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|error_mark_node
comment|/* This can happen after weird syntax errors 	     or if an enum type is defined among the parms.  */
operator|||
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
operator|||
name|passed_type
operator|==
name|NULL
condition|)
block|{
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* For varargs.h function, save info about regs and stack space 	 used by the individual args, not including the va_alist arg.  */
if|if
condition|(
name|hide_last_arg
operator|&&
name|last_named
condition|)
name|current_function_args_info
operator|=
name|args_so_far
expr_stmt|;
comment|/* Find mode of arg as it is passed, and mode of arg 	 as it should be during execution of this function.  */
name|passed_mode
operator|=
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
expr_stmt|;
name|nominal_mode
operator|=
name|TYPE_MODE
argument_list|(
name|nominal_type
argument_list|)
expr_stmt|;
comment|/* If the parm's mode is VOID, its value doesn't matter, 	 and avoid the usual things like emit_move_insn that could crash.  */
if|if
condition|(
name|nominal_mode
operator|==
name|VOIDmode
condition|)
block|{
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
continue|continue;
block|}
comment|/* If the parm is to be passed as a transparent union, use the 	 type of the first field for the tests below.  We have already 	 verified that the modes are the same.  */
if|if
condition|(
name|DECL_TRANSPARENT_UNION
argument_list|(
name|parm
argument_list|)
operator|||
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|passed_type
argument_list|)
condition|)
name|passed_type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|passed_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if this arg was passed by invisible reference.  It is if 	 it is an object whose size depends on the contents of the 	 object itself or if the machine requires these objects be passed 	 that way.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|contains_placeholder_p
argument_list|(
name|TYPE_SIZE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|passed_type
argument_list|)
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PASS_BY_REFERENCE
operator|||
name|FUNCTION_ARG_PASS_BY_REFERENCE
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|passed_type
operator|=
name|nominal_type
operator|=
name|build_pointer_type
argument_list|(
name|passed_type
argument_list|)
expr_stmt|;
name|passed_pointer
operator|=
literal|1
expr_stmt|;
name|passed_mode
operator|=
name|nominal_mode
operator|=
name|Pmode
expr_stmt|;
block|}
name|promoted_mode
operator|=
name|passed_mode
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_ARGS
comment|/* Compute the mode in which the arg is actually extended to.  */
name|promoted_mode
operator|=
name|promote_mode
argument_list|(
name|passed_type
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Let machine desc say which reg (if any) the parm arrives in. 	 0 means it arrives on the stack.  */
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
name|entry_parm
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
argument_list|)
expr_stmt|;
else|#
directive|else
name|entry_parm
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry_parm
operator|==
literal|0
condition|)
name|promoted_mode
operator|=
name|passed_mode
expr_stmt|;
ifdef|#
directive|ifdef
name|SETUP_INCOMING_VARARGS
comment|/* If this is the last named parameter, do any required setup for 	 varargs or stdargs.  We need to know about the case of this being an 	 addressable type, in which case we skip the registers it 	 would have arrived in.  	 For stdargs, LAST_NAMED will be set for two parameters, the one that 	 is actually the last named, and the dummy parameter.  We only 	 want to do this action once.  	 Also, indicate when RTL generation is to be suppressed.  */
if|if
condition|(
name|last_named
operator|&&
operator|!
name|varargs_setup
condition|)
block|{
name|SETUP_INCOMING_VARARGS
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
name|current_function_pretend_args_size
argument_list|,
name|second_time
argument_list|)
expr_stmt|;
name|varargs_setup
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Determine parm's home in the stack, 	 in case it arrives in the stack or we should pretend it did.  	 Compute the stack position and rtx where the argument arrives 	 and its size.  	 There is one complexity here:  If this was a parameter that would 	 have been passed in registers, but wasn't only because it is 	 __builtin_va_alist, we want locate_and_pad_parm to treat it as if 	 it came in a register so that REG_PARM_STACK_SPACE isn't skipped. 	 In this case, we call FUNCTION_ARG with NAMED set to 1 instead of 	 0 as it was the previous time.  */
name|locate_and_pad_parm
argument_list|(
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
literal|1
argument_list|,
else|#
directive|else
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
name|FUNCTION_INCOMING_ARG
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
operator|(
operator|!
name|last_named
operator|||
name|varargs_setup
operator|)
argument_list|)
operator|!=
literal|0
argument_list|,
else|#
directive|else
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
operator|||
name|varargs_setup
argument_list|)
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
name|fndecl
argument_list|,
operator|&
name|stack_args_size
argument_list|,
operator|&
name|stack_offset
argument_list|,
operator|&
name|arg_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|second_time
condition|)
block|{
name|rtx
name|offset_rtx
init|=
name|ARGS_SIZE_RTX
argument_list|(
name|stack_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset_rtx
operator|==
name|const0_rtx
condition|)
name|stack_parm
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|promoted_mode
argument_list|,
name|internal_arg_pointer
argument_list|)
expr_stmt|;
else|else
name|stack_parm
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|promoted_mode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|internal_arg_pointer
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components, 	     mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|stack_parm
argument_list|)
operator|=
name|aggregate
expr_stmt|;
block|}
comment|/* If this parameter was passed both in registers and in the stack, 	 use the copy on the stack.  */
if|if
condition|(
name|MUST_PASS_IN_STACK
argument_list|(
name|promoted_mode
argument_list|,
name|passed_type
argument_list|)
condition|)
name|entry_parm
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
comment|/* If this parm was passed part in regs and part in memory, 	 pretend it arrived entirely in memory 	 by pushing the register-part onto the stack.  	 In the special case of a DImode or DFmode that is split, 	 we could put it together in a pseudoreg directly, 	 but for now that's not worth bothering with.  */
if|if
condition|(
name|entry_parm
condition|)
block|{
name|int
name|nregs
init|=
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
argument_list|)
decl_stmt|;
if|if
condition|(
name|nregs
operator|>
literal|0
condition|)
block|{
name|current_function_pretend_args_size
operator|=
operator|(
operator|(
operator|(
name|nregs
operator|*
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|second_time
condition|)
name|move_block_from_reg
argument_list|(
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|nregs
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|entry_parm
operator|=
name|stack_parm
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* If we didn't decide this parm came in a register, 	 by default it came on the stack.  */
if|if
condition|(
name|entry_parm
operator|==
literal|0
condition|)
name|entry_parm
operator|=
name|stack_parm
expr_stmt|;
comment|/* Record permanently how this parm was passed.  */
if|if
condition|(
operator|!
name|second_time
condition|)
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|entry_parm
expr_stmt|;
comment|/* If there is actually space on the stack for this parm, 	 count it in stack_args_size; otherwise set stack_parm to 0 	 to indicate there is no preallocated stack slot for the parm.  */
if|if
condition|(
name|entry_parm
operator|==
name|stack_parm
if|#
directive|if
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MAYBE_REG_PARM_STACK_SPACE
argument_list|)
comment|/* On some machines, even if a parm value arrives in a register 	     there is still an (uninitialized) stack slot allocated for it.  	     ??? When MAYBE_REG_PARM_STACK_SPACE is defined, we can't tell 	     whether this parameter already has a stack slot allocated, 	     because an arg block exists only if current_function_args_size 	     is larger than some threshold, and we haven't calculated that 	     yet.  So, for now, we just assume that stack slots never exist 	     in this case.  */
operator|||
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
operator|>
literal|0
endif|#
directive|endif
condition|)
block|{
name|stack_args_size
operator|.
name|constant
operator|+=
name|arg_size
operator|.
name|constant
expr_stmt|;
if|if
condition|(
name|arg_size
operator|.
name|var
condition|)
name|ADD_PARM_SIZE
argument_list|(
name|stack_args_size
argument_list|,
name|arg_size
operator|.
name|var
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* No stack slot was pushed for this parm.  */
name|stack_parm
operator|=
literal|0
expr_stmt|;
comment|/* Update info on where next arg arrives in registers.  */
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
argument_list|)
expr_stmt|;
comment|/* If this is our second time through, we are done with this parm. */
if|if
condition|(
name|second_time
condition|)
continue|continue;
comment|/* If we can't trust the parm stack slot to be aligned enough 	 for its ultimate type, don't use that slot after entry. 	 We'll make another stack slot, if we need one.  */
block|{
name|int
name|thisparm_boundary
init|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|promoted_mode
argument_list|,
name|passed_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|nominal_mode
argument_list|)
operator|>
name|thisparm_boundary
condition|)
name|stack_parm
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If parm was passed in memory, and we need to convert it on entry, 	 don't store it back in that same slot.  */
if|if
condition|(
name|entry_parm
operator|!=
literal|0
operator|&&
name|nominal_mode
operator|!=
name|BLKmode
operator|&&
name|nominal_mode
operator|!=
name|passed_mode
condition|)
name|stack_parm
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Now adjust STACK_PARM to the mode and precise location 	 where this parameter should live during execution, 	 if we discover that it must live in the stack during execution. 	 To make debuggers happier on big-endian machines, we store 	 the value in the last bytes of the space available.  */
block|if (nominal_mode != BLKmode&& nominal_mode != passed_mode&& stack_parm != 0) 	{ 	  rtx offset_rtx;  	  if (BYTES_BIG_ENDIAN&& GET_MODE_SIZE (nominal_mode)< UNITS_PER_WORD) 	    stack_offset.constant += (GET_MODE_SIZE (passed_mode) 				      - GET_MODE_SIZE (nominal_mode));  	  offset_rtx = ARGS_SIZE_RTX (stack_offset); 	  if (offset_rtx == const0_rtx) 	    stack_parm = gen_rtx (MEM, nominal_mode, internal_arg_pointer); 	  else 	    stack_parm = gen_rtx (MEM, nominal_mode, 				  gen_rtx (PLUS, Pmode, 					   internal_arg_pointer, offset_rtx));
comment|/* If this is a memory ref that contains aggregate components, 	     mark it as such for cse and loop optimize.  */
block|MEM_IN_STRUCT_P (stack_parm) = aggregate; 	}
endif|#
directive|endif
comment|/* 0 */
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* We need this "use" info, because the gcc-register->stack-register 	 converter in reg-stack.c needs to know which registers are active 	 at the start of the function call.  The actual parameter loading 	 instructions are not always available then anymore, since they might 	 have been optimised away.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|REG
operator|&&
operator|!
operator|(
name|hide_last_arg
operator|&&
name|last_named
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENTRY_PARM is an RTX for the parameter as it arrives, 	 in the mode in which it arrives. 	 STACK_PARM is an RTX for a stack slot where the parameter can live 	 during the function (in case we want to put it there). 	 STACK_PARM is 0 if no stack slot was pushed for it.  	 Now output code if necessary to convert ENTRY_PARM to 	 the type in which this function declares it, 	 and store that result in an appropriate place, 	 which may be a pseudo reg, may be STACK_PARM, 	 or may be a local stack slot if STACK_PARM is 0.  	 Set DECL_RTL to that place.  */
if|if
condition|(
name|nominal_mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* If a BLKmode arrives in registers, copy it to a stack slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|size_stored
init|=
name|CEIL_ROUND
argument_list|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
comment|/* Note that we will be storing an integral number of words. 		 So we have to be careful to ensure that we allocate an 		 integral number of words.  We do this below in the 		 assign_stack_local if space was not allocated in the argument 		 list.  If it was, this will not work if PARM_BOUNDARY is not 		 a multiple of BITS_PER_WORD.  It isn't clear how to fix this 		 if it becomes a problem.  */
if|if
condition|(
name|stack_parm
operator|==
literal|0
condition|)
block|{
name|stack_parm
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|size_stored
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate 		     components, mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|stack_parm
argument_list|)
operator|=
name|aggregate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PARM_BOUNDARY
operator|%
name|BITS_PER_WORD
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|stack_parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|move_block_from_reg
argument_list|(
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|size_stored
operator|/
name|UNITS_PER_WORD
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|stack_parm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|obey_regdecls
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|)
comment|/* layout_decl may set this.  */
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|parm
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|parm
argument_list|)
comment|/* If -ffloat-store specified, don't put explicit 		     float variables into registers.  */
operator|||
operator|(
name|flag_float_store
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|)
comment|/* Always assign pseudo to structure return or item passed 		  by invisible reference.  */
operator|||
name|passed_pointer
operator|||
name|parm
operator|==
name|function_result_decl
condition|)
block|{
comment|/* Store the parm in a pseudoregister during the function, but we 	     may need to do it in a wider mode.  */
specifier|register
name|rtx
name|parmreg
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|regnoi
decl_stmt|,
name|regnor
decl_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|promoted_nominal_mode
operator|=
name|promote_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|nominal_mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parmreg
operator|=
name|gen_reg_rtx
argument_list|(
name|promoted_nominal_mode
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|parmreg
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this was an item that we received a pointer to, set DECL_RTL 	     appropriately.  */
if|if
condition|(
name|passed_pointer
condition|)
block|{
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
argument_list|,
name|parmreg
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
name|aggregate
expr_stmt|;
block|}
else|else
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|parmreg
expr_stmt|;
comment|/* Copy the value into the register.  */
if|if
condition|(
name|nominal_mode
operator|!=
name|passed_mode
operator|||
name|promoted_nominal_mode
operator|!=
name|promoted_mode
condition|)
block|{
comment|/* ENTRY_PARM has been converted to PROMOTED_MODE, its 		 mode, by the caller.  We now have to convert it to  		 NOMINAL_MODE, if different.  However, PARMREG may be in 		 a diffent mode than NOMINAL_MODE if it is being stored 		 promoted.  		 If ENTRY_PARM is a hard register, it might be in a register 		 not valid for operating in its mode (e.g., an odd-numbered 		 register for a DFmode).  In that case, moves are the only 		 thing valid, so we can't do a convert from there.  This 		 occurs when the calling sequence allow such misaligned 		 usages.  		 In addition, the conversion may involve a call, which could 		 clobber parameters which haven't been copied to pseudo 		 registers yet.  Therefore, we must first copy the parm to 		 a pseudo reg here, and save the conversion until after all 		 parameters have been moved.  */
name|rtx
name|tempreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tempreg
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|tempreg
operator|=
name|convert_to_mode
argument_list|(
name|nominal_mode
argument_list|,
name|tempreg
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|parm
argument_list|,
name|make_tree
argument_list|(
name|nominal_type
argument_list|,
name|tempreg
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|did_conversion
operator|=
literal|1
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we were passed a pointer but the actual value 	     can safely live in a register, put it in one.  */
if|if
condition|(
name|passed_pointer
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|&&
operator|!
operator|(
operator|(
name|obey_regdecls
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|)
comment|/* layout_decl may set this.  */
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|parm
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|parm
argument_list|)
comment|/* If -ffloat-store specified, don't put explicit 		       float variables into registers.  */
operator|||
operator|(
name|flag_float_store
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|)
condition|)
block|{
comment|/* We can't use nominal_mode, because it will have been set to 		 Pmode above.  We must use the actual mode of the parm.  */
name|parmreg
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|parmreg
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|parmreg
expr_stmt|;
comment|/* STACK_PARM is the pointer, not the parm, and PARMREG is 		 now the parm.  */
name|stack_parm
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FUNCTION_ARG_CALLEE_COPIES
comment|/* If we are passed an arg by reference and it is our responsibility 	     to make a copy, do it now. 	     PASSED_TYPE and PASSED mode now refer to the pointer, not the 	     original argument, so we must recreate them in the call to 	     FUNCTION_ARG_CALLEE_COPIES.  */
comment|/* ??? Later add code to handle the case that if the argument isn't 	     modified, don't do the copy.  */
elseif|else
if|if
condition|(
name|passed_pointer
operator|&&
name|FUNCTION_ARG_CALLEE_COPIES
argument_list|(
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|!
name|last_named
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|copy
decl_stmt|;
name|tree
name|type
init|=
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
comment|/* This sequence may involve a library call perhaps clobbering 		 registers that haven't been copied to pseudos yet.  */
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
comment|/* This is a variable sized object.  */
name|copy
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|allocate_dynamic_stack_space
argument_list|(
name|expr_size
argument_list|(
name|parm
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|copy
operator|=
name|assign_stack_temp
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|copy
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|parm
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|did_conversion
operator|=
literal|1
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FUNCTION_ARG_CALLEE_COPIES */
comment|/* In any case, record the parm's desired stack location 	     in case we later discover it must live in the stack.   	     If it is a COMPLEX value, store the stack location for both 	     halves.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|parmreg
argument_list|)
operator|==
name|CONCAT
condition|)
name|regno
operator|=
name|MAX
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|parmreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|parmreg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|regno
operator|=
name|REGNO
argument_list|(
name|parmreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|nparmregs
condition|)
block|{
name|rtx
modifier|*
name|new
decl_stmt|;
name|int
name|old_nparmregs
init|=
name|nparmregs
decl_stmt|;
name|nparmregs
operator|=
name|regno
operator|+
literal|5
expr_stmt|;
name|new
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm_reg_stack_loc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
name|old_nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|new
operator|+
name|old_nparmregs
operator|)
argument_list|,
operator|(
name|nparmregs
operator|-
name|old_nparmregs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|parm_reg_stack_loc
operator|=
name|new
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|parmreg
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|enum
name|machine_mode
name|submode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|parmreg
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|regnor
operator|=
name|REGNO
argument_list|(
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|parmreg
argument_list|)
argument_list|)
expr_stmt|;
name|regnoi
operator|=
name|REGNO
argument_list|(
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|parmreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_parm
operator|!=
literal|0
condition|)
block|{
name|parm_reg_stack_loc
index|[
name|regnor
index|]
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|stack_parm
argument_list|)
expr_stmt|;
name|parm_reg_stack_loc
index|[
name|regnoi
index|]
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|stack_parm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parm_reg_stack_loc
index|[
name|regnor
index|]
operator|=
literal|0
expr_stmt|;
name|parm_reg_stack_loc
index|[
name|regnoi
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|parm_reg_stack_loc
index|[
name|REGNO
argument_list|(
name|parmreg
argument_list|)
index|]
operator|=
name|stack_parm
expr_stmt|;
comment|/* Mark the register as eliminable if we did no conversion 	     and it was copied from memory at a fixed offset, 	     and the arg pointer was not copied to a pseudo-reg. 	     If the arg pointer is a pseudo reg or the offset formed 	     an invalid address, such memory-equivalences 	     as we make here would screw up life analysis for it.  */
if|if
condition|(
name|nominal_mode
operator|==
name|passed_mode
operator|&&
operator|!
name|did_conversion
operator|&&
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|MEM
operator|&&
name|entry_parm
operator|==
name|stack_parm
operator|&&
name|stack_offset
operator|.
name|var
operator|==
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|XEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|linsn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* Mark complex types separately.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|parmreg
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|REG_NOTES
argument_list|(
name|linsn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUIV
argument_list|,
name|parm_reg_stack_loc
index|[
name|regnoi
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|linsn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now search backward for where we set the real part.  */
for|for
control|(
init|;
name|linsn
operator|!=
literal|0
operator|&&
operator|!
name|reg_referenced_p
argument_list|(
name|parm_reg_stack_loc
index|[
name|regnor
index|]
argument_list|,
name|PATTERN
argument_list|(
name|linsn
argument_list|)
argument_list|)
condition|;
name|linsn
operator|=
name|prev_nonnote_insn
argument_list|(
name|linsn
argument_list|)
control|)
empty_stmt|;
name|REG_NOTES
argument_list|(
name|linsn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUIV
argument_list|,
name|parm_reg_stack_loc
index|[
name|regnor
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|linsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|REG_NOTES
argument_list|(
name|linsn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUIV
argument_list|,
name|entry_parm
argument_list|,
name|REG_NOTES
argument_list|(
name|linsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For pointer data type, suggest pointer register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|mark_reg_pointer
argument_list|(
name|parmreg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Value must be stored in the stack slot STACK_PARM 	     during function execution.  */
if|if
condition|(
name|promoted_mode
operator|!=
name|nominal_mode
condition|)
block|{
comment|/* Conversion is required.   */
name|rtx
name|tempreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tempreg
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|entry_parm
operator|=
name|convert_to_mode
argument_list|(
name|nominal_mode
argument_list|,
name|tempreg
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|did_conversion
operator|=
literal|1
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|entry_parm
operator|!=
name|stack_parm
condition|)
block|{
if|if
condition|(
name|stack_parm
operator|==
literal|0
condition|)
block|{
name|stack_parm
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components, 		     mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|stack_parm
argument_list|)
operator|=
name|aggregate
expr_stmt|;
block|}
if|if
condition|(
name|promoted_mode
operator|!=
name|nominal_mode
condition|)
block|{
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|stack_parm
expr_stmt|;
block|}
comment|/* If this "parameter" was the place where we are receiving the 	 function's incoming structure pointer, set up the result.  */
if|if
condition|(
name|parm
operator|==
name|function_result_decl
condition|)
block|{
name|tree
name|result
init|=
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|restype
init|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|DECL_RTL
argument_list|(
name|result
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DECL_MODE
argument_list|(
name|result
argument_list|)
argument_list|,
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|result
argument_list|)
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|restype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|parm
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Output all parameter conversion instructions (possibly including calls)      now that all parameters have been copied out of hard registers.  */
name|emit_insns
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|max_parm_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|current_function_args_size
operator|=
name|stack_args_size
operator|.
name|constant
expr_stmt|;
comment|/* Adjust function incoming argument size for alignment and      minimum length.  */
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
ifndef|#
directive|ifndef
name|MAYBE_REG_PARM_STACK_SPACE
name|current_function_args_size
operator|=
name|MAX
argument_list|(
name|current_function_args_size
argument_list|,
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
define|#
directive|define
name|STACK_BYTES
value|(STACK_BOUNDARY / BITS_PER_UNIT)
name|current_function_args_size
operator|=
operator|(
operator|(
name|current_function_args_size
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|)
operator|*
name|STACK_BYTES
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|current_function_arg_offset_rtx
operator|=
operator|(
name|stack_args_size
operator|.
name|var
operator|==
literal|0
condition|?
name|GEN_INT
argument_list|(
operator|-
name|stack_args_size
operator|.
name|constant
argument_list|)
else|:
name|expand_expr
argument_list|(
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|stack_args_size
operator|.
name|var
argument_list|,
name|size_int
argument_list|(
operator|-
name|stack_args_size
operator|.
name|constant
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|current_function_arg_offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|stack_args_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See how many bytes, if any, of its args a function should try to pop      on return.  */
name|current_function_pops_args
operator|=
name|RETURN_POPS_ARGS
argument_list|(
name|fndecl
argument_list|,
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|current_function_args_size
argument_list|)
expr_stmt|;
comment|/* For stdarg.h function, save info about      regs and stack space used by the named args.  */
if|if
condition|(
operator|!
name|hide_last_arg
condition|)
name|current_function_args_info
operator|=
name|args_so_far
expr_stmt|;
comment|/* Set the rtx used for the function return value.  Put this in its      own variable so any optimizers that need this information don't have      to include tree.h.  Do this here so it gets done when an inlined      function gets output.  */
name|current_function_return_rtx
operator|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Indicate whether REGNO is an incoming argument to the current function    that was promoted to a wider mode.  If so, return the RTX for the    register (to get its mode).  PMODE and PUNSIGNEDP are set to the mode    that REGNO is promoted from and whether the promotion was signed or    unsigned.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_ARGS
end_ifdef

begin_function
name|rtx
name|promoted_input_arg
parameter_list|(
name|regno
parameter_list|,
name|pmode
parameter_list|,
name|punsignedp
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|pmode
decl_stmt|;
name|int
modifier|*
name|punsignedp
decl_stmt|;
block|{
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|regno
operator|&&
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|mode
operator|=
name|promote_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
name|mode
operator|!=
name|DECL_MODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
operator|*
name|pmode
operator|=
name|DECL_MODE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|unsignedp
expr_stmt|;
return|return
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Compute the size and offset from the start of the stacked arguments for a    parm passed in mode PASSED_MODE and with type TYPE.     INITIAL_OFFSET_PTR points to the current offset into the stacked    arguments.     The starting offset and size for this parm are returned in *OFFSET_PTR    and *ARG_SIZE_PTR, respectively.     IN_REGS is non-zero if the argument will be passed in registers.  It will    never be set if REG_PARM_STACK_SPACE is not defined.     FNDECL is the function in which the argument was defined.     There are two types of rounding that are done.  The first, controlled by    FUNCTION_ARG_BOUNDARY, forces the offset from the start of the argument    list to be aligned to the specific boundary (in bits).  This rounding    affects the initial and starting offsets, but not the argument size.     The second, controlled by FUNCTION_ARG_PADDING and PARM_BOUNDARY,    optionally rounds the size of the parm to PARM_BOUNDARY.  The    initial offset is not affected by this rounding, while the size always    is and the starting offset may be.  */
end_comment

begin_comment
comment|/*  offset_ptr will be negative for ARGS_GROW_DOWNWARD case;      initial_offset_ptr is positive because locate_and_pad_parm's     callers pass in the total size of args so far as     initial_offset_ptr. arg_size_ptr is always positive.*/
end_comment

begin_function
name|void
name|locate_and_pad_parm
parameter_list|(
name|passed_mode
parameter_list|,
name|type
parameter_list|,
name|in_regs
parameter_list|,
name|fndecl
parameter_list|,
name|initial_offset_ptr
parameter_list|,
name|offset_ptr
parameter_list|,
name|arg_size_ptr
parameter_list|)
name|enum
name|machine_mode
name|passed_mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|in_regs
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|struct
name|args_size
modifier|*
name|initial_offset_ptr
decl_stmt|;
name|struct
name|args_size
modifier|*
name|offset_ptr
decl_stmt|;
name|struct
name|args_size
modifier|*
name|arg_size_ptr
decl_stmt|;
block|{
name|tree
name|sizetree
init|=
name|type
condition|?
name|size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|size_int
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|passed_mode
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|direction
name|where_pad
init|=
name|FUNCTION_ARG_PADDING
argument_list|(
name|passed_mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|boundary
init|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|passed_mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|boundary_in_bytes
init|=
name|boundary
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
comment|/* If we have found a stack parm before we reach the end of the      area reserved for registers, skip that area.  */
if|if
condition|(
operator|!
name|in_regs
condition|)
block|{
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|MAYBE_REG_PARM_STACK_SPACE
expr_stmt|;
else|#
directive|else
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|reg_parm_stack_space
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
block|{
name|initial_offset_ptr
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|ARGS_SIZE_TREE
argument_list|(
operator|*
name|initial_offset_ptr
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
name|initial_offset_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|initial_offset_ptr
operator|->
name|constant
operator|<
name|reg_parm_stack_space
condition|)
name|initial_offset_ptr
operator|->
name|constant
operator|=
name|reg_parm_stack_space
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* REG_PARM_STACK_SPACE */
name|arg_size_ptr
operator|->
name|var
operator|=
literal|0
expr_stmt|;
name|arg_size_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
block|{
name|offset_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
name|offset_ptr
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|initial_offset_ptr
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset_ptr
operator|->
name|constant
operator|=
operator|-
name|initial_offset_ptr
operator|->
name|constant
expr_stmt|;
name|offset_ptr
operator|->
name|var
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|where_pad
operator|!=
name|none
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|sizetree
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
operator|)
operator|)
condition|)
name|sizetree
operator|=
name|round_up
argument_list|(
name|sizetree
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|SUB_PARM_SIZE
argument_list|(
operator|*
name|offset_ptr
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
if|if
condition|(
name|where_pad
operator|!=
name|downward
condition|)
name|pad_to_arg_alignment
argument_list|(
name|offset_ptr
argument_list|,
name|boundary
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
block|{
name|arg_size_ptr
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|initial_offset_ptr
operator|->
name|var
argument_list|)
argument_list|,
name|offset_ptr
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg_size_ptr
operator|->
name|constant
operator|=
operator|(
operator|-
name|initial_offset_ptr
operator|->
name|constant
operator|-
name|offset_ptr
operator|->
name|constant
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !ARGS_GROW_DOWNWARD */
name|pad_to_arg_alignment
argument_list|(
name|initial_offset_ptr
argument_list|,
name|boundary
argument_list|)
expr_stmt|;
operator|*
name|offset_ptr
operator|=
operator|*
name|initial_offset_ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|passed_mode
operator|!=
name|BLKmode
condition|)
name|sizetree
operator|=
name|size_int
argument_list|(
name|PUSH_ROUNDING
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Pad_below needs the pre-rounded size to know how much to pad below      so this must be done before rounding up.  */
if|if
condition|(
name|where_pad
operator|==
name|downward
comment|/* However, BLKmode args passed in regs have their padding done elsewhere.        The stack slot must be able to hold the entire register.  */
operator|&&
operator|!
operator|(
name|in_regs
operator|&&
name|passed_mode
operator|==
name|BLKmode
operator|)
condition|)
name|pad_below
argument_list|(
name|offset_ptr
argument_list|,
name|passed_mode
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
if|if
condition|(
name|where_pad
operator|!=
name|none
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|sizetree
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
operator|)
operator|)
condition|)
name|sizetree
operator|=
name|round_up
argument_list|(
name|sizetree
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ADD_PARM_SIZE
argument_list|(
operator|*
name|arg_size_ptr
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ARGS_GROW_DOWNWARD */
block|}
end_function

begin_comment
comment|/* Round the stack offset in *OFFSET_PTR up to a multiple of BOUNDARY.    BOUNDARY is measured in bits, but must be a multiple of a storage unit.  */
end_comment

begin_function
specifier|static
name|void
name|pad_to_arg_alignment
parameter_list|(
name|offset_ptr
parameter_list|,
name|boundary
parameter_list|)
name|struct
name|args_size
modifier|*
name|offset_ptr
decl_stmt|;
name|int
name|boundary
decl_stmt|;
block|{
name|int
name|boundary_in_bytes
init|=
name|boundary
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|boundary
operator|>
name|BITS_PER_UNIT
condition|)
block|{
if|if
condition|(
name|offset_ptr
operator|->
name|var
condition|)
block|{
name|offset_ptr
operator|->
name|var
operator|=
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|round_down
else|#
directive|else
name|round_up
endif|#
directive|endif
argument_list|(
name|ARGS_SIZE_TREE
argument_list|(
operator|*
name|offset_ptr
argument_list|)
argument_list|,
name|boundary
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|offset_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
comment|/*?*/
block|}
else|else
name|offset_ptr
operator|->
name|constant
operator|=
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|FLOOR_ROUND
argument_list|(
name|offset_ptr
operator|->
name|constant
argument_list|,
name|boundary_in_bytes
argument_list|)
expr_stmt|;
else|#
directive|else
name|CEIL_ROUND
argument_list|(
name|offset_ptr
operator|->
name|constant
argument_list|,
name|boundary_in_bytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pad_below
parameter_list|(
name|offset_ptr
parameter_list|,
name|passed_mode
parameter_list|,
name|sizetree
parameter_list|)
name|struct
name|args_size
modifier|*
name|offset_ptr
decl_stmt|;
name|enum
name|machine_mode
name|passed_mode
decl_stmt|;
name|tree
name|sizetree
decl_stmt|;
block|{
if|if
condition|(
name|passed_mode
operator|!=
name|BLKmode
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|passed_mode
argument_list|)
operator|%
name|PARM_BOUNDARY
condition|)
name|offset_ptr
operator|->
name|constant
operator|+=
operator|(
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|passed_mode
argument_list|)
operator|+
name|PARM_BOUNDARY
operator|-
literal|1
operator|)
operator|/
name|PARM_BOUNDARY
operator|*
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|passed_mode
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sizetree
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
condition|)
block|{
comment|/* Round the size up to multiple of PARM_BOUNDARY bits.  */
name|tree
name|s2
init|=
name|round_up
argument_list|(
name|sizetree
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
comment|/* Add it in.  */
name|ADD_PARM_SIZE
argument_list|(
operator|*
name|offset_ptr
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|SUB_PARM_SIZE
argument_list|(
operator|*
name|offset_ptr
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|round_down
parameter_list|(
name|value
parameter_list|,
name|divisor
parameter_list|)
name|tree
name|value
decl_stmt|;
name|int
name|divisor
decl_stmt|;
block|{
return|return
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|value
argument_list|,
name|size_int
argument_list|(
name|divisor
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|divisor
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk the tree of blocks describing the binding levels within a function    and warn about uninitialized variables.    This is done after calling flow_analysis and before global_alloc    clobbers the pseudo-regs to hard regs.  */
end_comment

begin_function
name|void
name|uninitialized_vars_warning
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|,
name|sub
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
comment|/* These warnings are unreliable for and aggregates 	     because assigning the fields one by one can fail to convince 	     flow.c that the entire aggregate was initialized. 	     Unions are troublesome because members may be shorter.  */
operator|&&
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|regno_uninitialized
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' might be used uninitialized in this function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|regno_clobbered_at_setjmp
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"variable `%s' might be clobbered by `longjmp' or `vfork'"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sub
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|sub
condition|;
name|sub
operator|=
name|TREE_CHAIN
argument_list|(
name|sub
argument_list|)
control|)
name|uninitialized_vars_warning
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do the appropriate part of uninitialized_vars_warning    but for arguments instead of local variables.  */
end_comment

begin_function
name|void
name|setjmp_args_warning
parameter_list|()
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|regno_clobbered_at_setjmp
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"argument `%s' might be clobbered by `longjmp' or `vfork'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If this function call setjmp, put all vars into the stack    unless they were declared `register'.  */
end_comment

begin_function
name|void
name|setjmp_protect
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|,
name|sub
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
comment|/* If this variable came from an inline function, it must be 	   that it's life doesn't overlap the setjmp.  If there was a 	   setjmp in the function, it would already be in memory.  We 	   must exclude such variable because their DECL_RTL might be 	   set to strange things such as virtual_stack_vars_rtx.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
comment|/* If longjmp doesn't restore the registers, 	       don't put anything in them.  */
name|NON_SAVING_SETJMP
operator|||
endif|#
directive|endif
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|put_var_into_stack
argument_list|(
name|decl
argument_list|)
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|sub
condition|;
name|sub
operator|=
name|TREE_CHAIN
argument_list|(
name|sub
argument_list|)
control|)
name|setjmp_protect
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like the previous function, but for args instead of local variables.  */
end_comment

begin_function
name|void
name|setjmp_protect_args
parameter_list|()
block|{
specifier|register
name|tree
name|decl
decl_stmt|,
name|sub
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
comment|/* If longjmp doesn't restore the registers, 	       don't put anything in them.  */
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
name|NON_SAVING_SETJMP
operator|||
endif|#
directive|endif
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|put_var_into_stack
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the context-pointer register corresponding to DECL,    or 0 if it does not need one.  */
end_comment

begin_function
name|rtx
name|lookup_static_chain
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|link
decl_stmt|;
if|if
condition|(
name|context
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We treat inline_function_decl as an alias for the current function      because that is the inline function whose vars, types, etc.      are being merged into the current function.      See expand_inline_function.  */
if|if
condition|(
name|context
operator|==
name|current_function_decl
operator|||
name|context
operator|==
name|inline_function_decl
condition|)
return|return
name|virtual_stack_vars_rtx
return|;
for|for
control|(
name|link
operator|=
name|context_display
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|context
condition|)
return|return
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a stack slot address ADDR for variable VAR    (from a containing function)    into an address valid in this function (using a static chain).  */
end_comment

begin_function
name|rtx
name|fix_lexical_addr
parameter_list|(
name|addr
parameter_list|,
name|var
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|tree
name|var
decl_stmt|;
block|{
name|rtx
name|basereg
decl_stmt|;
name|int
name|displacement
decl_stmt|;
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|struct
name|function
modifier|*
name|fp
decl_stmt|;
name|rtx
name|base
init|=
literal|0
decl_stmt|;
comment|/* If this is the present function, we need not do anything.  */
if|if
condition|(
name|context
operator|==
name|current_function_decl
operator|||
name|context
operator|==
name|inline_function_decl
condition|)
return|return
name|addr
return|;
for|for
control|(
name|fp
operator|=
name|outer_function_chain
init|;
name|fp
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
if|if
condition|(
name|fp
operator|->
name|decl
operator|==
name|context
condition|)
break|break;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Decode given address as base reg plus displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|addr
operator|,
name|displacement
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|basereg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|,
name|displacement
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* We accept vars reached via the containing function's      incoming arg pointer and via its stack variables pointer.  */
if|if
condition|(
name|basereg
operator|==
name|fp
operator|->
name|internal_arg_pointer
condition|)
block|{
comment|/* If reached via arg pointer, get the arg pointer value 	 out of that function's stack frame.  	 There are two cases:  If a separate ap is needed, allocate a 	 slot in the outer function for it and dereference it that way. 	 This is correct even if the real ap is actually a pseudo. 	 Otherwise, just adjust the offset from the frame pointer to 	 compensate.  */
ifdef|#
directive|ifdef
name|NEED_SEPARATE_AP
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|arg_pointer_save_area
operator|==
literal|0
condition|)
name|fp
operator|->
name|arg_pointer_save_area
operator|=
name|assign_outer_stack_local
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|fp
operator|->
name|arg_pointer_save_area
argument_list|,
literal|0
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|base
operator|=
name|copy_to_reg
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|displacement
operator|+=
operator|(
name|FIRST_PARM_OFFSET
argument_list|(
name|context
argument_list|)
operator|-
name|STARTING_FRAME_OFFSET
operator|)
expr_stmt|;
name|base
operator|=
name|lookup_static_chain
argument_list|(
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|basereg
operator|==
name|virtual_stack_vars_rtx
condition|)
block|{
comment|/* This is the same code as lookup_static_chain, duplicated here to 	 avoid an extra call to decl_function_context.  */
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|context_display
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|context
condition|)
block|{
name|base
operator|=
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Use same offset, relative to appropriate static chain or argument      pointer.  */
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|displacement
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the address of the trampoline for entering nested fn FUNCTION.    If necessary, allocate a trampoline (in the stack frame)    and emit rtl to initialize its contents (at entry to this function).  */
end_comment

begin_function
name|rtx
name|trampoline_address
parameter_list|(
name|function
parameter_list|)
name|tree
name|function
decl_stmt|;
block|{
name|tree
name|link
decl_stmt|;
name|tree
name|rtlexp
decl_stmt|;
name|rtx
name|tramp
decl_stmt|;
name|struct
name|function
modifier|*
name|fp
decl_stmt|;
name|tree
name|fn_context
decl_stmt|;
comment|/* Find an existing trampoline and return it.  */
for|for
control|(
name|link
operator|=
name|trampoline_list
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|function
condition|)
return|return
name|round_trampoline_addr
argument_list|(
name|XEXP
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
for|for
control|(
name|fp
operator|=
name|outer_function_chain
init|;
name|fp
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
for|for
control|(
name|link
operator|=
name|fp
operator|->
name|trampoline_list
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|function
condition|)
block|{
name|tramp
operator|=
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|round_trampoline_addr
argument_list|(
name|tramp
argument_list|)
return|;
block|}
comment|/* None exists; we must make one.  */
comment|/* Find the `struct function' for the function containing FUNCTION.  */
name|fp
operator|=
literal|0
expr_stmt|;
name|fn_context
operator|=
name|decl_function_context
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_context
operator|!=
name|current_function_decl
condition|)
for|for
control|(
name|fp
operator|=
name|outer_function_chain
init|;
name|fp
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
if|if
condition|(
name|fp
operator|->
name|decl
operator|==
name|fn_context
condition|)
break|break;
comment|/* Allocate run-time space for this trampoline      (usually in the defining function's stack frame).  */
ifdef|#
directive|ifdef
name|ALLOCATE_TRAMPOLINE
name|tramp
operator|=
name|ALLOCATE_TRAMPOLINE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* If rounding needed, allocate extra space      to ensure we have TRAMPOLINE_SIZE bytes left after rounding up.  */
ifdef|#
directive|ifdef
name|TRAMPOLINE_ALIGNMENT
define|#
directive|define
name|TRAMPOLINE_REAL_SIZE
value|(TRAMPOLINE_SIZE + TRAMPOLINE_ALIGNMENT - 1)
else|#
directive|else
define|#
directive|define
name|TRAMPOLINE_REAL_SIZE
value|(TRAMPOLINE_SIZE)
endif|#
directive|endif
if|if
condition|(
name|fp
operator|!=
literal|0
condition|)
name|tramp
operator|=
name|assign_outer_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|TRAMPOLINE_REAL_SIZE
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|tramp
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|TRAMPOLINE_REAL_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Record the trampoline for reuse and note it for later initialization      by expand_function_end.  */
if|if
condition|(
name|fp
operator|!=
literal|0
condition|)
block|{
name|push_obstacks
argument_list|(
name|fp
operator|->
name|function_maybepermanent_obstack
argument_list|,
name|fp
operator|->
name|function_maybepermanent_obstack
argument_list|)
expr_stmt|;
name|rtlexp
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|rtlexp
argument_list|)
operator|=
name|tramp
expr_stmt|;
name|fp
operator|->
name|trampoline_list
operator|=
name|tree_cons
argument_list|(
name|function
argument_list|,
name|rtlexp
argument_list|,
name|fp
operator|->
name|trampoline_list
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Make the RTL_EXPR node temporary, not momentary, so that the 	 trampoline_list doesn't become garbage.  */
name|int
name|momentary
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
name|rtlexp
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|momentary
argument_list|)
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|rtlexp
argument_list|)
operator|=
name|tramp
expr_stmt|;
name|trampoline_list
operator|=
name|tree_cons
argument_list|(
name|function
argument_list|,
name|rtlexp
argument_list|,
name|trampoline_list
argument_list|)
expr_stmt|;
block|}
name|tramp
operator|=
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|tramp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|round_trampoline_addr
argument_list|(
name|tramp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a trampoline address,    round it to multiple of TRAMPOLINE_ALIGNMENT.  */
end_comment

begin_function
specifier|static
name|rtx
name|round_trampoline_addr
parameter_list|(
name|tramp
parameter_list|)
name|rtx
name|tramp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TRAMPOLINE_ALIGNMENT
comment|/* Round address up to desired boundary.  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|tramp
argument_list|,
name|GEN_INT
argument_list|(
name|TRAMPOLINE_ALIGNMENT
operator|-
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|tramp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|and_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|TRAMPOLINE_ALIGNMENT
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tramp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The functions identify_blocks and reorder_blocks provide a way to    reorder the tree of BLOCK nodes, for optimizers that reshuffle or    duplicate portions of the RTL code.  Call identify_blocks before    changing the RTL, and call reorder_blocks after.  */
end_comment

begin_comment
comment|/* Put all this function's BLOCK nodes into a vector, and return it.    Also store in each NOTE for the beginning or end of a block    the index of that block in the vector.    The arguments are TOP_BLOCK, the top-level block of the function,    and INSNS, the insn chain of the function.  */
end_comment

begin_function
name|tree
modifier|*
name|identify_blocks
parameter_list|(
name|top_block
parameter_list|,
name|insns
parameter_list|)
name|tree
name|top_block
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
block|{
name|int
name|n_blocks
decl_stmt|;
name|tree
modifier|*
name|block_vector
decl_stmt|;
name|int
modifier|*
name|block_stack
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|next_block_number
init|=
literal|0
decl_stmt|;
name|int
name|current_block_number
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|top_block
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|n_blocks
operator|=
name|all_blocks
argument_list|(
name|top_block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|block_vector
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_blocks
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|block_stack
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|all_blocks
argument_list|(
name|top_block
argument_list|,
name|block_vector
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
block|{
name|block_stack
index|[
name|depth
operator|++
index|]
operator|=
name|current_block_number
expr_stmt|;
name|current_block_number
operator|=
name|next_block_number
expr_stmt|;
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|next_block_number
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
condition|)
block|{
name|current_block_number
operator|=
name|block_stack
index|[
operator|--
name|depth
index|]
expr_stmt|;
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|current_block_number
expr_stmt|;
block|}
block|}
return|return
name|block_vector
return|;
block|}
end_function

begin_comment
comment|/* Given BLOCK_VECTOR which was returned by identify_blocks,    and a revised instruction chain, rebuild the tree structure    of BLOCK nodes to correspond to the new order of RTL.    The new block tree is inserted below TOP_BLOCK.    Returns the current top-level block.  */
end_comment

begin_function
name|tree
name|reorder_blocks
parameter_list|(
name|block_vector
parameter_list|,
name|top_block
parameter_list|,
name|insns
parameter_list|)
name|tree
modifier|*
name|block_vector
decl_stmt|;
name|tree
name|top_block
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
block|{
name|tree
name|current_block
init|=
name|top_block
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|block_vector
operator|==
literal|0
condition|)
return|return
name|top_block
return|;
comment|/* Prune the old tree away, so that it doesn't get in the way.  */
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
block|{
name|tree
name|block
init|=
name|block_vector
index|[
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
decl_stmt|;
comment|/* If we have seen this block before, copy it.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
condition|)
name|block
operator|=
name|copy_node
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|block
argument_list|)
operator|=
name|current_block
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
operator|=
name|block
expr_stmt|;
name|current_block
operator|=
name|block
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
condition|)
block|{
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
operator|=
name|blocks_nreverse
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
argument_list|)
expr_stmt|;
name|current_block
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|current_block
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|current_block
return|;
block|}
end_function

begin_comment
comment|/* Reverse the order of elements in the chain T of blocks,    and return the new head of the chain (old last element).  */
end_comment

begin_function
specifier|static
name|tree
name|blocks_nreverse
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|register
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|decl
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|t
init|;
name|decl
condition|;
name|decl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|BLOCK_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|decl
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Count the subblocks of BLOCK, and list them all into the vector VECTOR.    Also clear TREE_ASM_WRITTEN in all blocks.  */
end_comment

begin_function
specifier|static
name|int
name|all_blocks
parameter_list|(
name|block
parameter_list|,
name|vector
parameter_list|)
name|tree
name|block
decl_stmt|;
name|tree
modifier|*
name|vector
decl_stmt|;
block|{
name|int
name|n_blocks
init|=
literal|1
decl_stmt|;
name|tree
name|subblocks
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Record this block.  */
if|if
condition|(
name|vector
condition|)
name|vector
index|[
literal|0
index|]
operator|=
name|block
expr_stmt|;
comment|/* Record the subblocks, and their subblocks.  */
for|for
control|(
name|subblocks
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|subblocks
condition|;
name|subblocks
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblocks
argument_list|)
control|)
name|n_blocks
operator|+=
name|all_blocks
argument_list|(
name|subblocks
argument_list|,
name|vector
condition|?
name|vector
operator|+
name|n_blocks
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
name|n_blocks
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build bytecode call descriptor for function SUBR. */
end_comment

begin_function
name|rtx
name|bc_build_calldesc
parameter_list|(
name|subr
parameter_list|)
name|tree
name|subr
decl_stmt|;
block|{
name|tree
name|calldesc
init|=
literal|0
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
comment|/* Build the argument description vector in reverse order.  */
name|DECL_ARGUMENTS
argument_list|(
name|subr
argument_list|)
operator|=
name|nreverse
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|subr
argument_list|)
argument_list|)
expr_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|subr
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
operator|++
name|nargs
expr_stmt|;
name|calldesc
operator|=
name|tree_cons
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
name|calldesc
operator|=
name|tree_cons
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|bc_runtime_type_code
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
block|}
name|DECL_ARGUMENTS
argument_list|(
name|subr
argument_list|)
operator|=
name|nreverse
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|subr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepend the function's return type.  */
name|calldesc
operator|=
name|tree_cons
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
name|calldesc
operator|=
name|tree_cons
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|bc_runtime_type_code
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
comment|/* Prepend the arg count.  */
name|calldesc
operator|=
name|tree_cons
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|build_int_2
argument_list|(
name|nargs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
comment|/* Output the call description vector and get its address.  */
name|calldesc
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|calldesc
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nargs
operator|*
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|output_constant_def
argument_list|(
name|calldesc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the start of the function SUBR (a FUNCTION_DECL tree node)    and initialize static variables for generating RTL for the statements    of the function.  */
end_comment

begin_function
name|void
name|init_function_start
parameter_list|(
name|subr
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|subr
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|junk
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|this_function_decl
operator|=
name|subr
expr_stmt|;
name|this_function_calldesc
operator|=
name|bc_build_calldesc
argument_list|(
name|subr
argument_list|)
expr_stmt|;
name|local_vars_size
operator|=
literal|0
expr_stmt|;
name|stack_depth
operator|=
literal|0
expr_stmt|;
name|max_stack_depth
operator|=
literal|0
expr_stmt|;
name|stmt_expr_depth
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|init_stmt_for_function
argument_list|()
expr_stmt|;
name|cse_not_expected
operator|=
operator|!
name|optimize
expr_stmt|;
comment|/* Caller save not needed yet.  */
name|caller_save_needed
operator|=
literal|0
expr_stmt|;
comment|/* No stack slots have been made yet.  */
name|stack_slot_list
operator|=
literal|0
expr_stmt|;
comment|/* There is no stack slot for handling nonlocal gotos.  */
name|nonlocal_goto_handler_slot
operator|=
literal|0
expr_stmt|;
name|nonlocal_goto_stack_level
operator|=
literal|0
expr_stmt|;
comment|/* No labels have been declared for nonlocal use.  */
name|nonlocal_labels
operator|=
literal|0
expr_stmt|;
comment|/* No function calls so far in this function.  */
name|function_call_count
operator|=
literal|0
expr_stmt|;
comment|/* No parm regs have been allocated.      (This is important for output_inline_function.)  */
name|max_parm_reg
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
expr_stmt|;
comment|/* Initialize the RTL mechanism.  */
name|init_emit
argument_list|()
expr_stmt|;
comment|/* Initialize the queue of pending postincrement and postdecrements,      and some other info in expr.c.  */
name|init_expr
argument_list|()
expr_stmt|;
comment|/* We haven't done register allocation yet.  */
name|reg_renumber
operator|=
literal|0
expr_stmt|;
name|init_const_rtx_hash_table
argument_list|()
expr_stmt|;
name|current_function_name
operator|=
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|subr
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
comment|/* Nonzero if this is a nested function that uses a static chain.  */
name|current_function_needs_context
operator|=
operator|(
name|decl_function_context
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Set if a call to setjmp is seen.  */
name|current_function_calls_setjmp
operator|=
literal|0
expr_stmt|;
comment|/* Set if a call to longjmp is seen.  */
name|current_function_calls_longjmp
operator|=
literal|0
expr_stmt|;
name|current_function_calls_alloca
operator|=
literal|0
expr_stmt|;
name|current_function_has_nonlocal_label
operator|=
literal|0
expr_stmt|;
name|current_function_has_nonlocal_goto
operator|=
literal|0
expr_stmt|;
name|current_function_contains_functions
operator|=
literal|0
expr_stmt|;
name|current_function_returns_pcc_struct
operator|=
literal|0
expr_stmt|;
name|current_function_returns_struct
operator|=
literal|0
expr_stmt|;
name|current_function_epilogue_delay_list
operator|=
literal|0
expr_stmt|;
name|current_function_uses_const_pool
operator|=
literal|0
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|0
expr_stmt|;
comment|/* We have not yet needed to make a label to jump to for tail-recursion.  */
name|tail_recursion_label
operator|=
literal|0
expr_stmt|;
comment|/* We haven't had a need to make a save area for ap yet.  */
name|arg_pointer_save_area
operator|=
literal|0
expr_stmt|;
comment|/* No stack slots allocated yet.  */
name|frame_offset
operator|=
literal|0
expr_stmt|;
comment|/* No SAVE_EXPRs in this function yet.  */
name|save_expr_regs
operator|=
literal|0
expr_stmt|;
comment|/* No RTL_EXPRs in this function yet.  */
name|rtl_expr_chain
operator|=
literal|0
expr_stmt|;
comment|/* We have not allocated any temporaries yet.  */
name|temp_slots
operator|=
literal|0
expr_stmt|;
name|temp_slot_level
operator|=
literal|0
expr_stmt|;
name|target_temp_slot_level
operator|=
literal|0
expr_stmt|;
comment|/* Within function body, compute a type's size as soon it is laid out.  */
name|immediate_size_expand
operator|++
expr_stmt|;
comment|/* We haven't made any trampolines for this function yet.  */
name|trampoline_list
operator|=
literal|0
expr_stmt|;
name|init_pending_stack_adjust
argument_list|()
expr_stmt|;
name|inhibit_defer_pop
operator|=
literal|0
expr_stmt|;
name|current_function_outgoing_args_size
operator|=
literal|0
expr_stmt|;
comment|/* Prevent ever trying to delete the first instruction of a function.      Also tell final how to output a linenum before the function prologue.  */
name|emit_line_note
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Make sure first insn is a note even if we don't want linenums.      This makes sure the first insn will never be deleted.      Also, final expects a note to appear there.  */
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Set flags used by final.c.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
name|current_function_returns_pcc_struct
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|current_function_returns_struct
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Warn if this value is an aggregate type,      regardless of which calling convention we are using for it.  */
if|if
condition|(
name|warn_aggregate_return
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function returns an aggregate"
argument_list|)
expr_stmt|;
name|current_function_returns_pointer
operator|=
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Indicate that we need to distinguish between the return value of the      present function and the return value of a function being called.  */
name|rtx_equal_function_value_matters
operator|=
literal|1
expr_stmt|;
comment|/* Indicate that we have not instantiated virtual registers yet.  */
name|virtuals_instantiated
operator|=
literal|0
expr_stmt|;
comment|/* Indicate we have no need of a frame pointer yet.  */
name|frame_pointer_needed
operator|=
literal|0
expr_stmt|;
comment|/* By default assume not varargs or stdarg.  */
name|current_function_varargs
operator|=
literal|0
expr_stmt|;
name|current_function_stdarg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indicate that the current function uses extra args    not explicitly mentioned in the argument list in any fashion.  */
end_comment

begin_function
name|void
name|mark_varargs
parameter_list|()
block|{
name|current_function_varargs
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a call to __main at the beginning of a possible main function.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INIT_SECTION_ASM_OP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|INVOKE__main
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|HAS_INIT_SECTION
end_undef

begin_define
define|#
directive|define
name|HAS_INIT_SECTION
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GEN_CALL__MAIN
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_INIT_SECTION
end_ifndef

begin_define
define|#
directive|define
name|GEN_CALL__MAIN
define|\
value|do {									\     emit_library_call (gen_rtx (SYMBOL_REF, Pmode, NAME__MAIN), 0,	\ 		       VOIDmode, 0);					\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|expand_main_function
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GEN_CALL__MAIN
if|if
condition|(
operator|!
name|output_bytecode
condition|)
name|GEN_CALL__MAIN
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand start of bytecode function. See comment at    expand_function_start below for details. */
end_comment

begin_function
name|void
name|bc_expand_function_start
parameter_list|(
name|subr
parameter_list|,
name|parms_have_cleanups
parameter_list|)
name|tree
name|subr
decl_stmt|;
name|int
name|parms_have_cleanups
decl_stmt|;
block|{
name|char
name|label
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|name
decl_stmt|;
specifier|static
name|int
name|nlab
decl_stmt|;
name|tree
name|thisarg
decl_stmt|;
name|int
name|argsz
decl_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|subr
argument_list|)
condition|)
name|bc_globalize_label
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n<func %s>\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|argsz
operator|=
literal|0
operator|,
name|thisarg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|subr
argument_list|)
init|;
name|thisarg
condition|;
name|thisarg
operator|=
name|TREE_CHAIN
argument_list|(
name|thisarg
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_RTL
argument_list|(
name|thisarg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Should be NULL here I think.  */
elseif|else
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|thisarg
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_RTL
argument_list|(
name|thisarg
argument_list|)
operator|=
name|bc_gen_rtx
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|argsz
argument_list|,
operator|(
expr|struct
name|bc_label
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|argsz
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|thisarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Variable-sized objects are pointers to their storage. */
name|DECL_RTL
argument_list|(
name|thisarg
argument_list|)
operator|=
name|bc_gen_rtx
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|argsz
argument_list|,
operator|(
expr|struct
name|bc_label
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|argsz
operator|+=
name|POINTER_SIZE
expr_stmt|;
block|}
block|}
name|bc_begin_function
argument_list|(
name|bc_xstrdup
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LX"
argument_list|,
name|nlab
argument_list|)
expr_stmt|;
operator|++
name|nlab
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|this_function_callinfo
operator|=
name|bc_gen_rtx
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|bc_label
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|this_function_bytecode
operator|=
name|bc_emit_trampoline
argument_list|(
name|BYTECODE_LABEL
argument_list|(
name|this_function_callinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand end of bytecode function. See details the comment of    expand_function_end(), below. */
end_comment

begin_function
name|void
name|bc_expand_function_end
parameter_list|()
block|{
name|char
modifier|*
name|ptrconsts
decl_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
comment|/* Emit any fixup code. This must be done before the call to      to BC_END_FUNCTION (), since that will cause the bytecode      segment to be finished off and closed. */
name|expand_fixups
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|ptrconsts
operator|=
name|bc_end_function
argument_list|()
expr_stmt|;
name|bc_align_const
argument_list|(
literal|2
comment|/* INT_ALIGN */
argument_list|)
expr_stmt|;
comment|/* If this changes also make sure to change bc-interp.h!  */
name|bc_emit_const_labeldef
argument_list|(
name|BYTECODE_LABEL
argument_list|(
name|this_function_callinfo
argument_list|)
argument_list|)
expr_stmt|;
name|bc_emit_const
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|max_stack_depth
argument_list|,
sizeof|sizeof
name|max_stack_depth
argument_list|)
expr_stmt|;
name|bc_emit_const
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|local_vars_size
argument_list|,
sizeof|sizeof
name|local_vars_size
argument_list|)
expr_stmt|;
name|bc_emit_const_labelref
argument_list|(
name|this_function_bytecode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc_emit_const_labelref
argument_list|(
name|ptrconsts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc_emit_const_labelref
argument_list|(
name|BYTECODE_LABEL
argument_list|(
name|this_function_calldesc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start the RTL for a new function, and set variables used for    emitting RTL.    SUBR is the FUNCTION_DECL node.    PARMS_HAVE_CLEANUPS is nonzero if there are cleanups associated with    the function's parameters, which must be run at any return statement.  */
end_comment

begin_function
name|void
name|expand_function_start
parameter_list|(
name|subr
parameter_list|,
name|parms_have_cleanups
parameter_list|)
name|tree
name|subr
decl_stmt|;
name|int
name|parms_have_cleanups
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|rtx
name|last_ptr
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_function_start
argument_list|(
name|subr
argument_list|,
name|parms_have_cleanups
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure volatile mem refs aren't considered      valid operands of arithmetic insns.  */
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
comment|/* If function gets a static chain arg, store it in the stack frame.      Do this first, so it gets the first stack slot offset.  */
if|if
condition|(
name|current_function_needs_context
condition|)
block|{
name|last_ptr
operator|=
name|assign_stack_local
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMALL_REGISTER_CLASSES
comment|/* Delay copying static chain if it is not a register to avoid 	 conflicts with regs used for parameters.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
operator|==
name|REG
condition|)
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|last_ptr
argument_list|,
name|static_chain_incoming_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* If the parameters of this function need cleaning up, get a label      for the beginning of the code which executes those cleanups.  This must      be done before doing anything with return_label.  */
if|if
condition|(
name|parms_have_cleanups
condition|)
name|cleanup_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
else|else
name|cleanup_label
operator|=
literal|0
expr_stmt|;
comment|/* Make the label for return statements to jump to, if this machine      does not have a one-instruction return and uses an epilogue,      or if it returns a structure, or if it has parm cleanups.  */
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|cleanup_label
operator|==
literal|0
operator|&&
name|HAVE_return
operator|&&
operator|!
name|current_function_returns_pcc_struct
operator|&&
operator|!
operator|(
name|current_function_returns_struct
operator|&&
operator|!
name|optimize
operator|)
condition|)
name|return_label
operator|=
literal|0
expr_stmt|;
else|else
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
else|#
directive|else
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize rtx used to return the value.  */
comment|/* Do this before assign_parms so that we copy the struct value address      before any library calls that assign parms might generate.  */
comment|/* Decide whether to return the value in memory or in a register.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Returning something that won't go in a register.  */
specifier|register
name|rtx
name|value_address
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
if|if
condition|(
name|current_function_returns_pcc_struct
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|value_address
operator|=
name|assemble_static_space
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* Expect to be passed the address of a place to store the value. 	     If it is passed as an argument, assign_parms will take care of 	     it.  */
if|if
condition|(
name|struct_value_incoming_rtx
condition|)
block|{
name|value_address
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|value_address
argument_list|,
name|struct_value_incoming_rtx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value_address
condition|)
block|{
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|value_address
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
comment|/* If return mode is void, this decl rtl should not be used.  */
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|parms_have_cleanups
condition|)
block|{
comment|/* If function will end with cleanup code for parms, 	 compute the return values into a pseudo reg, 	 which we will copy into the true return register 	 after the cleanups are done.  */
name|enum
name|machine_mode
name|mode
init|=
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_RETURN
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|mode
operator|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Scalar, returned in a register.  */
block|{
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|subr
argument_list|)
expr_stmt|;
else|#
directive|else
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|subr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark this reg as the function's return value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|REG_FUNCTION_VALUE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Needed because we may need to move this to memory 	     in case it's a named return value whose address is taken.  */
name|DECL_REGISTER
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Initialize rtx for parameters and local variables.      In some cases this requires emitting insns.  */
name|assign_parms
argument_list|(
name|subr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMALL_REGISTER_CLASSES
comment|/* Copy the static chain now if it wasn't a register.  The delay is to      avoid conflicts with the parameter passing registers.  */
if|if
condition|(
name|current_function_needs_context
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
operator|!=
name|REG
condition|)
name|emit_move_insn
argument_list|(
name|last_ptr
argument_list|,
name|static_chain_incoming_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The following was moved from init_function_start.      The move is supposed to make sdb output more accurate.  */
comment|/* Indicate the beginning of the function body,      as opposed to parm setup.  */
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_FUNCTION_BEG
argument_list|)
expr_stmt|;
comment|/* If doing stupid allocation, mark parms as born here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|NOTE
condition|)
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|parm_birth_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
block|{
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_parm_reg
condition|;
name|i
operator|++
control|)
name|use_variable
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_internal_arg_pointer
operator|!=
name|virtual_incoming_args_rtx
condition|)
name|use_variable
argument_list|(
name|current_function_internal_arg_pointer
argument_list|)
expr_stmt|;
block|}
comment|/* Fetch static chain values for containing functions.  */
name|tem
operator|=
name|decl_function_context
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* If not doing stupid register allocation copy the static chain      pointer into a pseudo.  If we have small register classes, copy the      value from memory if static_chain_incoming_rtx is a REG.  If we do      stupid register allocation, we use the stack address generated above.  */
if|if
condition|(
name|tem
operator|&&
operator|!
name|obey_regdecls
condition|)
block|{
ifdef|#
directive|ifdef
name|SMALL_REGISTER_CLASSES
comment|/* If the static chain originally came in a register, put it back 	 there, then move it out in the next insn.  The reason for 	 this peculiar code is to satisfy function integration.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
operator|==
name|REG
condition|)
name|emit_move_insn
argument_list|(
name|static_chain_incoming_rtx
argument_list|,
name|last_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|last_ptr
operator|=
name|copy_to_reg
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
expr_stmt|;
block|}
name|context_display
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tem
condition|)
block|{
name|tree
name|rtlexp
init|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
decl_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|rtlexp
argument_list|)
operator|=
name|last_ptr
expr_stmt|;
name|context_display
operator|=
name|tree_cons
argument_list|(
name|tem
argument_list|,
name|rtlexp
argument_list|,
name|context_display
argument_list|)
expr_stmt|;
name|tem
operator|=
name|decl_function_context
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
break|break;
comment|/* Chain thru stack frames, assuming pointer to next lexical frame 	 is found at the place we always store it.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|last_ptr
operator|=
name|plus_constant
argument_list|(
name|last_ptr
argument_list|,
operator|-
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|last_ptr
operator|=
name|copy_to_reg
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|last_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are not optimizing, ensure that we know that this 	 piece of context is live over the entire function.  */
if|if
condition|(
operator|!
name|optimize
condition|)
name|save_expr_regs
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|last_ptr
argument_list|,
name|save_expr_regs
argument_list|)
expr_stmt|;
block|}
comment|/* After the display initializations is where the tail-recursion label      should go, if we end up needing one.   Ensure we have a NOTE here      since some things (like trampolines) get placed before this.  */
name|tail_recursion_reentry
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Evaluate now the sizes of any types declared among the arguments.  */
for|for
control|(
name|tem
operator|=
name|nreverse
argument_list|(
name|get_pending_sizes
argument_list|()
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure there is a line number after the function entry setup code.  */
name|force_next_line_note
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the end of the current function.    FILENAME and LINE are the current position in the source file.      It is up to language-specific callers to do cleanups for parameters--    or else, supply 1 for END_BINDINGS and we will call expand_end_bindings.  */
end_comment

begin_function
name|void
name|expand_function_end
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|end_bindings
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|end_bindings
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|tree
name|link
decl_stmt|;
specifier|static
name|rtx
name|initial_trampoline
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_function_end
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
comment|/* Don't put any variables in registers if we call setjmp      on a machine that fails to restore the registers.  */
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|current_function_calls_setjmp
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|setjmp_protect
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|setjmp_protect_args
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Save the argument pointer if a save area was made for it.  */
if|if
condition|(
name|arg_pointer_save_area
condition|)
block|{
name|rtx
name|x
init|=
name|gen_move_insn
argument_list|(
name|arg_pointer_save_area
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|x
argument_list|,
name|tail_recursion_reentry
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize any trampolines required by this function.  */
for|for
control|(
name|link
operator|=
name|trampoline_list
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|function
init|=
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|rtx
name|context
init|=
name|lookup_static_chain
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|rtx
name|tramp
init|=
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* First make sure this compilation has a template for 	 initializing trampolines.  */
if|if
condition|(
name|initial_trampoline
operator|==
literal|0
condition|)
block|{
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|initial_trampoline
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|assemble_trampoline_template
argument_list|()
argument_list|)
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
comment|/* Generate insns to initialize the trampoline.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|tramp
operator|=
name|change_address
argument_list|(
name|initial_trampoline
argument_list|,
name|BLKmode
argument_list|,
name|round_trampoline_addr
argument_list|(
name|XEXP
argument_list|(
name|tramp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|tramp
argument_list|,
name|initial_trampoline
argument_list|,
name|GEN_INT
argument_list|(
name|TRAMPOLINE_SIZE
argument_list|)
argument_list|,
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|INITIALIZE_TRAMPOLINE
argument_list|(
name|XEXP
argument_list|(
name|tramp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Put those insns at entry to the containing function (this one).  */
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|tail_recursion_reentry
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about unused parms if extra warnings were specified.  */
if|if
condition|(
name|warn_unused
operator|&&
name|extra_warnings
condition|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"unused parameter `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* Delete handlers for nonlocal gotos if nothing uses them.  */
if|if
condition|(
name|nonlocal_goto_handler_slot
operator|!=
literal|0
operator|&&
operator|!
name|current_function_has_nonlocal_label
condition|)
name|delete_handlers
argument_list|()
expr_stmt|;
comment|/* End any sequences that failed to be closed due to syntax errors.  */
while|while
condition|(
name|in_sequence_p
argument_list|()
condition|)
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Outside function body, can't compute type's actual size      until next function's body starts.  */
name|immediate_size_expand
operator|--
expr_stmt|;
comment|/* If doing stupid register allocation,      mark register parms as dying here.  */
if|if
condition|(
name|obey_regdecls
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_parm_reg
condition|;
name|i
operator|++
control|)
name|use_variable
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Likewise for the regs of all the SAVE_EXPRs in the function.  */
for|for
control|(
name|tem
operator|=
name|save_expr_regs
init|;
name|tem
condition|;
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|use_variable
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|use_variable_after
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|parm_birth_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_internal_arg_pointer
operator|!=
name|virtual_incoming_args_rtx
condition|)
name|use_variable
argument_list|(
name|current_function_internal_arg_pointer
argument_list|)
expr_stmt|;
block|}
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Mark the end of the function body.      If control reaches this insn, the function can drop through      without returning a value.  */
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_FUNCTION_END
argument_list|)
expr_stmt|;
comment|/* Output a linenumber for the end of the function.      SDB depends on this.  */
name|emit_line_note_force
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Output the label for the actual return from the function,      if one is expected.  This happens either because a function epilogue      is used instead of a return instruction, or because a return was done      with a goto in order to run local cleanups, or because of pcc-style      structure returning.  */
if|if
condition|(
name|return_label
condition|)
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
comment|/* C++ uses this.  */
if|if
condition|(
name|end_bindings
condition|)
name|expand_end_bindings
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we had calls to alloca, and this machine needs      an accurate stack pointer to exit the function,      insert some code to save and restore the stack pointer.  */
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
condition|)
endif|#
directive|endif
if|if
condition|(
name|current_function_calls_alloca
condition|)
block|{
name|rtx
name|tem
init|=
literal|0
decl_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_FUNCTION
argument_list|,
operator|&
name|tem
argument_list|,
name|parm_birth_insn
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_FUNCTION
argument_list|,
name|tem
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* If scalar return value was computed in a pseudo-reg,      copy that to the hard return register.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
name|rtx
name|real_decl_result
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|real_decl_result
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|real_decl_result
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REG_FUNCTION_VALUE_P
argument_list|(
name|real_decl_result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|real_decl_result
argument_list|,
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|real_decl_result
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If returning a structure, arrange to return the address of the value      in a place where debuggers expect to find it.       If returning a structure PCC style,      the caller also depends on this value.      And current_function_returns_pcc_struct is not necessarily set.  */
if|if
condition|(
name|current_function_returns_struct
operator|||
name|current_function_returns_pcc_struct
condition|)
block|{
name|rtx
name|value_address
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|rtx
name|outgoing
init|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|outgoing
init|=
name|FUNCTION_VALUE
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Mark this as a function return value so integrate will delete the 	 assignment and USE below when inlining this function.  */
name|REG_FUNCTION_VALUE_P
argument_list|(
name|outgoing
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|outgoing
argument_list|,
name|value_address
argument_list|)
expr_stmt|;
name|use_variable
argument_list|(
name|outgoing
argument_list|)
expr_stmt|;
block|}
comment|/* Output a return insn if we are using one.      Otherwise, let the rtl chain end here, to drop through      into the epilogue.  */
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_return
argument_list|()
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Fix up any gotos that jumped out to the outermost      binding level of the function.      Must follow emitting RETURN_LABEL.  */
comment|/* If you have any cleanups to do at this point,      and they need to create temporary variables,      then you will lose.  */
name|expand_fixups
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These arrays record the INSN_UIDs of the prologue and epilogue insns.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|prologue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|epilogue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create an array that records the INSN_UIDs of INSNS (either a sequence    or a single insn).  */
end_comment

begin_function
specifier|static
name|int
modifier|*
name|record_insns
parameter_list|(
name|insns
parameter_list|)
name|rtx
name|insns
decl_stmt|;
block|{
name|int
modifier|*
name|vec
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insns
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|vec
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|vec
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
name|vec
index|[
name|len
index|]
operator|=
name|INSN_UID
argument_list|(
name|XVECEXP
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vec
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
name|INSN_UID
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* Determine how many INSN_UIDs in VEC are part of INSN.  */
end_comment

begin_function
specifier|static
name|int
name|contains
parameter_list|(
name|insn
parameter_list|,
name|vec
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|vec
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|vec
index|[
name|j
index|]
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|vec
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|==
name|vec
index|[
name|j
index|]
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate the prologue and epilogue RTL if the machine supports it.  Thread    this into place with notes indicating where the prologue ends and where    the epilogue begins.  Update the basic block information when possible.  */
end_comment

begin_function
name|void
name|thread_prologue_and_epilogue_insns
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_prologue
if|if
condition|(
name|HAVE_prologue
condition|)
block|{
name|rtx
name|head
decl_stmt|,
name|seq
decl_stmt|,
name|insn
decl_stmt|;
comment|/* The first insn (a NOTE_INSN_DELETED) is followed by zero or more 	 prologue insns and a NOTE_INSN_PROLOGUE_END.  */
name|emit_note_after
argument_list|(
name|NOTE_INSN_PROLOGUE_END
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_prologue
argument_list|()
expr_stmt|;
name|head
operator|=
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* Include the new prologue insns in the first block.  Ignore them 	 if they form a basic block unto themselves.  */
if|if
condition|(
name|basic_block_head
operator|&&
name|n_basic_blocks
operator|&&
name|GET_CODE
argument_list|(
name|basic_block_head
index|[
literal|0
index|]
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|basic_block_head
index|[
literal|0
index|]
operator|=
name|NEXT_INSN
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Retain a map of the prologue insns.  */
name|prologue
operator|=
name|record_insns
argument_list|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SEQUENCE
condition|?
name|seq
else|:
name|head
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|prologue
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_epilogue
if|if
condition|(
name|HAVE_epilogue
condition|)
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|prev
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If we end with a BARRIER, we don't need an epilogue.  */
if|if
condition|(
operator|!
operator|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|BARRIER
operator|)
condition|)
block|{
name|rtx
name|tail
decl_stmt|,
name|seq
decl_stmt|,
name|tem
decl_stmt|;
name|rtx
name|first_use
init|=
literal|0
decl_stmt|;
name|rtx
name|last_use
init|=
literal|0
decl_stmt|;
comment|/* The last basic block ends with a NOTE_INSN_EPILOGUE_BEG, the 	     epilogue insns, the USE insns at the end of a function, 	     the jump insn that returns, and then a BARRIER.  */
comment|/* Move the USE insns at the end of a function onto a list.  */
while|while
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|tem
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_use
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
operator|=
name|first_use
expr_stmt|;
name|PREV_INSN
argument_list|(
name|first_use
argument_list|)
operator|=
name|tem
expr_stmt|;
block|}
name|first_use
operator|=
name|tem
expr_stmt|;
if|if
condition|(
operator|!
name|last_use
condition|)
name|last_use
operator|=
name|tem
expr_stmt|;
block|}
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_epilogue
argument_list|()
expr_stmt|;
name|tail
operator|=
name|emit_jump_insn_after
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Insert the USE insns immediately before the return insn, which 	     must be the first instruction before the final barrier.  */
if|if
condition|(
name|first_use
condition|)
block|{
name|tem
operator|=
name|prev_nonnote_insn
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|=
name|first_use
expr_stmt|;
name|PREV_INSN
argument_list|(
name|first_use
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
operator|=
name|last_use
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last_use
argument_list|)
operator|=
name|tem
expr_stmt|;
block|}
name|emit_note_after
argument_list|(
name|NOTE_INSN_EPILOGUE_BEG
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Include the new epilogue insns in the last block.  Ignore 	     them if they form a basic block unto themselves.  */
if|if
condition|(
name|basic_block_end
operator|&&
name|n_basic_blocks
operator|&&
name|GET_CODE
argument_list|(
name|basic_block_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
name|basic_block_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
operator|=
name|tail
expr_stmt|;
comment|/* Retain a map of the epilogue insns.  */
name|epilogue
operator|=
name|record_insns
argument_list|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SEQUENCE
condition|?
name|seq
else|:
name|tail
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|epilogue
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reposition the prologue-end and epilogue-begin notes after instruction    scheduling and delayed branch scheduling.  */
end_comment

begin_function
name|void
name|reposition_prologue_and_epilogue_notes
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_prologue
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
comment|/* Reposition the prologue and epilogue notes.  */
if|if
condition|(
name|n_basic_blocks
condition|)
block|{
name|rtx
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|prologue
condition|)
block|{
specifier|register
name|rtx
name|insn
decl_stmt|,
name|note
init|=
literal|0
decl_stmt|;
comment|/* Scan from the beginning until we reach the last prologue insn. 	     We apparently can't depend on basic_block_{head,end} after 	     reorg has run.  */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|prologue
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|len
operator|&&
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_PROLOGUE_END
condition|)
name|note
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|-=
name|contains
argument_list|(
name|insn
argument_list|,
name|prologue
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Find the prologue-end note if we haven't already, and 		     move it to just after the last prologue insn.  */
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|note
operator|=
name|insn
init|;
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
condition|;
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_PROLOGUE_END
condition|)
break|break;
block|}
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
name|add_insn_after
argument_list|(
name|note
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|epilogue
condition|)
block|{
specifier|register
name|rtx
name|insn
decl_stmt|,
name|note
init|=
literal|0
decl_stmt|;
comment|/* Scan from the end until we reach the first epilogue insn. 	     We apparently can't depend on basic_block_{head,end} after 	     reorg has run.  */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|epilogue
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|len
operator|&&
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
name|note
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|-=
name|contains
argument_list|(
name|insn
argument_list|,
name|epilogue
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Find the epilogue-begin note if we haven't already, and 		     move it to just before the first epilogue insn.  */
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|note
operator|=
name|insn
init|;
name|note
operator|=
name|PREV_INSN
argument_list|(
name|note
argument_list|)
condition|;
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
break|break;
block|}
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
name|add_insn_after
argument_list|(
name|note
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_prologue or HAVE_epilogue */
block|}
end_function

end_unit

