begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expands front end tree to back end RTL for GCC.    Copyright (C) 1987, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file handles the generation of rtl code from tree structure    at the level of the function as a whole.    It creates the rtl expressions for parameters and auto variables    and has full responsibility for allocating stack slots.     `expand_function_start' is called at the beginning of a function,    before the function body is parsed, and `expand_function_end' is    called after parsing the body.     Call `assign_stack_local' to allocate a stack slot for a local variable.    This is usually done during the RTL generation for the function body,    but it can also be done in the reload pass when a pseudo-register does    not get a hard register.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_include
include|#
directive|include
file|"vecprim.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|LOCAL_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|LOCAL_ALIGNMENT
parameter_list|(
name|TYPE
parameter_list|,
name|ALIGNMENT
parameter_list|)
value|ALIGNMENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_ALIGNMENT_NEEDED
end_ifndef

begin_define
define|#
directive|define
name|STACK_ALIGNMENT_NEEDED
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STACK_BYTES
value|(STACK_BOUNDARY / BITS_PER_UNIT)
end_define

begin_comment
comment|/* Some systems use __main in a way incompatible with its use in gcc, in these    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to    give the same symbol without quotes for an alternative entry point.  You    must define both, or neither.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME__MAIN
end_ifndef

begin_define
define|#
directive|define
name|NAME__MAIN
value|"__main"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Round a value to the lowest integer less than it that is a multiple of    the required alignment.  Avoid using division in case the value is    negative.  Assume the alignment is a power of two.  */
end_comment

begin_define
define|#
directive|define
name|FLOOR_ROUND
parameter_list|(
name|VALUE
parameter_list|,
name|ALIGN
parameter_list|)
value|((VALUE)& ~((ALIGN) - 1))
end_define

begin_comment
comment|/* Similar, but round to the next highest integer that meets the    alignment.  */
end_comment

begin_define
define|#
directive|define
name|CEIL_ROUND
parameter_list|(
name|VALUE
parameter_list|,
name|ALIGN
parameter_list|)
value|(((VALUE) + (ALIGN) - 1)& ~((ALIGN)- 1))
end_define

begin_comment
comment|/* Nonzero if function being compiled doesn't contain any calls    (ignoring the prologue and epilogue).  This is set prior to    local register allocation and is valid for the remaining    compiler passes.  */
end_comment

begin_decl_stmt
name|int
name|current_function_is_leaf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled doesn't modify the stack pointer    (ignoring the prologue and epilogue).  This is only valid after    life_analysis has run.  */
end_comment

begin_decl_stmt
name|int
name|current_function_sp_is_unchanging
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the function being compiled is a leaf function which only    uses leaf registers.  This is valid after reload (specifically after    sched2) and is useful only if the port defines LEAF_REGISTERS.  */
end_comment

begin_decl_stmt
name|int
name|current_function_uses_only_leaf_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero once virtual register instantiation has been done.    assign_stack_local uses frame_pointer_rtx when this is nonzero.    calls.c:emit_library_call_value_1 uses it to set up    post-instantiation libcalls.  */
end_comment

begin_decl_stmt
name|int
name|virtuals_instantiated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign unique numbers to labels generated for profiling, debugging, etc.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|funcdef_no
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* These variables hold pointers to functions to create and destroy    target specific, per-function data structures.  */
end_comment

begin_function_decl
name|struct
name|machine_function
modifier|*
function_decl|(
modifier|*
name|init_machine_status
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The currently compiled function.  */
end_comment

begin_decl_stmt
name|struct
name|function
modifier|*
name|cfun
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These arrays record the INSN_UIDs of the prologue and epilogue insns.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|prologue
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|epilogue
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Array of INSN_UIDs to hold the INSN_UIDs for each sibcall epilogue    in this function.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|sibcall_epilogue
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* In order to evaluate some expressions, such as function calls returning    structures in memory, we need to temporarily allocate stack locations.    We record each allocated temporary in the following structure.     Associated with each temporary slot is a nesting level.  When we pop up    one level, all temporaries associated with the previous level are freed.    Normally, all temporaries are freed after the execution of the statement    in which they were created.  However, if we are inside a ({...}) grouping,    the result may be in a temporary and hence must be preserved.  If the    result could be in a temporary, we preserve it if we can determine which    one it is in.  If we cannot determine which temporary may contain the    result, all temporaries are preserved.  A temporary is preserved by    pretending it was allocated at the previous nesting level.     Automatic variables are also assigned temporary slots, at the nesting    level where they are defined.  They are marked a "kept" so that    free_temp_slots will not free them.  */
end_comment

begin_decl_stmt
name|struct
name|temp_slot
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Points to next temporary slot.  */
name|struct
name|temp_slot
modifier|*
name|next
decl_stmt|;
comment|/* Points to previous temporary slot.  */
name|struct
name|temp_slot
modifier|*
name|prev
decl_stmt|;
comment|/* The rtx to used to reference the slot.  */
name|rtx
name|slot
decl_stmt|;
comment|/* The rtx used to represent the address if not the address of the      slot above.  May be an EXPR_LIST if multiple addresses exist.  */
name|rtx
name|address
decl_stmt|;
comment|/* The alignment (in bits) of the slot.  */
name|unsigned
name|int
name|align
decl_stmt|;
comment|/* The size, in units, of the slot.  */
name|HOST_WIDE_INT
name|size
decl_stmt|;
comment|/* The type of the object in the slot, or zero if it doesn't correspond      to a type.  We use this to determine whether a slot can be reused.      It can be reused if objects of the type of the new slot will always      conflict with objects of the type of the old slot.  */
name|tree
name|type
decl_stmt|;
comment|/* Nonzero if this temporary is currently in use.  */
name|char
name|in_use
decl_stmt|;
comment|/* Nonzero if this temporary has its address taken.  */
name|char
name|addr_taken
decl_stmt|;
comment|/* Nesting level at which this slot is being used.  */
name|int
name|level
decl_stmt|;
comment|/* Nonzero if this should survive a call to free_temp_slots.  */
name|int
name|keep
decl_stmt|;
comment|/* The offset of the slot from the frame_pointer, including extra space      for alignment.  This info is for combine_temp_slots.  */
name|HOST_WIDE_INT
name|base_offset
decl_stmt|;
comment|/* The size of the slot, including extra space for alignment.  This      info is for combine_temp_slots.  */
name|HOST_WIDE_INT
name|full_size
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|assign_stack_local_1
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|,
name|struct
name|function
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|temp_slot
modifier|*
name|find_temp_slot_from_address
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_to_arg_alignment
parameter_list|(
name|struct
name|args_size
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|args_size
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_below
parameter_list|(
name|struct
name|args_size
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|reorder_blocks_1
argument_list|(
name|rtx
argument_list|,
name|tree
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|all_blocks
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
modifier|*
name|get_block_vector
parameter_list|(
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|tree
name|debug_find_var_in_block_tree
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We always define `record_insns' even if it's not used so that we    can always export `prologue_epilogue_contains'.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|record_insns
argument_list|(
name|rtx
argument_list|,
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|contains
argument_list|(
name|rtx
argument_list|,
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_return
end_ifdef

begin_function_decl
specifier|static
name|void
name|emit_return_into_block
parameter_list|(
name|basic_block
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
operator|&&
name|defined
argument_list|(
name|INCOMING_RETURN_ADDR_RTX
argument_list|)
end_if

begin_function_decl
specifier|static
name|rtx
name|keep_stack_depressed
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|prepare_function_start
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_clobber_return_reg
parameter_list|(
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_use_return_reg
parameter_list|(
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|set_insn_locators
argument_list|(
name|rtx
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Pointer to chain of `struct function' for containing functions.  */
end_comment

begin_decl_stmt
name|struct
name|function
modifier|*
name|outer_function_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a function decl for a containing function,    return the `struct function' for it.  */
end_comment

begin_function
name|struct
name|function
modifier|*
name|find_function_data
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|function
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|outer_function_chain
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|outer
control|)
if|if
condition|(
name|p
operator|->
name|decl
operator|==
name|decl
condition|)
return|return
name|p
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the current context for compilation of a nested function.    This is called from language-specific code.  The caller should use    the enter_nested langhook to save any language-specific state,    since this function knows only about language-independent    variables.  */
end_comment

begin_function
name|void
name|push_function_context_to
parameter_list|(
name|tree
name|context
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|function
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cfun
operator|==
literal|0
condition|)
name|init_dummy_function_start
argument_list|()
expr_stmt|;
name|p
operator|=
name|cfun
expr_stmt|;
name|p
operator|->
name|outer
operator|=
name|outer_function_chain
expr_stmt|;
name|outer_function_chain
operator|=
name|p
expr_stmt|;
name|lang_hooks
operator|.
name|function
operator|.
name|enter_nested
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cfun
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_function_context
parameter_list|(
name|void
parameter_list|)
block|{
name|push_function_context_to
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the last saved context, at the end of a nested function.    This function is called from language-specific code.  */
end_comment

begin_function
name|void
name|pop_function_context_from
parameter_list|(
name|tree
name|context
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|function
modifier|*
name|p
init|=
name|outer_function_chain
decl_stmt|;
name|cfun
operator|=
name|p
expr_stmt|;
name|outer_function_chain
operator|=
name|p
operator|->
name|outer
expr_stmt|;
name|current_function_decl
operator|=
name|p
operator|->
name|decl
expr_stmt|;
name|lang_hooks
operator|.
name|function
operator|.
name|leave_nested
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Reset variables that have known state during rtx generation.  */
name|virtuals_instantiated
operator|=
literal|0
expr_stmt|;
name|generating_concat_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_function_context
parameter_list|(
name|void
parameter_list|)
block|{
name|pop_function_context_from
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out all parts of the state in F that can safely be discarded    after the function has been parsed, but not compiled, to let    garbage collection reclaim the memory.  */
end_comment

begin_function
name|void
name|free_after_parsing
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
comment|/* f->expr->forced_labels is used by code generation.  */
comment|/* f->emit->regno_reg_rtx is used by code generation.  */
comment|/* f->varasm is used by code generation.  */
comment|/* f->eh->eh_return_stub_label is used by code generation.  */
name|lang_hooks
operator|.
name|function
operator|.
name|final
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out all parts of the state in F that can safely be discarded    after the function has been compiled, to let garbage collection    reclaim the memory.  */
end_comment

begin_function
name|void
name|free_after_compilation
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|prologue
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|epilogue
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|sibcall_epilogue
argument_list|)
expr_stmt|;
name|f
operator|->
name|eh
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|expr
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|emit
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|varasm
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|machine
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|cfg
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_avail_temp_slots
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_used_temp_slots
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|arg_offset_rtx
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|return_rtx
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|internal_arg_pointer
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_nonlocal_goto_handler_labels
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_return_label
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_naked_return_label
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_stack_slot_list
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_stack_check_probe_note
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_arg_pointer_save_area
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|x_parm_birth_insn
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|epilogue_delay_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate fixed slots in the stack frame of the current function.  */
end_comment

begin_comment
comment|/* Return size needed for stack frame based on slots so far allocated in    function F.    This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;    the caller may have to do that.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|get_func_frame_size
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|FRAME_GROWS_DOWNWARD
condition|)
return|return
operator|-
name|f
operator|->
name|x_frame_offset
return|;
else|else
return|return
name|f
operator|->
name|x_frame_offset
return|;
block|}
end_function

begin_comment
comment|/* Return size needed for stack frame based on slots so far allocated.    This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;    the caller may have to do that.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|get_frame_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|get_func_frame_size
argument_list|(
name|cfun
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Issue an error message and return TRUE if frame OFFSET overflows in    the signed target pointer arithmetics for function FUNC.  Otherwise    return FALSE.  */
end_comment

begin_function
name|bool
name|frame_offset_overflow
parameter_list|(
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|tree
name|func
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|size
init|=
name|FRAME_GROWS_DOWNWARD
condition|?
operator|-
name|offset
else|:
name|offset
decl_stmt|;
if|if
condition|(
name|size
operator|>
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|Pmode
argument_list|)
operator|-
literal|1
operator|)
operator|)
comment|/* Leave room for the fixed part of the frame.  */
operator|-
literal|64
operator|*
name|UNITS_PER_WORD
condition|)
block|{
name|error
argument_list|(
literal|"%Jtotal size of local objects too large"
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Allocate a stack slot of SIZE bytes and return a MEM rtx for it    with machine mode MODE.     ALIGN controls the amount of alignment for the address of the slot:    0 means according to MODE,    -1 means use BIGGEST_ALIGNMENT and round size to multiple of that,    -2 means use BITS_PER_UNIT,    positive specifies alignment boundary in bits.     We do not round to stack_boundary here.     FUNCTION specifies the function to allocate in.  */
end_comment

begin_function
specifier|static
name|rtx
name|assign_stack_local_1
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|align
parameter_list|,
name|struct
name|function
modifier|*
name|function
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|bigend_correction
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|alignment
decl_stmt|;
name|int
name|frame_off
decl_stmt|,
name|frame_alignment
decl_stmt|,
name|frame_phase
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|0
condition|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
else|else
name|alignment
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Allow the target to (possibly) increase the alignment of this 	 stack slot.  */
name|type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|alignment
operator|=
name|LOCAL_ALIGNMENT
argument_list|(
name|type
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|alignment
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|==
operator|-
literal|1
condition|)
block|{
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|size
operator|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|==
operator|-
literal|2
condition|)
name|alignment
operator|=
literal|1
expr_stmt|;
comment|/* BITS_PER_UNIT / BITS_PER_UNIT */
else|else
name|alignment
operator|=
name|align
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|FRAME_GROWS_DOWNWARD
condition|)
name|function
operator|->
name|x_frame_offset
operator|-=
name|size
expr_stmt|;
comment|/* Ignore alignment we can't do with expected alignment of the boundary.  */
if|if
condition|(
name|alignment
operator|*
name|BITS_PER_UNIT
operator|>
name|PREFERRED_STACK_BOUNDARY
condition|)
name|alignment
operator|=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|function
operator|->
name|stack_alignment_needed
operator|<
name|alignment
operator|*
name|BITS_PER_UNIT
condition|)
name|function
operator|->
name|stack_alignment_needed
operator|=
name|alignment
operator|*
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Calculate how many bytes the start of local variables is off from      stack alignment.  */
name|frame_alignment
operator|=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|frame_off
operator|=
name|STARTING_FRAME_OFFSET
operator|%
name|frame_alignment
expr_stmt|;
name|frame_phase
operator|=
name|frame_off
condition|?
name|frame_alignment
operator|-
name|frame_off
else|:
literal|0
expr_stmt|;
comment|/* Round the frame offset to the specified alignment.  The default is      to always honor requests to align the stack but a port may choose to      do its own stack alignment by defining STACK_ALIGNMENT_NEEDED.  */
if|if
condition|(
name|STACK_ALIGNMENT_NEEDED
operator|||
name|mode
operator|!=
name|BLKmode
operator|||
name|size
operator|!=
literal|0
condition|)
block|{
comment|/*  We must be careful here, since FRAME_OFFSET might be negative and 	  division with a negative dividend isn't as well defined as we might 	  like.  So we instead assume that ALIGNMENT is a power of two and 	  use logical operations which are unambiguous.  */
if|if
condition|(
name|FRAME_GROWS_DOWNWARD
condition|)
name|function
operator|->
name|x_frame_offset
operator|=
operator|(
name|FLOOR_ROUND
argument_list|(
name|function
operator|->
name|x_frame_offset
operator|-
name|frame_phase
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|alignment
argument_list|)
operator|+
name|frame_phase
operator|)
expr_stmt|;
else|else
name|function
operator|->
name|x_frame_offset
operator|=
operator|(
name|CEIL_ROUND
argument_list|(
name|function
operator|->
name|x_frame_offset
operator|-
name|frame_phase
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|alignment
argument_list|)
operator|+
name|frame_phase
operator|)
expr_stmt|;
block|}
comment|/* On a big-endian machine, if we are allocating more space than we will use,      use the least significant bytes of those that are allocated.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|size
condition|)
name|bigend_correction
operator|=
name|size
operator|-
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* If we have already instantiated virtual registers, return the actual      address relative to the frame pointer.  */
if|if
condition|(
name|function
operator|==
name|cfun
operator|&&
name|virtuals_instantiated
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|trunc_int_for_mode
argument_list|(
name|frame_offset
operator|+
name|bigend_correction
operator|+
name|STARTING_FRAME_OFFSET
argument_list|,
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|plus_constant
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|trunc_int_for_mode
argument_list|(
name|function
operator|->
name|x_frame_offset
operator|+
name|bigend_correction
argument_list|,
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FRAME_GROWS_DOWNWARD
condition|)
name|function
operator|->
name|x_frame_offset
operator|+=
name|size
expr_stmt|;
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|MEM_NOTRAP_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|function
operator|->
name|x_stack_slot_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|function
operator|->
name|x_stack_slot_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_offset_overflow
argument_list|(
name|function
operator|->
name|x_frame_offset
argument_list|,
name|function
operator|->
name|decl
argument_list|)
condition|)
name|function
operator|->
name|x_frame_offset
operator|=
literal|0
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Wrapper around assign_stack_local_1;  assign a local stack slot for the    current function.  */
end_comment

begin_function
name|rtx
name|assign_stack_local
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
return|return
name|assign_stack_local_1
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|cfun
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Removes temporary slot TEMP from LIST.  */
end_comment

begin_function
specifier|static
name|void
name|cut_slot_from_list
parameter_list|(
name|struct
name|temp_slot
modifier|*
name|temp
parameter_list|,
name|struct
name|temp_slot
modifier|*
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|temp
operator|->
name|next
condition|)
name|temp
operator|->
name|next
operator|->
name|prev
operator|=
name|temp
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|prev
condition|)
name|temp
operator|->
name|prev
operator|->
name|next
operator|=
name|temp
operator|->
name|next
expr_stmt|;
else|else
operator|*
name|list
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|temp
operator|->
name|prev
operator|=
name|temp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Inserts temporary slot TEMP to LIST.  */
end_comment

begin_function
specifier|static
name|void
name|insert_slot_to_list
parameter_list|(
name|struct
name|temp_slot
modifier|*
name|temp
parameter_list|,
name|struct
name|temp_slot
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|temp
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
operator|*
name|list
condition|)
operator|(
operator|*
name|list
operator|)
operator|->
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
operator|*
name|list
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the list of used temp slots at LEVEL.  */
end_comment

begin_function
specifier|static
name|struct
name|temp_slot
modifier|*
modifier|*
name|temp_slots_at_level
parameter_list|(
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|level
operator|>=
operator|(
name|int
operator|)
name|VEC_length
argument_list|(
name|temp_slot_p
argument_list|,
name|used_temp_slots
argument_list|)
condition|)
block|{
name|size_t
name|old_length
init|=
name|VEC_length
argument_list|(
name|temp_slot_p
argument_list|,
name|used_temp_slots
argument_list|)
decl_stmt|;
name|temp_slot_p
modifier|*
name|p
decl_stmt|;
name|VEC_safe_grow
argument_list|(
name|temp_slot_p
argument_list|,
name|gc
argument_list|,
name|used_temp_slots
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|VEC_address
argument_list|(
name|temp_slot_p
argument_list|,
name|used_temp_slots
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|p
index|[
name|old_length
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_slot_p
argument_list|)
operator|*
operator|(
name|level
operator|+
literal|1
operator|-
name|old_length
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
operator|(
name|VEC_address
argument_list|(
name|temp_slot_p
argument_list|,
name|used_temp_slots
argument_list|)
index|[
name|level
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the maximal temporary slot level.  */
end_comment

begin_function
specifier|static
name|int
name|max_slot_level
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|used_temp_slots
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|VEC_length
argument_list|(
name|temp_slot_p
argument_list|,
name|used_temp_slots
argument_list|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Moves temporary slot TEMP to LEVEL.  */
end_comment

begin_function
specifier|static
name|void
name|move_slot_to_level
parameter_list|(
name|struct
name|temp_slot
modifier|*
name|temp
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|cut_slot_from_list
argument_list|(
name|temp
argument_list|,
name|temp_slots_at_level
argument_list|(
name|temp
operator|->
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|insert_slot_to_list
argument_list|(
name|temp
argument_list|,
name|temp_slots_at_level
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|level
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make temporary slot TEMP available.  */
end_comment

begin_function
specifier|static
name|void
name|make_slot_available
parameter_list|(
name|struct
name|temp_slot
modifier|*
name|temp
parameter_list|)
block|{
name|cut_slot_from_list
argument_list|(
name|temp
argument_list|,
name|temp_slots_at_level
argument_list|(
name|temp
operator|->
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|insert_slot_to_list
argument_list|(
name|temp
argument_list|,
operator|&
name|avail_temp_slots
argument_list|)
expr_stmt|;
name|temp
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|level
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a temporary stack slot and record it for possible later    reuse.     MODE is the machine mode to be given to the returned rtx.     SIZE is the size in units of the space required.  We do no rounding here    since assign_stack_local will do any required rounding.     KEEP is 1 if this slot is to be retained after a call to    free_temp_slots.  Automatic variables for a block are allocated    with this flag.  KEEP values of 2 or 3 were needed respectively    for variables whose lifetime is controlled by CLEANUP_POINT_EXPRs    or for SAVE_EXPRs, but they are now unused.     TYPE is the type that will be used for the stack slot.  */
end_comment

begin_function
name|rtx
name|assign_stack_temp_for_type
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|keep
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|unsigned
name|int
name|align
decl_stmt|;
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|,
modifier|*
name|best_p
init|=
literal|0
decl_stmt|,
modifier|*
name|selected
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|rtx
name|slot
decl_stmt|;
comment|/* If SIZE is -1 it means that somebody tried to allocate a temporary      of a variable size.  */
name|gcc_assert
argument_list|(
name|size
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* These are now unused.  */
name|gcc_assert
argument_list|(
name|keep
operator|<=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|align
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
else|else
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|align
operator|=
name|LOCAL_ALIGNMENT
argument_list|(
name|type
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Try to find an available, already-allocated temporary of the proper      mode which meets the size and alignment requirements.  Choose the      smallest one with the closest alignment.          If assign_stack_temp is called outside of the tree->rtl expansion,      we cannot reuse the stack slots (that may still refer to      VIRTUAL_STACK_VARS_REGNUM).  */
if|if
condition|(
operator|!
name|virtuals_instantiated
condition|)
block|{
for|for
control|(
name|p
operator|=
name|avail_temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|align
operator|>=
name|align
operator|&&
name|p
operator|->
name|size
operator|>=
name|size
operator|&&
name|GET_MODE
argument_list|(
name|p
operator|->
name|slot
argument_list|)
operator|==
name|mode
operator|&&
name|objects_must_conflict_p
argument_list|(
name|p
operator|->
name|type
argument_list|,
name|type
argument_list|)
operator|&&
operator|(
name|best_p
operator|==
literal|0
operator|||
name|best_p
operator|->
name|size
operator|>
name|p
operator|->
name|size
operator|||
operator|(
name|best_p
operator|->
name|size
operator|==
name|p
operator|->
name|size
operator|&&
name|best_p
operator|->
name|align
operator|>
name|p
operator|->
name|align
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|align
operator|==
name|align
operator|&&
name|p
operator|->
name|size
operator|==
name|size
condition|)
block|{
name|selected
operator|=
name|p
expr_stmt|;
name|cut_slot_from_list
argument_list|(
name|selected
argument_list|,
operator|&
name|avail_temp_slots
argument_list|)
expr_stmt|;
name|best_p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|best_p
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
comment|/* Make our best, if any, the one to use.  */
if|if
condition|(
name|best_p
condition|)
block|{
name|selected
operator|=
name|best_p
expr_stmt|;
name|cut_slot_from_list
argument_list|(
name|selected
argument_list|,
operator|&
name|avail_temp_slots
argument_list|)
expr_stmt|;
comment|/* If there are enough aligned bytes left over, make them into a new 	 temp_slot so that the extra bytes don't get wasted.  Do this only 	 for BLKmode slots, so that we can be sure of the alignment.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|best_p
operator|->
name|slot
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|int
name|alignment
init|=
name|best_p
operator|->
name|align
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|rounded_size
init|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
if|if
condition|(
name|best_p
operator|->
name|size
operator|-
name|rounded_size
operator|>=
name|alignment
condition|)
block|{
name|p
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_slot
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|in_use
operator|=
name|p
operator|->
name|addr_taken
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|best_p
operator|->
name|size
operator|-
name|rounded_size
expr_stmt|;
name|p
operator|->
name|base_offset
operator|=
name|best_p
operator|->
name|base_offset
operator|+
name|rounded_size
expr_stmt|;
name|p
operator|->
name|full_size
operator|=
name|best_p
operator|->
name|full_size
operator|-
name|rounded_size
expr_stmt|;
name|p
operator|->
name|slot
operator|=
name|adjust_address_nv
argument_list|(
name|best_p
operator|->
name|slot
argument_list|,
name|BLKmode
argument_list|,
name|rounded_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|align
operator|=
name|best_p
operator|->
name|align
expr_stmt|;
name|p
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|best_p
operator|->
name|type
expr_stmt|;
name|insert_slot_to_list
argument_list|(
name|p
argument_list|,
operator|&
name|avail_temp_slots
argument_list|)
expr_stmt|;
name|stack_slot_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|p
operator|->
name|slot
argument_list|,
name|stack_slot_list
argument_list|)
expr_stmt|;
name|best_p
operator|->
name|size
operator|=
name|rounded_size
expr_stmt|;
name|best_p
operator|->
name|full_size
operator|=
name|rounded_size
expr_stmt|;
block|}
block|}
block|}
comment|/* If we still didn't find one, make a new temporary.  */
if|if
condition|(
name|selected
operator|==
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|frame_offset_old
init|=
name|frame_offset
decl_stmt|;
name|p
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_slot
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are passing an explicit alignment request to assign_stack_local. 	 One side effect of that is assign_stack_local will not round SIZE 	 to ensure the frame offset remains suitably aligned.  	 So for requests which depended on the rounding of SIZE, we go ahead 	 and round it now.  We also make sure ALIGNMENT is at least 	 BIGGEST_ALIGNMENT.  */
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|BLKmode
operator|||
name|align
operator|==
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
name|p
operator|->
name|slot
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
operator|(
name|mode
operator|==
name|BLKmode
condition|?
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
operator|(
name|int
operator|)
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
else|:
name|size
operator|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|p
operator|->
name|align
operator|=
name|align
expr_stmt|;
comment|/* The following slot size computation is necessary because we don't 	 know the actual size of the temporary slot until assign_stack_local 	 has performed all the frame alignment and size rounding for the 	 requested temporary.  Note that extra space added for alignment 	 can be either above or below this stack slot depending on which 	 way the frame grows.  We include the extra space if and only if it 	 is above this slot.  */
if|if
condition|(
name|FRAME_GROWS_DOWNWARD
condition|)
name|p
operator|->
name|size
operator|=
name|frame_offset_old
operator|-
name|frame_offset
expr_stmt|;
else|else
name|p
operator|->
name|size
operator|=
name|size
expr_stmt|;
comment|/* Now define the fields used by combine_temp_slots.  */
if|if
condition|(
name|FRAME_GROWS_DOWNWARD
condition|)
block|{
name|p
operator|->
name|base_offset
operator|=
name|frame_offset
expr_stmt|;
name|p
operator|->
name|full_size
operator|=
name|frame_offset_old
operator|-
name|frame_offset
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|base_offset
operator|=
name|frame_offset_old
expr_stmt|;
name|p
operator|->
name|full_size
operator|=
name|frame_offset
operator|-
name|frame_offset_old
expr_stmt|;
block|}
name|p
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|selected
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|=
name|selected
expr_stmt|;
name|p
operator|->
name|in_use
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|addr_taken
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|level
operator|=
name|temp_slot_level
expr_stmt|;
name|p
operator|->
name|keep
operator|=
name|keep
expr_stmt|;
name|pp
operator|=
name|temp_slots_at_level
argument_list|(
name|p
operator|->
name|level
argument_list|)
expr_stmt|;
name|insert_slot_to_list
argument_list|(
name|p
argument_list|,
name|pp
argument_list|)
expr_stmt|;
comment|/* Create a new MEM rtx to avoid clobbering MEM flags of old slots.  */
name|slot
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|p
operator|->
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|stack_slot_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|slot
argument_list|,
name|stack_slot_list
argument_list|)
expr_stmt|;
comment|/* If we know the alias set for the memory that will be used, use      it.  If there's no TYPE, then we don't know anything about the      alias set for the memory.  */
name|set_mem_alias_set
argument_list|(
name|slot
argument_list|,
name|type
condition|?
name|get_alias_set
argument_list|(
name|type
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|slot
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* If a type is specified, set the relevant flags.  */
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
name|MEM_VOLATILE_P
argument_list|(
name|slot
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|slot
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MEM_NOTRAP_P
argument_list|(
name|slot
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Allocate a temporary stack slot and record it for possible later    reuse.  First three arguments are same as in preceding function.  */
end_comment

begin_function
name|rtx
name|assign_stack_temp
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|keep
parameter_list|)
block|{
return|return
name|assign_stack_temp_for_type
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
name|keep
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign a temporary.    If TYPE_OR_DECL is a decl, then we are doing it on behalf of the decl    and so that should be used in error messages.  In either case, we    allocate of the given type.    KEEP is as for assign_stack_temp.    MEMORY_REQUIRED is 1 if the result must be addressable stack memory;    it is 0 if a register is OK.    DONT_PROMOTE is 1 if we should not promote values in register    to wider modes.  */
end_comment

begin_function
name|rtx
name|assign_temp
parameter_list|(
name|tree
name|type_or_decl
parameter_list|,
name|int
name|keep
parameter_list|,
name|int
name|memory_required
parameter_list|,
name|int
name|dont_promote
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_MODE
name|int
name|unsignedp
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DECL_P
argument_list|(
name|type_or_decl
argument_list|)
condition|)
name|decl
operator|=
name|type_or_decl
operator|,
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|NULL
operator|,
name|type
operator|=
name|type_or_decl
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_MODE
name|unsignedp
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
name|memory_required
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* Zero sized arrays are GNU C extension.  Set size to 1 to avoid 	 problems with allocating the stack space.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
comment|/* Unfortunately, we don't yet know how to allocate variable-sized 	 temporaries.  However, sometimes we can find a fixed upper limit on 	 the size, so try that instead.  */
elseif|else
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
name|size
operator|=
name|max_int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The size of the temporary may be too large to fit into an integer.  */
comment|/* ??? Not sure this should happen except for user silliness, so limit 	 this to things that aren't compiler-generated temporaries.  The 	 rest of the time we'll die in assign_stack_temp_for_type.  */
if|if
condition|(
name|decl
operator|&&
name|size
operator|==
operator|-
literal|1
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"size of variable %q+D is too large"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
name|tmp
operator|=
name|assign_stack_temp_for_type
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
name|keep
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
ifdef|#
directive|ifdef
name|PROMOTE_MODE
if|if
condition|(
operator|!
name|dont_promote
condition|)
name|mode
operator|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Combine temporary stack slots which are adjacent on the stack.     This allows for better use of already allocated stack space.  This is only    done for BLKmode slots because we can be sure that we won't have alignment    problems in this case.  */
end_comment

begin_function
specifier|static
name|void
name|combine_temp_slots
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|next_q
decl_stmt|;
name|int
name|num_slots
decl_stmt|;
comment|/* We can't combine slots, because the information about which slot      is in which alias set will be lost.  */
if|if
condition|(
name|flag_strict_aliasing
condition|)
return|return;
comment|/* If there are a lot of temp slots, don't do anything unless      high levels of optimization.  */
if|if
condition|(
operator|!
name|flag_expensive_optimizations
condition|)
for|for
control|(
name|p
operator|=
name|avail_temp_slots
operator|,
name|num_slots
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
operator|,
name|num_slots
operator|++
control|)
if|if
condition|(
name|num_slots
operator|>
literal|100
operator|||
operator|(
name|num_slots
operator|>
literal|10
operator|&&
name|optimize
operator|==
literal|0
operator|)
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|avail_temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|int
name|delete_p
init|=
literal|0
decl_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|p
operator|->
name|slot
argument_list|)
operator|!=
name|BLKmode
condition|)
continue|continue;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|next
init|;
name|q
condition|;
name|q
operator|=
name|next_q
control|)
block|{
name|int
name|delete_q
init|=
literal|0
decl_stmt|;
name|next_q
operator|=
name|q
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|q
operator|->
name|slot
argument_list|)
operator|!=
name|BLKmode
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|base_offset
operator|+
name|p
operator|->
name|full_size
operator|==
name|q
operator|->
name|base_offset
condition|)
block|{
comment|/* Q comes after P; combine Q into P.  */
name|p
operator|->
name|size
operator|+=
name|q
operator|->
name|size
expr_stmt|;
name|p
operator|->
name|full_size
operator|+=
name|q
operator|->
name|full_size
expr_stmt|;
name|delete_q
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|base_offset
operator|+
name|q
operator|->
name|full_size
operator|==
name|p
operator|->
name|base_offset
condition|)
block|{
comment|/* P comes after Q; combine P into Q.  */
name|q
operator|->
name|size
operator|+=
name|p
operator|->
name|size
expr_stmt|;
name|q
operator|->
name|full_size
operator|+=
name|p
operator|->
name|full_size
expr_stmt|;
name|delete_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|delete_q
condition|)
name|cut_slot_from_list
argument_list|(
name|q
argument_list|,
operator|&
name|avail_temp_slots
argument_list|)
expr_stmt|;
block|}
comment|/* Either delete P or advance past it.  */
if|if
condition|(
name|delete_p
condition|)
name|cut_slot_from_list
argument_list|(
name|p
argument_list|,
operator|&
name|avail_temp_slots
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the temp slot corresponding to the object at address X.  */
end_comment

begin_function
specifier|static
name|struct
name|temp_slot
modifier|*
name|find_temp_slot_from_address
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|max_slot_level
argument_list|()
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
for|for
control|(
name|p
operator|=
operator|*
name|temp_slots_at_level
argument_list|(
name|i
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|p
operator|->
name|slot
argument_list|,
literal|0
argument_list|)
operator|==
name|x
operator|||
name|p
operator|->
name|address
operator|==
name|x
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
name|p
operator|->
name|base_offset
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|p
operator|->
name|base_offset
operator|+
name|p
operator|->
name|full_size
operator|)
condition|)
return|return
name|p
return|;
elseif|else
if|if
condition|(
name|p
operator|->
name|address
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|p
operator|->
name|address
argument_list|)
operator|==
name|EXPR_LIST
condition|)
for|for
control|(
name|next
operator|=
name|p
operator|->
name|address
init|;
name|next
condition|;
name|next
operator|=
name|XEXP
argument_list|(
name|next
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|next
argument_list|,
literal|0
argument_list|)
operator|==
name|x
condition|)
return|return
name|p
return|;
block|}
comment|/* If we have a sum involving a register, see if it points to a temp      slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|p
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|p
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Indicate that NEW is an alternate way of referring to the temp slot    that previously was known by OLD.  */
end_comment

begin_function
name|void
name|update_temp_slot_address
parameter_list|(
name|rtx
name|old
parameter_list|,
name|rtx
name|new
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
condition|)
return|return;
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|old
argument_list|)
expr_stmt|;
comment|/* If we didn't find one, see if both OLD is a PLUS.  If so, and NEW      is a register, see if one operand of the PLUS is a temporary      location.  If so, NEW points into it.  Otherwise, if both OLD and      NEW are a PLUS and if there is a register in common between them.      If so, try a recursive call on those values.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|PLUS
condition|)
return|return;
if|if
condition|(
name|REG_P
argument_list|(
name|new
argument_list|)
condition|)
block|{
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|!=
name|PLUS
condition|)
return|return;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|update_temp_slot_address
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise add an alias for the temp's address.  */
elseif|else
if|if
condition|(
name|p
operator|->
name|address
operator|==
literal|0
condition|)
name|p
operator|->
name|address
operator|=
name|new
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
operator|->
name|address
argument_list|)
operator|!=
name|EXPR_LIST
condition|)
name|p
operator|->
name|address
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|p
operator|->
name|address
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|p
operator|->
name|address
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|new
argument_list|,
name|p
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If X could be a reference to a temporary slot, mark the fact that its    address was taken.  */
end_comment

begin_function
name|void
name|mark_temp_addr_taken
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
comment|/* If X is not in memory or is at a constant address, it cannot be in      a temporary slot.  */
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return;
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
name|p
operator|->
name|addr_taken
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If X could be a reference to a temporary slot, mark that slot as    belonging to the to one level higher than the current level.  If X    matched one of our slots, just mark that one.  Otherwise, we can't    easily predict which it is, so upgrade all of them.  Kept slots    need not be touched.     This is called when an ({...}) construct occurs and a statement    returns a value in memory.  */
end_comment

begin_function
name|void
name|preserve_temp_slots
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
init|=
literal|0
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* If there is no result, we still might have some objects whose address      were taken, so we need to make sure they stay around.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|*
name|temp_slots_at_level
argument_list|(
name|temp_slot_level
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|addr_taken
condition|)
name|move_slot_to_level
argument_list|(
name|p
argument_list|,
name|temp_slot_level
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* If X is a register that is being used as a pointer, see if we have      a temporary slot we know it points to.  To be consistent with      the code below, we really should preserve all non-kept slots      if we can't find a match, but that seems to be much too costly.  */
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|x
argument_list|)
condition|)
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If X is not in memory or is at a constant address, it cannot be in      a temporary slot, but it can contain something whose address was      taken.  */
if|if
condition|(
name|p
operator|==
literal|0
operator|&&
operator|(
operator|!
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|*
name|temp_slots_at_level
argument_list|(
name|temp_slot_level
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|addr_taken
condition|)
name|move_slot_to_level
argument_list|(
name|p
argument_list|,
name|temp_slot_level
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* First see if we can find a match.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
name|find_temp_slot_from_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
comment|/* Move everything at our level whose address was taken to our new 	 level in case we used its address.  */
name|struct
name|temp_slot
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|level
operator|==
name|temp_slot_level
condition|)
block|{
for|for
control|(
name|q
operator|=
operator|*
name|temp_slots_at_level
argument_list|(
name|temp_slot_level
argument_list|)
init|;
name|q
condition|;
name|q
operator|=
name|next
control|)
block|{
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|q
operator|&&
name|q
operator|->
name|addr_taken
condition|)
name|move_slot_to_level
argument_list|(
name|q
argument_list|,
name|temp_slot_level
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|move_slot_to_level
argument_list|(
name|p
argument_list|,
name|temp_slot_level
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|addr_taken
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
comment|/* Otherwise, preserve all non-kept slots at this level.  */
for|for
control|(
name|p
operator|=
operator|*
name|temp_slots_at_level
argument_list|(
name|temp_slot_level
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|keep
condition|)
name|move_slot_to_level
argument_list|(
name|p
argument_list|,
name|temp_slot_level
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free all temporaries used so far.  This is normally called at the    end of generating code for a statement.  */
end_comment

begin_function
name|void
name|free_temp_slots
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|temp_slots_at_level
argument_list|(
name|temp_slot_level
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|keep
condition|)
name|make_slot_available
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|combine_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push deeper into the nesting level for stack temporaries.  */
end_comment

begin_function
name|void
name|push_temp_slots
parameter_list|(
name|void
parameter_list|)
block|{
name|temp_slot_level
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a temporary nesting level.  All slots in use in the current level    are freed.  */
end_comment

begin_function
name|void
name|pop_temp_slots
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|temp_slots_at_level
argument_list|(
name|temp_slot_level
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|make_slot_available
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|combine_temp_slots
argument_list|()
expr_stmt|;
name|temp_slot_level
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize temporary slots.  */
end_comment

begin_function
name|void
name|init_temp_slots
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We have not allocated any temporaries yet.  */
name|avail_temp_slots
operator|=
literal|0
expr_stmt|;
name|used_temp_slots
operator|=
literal|0
expr_stmt|;
name|temp_slot_level
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines are responsible for converting virtual register references    to the actual hard register references once RTL generation is complete.     The following four variables are used for communication between the    routines.  They contain the offsets of the virtual registers from their    respective hard registers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_arg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|var_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dynamic_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|out_arg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cfa_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In most machines, the stack pointer register is equivalent to the bottom    of the stack.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_POINTER_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|STACK_POINTER_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If not defined, pick an appropriate default for the offset of dynamically    allocated memory depending on the value of ACCUMULATE_OUTGOING_ARGS,    REG_PARM_STACK_SPACE, and OUTGOING_REG_PARM_STACK_SPACE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_DYNAMIC_OFFSET
end_ifndef

begin_comment
comment|/* The bottom of the stack points to the actual arguments.  If    REG_PARM_STACK_SPACE is defined, this includes the space for the register    parameters.  However, if OUTGOING_REG_PARM_STACK space is not defined,    stack space for register parameters is not pushed by the caller, but    rather part of the fixed stack areas and hence not included in    `current_function_outgoing_args_size'.  Nevertheless, we must allow    for it when allocating stack dynamic objects.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OUTGOING_REG_PARM_STACK_SPACE
argument_list|)
end_if

begin_define
define|#
directive|define
name|STACK_DYNAMIC_OFFSET
parameter_list|(
name|FNDECL
parameter_list|)
define|\
value|((ACCUMULATE_OUTGOING_ARGS						      \   ? (current_function_outgoing_args_size + REG_PARM_STACK_SPACE (FNDECL)) : 0)\  + (STACK_POINTER_OFFSET))						      \  #else
end_define

begin_define
define|#
directive|define
name|STACK_DYNAMIC_OFFSET
parameter_list|(
name|FNDECL
parameter_list|)
define|\
value|((ACCUMULATE_OUTGOING_ARGS ? current_function_outgoing_args_size : 0)	      \  + (STACK_POINTER_OFFSET))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Given a piece of RTX and a pointer to a HOST_WIDE_INT, if the RTX    is a virtual register, return the equivalent hard register and set the    offset indirectly through the pointer.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|instantiate_new_reg
parameter_list|(
name|rtx
name|x
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|poffset
parameter_list|)
block|{
name|rtx
name|new
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|virtual_incoming_args_rtx
condition|)
name|new
operator|=
name|arg_pointer_rtx
operator|,
name|offset
operator|=
name|in_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_stack_vars_rtx
condition|)
name|new
operator|=
name|frame_pointer_rtx
operator|,
name|offset
operator|=
name|var_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_stack_dynamic_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|dynamic_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_outgoing_args_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|out_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_cfa_rtx
condition|)
block|{
ifdef|#
directive|ifdef
name|FRAME_POINTER_CFA_OFFSET
name|new
operator|=
name|frame_pointer_rtx
expr_stmt|;
else|#
directive|else
name|new
operator|=
name|arg_pointer_rtx
expr_stmt|;
endif|#
directive|endif
name|offset
operator|=
name|cfa_offset
expr_stmt|;
block|}
else|else
return|return
name|NULL_RTX
return|;
operator|*
name|poffset
operator|=
name|offset
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of instantiate_virtual_regs, called via for_each_rtx.    Instantiate any virtual registers present inside of *LOC.  The expression    is simplified, as much as possible, but is not to be considered "valid"    in any sense implied by the target.  If any change is made, set CHANGED    to true.  */
end_comment

begin_function
specifier|static
name|int
name|instantiate_virtual_regs_in_rtx
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|bool
modifier|*
name|changed
init|=
operator|(
name|bool
operator|*
operator|)
name|data
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|new
decl_stmt|;
name|x
operator|=
operator|*
name|loc
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|x
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
operator|*
name|loc
operator|=
name|plus_constant
argument_list|(
name|new
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
operator|*
name|changed
operator|=
name|true
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
case|case
name|PLUS
case|:
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|new
operator|=
name|plus_constant
argument_list|(
name|new
argument_list|,
name|offset
argument_list|)
expr_stmt|;
operator|*
name|loc
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
operator|*
name|changed
operator|=
name|true
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* FIXME -- from old code */
comment|/* If we have (plus (subreg (virtual-reg)) (const_int)), we know 	     we can commute the PLUS and SUBREG because pointers into the 	     frame are well-behaved.  */
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of instantiate_virtual_regs_in_insn.  Return true if X    matches the predicate for insn CODE operand OPERAND.  */
end_comment

begin_function
specifier|static
name|int
name|safe_insn_predicate
parameter_list|(
name|int
name|code
parameter_list|,
name|int
name|operand
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|struct
name|insn_operand_data
modifier|*
name|op_data
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|true
return|;
name|op_data
operator|=
operator|&
name|insn_data
index|[
name|code
index|]
operator|.
name|operand
index|[
name|operand
index|]
expr_stmt|;
if|if
condition|(
name|op_data
operator|->
name|predicate
operator|==
name|NULL
condition|)
return|return
name|true
return|;
return|return
name|op_data
operator|->
name|predicate
argument_list|(
name|x
argument_list|,
name|op_data
operator|->
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of instantiate_virtual_regs.  Instantiate any virtual    registers present inside of insn.  The result will be a valid insn.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_virtual_regs_in_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|insn_code
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|any_change
init|=
name|false
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|new
decl_stmt|,
name|x
decl_stmt|,
name|seq
decl_stmt|;
comment|/* There are some special cases to be handled first.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
comment|/* We're allowed to assign to a virtual register.  This is interpreted 	 to mean that the underlying register gets assigned the inverse 	 transformation.  This is used, for example, in the handling of 	 non-local gotos.  */
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|instantiate_virtual_regs_in_rtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|x
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|new
condition|)
name|emit_move_insn
argument_list|(
name|new
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle a straight copy from a virtual register by generating a 	 new add insn.  The difference between this and falling through 	 to the generic case is avoiding a new pseudo and eliminating a 	 move insn in the initial rtl stream.  */
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&&
name|offset
operator|!=
literal|0
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|x
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|PLUS
argument_list|,
name|new
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SET_DEST
argument_list|(
name|set
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_code
operator|=
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Handle a plus involving a virtual register by determining if the 	 operands remain valid if they're modified in place.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|recog_data
operator|.
name|n_operands
operator|>=
literal|3
operator|&&
name|recog_data
operator|.
name|operand_loc
index|[
literal|1
index|]
operator|==
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|recog_data
operator|.
name|operand_loc
index|[
literal|2
index|]
operator|==
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|1
index|]
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
condition|)
block|{
name|offset
operator|+=
name|INTVAL
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* If the sum is zero, then replace with a plain move.  */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
name|x
operator|=
name|gen_int_mode
argument_list|(
name|offset
argument_list|,
name|recog_data
operator|.
name|operand_mode
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Using validate_change and apply_change_group here leaves 	     recog_data in an invalid state.  Since we know exactly what 	     we want to check, do those two by hand.  */
if|if
condition|(
name|safe_insn_predicate
argument_list|(
name|insn_code
argument_list|,
literal|1
argument_list|,
name|new
argument_list|)
operator|&&
name|safe_insn_predicate
argument_list|(
name|insn_code
argument_list|,
literal|2
argument_list|,
name|x
argument_list|)
condition|)
block|{
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
literal|1
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
literal|1
index|]
operator|=
name|new
expr_stmt|;
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
literal|2
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
literal|2
index|]
operator|=
name|x
expr_stmt|;
name|any_change
operator|=
name|true
expr_stmt|;
comment|/* Fall through into the regular operand fixup loop in 		 order to take care of operands other than 1 and 2.  */
block|}
block|}
block|}
else|else
block|{
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_code
operator|=
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* In the general case, we expect virtual registers to appear only in      operands, and then only as either bare registers or inside memories.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|addr
argument_list|,
name|instantiate_virtual_regs_in_rtx
argument_list|,
operator|&
name|changed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
continue|continue;
name|start_sequence
argument_list|()
expr_stmt|;
name|x
operator|=
name|replace_equiv_address
argument_list|(
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|seq
condition|)
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REG
case|:
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|x
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|x
operator|=
name|new
expr_stmt|;
else|else
block|{
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Careful, special mode predicates may have stuff in 		 insn_data[insn_code].operand[i].mode that isn't useful 		 to us for computing a new value.  */
comment|/* ??? Recognize address_operand and/or "p" constraints 		 to see if (plus new offset) is a valid before we put 		 this through expand_simple_binop.  */
name|x
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|PLUS
argument_list|,
name|new
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUBREG
case|:
name|new
operator|=
name|instantiate_new_reg
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|new
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|,
name|PLUS
argument_list|,
name|new
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|simplify_gen_subreg
argument_list|(
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
argument_list|,
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
comment|/* At this point, X contains the new value for the operand. 	 Validate the new value vs the insn predicate.  Note that 	 asm insns will have insn_code -1 here.  */
if|if
condition|(
operator|!
name|safe_insn_predicate
argument_list|(
name|insn_code
argument_list|,
name|i
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|x
operator|=
name|force_reg
argument_list|(
name|insn_data
index|[
name|insn_code
index|]
operator|.
name|operand
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|seq
condition|)
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
name|any_change
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|any_change
condition|)
block|{
comment|/* Propagate operand changes into the duplicates.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
operator|++
name|i
control|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
operator|(
name|unsigned
operator|)
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
index|]
expr_stmt|;
comment|/* Force re-recognition of the instruction for validation.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|check_asm_operands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"impossible constraint in %<asm%>"
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of instantiate_decls.  Given RTL representing a decl,    do any instantiation required.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decl
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
comment|/* If this is a CONCAT, recurse for the pieces.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|instantiate_decl
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|instantiate_decl
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is not a MEM, no need to do anything.  Similarly if the      address is a constant or a register that is not a virtual register.  */
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|x
argument_list|)
condition|)
return|return;
name|addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|||
operator|(
name|REG_P
argument_list|(
name|addr
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|<
name|FIRST_VIRTUAL_REGISTER
operator|||
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
condition|)
return|return;
name|for_each_rtx
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|instantiate_virtual_regs_in_rtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for instantiate_decls called via walk_tree: Process all decls    in the given DECL_VALUE_EXPR.  */
end_comment

begin_function
specifier|static
name|tree
name|instantiate_expr
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
operator|!
name|EXPR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_RTL_SET_P
argument_list|(
name|t
argument_list|)
condition|)
name|instantiate_decl
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of instantiate_decls: Process all decls in the given    BLOCK node and all its subblocks.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decls_1
parameter_list|(
name|tree
name|let
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|t
argument_list|)
condition|)
name|instantiate_decl
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|v
init|=
name|DECL_VALUE_EXPR
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|walk_tree
argument_list|(
operator|&
name|v
argument_list|,
name|instantiate_expr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process all subblocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|instantiate_decls_1
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan all decls in FNDECL (both variables and parameters) and instantiate    all virtual registers in their DECL_RTL's.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decls
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Process all parameters of the function.  */
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|instantiate_decl
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|instantiate_decl
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|v
init|=
name|DECL_VALUE_EXPR
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|walk_tree
argument_list|(
operator|&
name|v
argument_list|,
name|instantiate_expr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now process all variables defined in the function or its subblocks.  */
name|instantiate_decls_1
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass through the INSNS of function FNDECL and convert virtual register    references to hard register references.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|instantiate_virtual_regs
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Compute the offsets to use for this function.  */
name|in_arg_offset
operator|=
name|FIRST_PARM_OFFSET
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|var_offset
operator|=
name|STARTING_FRAME_OFFSET
expr_stmt|;
name|dynamic_offset
operator|=
name|STACK_DYNAMIC_OFFSET
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|out_arg_offset
operator|=
name|STACK_POINTER_OFFSET
expr_stmt|;
ifdef|#
directive|ifdef
name|FRAME_POINTER_CFA_OFFSET
name|cfa_offset
operator|=
name|FRAME_POINTER_CFA_OFFSET
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|cfa_offset
operator|=
name|ARG_POINTER_CFA_OFFSET
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize recognition, indicating that volatile is OK.  */
name|init_recog
argument_list|()
expr_stmt|;
comment|/* Scan through all the insns, instantiating every virtual register still      present.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* These patterns in the instruction stream can never be recognized. 	   Fortunately, they shouldn't contain virtual registers either.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
condition|)
continue|continue;
name|instantiate_virtual_regs_in_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|for_each_rtx
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|instantiate_virtual_regs_in_rtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Instantiate any virtual registers in CALL_INSN_FUNCTION_USAGE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|for_each_rtx
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|instantiate_virtual_regs_in_rtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Instantiate the virtual registers in the DECLs for debugging purposes.  */
name|instantiate_decls
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* Indicate that, from now on, assign_stack_local should use      frame_pointer_rtx.  */
name|virtuals_instantiated
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_instantiate_virtual_regs
init|=
block|{
literal|"vregs"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|instantiate_virtual_regs
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return 1 if EXP is an aggregate type (or a value with aggregate type).    This means a type for which function calls must pass an address to the    function or get an address back from the function.    EXP may be a type node or an expression (whose type is tested).  */
end_comment

begin_function
name|int
name|aggregate_value_p
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|fntype
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|,
name|nregs
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|tree
name|type
init|=
operator|(
name|TYPE_P
argument_list|(
name|exp
argument_list|)
operator|)
condition|?
name|exp
else|:
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* DECL node associated with FNTYPE when relevant, which we might need to      check for by-invisible-reference returns, typically for CALL_EXPR input      EXPressions.  */
name|tree
name|fndecl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|fntype
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|fndecl
condition|?
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
name|fndecl
operator|=
name|fntype
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|fntype
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* We don't expect other rtl types here.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
literal|0
return|;
comment|/* If the front end has decided that this needs to be passed by      reference, do so.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|RESULT_DECL
operator|)
operator|&&
name|DECL_BY_REFERENCE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If the EXPression is a CALL_EXPR, honor DECL_BY_REFERENCE set on the      called function RESULT_DECL, meaning the function returns in memory by      invisible reference.  This check lets front-ends not set TREE_ADDRESSABLE      on the function type, which used to be the way to request such a return      mechanism but might now be causing troubles at gimplification time if      temporaries with the function type need to be created.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|fndecl
operator|&&
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_BY_REFERENCE
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|return_in_memory
argument_list|(
name|type
argument_list|,
name|fntype
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Types that are TREE_ADDRESSABLE must be constructed in memory,      and thus can't be returned in registers.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flag_pcc_struct_return
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Make sure we have suitable call-clobbered regs to return      the value in; if not, we must return it in memory.  */
name|reg
operator|=
name|hard_function_value
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|fntype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have something other than a REG (e.g. a PARALLEL), then assume      it is OK.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|nregs
operator|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|regno
operator|+
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if we should assign DECL a pseudo register; false if it    should live on the local stack.  */
end_comment

begin_function
name|bool
name|use_register_for_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* Honor volatile.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Honor addressability.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Only register-like things go in registers.  */
if|if
condition|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
name|false
return|;
comment|/* If -ffloat-store specified, don't put explicit float variables      into registers.  */
comment|/* ??? This should be checked after DECL_ARTIFICIAL, but tree-ssa      propagates values across these stores, and it probably shouldn't.  */
if|if
condition|(
name|flag_float_store
operator|&&
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If we're not interested in tracking debugging information for      this decl, then we can certainly put it in a register.  */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
return|return
operator|(
name|optimize
operator|||
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE should be passed by invisible reference.  */
end_comment

begin_function
name|bool
name|pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named_arg
parameter_list|)
block|{
if|if
condition|(
name|type
condition|)
block|{
comment|/* If this type contains non-trivial constructors, then it is 	 forbidden for the middle-end to create any new copies.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* GCC post 3.4 passes *all* variable sized types by reference.  */
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|true
return|;
block|}
return|return
name|targetm
operator|.
name|calls
operator|.
name|pass_by_reference
argument_list|(
name|ca
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named_arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE, which is passed by reference, should be callee    copied instead of caller copied.  */
end_comment

begin_function
name|bool
name|reference_callee_copied
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named_arg
parameter_list|)
block|{
if|if
condition|(
name|type
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|targetm
operator|.
name|calls
operator|.
name|callee_copies
argument_list|(
name|ca
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named_arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Structures to communicate between the subroutines of assign_parms.    The first holds data persistent across all parameters, the second    is cleared out for each parameter.  */
end_comment

begin_struct
struct|struct
name|assign_parm_data_all
block|{
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
name|struct
name|args_size
name|stack_args_size
decl_stmt|;
name|tree
name|function_result_decl
decl_stmt|;
name|tree
name|orig_fnargs
decl_stmt|;
name|rtx
name|conversion_insns
decl_stmt|;
name|HOST_WIDE_INT
name|pretend_args_size
decl_stmt|;
name|HOST_WIDE_INT
name|extra_pretend_bytes
decl_stmt|;
name|int
name|reg_parm_stack_space
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|assign_parm_data_one
block|{
name|tree
name|nominal_type
decl_stmt|;
name|tree
name|passed_type
decl_stmt|;
name|rtx
name|entry_parm
decl_stmt|;
name|rtx
name|stack_parm
decl_stmt|;
name|enum
name|machine_mode
name|nominal_mode
decl_stmt|;
name|enum
name|machine_mode
name|passed_mode
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|;
name|struct
name|locate_and_pad_arg_data
name|locate
decl_stmt|;
name|int
name|partial
decl_stmt|;
name|BOOL_BITFIELD
name|named_arg
range|:
literal|1
decl_stmt|;
name|BOOL_BITFIELD
name|passed_pointer
range|:
literal|1
decl_stmt|;
name|BOOL_BITFIELD
name|on_stack
range|:
literal|1
decl_stmt|;
name|BOOL_BITFIELD
name|loaded_in_reg
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A subroutine of assign_parms.  Initialize ALL.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parms_initialize_all
parameter_list|(
name|struct
name|assign_parm_data_all
modifier|*
name|all
parameter_list|)
block|{
name|tree
name|fntype
decl_stmt|;
name|memset
argument_list|(
name|all
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|all
argument_list|)
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_CUMULATIVE_INCOMING_ARGS
name|INIT_CUMULATIVE_INCOMING_ARGS
argument_list|(
name|all
operator|->
name|args_so_far
argument_list|,
name|fntype
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|#
directive|else
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|all
operator|->
name|args_so_far
argument_list|,
name|fntype
argument_list|,
name|NULL_RTX
argument_list|,
name|current_function_decl
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
name|all
operator|->
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* If ARGS contains entries with complex types, split the entry into two    entries of the component type.  Return a new list of substitutions are    needed, else the old list.  */
end_comment

begin_function
specifier|static
name|tree
name|split_complex_args
parameter_list|(
name|tree
name|args
parameter_list|)
block|{
name|tree
name|p
decl_stmt|;
comment|/* Before allocating memory, check for the common case of no complex.  */
for|for
control|(
name|p
operator|=
name|args
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
argument_list|(
name|type
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
return|return
name|args
return|;
name|found
label|:
name|args
operator|=
name|copy_list
argument_list|(
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|args
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|subtype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|bool
name|addressable
init|=
name|TREE_ADDRESSABLE
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* Rewrite the PARM_DECL's type with its component.  */
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
operator|=
name|subtype
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|p
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|p
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|p
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|p
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* If this arg must go in memory, put it in a pseudo here. 	     We can't allow it to go in memory as per normal parms, 	     because the usual place might not have the imag part 	     adjacent to the real part.  */
name|DECL_ARTIFICIAL
argument_list|(
name|p
argument_list|)
operator|=
name|addressable
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|p
argument_list|)
operator|=
name|addressable
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_decl
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Build a second synthetic decl.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|addressable
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
name|addressable
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Splice it in; skip the new decl.  */
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|decl
expr_stmt|;
name|p
operator|=
name|decl
expr_stmt|;
block|}
block|}
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  Adjust the parameter list to incorporate    the hidden struct return argument, and (abi willing) complex args.    Return the new parameter list.  */
end_comment

begin_function
specifier|static
name|tree
name|assign_parms_augmented_arg_list
parameter_list|(
name|struct
name|assign_parm_data_all
modifier|*
name|all
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|fnargs
init|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
comment|/* If struct value address is treated as the first argument, make it so.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|fndecl
argument_list|)
operator|&&
operator|!
name|current_function_returns_pcc_struct
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|fnargs
expr_stmt|;
name|fnargs
operator|=
name|decl
expr_stmt|;
name|all
operator|->
name|function_result_decl
operator|=
name|decl
expr_stmt|;
block|}
name|all
operator|->
name|orig_fnargs
operator|=
name|fnargs
expr_stmt|;
comment|/* If the target wants to split complex arguments into scalars, do so.  */
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
condition|)
name|fnargs
operator|=
name|split_complex_args
argument_list|(
name|fnargs
argument_list|)
expr_stmt|;
return|return
name|fnargs
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  Examine PARM and pull out type and mode    data for the parameter.  Incorporate ABI specifics such as pass-by-    reference and type promotion.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parm_find_data_types
parameter_list|(
name|struct
name|assign_parm_data_all
modifier|*
name|all
parameter_list|,
name|tree
name|parm
parameter_list|,
name|struct
name|assign_parm_data_one
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|nominal_type
decl_stmt|,
name|passed_type
decl_stmt|;
name|enum
name|machine_mode
name|nominal_mode
decl_stmt|,
name|passed_mode
decl_stmt|,
name|promoted_mode
decl_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NAMED_ARG is a mis-nomer.  We really mean 'non-varadic'. */
if|if
condition|(
operator|!
name|current_function_stdarg
condition|)
name|data
operator|->
name|named_arg
operator|=
literal|1
expr_stmt|;
comment|/* No varadic parms.  */
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
condition|)
name|data
operator|->
name|named_arg
operator|=
literal|1
expr_stmt|;
comment|/* Not the last non-varadic parm. */
elseif|else
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|strict_argument_naming
argument_list|(
operator|&
name|all
operator|->
name|args_so_far
argument_list|)
condition|)
name|data
operator|->
name|named_arg
operator|=
literal|1
expr_stmt|;
comment|/* Only varadic ones are unnamed.  */
else|else
name|data
operator|->
name|named_arg
operator|=
literal|0
expr_stmt|;
comment|/* Treat as varadic.  */
name|nominal_type
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|passed_type
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* Look out for errors propagating this far.  Also, if the parameter's      type is void then its value doesn't matter.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|error_mark_node
comment|/* This can happen after weird syntax errors 	 or if an enum type is defined among the parms.  */
operator|||
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
operator|||
name|passed_type
operator|==
name|NULL
operator|||
name|VOID_TYPE_P
argument_list|(
name|nominal_type
argument_list|)
condition|)
block|{
name|nominal_type
operator|=
name|passed_type
operator|=
name|void_type_node
expr_stmt|;
name|nominal_mode
operator|=
name|passed_mode
operator|=
name|promoted_mode
operator|=
name|VOIDmode
expr_stmt|;
goto|goto
name|egress
goto|;
block|}
comment|/* Find mode of arg as it is passed, and mode of arg as it should be      during execution of this function.  */
name|passed_mode
operator|=
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
expr_stmt|;
name|nominal_mode
operator|=
name|TYPE_MODE
argument_list|(
name|nominal_type
argument_list|)
expr_stmt|;
comment|/* If the parm is to be passed as a transparent union, use the type of      the first field for the tests below.  We have already verified that      the modes are the same.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|passed_type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|passed_type
argument_list|)
condition|)
name|passed_type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|passed_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if this arg was passed by invisible reference.  */
if|if
condition|(
name|pass_by_reference
argument_list|(
operator|&
name|all
operator|->
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|passed_type
argument_list|,
name|data
operator|->
name|named_arg
argument_list|)
condition|)
block|{
name|passed_type
operator|=
name|nominal_type
operator|=
name|build_pointer_type
argument_list|(
name|passed_type
argument_list|)
expr_stmt|;
name|data
operator|->
name|passed_pointer
operator|=
name|true
expr_stmt|;
name|passed_mode
operator|=
name|nominal_mode
operator|=
name|Pmode
expr_stmt|;
block|}
comment|/* Find mode as it is passed by the ABI.  */
name|promoted_mode
operator|=
name|passed_mode
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|promote_function_args
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|passed_type
argument_list|)
decl_stmt|;
name|promoted_mode
operator|=
name|promote_mode
argument_list|(
name|passed_type
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|egress
label|:
name|data
operator|->
name|nominal_type
operator|=
name|nominal_type
expr_stmt|;
name|data
operator|->
name|passed_type
operator|=
name|passed_type
expr_stmt|;
name|data
operator|->
name|nominal_mode
operator|=
name|nominal_mode
expr_stmt|;
name|data
operator|->
name|passed_mode
operator|=
name|passed_mode
expr_stmt|;
name|data
operator|->
name|promoted_mode
operator|=
name|promoted_mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  Invoke setup_incoming_varargs.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parms_setup_varargs
parameter_list|(
name|struct
name|assign_parm_data_all
modifier|*
name|all
parameter_list|,
name|struct
name|assign_parm_data_one
modifier|*
name|data
parameter_list|,
name|bool
name|no_rtl
parameter_list|)
block|{
name|int
name|varargs_pretend_bytes
init|=
literal|0
decl_stmt|;
name|targetm
operator|.
name|calls
operator|.
name|setup_incoming_varargs
argument_list|(
operator|&
name|all
operator|->
name|args_so_far
argument_list|,
name|data
operator|->
name|promoted_mode
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
operator|&
name|varargs_pretend_bytes
argument_list|,
name|no_rtl
argument_list|)
expr_stmt|;
comment|/* If the back-end has requested extra stack space, record how much is      needed.  Do not change pretend_args_size otherwise since it may be      nonzero from an earlier partial argument.  */
if|if
condition|(
name|varargs_pretend_bytes
operator|>
literal|0
condition|)
name|all
operator|->
name|pretend_args_size
operator|=
name|varargs_pretend_bytes
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  Set DATA->ENTRY_PARM corresponding to    the incoming location of the current parameter.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parm_find_entry_rtl
parameter_list|(
name|struct
name|assign_parm_data_all
modifier|*
name|all
parameter_list|,
name|struct
name|assign_parm_data_one
modifier|*
name|data
parameter_list|)
block|{
name|HOST_WIDE_INT
name|pretend_bytes
init|=
literal|0
decl_stmt|;
name|rtx
name|entry_parm
decl_stmt|;
name|bool
name|in_regs
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|promoted_mode
operator|==
name|VOIDmode
condition|)
block|{
name|data
operator|->
name|entry_parm
operator|=
name|data
operator|->
name|stack_parm
operator|=
name|const0_rtx
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
name|entry_parm
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
name|all
operator|->
name|args_so_far
argument_list|,
name|data
operator|->
name|promoted_mode
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
name|data
operator|->
name|named_arg
argument_list|)
expr_stmt|;
else|#
directive|else
name|entry_parm
operator|=
name|FUNCTION_ARG
argument_list|(
name|all
operator|->
name|args_so_far
argument_list|,
name|data
operator|->
name|promoted_mode
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
name|data
operator|->
name|named_arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry_parm
operator|==
literal|0
condition|)
name|data
operator|->
name|promoted_mode
operator|=
name|data
operator|->
name|passed_mode
expr_stmt|;
comment|/* Determine parm's home in the stack, in case it arrives in the stack      or we should pretend it did.  Compute the stack position and rtx where      the argument arrives and its size.       There is one complexity here:  If this was a parameter that would      have been passed in registers, but wasn't only because it is      __builtin_va_alist, we want locate_and_pad_parm to treat it as if      it came in a register so that REG_PARM_STACK_SPACE isn't skipped.      In this case, we call FUNCTION_ARG with NAMED set to 1 instead of 0      as it was the previous time.  */
name|in_regs
operator|=
name|entry_parm
operator|!=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
name|in_regs
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|in_regs
operator|&&
operator|!
name|data
operator|->
name|named_arg
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|pretend_outgoing_varargs_named
argument_list|(
operator|&
name|all
operator|->
name|args_so_far
argument_list|)
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
name|tem
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
name|all
operator|->
name|args_so_far
argument_list|,
name|data
operator|->
name|promoted_mode
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|#
directive|else
name|tem
operator|=
name|FUNCTION_ARG
argument_list|(
name|all
operator|->
name|args_so_far
argument_list|,
name|data
operator|->
name|promoted_mode
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
name|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|in_regs
operator|=
name|tem
operator|!=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If this parameter was passed both in registers and in the stack, use      the copy on the stack.  */
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|must_pass_in_stack
argument_list|(
name|data
operator|->
name|promoted_mode
argument_list|,
name|data
operator|->
name|passed_type
argument_list|)
condition|)
name|entry_parm
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry_parm
condition|)
block|{
name|int
name|partial
decl_stmt|;
name|partial
operator|=
name|targetm
operator|.
name|calls
operator|.
name|arg_partial_bytes
argument_list|(
operator|&
name|all
operator|->
name|args_so_far
argument_list|,
name|data
operator|->
name|promoted_mode
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
name|data
operator|->
name|named_arg
argument_list|)
expr_stmt|;
name|data
operator|->
name|partial
operator|=
name|partial
expr_stmt|;
comment|/* The caller might already have allocated stack space for the 	 register parameters.  */
if|if
condition|(
name|partial
operator|!=
literal|0
operator|&&
name|all
operator|->
name|reg_parm_stack_space
operator|==
literal|0
condition|)
block|{
comment|/* Part of this argument is passed in registers and part 	     is passed on the stack.  Ask the prologue code to extend 	     the stack part so that we can recreate the full value.  	     PRETEND_BYTES is the size of the registers we need to store. 	     CURRENT_FUNCTION_PRETEND_ARGS_SIZE is the amount of extra 	     stack space that the prologue should allocate.  	     Internally, gcc assumes that the argument pointer is aligned 	     to STACK_BOUNDARY bits.  This is used both for alignment 	     optimizations (see init_emit) and to locate arguments that are 	     aligned to more than PARM_BOUNDARY bits.  We must preserve this 	     invariant by rounding CURRENT_FUNCTION_PRETEND_ARGS_SIZE up to 	     a stack boundary.  */
comment|/* We assume at most one partial arg, and it must be the first 	     argument on the stack.  */
name|gcc_assert
argument_list|(
operator|!
name|all
operator|->
name|extra_pretend_bytes
operator|&&
operator|!
name|all
operator|->
name|pretend_args_size
argument_list|)
expr_stmt|;
name|pretend_bytes
operator|=
name|partial
expr_stmt|;
name|all
operator|->
name|pretend_args_size
operator|=
name|CEIL_ROUND
argument_list|(
name|pretend_bytes
argument_list|,
name|STACK_BYTES
argument_list|)
expr_stmt|;
comment|/* We want to align relative to the actual stack pointer, so 	     don't include this in the stack size until later.  */
name|all
operator|->
name|extra_pretend_bytes
operator|=
name|all
operator|->
name|pretend_args_size
expr_stmt|;
block|}
block|}
name|locate_and_pad_parm
argument_list|(
name|data
operator|->
name|promoted_mode
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
name|in_regs
argument_list|,
name|entry_parm
condition|?
name|data
operator|->
name|partial
else|:
literal|0
argument_list|,
name|current_function_decl
argument_list|,
operator|&
name|all
operator|->
name|stack_args_size
argument_list|,
operator|&
name|data
operator|->
name|locate
argument_list|)
expr_stmt|;
comment|/* Adjust offsets to include the pretend args.  */
name|pretend_bytes
operator|=
name|all
operator|->
name|extra_pretend_bytes
operator|-
name|pretend_bytes
expr_stmt|;
name|data
operator|->
name|locate
operator|.
name|slot_offset
operator|.
name|constant
operator|+=
name|pretend_bytes
expr_stmt|;
name|data
operator|->
name|locate
operator|.
name|offset
operator|.
name|constant
operator|+=
name|pretend_bytes
expr_stmt|;
name|data
operator|->
name|entry_parm
operator|=
name|entry_parm
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  If there is actually space on the stack    for this parm, count it in stack_args_size and return true.  */
end_comment

begin_function
specifier|static
name|bool
name|assign_parm_is_stack_parm
parameter_list|(
name|struct
name|assign_parm_data_all
modifier|*
name|all
parameter_list|,
name|struct
name|assign_parm_data_one
modifier|*
name|data
parameter_list|)
block|{
comment|/* Trivially true if we've no incoming register.  */
if|if
condition|(
name|data
operator|->
name|entry_parm
operator|==
name|NULL
condition|)
empty_stmt|;
comment|/* Also true if we're partially in registers and partially not,      since we've arranged to drop the entire argument on the stack.  */
elseif|else
if|if
condition|(
name|data
operator|->
name|partial
operator|!=
literal|0
condition|)
empty_stmt|;
comment|/* Also true if the target says that it's passed in both registers      and on the stack.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_RTX
condition|)
empty_stmt|;
comment|/* Also true if the target says that there's stack allocated for      all register parameters.  */
elseif|else
if|if
condition|(
name|all
operator|->
name|reg_parm_stack_space
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* Otherwise, no, this parameter has no ABI defined stack slot.  */
else|else
return|return
name|false
return|;
name|all
operator|->
name|stack_args_size
operator|.
name|constant
operator|+=
name|data
operator|->
name|locate
operator|.
name|size
operator|.
name|constant
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|locate
operator|.
name|size
operator|.
name|var
condition|)
name|ADD_PARM_SIZE
argument_list|(
name|all
operator|->
name|stack_args_size
argument_list|,
name|data
operator|->
name|locate
operator|.
name|size
operator|.
name|var
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  Given that this parameter is allocated    stack space by the ABI, find it.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parm_find_stack_rtl
parameter_list|(
name|tree
name|parm
parameter_list|,
name|struct
name|assign_parm_data_one
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|offset_rtx
decl_stmt|,
name|stack_parm
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|,
name|boundary
decl_stmt|;
comment|/* If we're passing this arg using a reg, make its stack home the      aligned stack slot.  */
if|if
condition|(
name|data
operator|->
name|entry_parm
condition|)
name|offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|data
operator|->
name|locate
operator|.
name|slot_offset
argument_list|)
expr_stmt|;
else|else
name|offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|data
operator|->
name|locate
operator|.
name|offset
argument_list|)
expr_stmt|;
name|stack_parm
operator|=
name|current_function_internal_arg_pointer
expr_stmt|;
if|if
condition|(
name|offset_rtx
operator|!=
name|const0_rtx
condition|)
name|stack_parm
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_parm
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
name|stack_parm
operator|=
name|gen_rtx_MEM
argument_list|(
name|data
operator|->
name|promoted_mode
argument_list|,
name|stack_parm
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|stack_parm
argument_list|,
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|boundary
operator|=
name|data
operator|->
name|locate
operator|.
name|boundary
expr_stmt|;
name|align
operator|=
name|BITS_PER_UNIT
expr_stmt|;
comment|/* If we're padding upward, we know that the alignment of the slot      is FUNCTION_ARG_BOUNDARY.  If we're using slot_offset, we're      intentionally forcing upward padding.  Otherwise we have to come      up with a guess at the alignment based on OFFSET_RTX.  */
if|if
condition|(
name|data
operator|->
name|locate
operator|.
name|where_pad
operator|!=
name|downward
operator|||
name|data
operator|->
name|entry_parm
condition|)
name|align
operator|=
name|boundary
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|align
operator|=
name|INTVAL
argument_list|(
name|offset_rtx
argument_list|)
operator|*
name|BITS_PER_UNIT
operator||
name|boundary
expr_stmt|;
name|align
operator|=
name|align
operator|&
operator|-
name|align
expr_stmt|;
block|}
name|set_mem_align
argument_list|(
name|stack_parm
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|entry_parm
condition|)
name|set_reg_attrs_for_parm
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|,
name|stack_parm
argument_list|)
expr_stmt|;
name|data
operator|->
name|stack_parm
operator|=
name|stack_parm
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  Adjust DATA->ENTRY_RTL such that it's    always valid and contiguous.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parm_adjust_entry_rtl
parameter_list|(
name|struct
name|assign_parm_data_one
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|entry_parm
init|=
name|data
operator|->
name|entry_parm
decl_stmt|;
name|rtx
name|stack_parm
init|=
name|data
operator|->
name|stack_parm
decl_stmt|;
comment|/* If this parm was passed part in regs and part in memory, pretend it      arrived entirely in memory by pushing the register-part onto the stack.      In the special case of a DImode or DFmode that is split, we could put      it together in a pseudoreg directly, but for now that's not worth      bothering with.  */
if|if
condition|(
name|data
operator|->
name|partial
operator|!=
literal|0
condition|)
block|{
comment|/* Handle calls that pass values in multiple non-contiguous 	 locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_store
argument_list|(
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|entry_parm
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
name|int_size_in_bytes
argument_list|(
name|data
operator|->
name|passed_type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|data
operator|->
name|partial
operator|%
name|UNITS_PER_WORD
operator|==
literal|0
argument_list|)
expr_stmt|;
name|move_block_from_reg
argument_list|(
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|data
operator|->
name|partial
operator|/
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
name|entry_parm
operator|=
name|stack_parm
expr_stmt|;
block|}
comment|/* If we didn't decide this parm came in a register, by default it came      on the stack.  */
elseif|else
if|if
condition|(
name|entry_parm
operator|==
name|NULL
condition|)
name|entry_parm
operator|=
name|stack_parm
expr_stmt|;
comment|/* When an argument is passed in multiple locations, we can't make use      of this information, but we can save some copying if the whole argument      is passed in a single register.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|data
operator|->
name|nominal_mode
operator|!=
name|BLKmode
operator|&&
name|data
operator|->
name|passed_mode
operator|!=
name|BLKmode
condition|)
block|{
name|size_t
name|i
decl_stmt|,
name|len
init|=
name|XVECLEN
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|data
operator|->
name|passed_mode
operator|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|entry_parm
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|data
operator|->
name|entry_parm
operator|=
name|entry_parm
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  Adjust DATA->STACK_RTL such that it's    always valid and properly aligned.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parm_adjust_stack_rtl
parameter_list|(
name|struct
name|assign_parm_data_one
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|stack_parm
init|=
name|data
operator|->
name|stack_parm
decl_stmt|;
comment|/* If we can't trust the parm stack slot to be aligned enough for its      ultimate type, don't use that slot after entry.  We'll make another      stack slot, if we need one.  */
if|if
condition|(
name|stack_parm
operator|&&
operator|(
operator|(
name|STRICT_ALIGNMENT
operator|&&
name|GET_MODE_ALIGNMENT
argument_list|(
name|data
operator|->
name|nominal_mode
argument_list|)
operator|>
name|MEM_ALIGN
argument_list|(
name|stack_parm
argument_list|)
operator|)
operator|||
operator|(
name|data
operator|->
name|nominal_type
operator|&&
name|TYPE_ALIGN
argument_list|(
name|data
operator|->
name|nominal_type
argument_list|)
operator|>
name|MEM_ALIGN
argument_list|(
name|stack_parm
argument_list|)
operator|&&
name|MEM_ALIGN
argument_list|(
name|stack_parm
argument_list|)
operator|<
name|PREFERRED_STACK_BOUNDARY
operator|)
operator|)
condition|)
name|stack_parm
operator|=
name|NULL
expr_stmt|;
comment|/* If parm was passed in memory, and we need to convert it on entry,      don't store it back in that same slot.  */
elseif|else
if|if
condition|(
name|data
operator|->
name|entry_parm
operator|==
name|stack_parm
operator|&&
name|data
operator|->
name|nominal_mode
operator|!=
name|BLKmode
operator|&&
name|data
operator|->
name|nominal_mode
operator|!=
name|data
operator|->
name|passed_mode
condition|)
name|stack_parm
operator|=
name|NULL
expr_stmt|;
comment|/* If stack protection is in effect for this function, don't leave any      pointers in their passed stack slots.  */
elseif|else
if|if
condition|(
name|cfun
operator|->
name|stack_protect_guard
operator|&&
operator|(
name|flag_stack_protect
operator|==
literal|2
operator|||
name|data
operator|->
name|passed_pointer
operator|||
name|POINTER_TYPE_P
argument_list|(
name|data
operator|->
name|nominal_type
argument_list|)
operator|)
condition|)
name|stack_parm
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|stack_parm
operator|=
name|stack_parm
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  Return true if the current parameter    should be stored as a BLKmode in the current frame.  */
end_comment

begin_function
specifier|static
name|bool
name|assign_parm_setup_block_p
parameter_list|(
name|struct
name|assign_parm_data_one
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|nominal_mode
operator|==
name|BLKmode
condition|)
return|return
name|true
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
name|true
return|;
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
comment|/* Only assign_parm_setup_block knows how to deal with register arguments      that are padded at the least significant end.  */
if|if
condition|(
name|REG_P
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|data
operator|->
name|promoted_mode
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|&&
operator|(
name|BLOCK_REG_PADDING
argument_list|(
name|data
operator|->
name|passed_mode
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
literal|1
argument_list|)
operator|==
operator|(
name|BYTES_BIG_ENDIAN
condition|?
name|upward
else|:
name|downward
operator|)
operator|)
condition|)
return|return
name|true
return|;
endif|#
directive|endif
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  Arrange for the parameter to be     present and valid in DATA->STACK_RTL.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parm_setup_block
parameter_list|(
name|struct
name|assign_parm_data_all
modifier|*
name|all
parameter_list|,
name|tree
name|parm
parameter_list|,
name|struct
name|assign_parm_data_one
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|entry_parm
init|=
name|data
operator|->
name|entry_parm
decl_stmt|;
name|rtx
name|stack_parm
init|=
name|data
operator|->
name|stack_parm
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
name|HOST_WIDE_INT
name|size_stored
decl_stmt|;
name|rtx
name|orig_entry_parm
init|=
name|entry_parm
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
condition|)
name|entry_parm
operator|=
name|emit_group_move_into_temps
argument_list|(
name|entry_parm
argument_list|)
expr_stmt|;
comment|/* If we've a non-block object that's nevertheless passed in parts,      reconstitute it in register operations rather than on the stack.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|data
operator|->
name|nominal_mode
operator|!=
name|BLKmode
condition|)
block|{
name|rtx
name|elt0
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|orig_entry_parm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|XVECLEN
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|)
operator|>
literal|1
operator|||
name|hard_regno_nregs
index|[
name|REGNO
argument_list|(
name|elt0
argument_list|)
index|]
index|[
name|GET_MODE
argument_list|(
name|elt0
argument_list|)
index|]
operator|>
literal|1
operator|)
operator|&&
name|use_register_for_decl
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|rtx
name|parmreg
init|=
name|gen_reg_rtx
argument_list|(
name|data
operator|->
name|nominal_mode
argument_list|)
decl_stmt|;
name|push_to_sequence
argument_list|(
name|all
operator|->
name|conversion_insns
argument_list|)
expr_stmt|;
comment|/* For values returned in multiple registers, handle possible 	     incompatible calls to emit_group_store.  	     For example, the following would be invalid, and would have to 	     be fixed by the conditional below:  	     emit_group_store ((reg:SF), (parallel:DF)) 	     emit_group_store ((reg:SI), (parallel:DI))  	     An example of this are doubles in e500 v2: 	     (parallel:DF (expr_list (reg:SI) (const_int 0)) 	     (expr_list (reg:SI) (const_int 4))).  */
if|if
condition|(
name|data
operator|->
name|nominal_mode
operator|!=
name|data
operator|->
name|passed_mode
condition|)
block|{
name|rtx
name|t
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|emit_group_store
argument_list|(
name|t
argument_list|,
name|entry_parm
argument_list|,
name|NULL_TREE
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|parmreg
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_group_store
argument_list|(
name|parmreg
argument_list|,
name|entry_parm
argument_list|,
name|data
operator|->
name|nominal_type
argument_list|,
name|int_size_in_bytes
argument_list|(
name|data
operator|->
name|nominal_type
argument_list|)
argument_list|)
expr_stmt|;
name|all
operator|->
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|parmreg
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|data
operator|->
name|passed_type
argument_list|)
expr_stmt|;
name|size_stored
operator|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_parm
operator|==
literal|0
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|parm
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|parm
argument_list|)
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|stack_parm
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|size_stored
argument_list|,
name|DECL_ALIGN
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
operator|==
name|size
condition|)
name|PUT_MODE
argument_list|(
name|stack_parm
argument_list|,
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|stack_parm
argument_list|,
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If a BLKmode arrives in registers, copy it to a stack slot.  Handle      calls that pass values in multiple non-contiguous locations.  */
if|if
condition|(
name|REG_P
argument_list|(
name|entry_parm
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|rtx
name|mem
decl_stmt|;
comment|/* Note that we will be storing an integral number of words. 	 So we have to be careful to ensure that we allocate an 	 integral number of words.  We do this above when we call 	 assign_stack_local if space was not allocated in the argument 	 list.  If it was, this will not work if PARM_BOUNDARY is not 	 a multiple of BITS_PER_WORD.  It isn't clear how to fix this 	 if it becomes a problem.  Exception is when BLKmode arrives 	 with arguments not conforming to word_mode.  */
if|if
condition|(
name|data
operator|->
name|stack_parm
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
condition|)
empty_stmt|;
else|else
name|gcc_assert
argument_list|(
operator|!
name|size
operator|||
operator|!
operator|(
name|PARM_BOUNDARY
operator|%
name|BITS_PER_WORD
operator|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
expr_stmt|;
comment|/* Handle values in multiple non-contiguous locations.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|push_to_sequence
argument_list|(
name|all
operator|->
name|conversion_insns
argument_list|)
expr_stmt|;
name|emit_group_store
argument_list|(
name|mem
argument_list|,
name|entry_parm
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|all
operator|->
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* If SIZE is that of a mode no bigger than a word, just use 	 that mode's store operation.  */
elseif|else
if|if
condition|(
name|size
operator|<=
name|UNITS_PER_WORD
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
operator|&&
operator|(
name|size
operator|==
name|UNITS_PER_WORD
operator|||
operator|(
name|BLOCK_REG_PADDING
argument_list|(
name|mode
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
literal|1
argument_list|)
operator|!=
operator|(
name|BYTES_BIG_ENDIAN
condition|?
name|upward
else|:
name|downward
operator|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Blocks smaller than a word on a BYTES_BIG_ENDIAN 	     machine must be aligned to the left before storing 	     to memory.  Note that the previous test doesn't 	     handle all cases (e.g. SIZE == 3).  */
elseif|else
if|if
condition|(
name|size
operator|!=
name|UNITS_PER_WORD
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
operator|&&
operator|(
name|BLOCK_REG_PADDING
argument_list|(
name|mode
argument_list|,
name|data
operator|->
name|passed_type
argument_list|,
literal|1
argument_list|)
operator|==
name|downward
operator|)
else|#
directive|else
operator|&&
name|BYTES_BIG_ENDIAN
endif|#
directive|endif
condition|)
block|{
name|rtx
name|tem
decl_stmt|,
name|x
decl_stmt|;
name|int
name|by
init|=
operator|(
name|UNITS_PER_WORD
operator|-
name|size
operator|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|by
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|change_address
argument_list|(
name|mem
argument_list|,
name|word_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|move_block_from_reg
argument_list|(
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|mem
argument_list|,
name|size_stored
operator|/
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
else|else
name|move_block_from_reg
argument_list|(
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|mem
argument_list|,
name|size_stored
operator|/
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|stack_parm
operator|==
literal|0
condition|)
block|{
name|push_to_sequence
argument_list|(
name|all
operator|->
name|conversion_insns
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|stack_parm
argument_list|,
name|data
operator|->
name|entry_parm
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
name|all
operator|->
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
name|data
operator|->
name|stack_parm
operator|=
name|stack_parm
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|stack_parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  Allocate a pseudo to hold the current    parameter.  Get it there.  Perform all ABI specified conversions.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parm_setup_reg
parameter_list|(
name|struct
name|assign_parm_data_all
modifier|*
name|all
parameter_list|,
name|tree
name|parm
parameter_list|,
name|struct
name|assign_parm_data_one
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|parmreg
decl_stmt|;
name|enum
name|machine_mode
name|promoted_nominal_mode
decl_stmt|;
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|did_conversion
init|=
name|false
decl_stmt|;
comment|/* Store the parm in a pseudoregister during the function, but we may      need to do it in a wider mode.  */
comment|/* This is not really promoting for a call.  However we need to be      consistent with assign_parm_find_data_types and expand_expr_real_1.  */
name|promoted_nominal_mode
operator|=
name|promote_mode
argument_list|(
name|data
operator|->
name|nominal_type
argument_list|,
name|data
operator|->
name|nominal_mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|parmreg
operator|=
name|gen_reg_rtx
argument_list|(
name|promoted_nominal_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|parm
argument_list|)
condition|)
name|mark_user_reg
argument_list|(
name|parmreg
argument_list|)
expr_stmt|;
comment|/* If this was an item that we received a pointer to,      set DECL_RTL appropriately.  */
if|if
condition|(
name|data
operator|->
name|passed_pointer
condition|)
block|{
name|rtx
name|x
init|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|data
operator|->
name|passed_type
argument_list|)
argument_list|)
argument_list|,
name|parmreg
argument_list|)
decl_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|parmreg
argument_list|)
expr_stmt|;
comment|/* Copy the value into the register.  */
if|if
condition|(
name|data
operator|->
name|nominal_mode
operator|!=
name|data
operator|->
name|passed_mode
operator|||
name|promoted_nominal_mode
operator|!=
name|data
operator|->
name|promoted_mode
condition|)
block|{
name|int
name|save_tree_used
decl_stmt|;
comment|/* ENTRY_PARM has been converted to PROMOTED_MODE, its 	 mode, by the caller.  We now have to convert it to 	 NOMINAL_MODE, if different.  However, PARMREG may be in 	 a different mode than NOMINAL_MODE if it is being stored 	 promoted.  	 If ENTRY_PARM is a hard register, it might be in a register 	 not valid for operating in its mode (e.g., an odd-numbered 	 register for a DFmode).  In that case, moves are the only 	 thing valid, so we can't do a convert from there.  This 	 occurs when the calling sequence allow such misaligned 	 usages.  	 In addition, the conversion may involve a call, which could 	 clobber parameters which haven't been copied to pseudo 	 registers yet.  Therefore, we must first copy the parm to 	 a pseudo reg here, and save the conversion until after all 	 parameters have been moved.  */
name|rtx
name|tempreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tempreg
argument_list|,
name|validize_mem
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|all
operator|->
name|conversion_insns
argument_list|)
expr_stmt|;
name|tempreg
operator|=
name|convert_to_mode
argument_list|(
name|data
operator|->
name|nominal_mode
argument_list|,
name|tempreg
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tempreg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|tempreg
argument_list|)
operator|==
name|data
operator|->
name|nominal_mode
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|tempreg
argument_list|)
argument_list|)
operator|&&
name|data
operator|->
name|nominal_mode
operator|==
name|data
operator|->
name|passed_mode
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|tempreg
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tempreg
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The argument is already sign/zero extended, so note it 	     into the subreg.  */
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|tempreg
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_SET
argument_list|(
name|tempreg
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
comment|/* TREE_USED gets set erroneously during expand_assignment.  */
name|save_tree_used
operator|=
name|TREE_USED
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|parm
argument_list|,
name|make_tree
argument_list|(
name|data
operator|->
name|nominal_type
argument_list|,
name|tempreg
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|parm
argument_list|)
operator|=
name|save_tree_used
expr_stmt|;
name|all
operator|->
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|did_conversion
operator|=
name|true
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|validize_mem
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we were passed a pointer but the actual value can safely live      in a register, put it in one.  */
if|if
condition|(
name|data
operator|->
name|passed_pointer
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|BLKmode
comment|/* If by-reference argument was promoted, demote it.  */
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|||
name|use_register_for_decl
argument_list|(
name|parm
argument_list|)
operator|)
condition|)
block|{
comment|/* We can't use nominal_mode, because it will have been set to 	 Pmode above.  We must use the actual mode of the parm.  */
name|parmreg
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mark_user_reg
argument_list|(
name|parmreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|parmreg
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tempreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsigned_p
init|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|push_to_sequence
argument_list|(
name|all
operator|->
name|conversion_insns
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tempreg
argument_list|,
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|tempreg
operator|=
name|convert_to_mode
argument_list|(
name|GET_MODE
argument_list|(
name|parmreg
argument_list|)
argument_list|,
name|tempreg
argument_list|,
name|unsigned_p
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|all
operator|->
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|did_conversion
operator|=
name|true
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|parmreg
argument_list|)
expr_stmt|;
comment|/* STACK_PARM is the pointer, not the parm, and PARMREG is 	 now the parm.  */
name|data
operator|->
name|stack_parm
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Mark the register as eliminable if we did no conversion and it was      copied from memory at a fixed offset, and the arg pointer was not      copied to a pseudo-reg.  If the arg pointer is a pseudo reg or the      offset formed an invalid address, such memory-equivalences as we      make here would screw up life analysis for it.  */
if|if
condition|(
name|data
operator|->
name|nominal_mode
operator|==
name|data
operator|->
name|passed_mode
operator|&&
operator|!
name|did_conversion
operator|&&
name|data
operator|->
name|stack_parm
operator|!=
literal|0
operator|&&
name|MEM_P
argument_list|(
name|data
operator|->
name|stack_parm
argument_list|)
operator|&&
name|data
operator|->
name|locate
operator|.
name|offset
operator|.
name|var
operator|==
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|XEXP
argument_list|(
name|data
operator|->
name|stack_parm
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|linsn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|sinsn
decl_stmt|,
name|set
decl_stmt|;
comment|/* Mark complex types separately.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|parmreg
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|enum
name|machine_mode
name|submode
init|=
name|GET_MODE_INNER
argument_list|(
name|GET_MODE
argument_list|(
name|parmreg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|regnor
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|parmreg
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|regnoi
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|parmreg
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|stackr
init|=
name|adjust_address_nv
argument_list|(
name|data
operator|->
name|stack_parm
argument_list|,
name|submode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|stacki
init|=
name|adjust_address_nv
argument_list|(
name|data
operator|->
name|stack_parm
argument_list|,
name|submode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|submode
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Scan backwards for the set of the real and 	     imaginary parts.  */
for|for
control|(
name|sinsn
operator|=
name|linsn
init|;
name|sinsn
operator|!=
literal|0
condition|;
name|sinsn
operator|=
name|prev_nonnote_insn
argument_list|(
name|sinsn
argument_list|)
control|)
block|{
name|set
operator|=
name|single_set
argument_list|(
name|sinsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|regno_reg_rtx
index|[
name|regnoi
index|]
condition|)
name|REG_NOTES
argument_list|(
name|sinsn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|stacki
argument_list|,
name|REG_NOTES
argument_list|(
name|sinsn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|regno_reg_rtx
index|[
name|regnor
index|]
condition|)
name|REG_NOTES
argument_list|(
name|sinsn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|stackr
argument_list|,
name|REG_NOTES
argument_list|(
name|sinsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|linsn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|parmreg
condition|)
name|REG_NOTES
argument_list|(
name|linsn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUIV
argument_list|,
name|data
operator|->
name|stack_parm
argument_list|,
name|REG_NOTES
argument_list|(
name|linsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For pointer data type, suggest pointer register.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|parmreg
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  Allocate stack space to hold the current    parameter.  Get it there.  Perform all ABI specified conversions.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parm_setup_stack
parameter_list|(
name|struct
name|assign_parm_data_all
modifier|*
name|all
parameter_list|,
name|tree
name|parm
parameter_list|,
name|struct
name|assign_parm_data_one
modifier|*
name|data
parameter_list|)
block|{
comment|/* Value must be stored in the stack slot STACK_PARM during function      execution.  */
name|bool
name|to_conversion
init|=
name|false
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|promoted_mode
operator|!=
name|data
operator|->
name|nominal_mode
condition|)
block|{
comment|/* Conversion is required.  */
name|rtx
name|tempreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tempreg
argument_list|,
name|validize_mem
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|all
operator|->
name|conversion_insns
argument_list|)
expr_stmt|;
name|to_conversion
operator|=
name|true
expr_stmt|;
name|data
operator|->
name|entry_parm
operator|=
name|convert_to_mode
argument_list|(
name|data
operator|->
name|nominal_mode
argument_list|,
name|tempreg
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|stack_parm
condition|)
comment|/* ??? This may need a big-endian conversion on sparc64.  */
name|data
operator|->
name|stack_parm
operator|=
name|adjust_address
argument_list|(
name|data
operator|->
name|stack_parm
argument_list|,
name|data
operator|->
name|nominal_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|entry_parm
operator|!=
name|data
operator|->
name|stack_parm
condition|)
block|{
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|stack_parm
operator|==
literal|0
condition|)
block|{
name|data
operator|->
name|stack_parm
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|data
operator|->
name|passed_type
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|data
operator|->
name|stack_parm
argument_list|,
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|validize_mem
argument_list|(
name|data
operator|->
name|stack_parm
argument_list|)
expr_stmt|;
name|src
operator|=
name|validize_mem
argument_list|(
name|data
operator|->
name|entry_parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* Use a block move to handle potentially misaligned entry_parm.  */
if|if
condition|(
operator|!
name|to_conversion
condition|)
name|push_to_sequence
argument_list|(
name|all
operator|->
name|conversion_insns
argument_list|)
expr_stmt|;
name|to_conversion
operator|=
name|true
expr_stmt|;
name|emit_block_move
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|int_size_in_bytes
argument_list|(
name|data
operator|->
name|passed_type
argument_list|)
argument_list|)
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|to_conversion
condition|)
block|{
name|all
operator|->
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|data
operator|->
name|stack_parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of assign_parms.  If the ABI splits complex arguments, then    undo the frobbing that we did in assign_parms_augmented_arg_list.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parms_unsplit_complex
parameter_list|(
name|struct
name|assign_parm_data_all
modifier|*
name|all
parameter_list|,
name|tree
name|fnargs
parameter_list|)
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|orig_fnargs
init|=
name|all
operator|->
name|orig_fnargs
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|orig_fnargs
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|real
decl_stmt|,
name|imag
decl_stmt|;
name|enum
name|machine_mode
name|inner
init|=
name|GET_MODE_INNER
argument_list|(
name|DECL_MODE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|real
operator|=
name|DECL_RTL
argument_list|(
name|fnargs
argument_list|)
expr_stmt|;
name|imag
operator|=
name|DECL_RTL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|fnargs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
operator|!=
name|GET_MODE
argument_list|(
name|real
argument_list|)
condition|)
block|{
name|real
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|inner
argument_list|,
name|real
argument_list|)
expr_stmt|;
name|imag
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|inner
argument_list|,
name|imag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|rtx
name|rmem
decl_stmt|,
name|imem
decl_stmt|;
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
comment|/* split_complex_arg put the real and imag parts in 		 pseudos.  Move them to memory.  */
name|tmp
operator|=
name|assign_stack_local
argument_list|(
name|DECL_MODE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|size
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|tmp
argument_list|,
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rmem
operator|=
name|adjust_address_nv
argument_list|(
name|tmp
argument_list|,
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imem
operator|=
name|adjust_address_nv
argument_list|(
name|tmp
argument_list|,
name|inner
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|all
operator|->
name|conversion_insns
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|rmem
argument_list|,
name|real
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|imem
argument_list|,
name|imag
argument_list|)
expr_stmt|;
name|all
operator|->
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|gen_rtx_CONCAT
argument_list|(
name|DECL_MODE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|real
argument_list|,
name|imag
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|real
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|fnargs
argument_list|)
expr_stmt|;
name|imag
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|fnargs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
operator|!=
name|GET_MODE
argument_list|(
name|real
argument_list|)
condition|)
block|{
name|real
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|inner
argument_list|,
name|real
argument_list|)
expr_stmt|;
name|imag
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|inner
argument_list|,
name|imag
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|gen_rtx_CONCAT
argument_list|(
name|DECL_MODE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|real
argument_list|,
name|imag
argument_list|)
expr_stmt|;
name|set_decl_incoming_rtl
argument_list|(
name|parm
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fnargs
operator|=
name|TREE_CHAIN
argument_list|(
name|fnargs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|DECL_RTL
argument_list|(
name|fnargs
argument_list|)
argument_list|)
expr_stmt|;
name|set_decl_incoming_rtl
argument_list|(
name|parm
argument_list|,
name|DECL_INCOMING_RTL
argument_list|(
name|fnargs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set MEM_EXPR to the original decl, i.e. to PARM, 	     instead of the copy of decl, i.e. FNARGS.  */
if|if
condition|(
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
name|set_mem_expr
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
name|fnargs
operator|=
name|TREE_CHAIN
argument_list|(
name|fnargs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assign RTL expressions to the function's parameters.  This may involve    copying them into registers and using those registers as the DECL_RTL.  */
end_comment

begin_function
specifier|static
name|void
name|assign_parms
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|struct
name|assign_parm_data_all
name|all
decl_stmt|;
name|tree
name|fnargs
decl_stmt|,
name|parm
decl_stmt|;
name|current_function_internal_arg_pointer
operator|=
name|targetm
operator|.
name|calls
operator|.
name|internal_arg_pointer
argument_list|()
expr_stmt|;
name|assign_parms_initialize_all
argument_list|(
operator|&
name|all
argument_list|)
expr_stmt|;
name|fnargs
operator|=
name|assign_parms_augmented_arg_list
argument_list|(
operator|&
name|all
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|fnargs
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|struct
name|assign_parm_data_one
name|data
decl_stmt|;
comment|/* Extract the type of PARM; adjust it according to ABI.  */
name|assign_parm_find_data_types
argument_list|(
operator|&
name|all
argument_list|,
name|parm
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* Early out for errors and void parameters.  */
if|if
condition|(
name|data
operator|.
name|passed_mode
operator|==
name|VOIDmode
condition|)
block|{
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|current_function_stdarg
operator|&&
operator|!
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
condition|)
name|assign_parms_setup_varargs
argument_list|(
operator|&
name|all
argument_list|,
operator|&
name|data
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Find out where the parameter arrives in this function.  */
name|assign_parm_find_entry_rtl
argument_list|(
operator|&
name|all
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* Find out where stack space for this parameter might be.  */
if|if
condition|(
name|assign_parm_is_stack_parm
argument_list|(
operator|&
name|all
argument_list|,
operator|&
name|data
argument_list|)
condition|)
block|{
name|assign_parm_find_stack_rtl
argument_list|(
name|parm
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|assign_parm_adjust_entry_rtl
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* Record permanently how this parm was passed.  */
name|set_decl_incoming_rtl
argument_list|(
name|parm
argument_list|,
name|data
operator|.
name|entry_parm
argument_list|)
expr_stmt|;
comment|/* Update info on where next arg arrives in registers.  */
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|all
operator|.
name|args_so_far
argument_list|,
name|data
operator|.
name|promoted_mode
argument_list|,
name|data
operator|.
name|passed_type
argument_list|,
name|data
operator|.
name|named_arg
argument_list|)
expr_stmt|;
name|assign_parm_adjust_stack_rtl
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|assign_parm_setup_block_p
argument_list|(
operator|&
name|data
argument_list|)
condition|)
name|assign_parm_setup_block
argument_list|(
operator|&
name|all
argument_list|,
name|parm
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|data
operator|.
name|passed_pointer
operator|||
name|use_register_for_decl
argument_list|(
name|parm
argument_list|)
condition|)
name|assign_parm_setup_reg
argument_list|(
operator|&
name|all
argument_list|,
name|parm
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
else|else
name|assign_parm_setup_stack
argument_list|(
operator|&
name|all
argument_list|,
name|parm
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
operator|&&
name|fnargs
operator|!=
name|all
operator|.
name|orig_fnargs
condition|)
name|assign_parms_unsplit_complex
argument_list|(
operator|&
name|all
argument_list|,
name|fnargs
argument_list|)
expr_stmt|;
comment|/* Output all parameter conversion instructions (possibly including calls)      now that all parameters have been copied out of hard registers.  */
name|emit_insn
argument_list|(
name|all
operator|.
name|conversion_insns
argument_list|)
expr_stmt|;
comment|/* If we are receiving a struct value address as the first argument, set up      the RTL for the function result. As this might require code to convert      the transmitted address to Pmode, we do this here to ensure that possible      preliminary conversions of the address have been emitted already.  */
if|if
condition|(
name|all
operator|.
name|function_result_decl
condition|)
block|{
name|tree
name|result
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|DECL_RTL
argument_list|(
name|all
operator|.
name|function_result_decl
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|DECL_BY_REFERENCE
argument_list|(
name|result
argument_list|)
condition|)
name|x
operator|=
name|addr
expr_stmt|;
else|else
block|{
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|result
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SET_DECL_RTL
argument_list|(
name|result
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* We have aligned all the args, so add space for the pretend args.  */
name|current_function_pretend_args_size
operator|=
name|all
operator|.
name|pretend_args_size
expr_stmt|;
name|all
operator|.
name|stack_args_size
operator|.
name|constant
operator|+=
name|all
operator|.
name|extra_pretend_bytes
expr_stmt|;
name|current_function_args_size
operator|=
name|all
operator|.
name|stack_args_size
operator|.
name|constant
expr_stmt|;
comment|/* Adjust function incoming argument size for alignment and      minimum length.  */
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
name|current_function_args_size
operator|=
name|MAX
argument_list|(
name|current_function_args_size
argument_list|,
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|current_function_args_size
operator|=
name|CEIL_ROUND
argument_list|(
name|current_function_args_size
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|current_function_arg_offset_rtx
operator|=
operator|(
name|all
operator|.
name|stack_args_size
operator|.
name|var
operator|==
literal|0
condition|?
name|GEN_INT
argument_list|(
operator|-
name|all
operator|.
name|stack_args_size
operator|.
name|constant
argument_list|)
else|:
name|expand_expr
argument_list|(
name|size_diffop
argument_list|(
name|all
operator|.
name|stack_args_size
operator|.
name|var
argument_list|,
name|size_int
argument_list|(
operator|-
name|all
operator|.
name|stack_args_size
operator|.
name|constant
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|current_function_arg_offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|all
operator|.
name|stack_args_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See how many bytes, if any, of its args a function should try to pop      on return.  */
name|current_function_pops_args
operator|=
name|RETURN_POPS_ARGS
argument_list|(
name|fndecl
argument_list|,
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|current_function_args_size
argument_list|)
expr_stmt|;
comment|/* For stdarg.h function, save info about      regs and stack space used by the named args.  */
name|current_function_args_info
operator|=
name|all
operator|.
name|args_so_far
expr_stmt|;
comment|/* Set the rtx used for the function return value.  Put this in its      own variable so any optimizers that need this information don't have      to include tree.h.  Do this here so it gets done when an inlined      function gets output.  */
name|current_function_return_rtx
operator|=
operator|(
name|DECL_RTL_SET_P
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|?
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
else|:
name|NULL_RTX
operator|)
expr_stmt|;
comment|/* If scalar return value was computed in a pseudo-reg, or was a named      return value that got dumped to the stack, copy that to the hard      return register.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|decl_result
init|=
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|rtx
name|decl_rtl
init|=
name|DECL_RTL
argument_list|(
name|decl_result
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|decl_rtl
argument_list|)
condition|?
name|REGNO
argument_list|(
name|decl_rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
else|:
name|DECL_REGISTER
argument_list|(
name|decl_result
argument_list|)
condition|)
block|{
name|rtx
name|real_decl_rtl
decl_stmt|;
name|real_decl_rtl
operator|=
name|targetm
operator|.
name|calls
operator|.
name|function_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|,
name|fndecl
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|REG_FUNCTION_VALUE_P
argument_list|(
name|real_decl_rtl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The delay slot scheduler assumes that current_function_return_rtx 	     holds the hard register containing the return value, not a 	     temporary pseudo.  */
name|current_function_return_rtx
operator|=
name|real_decl_rtl
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_parameters, invoked via walk_tree.    For all seen types, gimplify their sizes.  */
end_comment

begin_function
specifier|static
name|tree
name|gimplify_parm_type
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_SIZES_GIMPLIFIED
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|gimplify_type_sizes
argument_list|(
name|t
argument_list|,
operator|(
name|tree
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Gimplify the parameter list for current_function_decl.  This involves    evaluating SAVE_EXPRs of variable sized parameters and generating code    to implement callee-copies reference parameters.  Returns a list of    statements to add to the beginning of the function, or NULL if nothing    to do.  */
end_comment

begin_function
name|tree
name|gimplify_parameters
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|assign_parm_data_all
name|all
decl_stmt|;
name|tree
name|fnargs
decl_stmt|,
name|parm
decl_stmt|,
name|stmts
init|=
name|NULL
decl_stmt|;
name|assign_parms_initialize_all
argument_list|(
operator|&
name|all
argument_list|)
expr_stmt|;
name|fnargs
operator|=
name|assign_parms_augmented_arg_list
argument_list|(
operator|&
name|all
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|fnargs
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|struct
name|assign_parm_data_one
name|data
decl_stmt|;
comment|/* Extract the type of PARM; adjust it according to ABI.  */
name|assign_parm_find_data_types
argument_list|(
operator|&
name|all
argument_list|,
name|parm
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* Early out for errors and void parameters.  */
if|if
condition|(
name|data
operator|.
name|passed_mode
operator|==
name|VOIDmode
operator|||
name|DECL_SIZE
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Update info on where next arg arrives in registers.  */
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|all
operator|.
name|args_so_far
argument_list|,
name|data
operator|.
name|promoted_mode
argument_list|,
name|data
operator|.
name|passed_type
argument_list|,
name|data
operator|.
name|named_arg
argument_list|)
expr_stmt|;
comment|/* ??? Once upon a time variable_size stuffed parameter list 	 SAVE_EXPRs (amongst others) onto a pending sizes list.  This 	 turned out to be less than manageable in the gimple world. 	 Now we have to hunt them down ourselves.  */
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|data
operator|.
name|passed_type
argument_list|,
name|gimplify_parm_type
argument_list|,
operator|&
name|stmts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|gimplify_one_sizepos
argument_list|(
operator|&
name|DECL_SIZE
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|&
name|stmts
argument_list|)
expr_stmt|;
name|gimplify_one_sizepos
argument_list|(
operator|&
name|DECL_SIZE_UNIT
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|&
name|stmts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|.
name|passed_pointer
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|data
operator|.
name|passed_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|reference_callee_copied
argument_list|(
operator|&
name|all
operator|.
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|data
operator|.
name|named_arg
argument_list|)
condition|)
block|{
name|tree
name|local
decl_stmt|,
name|t
decl_stmt|;
comment|/* For constant sized objects, this is trivial; for 		 variable-sized objects, we have to play games.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|local
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
name|get_name
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|local
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tree
name|ptr_type
decl_stmt|,
name|addr
decl_stmt|,
name|args
decl_stmt|;
name|ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|addr
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type
argument_list|,
name|get_name
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|addr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|local
operator|=
name|build_fold_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|parm
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_ALLOCA
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|ptr_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|addr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|stmts
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|local
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
operator|&
name|stmts
argument_list|)
expr_stmt|;
name|SET_DECL_VALUE_EXPR
argument_list|(
name|parm
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|stmts
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Indicate whether REGNO is an incoming argument to the current function    that was promoted to a wider mode.  If so, return the RTX for the    register (to get its mode).  PMODE and PUNSIGNEDP are set to the mode    that REGNO is promoted from and whether the promotion was signed or    unsigned.  */
end_comment

begin_function
name|rtx
name|promoted_input_arg
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|pmode
parameter_list|,
name|int
modifier|*
name|punsignedp
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
if|if
condition|(
name|REG_P
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|regno
operator|&&
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|mode
operator|=
name|promote_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
name|mode
operator|!=
name|DECL_MODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
operator|*
name|pmode
operator|=
name|DECL_MODE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|unsignedp
expr_stmt|;
return|return
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the size and offset from the start of the stacked arguments for a    parm passed in mode PASSED_MODE and with type TYPE.     INITIAL_OFFSET_PTR points to the current offset into the stacked    arguments.     The starting offset and size for this parm are returned in    LOCATE->OFFSET and LOCATE->SIZE, respectively.  When IN_REGS is    nonzero, the offset is that of stack slot, which is returned in    LOCATE->SLOT_OFFSET.  LOCATE->ALIGNMENT_PAD is the amount of    padding required from the initial offset ptr to the stack slot.     IN_REGS is nonzero if the argument will be passed in registers.  It will    never be set if REG_PARM_STACK_SPACE is not defined.     FNDECL is the function in which the argument was defined.     There are two types of rounding that are done.  The first, controlled by    FUNCTION_ARG_BOUNDARY, forces the offset from the start of the argument    list to be aligned to the specific boundary (in bits).  This rounding    affects the initial and starting offsets, but not the argument size.     The second, controlled by FUNCTION_ARG_PADDING and PARM_BOUNDARY,    optionally rounds the size of the parm to PARM_BOUNDARY.  The    initial offset is not affected by this rounding, while the size always    is and the starting offset may be.  */
end_comment

begin_comment
comment|/*  LOCATE->OFFSET will be negative for ARGS_GROW_DOWNWARD case;     INITIAL_OFFSET_PTR is positive because locate_and_pad_parm's     callers pass in the total size of args so far as     INITIAL_OFFSET_PTR.  LOCATE->SIZE is always positive.  */
end_comment

begin_function
name|void
name|locate_and_pad_parm
parameter_list|(
name|enum
name|machine_mode
name|passed_mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|in_regs
parameter_list|,
name|int
name|partial
parameter_list|,
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|args_size
modifier|*
name|initial_offset_ptr
parameter_list|,
name|struct
name|locate_and_pad_arg_data
modifier|*
name|locate
parameter_list|)
block|{
name|tree
name|sizetree
decl_stmt|;
name|enum
name|direction
name|where_pad
decl_stmt|;
name|unsigned
name|int
name|boundary
decl_stmt|;
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
name|int
name|part_size_in_regs
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* If we have found a stack parm before we reach the end of the      area reserved for registers, skip that area.  */
if|if
condition|(
operator|!
name|in_regs
condition|)
block|{
if|if
condition|(
name|reg_parm_stack_space
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
block|{
name|initial_offset_ptr
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|ARGS_SIZE_TREE
argument_list|(
operator|*
name|initial_offset_ptr
argument_list|)
argument_list|,
name|ssize_int
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
name|initial_offset_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|initial_offset_ptr
operator|->
name|constant
operator|<
name|reg_parm_stack_space
condition|)
name|initial_offset_ptr
operator|->
name|constant
operator|=
name|reg_parm_stack_space
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* REG_PARM_STACK_SPACE */
name|part_size_in_regs
operator|=
operator|(
name|reg_parm_stack_space
operator|==
literal|0
condition|?
name|partial
else|:
literal|0
operator|)
expr_stmt|;
name|sizetree
operator|=
name|type
condition|?
name|size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|size_int
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|passed_mode
argument_list|)
argument_list|)
expr_stmt|;
name|where_pad
operator|=
name|FUNCTION_ARG_PADDING
argument_list|(
name|passed_mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|boundary
operator|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|passed_mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|locate
operator|->
name|where_pad
operator|=
name|where_pad
expr_stmt|;
name|locate
operator|->
name|boundary
operator|=
name|boundary
expr_stmt|;
comment|/* Remember if the outgoing parameter requires extra alignment on the      calling function side.  */
if|if
condition|(
name|boundary
operator|>
name|PREFERRED_STACK_BOUNDARY
condition|)
name|boundary
operator|=
name|PREFERRED_STACK_BOUNDARY
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|stack_alignment_needed
operator|<
name|boundary
condition|)
name|cfun
operator|->
name|stack_alignment_needed
operator|=
name|boundary
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|locate
operator|->
name|slot_offset
operator|.
name|constant
operator|=
operator|-
name|initial_offset_ptr
operator|->
name|constant
expr_stmt|;
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
name|locate
operator|->
name|slot_offset
operator|.
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|0
argument_list|)
argument_list|,
name|initial_offset_ptr
operator|->
name|var
argument_list|)
expr_stmt|;
block|{
name|tree
name|s2
init|=
name|sizetree
decl_stmt|;
if|if
condition|(
name|where_pad
operator|!=
name|none
operator|&&
operator|(
operator|!
name|host_integerp
argument_list|(
name|sizetree
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|tree_low_cst
argument_list|(
name|sizetree
argument_list|,
literal|1
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
operator|)
condition|)
name|s2
operator|=
name|round_up
argument_list|(
name|s2
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|SUB_PARM_SIZE
argument_list|(
name|locate
operator|->
name|slot_offset
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
name|locate
operator|->
name|slot_offset
operator|.
name|constant
operator|+=
name|part_size_in_regs
expr_stmt|;
if|if
condition|(
operator|!
name|in_regs
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
operator|||
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
operator|>
literal|0
endif|#
directive|endif
condition|)
name|pad_to_arg_alignment
argument_list|(
operator|&
name|locate
operator|->
name|slot_offset
argument_list|,
name|boundary
argument_list|,
operator|&
name|locate
operator|->
name|alignment_pad
argument_list|)
expr_stmt|;
name|locate
operator|->
name|size
operator|.
name|constant
operator|=
operator|(
operator|-
name|initial_offset_ptr
operator|->
name|constant
operator|-
name|locate
operator|->
name|slot_offset
operator|.
name|constant
operator|)
expr_stmt|;
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
name|locate
operator|->
name|size
operator|.
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ssize_int
argument_list|(
literal|0
argument_list|)
argument_list|,
name|initial_offset_ptr
operator|->
name|var
argument_list|)
argument_list|,
name|locate
operator|->
name|slot_offset
operator|.
name|var
argument_list|)
expr_stmt|;
comment|/* Pad_below needs the pre-rounded size to know how much to pad      below.  */
name|locate
operator|->
name|offset
operator|=
name|locate
operator|->
name|slot_offset
expr_stmt|;
if|if
condition|(
name|where_pad
operator|==
name|downward
condition|)
name|pad_below
argument_list|(
operator|&
name|locate
operator|->
name|offset
argument_list|,
name|passed_mode
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !ARGS_GROW_DOWNWARD */
if|if
condition|(
operator|!
name|in_regs
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
operator|||
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
operator|>
literal|0
endif|#
directive|endif
condition|)
name|pad_to_arg_alignment
argument_list|(
name|initial_offset_ptr
argument_list|,
name|boundary
argument_list|,
operator|&
name|locate
operator|->
name|alignment_pad
argument_list|)
expr_stmt|;
name|locate
operator|->
name|slot_offset
operator|=
operator|*
name|initial_offset_ptr
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|passed_mode
operator|!=
name|BLKmode
condition|)
name|sizetree
operator|=
name|size_int
argument_list|(
name|PUSH_ROUNDING
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Pad_below needs the pre-rounded size to know how much to pad below      so this must be done before rounding up.  */
name|locate
operator|->
name|offset
operator|=
name|locate
operator|->
name|slot_offset
expr_stmt|;
if|if
condition|(
name|where_pad
operator|==
name|downward
condition|)
name|pad_below
argument_list|(
operator|&
name|locate
operator|->
name|offset
argument_list|,
name|passed_mode
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
if|if
condition|(
name|where_pad
operator|!=
name|none
operator|&&
operator|(
operator|!
name|host_integerp
argument_list|(
name|sizetree
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|tree_low_cst
argument_list|(
name|sizetree
argument_list|,
literal|1
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
operator|)
condition|)
name|sizetree
operator|=
name|round_up
argument_list|(
name|sizetree
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ADD_PARM_SIZE
argument_list|(
name|locate
operator|->
name|size
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
name|locate
operator|->
name|size
operator|.
name|constant
operator|-=
name|part_size_in_regs
expr_stmt|;
endif|#
directive|endif
comment|/* ARGS_GROW_DOWNWARD */
block|}
end_function

begin_comment
comment|/* Round the stack offset in *OFFSET_PTR up to a multiple of BOUNDARY.    BOUNDARY is measured in bits, but must be a multiple of a storage unit.  */
end_comment

begin_function
specifier|static
name|void
name|pad_to_arg_alignment
parameter_list|(
name|struct
name|args_size
modifier|*
name|offset_ptr
parameter_list|,
name|int
name|boundary
parameter_list|,
name|struct
name|args_size
modifier|*
name|alignment_pad
parameter_list|)
block|{
name|tree
name|save_var
init|=
name|NULL_TREE
decl_stmt|;
name|HOST_WIDE_INT
name|save_constant
init|=
literal|0
decl_stmt|;
name|int
name|boundary_in_bytes
init|=
name|boundary
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|sp_offset
init|=
name|STACK_POINTER_OFFSET
decl_stmt|;
ifdef|#
directive|ifdef
name|SPARC_STACK_BOUNDARY_HACK
comment|/* ??? The SPARC port may claim a STACK_BOUNDARY higher than      the real alignment of %sp.  However, when it does this, the      alignment of %sp+STACK_POINTER_OFFSET is STACK_BOUNDARY.  */
if|if
condition|(
name|SPARC_STACK_BOUNDARY_HACK
condition|)
name|sp_offset
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|boundary
operator|>
name|PARM_BOUNDARY
operator|&&
name|boundary
operator|>
name|STACK_BOUNDARY
condition|)
block|{
name|save_var
operator|=
name|offset_ptr
operator|->
name|var
expr_stmt|;
name|save_constant
operator|=
name|offset_ptr
operator|->
name|constant
expr_stmt|;
block|}
name|alignment_pad
operator|->
name|var
operator|=
name|NULL_TREE
expr_stmt|;
name|alignment_pad
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|boundary
operator|>
name|BITS_PER_UNIT
condition|)
block|{
if|if
condition|(
name|offset_ptr
operator|->
name|var
condition|)
block|{
name|tree
name|sp_offset_tree
init|=
name|ssize_int
argument_list|(
name|sp_offset
argument_list|)
decl_stmt|;
name|tree
name|offset
init|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ARGS_SIZE_TREE
argument_list|(
operator|*
name|offset_ptr
argument_list|)
argument_list|,
name|sp_offset_tree
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|tree
name|rounded
init|=
name|round_down
argument_list|(
name|offset
argument_list|,
name|boundary
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
else|#
directive|else
name|tree
name|rounded
init|=
name|round_up
argument_list|(
name|offset
argument_list|,
name|boundary
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|offset_ptr
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|rounded
argument_list|,
name|sp_offset_tree
argument_list|)
expr_stmt|;
comment|/* ARGS_SIZE_TREE includes constant term.  */
name|offset_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|boundary
operator|>
name|PARM_BOUNDARY
operator|&&
name|boundary
operator|>
name|STACK_BOUNDARY
condition|)
name|alignment_pad
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset_ptr
operator|->
name|var
argument_list|,
name|save_var
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset_ptr
operator|->
name|constant
operator|=
operator|-
name|sp_offset
operator|+
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|FLOOR_ROUND
argument_list|(
name|offset_ptr
operator|->
name|constant
operator|+
name|sp_offset
argument_list|,
name|boundary_in_bytes
argument_list|)
expr_stmt|;
else|#
directive|else
name|CEIL_ROUND
argument_list|(
name|offset_ptr
operator|->
name|constant
operator|+
name|sp_offset
argument_list|,
name|boundary_in_bytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|boundary
operator|>
name|PARM_BOUNDARY
operator|&&
name|boundary
operator|>
name|STACK_BOUNDARY
condition|)
name|alignment_pad
operator|->
name|constant
operator|=
name|offset_ptr
operator|->
name|constant
operator|-
name|save_constant
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pad_below
parameter_list|(
name|struct
name|args_size
modifier|*
name|offset_ptr
parameter_list|,
name|enum
name|machine_mode
name|passed_mode
parameter_list|,
name|tree
name|sizetree
parameter_list|)
block|{
if|if
condition|(
name|passed_mode
operator|!=
name|BLKmode
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|passed_mode
argument_list|)
operator|%
name|PARM_BOUNDARY
condition|)
name|offset_ptr
operator|->
name|constant
operator|+=
operator|(
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|passed_mode
argument_list|)
operator|+
name|PARM_BOUNDARY
operator|-
literal|1
operator|)
operator|/
name|PARM_BOUNDARY
operator|*
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|passed_mode
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sizetree
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
condition|)
block|{
comment|/* Round the size up to multiple of PARM_BOUNDARY bits.  */
name|tree
name|s2
init|=
name|round_up
argument_list|(
name|sizetree
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
comment|/* Add it in.  */
name|ADD_PARM_SIZE
argument_list|(
operator|*
name|offset_ptr
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|SUB_PARM_SIZE
argument_list|(
operator|*
name|offset_ptr
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk the tree of blocks describing the binding levels within a function    and warn about variables the might be killed by setjmp or vfork.    This is done after calling flow_analysis and before global_alloc    clobbers the pseudo-regs to hard regs.  */
end_comment

begin_function
name|void
name|setjmp_vars_warning
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|sub
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|regno_clobbered_at_setjmp
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"variable %q+D might be clobbered by %<longjmp%>"
literal|" or %<vfork%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sub
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|sub
condition|;
name|sub
operator|=
name|TREE_CHAIN
argument_list|(
name|sub
argument_list|)
control|)
name|setjmp_vars_warning
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do the appropriate part of setjmp_vars_warning    but for arguments instead of local variables.  */
end_comment

begin_function
name|void
name|setjmp_args_warning
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|regno_clobbered_at_setjmp
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"argument %q+D might be clobbered by %<longjmp%> or %<vfork%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Identify BLOCKs referenced by more than one NOTE_INSN_BLOCK_{BEG,END},    and create duplicate blocks.  */
end_comment

begin_comment
comment|/* ??? Need an option to either create block fragments or to create    abstract origin duplicates of a source block.  It really depends    on what optimization has been performed.  */
end_comment

begin_function
name|void
name|reorder_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|block
init|=
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|block_stack
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL_TREE
condition|)
return|return;
name|block_stack
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Reset the TREE_ASM_WRITTEN bit for all blocks.  */
name|clear_block_marks
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|/* Prune the old trees away, so that they don't get in the way.  */
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Recreate the block tree from the note nesting.  */
name|reorder_blocks_1
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|block
argument_list|,
operator|&
name|block_stack
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|blocks_nreverse
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|block_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for reorder_blocks.  Reset TREE_ASM_WRITTEN.  */
end_comment

begin_function
name|void
name|clear_block_marks
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
while|while
condition|(
name|block
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|clear_block_marks
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|reorder_blocks_1
argument_list|(
name|rtx
name|insns
argument_list|,
name|tree
name|current_block
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|p_block_stack
argument_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
block|{
name|tree
name|block
init|=
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|tree
name|origin
decl_stmt|;
name|origin
operator|=
operator|(
name|BLOCK_FRAGMENT_ORIGIN
argument_list|(
name|block
argument_list|)
condition|?
name|BLOCK_FRAGMENT_ORIGIN
argument_list|(
name|block
argument_list|)
else|:
name|block
operator|)
expr_stmt|;
comment|/* If we have seen this block before, that means it now 		 spans multiple address regions.  Create a new fragment.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|tree
name|new_block
init|=
name|copy_node
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|BLOCK_FRAGMENT_ORIGIN
argument_list|(
name|new_block
argument_list|)
operator|=
name|origin
expr_stmt|;
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|new_block
argument_list|)
operator|=
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|origin
argument_list|)
expr_stmt|;
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|origin
argument_list|)
operator|=
name|new_block
expr_stmt|;
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
operator|=
name|new_block
expr_stmt|;
name|block
operator|=
name|new_block
expr_stmt|;
block|}
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* When there's only one block for the entire function, 		 current_block == block and we mustn't do this, it 		 will cause infinite recursion.  */
if|if
condition|(
name|block
operator|!=
name|current_block
condition|)
block|{
if|if
condition|(
name|block
operator|!=
name|origin
condition|)
name|gcc_assert
argument_list|(
name|BLOCK_SUPERCONTEXT
argument_list|(
name|origin
argument_list|)
operator|==
name|current_block
argument_list|)
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|block
argument_list|)
operator|=
name|current_block
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
operator|=
name|block
expr_stmt|;
name|current_block
operator|=
name|origin
expr_stmt|;
block|}
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|p_block_stack
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
condition|)
block|{
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
operator|*
name|p_block_stack
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
operator|=
name|blocks_nreverse
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
argument_list|)
expr_stmt|;
name|current_block
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|current_block
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Reverse the order of elements in the chain T of blocks,    and return the new head of the chain (old last element).  */
end_comment

begin_function
name|tree
name|blocks_nreverse
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|decl
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|t
init|;
name|decl
condition|;
name|decl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|BLOCK_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|decl
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Count the subblocks of the list starting with BLOCK.  If VECTOR is    non-NULL, list them all into VECTOR, in a depth-first preorder    traversal of the block tree.  Also clear TREE_ASM_WRITTEN in all    blocks.  */
end_comment

begin_function
specifier|static
name|int
name|all_blocks
parameter_list|(
name|tree
name|block
parameter_list|,
name|tree
modifier|*
name|vector
parameter_list|)
block|{
name|int
name|n_blocks
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|block
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Record this block.  */
if|if
condition|(
name|vector
condition|)
name|vector
index|[
name|n_blocks
index|]
operator|=
name|block
expr_stmt|;
operator|++
name|n_blocks
expr_stmt|;
comment|/* Record the subblocks, and their subblocks...  */
name|n_blocks
operator|+=
name|all_blocks
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|vector
condition|?
name|vector
operator|+
name|n_blocks
else|:
literal|0
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
return|return
name|n_blocks
return|;
block|}
end_function

begin_comment
comment|/* Return a vector containing all the blocks rooted at BLOCK.  The    number of elements in the vector is stored in N_BLOCKS_P.  The    vector is dynamically allocated; it is the caller's responsibility    to call `free' on the pointer returned.  */
end_comment

begin_function
specifier|static
name|tree
modifier|*
name|get_block_vector
parameter_list|(
name|tree
name|block
parameter_list|,
name|int
modifier|*
name|n_blocks_p
parameter_list|)
block|{
name|tree
modifier|*
name|block_vector
decl_stmt|;
operator|*
name|n_blocks_p
operator|=
name|all_blocks
argument_list|(
name|block
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|block_vector
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
operator|*
name|n_blocks_p
argument_list|)
expr_stmt|;
name|all_blocks
argument_list|(
name|block
argument_list|,
name|block_vector
argument_list|)
expr_stmt|;
return|return
name|block_vector
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|next_block_index
operator|=
literal|2
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set BLOCK_NUMBER for all the blocks in FN.  */
end_comment

begin_function
name|void
name|number_blocks
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_blocks
decl_stmt|;
name|tree
modifier|*
name|block_vector
decl_stmt|;
comment|/* For SDB and XCOFF debugging output, we start numbering the blocks      from 1 within each function, rather than keeping a running      count.  */
if|#
directive|if
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|next_block_index
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|block_vector
operator|=
name|get_block_vector
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
argument_list|,
operator|&
name|n_blocks
argument_list|)
expr_stmt|;
comment|/* The top-level BLOCK isn't numbered at all.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_blocks
condition|;
operator|++
name|i
control|)
comment|/* We number the blocks from two.  */
name|BLOCK_NUMBER
argument_list|(
name|block_vector
index|[
name|i
index|]
argument_list|)
operator|=
name|next_block_index
operator|++
expr_stmt|;
name|free
argument_list|(
name|block_vector
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* If VAR is present in a subblock of BLOCK, return the subblock.  */
end_comment

begin_function
name|tree
name|debug_find_var_in_block_tree
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|block
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|t
operator|==
name|var
condition|)
return|return
name|block
return|;
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|ret
init|=
name|debug_find_var_in_block_tree
argument_list|(
name|var
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a function structure for FNDECL and set its contents    to the defaults.  */
end_comment

begin_function
name|void
name|allocate_struct_function
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|fntype
init|=
name|fndecl
condition|?
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
name|cfun
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|stack_alignment_needed
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|cfun
operator|->
name|preferred_stack_boundary
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|current_function_funcdef_no
operator|=
name|funcdef_no
operator|++
expr_stmt|;
name|cfun
operator|->
name|function_frequency
operator|=
name|FUNCTION_FREQUENCY_NORMAL
expr_stmt|;
name|init_eh_for_function
argument_list|()
expr_stmt|;
name|lang_hooks
operator|.
name|function
operator|.
name|init
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_machine_status
condition|)
name|cfun
operator|->
name|machine
operator|=
call|(
modifier|*
name|init_machine_status
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|NULL
condition|)
return|return;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fndecl
argument_list|)
operator|=
name|cfun
expr_stmt|;
name|cfun
operator|->
name|decl
operator|=
name|fndecl
expr_stmt|;
name|result
operator|=
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|result
argument_list|,
name|fndecl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
name|current_function_returns_pcc_struct
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|current_function_returns_struct
operator|=
literal|1
expr_stmt|;
block|}
name|current_function_returns_pointer
operator|=
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_stdarg
operator|=
operator|(
name|fntype
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
expr_stmt|;
comment|/* Assume all registers in stdarg functions need to be saved.  */
name|cfun
operator|->
name|va_list_gpr_size
operator|=
name|VA_LIST_MAX_GPR_SIZE
expr_stmt|;
name|cfun
operator|->
name|va_list_fpr_size
operator|=
name|VA_LIST_MAX_FPR_SIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset cfun, and other non-struct-function variables to defaults as    appropriate for emitting rtl at the start of a function.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_function_start
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
if|if
condition|(
name|fndecl
operator|&&
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fndecl
argument_list|)
condition|)
name|cfun
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|allocate_struct_function
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|init_emit
argument_list|()
expr_stmt|;
name|init_varasm_status
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|init_expr
argument_list|()
expr_stmt|;
name|cse_not_expected
operator|=
operator|!
name|optimize
expr_stmt|;
comment|/* Caller save not needed yet.  */
name|caller_save_needed
operator|=
literal|0
expr_stmt|;
comment|/* We haven't done register allocation yet.  */
name|reg_renumber
operator|=
literal|0
expr_stmt|;
comment|/* Indicate that we have not instantiated virtual registers yet.  */
name|virtuals_instantiated
operator|=
literal|0
expr_stmt|;
comment|/* Indicate that we want CONCATs now.  */
name|generating_concat_p
operator|=
literal|1
expr_stmt|;
comment|/* Indicate we have no need of a frame pointer yet.  */
name|frame_pointer_needed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the rtl expansion mechanism so that we can do simple things    like generate sequences.  This is used to provide a context during global    initialization of some passes.  */
end_comment

begin_function
name|void
name|init_dummy_function_start
parameter_list|(
name|void
parameter_list|)
block|{
name|prepare_function_start
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the start of the function SUBR (a FUNCTION_DECL tree node)    and initialize static variables for generating RTL for the statements    of the function.  */
end_comment

begin_function
name|void
name|init_function_start
parameter_list|(
name|tree
name|subr
parameter_list|)
block|{
name|prepare_function_start
argument_list|(
name|subr
argument_list|)
expr_stmt|;
comment|/* Prevent ever trying to delete the first instruction of a      function.  Also tell final how to output a linenum before the      function prologue.  Note linenums could be missing, e.g. when      compiling a Java .class file.  */
if|if
condition|(
operator|!
name|DECL_IS_BUILTIN
argument_list|(
name|subr
argument_list|)
condition|)
name|emit_line_note
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|subr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure first insn is a note even if we don't want linenums.      This makes sure the first insn will never be deleted.      Also, final expects a note to appear there.  */
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Warn if this value is an aggregate type,      regardless of which calling convention we are using for it.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Waggregate_return
argument_list|,
literal|"function returns an aggregate"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure all values used by the optimization passes have sane    defaults.  */
end_comment

begin_function
name|unsigned
name|int
name|init_function_for_compilation
parameter_list|(
name|void
parameter_list|)
block|{
name|reg_renumber
operator|=
literal|0
expr_stmt|;
comment|/* No prologue/epilogue insns yet.  Make sure that these vectors are      empty.  */
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|int
argument_list|,
name|prologue
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|int
argument_list|,
name|epilogue
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|int
argument_list|,
name|sibcall_epilogue
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_init_function
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|init_function_for_compilation
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|expand_main_function
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|INVOKE__main
argument_list|)
expr|\
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|INIT_SECTION_ASM_OP
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|INIT_ARRAY_SECTION_ASM_OP
argument_list|)
operator|)
operator|)
name|emit_library_call
argument_list|(
name|init_one_libfunc
argument_list|(
name|NAME__MAIN
argument_list|)
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand code to initialize the stack_protect_guard.  This is invoked at    the beginning of a function to be protected.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_stack_protect_set
end_ifndef

begin_define
define|#
directive|define
name|HAVE_stack_protect_set
value|0
end_define

begin_define
define|#
directive|define
name|gen_stack_protect_set
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(gcc_unreachable (), NULL_RTX)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|stack_protect_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|guard_decl
init|=
name|targetm
operator|.
name|stack_protect_guard
argument_list|()
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Avoid expand_expr here, because we don't want guard_decl pulled      into registers unless absolutely necessary.  And we know that      cfun->stack_protect_guard is a local stack slot, so this skips      all the fluff.  */
name|x
operator|=
name|validize_mem
argument_list|(
name|DECL_RTL
argument_list|(
name|cfun
operator|->
name|stack_protect_guard
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|validize_mem
argument_list|(
name|DECL_RTL
argument_list|(
name|guard_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allow the target to copy from Y to X without leaking Y into a      register.  */
if|if
condition|(
name|HAVE_stack_protect_set
condition|)
block|{
name|rtx
name|insn
init|=
name|gen_stack_protect_set
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Otherwise do a straight move.  */
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand code to verify the stack_protect_guard.  This is invoked at    the end of a function to be protected.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_stack_protect_test
end_ifndef

begin_define
define|#
directive|define
name|HAVE_stack_protect_test
value|0
end_define

begin_define
define|#
directive|define
name|gen_stack_protect_test
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(gcc_unreachable (), NULL_RTX)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|stack_protect_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|guard_decl
init|=
name|targetm
operator|.
name|stack_protect_guard
argument_list|()
decl_stmt|;
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* Avoid expand_expr here, because we don't want guard_decl pulled      into registers unless absolutely necessary.  And we know that      cfun->stack_protect_guard is a local stack slot, so this skips      all the fluff.  */
name|x
operator|=
name|validize_mem
argument_list|(
name|DECL_RTL
argument_list|(
name|cfun
operator|->
name|stack_protect_guard
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|validize_mem
argument_list|(
name|DECL_RTL
argument_list|(
name|guard_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allow the target to compare Y with X without leaking either into      a register.  */
switch|switch
condition|(
name|HAVE_stack_protect_test
operator|!=
literal|0
condition|)
block|{
case|case
literal|1
case|:
name|tmp
operator|=
name|gen_stack_protect_test
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
default|default:
name|emit_cmp_and_jump_insns
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* The noreturn predictor has been moved to the tree level.  The rtl-level      predictors estimate this branch about 20%, which isn't enough to get      things moved out of line.  Since this is the only extant case of adding      a noreturn function at the rtl level, it doesn't seem worth doing ought      except adding the prediction by hand.  */
name|tmp
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|predict_insn_def
argument_list|(
name|tmp
argument_list|,
name|PRED_NORETURN
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|targetm
operator|.
name|stack_protect_fail
argument_list|()
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start the RTL for a new function, and set variables used for    emitting RTL.    SUBR is the FUNCTION_DECL node.    PARMS_HAVE_CLEANUPS is nonzero if there are cleanups associated with    the function's parameters, which must be run at any return statement.  */
end_comment

begin_function
name|void
name|expand_function_start
parameter_list|(
name|tree
name|subr
parameter_list|)
block|{
comment|/* Make sure volatile mem refs aren't considered      valid operands of arithmetic insns.  */
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
name|current_function_profile
operator|=
operator|(
name|profile_flag
operator|&&
operator|!
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|subr
argument_list|)
operator|)
expr_stmt|;
name|current_function_limit_stack
operator|=
operator|(
name|stack_limit_rtx
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|DECL_NO_LIMIT_STACK
argument_list|(
name|subr
argument_list|)
operator|)
expr_stmt|;
comment|/* Make the label for return statements to jump to.  Do not special      case machines with special return instructions -- they will be      handled later during jump, ifcvt, or epilogue creation.  */
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Initialize rtx used to return the value.  */
comment|/* Do this before assign_parms so that we copy the struct value address      before any library calls that assign parms might generate.  */
comment|/* Decide whether to return the value in memory or in a register.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
name|subr
argument_list|)
condition|)
block|{
comment|/* Returning something that won't go in a register.  */
name|rtx
name|value_address
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
if|if
condition|(
name|current_function_returns_pcc_struct
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|value_address
operator|=
name|assemble_static_space
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|rtx
name|sv
init|=
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|TREE_TYPE
argument_list|(
name|subr
argument_list|)
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|/* Expect to be passed the address of a place to store the value. 	     If it is passed as an argument, assign_parms will take care of 	     it.  */
if|if
condition|(
name|sv
condition|)
block|{
name|value_address
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|value_address
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value_address
condition|)
block|{
name|rtx
name|x
init|=
name|value_address
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_BY_REFERENCE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
condition|)
block|{
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SET_DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
comment|/* If return mode is void, this decl rtl should not be used.  */
name|SET_DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Compute the return values into a pseudo reg, which we will copy 	 into the true return register after the cleanups are done.  */
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|return_type
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|return_in_msb
argument_list|(
name|return_type
argument_list|)
condition|)
comment|/* expand_function_end will insert the appropriate padding in 	   this case.  Use the return value's natural (unpadded) mode 	   within the function proper.  */
name|SET_DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|return_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* In order to figure out what mode to use for the pseudo, we 	     figure out what the mode of the eventual return register will 	     actually be, and use that.  */
name|rtx
name|hard_reg
init|=
name|hard_function_value
argument_list|(
name|return_type
argument_list|,
name|subr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Structures that are returned in registers are not 	     aggregate_value_p, so we may see a PARALLEL or a REG.  */
if|if
condition|(
name|REG_P
argument_list|(
name|hard_reg
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|hard_reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|hard_reg
argument_list|)
operator|==
name|PARALLEL
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|,
name|gen_group_rtx
argument_list|(
name|hard_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set DECL_REGISTER flag so that expand_function_end will copy the 	 result to the real return register(s).  */
name|DECL_REGISTER
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Initialize rtx for parameters and local variables.      In some cases this requires emitting insns.  */
name|assign_parms
argument_list|(
name|subr
argument_list|)
expr_stmt|;
comment|/* If function gets a static chain arg, store it.  */
if|if
condition|(
name|cfun
operator|->
name|static_chain_decl
condition|)
block|{
name|tree
name|parm
init|=
name|cfun
operator|->
name|static_chain_decl
decl_stmt|;
name|rtx
name|local
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|set_decl_incoming_rtl
argument_list|(
name|parm
argument_list|,
name|static_chain_incoming_rtx
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parm
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|mark_reg_pointer
argument_list|(
name|local
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|local
argument_list|,
name|static_chain_incoming_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* If the function receives a non-local goto, then store the      bits we need to restore the frame pointer.  */
if|if
condition|(
name|cfun
operator|->
name|nonlocal_goto_save_area
condition|)
block|{
name|tree
name|t_save
decl_stmt|;
name|rtx
name|r_save
decl_stmt|;
comment|/* ??? We need to do this save early.  Unfortunately here is 	 before the frame variable gets declared.  Help out...  */
name|expand_var
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cfun
operator|->
name|nonlocal_goto_save_area
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t_save
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|ptr_type_node
argument_list|,
name|cfun
operator|->
name|nonlocal_goto_save_area
argument_list|,
name|integer_zero_node
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|r_save
operator|=
name|expand_expr
argument_list|(
name|t_save
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_WRITE
argument_list|)
expr_stmt|;
name|r_save
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|r_save
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|r_save
argument_list|,
name|virtual_stack_vars_rtx
argument_list|)
expr_stmt|;
name|update_nonlocal_goto_save_area
argument_list|()
expr_stmt|;
block|}
comment|/* The following was moved from init_function_start.      The move is supposed to make sdb output more accurate.  */
comment|/* Indicate the beginning of the function body,      as opposed to parm setup.  */
name|emit_note
argument_list|(
name|NOTE_INSN_FUNCTION_BEG
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_P
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|parm_birth_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_function_profile
condition|)
block|{
ifdef|#
directive|ifdef
name|PROFILE_HOOK
name|PROFILE_HOOK
argument_list|(
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* After the display initializations is where the stack checking      probe should go.  */
if|if
condition|(
name|flag_stack_check
condition|)
name|stack_check_probe_note
operator|=
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Make sure there is a line number after the function entry setup code.  */
name|force_next_line_note
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Undo the effects of init_dummy_function_start.  */
end_comment

begin_function
name|void
name|expand_dummy_function_end
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* End any sequences that failed to be closed due to syntax errors.  */
while|while
condition|(
name|in_sequence_p
argument_list|()
condition|)
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Outside function body, can't compute type's actual size      until next function's body starts.  */
name|free_after_parsing
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|free_after_compilation
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|cfun
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call DOIT for each hard register used as a return value from    the current function.  */
end_comment

begin_function
name|void
name|diddle_return_value
parameter_list|(
name|void
function_decl|(
modifier|*
name|doit
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rtx
name|outgoing
init|=
name|current_function_return_rtx
decl_stmt|;
if|if
condition|(
operator|!
name|outgoing
condition|)
return|return;
if|if
condition|(
name|REG_P
argument_list|(
name|outgoing
argument_list|)
condition|)
call|(
modifier|*
name|doit
call|)
argument_list|(
name|outgoing
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|outgoing
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|outgoing
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|outgoing
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
call|(
modifier|*
name|doit
call|)
argument_list|(
name|x
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_clobber_return_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|void
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clobber_return_register
parameter_list|(
name|void
parameter_list|)
block|{
name|diddle_return_value
argument_list|(
name|do_clobber_return_reg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* In case we do use pseudo to return value, clobber it too.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|decl_result
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|rtx
name|decl_rtl
init|=
name|DECL_RTL
argument_list|(
name|decl_result
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|decl_rtl
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|decl_rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|do_clobber_return_reg
argument_list|(
name|decl_rtl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_use_return_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|void
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|use_return_register
parameter_list|(
name|void
parameter_list|)
block|{
name|diddle_return_value
argument_list|(
name|do_use_return_reg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Possibly warn about unused parameters.  */
end_comment

begin_function
name|void
name|do_warn_unused_parameter
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wunused_parameter
argument_list|,
literal|"unused parameter %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|initial_trampoline
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Generate RTL for the end of the current function.  */
end_comment

begin_function
name|void
name|expand_function_end
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|clobber_after
decl_stmt|;
comment|/* If arg_pointer_save_area was referenced only from a nested      function, we will not have initialized it yet.  Do that now.  */
if|if
condition|(
name|arg_pointer_save_area
operator|&&
operator|!
name|cfun
operator|->
name|arg_pointer_save_area_init
condition|)
name|get_arg_pointer_save_area
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
comment|/* If we are doing stack checking and this function makes calls,      do a stack probe at the start of the function to ensure we have enough      space for another stack frame.  */
if|if
condition|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|seq
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|probe_stack_range
argument_list|(
name|STACK_CHECK_PROTECT
argument_list|,
name|GEN_INT
argument_list|(
name|STACK_CHECK_MAX_FRAME_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|stack_check_probe_note
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Possibly warn about unused parameters.      When frontend does unit-at-a-time, the warning is already      issued at finalization time.  */
if|if
condition|(
name|warn_unused_parameter
operator|&&
operator|!
name|lang_hooks
operator|.
name|callgraph
operator|.
name|expand_function
condition|)
name|do_warn_unused_parameter
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* End any sequences that failed to be closed due to syntax errors.  */
while|while
condition|(
name|in_sequence_p
argument_list|()
condition|)
name|end_sequence
argument_list|()
expr_stmt|;
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Mark the end of the function body.      If control reaches this insn, the function can drop through      without returning a value.  */
name|emit_note
argument_list|(
name|NOTE_INSN_FUNCTION_END
argument_list|)
expr_stmt|;
comment|/* Must mark the last line number note in the function, so that the test      coverage code can avoid counting the last line twice.  This just tells      the code to ignore the immediately following line note, since there      already exists a copy of this note somewhere above.  This line number      note is still needed for debugging though, so we can't delete it.  */
if|if
condition|(
name|flag_test_coverage
condition|)
name|emit_note
argument_list|(
name|NOTE_INSN_REPEATED_LINE_NUMBER
argument_list|)
expr_stmt|;
comment|/* Output a linenumber for the end of the function.      SDB depends on this.  */
name|force_next_line_note
argument_list|()
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
comment|/* Before the return label (if any), clobber the return      registers so that they are not propagated live to the rest of      the function.  This can only happen with functions that drop      through; if there had been a return statement, there would      have either been a return rtx, or a jump to the return label.       We delay actual code generation after the current_function_value_rtx      is computed.  */
name|clobber_after
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Output the label for the actual return from the function.  */
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
block|{
comment|/* Let except.c know where it should emit the call to unregister 	 the function context for sjlj exceptions.  */
if|if
condition|(
name|flag_exceptions
condition|)
name|sjlj_emit_function_exit_after
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* @@@ This is a kludge.  We want to ensure that instructions that 	 may trap are not moved into the epilogue by scheduling, because 	 we don't always emit unwind information for the epilogue. 	 However, not all machine descriptions define a blockage insn, so 	 emit an ASM_INPUT to act as one.  */
if|if
condition|(
name|flag_non_call_exceptions
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is an implementation of throw, do what's necessary to      communicate between __builtin_eh_return and the epilogue.  */
name|expand_eh_return
argument_list|()
expr_stmt|;
comment|/* If scalar return value was computed in a pseudo-reg, or was a named      return value that got dumped to the stack, copy that to the hard      return register.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|decl_result
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|rtx
name|decl_rtl
init|=
name|DECL_RTL
argument_list|(
name|decl_result
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|decl_rtl
argument_list|)
condition|?
name|REGNO
argument_list|(
name|decl_rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
else|:
name|DECL_REGISTER
argument_list|(
name|decl_result
argument_list|)
condition|)
block|{
name|rtx
name|real_decl_rtl
init|=
name|current_function_return_rtx
decl_stmt|;
comment|/* This should be set in assign_parms.  */
name|gcc_assert
argument_list|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|real_decl_rtl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a BLKmode structure being returned in registers, 	     then use the mode computed in expand_return.  Note that if 	     decl_rtl is memory, then its mode may have been changed, 	     but that current_function_return_rtx has not.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|real_decl_rtl
argument_list|)
operator|==
name|BLKmode
condition|)
name|PUT_MODE
argument_list|(
name|real_decl_rtl
argument_list|,
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a non-BLKmode return value should be padded at the least 	     significant end of the register, shift it left by the appropriate 	     amount.  BLKmode results are handled using the group load/store 	     machinery.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|return_in_msb
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|real_decl_rtl
argument_list|)
argument_list|)
argument_list|,
name|decl_rtl
argument_list|)
expr_stmt|;
name|shift_return_value
argument_list|(
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
argument_list|,
name|true
argument_list|,
name|real_decl_rtl
argument_list|)
expr_stmt|;
block|}
comment|/* If a named return value dumped decl_return to memory, then 	     we may need to re-do the PROMOTE_MODE signed/unsigned 	     extension.  */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|real_decl_rtl
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
condition|)
block|{
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|promote_function_return
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|promote_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|real_decl_rtl
argument_list|,
name|decl_rtl
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_decl_rtl
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* If expand_function_start has created a PARALLEL for decl_rtl, 		 move the result to the real return registers.  Otherwise, do 		 a group load from decl_rtl for a named return.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|decl_rtl
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_move
argument_list|(
name|real_decl_rtl
argument_list|,
name|decl_rtl
argument_list|)
expr_stmt|;
else|else
name|emit_group_load
argument_list|(
name|real_decl_rtl
argument_list|,
name|decl_rtl
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* In the case of complex integer modes smaller than a word, we'll 	     need to generate some non-trivial bitfield insertions.  Do that 	     on a pseudo and not the hard register.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|decl_rtl
argument_list|)
operator|==
name|CONCAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_WORD
condition|)
block|{
name|int
name|old_generating_concat_p
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|old_generating_concat_p
operator|=
name|generating_concat_p
expr_stmt|;
name|generating_concat_p
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
argument_list|)
expr_stmt|;
name|generating_concat_p
operator|=
name|old_generating_concat_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|decl_rtl
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|real_decl_rtl
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|real_decl_rtl
argument_list|,
name|decl_rtl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If returning a structure, arrange to return the address of the value      in a place where debuggers expect to find it.       If returning a structure PCC style,      the caller also depends on this value.      And current_function_returns_pcc_struct is not necessarily set.  */
if|if
condition|(
name|current_function_returns_struct
operator|||
name|current_function_returns_pcc_struct
condition|)
block|{
name|rtx
name|value_address
init|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|outgoing
decl_stmt|;
if|if
condition|(
name|DECL_BY_REFERENCE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|value_address
operator|=
name|XEXP
argument_list|(
name|value_address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outgoing
operator|=
name|targetm
operator|.
name|calls
operator|.
name|function_value
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_function_decl
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Mark this as a function return value so integrate will delete the 	 assignment and USE below when inlining this function.  */
name|REG_FUNCTION_VALUE_P
argument_list|(
name|outgoing
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The address may be ptr_mode and OUTGOING may be Pmode.  */
name|value_address
operator|=
name|convert_memory_address
argument_list|(
name|GET_MODE
argument_list|(
name|outgoing
argument_list|)
argument_list|,
name|value_address
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|outgoing
argument_list|,
name|value_address
argument_list|)
expr_stmt|;
comment|/* Show return register used to hold result (in this case the address 	 of the result.  */
name|current_function_return_rtx
operator|=
name|outgoing
expr_stmt|;
block|}
comment|/* Emit the actual code to clobber return register.  */
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|clobber_return_register
argument_list|()
expr_stmt|;
name|expand_naked_return
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|clobber_after
argument_list|)
expr_stmt|;
block|}
comment|/* Output the label for the naked return from the function.  */
name|emit_label
argument_list|(
name|naked_return_label
argument_list|)
expr_stmt|;
comment|/* If stack protection is enabled for this function, check the guard.  */
if|if
condition|(
name|cfun
operator|->
name|stack_protect_guard
condition|)
name|stack_protect_epilogue
argument_list|()
expr_stmt|;
comment|/* If we had calls to alloca, and this machine needs      an accurate stack pointer to exit the function,      insert some code to save and restore the stack pointer.  */
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
operator|&&
name|current_function_calls_alloca
condition|)
block|{
name|rtx
name|tem
init|=
literal|0
decl_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_FUNCTION
argument_list|,
operator|&
name|tem
argument_list|,
name|parm_birth_insn
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_FUNCTION
argument_list|,
name|tem
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* ??? This should no longer be necessary since stupid is no longer with      us, but there are some parts of the compiler (eg reload_combine, and      sh mach_dep_reorg) that still try and compute their own lifetime info      instead of using the general framework.  */
name|use_return_register
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|rtx
name|get_arg_pointer_save_area
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|rtx
name|ret
init|=
name|f
operator|->
name|x_arg_pointer_save_area
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ret
operator|=
name|assign_stack_local_1
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|x_arg_pointer_save_area
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|cfun
operator|&&
operator|!
name|f
operator|->
name|arg_pointer_save_area_init
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
comment|/* Save the arg pointer at the beginning of the function.  The 	 generated stack slot may not be a valid memory address, so we 	 have to check it and fix it if necessary.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|ret
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|entry_of_function
argument_list|()
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extend a vector that records the INSN_UIDs of INSNS    (a list of one or more insns).  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|record_insns
argument_list|(
name|rtx
name|insns
argument_list|,
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|vecp
argument_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|insns
init|;
name|tmp
operator|!=
name|NULL_RTX
condition|;
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
control|)
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
operator|*
name|vecp
argument_list|,
name|INSN_UID
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Set the locator of the insn chain starting at INSN to LOC.  */
end_comment

begin_function
specifier|static
name|void
name|set_insn_locators
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|loc
parameter_list|)
block|{
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|INSN_LOCATOR
argument_list|(
name|insn
argument_list|)
operator|=
name|loc
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine how many INSN_UIDs in VEC are part of INSN.  Because we can    be running after reorg, SEQUENCE rtl is possible.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|contains
argument_list|(
name|rtx
name|insn
argument_list|,
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|vec
argument_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
for|for
control|(
name|j
operator|=
name|VEC_length
argument_list|(
name|int
argument_list|,
operator|*
name|vec
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|VEC_index
argument_list|(
name|int
argument_list|,
operator|*
name|vec
argument_list|,
name|j
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
name|VEC_length
argument_list|(
name|int
argument_list|,
operator|*
name|vec
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|==
name|VEC_index
argument_list|(
name|int
argument_list|,
operator|*
name|vec
argument_list|,
name|j
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_function
name|int
name|prologue_epilogue_contains
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|insn
argument_list|,
operator|&
name|prologue
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|contains
argument_list|(
name|insn
argument_list|,
operator|&
name|epilogue
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sibcall_epilogue_contains
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|sibcall_epilogue
condition|)
return|return
name|contains
argument_list|(
name|insn
argument_list|,
operator|&
name|sibcall_epilogue
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_return
end_ifdef

begin_comment
comment|/* Insert gen_return at the end of block BB.  This also means updating    block_for_insn appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|emit_return_into_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
name|line_note
parameter_list|)
block|{
name|emit_jump_insn_after
argument_list|(
name|gen_return
argument_list|()
argument_list|,
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_note
condition|)
name|emit_note_copy_after
argument_list|(
name|line_note
argument_list|,
name|PREV_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_return */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
operator|&&
name|defined
argument_list|(
name|INCOMING_RETURN_ADDR_RTX
argument_list|)
end_if

begin_comment
comment|/* These functions convert the epilogue into a variant that does not    modify the stack pointer.  This is used in cases where a function    returns an object whose size is not known until it is computed.    The called function leaves the object on the stack, leaves the    stack depressed, and returns a pointer to the object.     What we need to do is track all modifications and references to the    stack pointer, deleting the modifications and changing the    references to point to the location the stack pointer would have    pointed to had the modifications taken place.     These functions need to be portable so we need to make as few    assumptions about the epilogue as we can.  However, the epilogue    basically contains three things: instructions to reset the stack    pointer, instructions to reload registers, possibly including the    frame pointer, and an instruction to return to the caller.     We must be sure of what a relevant epilogue insn is doing.  We also    make no attempt to validate the insns we make since if they are    invalid, we probably can't do anything valid.  The intent is that    these routines get "smarter" as more and more machines start to use    them and they try operating on different epilogues.     We use the following structure to track what the part of the    epilogue that we've already processed has done.  We keep two copies    of the SP equivalence, one for use during the insn we are    processing and one for use in the next insn.  The difference is    because one part of a PARALLEL may adjust SP and the other may use    it.  */
end_comment

begin_struct
struct|struct
name|epi_info
block|{
name|rtx
name|sp_equiv_reg
decl_stmt|;
comment|/* REG that SP is set from, perhaps SP.  */
name|HOST_WIDE_INT
name|sp_offset
decl_stmt|;
comment|/* Offset from SP_EQUIV_REG of present SP.  */
name|rtx
name|new_sp_equiv_reg
decl_stmt|;
comment|/* REG to be used at end of insn.  */
name|HOST_WIDE_INT
name|new_sp_offset
decl_stmt|;
comment|/* Offset to be used at end of insn.  */
name|rtx
name|equiv_reg_src
decl_stmt|;
comment|/* If nonzero, the value that SP_EQUIV_REG 				   should be set to once we no longer need 				   its value.  */
name|rtx
name|const_equiv
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
comment|/* Any known constant equivalences 					     for registers.  */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|handle_epilogue_set
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|epi_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_epilogue_consts
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_equiv_load
parameter_list|(
name|struct
name|epi_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Modify INSN, a list of one or more insns that is part of the epilogue, to    no modifications to the stack pointer.  Return the new list of insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|keep_stack_depressed
parameter_list|(
name|rtx
name|insns
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|epi_info
name|info
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
comment|/* If the epilogue is just a single instruction, it must be OK as is.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insns
argument_list|)
operator|==
name|NULL_RTX
condition|)
return|return
name|insns
return|;
comment|/* Otherwise, start a sequence, initialize the information we have, and      process all the insns we were given.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|info
operator|.
name|sp_equiv_reg
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|info
operator|.
name|sp_offset
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|equiv_reg_src
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
name|info
operator|.
name|const_equiv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|insns
expr_stmt|;
name|next
operator|=
name|NULL_RTX
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* If this insn references the register that SP is equivalent to and 	 we have a pending load to that register, we must force out the load 	 first and then indicate we no longer know what SP's equivalent is.  */
if|if
condition|(
name|info
operator|.
name|equiv_reg_src
operator|!=
literal|0
operator|&&
name|reg_referenced_p
argument_list|(
name|info
operator|.
name|sp_equiv_reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|emit_equiv_load
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|sp_equiv_reg
operator|=
literal|0
expr_stmt|;
block|}
name|info
operator|.
name|new_sp_equiv_reg
operator|=
name|info
operator|.
name|sp_equiv_reg
expr_stmt|;
name|info
operator|.
name|new_sp_offset
operator|=
name|info
operator|.
name|sp_offset
expr_stmt|;
comment|/* If this is a (RETURN) and the return address is on the stack, 	 update the address and change to an indirect jump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
block|{
name|rtx
name|retaddr
init|=
name|INCOMING_RETURN_ADDR_RTX
decl_stmt|;
name|rtx
name|base
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|jump_insn
decl_stmt|,
name|jump_set
decl_stmt|;
comment|/* If the return address is in a register, we can emit the insn 	     unchanged.  Otherwise, it must be a MEM and we see what the 	     base register and offset are.  In any case, we have to emit any 	     pending load to the equivalent reg of SP, if any.  */
if|if
condition|(
name|REG_P
argument_list|(
name|retaddr
argument_list|)
condition|)
block|{
name|emit_equiv_load
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|rtx
name|ret_ptr
decl_stmt|;
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|retaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ret_ptr
operator|=
name|XEXP
argument_list|(
name|retaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|ret_ptr
argument_list|)
condition|)
block|{
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REGNO
argument_list|(
name|ret_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|ret_ptr
argument_list|)
operator|==
name|PLUS
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|ret_ptr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ret_ptr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ret_ptr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ret_ptr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the base of the location containing the return pointer 	     is SP, we must update it with the replacement address.  Otherwise, 	     just build the necessary MEM.  */
name|retaddr
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|stack_pointer_rtx
condition|)
name|retaddr
operator|=
name|simplify_replace_rtx
argument_list|(
name|retaddr
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|info
operator|.
name|sp_equiv_reg
argument_list|,
name|info
operator|.
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|retaddr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
name|MEM_NOTRAP_P
argument_list|(
name|retaddr
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If there is a pending load to the equivalent register for SP 	     and we reference that register, we must load our address into 	     a scratch register and then do that load.  */
if|if
condition|(
name|info
operator|.
name|equiv_reg_src
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|info
operator|.
name|equiv_reg_src
argument_list|,
name|retaddr
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|Pmode
argument_list|)
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|Pmode
index|]
argument_list|,
name|info
operator|.
name|equiv_reg_src
argument_list|,
name|NULL
argument_list|)
operator|&&
name|info
operator|.
name|const_equiv
index|[
name|regno
index|]
operator|==
literal|0
condition|)
break|break;
name|gcc_assert
argument_list|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
name|retaddr
operator|=
name|reg
expr_stmt|;
block|}
name|emit_equiv_load
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|jump_insn
operator|=
name|emit_jump_insn
argument_list|(
name|gen_indirect_jump
argument_list|(
name|retaddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Show the SET in the above insn is a RETURN.  */
name|jump_set
operator|=
name|single_set
argument_list|(
name|jump_insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|jump_set
argument_list|)
expr_stmt|;
name|SET_IS_RETURN_P
argument_list|(
name|jump_set
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If SP is not mentioned in the pattern and its equivalent register, if 	 any, is not modified, just emit it.  Otherwise, if neither is set, 	 replace the reference to SP and emit the insn.  If none of those are 	 true, handle each SET individually.  */
elseif|else
if|if
condition|(
operator|!
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|(
name|info
operator|.
name|sp_equiv_reg
operator|==
name|stack_pointer_rtx
operator|||
operator|!
name|reg_set_p
argument_list|(
name|info
operator|.
name|sp_equiv_reg
argument_list|,
name|insn
argument_list|)
operator|)
condition|)
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|reg_set_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|insn
argument_list|)
operator|&&
operator|(
name|info
operator|.
name|sp_equiv_reg
operator|==
name|stack_pointer_rtx
operator|||
operator|!
name|reg_set_p
argument_list|(
name|info
operator|.
name|sp_equiv_reg
argument_list|,
name|insn
argument_list|)
operator|)
condition|)
block|{
name|int
name|changed
decl_stmt|;
name|changed
operator|=
name|validate_replace_rtx
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|info
operator|.
name|sp_equiv_reg
argument_list|,
name|info
operator|.
name|sp_offset
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|changed
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|handle_epilogue_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|handle_epilogue_set
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
else|else
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|info
operator|.
name|sp_equiv_reg
operator|=
name|info
operator|.
name|new_sp_equiv_reg
expr_stmt|;
name|info
operator|.
name|sp_offset
operator|=
name|info
operator|.
name|new_sp_offset
expr_stmt|;
comment|/* Now update any constants this insn sets.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|update_epilogue_consts
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|insns
return|;
block|}
end_function

begin_comment
comment|/* SET is a SET from an insn in the epilogue.  P is a pointer to the epi_info    structure that contains information about what we've seen so far.  We    process this SET by either updating that data or by emitting one or    more insns.  */
end_comment

begin_function
specifier|static
name|void
name|handle_epilogue_set
parameter_list|(
name|rtx
name|set
parameter_list|,
name|struct
name|epi_info
modifier|*
name|p
parameter_list|)
block|{
comment|/* First handle the case where we are setting SP.  Record what it is being      set from, which we must be able to determine  */
if|if
condition|(
name|reg_set_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|set
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|p
operator|->
name|new_sp_equiv_reg
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|p
operator|->
name|new_sp_offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|new_sp_offset
operator|=
name|INTVAL
argument_list|(
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|p
operator|->
name|new_sp_equiv_reg
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|,
name|p
operator|->
name|new_sp_offset
operator|=
literal|0
expr_stmt|;
comment|/* If we are adjusting SP, we adjust from the old data.  */
if|if
condition|(
name|p
operator|->
name|new_sp_equiv_reg
operator|==
name|stack_pointer_rtx
condition|)
block|{
name|p
operator|->
name|new_sp_equiv_reg
operator|=
name|p
operator|->
name|sp_equiv_reg
expr_stmt|;
name|p
operator|->
name|new_sp_offset
operator|+=
name|p
operator|->
name|sp_offset
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|p
operator|->
name|new_sp_equiv_reg
operator|&&
name|REG_P
argument_list|(
name|p
operator|->
name|new_sp_equiv_reg
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Next handle the case where we are setting SP's equivalent      register.  We must not already have a value to set it to.  We      could update, but there seems little point in handling that case.      Note that we have to allow for the case where we are setting the      register set in the previous part of a PARALLEL inside a single      insn.  But use the old offset for any updates within this insn.      We must allow for the case where the register is being set in a      different (usually wider) mode than Pmode).  */
elseif|else
if|if
condition|(
name|p
operator|->
name|new_sp_equiv_reg
operator|!=
literal|0
operator|&&
name|reg_set_p
argument_list|(
name|p
operator|->
name|new_sp_equiv_reg
argument_list|,
name|set
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|p
operator|->
name|equiv_reg_src
operator|&&
name|REG_P
argument_list|(
name|p
operator|->
name|new_sp_equiv_reg
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_WORD
operator|)
operator|&&
name|REGNO
argument_list|(
name|p
operator|->
name|new_sp_equiv_reg
argument_list|)
operator|==
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|equiv_reg_src
operator|=
name|simplify_replace_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|p
operator|->
name|sp_equiv_reg
argument_list|,
name|p
operator|->
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, replace any references to SP in the insn to its new value      and emit the insn.  */
else|else
block|{
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|simplify_replace_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|p
operator|->
name|sp_equiv_reg
argument_list|,
name|p
operator|->
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|simplify_replace_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|p
operator|->
name|sp_equiv_reg
argument_list|,
name|p
operator|->
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update the tracking information for registers set to constants.  */
end_comment

begin_function
specifier|static
name|void
name|update_epilogue_consts
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|epi_info
modifier|*
name|p
init|=
operator|(
expr|struct
name|epi_info
operator|*
operator|)
name|data
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|dest
argument_list|)
operator|||
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
comment|/* If we are either clobbering a register or doing a partial set,      show we don't know the value.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|dest
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If we are setting it to a constant, record that constant.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this is a binary operation between a register we have been tracking      and a constant, see if we can compute a new constant value.  */
elseif|else
if|if
condition|(
name|ARITHMETIC_P
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
literal|0
operator|!=
operator|(
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
name|new
expr_stmt|;
comment|/* Otherwise, we can't do anything with this value.  */
else|else
name|p
operator|->
name|const_equiv
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an insn to do the load shown in p->equiv_reg_src, if needed.  */
end_comment

begin_function
specifier|static
name|void
name|emit_equiv_load
parameter_list|(
name|struct
name|epi_info
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|equiv_reg_src
operator|!=
literal|0
condition|)
block|{
name|rtx
name|dest
init|=
name|p
operator|->
name|sp_equiv_reg
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|p
operator|->
name|equiv_reg_src
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
condition|)
name|dest
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|p
operator|->
name|equiv_reg_src
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|p
operator|->
name|sp_equiv_reg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|p
operator|->
name|equiv_reg_src
argument_list|)
expr_stmt|;
name|p
operator|->
name|equiv_reg_src
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate the prologue and epilogue RTL if the machine supports it.  Thread    this into place with notes indicating where the prologue ends and where    the epilogue begins.  Update the basic block information when possible.  */
end_comment

begin_function
name|void
name|thread_prologue_and_epilogue_insns
parameter_list|(
name|rtx
name|f
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|inserted
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_sibcall_epilogue
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_return
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_prologue
argument_list|)
name|rtx
name|seq
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_prologue
name|rtx
name|prologue_end
init|=
name|NULL_RTX
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_return
argument_list|)
name|rtx
name|epilogue_end
init|=
name|NULL_RTX
decl_stmt|;
endif|#
directive|endif
name|edge_iterator
name|ei
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_prologue
if|if
condition|(
name|HAVE_prologue
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|seq
operator|=
name|gen_prologue
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* Retain a map of the prologue insns.  */
name|record_insns
argument_list|(
name|seq
argument_list|,
operator|&
name|prologue
argument_list|)
expr_stmt|;
name|prologue_end
operator|=
name|emit_note
argument_list|(
name|NOTE_INSN_PROLOGUE_END
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PROFILE_BEFORE_PROLOGUE
comment|/* Ensure that instructions are not moved into the prologue when 	 profiling is on.  The call to the profiling routine can be 	 emitted within the live range of a call-clobbered register.  */
if|if
condition|(
name|current_function_profile
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|set_insn_locators
argument_list|(
name|seq
argument_list|,
name|prologue_locator
argument_list|)
expr_stmt|;
comment|/* Can't deal with multiple successors of the entry block          at the moment.  Function should always have at least one          entry point.  */
name|gcc_assert
argument_list|(
name|single_succ_p
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|)
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|seq
argument_list|,
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If the exit block has no non-fake predecessors, we don't need      an epilogue.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
goto|goto
name|epilogue_done
goto|;
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|optimize
operator|&&
name|HAVE_return
condition|)
block|{
comment|/* If we're allowed to generate a simple return instruction, 	 then by definition we don't need a full epilogue.  Examine 	 the block that falls through to EXIT.   If it does not 	 contain any code, examine its predecessors and try to 	 emit (conditional) return instructions.  */
name|basic_block
name|last
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
goto|goto
name|epilogue_done
goto|;
name|last
operator|=
name|e
operator|->
name|src
expr_stmt|;
comment|/* Verify that there are no active instructions in the last block.  */
name|label
operator|=
name|BB_END
argument_list|(
name|last
argument_list|)
expr_stmt|;
while|while
condition|(
name|label
operator|&&
operator|!
name|LABEL_P
argument_list|(
name|label
argument_list|)
condition|)
block|{
if|if
condition|(
name|active_insn_p
argument_list|(
name|label
argument_list|)
condition|)
break|break;
name|label
operator|=
name|PREV_INSN
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BB_HEAD
argument_list|(
name|last
argument_list|)
operator|==
name|label
operator|&&
name|LABEL_P
argument_list|(
name|label
argument_list|)
condition|)
block|{
name|edge_iterator
name|ei2
decl_stmt|;
name|rtx
name|epilogue_line_note
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Locate the line number associated with the closing brace, 	     if we can find one.  */
for|for
control|(
name|seq
operator|=
name|get_last_insn
argument_list|()
init|;
name|seq
operator|&&
operator|!
name|active_insn_p
argument_list|(
name|seq
argument_list|)
condition|;
name|seq
operator|=
name|PREV_INSN
argument_list|(
name|seq
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|seq
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|seq
argument_list|)
operator|>
literal|0
condition|)
block|{
name|epilogue_line_note
operator|=
name|seq
expr_stmt|;
break|break;
block|}
for|for
control|(
name|ei2
operator|=
name|ei_start
argument_list|(
name|last
operator|->
name|preds
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei2
argument_list|)
operator|)
condition|;
control|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|jump
decl_stmt|;
if|if
condition|(
name|bb
operator|==
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|ei_next
argument_list|(
operator|&
name|ei2
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|jump
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|jump
argument_list|)
operator|||
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|!=
name|label
condition|)
block|{
name|ei_next
argument_list|(
operator|&
name|ei2
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we have an unconditional jump, we can replace that 		 with a simple return instruction.  */
if|if
condition|(
name|simplejump_p
argument_list|(
name|jump
argument_list|)
condition|)
block|{
name|emit_return_into_block
argument_list|(
name|bb
argument_list|,
name|epilogue_line_note
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a conditional jump, we can try to replace 		 that with a conditional return instruction.  */
elseif|else
if|if
condition|(
name|condjump_p
argument_list|(
name|jump
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|jump
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ei_next
argument_list|(
operator|&
name|ei2
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this block has only one successor, it both jumps 		     and falls through to the fallthru block, so we can't 		     delete the edge.  */
if|if
condition|(
name|single_succ_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|ei_next
argument_list|(
operator|&
name|ei2
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|ei_next
argument_list|(
operator|&
name|ei2
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Fix up the CFG for the successful change we just made.  */
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
block|}
comment|/* Emit a return insn for the exit fallthru block.  Whether 	     this is still reachable will be determined later.  */
name|emit_barrier_after
argument_list|(
name|BB_END
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|emit_return_into_block
argument_list|(
name|last
argument_list|,
name|epilogue_line_note
argument_list|)
expr_stmt|;
name|epilogue_end
operator|=
name|BB_END
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|last
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
goto|goto
name|epilogue_done
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* Find the edge that falls through to EXIT.  Other edges may exist      due to RETURN instructions, but those don't need epilogues.      There really shouldn't be a mixture -- either all should have      been converted or none, however...  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
goto|goto
name|epilogue_done
goto|;
ifdef|#
directive|ifdef
name|HAVE_epilogue
if|if
condition|(
name|HAVE_epilogue
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|epilogue_end
operator|=
name|emit_note
argument_list|(
name|NOTE_INSN_EPILOGUE_BEG
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_epilogue
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|INCOMING_RETURN_ADDR_RTX
comment|/* If this function returns with the stack depressed and we can support 	 it, massage the epilogue to actually do that.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TYPE_RETURNS_STACK_DEPRESSED
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|seq
operator|=
name|keep_stack_depressed
argument_list|(
name|seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_jump_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* Retain a map of the epilogue insns.  */
name|record_insns
argument_list|(
name|seq
argument_list|,
operator|&
name|epilogue
argument_list|)
expr_stmt|;
name|set_insn_locators
argument_list|(
name|seq
argument_list|,
name|epilogue_locator
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|seq
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|basic_block
name|cur_bb
decl_stmt|;
if|if
condition|(
operator|!
name|next_active_insn
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
argument_list|)
condition|)
goto|goto
name|epilogue_done
goto|;
comment|/* We have a fall-through edge to the exit block, the source is not          at the end of the function, and there will be an assembler epilogue          at the end of the function.          We can't use force_nonfallthru here, because that would try to          use return.  Inserting a jump 'by hand' is extremely messy, so 	 we take advantage of cfg_layout_finalize using 	fixup_fallthru_exit_predecessor.  */
name|cfg_layout_initialize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|cur_bb
argument_list|)
if|if
condition|(
name|cur_bb
operator|->
name|index
operator|>=
name|NUM_FIXED_BLOCKS
operator|&&
name|cur_bb
operator|->
name|next_bb
operator|->
name|index
operator|>=
name|NUM_FIXED_BLOCKS
condition|)
name|cur_bb
operator|->
name|aux
operator|=
name|cur_bb
operator|->
name|next_bb
expr_stmt|;
name|cfg_layout_finalize
argument_list|()
expr_stmt|;
block|}
name|epilogue_done
label|:
if|if
condition|(
name|inserted
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_sibcall_epilogue
comment|/* Emit sibling epilogues before any sibling call sites.  */
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|preds
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sibcall_epilogue
argument_list|()
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Retain a map of the epilogue insns.  Used in life analysis to 	 avoid getting rid of sibcall epilogue insns.  Do this before we 	 actually emit the sequence.  */
name|record_insns
argument_list|(
name|seq
argument_list|,
operator|&
name|sibcall_epilogue
argument_list|)
expr_stmt|;
name|set_insn_locators
argument_list|(
name|seq
argument_list|,
name|epilogue_locator
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_prologue
comment|/* This is probably all useless now that we use locators.  */
if|if
condition|(
name|prologue_end
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|prev
decl_stmt|;
comment|/* GDB handles `break f' by setting a breakpoint on the first 	 line note after the prologue.  Which means (1) that if 	 there are line number notes before where we inserted the 	 prologue we should move them, and (2) we should generate a 	 note before the end of the first basic block, if there isn't 	 one already there.  	 ??? This behavior is completely broken when dealing with 	 multiple entry functions.  We simply place the note always 	 into first basic block and let alternate entry points 	 to be missed.        */
for|for
control|(
name|insn
operator|=
name|prologue_end
init|;
name|insn
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Note that we cannot reorder the first insn in the 		 chain, since rest_of_compilation relies on that 		 remaining constant.  */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
break|break;
name|reorder_insns
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
name|prologue_end
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Find the last line number note in the first block.  */
for|for
control|(
name|insn
operator|=
name|BB_END
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
argument_list|)
init|;
name|insn
operator|!=
name|prologue_end
operator|&&
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
break|break;
comment|/* If we didn't find one, make a copy of the first line number 	 we run across.  */
if|if
condition|(
operator|!
name|insn
condition|)
block|{
for|for
control|(
name|insn
operator|=
name|next_active_insn
argument_list|(
name|prologue_end
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
name|emit_note_copy_after
argument_list|(
name|insn
argument_list|,
name|prologue_end
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_epilogue
if|if
condition|(
name|epilogue_end
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
comment|/* Similarly, move any line notes that appear after the epilogue.          There is no need, however, to be quite so anal about the existence 	 of such a note.  Also move the NOTE_INSN_FUNCTION_END and (possibly) 	 NOTE_INSN_FUNCTION_BEG notes, as those can be relevant for debug 	 info generation.  */
for|for
control|(
name|insn
operator|=
name|epilogue_end
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_END
operator|)
condition|)
name|reorder_insns
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
name|PREV_INSN
argument_list|(
name|epilogue_end
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Reposition the prologue-end and epilogue-begin notes after instruction    scheduling and delayed branch scheduling.  */
end_comment

begin_function
name|void
name|reposition_prologue_and_epilogue_notes
parameter_list|(
name|rtx
name|f
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_prologue
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|,
name|note
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|VEC_length
argument_list|(
name|int
argument_list|,
name|prologue
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|last
operator|=
literal|0
operator|,
name|note
operator|=
literal|0
expr_stmt|;
comment|/* Scan from the beginning until we reach the last prologue insn. 	 We apparently can't depend on basic_block_{head,end} after 	 reorg has run.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_PROLOGUE_END
condition|)
name|note
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|contains
argument_list|(
name|insn
argument_list|,
operator|&
name|prologue
argument_list|)
condition|)
block|{
name|last
operator|=
name|insn
expr_stmt|;
if|if
condition|(
operator|--
name|len
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|last
condition|)
block|{
comment|/* Find the prologue-end note if we haven't already, and 	     move it to just after the last prologue insn.  */
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|note
operator|=
name|last
init|;
operator|(
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
operator|)
condition|;
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|note
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_PROLOGUE_END
condition|)
break|break;
block|}
comment|/* Avoid placing note between CODE_LABEL and BASIC_BLOCK note.  */
if|if
condition|(
name|LABEL_P
argument_list|(
name|last
argument_list|)
condition|)
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|note
argument_list|,
name|note
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|VEC_length
argument_list|(
name|int
argument_list|,
name|epilogue
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|last
operator|=
literal|0
operator|,
name|note
operator|=
literal|0
expr_stmt|;
comment|/* Scan from the end until we reach the first epilogue insn. 	 We apparently can't depend on basic_block_{head,end} after 	 reorg has run.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
name|note
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|contains
argument_list|(
name|insn
argument_list|,
operator|&
name|epilogue
argument_list|)
condition|)
block|{
name|last
operator|=
name|insn
expr_stmt|;
if|if
condition|(
operator|--
name|len
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|last
condition|)
block|{
comment|/* Find the epilogue-begin note if we haven't already, and 	     move it to just before the first epilogue insn.  */
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|note
operator|=
name|insn
init|;
operator|(
name|note
operator|=
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|)
condition|;
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|note
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
break|break;
block|}
if|if
condition|(
name|PREV_INSN
argument_list|(
name|last
argument_list|)
operator|!=
name|note
condition|)
name|reorder_insns
argument_list|(
name|note
argument_list|,
name|note
argument_list|,
name|PREV_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_prologue or HAVE_epilogue */
block|}
end_function

begin_comment
comment|/* Resets insn_block_boundaries array.  */
end_comment

begin_function
name|void
name|reset_block_changes
parameter_list|(
name|void
parameter_list|)
block|{
name|cfun
operator|->
name|ib_boundaries_block
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|cfun
operator|->
name|ib_boundaries_block
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the boundary for BLOCK.  */
end_comment

begin_function
name|void
name|record_block_change
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|tree
name|last_block
decl_stmt|;
if|if
condition|(
operator|!
name|block
condition|)
return|return;
if|if
condition|(
operator|!
name|cfun
operator|->
name|ib_boundaries_block
condition|)
return|return;
name|last_block
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|cfun
operator|->
name|ib_boundaries_block
argument_list|)
expr_stmt|;
name|n
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|cfun
operator|->
name|ib_boundaries_block
argument_list|)
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|cfun
operator|->
name|ib_boundaries_block
argument_list|,
name|last_block
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|cfun
operator|->
name|ib_boundaries_block
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finishes record of boundaries.  */
end_comment

begin_function
name|void
name|finalize_block_changes
parameter_list|(
name|void
parameter_list|)
block|{
name|record_block_change
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For INSN return the BLOCK it belongs to.  */
end_comment

begin_function
name|void
name|check_block_change
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|tree
modifier|*
name|block
parameter_list|)
block|{
name|unsigned
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|uid
operator|>=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|cfun
operator|->
name|ib_boundaries_block
argument_list|)
condition|)
return|return;
operator|*
name|block
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|cfun
operator|->
name|ib_boundaries_block
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Releases the ib_boundaries_block records.  */
end_comment

begin_function
name|void
name|free_block_changes
parameter_list|(
name|void
parameter_list|)
block|{
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|cfun
operator|->
name|ib_boundaries_block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the name of the current function.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|current_function_name
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|cfun
operator|->
name|decl
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_check_leaf_regs
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
name|current_function_uses_only_leaf_regs
operator|=
name|optimize
operator|>
literal|0
operator|&&
name|only_leaf_regs_used
argument_list|()
operator|&&
name|leaf_function_p
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insert a TYPE into the used types hash table of CFUN.  */
end_comment

begin_function
specifier|static
name|void
name|used_types_insert_helper
parameter_list|(
name|tree
name|type
parameter_list|,
name|struct
name|function
modifier|*
name|func
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|NULL
operator|&&
name|func
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|func
operator|->
name|used_types_hash
operator|==
name|NULL
condition|)
name|func
operator|->
name|used_types_hash
operator|=
name|htab_create_ggc
argument_list|(
literal|37
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|func
operator|->
name|used_types_hash
argument_list|,
name|type
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
operator|*
name|slot
operator|=
name|type
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a type, insert it into the used hash table in cfun.  */
end_comment

begin_function
name|void
name|used_types_insert
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_NONE
condition|)
name|used_types_insert_helper
argument_list|(
name|t
argument_list|,
name|cfun
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_leaf_regs
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|rest_of_handle_check_leaf_regs
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gt-function.h"
end_include

end_unit

