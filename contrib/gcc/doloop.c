begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform doloop optimizations    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* This module is used to modify loops with a determinable number of    iterations to use special low-overhead looping instructions.     It first validates whether the loop is well behaved and has a    determinable number of iterations (either at compile or run-time).    It then modifies the loop to use a low-overhead looping pattern as    follows:     1. A pseudo register is allocated as the loop iteration counter.     2. The number of loop iterations is calculated and is stored       in the loop counter.     3. At the end of the loop, the jump insn is replaced by the       doloop_end pattern.  The compare must remain because it might be       used elsewhere.  If the loop-variable or condition register are       used elsewhere, they will be eliminated by flow.     4. An optional doloop_begin pattern is inserted at the top of the       loop. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_doloop_end
end_ifdef

begin_decl_stmt
specifier|static
name|rtx
name|doloop_condition_get
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|doloop_iterations_max
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop_info
operator|*
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doloop_valid_p
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doloop_modify
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doloop_modify_runtime
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the loop termination condition for PATTERN or zero    if it is not a decrement and branch jump insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|doloop_condition_get
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
name|rtx
name|cmp
decl_stmt|;
name|rtx
name|inc
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
comment|/* The canonical doloop pattern we expect is:       (parallel [(set (pc) (if_then_else (condition)                                         (label_ref (label))                                         (pc)))                 (set (reg) (plus (reg) (const_int -1)))                 (additional clobbers and uses)])       Some machines (IA-64) make the decrement conditional on      the condition as well, so we don't bother verifying the      actual decrement.  In summary, the branch must be the      first entry of the parallel (also required by jump.c),      and the second entry of the parallel must be a set of      the loop counter register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|!=
name|PARALLEL
condition|)
return|return
literal|0
return|;
name|cmp
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inc
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check for (set (reg) (something)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inc
argument_list|)
operator|!=
name|SET
operator|||
operator|!
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|inc
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Extract loop counter register.  */
name|reg
operator|=
name|SET_DEST
argument_list|(
name|inc
argument_list|)
expr_stmt|;
comment|/* Check for (set (pc) (if_then_else (condition)                                        (label_ref (label))                                        (pc))).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|cmp
argument_list|)
operator|!=
name|SET
operator|||
name|SET_DEST
argument_list|(
name|cmp
argument_list|)
operator|!=
name|pc_rtx
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|cmp
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|cmp
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|cmp
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|!=
name|pc_rtx
condition|)
return|return
literal|0
return|;
comment|/* Extract loop termination condition.  */
name|condition
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|cmp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
operator|!=
name|GE
operator|&&
name|GET_CODE
argument_list|(
name|condition
argument_list|)
operator|!=
name|NE
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
condition|)
return|return
name|condition
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
condition|)
return|return
name|condition
return|;
comment|/* ??? If a machine uses a funny comparison, we could return a      canonicalised form here.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return an estimate of the maximum number of loop iterations for the    loop specified by LOOP or zero if the loop is not normal.    MODE is the mode of the iteration count and NONNEG is non-zero if    the iteration count has been proved to be non-negative.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|doloop_iterations_max
parameter_list|(
name|loop_info
parameter_list|,
name|mode
parameter_list|,
name|nonneg
parameter_list|)
specifier|const
name|struct
name|loop_info
modifier|*
name|loop_info
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|nonneg
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|n_iterations_max
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|min_value
decl_stmt|;
name|rtx
name|max_value
decl_stmt|;
name|HOST_WIDE_INT
name|abs_inc
decl_stmt|;
name|int
name|neg_inc
decl_stmt|;
name|neg_inc
operator|=
literal|0
expr_stmt|;
name|abs_inc
operator|=
name|INTVAL
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs_inc
operator|<
literal|0
condition|)
block|{
name|abs_inc
operator|=
operator|-
name|abs_inc
expr_stmt|;
name|neg_inc
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|neg_inc
condition|)
block|{
name|code
operator|=
name|swap_condition
argument_list|(
name|loop_info
operator|->
name|comparison_code
argument_list|)
expr_stmt|;
name|min_value
operator|=
name|loop_info
operator|->
name|final_equiv_value
expr_stmt|;
name|max_value
operator|=
name|loop_info
operator|->
name|initial_equiv_value
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|loop_info
operator|->
name|comparison_code
expr_stmt|;
name|min_value
operator|=
name|loop_info
operator|->
name|initial_equiv_value
expr_stmt|;
name|max_value
operator|=
name|loop_info
operator|->
name|final_equiv_value
expr_stmt|;
block|}
comment|/* Since the loop has a VTOP, we know that the initial test will be      true and thus the value of max_value should be greater than the      value of min_value.  Thus the difference should always be positive      and the code must be LT, LE, LTU, LEU, or NE.  Otherwise the loop is      not normal, e.g., `for (i = 0; i< 10; i--)'.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LTU
case|:
case|case
name|LEU
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|umax
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|umin
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|min_value
argument_list|)
operator|==
name|CONST_INT
condition|)
name|umin
operator|=
name|INTVAL
argument_list|(
name|min_value
argument_list|)
expr_stmt|;
else|else
name|umin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|max_value
argument_list|)
operator|==
name|CONST_INT
condition|)
name|umax
operator|=
name|INTVAL
argument_list|(
name|max_value
argument_list|)
expr_stmt|;
else|else
name|umax
operator|=
operator|(
operator|(
name|unsigned
operator|)
literal|2
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|n_iterations_max
operator|=
name|umax
operator|-
name|umin
expr_stmt|;
break|break;
block|}
case|case
name|LT
case|:
case|case
name|LE
case|:
block|{
name|HOST_WIDE_INT
name|smax
decl_stmt|;
name|HOST_WIDE_INT
name|smin
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|min_value
argument_list|)
operator|==
name|CONST_INT
condition|)
name|smin
operator|=
name|INTVAL
argument_list|(
name|min_value
argument_list|)
expr_stmt|;
else|else
name|smin
operator|=
operator|-
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|max_value
argument_list|)
operator|==
name|CONST_INT
condition|)
name|smax
operator|=
name|INTVAL
argument_list|(
name|max_value
argument_list|)
expr_stmt|;
else|else
name|smax
operator|=
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|n_iterations_max
operator|=
name|smax
operator|-
name|smin
expr_stmt|;
break|break;
block|}
case|case
name|NE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|min_value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|max_value
argument_list|)
operator|==
name|CONST_INT
condition|)
name|n_iterations_max
operator|=
name|INTVAL
argument_list|(
name|max_value
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|min_value
argument_list|)
expr_stmt|;
else|else
comment|/* We need to conservatively assume that we might have the maximum 	   number of iterations without any additional knowledge.  */
name|n_iterations_max
operator|=
operator|(
operator|(
name|unsigned
operator|)
literal|2
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
name|n_iterations_max
operator|/=
name|abs_inc
expr_stmt|;
comment|/* If we know that the iteration count is non-negative then adjust      n_iterations_max if it is so large that it appears negative.  */
if|if
condition|(
name|nonneg
operator|&&
name|n_iterations_max
operator|>
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|n_iterations_max
operator|=
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|n_iterations_max
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the loop specified by LOOP is suitable for    the use of special low-overhead looping instructions.  */
end_comment

begin_function
specifier|static
name|int
name|doloop_valid_p
parameter_list|(
name|loop
parameter_list|,
name|jump_insn
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|jump_insn
decl_stmt|;
block|{
specifier|const
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
comment|/* The loop must have a conditional jump at the end.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|jump_insn
argument_list|)
operator|||
operator|!
name|onlyjump_p
argument_list|(
name|jump_insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Invalid jump at loop end.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Give up if a loop has been completely unrolled.  */
if|if
condition|(
name|loop_info
operator|->
name|n_iterations
operator|==
name|loop_info
operator|->
name|unroll_number
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Loop completely unrolled.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* The loop must have a single exit target.  A break or return      statement within a loop will generate multiple loop exits.      Another example of a loop that currently generates multiple exit      targets is for (i = 0; i< (foo ? 8 : 4); i++) { }.  */
if|if
condition|(
name|loop_info
operator|->
name|has_multiple_exit_targets
operator|||
name|loop
operator|->
name|exit_count
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Loop has multiple exit targets.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* An indirect jump may jump out of the loop.  */
if|if
condition|(
name|loop_info
operator|->
name|has_indirect_jump
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Indirect jump in function.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* A called function may clobber any special registers required for      low-overhead looping.  */
if|if
condition|(
name|loop_info
operator|->
name|has_call
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Function call in loop.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Some targets (eg, PPC) use the count register for branch on table      instructions.  ??? This should be a target specific check.  */
if|if
condition|(
name|loop_info
operator|->
name|has_tablejump
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Computed branch in the loop.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|loop_info
operator|->
name|increment
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Could not determine iteration info.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Increment not an integer constant.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* There is no guarantee that a NE loop will terminate if the      absolute increment is not unity.  ??? We could compute this      condition at run-time and have an additional jump around the loop      to ensure an infinite loop.  */
if|if
condition|(
name|loop_info
operator|->
name|comparison_code
operator|==
name|NE
operator|&&
name|INTVAL
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|INTVAL
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: NE loop with non-unity increment.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for loops that may not terminate under special conditions.  */
if|if
condition|(
operator|!
name|loop_info
operator|->
name|n_iterations
operator|&&
operator|(
operator|(
name|loop_info
operator|->
name|comparison_code
operator|==
name|LEU
operator|&&
name|INTVAL
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|loop_info
operator|->
name|comparison_code
operator|==
name|GEU
operator|&&
name|INTVAL
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|loop_info
operator|->
name|comparison_code
operator|==
name|LTU
operator|&&
name|INTVAL
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
operator|>
literal|1
operator|)
operator|||
operator|(
name|loop_info
operator|->
name|comparison_code
operator|==
name|GTU
operator|&&
name|INTVAL
argument_list|(
name|loop_info
operator|->
name|increment
argument_list|)
operator|<
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* If the comparison is LEU and the comparison value is UINT_MAX 	 then the loop will not terminate.  Similarly, if the 	 comparison code is GEU and the initial value is 0, the loop 	 will not terminate.  	 If the absolute increment is not 1, the loop can be infinite 	 even with LTU/GTU, e.g. for (i = 3; i> 0; i -= 2)  	 Note that with LE and GE, the loop behaviour is undefined 	 (C++ standard section 5 clause 5) if an overflow occurs, say 	 between INT_MAX and INT_MAX + 1.  We thus don't have to worry 	 about these two cases.  	 ??? We could compute these conditions at run-time and have a 	 additional jump around the loop to ensure an infinite loop. 	 However, it is very unlikely that this is the intended 	 behaviour of the loop and checking for these rare boundary 	 conditions would pessimize all other code.  	 If the loop is executed only a few times an extra check to 	 restart the loop could use up most of the benefits of using a 	 count register loop.  Note however, that normally, this 	 restart branch would never execute, so it could be predicted 	 well by the CPU.  We should generate the pessimistic code by 	 default, and have an option, e.g. -funsafe-loops that would 	 enable count-register loops in this case.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Possible infinite iteration case ignored.\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Modify the loop to use the low-overhead looping insn where LOOP    describes the loop, ITERATIONS is an RTX containing the desired    number of loop iterations, ITERATIONS_MAX is a CONST_INT specifying    the maximum number of loop iterations, and DOLOOP_INSN is the    low-overhead looping insn to emit at the end of the loop.  This    returns non-zero if it was successful.  */
end_comment

begin_function
specifier|static
name|int
name|doloop_modify
parameter_list|(
name|loop
parameter_list|,
name|iterations
parameter_list|,
name|iterations_max
parameter_list|,
name|doloop_seq
parameter_list|,
name|start_label
parameter_list|,
name|condition
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|iterations
decl_stmt|;
name|rtx
name|iterations_max
decl_stmt|;
name|rtx
name|doloop_seq
decl_stmt|;
name|rtx
name|start_label
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
block|{
name|rtx
name|counter_reg
decl_stmt|;
name|rtx
name|count
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|rtx
name|jump_insn
decl_stmt|;
name|int
name|nonneg
init|=
literal|0
decl_stmt|;
name|int
name|decrement_count
decl_stmt|;
name|jump_insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|loop
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Inserting doloop pattern ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|iterations
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|iterations
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"runtime"
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" iterations)."
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the label that will delimit the top of the loop.      This has to be done before the delete_insn call below, to prevent      delete_insn from deleting too much.  */
name|emit_label_after
argument_list|(
name|start_label
argument_list|,
name|loop
operator|->
name|top
condition|?
name|loop
operator|->
name|top
else|:
name|loop
operator|->
name|start
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|start_label
argument_list|)
operator|++
expr_stmt|;
comment|/* Discard original jump to continue loop.  The original compare      result may still be live, so it cannot be discarded explicitly.  */
name|delete_related_insns
argument_list|(
name|jump_insn
argument_list|)
expr_stmt|;
name|counter_reg
operator|=
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|counter_reg
argument_list|)
operator|==
name|PLUS
condition|)
name|counter_reg
operator|=
name|XEXP
argument_list|(
name|counter_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|count
operator|=
name|iterations
expr_stmt|;
name|decrement_count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
condition|)
block|{
case|case
name|NE
case|:
comment|/* Currently only NE tests against zero and one are supported.  */
if|if
condition|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
name|decrement_count
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|!=
name|const1_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|GE
case|:
comment|/* Currently only GE tests against zero are supported.  */
if|if
condition|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The iteration count needs decrementing for a GE test.  */
name|decrement_count
operator|=
literal|1
expr_stmt|;
comment|/* Determine if the iteration counter will be non-negative. 	 Note that the maximum value loaded is iterations_max - 1.  */
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|iterations_max
argument_list|)
operator|<=
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|counter_reg
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|nonneg
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Abort if an invalid doloop pattern has been generated.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|decrement_count
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|count
argument_list|)
operator|==
name|CONST_INT
condition|)
name|count
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|count
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|count
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|counter_reg
argument_list|)
argument_list|,
name|MINUS
argument_list|,
name|count
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* Insert initialization of the count register into the loop header.  */
name|convert_move
argument_list|(
name|counter_reg
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|sequence
argument_list|,
name|loop
operator|->
name|start
argument_list|)
expr_stmt|;
comment|/* Some targets (eg, C4x) need to initialize special looping      registers.  */
ifdef|#
directive|ifdef
name|HAVE_doloop_begin
block|{
name|rtx
name|init
decl_stmt|;
name|init
operator|=
name|gen_doloop_begin
argument_list|(
name|counter_reg
argument_list|,
name|GET_CODE
argument_list|(
name|iterations
argument_list|)
operator|==
name|CONST_INT
condition|?
name|iterations
else|:
name|const0_rtx
argument_list|,
name|iterations_max
argument_list|,
name|GEN_INT
argument_list|(
name|loop
operator|->
name|level
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|sequence
argument_list|,
name|loop
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Insert the new low-overhead looping insn.  */
name|emit_jump_insn_before
argument_list|(
name|doloop_seq
argument_list|,
name|loop
operator|->
name|end
argument_list|)
expr_stmt|;
name|jump_insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|loop
operator|->
name|end
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump_insn
argument_list|)
operator|=
name|start_label
expr_stmt|;
comment|/* Add a REG_NONNEG note if the actual or estimated maximum number      of iterations is non-negative.  */
if|if
condition|(
name|nonneg
condition|)
block|{
name|REG_NOTES
argument_list|(
name|jump_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NONNEG
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle the more complex case, where the bounds are not known at    compile time.  In this case we generate a run_time calculation of    the number of iterations.  We rely on the existence of a run-time    guard to ensure that the loop executes at least once, i.e.,    initial_value obeys the loop comparison condition.  If a guard is    not present, we emit one.  The loop to modify is described by LOOP.    ITERATIONS_MAX is a CONST_INT specifying the estimated maximum    number of loop iterations.  DOLOOP_INSN is the low-overhead looping    insn to insert.  Returns non-zero if loop successfully modified.  */
end_comment

begin_function
specifier|static
name|int
name|doloop_modify_runtime
parameter_list|(
name|loop
parameter_list|,
name|iterations_max
parameter_list|,
name|doloop_seq
parameter_list|,
name|start_label
parameter_list|,
name|mode
parameter_list|,
name|condition
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|iterations_max
decl_stmt|;
name|rtx
name|doloop_seq
decl_stmt|;
name|rtx
name|start_label
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
block|{
specifier|const
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|abs_inc
decl_stmt|;
name|int
name|neg_inc
decl_stmt|;
name|rtx
name|diff
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|rtx
name|iterations
decl_stmt|;
name|rtx
name|initial_value
decl_stmt|;
name|rtx
name|final_value
decl_stmt|;
name|rtx
name|increment
decl_stmt|;
name|int
name|unsigned_p
decl_stmt|;
name|enum
name|rtx_code
name|comparison_code
decl_stmt|;
name|increment
operator|=
name|loop_info
operator|->
name|increment
expr_stmt|;
name|initial_value
operator|=
name|loop_info
operator|->
name|initial_value
expr_stmt|;
name|final_value
operator|=
name|loop_info
operator|->
name|final_value
expr_stmt|;
name|neg_inc
operator|=
literal|0
expr_stmt|;
name|abs_inc
operator|=
name|INTVAL
argument_list|(
name|increment
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs_inc
operator|<
literal|0
condition|)
block|{
name|abs_inc
operator|=
operator|-
name|abs_inc
expr_stmt|;
name|neg_inc
operator|=
literal|1
expr_stmt|;
block|}
name|comparison_code
operator|=
name|loop_info
operator|->
name|comparison_code
expr_stmt|;
name|unsigned_p
operator|=
operator|(
name|comparison_code
operator|==
name|LTU
operator|||
name|comparison_code
operator|==
name|LEU
operator|||
name|comparison_code
operator|==
name|GTU
operator|||
name|comparison_code
operator|==
name|GEU
operator|||
name|comparison_code
operator|==
name|NE
operator|)
expr_stmt|;
comment|/* The number of iterations (prior to any loop unrolling) is given by:         n = (abs (final - initial) + abs_inc - 1) / abs_inc.       However, it is possible for the summation to overflow, and a      safer method is:         n = abs (final - initial) / abs_inc;        n += (abs (final - initial) % abs_inc) != 0;       If the loop has been unrolled, then the loop body has been      preconditioned to iterate a multiple of unroll_number times.  If      abs_inc is != 1, the full calculation is         t1 = abs_inc * unroll_number;        n = abs (final - initial) / t1;        n += (abs (final - initial) % t1)> t1 - abs_inc;       The division and modulo operations can be avoided by requiring      that the increment is a power of 2 (precondition_loop_p enforces      this requirement).  Nevertheless, the RTX_COSTS should be checked      to see if a fast divmod is available.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* abs (final - initial)  */
name|diff
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|MINUS
argument_list|,
name|copy_rtx
argument_list|(
name|neg_inc
condition|?
name|initial_value
else|:
name|final_value
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|neg_inc
condition|?
name|final_value
else|:
name|initial_value
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|unsigned_p
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Some code transformations can result in code akin to  	  tmp = i + 1; 	  ... 	  goto scan_start; 	top: 	  tmp = tmp + 1; 	scan_start: 	  i = tmp; 	  if (i< n) goto top;       We'll have already detected this form of loop in scan_loop,      and set loop->top and loop->scan_start appropriately.       In this situation, we skip the increment the first time through      the loop, which results in an incorrect estimate of the number      of iterations.  Adjust the difference to compensate.  */
comment|/* ??? Logically, it would seem this belongs in loop_iterations.      However, this causes regressions e.g. on x86 execute/20011008-3.c,      so I do not believe we've properly characterized the exact nature      of the problem.  In the meantime, this fixes execute/20011126-2.c      on ia64 and some Ada front end miscompilation on ppc.  */
if|if
condition|(
name|loop
operator|->
name|scan_start
condition|)
block|{
name|rtx
name|iteration_var
init|=
name|loop_info
operator|->
name|iteration_var
decl_stmt|;
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
if|if
condition|(
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|iteration_var
argument_list|)
argument_list|)
operator|==
name|BASIC_INDUCT
condition|)
name|bl
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|iteration_var
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|iteration_var
argument_list|)
argument_list|)
operator|==
name|GENERAL_INDUCT
condition|)
block|{
name|struct
name|induction
modifier|*
name|v
init|=
name|REG_IV_INFO
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|iteration_var
argument_list|)
argument_list|)
decl_stmt|;
name|bl
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Iteration var must be an induction variable to get here.  */
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|scan_start
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Basic induction var skips initial incr.\n"
argument_list|)
expr_stmt|;
name|diff
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|diff
argument_list|,
name|increment
argument_list|,
name|diff
argument_list|,
name|unsigned_p
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|abs_inc
operator|*
name|loop_info
operator|->
name|unroll_number
operator|!=
literal|1
condition|)
block|{
name|int
name|shift_count
decl_stmt|;
name|rtx
name|extra
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|limit
decl_stmt|;
name|shift_count
operator|=
name|exact_log2
argument_list|(
name|abs_inc
operator|*
name|loop_info
operator|->
name|unroll_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift_count
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* abs (final - initial) / (abs_inc * unroll_number)  */
name|iterations
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|diff
argument_list|)
argument_list|,
name|LSHIFTRT
argument_list|,
name|diff
argument_list|,
name|GEN_INT
argument_list|(
name|shift_count
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs_inc
operator|!=
literal|1
condition|)
block|{
comment|/* abs (final - initial) % (abs_inc * unroll_number)  */
name|rtx
name|count
init|=
name|GEN_INT
argument_list|(
name|abs_inc
operator|*
name|loop_info
operator|->
name|unroll_number
operator|-
literal|1
argument_list|)
decl_stmt|;
name|extra
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|iterations
argument_list|)
argument_list|,
name|AND
argument_list|,
name|diff
argument_list|,
name|count
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* If (abs (final - initial) % (abs_inc * unroll_number)<= abs_inc * (unroll - 1)), 	     jump past following increment instruction.  */
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|limit
operator|=
name|abs_inc
operator|*
operator|(
name|loop_info
operator|->
name|unroll_number
operator|-
literal|1
operator|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|extra
argument_list|,
name|GEN_INT
argument_list|(
name|limit
argument_list|)
argument_list|,
name|limit
operator|==
literal|0
condition|?
name|EQ
else|:
name|LEU
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|extra
argument_list|)
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
comment|/* Increment the iteration count by one.  */
name|iterations
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|iterations
argument_list|)
argument_list|,
name|PLUS
argument_list|,
name|iterations
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|,
name|iterations
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|iterations
operator|=
name|diff
expr_stmt|;
comment|/* If there is a NOTE_INSN_LOOP_VTOP, we have a `for' or `while'      style loop, with a loop exit test at the start.  Thus, we can      assume that the loop condition was true when the loop was      entered.       `do-while' loops require special treatment since the exit test is      not executed before the start of the loop.  We need to determine      if the loop will terminate after the first pass and to limit the      iteration count to one if necessary.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|vtop
condition|)
block|{
name|rtx
name|label
decl_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Do-while loop.\n"
argument_list|)
expr_stmt|;
comment|/* A `do-while' loop must iterate at least once.  If the 	 iteration count is bogus, we set the iteration count to 1. 	 Note that if the loop has been unrolled, then the loop body 	 is guaranteed to execute at least once.  */
if|if
condition|(
name|loop_info
operator|->
name|unroll_number
operator|==
literal|1
condition|)
block|{
comment|/*  Emit insns to test if the loop will immediately 	      terminate and to set the iteration count to 1 if true.  */
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|copy_rtx
argument_list|(
name|initial_value
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|loop_info
operator|->
name|comparison_value
argument_list|)
argument_list|,
name|comparison_code
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
name|emit_move_insn
argument_list|(
name|iterations
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|sequence
argument_list|,
name|loop
operator|->
name|start
argument_list|)
expr_stmt|;
return|return
name|doloop_modify
argument_list|(
name|loop
argument_list|,
name|iterations
argument_list|,
name|iterations_max
argument_list|,
name|doloop_seq
argument_list|,
name|start_label
argument_list|,
name|condition
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is the main entry point.  Process loop described by LOOP    validating that the loop is suitable for conversion to use a low    overhead looping instruction, replacing the jump insn where    suitable.  We distinguish between loops with compile-time bounds    and those with run-time bounds.  Information from LOOP is used to    compute the number of iterations and to determine whether the loop    is a candidate for this optimization.  Returns non-zero if loop    successfully modified.  */
end_comment

begin_function
name|int
name|doloop_optimize
parameter_list|(
name|loop
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|rtx
name|initial_value
decl_stmt|;
name|rtx
name|final_value
decl_stmt|;
name|rtx
name|increment
decl_stmt|;
name|rtx
name|jump_insn
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n_iterations
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n_iterations_max
decl_stmt|;
name|rtx
name|doloop_seq
decl_stmt|,
name|doloop_pat
decl_stmt|,
name|doloop_reg
decl_stmt|;
name|rtx
name|iterations
decl_stmt|;
name|rtx
name|iterations_max
decl_stmt|;
name|rtx
name|start_label
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Processing loop %d, enclosed levels %d.\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|,
name|loop
operator|->
name|level
argument_list|)
expr_stmt|;
name|jump_insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|loop
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* Check that loop is a candidate for a low-overhead looping insn.  */
if|if
condition|(
operator|!
name|doloop_valid_p
argument_list|(
name|loop
argument_list|,
name|jump_insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Determine if the loop can be safely, and profitably,      preconditioned.  While we don't precondition the loop in a loop      unrolling sense, this test ensures that the loop is well behaved      and that the increment is a constant integer.  */
if|if
condition|(
operator|!
name|precondition_loop_p
argument_list|(
name|loop
argument_list|,
operator|&
name|initial_value
argument_list|,
operator|&
name|final_value
argument_list|,
operator|&
name|increment
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Cannot precondition loop.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Determine or estimate the maximum number of loop iterations.  */
name|n_iterations
operator|=
name|loop_info
operator|->
name|n_iterations
expr_stmt|;
if|if
condition|(
name|n_iterations
condition|)
block|{
comment|/* This is the simple case where the initial and final loop 	 values are constants.  */
name|n_iterations_max
operator|=
name|n_iterations
expr_stmt|;
block|}
else|else
block|{
name|int
name|nonneg
init|=
name|find_reg_note
argument_list|(
name|jump_insn
argument_list|,
name|REG_NONNEG
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
decl_stmt|;
comment|/* This is the harder case where the initial and final loop 	 values may not be constants.  */
name|n_iterations_max
operator|=
name|doloop_iterations_max
argument_list|(
name|loop_info
argument_list|,
name|mode
argument_list|,
name|nonneg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n_iterations_max
condition|)
block|{
comment|/* We have something like `for (i = 0; i< 10; i--)'.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Not normal loop.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Account for loop unrolling in the iteration count.  This will      have no effect if loop_iterations could not determine the number      of iterations.  */
name|n_iterations
operator|/=
name|loop_info
operator|->
name|unroll_number
expr_stmt|;
name|n_iterations_max
operator|/=
name|loop_info
operator|->
name|unroll_number
expr_stmt|;
if|if
condition|(
name|n_iterations
operator|&&
name|n_iterations
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Too few iterations (%ld) to be profitable.\n"
argument_list|,
operator|(
name|long
name|int
operator|)
name|n_iterations
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|iterations
operator|=
name|GEN_INT
argument_list|(
name|n_iterations
argument_list|)
expr_stmt|;
name|iterations_max
operator|=
name|GEN_INT
argument_list|(
name|n_iterations_max
argument_list|)
expr_stmt|;
comment|/* Generate looping insn.  If the pattern FAILs then give up trying      to modify the loop since there is some aspect the back-end does      not like.  */
name|start_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|doloop_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|doloop_seq
operator|=
name|gen_doloop_end
argument_list|(
name|doloop_reg
argument_list|,
name|iterations
argument_list|,
name|iterations_max
argument_list|,
name|GEN_INT
argument_list|(
name|loop
operator|->
name|level
argument_list|)
argument_list|,
name|start_label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doloop_seq
operator|&&
name|mode
operator|!=
name|word_mode
condition|)
block|{
name|PUT_MODE
argument_list|(
name|doloop_reg
argument_list|,
name|word_mode
argument_list|)
expr_stmt|;
name|doloop_seq
operator|=
name|gen_doloop_end
argument_list|(
name|doloop_reg
argument_list|,
name|iterations
argument_list|,
name|iterations_max
argument_list|,
name|GEN_INT
argument_list|(
name|loop
operator|->
name|level
argument_list|)
argument_list|,
name|start_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doloop_seq
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Target unwilling to use doloop pattern!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* A raw define_insn may yield a plain pattern.  If a sequence      was involved, the last must be the jump instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|doloop_seq
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|doloop_pat
operator|=
name|XVECEXP
argument_list|(
name|doloop_seq
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|doloop_seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|doloop_pat
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|doloop_pat
operator|=
name|PATTERN
argument_list|(
name|doloop_pat
argument_list|)
expr_stmt|;
else|else
name|doloop_pat
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
name|doloop_pat
operator|=
name|doloop_seq
expr_stmt|;
if|if
condition|(
operator|!
name|doloop_pat
operator|||
operator|!
operator|(
name|condition
operator|=
name|doloop_condition_get
argument_list|(
name|doloop_pat
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Doloop: Unrecognizable doloop pattern!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|n_iterations
operator|!=
literal|0
condition|)
comment|/* Handle the simpler case, where we know the iteration count at        compile time.  */
return|return
name|doloop_modify
argument_list|(
name|loop
argument_list|,
name|iterations
argument_list|,
name|iterations_max
argument_list|,
name|doloop_seq
argument_list|,
name|start_label
argument_list|,
name|condition
argument_list|)
return|;
else|else
comment|/* Handle the harder case, where we must add additional runtime tests.  */
return|return
name|doloop_modify_runtime
argument_list|(
name|loop
argument_list|,
name|iterations_max
argument_list|,
name|doloop_seq
argument_list|,
name|start_label
argument_list|,
name|mode
argument_list|,
name|condition
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_doloop_end */
end_comment

end_unit

