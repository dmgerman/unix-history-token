begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Code sinking for trees    Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Daniel Berlin<dan@dberlin.org>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_comment
comment|/* TODO:    1. Sinking store only using scalar promotion (IE without moving the RHS):     *q = p;    p = p + 1;    if (something)      *q =<not p>;    else      y = *q;         should become    sinktemp = p;    p = p + 1;    if (something)      *q =<not p>;    else    {      *q = sinktemp;      y = *q    }    Store copy propagation will take care of the store elimination above.           2. Sinking using Partial Dead Code Elimination.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
comment|/* The number of statements sunk down the flowgraph by code sinking.  */
name|int
name|sunk
decl_stmt|;
block|}
name|sink_stats
struct|;
end_struct

begin_comment
comment|/* Given a PHI, and one of its arguments (DEF), find the edge for    that argument and return it.  If the argument occurs twice in the PHI node,    we return NULL.  */
end_comment

begin_function
specifier|static
name|basic_block
name|find_bb_for_arg
parameter_list|(
name|tree
name|phi
parameter_list|,
name|tree
name|def
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|foundone
init|=
name|false
decl_stmt|;
name|basic_block
name|result
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|==
name|def
condition|)
block|{
if|if
condition|(
name|foundone
condition|)
return|return
name|NULL
return|;
name|foundone
operator|=
name|true
expr_stmt|;
name|result
operator|=
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|->
name|src
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* When the first immediate use is in a statement, then return true if all    immediate uses in IMM are in the same statement.    We could also do the case where  the first immediate use is in a phi node,    and all the other uses are in phis in the same basic block, but this    requires some expensive checking later (you have to make sure no def/vdef    in the statement occurs for multiple edges in the various phi nodes it's    used in, so that you only have one place you can sink it to.  */
end_comment

begin_function
specifier|static
name|bool
name|all_immediate_uses_same_place
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|firstuse
init|=
name|NULL_TREE
decl_stmt|;
name|ssa_op_iter
name|op_iter
decl_stmt|;
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|var
argument_list|,
argument|stmt
argument_list|,
argument|op_iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
block|{
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|imm_iter
argument_list|,
argument|var
argument_list|)
block|{
if|if
condition|(
name|firstuse
operator|==
name|NULL_TREE
condition|)
name|firstuse
operator|=
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|firstuse
operator|!=
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Some global stores don't necessarily have V_MAY_DEF's of global variables,    but we still must avoid moving them around.  */
end_comment

begin_function
name|bool
name|is_hidden_global_store
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
comment|/* Check virtual definitions.  If we get here, the only virtual      definitions we should see are those generated by assignment      statements.  */
if|if
condition|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VIRTUAL_DEFS
argument_list|)
condition|)
block|{
name|tree
name|lhs
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
comment|/* Note that we must not check the individual virtual operands 	 here.  In particular, if this is an aliased store, we could 	 end up with something like the following (SSA notation 	 redacted for brevity):  	 	foo (int *p, int i) 		{ 		  int x; 		  p_1 = (i_2> 3) ?&x : p;  		  # x_4 = V_MAY_DEF<x_3> 		  *p_1 = 5;  		  return 2; 		}  	 Notice that the store to '*p_1' should be preserved, if we 	 were to check the virtual definitions in that store, we would 	 not mark it needed.  This is because 'x' is not a global 	 variable.  	 Therefore, we check the base address of the LHS.  If the 	 address is a pointer, we check if its name tag or symbol tag is 	 a global variable.  Otherwise, we check if the base variable 	 is a global.  */
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REFERENCE_CLASS_P
argument_list|(
name|lhs
argument_list|)
condition|)
name|lhs
operator|=
name|get_base_address
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* If LHS is NULL, it means that we couldn't get the base 	     address of the reference.  In which case, we should not 	     move this store.  */
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* If the store is to a global symbol, we need to keep it.  */
if|if
condition|(
name|is_global_var
argument_list|(
name|lhs
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|INDIRECT_REF_P
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|tree
name|ptr
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|tree
name|nmt
init|=
operator|(
name|pi
operator|)
condition|?
name|pi
operator|->
name|name_mem_tag
else|:
name|NULL_TREE
decl_stmt|;
name|tree
name|smt
init|=
name|var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|->
name|symbol_mem_tag
decl_stmt|;
comment|/* If either the name tag or the symbol tag for PTR is a 	     global variable, then the store is necessary.  */
if|if
condition|(
operator|(
name|nmt
operator|&&
name|is_global_var
argument_list|(
name|nmt
argument_list|)
operator|)
operator|||
operator|(
name|smt
operator|&&
name|is_global_var
argument_list|(
name|smt
argument_list|)
operator|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Find the nearest common dominator of all of the immediate uses in IMM.  */
end_comment

begin_function
specifier|static
name|basic_block
name|nearest_common_dominator_of_uses
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|bitmap
name|blocks
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|basic_block
name|commondom
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|ssa_op_iter
name|op_iter
decl_stmt|;
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|bitmap_clear
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|var
argument_list|,
argument|stmt
argument_list|,
argument|op_iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
block|{
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|imm_iter
argument_list|,
argument|var
argument_list|)
block|{
name|tree
name|usestmt
init|=
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|basic_block
name|useblock
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|usestmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|int
name|idx
init|=
name|PHI_ARG_INDEX_FROM_USE
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|useblock
operator|=
name|PHI_ARG_EDGE
argument_list|(
name|usestmt
argument_list|,
name|idx
argument_list|)
operator|->
name|src
expr_stmt|;
block|}
else|else
block|{
name|useblock
operator|=
name|bb_for_stmt
argument_list|(
name|usestmt
argument_list|)
expr_stmt|;
block|}
comment|/* Short circuit. Nothing dominates the entry block.  */
if|if
condition|(
name|useblock
operator|==
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bitmap_set_bit
argument_list|(
name|blocks
argument_list|,
name|useblock
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|commondom
operator|=
name|BASIC_BLOCK
argument_list|(
name|bitmap_first_set_bit
argument_list|(
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
name|commondom
operator|=
name|nearest_common_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|commondom
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
return|return
name|commondom
return|;
block|}
end_function

begin_comment
comment|/* Given a statement (STMT) and the basic block it is currently in (FROMBB),     determine the location to sink the statement to, if any.    Return the basic block to sink it to, or NULL if we should not sink    it.  */
end_comment

begin_function
specifier|static
name|tree
name|statement_sink_location
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|basic_block
name|frombb
parameter_list|)
block|{
name|tree
name|use
decl_stmt|,
name|def
decl_stmt|;
name|use_operand_p
name|one_use
init|=
name|NULL_USE_OPERAND_P
decl_stmt|;
name|basic_block
name|sinkbb
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|def_operand_p
name|def_p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
block|{
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|one_use
argument_list|,
argument|imm_iter
argument_list|,
argument|def
argument_list|)
block|{
break|break;
block|}
if|if
condition|(
name|one_use
operator|!=
name|NULL_USE_OPERAND_P
condition|)
break|break;
block|}
comment|/* Return if there are no immediate uses of this stmt.  */
if|if
condition|(
name|one_use
operator|==
name|NULL_USE_OPERAND_P
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|NULL
return|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* There are a few classes of things we can't or don't move, some because we      don't have code to handle it, some because it's not profitable and some      because it's not legal.          We can't sink things that may be global stores, at least not without      calculating a lot more information, because we may cause it to no longer      be seen by an external routine that needs it depending on where it gets      moved to.               We don't want to sink loads from memory.       We can't sink statements that end basic blocks without splitting the      incoming edge for the sink location to place it there.       We can't sink statements that have volatile operands.         We don't want to sink dead code, so anything with 0 immediate uses is not      sunk.      */
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|rhs
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|EXC_PTR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|FILTER_EXPR
operator|||
name|is_hidden_global_store
argument_list|(
name|stmt
argument_list|)
operator|||
name|ann
operator|->
name|has_volatile_ops
operator|||
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VUSE
argument_list|)
condition|)
return|return
name|NULL
return|;
name|FOR_EACH_SSA_DEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
block|{
name|tree
name|def
init|=
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_global_var
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|def
argument_list|)
argument_list|)
operator|||
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|def
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_USES
argument_list|)
block|{
name|tree
name|use
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|use
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
comment|/* If all the immediate uses are not in the same place, find the nearest      common dominator of all the immediate uses.  For PHI nodes, we have to      find the nearest common dominator of all of the predecessor blocks, since      that is where insertion would have to take place.  */
if|if
condition|(
operator|!
name|all_immediate_uses_same_place
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|basic_block
name|commondom
init|=
name|nearest_common_dominator_of_uses
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|commondom
operator|==
name|frombb
condition|)
return|return
name|NULL
return|;
comment|/* Our common dominator has to be dominated by frombb in order to be a 	 trivially safe place to put this statement, since it has multiple 	 uses.  */
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|commondom
argument_list|,
name|frombb
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* It doesn't make sense to move to a dominator that post-dominates 	 frombb, because it means we've just moved it into a path that always 	 executes if frombb executes, instead of reducing the number of 	 executions .  */
if|if
condition|(
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|frombb
argument_list|,
name|commondom
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Not moving store, common dominator post-dominates from block.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|commondom
operator|==
name|frombb
operator|||
name|commondom
operator|->
name|loop_depth
operator|>
name|frombb
operator|->
name|loop_depth
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Common dominator of all uses is %d\n"
argument_list|,
name|commondom
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|first_stmt
argument_list|(
name|commondom
argument_list|)
return|;
block|}
name|use
operator|=
name|USE_STMT
argument_list|(
name|one_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use
argument_list|)
operator|!=
name|PHI_NODE
condition|)
block|{
name|sinkbb
operator|=
name|bb_for_stmt
argument_list|(
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|sinkbb
operator|==
name|frombb
operator|||
name|sinkbb
operator|->
name|loop_depth
operator|>
name|frombb
operator|->
name|loop_depth
operator|||
name|sinkbb
operator|->
name|loop_father
operator|!=
name|frombb
operator|->
name|loop_father
condition|)
return|return
name|NULL
return|;
return|return
name|use
return|;
block|}
comment|/* Note that at this point, all uses must be in the same statement, so it      doesn't matter which def op we choose, pick the first one.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
break|break;
name|sinkbb
operator|=
name|find_bb_for_arg
argument_list|(
name|use
argument_list|,
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sinkbb
condition|)
return|return
name|NULL
return|;
comment|/* This will happen when you have      a_3 = PHI<a_13, a_26>              a_26 = V_MAY_DEF<a_3>        If the use is a phi, and is in the same bb as the def,       we can't sink it.  */
if|if
condition|(
name|bb_for_stmt
argument_list|(
name|use
argument_list|)
operator|==
name|frombb
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sinkbb
operator|==
name|frombb
operator|||
name|sinkbb
operator|->
name|loop_depth
operator|>
name|frombb
operator|->
name|loop_depth
operator|||
name|sinkbb
operator|->
name|loop_father
operator|!=
name|frombb
operator|->
name|loop_father
condition|)
return|return
name|NULL
return|;
return|return
name|first_stmt
argument_list|(
name|sinkbb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform code sinking on BB */
end_comment

begin_function
specifier|static
name|void
name|sink_code_in_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|basic_block
name|son
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* If this block doesn't dominate anything, there can't be any place to sink      the statements to.  */
if|if
condition|(
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|earlyout
goto|;
comment|/* We can't move things across abnormal edges, so don't try.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
goto|goto
name|earlyout
goto|;
for|for
control|(
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|tobsi
decl_stmt|;
name|tree
name|sinkstmt
decl_stmt|;
name|sinkstmt
operator|=
name|statement_sink_location
argument_list|(
name|stmt
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sinkstmt
condition|)
block|{
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Sinking "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" from bb %d to bb %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb_for_stmt
argument_list|(
name|sinkstmt
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|tobsi
operator|=
name|bsi_for_stmt
argument_list|(
name|sinkstmt
argument_list|)
expr_stmt|;
comment|/* Find the first non-label.  */
while|while
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|tobsi
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|tobsi
argument_list|)
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
name|bsi_next
argument_list|(
operator|&
name|tobsi
argument_list|)
expr_stmt|;
comment|/* If this is the end of the basic block, we need to insert at the end          of the basic block.  */
if|if
condition|(
name|bsi_end_p
argument_list|(
name|tobsi
argument_list|)
condition|)
name|bsi_move_to_bb_end
argument_list|(
operator|&
name|bsi
argument_list|,
name|bb_for_stmt
argument_list|(
name|sinkstmt
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bsi_move_before
argument_list|(
operator|&
name|bsi
argument_list|,
operator|&
name|tobsi
argument_list|)
expr_stmt|;
name|sink_stats
operator|.
name|sunk
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
name|earlyout
label|:
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|bb
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
block|{
name|sink_code_in_bb
argument_list|(
name|son
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Perform code sinking.    This moves code down the flowgraph when we know it would be    profitable to do so, or it wouldn't increase the number of    executions of the statement.     IE given        a_1 = b + c;    if (<something>)    {    }    else    {      foo (&b,&c);      a_5 = b + c;    }    a_6 = PHI (a_5, a_1);    USE a_6.     we'll transform this into:     if (<something>)    {       a_1 = b + c;    }    else    {       foo (&b,&c);       a_5 = b + c;    }    a_6 = PHI (a_5, a_1);    USE a_6.     Note that this reduces the number of computations of a = b + c to 1    when we take the else edge, instead of 2. */
end_comment

begin_function
specifier|static
name|void
name|execute_sink_code
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|loops
modifier|*
name|loops
init|=
name|loop_optimizer_init
argument_list|(
name|LOOPS_NORMAL
argument_list|)
decl_stmt|;
name|connect_infinite_loops_to_exit
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sink_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sink_stats
argument_list|)
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
operator||
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|sink_code_in_bb
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Sunk statements:%d\n"
argument_list|,
name|sink_stats
operator|.
name|sunk
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|remove_fake_exit_edges
argument_list|()
expr_stmt|;
name|loop_optimizer_finalize
argument_list|(
name|loops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gate and execute functions for PRE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|do_sink
parameter_list|(
name|void
parameter_list|)
block|{
name|execute_sink_code
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_sink
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_sink
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_sink_code
init|=
block|{
literal|"sink"
block|,
comment|/* name */
name|gate_sink
block|,
comment|/* gate */
name|do_sink
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_SINK
block|,
comment|/* tv_id */
name|PROP_no_crit_edges
operator||
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_update_ssa
operator||
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

