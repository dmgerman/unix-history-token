begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Check calls to formatted I/O functions (-Wformat).    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Command line options and their associated flags.  */
end_comment

begin_comment
comment|/* Warn about format/argument anomalies in calls to formatted I/O functions    (*printf, *scanf, strftime, strfmon, etc.).  */
end_comment

begin_decl_stmt
name|int
name|warn_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about Y2K problems with strftime formats.  */
end_comment

begin_decl_stmt
name|int
name|warn_format_y2k
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about excess arguments to formats.  */
end_comment

begin_decl_stmt
name|int
name|warn_format_extra_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about non-literal format arguments.  */
end_comment

begin_decl_stmt
name|int
name|warn_format_nonliteral
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about possible security problems with calls to format functions.  */
end_comment

begin_decl_stmt
name|int
name|warn_format_security
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set format warning options according to a -Wformat=n option.  */
end_comment

begin_function
name|void
name|set_Wformat
parameter_list|(
name|setting
parameter_list|)
name|int
name|setting
decl_stmt|;
block|{
name|warn_format
operator|=
name|setting
expr_stmt|;
name|warn_format_y2k
operator|=
name|setting
expr_stmt|;
name|warn_format_extra_args
operator|=
name|setting
expr_stmt|;
if|if
condition|(
name|setting
operator|!=
literal|1
condition|)
block|{
name|warn_format_nonliteral
operator|=
name|setting
expr_stmt|;
name|warn_format_security
operator|=
name|setting
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle attributes associated with format checking.  */
end_comment

begin_comment
comment|/* This must be in the same order as format_types, with format_type_error    last.  */
end_comment

begin_enum
enum|enum
name|format_type
block|{
name|printf_format_type
block|,
name|scanf_format_type
block|,
name|strftime_format_type
block|,
name|strfmon_format_type
block|,
name|format_type_error
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
name|function_format_info
block|{
name|enum
name|format_type
name|format_type
decl_stmt|;
comment|/* type of format (printf, scanf, etc.) */
name|unsigned
name|HOST_WIDE_INT
name|format_num
decl_stmt|;
comment|/* number of format argument */
name|unsigned
name|HOST_WIDE_INT
name|first_arg_num
decl_stmt|;
comment|/* number of first arg (zero for varargs) */
block|}
name|function_format_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|bool
name|decode_format_attr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|function_format_info
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|format_type
name|decode_format_type
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle a "format" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|handle_format_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|;
name|function_format_info
name|info
decl_stmt|;
name|tree
name|argument
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|arg_num
decl_stmt|;
if|if
condition|(
operator|!
name|decode_format_attr
argument_list|(
name|args
argument_list|,
operator|&
name|info
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* If a parameter list is specified, verify that the format_num      argument is actually a string, in case the format attribute      is in error.  */
name|argument
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument
condition|)
block|{
for|for
control|(
name|arg_num
operator|=
literal|1
init|;
name|argument
operator|!=
literal|0
operator|&&
name|arg_num
operator|!=
name|info
operator|.
name|format_num
condition|;
operator|++
name|arg_num
operator|,
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|argument
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_BUILT_IN
operator|)
condition|)
name|error
argument_list|(
literal|"format string arg not a string type"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
comment|/* Verify that first_arg_num points to the last arg, 	     the ...  */
while|while
condition|(
name|argument
condition|)
name|arg_num
operator|++
operator|,
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_num
operator|!=
name|info
operator|.
name|first_arg_num
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_BUILT_IN
operator|)
condition|)
name|error
argument_list|(
literal|"args to be formatted is not '...'"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
block|}
if|if
condition|(
name|info
operator|.
name|format_type
operator|==
name|strftime_format_type
operator|&&
name|info
operator|.
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"strftime formats cannot format arguments"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "format_arg" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|handle_format_arg_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|format_num_expr
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|format_num
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|arg_num
decl_stmt|;
name|tree
name|argument
decl_stmt|;
comment|/* Strip any conversions from the first arg number and verify it      is a constant.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|format_num_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|format_num_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|format_num_expr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"format string has invalid operand number"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|format_num
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|format_num_expr
argument_list|)
expr_stmt|;
comment|/* If a parameter list is specified, verify that the format_num      argument is actually a string, in case the format attribute      is in error.  */
name|argument
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument
condition|)
block|{
for|for
control|(
name|arg_num
operator|=
literal|1
init|;
name|argument
operator|!=
literal|0
operator|&&
name|arg_num
operator|!=
name|format_num
condition|;
operator|++
name|arg_num
operator|,
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|argument
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_BUILT_IN
operator|)
condition|)
name|error
argument_list|(
literal|"format string arg not a string type"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_BUILT_IN
operator|)
condition|)
name|error
argument_list|(
literal|"function does not return string type"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Decode the arguments to a "format" attribute into a function_format_info    structure.  It is already known that the list is of the right length.    If VALIDATED_P is true, then these attributes have already been validated    and this function will abort if they are erroneous; if false, it    will give an error message.  Returns true if the attributes are    successfully decoded, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|decode_format_attr
parameter_list|(
name|args
parameter_list|,
name|info
parameter_list|,
name|validated_p
parameter_list|)
name|tree
name|args
decl_stmt|;
name|function_format_info
modifier|*
name|info
decl_stmt|;
name|int
name|validated_p
decl_stmt|;
block|{
name|tree
name|format_type_id
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|tree
name|format_num_expr
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|first_arg_num_expr
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_type_id
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|validated_p
condition|)
name|abort
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"unrecognized format specifier"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|format_type_id
argument_list|)
decl_stmt|;
name|info
operator|->
name|format_type
operator|=
name|decode_format_type
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|format_type
operator|==
name|format_type_error
condition|)
block|{
if|if
condition|(
name|validated_p
condition|)
name|abort
argument_list|()
expr_stmt|;
name|warning
argument_list|(
literal|"`%s' is an unrecognized format function type"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Strip any conversions from the string index and first arg number      and verify they are constants.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|format_num_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|format_num_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|first_arg_num_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|first_arg_num_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|format_num_expr
argument_list|)
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|validated_p
condition|)
name|abort
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"format string has invalid operand number"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|info
operator|->
name|format_num
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|format_num_expr
argument_list|)
expr_stmt|;
name|info
operator|->
name|first_arg_num
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|first_arg_num_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
operator|&&
name|info
operator|->
name|first_arg_num
operator|<=
name|info
operator|->
name|format_num
condition|)
block|{
if|if
condition|(
name|validated_p
condition|)
name|abort
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"format string arg follows the args to be formatted"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check a call to a format function against a parameter list.  */
end_comment

begin_comment
comment|/* The meaningfully distinct length modifiers for format checking recognised    by GCC.  */
end_comment

begin_enum
enum|enum
name|format_lengths
block|{
name|FMT_LEN_none
block|,
name|FMT_LEN_hh
block|,
name|FMT_LEN_h
block|,
name|FMT_LEN_l
block|,
name|FMT_LEN_ll
block|,
name|FMT_LEN_L
block|,
name|FMT_LEN_z
block|,
name|FMT_LEN_t
block|,
name|FMT_LEN_j
block|,
name|FMT_LEN_MAX
block|}
enum|;
end_enum

begin_comment
comment|/* The standard versions in which various format features appeared.  */
end_comment

begin_enum
enum|enum
name|format_std_version
block|{
name|STD_C89
block|,
name|STD_C94
block|,
name|STD_C9L
block|,
comment|/* C99, but treat as C89 if -Wno-long-long.  */
name|STD_C99
block|,
name|STD_EXT
block|}
enum|;
end_enum

begin_comment
comment|/* The C standard version C++ is treated as equivalent to    or inheriting from, for the purpose of format features supported.  */
end_comment

begin_define
define|#
directive|define
name|CPLUSPLUS_STD_VER
value|STD_C94
end_define

begin_comment
comment|/* The C standard version we are checking formats against when pedantic.  */
end_comment

begin_define
define|#
directive|define
name|C_STD_VER
value|((int)(c_language == clk_cplusplus	  \ 				 ? CPLUSPLUS_STD_VER			  \ 				 : (flag_isoc99				  \ 				    ? STD_C99				  \ 				    : (flag_isoc94 ? STD_C94 : STD_C89))))
end_define

begin_comment
comment|/* The name to give to the standard version we are warning about when    pedantic.  FEATURE_VER is the version in which the feature warned out    appeared, which is higher than C_STD_VER.  */
end_comment

begin_define
define|#
directive|define
name|C_STD_NAME
parameter_list|(
name|FEATURE_VER
parameter_list|)
value|(c_language == clk_cplusplus	\ 				 ? "ISO C++"			\ 				 : ((FEATURE_VER) == STD_EXT	\ 				    ? "ISO C"			\ 				    : "ISO C89"))
end_define

begin_comment
comment|/* Adjust a C standard version, which may be STD_C9L, to account for    -Wno-long-long.  Returns other standard versions unchanged.  */
end_comment

begin_define
define|#
directive|define
name|ADJ_STD
parameter_list|(
name|VER
parameter_list|)
value|((int)((VER) == STD_C9L			      \ 				       ? (warn_long_long ? STD_C99 : STD_C89) \ 				       : (VER)))
end_define

begin_comment
comment|/* Flags that may apply to a particular kind of format checked by GCC.  */
end_comment

begin_enum
enum|enum
block|{
comment|/* This format converts arguments of types determined by the      format string.  */
name|FMT_FLAG_ARG_CONVERT
init|=
literal|1
block|,
comment|/* The scanf allocation 'a' kludge applies to this format kind.  */
name|FMT_FLAG_SCANF_A_KLUDGE
init|=
literal|2
block|,
comment|/* A % during parsing a specifier is allowed to be a modified % rather      that indicating the format is broken and we are out-of-sync.  */
name|FMT_FLAG_FANCY_PERCENT_OK
init|=
literal|4
block|,
comment|/* With $ operand numbers, it is OK to reference the same argument more      than once.  */
name|FMT_FLAG_DOLLAR_MULTIPLE
init|=
literal|8
block|,
comment|/* This format type uses $ operand numbers (strfmon doesn't).  */
name|FMT_FLAG_USE_DOLLAR
init|=
literal|16
block|,
comment|/* Zero width is bad in this type of format (scanf).  */
name|FMT_FLAG_ZERO_WIDTH_BAD
init|=
literal|32
block|,
comment|/* Empty precision specification is OK in this type of format (printf).  */
name|FMT_FLAG_EMPTY_PREC_OK
init|=
literal|64
block|,
comment|/* Gaps are allowed in the arguments with $ operand numbers if all      arguments are pointers (scanf).  */
name|FMT_FLAG_DOLLAR_GAP_POINTER_OK
init|=
literal|128
comment|/* Not included here: details of whether width or precision may occur      (controlled by width_char and precision_char); details of whether      '*' can be used for these (width_type and precision_type); details      of whether length modifiers can occur (length_char_specs).  */
block|}
enum|;
end_enum

begin_comment
comment|/* Structure describing a length modifier supported in format checking, and    possibly a doubled version such as "hh".  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Name of the single-character length modifier.  */
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Index into a format_char_info.types array.  */
specifier|const
name|enum
name|format_lengths
name|index
decl_stmt|;
comment|/* Standard version this length appears in.  */
specifier|const
name|enum
name|format_std_version
name|std
decl_stmt|;
comment|/* Same, if the modifier can be repeated, or NULL if it can't.  */
specifier|const
name|char
modifier|*
specifier|const
name|double_name
decl_stmt|;
specifier|const
name|enum
name|format_lengths
name|double_index
decl_stmt|;
specifier|const
name|enum
name|format_std_version
name|double_std
decl_stmt|;
block|}
name|format_length_info
typedef|;
end_typedef

begin_comment
comment|/* Structure describing the combination of a conversion specifier    (or a set of specifiers which act identically) and a length modifier.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The standard version this combination of length and type appeared in.      This is only relevant if greater than those for length and type      individually; otherwise it is ignored.  */
name|enum
name|format_std_version
name|std
decl_stmt|;
comment|/* The name to use for the type, if different from that generated internally      (e.g., "signed size_t").  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The type itself.  */
name|tree
modifier|*
name|type
decl_stmt|;
block|}
name|format_type_detail
typedef|;
end_typedef

begin_comment
comment|/* Macros to fill out tables of these.  */
end_comment

begin_define
define|#
directive|define
name|BADLEN
value|{ 0, NULL, NULL }
end_define

begin_define
define|#
directive|define
name|NOLENGTHS
value|{ BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }
end_define

begin_comment
comment|/* Structure describing a format conversion specifier (or a set of specifiers    which act identically), and the length modifiers used with it.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|format_chars
decl_stmt|;
specifier|const
name|int
name|pointer_count
decl_stmt|;
specifier|const
name|enum
name|format_std_version
name|std
decl_stmt|;
comment|/* Types accepted for each length modifier.  */
specifier|const
name|format_type_detail
name|types
index|[
name|FMT_LEN_MAX
index|]
decl_stmt|;
comment|/* List of other modifier characters allowed with these specifiers.      This lists flags, and additionally "w" for width, "p" for precision      (right precision, for strfmon), "#" for left precision (strfmon),      "a" for scanf "a" allocation extension (not applicable in C99 mode),      "*" for scanf suppression, and "E" and "O" for those strftime      modifiers.  */
specifier|const
name|char
modifier|*
specifier|const
name|flag_chars
decl_stmt|;
comment|/* List of additional flags describing these conversion specifiers.      "c" for generic character pointers being allowed, "2" for strftime      two digit year formats, "3" for strftime formats giving two digit      years in some locales, "4" for "2" which becomes "3" with an "E" modifier,      "o" if use of strftime "O" is a GNU extension beyond C99,      "W" if the argument is a pointer which is dereferenced and written into,      "R" if the argument is a pointer which is dereferenced and read from,      "i" for printf integer formats where the '0' flag is ignored with      precision, and "[" for the starting character of a scanf scanset.  */
specifier|const
name|char
modifier|*
specifier|const
name|flags2
decl_stmt|;
block|}
name|format_char_info
typedef|;
end_typedef

begin_comment
comment|/* Structure describing a flag accepted by some kind of format.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The flag character in question (0 for end of array).  */
specifier|const
name|int
name|flag_char
decl_stmt|;
comment|/* Zero if this entry describes the flag character in general, or a      non-zero character that may be found in flags2 if it describes the      flag when used with certain formats only.  If the latter, only      the first such entry found that applies to the current conversion      specifier is used; the values of `name' and `long_name' it supplies      will be used, if non-NULL and the standard version is higher than      the unpredicated one, for any pedantic warning.  For example, 'o'      for strftime formats (meaning 'O' is an extension over C99).  */
specifier|const
name|int
name|predicate
decl_stmt|;
comment|/* Nonzero if the next character after this flag in the format should      be skipped ('=' in strfmon), zero otherwise.  */
specifier|const
name|int
name|skip_next_char
decl_stmt|;
comment|/* The name to use for this flag in diagnostic messages.  For example,      N_("`0' flag"), N_("field width").  */
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Long name for this flag in diagnostic messages; currently only used for      "ISO C does not support ...".  For example, N_("the `I' printf flag").  */
specifier|const
name|char
modifier|*
specifier|const
name|long_name
decl_stmt|;
comment|/* The standard version in which it appeared.  */
specifier|const
name|enum
name|format_std_version
name|std
decl_stmt|;
block|}
name|format_flag_spec
typedef|;
end_typedef

begin_comment
comment|/* Structure describing a combination of flags that is bad for some kind    of format.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The first flag character in question (0 for end of array).  */
specifier|const
name|int
name|flag_char1
decl_stmt|;
comment|/* The second flag character.  */
specifier|const
name|int
name|flag_char2
decl_stmt|;
comment|/* Non-zero if the message should say that the first flag is ignored with      the second, zero if the combination should simply be objected to.  */
specifier|const
name|int
name|ignored
decl_stmt|;
comment|/* Zero if this entry applies whenever this flag combination occurs,      a non-zero character from flags2 if it only applies in some      circumstances (e.g. 'i' for printf formats ignoring 0 with precision).  */
specifier|const
name|int
name|predicate
decl_stmt|;
block|}
name|format_flag_pair
typedef|;
end_typedef

begin_comment
comment|/* Structure describing a particular kind of format processed by GCC.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The name of this kind of format, for use in diagnostics.  Also      the name of the attribute (without preceding and following __).  */
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Specifications of the length modifiers accepted; possibly NULL.  */
specifier|const
name|format_length_info
modifier|*
specifier|const
name|length_char_specs
decl_stmt|;
comment|/* Details of the conversion specification characters accepted.  */
specifier|const
name|format_char_info
modifier|*
specifier|const
name|conversion_specs
decl_stmt|;
comment|/* String listing the flag characters that are accepted.  */
specifier|const
name|char
modifier|*
specifier|const
name|flag_chars
decl_stmt|;
comment|/* String listing modifier characters (strftime) accepted.  May be NULL.  */
specifier|const
name|char
modifier|*
specifier|const
name|modifier_chars
decl_stmt|;
comment|/* Details of the flag characters, including pseudo-flags.  */
specifier|const
name|format_flag_spec
modifier|*
specifier|const
name|flag_specs
decl_stmt|;
comment|/* Details of bad combinations of flags.  */
specifier|const
name|format_flag_pair
modifier|*
specifier|const
name|bad_flag_pairs
decl_stmt|;
comment|/* Flags applicable to this kind of format.  */
specifier|const
name|int
name|flags
decl_stmt|;
comment|/* Flag character to treat a width as, or 0 if width not used.  */
specifier|const
name|int
name|width_char
decl_stmt|;
comment|/* Flag character to treat a left precision (strfmon) as,      or 0 if left precision not used.  */
specifier|const
name|int
name|left_precision_char
decl_stmt|;
comment|/* Flag character to treat a precision (for strfmon, right precision) as,      or 0 if precision not used.  */
specifier|const
name|int
name|precision_char
decl_stmt|;
comment|/* If a flag character has the effect of suppressing the conversion of      an argument ('*' in scanf), that flag character, otherwise 0.  */
specifier|const
name|int
name|suppression_char
decl_stmt|;
comment|/* Flag character to treat a length modifier as (ignored if length      modifiers not used).  Need not be placed in flag_chars for conversion      specifiers, but is used to check for bad combinations such as length      modifier with assignment suppression in scanf.  */
specifier|const
name|int
name|length_code_char
decl_stmt|;
comment|/* Pointer to type of argument expected if '*' is used for a width,      or NULL if '*' not used for widths.  */
name|tree
modifier|*
specifier|const
name|width_type
decl_stmt|;
comment|/* Pointer to type of argument expected if '*' is used for a precision,      or NULL if '*' not used for precisions.  */
name|tree
modifier|*
specifier|const
name|precision_type
decl_stmt|;
block|}
name|format_kind_info
typedef|;
end_typedef

begin_comment
comment|/* Structure describing details of a type expected in format checking,    and the type to check against it.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|format_wanted_type
block|{
comment|/* The type wanted.  */
name|tree
name|wanted_type
decl_stmt|;
comment|/* The name of this type to use in diagnostics.  */
specifier|const
name|char
modifier|*
name|wanted_type_name
decl_stmt|;
comment|/* The level of indirection through pointers at which this type occurs.  */
name|int
name|pointer_count
decl_stmt|;
comment|/* Whether, when pointer_count is 1, to allow any character type when      pedantic, rather than just the character or void type specified.  */
name|int
name|char_lenient_flag
decl_stmt|;
comment|/* Whether the argument, dereferenced once, is written into and so the      argument must not be a pointer to a const-qualified type.  */
name|int
name|writing_in_flag
decl_stmt|;
comment|/* Whether the argument, dereferenced once, is read from and so      must not be a NULL pointer.  */
name|int
name|reading_from_flag
decl_stmt|;
comment|/* If warnings should be of the form "field precision is not type int",      the name to use (in this case "field precision"), otherwise NULL,      for "%s format, %s arg" type messages.  If (in an extension), this      is a pointer type, wanted_type_name should be set to include the      terminating '*' characters of the type name to give a correct      message.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The actual parameter to check against the wanted type.  */
name|tree
name|param
decl_stmt|;
comment|/* The argument number of that parameter.  */
name|int
name|arg_num
decl_stmt|;
comment|/* The next type to check for this format conversion, or NULL if none.  */
name|struct
name|format_wanted_type
modifier|*
name|next
decl_stmt|;
block|}
name|format_wanted_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|format_length_info
name|printf_length_specs
index|[]
init|=
block|{
block|{
literal|"h"
block|,
name|FMT_LEN_h
block|,
name|STD_C89
block|,
literal|"hh"
block|,
name|FMT_LEN_hh
block|,
name|STD_C99
block|}
block|,
block|{
literal|"l"
block|,
name|FMT_LEN_l
block|,
name|STD_C89
block|,
literal|"ll"
block|,
name|FMT_LEN_ll
block|,
name|STD_C9L
block|}
block|,
block|{
literal|"q"
block|,
name|FMT_LEN_ll
block|,
name|STD_EXT
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"L"
block|,
name|FMT_LEN_L
block|,
name|STD_C89
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"z"
block|,
name|FMT_LEN_z
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"Z"
block|,
name|FMT_LEN_z
block|,
name|STD_EXT
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"t"
block|,
name|FMT_LEN_t
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"j"
block|,
name|FMT_LEN_j
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This differs from printf_length_specs only in that "Z" is not accepted.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|format_length_info
name|scanf_length_specs
index|[]
init|=
block|{
block|{
literal|"h"
block|,
name|FMT_LEN_h
block|,
name|STD_C89
block|,
literal|"hh"
block|,
name|FMT_LEN_hh
block|,
name|STD_C99
block|}
block|,
block|{
literal|"l"
block|,
name|FMT_LEN_l
block|,
name|STD_C89
block|,
literal|"ll"
block|,
name|FMT_LEN_ll
block|,
name|STD_C9L
block|}
block|,
block|{
literal|"q"
block|,
name|FMT_LEN_ll
block|,
name|STD_EXT
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"L"
block|,
name|FMT_LEN_L
block|,
name|STD_C89
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"z"
block|,
name|FMT_LEN_z
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"t"
block|,
name|FMT_LEN_t
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"j"
block|,
name|FMT_LEN_j
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All tables for strfmon use STD_C89 everywhere, since -pedantic warnings    make no sense for a format type not part of any C standard version.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|format_length_info
name|strfmon_length_specs
index|[]
init|=
block|{
comment|/* A GNU extension.  */
block|{
literal|"L"
block|,
name|FMT_LEN_L
block|,
name|STD_C89
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|printf_flag_specs
index|[]
init|=
block|{
block|{
literal|' '
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"` ' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the ` ' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'+'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`+' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `+' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'#'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`#' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `#' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'0'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`0' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `0' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'-'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`-' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `-' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'\''
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`'' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `'' printf flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'I'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`I' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `I' printf flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"field width"
argument_list|)
block|,
name|N_
argument_list|(
literal|"field width in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'p'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"precision"
argument_list|)
block|,
name|N_
argument_list|(
literal|"precision in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'L'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"length modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"length modifier in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|printf_flag_pairs
index|[]
init|=
block|{
block|{
literal|' '
block|,
literal|'+'
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'0'
block|,
literal|'-'
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'0'
block|,
literal|'p'
block|,
literal|1
block|,
literal|'i'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|scanf_flag_specs
index|[]
init|=
block|{
block|{
literal|'*'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"assignment suppression"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the assignment suppression scanf feature"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'a'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`a' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `a' scanf flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"field width"
argument_list|)
block|,
name|N_
argument_list|(
literal|"field width in scanf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'L'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"length modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"length modifier in scanf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'\''
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`'' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `'' scanf flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'I'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`I' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `I' scanf flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|scanf_flag_pairs
index|[]
init|=
block|{
block|{
literal|'*'
block|,
literal|'L'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|strftime_flag_specs
index|[]
init|=
block|{
block|{
literal|'_'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`_' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `_' strftime flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'-'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`-' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `-' strftime flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'0'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`0' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `0' strftime flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'^'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`^' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `^' strftime flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'#'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`#' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `#' strftime flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"field width"
argument_list|)
block|,
name|N_
argument_list|(
literal|"field width in strftime format"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'E'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`E' modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `E' strftime modifier"
argument_list|)
block|,
name|STD_C99
block|}
block|,
block|{
literal|'O'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`O' modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `O' strftime modifier"
argument_list|)
block|,
name|STD_C99
block|}
block|,
block|{
literal|'O'
block|,
literal|'o'
block|,
literal|0
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"the `O' modifier"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|strftime_flag_pairs
index|[]
init|=
block|{
block|{
literal|'E'
block|,
literal|'O'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'_'
block|,
literal|'-'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'_'
block|,
literal|'0'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'-'
block|,
literal|'0'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'^'
block|,
literal|'#'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|strfmon_flag_specs
index|[]
init|=
block|{
block|{
literal|'='
block|,
literal|0
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"fill character"
argument_list|)
block|,
name|N_
argument_list|(
literal|"fill character in strfmon format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'^'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`^' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `^' strfmon flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'+'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`+' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `+' strfmon flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'('
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`(' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `(' strfmon flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'!'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`!' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `!' strfmon flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'-'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"`-' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the `-' strfmon flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"field width"
argument_list|)
block|,
name|N_
argument_list|(
literal|"field width in strfmon format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'#'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"left precision"
argument_list|)
block|,
name|N_
argument_list|(
literal|"left precision in strfmon format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'p'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"right precision"
argument_list|)
block|,
name|N_
argument_list|(
literal|"right precision in strfmon format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'L'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"length modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"length modifier in strfmon format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|strfmon_flag_pairs
index|[]
init|=
block|{
block|{
literal|'+'
block|,
literal|'('
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|T_I
value|&integer_type_node
end_define

begin_define
define|#
directive|define
name|T89_I
value|{ STD_C89, NULL, T_I }
end_define

begin_define
define|#
directive|define
name|T99_I
value|{ STD_C99, NULL, T_I }
end_define

begin_define
define|#
directive|define
name|T_L
value|&long_integer_type_node
end_define

begin_define
define|#
directive|define
name|T89_L
value|{ STD_C89, NULL, T_L }
end_define

begin_define
define|#
directive|define
name|T_LL
value|&long_long_integer_type_node
end_define

begin_define
define|#
directive|define
name|T9L_LL
value|{ STD_C9L, NULL, T_LL }
end_define

begin_define
define|#
directive|define
name|TEX_LL
value|{ STD_EXT, NULL, T_LL }
end_define

begin_define
define|#
directive|define
name|T_S
value|&short_integer_type_node
end_define

begin_define
define|#
directive|define
name|T89_S
value|{ STD_C89, NULL, T_S }
end_define

begin_define
define|#
directive|define
name|T_UI
value|&unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T89_UI
value|{ STD_C89, NULL, T_UI }
end_define

begin_define
define|#
directive|define
name|T99_UI
value|{ STD_C99, NULL, T_UI }
end_define

begin_define
define|#
directive|define
name|T_UL
value|&long_unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T89_UL
value|{ STD_C89, NULL, T_UL }
end_define

begin_define
define|#
directive|define
name|T_ULL
value|&long_long_unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T9L_ULL
value|{ STD_C9L, NULL, T_ULL }
end_define

begin_define
define|#
directive|define
name|TEX_ULL
value|{ STD_EXT, NULL, T_ULL }
end_define

begin_define
define|#
directive|define
name|T_US
value|&short_unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T89_US
value|{ STD_C89, NULL, T_US }
end_define

begin_define
define|#
directive|define
name|T_F
value|&float_type_node
end_define

begin_define
define|#
directive|define
name|T89_F
value|{ STD_C89, NULL, T_F }
end_define

begin_define
define|#
directive|define
name|T99_F
value|{ STD_C99, NULL, T_F }
end_define

begin_define
define|#
directive|define
name|T_D
value|&double_type_node
end_define

begin_define
define|#
directive|define
name|T89_D
value|{ STD_C89, NULL, T_D }
end_define

begin_define
define|#
directive|define
name|T99_D
value|{ STD_C99, NULL, T_D }
end_define

begin_define
define|#
directive|define
name|T_LD
value|&long_double_type_node
end_define

begin_define
define|#
directive|define
name|T89_LD
value|{ STD_C89, NULL, T_LD }
end_define

begin_define
define|#
directive|define
name|T99_LD
value|{ STD_C99, NULL, T_LD }
end_define

begin_define
define|#
directive|define
name|T_C
value|&char_type_node
end_define

begin_define
define|#
directive|define
name|T89_C
value|{ STD_C89, NULL, T_C }
end_define

begin_define
define|#
directive|define
name|T_SC
value|&signed_char_type_node
end_define

begin_define
define|#
directive|define
name|T99_SC
value|{ STD_C99, NULL, T_SC }
end_define

begin_define
define|#
directive|define
name|T_UC
value|&unsigned_char_type_node
end_define

begin_define
define|#
directive|define
name|T99_UC
value|{ STD_C99, NULL, T_UC }
end_define

begin_define
define|#
directive|define
name|T_V
value|&void_type_node
end_define

begin_define
define|#
directive|define
name|T89_V
value|{ STD_C89, NULL, T_V }
end_define

begin_define
define|#
directive|define
name|T_W
value|&wchar_type_node
end_define

begin_define
define|#
directive|define
name|T94_W
value|{ STD_C94, "wchar_t", T_W }
end_define

begin_define
define|#
directive|define
name|TEX_W
value|{ STD_EXT, "wchar_t", T_W }
end_define

begin_define
define|#
directive|define
name|T_WI
value|&wint_type_node
end_define

begin_define
define|#
directive|define
name|T94_WI
value|{ STD_C94, "wint_t", T_WI }
end_define

begin_define
define|#
directive|define
name|TEX_WI
value|{ STD_EXT, "wint_t", T_WI }
end_define

begin_define
define|#
directive|define
name|T_ST
value|&c_size_type_node
end_define

begin_define
define|#
directive|define
name|T99_ST
value|{ STD_C99, "size_t", T_ST }
end_define

begin_define
define|#
directive|define
name|T_SST
value|&signed_size_type_node
end_define

begin_define
define|#
directive|define
name|T99_SST
value|{ STD_C99, "signed size_t", T_SST }
end_define

begin_define
define|#
directive|define
name|T_PD
value|&ptrdiff_type_node
end_define

begin_define
define|#
directive|define
name|T99_PD
value|{ STD_C99, "ptrdiff_t", T_PD }
end_define

begin_define
define|#
directive|define
name|T_UPD
value|&unsigned_ptrdiff_type_node
end_define

begin_define
define|#
directive|define
name|T99_UPD
value|{ STD_C99, "unsigned ptrdiff_t", T_UPD }
end_define

begin_define
define|#
directive|define
name|T_IM
value|&intmax_type_node
end_define

begin_define
define|#
directive|define
name|T99_IM
value|{ STD_C99, "intmax_t", T_IM }
end_define

begin_define
define|#
directive|define
name|T_UIM
value|&uintmax_type_node
end_define

begin_define
define|#
directive|define
name|T99_UIM
value|{ STD_C99, "uintmax_t", T_UIM }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|print_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"di"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|T99_SC
block|,
name|T89_S
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|TEX_LL
block|,
name|T99_SST
block|,
name|T99_PD
block|,
name|T99_IM
block|}
block|,
literal|"-wp0 +'I"
block|,
literal|"i"
block|}
block|,
block|{
literal|"oxX"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|T99_UC
block|,
name|T89_US
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|TEX_ULL
block|,
name|T99_ST
block|,
name|T99_UPD
block|,
name|T99_UIM
block|}
block|,
literal|"-wp0#"
block|,
literal|"i"
block|}
block|,
block|{
literal|"u"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|T99_UC
block|,
name|T89_US
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|TEX_ULL
block|,
name|T99_ST
block|,
name|T99_UPD
block|,
name|T99_UIM
block|}
block|,
literal|"-wp0'I"
block|,
literal|"i"
block|}
block|,
block|{
literal|"fgG"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_D
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T99_D
block|,
name|BADLEN
block|,
name|T89_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp0 +#'"
block|,
literal|""
block|}
block|,
block|{
literal|"eE"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_D
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T99_D
block|,
name|BADLEN
block|,
name|T89_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp0 +#"
block|,
literal|""
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T94_WI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-w"
block|,
literal|""
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T94_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp"
block|,
literal|"cR"
block|}
block|,
block|{
literal|"p"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-w"
block|,
literal|"c"
block|}
block|,
block|{
literal|"n"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|T99_SC
block|,
name|T89_S
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|BADLEN
block|,
name|T99_SST
block|,
name|T99_PD
block|,
name|T99_IM
block|}
block|,
literal|""
block|,
literal|"W"
block|}
block|,
comment|/* C99 conversion specifiers.  */
block|{
literal|"F"
block|,
literal|0
block|,
name|STD_C99
block|,
block|{
name|T99_D
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T99_D
block|,
name|BADLEN
block|,
name|T99_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp0 +#'"
block|,
literal|""
block|}
block|,
block|{
literal|"aA"
block|,
literal|0
block|,
name|STD_C99
block|,
block|{
name|T99_D
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T99_D
block|,
name|BADLEN
block|,
name|T99_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp0 +#"
block|,
literal|""
block|}
block|,
comment|/* X/Open conversion specifiers.  */
block|{
literal|"C"
block|,
literal|0
block|,
name|STD_EXT
block|,
block|{
name|TEX_WI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-w"
block|,
literal|""
block|}
block|,
block|{
literal|"S"
block|,
literal|1
block|,
name|STD_EXT
block|,
block|{
name|TEX_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp"
block|,
literal|"R"
block|}
block|,
comment|/* GNU conversion specifiers.  */
block|{
literal|"m"
block|,
literal|0
block|,
name|STD_EXT
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp"
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|scan_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"di"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|T99_SC
block|,
name|T89_S
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|TEX_LL
block|,
name|T99_SST
block|,
name|T99_PD
block|,
name|T99_IM
block|}
block|,
literal|"*w'I"
block|,
literal|"W"
block|}
block|,
block|{
literal|"u"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|T99_UC
block|,
name|T89_US
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|TEX_ULL
block|,
name|T99_ST
block|,
name|T99_UPD
block|,
name|T99_UIM
block|}
block|,
literal|"*w'I"
block|,
literal|"W"
block|}
block|,
block|{
literal|"oxX"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|T99_UC
block|,
name|T89_US
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|TEX_ULL
block|,
name|T99_ST
block|,
name|T99_UPD
block|,
name|T99_UIM
block|}
block|,
literal|"*w"
block|,
literal|"W"
block|}
block|,
block|{
literal|"efgEG"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_F
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_D
block|,
name|BADLEN
block|,
name|T89_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w'"
block|,
literal|"W"
block|}
block|,
block|{
literal|"c"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T94_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w"
block|,
literal|"cW"
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T94_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*aw"
block|,
literal|"cW"
block|}
block|,
block|{
literal|"["
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T94_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*aw"
block|,
literal|"cW["
block|}
block|,
block|{
literal|"p"
block|,
literal|2
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w"
block|,
literal|"W"
block|}
block|,
block|{
literal|"n"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|T99_SC
block|,
name|T89_S
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|BADLEN
block|,
name|T99_SST
block|,
name|T99_PD
block|,
name|T99_IM
block|}
block|,
literal|""
block|,
literal|"W"
block|}
block|,
comment|/* C99 conversion specifiers.  */
block|{
literal|"FaA"
block|,
literal|1
block|,
name|STD_C99
block|,
block|{
name|T99_F
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T99_D
block|,
name|BADLEN
block|,
name|T99_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w'"
block|,
literal|"W"
block|}
block|,
comment|/* X/Open conversion specifiers.  */
block|{
literal|"C"
block|,
literal|1
block|,
name|STD_EXT
block|,
block|{
name|TEX_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w"
block|,
literal|"W"
block|}
block|,
block|{
literal|"S"
block|,
literal|1
block|,
name|STD_EXT
block|,
block|{
name|TEX_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*aw"
block|,
literal|"W"
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|time_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"ABZab"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"^#"
block|,
literal|""
block|}
block|,
block|{
literal|"cx"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"E"
block|,
literal|"3"
block|}
block|,
block|{
literal|"HIMSUWdmw"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"-_0Ow"
block|,
literal|""
block|}
block|,
block|{
literal|"j"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"-_0Ow"
block|,
literal|"o"
block|}
block|,
block|{
literal|"p"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"#"
block|,
literal|""
block|}
block|,
block|{
literal|"X"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"E"
block|,
literal|""
block|}
block|,
block|{
literal|"y"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"EO-_0w"
block|,
literal|"4"
block|}
block|,
block|{
literal|"Y"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"-_0EOw"
block|,
literal|"o"
block|}
block|,
block|{
literal|"%"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* C99 conversion specifiers.  */
block|{
literal|"C"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"-_0EOw"
block|,
literal|"o"
block|}
block|,
block|{
literal|"D"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|""
block|,
literal|"2"
block|}
block|,
block|{
literal|"eVu"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"-_0Ow"
block|,
literal|""
block|}
block|,
block|{
literal|"FRTnrt"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|"g"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"O-_0w"
block|,
literal|"2o"
block|}
block|,
block|{
literal|"G"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"-_0Ow"
block|,
literal|"o"
block|}
block|,
block|{
literal|"h"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"^#"
block|,
literal|""
block|}
block|,
block|{
literal|"z"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"O"
block|,
literal|"o"
block|}
block|,
comment|/* GNU conversion specifiers.  */
block|{
literal|"kls"
block|,
literal|0
block|,
name|STD_EXT
block|,
name|NOLENGTHS
block|,
literal|"-_0Ow"
block|,
literal|""
block|}
block|,
block|{
literal|"P"
block|,
literal|0
block|,
name|STD_EXT
block|,
name|NOLENGTHS
block|,
literal|""
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|monetary_char_table
index|[]
init|=
block|{
block|{
literal|"in"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_D
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"=^+(!-w#p"
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This must be in the same order as enum format_type.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|format_kind_info
name|format_types
index|[]
init|=
block|{
block|{
literal|"printf"
block|,
name|printf_length_specs
block|,
name|print_char_table
block|,
literal|" +#0-'I"
block|,
name|NULL
block|,
name|printf_flag_specs
block|,
name|printf_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
operator||
name|FMT_FLAG_DOLLAR_MULTIPLE
operator||
name|FMT_FLAG_USE_DOLLAR
operator||
name|FMT_FLAG_EMPTY_PREC_OK
block|,
literal|'w'
block|,
literal|0
block|,
literal|'p'
block|,
literal|0
block|,
literal|'L'
block|,
operator|&
name|integer_type_node
block|,
operator|&
name|integer_type_node
block|}
block|,
block|{
literal|"scanf"
block|,
name|scanf_length_specs
block|,
name|scan_char_table
block|,
literal|"*'I"
block|,
name|NULL
block|,
name|scanf_flag_specs
block|,
name|scanf_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
operator||
name|FMT_FLAG_SCANF_A_KLUDGE
operator||
name|FMT_FLAG_USE_DOLLAR
operator||
name|FMT_FLAG_ZERO_WIDTH_BAD
operator||
name|FMT_FLAG_DOLLAR_GAP_POINTER_OK
block|,
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
literal|'*'
block|,
literal|'L'
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"strftime"
block|,
name|NULL
block|,
name|time_char_table
block|,
literal|"_-0^#"
block|,
literal|"EO"
block|,
name|strftime_flag_specs
block|,
name|strftime_flag_pairs
block|,
name|FMT_FLAG_FANCY_PERCENT_OK
block|,
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"strfmon"
block|,
name|strfmon_length_specs
block|,
name|monetary_char_table
block|,
literal|"=^+(!-"
block|,
name|NULL
block|,
name|strfmon_flag_specs
block|,
name|strfmon_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
block|,
literal|'w'
block|,
literal|'#'
block|,
literal|'p'
block|,
literal|0
block|,
literal|'L'
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure detailing the results of checking a format function call    where the format expression may be a conditional expression with    many leaves resulting from nested conditional expressions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Number of leaves of the format argument that could not be checked      as they were not string literals.  */
name|int
name|number_non_literal
decl_stmt|;
comment|/* Number of leaves of the format argument that were null pointers or      string literals, but had extra format arguments.  */
name|int
name|number_extra_args
decl_stmt|;
comment|/* Number of leaves of the format argument that were null pointers or      string literals, but had extra format arguments and used $ operand      numbers.  */
name|int
name|number_dollar_extra_args
decl_stmt|;
comment|/* Number of leaves of the format argument that were wide string      literals.  */
name|int
name|number_wide
decl_stmt|;
comment|/* Number of leaves of the format argument that were empty strings.  */
name|int
name|number_empty
decl_stmt|;
comment|/* Number of leaves of the format argument that were unterminated      strings.  */
name|int
name|number_unterminated
decl_stmt|;
comment|/* Number of leaves of the format argument that were not counted above.  */
name|int
name|number_other
decl_stmt|;
block|}
name|format_check_results
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|void
name|check_format_info
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|function_format_info
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_format_info_recurse
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|format_check_results
operator|*
operator|,
name|function_format_info
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_format_info_main
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|format_check_results
operator|*
operator|,
name|function_format_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|tree
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|status_warning
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_dollar_format_checking
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_read_dollar_number
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
specifier|const
name|format_kind_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_dollar_format_checking
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|format_check_results
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
modifier|*
name|get_flag_spec
name|PARAMS
argument_list|(
operator|(
specifier|const
name|format_flag_spec
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_format_types
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|format_wanted_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Decode a format type from a string, returning the type, or    format_type_error if not valid, in which case the caller should print an    error message.  */
end_comment

begin_function
specifier|static
name|enum
name|format_type
name|decode_format_type
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|slen
decl_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|format_type_error
condition|;
name|i
operator|++
control|)
block|{
name|int
name|alen
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|format_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
break|break;
name|alen
operator|=
name|strlen
argument_list|(
name|format_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|==
name|alen
operator|+
literal|4
operator|&&
name|s
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|s
index|[
name|slen
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|s
index|[
name|slen
operator|-
literal|2
index|]
operator|==
literal|'_'
operator|&&
operator|!
name|strncmp
argument_list|(
name|s
operator|+
literal|2
argument_list|,
name|format_types
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|alen
argument_list|)
condition|)
break|break;
block|}
return|return
operator|(
operator|(
expr|enum
name|format_type
operator|)
name|i
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check the argument list of a call to printf, scanf, etc.    ATTRS are the attributes on the function type.    PARAMS is the list of argument values.  Also, if -Wmissing-format-attribute,    warn for calls to vprintf or vscanf in functions with no such format    attribute themselves.  */
end_comment

begin_function
name|void
name|check_function_format
parameter_list|(
name|status
parameter_list|,
name|attrs
parameter_list|,
name|params
parameter_list|)
name|int
modifier|*
name|status
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
name|tree
name|params
decl_stmt|;
block|{
name|tree
name|a
decl_stmt|;
comment|/* See if this function has any format attributes.  */
for|for
control|(
name|a
operator|=
name|attrs
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"format"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Yup; check it.  */
name|function_format_info
name|info
decl_stmt|;
name|decode_format_attr
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
operator|&
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|check_format_info
argument_list|(
name|status
argument_list|,
operator|&
name|info
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_missing_format_attribute
operator|&&
name|info
operator|.
name|first_arg_num
operator|==
literal|0
operator|&&
operator|(
name|format_types
index|[
name|info
operator|.
name|format_type
index|]
operator|.
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_ARG_CONVERT
operator|)
condition|)
block|{
name|tree
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
init|;
name|c
condition|;
name|c
operator|=
name|TREE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"format"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|c
argument_list|)
argument_list|)
operator|&&
operator|(
name|decode_format_type
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|info
operator|.
name|format_type
operator|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Check if the current function has a parameter to which 		     the format attribute could be attached; if not, it 		     can't be a candidate for a format attribute, despite 		     the vprintf-like or vscanf-like call.  */
name|tree
name|args
decl_stmt|;
for|for
control|(
name|args
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|args
operator|!=
literal|0
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|args
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"function might be possible candidate for `%s' format attribute"
argument_list|,
name|format_types
index|[
name|info
operator|.
name|format_type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function replaces `warning' inside the printf format checking    functions.  If the `status' parameter is non-NULL, then it is    dereferenced and set to 1 whenever a warning is caught.  Otherwise    it warns as usual by replicating the innards of the warning    function from diagnostic.c.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|status_warning
name|VPARAMS
argument_list|(
operator|(
name|int
operator|*
name|status
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* This duplicates the warning function behavior.  */
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
comment|/* warn = */
literal|1
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
block|}
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Variables used by the checking of $ operand number formats.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dollar_arguments_used
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dollar_arguments_pointer_p
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dollar_arguments_alloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dollar_arguments_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dollar_first_arg_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dollar_max_arg_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dollar_format_warned
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the checking for a format string that may contain $    parameter number specifications; we will need to keep track of whether    each parameter has been used.  FIRST_ARG_NUM is the number of the first    argument that is a parameter to the format, or 0 for a vprintf-style    function; PARAMS is the list of arguments starting at this argument.  */
end_comment

begin_function
specifier|static
name|void
name|init_dollar_format_checking
parameter_list|(
name|first_arg_num
parameter_list|,
name|params
parameter_list|)
name|int
name|first_arg_num
decl_stmt|;
name|tree
name|params
decl_stmt|;
block|{
name|tree
name|oparams
init|=
name|params
decl_stmt|;
name|dollar_first_arg_num
operator|=
name|first_arg_num
expr_stmt|;
name|dollar_arguments_count
operator|=
literal|0
expr_stmt|;
name|dollar_max_arg_used
operator|=
literal|0
expr_stmt|;
name|dollar_format_warned
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first_arg_num
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|params
condition|)
block|{
name|dollar_arguments_count
operator|++
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dollar_arguments_alloc
operator|<
name|dollar_arguments_count
condition|)
block|{
if|if
condition|(
name|dollar_arguments_used
condition|)
name|free
argument_list|(
name|dollar_arguments_used
argument_list|)
expr_stmt|;
if|if
condition|(
name|dollar_arguments_pointer_p
condition|)
name|free
argument_list|(
name|dollar_arguments_pointer_p
argument_list|)
expr_stmt|;
name|dollar_arguments_alloc
operator|=
name|dollar_arguments_count
expr_stmt|;
name|dollar_arguments_used
operator|=
name|xmalloc
argument_list|(
name|dollar_arguments_alloc
argument_list|)
expr_stmt|;
name|dollar_arguments_pointer_p
operator|=
name|xmalloc
argument_list|(
name|dollar_arguments_alloc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dollar_arguments_alloc
condition|)
block|{
name|memset
argument_list|(
name|dollar_arguments_used
argument_list|,
literal|0
argument_list|,
name|dollar_arguments_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_arg_num
operator|>
literal|0
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|params
operator|=
name|oparams
expr_stmt|;
while|while
condition|(
name|params
condition|)
block|{
name|dollar_arguments_pointer_p
index|[
name|i
index|]
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Look for a decimal number followed by a $ in *FORMAT.  If DOLLAR_NEEDED    is set, it is an error if one is not found; otherwise, it is OK.  If    such a number is found, check whether it is within range and mark that    numbered operand as being used for later checking.  Returns the operand    number if found and within range, zero if no such number was found and    this is OK, or -1 on error.  PARAMS points to the first operand of the    format; PARAM_PTR is made to point to the parameter referred to.  If    a $ format is found, *FORMAT is updated to point just after it.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_read_dollar_number
parameter_list|(
name|status
parameter_list|,
name|format
parameter_list|,
name|dollar_needed
parameter_list|,
name|params
parameter_list|,
name|param_ptr
parameter_list|,
name|fki
parameter_list|)
name|int
modifier|*
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|format
decl_stmt|;
name|int
name|dollar_needed
decl_stmt|;
name|tree
name|params
decl_stmt|;
name|tree
modifier|*
name|param_ptr
decl_stmt|;
specifier|const
name|format_kind_info
modifier|*
name|fki
decl_stmt|;
block|{
name|int
name|argnum
decl_stmt|;
name|int
name|overflow_flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|fcp
init|=
operator|*
name|format
decl_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|fcp
argument_list|)
condition|)
block|{
if|if
condition|(
name|dollar_needed
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"missing $ operand number in format"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
name|argnum
operator|=
literal|0
expr_stmt|;
name|overflow_flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|fcp
argument_list|)
condition|)
block|{
name|int
name|nargnum
decl_stmt|;
name|nargnum
operator|=
literal|10
operator|*
name|argnum
operator|+
operator|(
operator|*
name|fcp
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|nargnum
operator|<
literal|0
operator|||
name|nargnum
operator|/
literal|10
operator|!=
name|argnum
condition|)
name|overflow_flag
operator|=
literal|1
expr_stmt|;
name|argnum
operator|=
name|nargnum
expr_stmt|;
name|fcp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|fcp
operator|!=
literal|'$'
condition|)
block|{
if|if
condition|(
name|dollar_needed
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"missing $ operand number in format"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
operator|*
name|format
operator|=
name|fcp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|dollar_format_warned
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"%s does not support %%n$ operand number formats"
argument_list|,
name|C_STD_NAME
argument_list|(
name|STD_EXT
argument_list|)
argument_list|)
expr_stmt|;
name|dollar_format_warned
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|overflow_flag
operator|||
name|argnum
operator|==
literal|0
operator|||
operator|(
name|dollar_first_arg_num
operator|&&
name|argnum
operator|>
name|dollar_arguments_count
operator|)
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"operand number out of range in format"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|argnum
operator|>
name|dollar_max_arg_used
condition|)
name|dollar_max_arg_used
operator|=
name|argnum
expr_stmt|;
comment|/* For vprintf-style functions we may need to allocate more memory to      track which arguments are used.  */
while|while
condition|(
name|dollar_arguments_alloc
operator|<
name|dollar_max_arg_used
condition|)
block|{
name|int
name|nalloc
decl_stmt|;
name|nalloc
operator|=
literal|2
operator|*
name|dollar_arguments_alloc
operator|+
literal|16
expr_stmt|;
name|dollar_arguments_used
operator|=
name|xrealloc
argument_list|(
name|dollar_arguments_used
argument_list|,
name|nalloc
argument_list|)
expr_stmt|;
name|dollar_arguments_pointer_p
operator|=
name|xrealloc
argument_list|(
name|dollar_arguments_pointer_p
argument_list|,
name|nalloc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dollar_arguments_used
operator|+
name|dollar_arguments_alloc
argument_list|,
literal|0
argument_list|,
name|nalloc
operator|-
name|dollar_arguments_alloc
argument_list|)
expr_stmt|;
name|dollar_arguments_alloc
operator|=
name|nalloc
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_DOLLAR_MULTIPLE
operator|)
operator|&&
name|dollar_arguments_used
index|[
name|argnum
operator|-
literal|1
index|]
operator|==
literal|1
condition|)
block|{
name|dollar_arguments_used
index|[
name|argnum
operator|-
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"format argument %d used more than once in %s format"
argument_list|,
name|argnum
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|dollar_arguments_used
index|[
name|argnum
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dollar_first_arg_num
condition|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|param_ptr
operator|=
name|params
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argnum
operator|&&
operator|*
name|param_ptr
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
operator|*
name|param_ptr
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|param_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|param_ptr
operator|==
literal|0
condition|)
block|{
comment|/* This case shouldn't be caught here.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
operator|*
name|param_ptr
operator|=
literal|0
expr_stmt|;
return|return
name|argnum
return|;
block|}
end_function

begin_comment
comment|/* Finish the checking for a format string that used $ operand number formats    instead of non-$ formats.  We check for unused operands before used ones    (a serious error, since the implementation of the format function    can't know what types to pass to va_arg to find the later arguments).    and for unused operands at the end of the format (if we know how many    arguments the format had, so not for vprintf).  If there were operand    numbers out of range on a non-vprintf-style format, we won't have reached    here.  If POINTER_GAP_OK, unused arguments are OK if all arguments are    pointers.  */
end_comment

begin_function
specifier|static
name|void
name|finish_dollar_format_checking
parameter_list|(
name|status
parameter_list|,
name|res
parameter_list|,
name|pointer_gap_ok
parameter_list|)
name|int
modifier|*
name|status
decl_stmt|;
name|format_check_results
modifier|*
name|res
decl_stmt|;
name|int
name|pointer_gap_ok
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bool
name|found_pointer_gap
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dollar_max_arg_used
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dollar_arguments_used
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|pointer_gap_ok
operator|&&
operator|(
name|dollar_first_arg_num
operator|==
literal|0
operator|||
name|dollar_arguments_pointer_p
index|[
name|i
index|]
operator|)
condition|)
name|found_pointer_gap
operator|=
name|true
expr_stmt|;
else|else
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"format argument %d unused before used argument %d in $-style format"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|dollar_max_arg_used
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found_pointer_gap
operator|||
operator|(
name|dollar_first_arg_num
operator|&&
name|dollar_max_arg_used
operator|<
name|dollar_arguments_count
operator|)
condition|)
block|{
name|res
operator|->
name|number_other
operator|--
expr_stmt|;
name|res
operator|->
name|number_dollar_extra_args
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Retrieve the specification for a format flag.  SPEC contains the    specifications for format flags for the applicable kind of format.    FLAG is the flag in question.  If PREDICATES is NULL, the basic    spec for that flag must be retrieved and this function aborts if    it cannot be found.  If PREDICATES is not NULL, it is a string listing    possible predicates for the spec entry; if an entry predicated on any    of these is found, it is returned, otherwise NULL is returned.  */
end_comment

begin_function
specifier|static
specifier|const
name|format_flag_spec
modifier|*
name|get_flag_spec
parameter_list|(
name|spec
parameter_list|,
name|flag
parameter_list|,
name|predicates
parameter_list|)
specifier|const
name|format_flag_spec
modifier|*
name|spec
decl_stmt|;
name|int
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|predicates
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|spec
index|[
name|i
index|]
operator|.
name|flag_char
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|.
name|flag_char
operator|!=
name|flag
condition|)
continue|continue;
if|if
condition|(
name|predicates
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|.
name|predicate
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|predicates
argument_list|,
name|spec
index|[
name|i
index|]
operator|.
name|predicate
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|&
name|spec
index|[
name|i
index|]
return|;
block|}
elseif|else
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|.
name|predicate
operator|==
literal|0
condition|)
return|return
operator|&
name|spec
index|[
name|i
index|]
return|;
block|}
if|if
condition|(
name|predicates
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Check the argument list of a call to printf, scanf, etc.    INFO points to the function_format_info structure.    PARAMS is the list of argument values.  */
end_comment

begin_function
specifier|static
name|void
name|check_format_info
parameter_list|(
name|status
parameter_list|,
name|info
parameter_list|,
name|params
parameter_list|)
name|int
modifier|*
name|status
decl_stmt|;
name|function_format_info
modifier|*
name|info
decl_stmt|;
name|tree
name|params
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|arg_num
decl_stmt|;
name|tree
name|format_tree
decl_stmt|;
name|format_check_results
name|res
decl_stmt|;
comment|/* Skip to format argument.  If the argument isn't available, there's      no work for us to do; prototype checking will catch the problem.  */
for|for
control|(
name|arg_num
operator|=
literal|1
init|;
condition|;
operator|++
name|arg_num
control|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|arg_num
operator|==
name|info
operator|->
name|format_num
condition|)
break|break;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
name|format_tree
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_tree
operator|==
literal|0
condition|)
return|return;
name|res
operator|.
name|number_non_literal
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_extra_args
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_dollar_extra_args
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_wide
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_empty
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_unterminated
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_other
operator|=
literal|0
expr_stmt|;
name|check_format_info_recurse
argument_list|(
name|status
argument_list|,
operator|&
name|res
argument_list|,
name|info
argument_list|,
name|format_tree
argument_list|,
name|params
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|number_non_literal
operator|>
literal|0
condition|)
block|{
comment|/* Functions taking a va_list normally pass a non-literal format 	 string.  These functions typically are declared with 	 first_arg_num == 0, so avoid warning in those cases.  */
if|if
condition|(
operator|!
operator|(
name|format_types
index|[
name|info
operator|->
name|format_type
index|]
operator|.
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_ARG_CONVERT
operator|)
condition|)
block|{
comment|/* For strftime-like formats, warn for not checking the format 	     string; but there are no arguments to check.  */
if|if
condition|(
name|warn_format_nonliteral
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"format not a string literal, format string not checked"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
comment|/* If there are no arguments for the format at all, we may have 	     printf (foo) which is likely to be a security hole.  */
while|while
condition|(
name|arg_num
operator|+
literal|1
operator|<
name|info
operator|->
name|first_arg_num
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
break|break;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|==
literal|0
operator|&&
operator|(
name|warn_format_nonliteral
operator|||
name|warn_format_security
operator|)
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"format not a string literal and no format arguments"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_format_nonliteral
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"format not a string literal, argument types not checked"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there were extra arguments to the format, normally warn.  However,      the standard does say extra arguments are ignored, so in the specific      case where we have multiple leaves (conditional expressions or      ngettext) allow extra arguments if at least one leaf didn't have extra      arguments, but was otherwise OK (either non-literal or checked OK).      If the format is an empty string, this should be counted similarly to the      case of extra format arguments.  */
if|if
condition|(
name|res
operator|.
name|number_extra_args
operator|>
literal|0
operator|&&
name|res
operator|.
name|number_non_literal
operator|==
literal|0
operator|&&
name|res
operator|.
name|number_other
operator|==
literal|0
operator|&&
name|warn_format_extra_args
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"too many arguments for format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|number_dollar_extra_args
operator|>
literal|0
operator|&&
name|res
operator|.
name|number_non_literal
operator|==
literal|0
operator|&&
name|res
operator|.
name|number_other
operator|==
literal|0
operator|&&
name|warn_format_extra_args
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"unused arguments in $-style format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|number_empty
operator|>
literal|0
operator|&&
name|res
operator|.
name|number_non_literal
operator|==
literal|0
operator|&&
name|res
operator|.
name|number_other
operator|==
literal|0
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"zero-length format string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|number_wide
operator|>
literal|0
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"format is a wide character string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|number_unterminated
operator|>
literal|0
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"unterminated format string"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recursively check a call to a format function.  FORMAT_TREE is the    format parameter, which may be a conditional expression in which    both halves should be checked.  ARG_NUM is the number of the    format argument; PARAMS points just after it in the argument list.  */
end_comment

begin_function
specifier|static
name|void
name|check_format_info_recurse
parameter_list|(
name|status
parameter_list|,
name|res
parameter_list|,
name|info
parameter_list|,
name|format_tree
parameter_list|,
name|params
parameter_list|,
name|arg_num
parameter_list|)
name|int
modifier|*
name|status
decl_stmt|;
name|format_check_results
modifier|*
name|res
decl_stmt|;
name|function_format_info
modifier|*
name|info
decl_stmt|;
name|tree
name|format_tree
decl_stmt|;
name|tree
name|params
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|arg_num
decl_stmt|;
block|{
name|int
name|format_length
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_chars
decl_stmt|;
name|tree
name|array_size
init|=
literal|0
decl_stmt|;
name|tree
name|array_init
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
comment|/* Strip coercion.  */
name|check_format_info_recurse
argument_list|(
name|status
argument_list|,
name|res
argument_list|,
name|info
argument_list|,
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
argument_list|,
name|params
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
name|bool
name|found_format_arg
init|=
name|false
decl_stmt|;
comment|/* See if this is a call to a known internationalization function 	 that modifies the format arg.  Such a function may have multiple 	 format_arg attributes (for example, ngettext).  */
for|for
control|(
name|attrs
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
init|;
name|attrs
condition|;
name|attrs
operator|=
name|TREE_CHAIN
argument_list|(
name|attrs
argument_list|)
control|)
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"format_arg"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|attrs
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|inner_args
decl_stmt|;
name|tree
name|format_num_expr
decl_stmt|;
name|int
name|format_num
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Extract the argument number, which was previously checked 	       to be valid.  */
name|format_num_expr
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attrs
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|format_num_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|format_num_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|format_num_expr
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|format_num
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|format_num_expr
argument_list|)
expr_stmt|;
for|for
control|(
name|inner_args
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|1
argument_list|)
operator|,
name|i
operator|=
literal|1
init|;
name|inner_args
operator|!=
literal|0
condition|;
name|inner_args
operator|=
name|TREE_CHAIN
argument_list|(
name|inner_args
argument_list|)
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|format_num
condition|)
block|{
name|check_format_info_recurse
argument_list|(
name|status
argument_list|,
name|res
argument_list|,
name|info
argument_list|,
name|TREE_VALUE
argument_list|(
name|inner_args
argument_list|)
argument_list|,
name|params
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
name|found_format_arg
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we found a format_arg attribute and did a recursive check, 	 we are done with checking this format string.  Otherwise, we 	 continue and this will count as a non-literal format string.  */
if|if
condition|(
name|found_format_arg
condition|)
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* Check both halves of the conditional expression.  */
name|check_format_info_recurse
argument_list|(
name|status
argument_list|,
name|res
argument_list|,
name|info
argument_list|,
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|1
argument_list|)
argument_list|,
name|params
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
name|check_format_info_recurse
argument_list|(
name|status
argument_list|,
name|res
argument_list|,
name|info
argument_list|,
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|2
argument_list|)
argument_list|,
name|params
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|format_tree
argument_list|)
condition|)
block|{
comment|/* FIXME: this warning should go away once Marc Espie's 	 __attribute__((nonnull)) patch is in.  Instead, checking for 	 nonnull attributes should probably change this function to act 	 specially if info == NULL and add a res->number_null entry for 	 that case, or maybe add a function pointer to be called at 	 the end instead of hardcoding check_format_info_main.  */
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"null format string"
argument_list|)
expr_stmt|;
comment|/* Skip to first argument to check, so we can see if this format 	 has any arguments (it shouldn't).  */
while|while
condition|(
name|arg_num
operator|+
literal|1
operator|<
name|info
operator|->
name|first_arg_num
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|==
literal|0
condition|)
name|res
operator|->
name|number_other
operator|++
expr_stmt|;
else|else
name|res
operator|->
name|number_extra_args
operator|++
expr_stmt|;
return|return;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|format_tree
operator|=
name|arg0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|format_tree
operator|=
name|arg1
expr_stmt|;
name|arg1
operator|=
name|arg0
expr_stmt|;
block|}
else|else
block|{
name|res
operator|->
name|number_non_literal
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|res
operator|->
name|number_non_literal
operator|++
expr_stmt|;
return|return;
block|}
name|offset
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
block|{
name|res
operator|->
name|number_non_literal
operator|++
expr_stmt|;
return|return;
block|}
name|format_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|format_tree
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|array_init
operator|=
name|decl_constant_value
argument_list|(
name|format_tree
argument_list|)
operator|)
operator|!=
name|format_tree
operator|&&
name|TREE_CODE
argument_list|(
name|array_init
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* Extract the string constant initializer.  Note that this may include 	 a trailing NUL character that is not in the array (e.g. 	 const char a[3] = "foo";).  */
name|array_size
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
name|format_tree
operator|=
name|array_init
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|res
operator|->
name|number_non_literal
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|format_tree
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
condition|)
block|{
name|res
operator|->
name|number_wide
operator|++
expr_stmt|;
return|return;
block|}
name|format_chars
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
name|format_length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_size
operator|!=
literal|0
condition|)
block|{
comment|/* Variable length arrays can't be initialized.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array_size
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|array_size
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|array_size_value
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|array_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|array_size_value
operator|>
literal|0
operator|&&
name|array_size_value
operator|==
operator|(
name|int
operator|)
name|array_size_value
operator|&&
name|format_length
operator|>
name|array_size_value
condition|)
name|format_length
operator|=
name|array_size_value
expr_stmt|;
block|}
block|}
if|if
condition|(
name|offset
condition|)
block|{
if|if
condition|(
name|offset
operator|>=
name|format_length
condition|)
block|{
name|res
operator|->
name|number_non_literal
operator|++
expr_stmt|;
return|return;
block|}
name|format_chars
operator|+=
name|offset
expr_stmt|;
name|format_length
operator|-=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|format_length
operator|<
literal|1
condition|)
block|{
name|res
operator|->
name|number_unterminated
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|format_length
operator|==
literal|1
condition|)
block|{
name|res
operator|->
name|number_empty
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|format_chars
index|[
operator|--
name|format_length
index|]
operator|!=
literal|0
condition|)
block|{
name|res
operator|->
name|number_unterminated
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Skip to first argument to check.  */
while|while
condition|(
name|arg_num
operator|+
literal|1
operator|<
name|info
operator|->
name|first_arg_num
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
comment|/* Provisionally increment res->number_other; check_format_info_main      will decrement it if it finds there are extra arguments, but this way      need not adjust it for every return.  */
name|res
operator|->
name|number_other
operator|++
expr_stmt|;
name|check_format_info_main
argument_list|(
name|status
argument_list|,
name|res
argument_list|,
name|info
argument_list|,
name|format_chars
argument_list|,
name|format_length
argument_list|,
name|params
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do the main part of checking a call to a format function.  FORMAT_CHARS    is the NUL-terminated format string (which at this point may contain    internal NUL characters); FORMAT_LENGTH is its length (excluding the    terminating NUL character).  ARG_NUM is one less than the number of    the first format argument to check; PARAMS points to that format    argument in the list of arguments.  */
end_comment

begin_function
specifier|static
name|void
name|check_format_info_main
parameter_list|(
name|status
parameter_list|,
name|res
parameter_list|,
name|info
parameter_list|,
name|format_chars
parameter_list|,
name|format_length
parameter_list|,
name|params
parameter_list|,
name|arg_num
parameter_list|)
name|int
modifier|*
name|status
decl_stmt|;
name|format_check_results
modifier|*
name|res
decl_stmt|;
name|function_format_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_chars
decl_stmt|;
name|int
name|format_length
decl_stmt|;
name|tree
name|params
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|arg_num
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig_format_chars
init|=
name|format_chars
decl_stmt|;
name|tree
name|first_fillin_param
init|=
name|params
decl_stmt|;
specifier|const
name|format_kind_info
modifier|*
name|fki
init|=
operator|&
name|format_types
index|[
name|info
operator|->
name|format_type
index|]
decl_stmt|;
specifier|const
name|format_flag_spec
modifier|*
name|flag_specs
init|=
name|fki
operator|->
name|flag_specs
decl_stmt|;
specifier|const
name|format_flag_pair
modifier|*
name|bad_flag_pairs
init|=
name|fki
operator|->
name|bad_flag_pairs
decl_stmt|;
comment|/* -1 if no conversions taking an operand have been found; 0 if one has      and it didn't use $; 1 if $ formats are in use.  */
name|int
name|has_operand_number
init|=
operator|-
literal|1
decl_stmt|;
name|init_dollar_format_checking
argument_list|(
name|info
operator|->
name|first_arg_num
argument_list|,
name|first_fillin_param
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|suppressed
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|length_chars
init|=
name|NULL
decl_stmt|;
name|enum
name|format_lengths
name|length_chars_val
init|=
name|FMT_LEN_none
decl_stmt|;
name|enum
name|format_std_version
name|length_chars_std
init|=
name|STD_C89
decl_stmt|;
name|int
name|format_char
decl_stmt|;
name|tree
name|cur_param
decl_stmt|;
name|tree
name|wanted_type
decl_stmt|;
name|int
name|main_arg_num
init|=
literal|0
decl_stmt|;
name|tree
name|main_arg_params
init|=
literal|0
decl_stmt|;
name|enum
name|format_std_version
name|wanted_type_std
decl_stmt|;
specifier|const
name|char
modifier|*
name|wanted_type_name
decl_stmt|;
name|format_wanted_type
name|width_wanted_type
decl_stmt|;
name|format_wanted_type
name|precision_wanted_type
decl_stmt|;
name|format_wanted_type
name|main_wanted_type
decl_stmt|;
name|format_wanted_type
modifier|*
name|first_wanted_type
init|=
name|NULL
decl_stmt|;
name|format_wanted_type
modifier|*
name|last_wanted_type
init|=
name|NULL
decl_stmt|;
specifier|const
name|format_length_info
modifier|*
name|fli
init|=
name|NULL
decl_stmt|;
specifier|const
name|format_char_info
modifier|*
name|fci
init|=
name|NULL
decl_stmt|;
name|char
name|flag_chars
index|[
literal|256
index|]
decl_stmt|;
name|int
name|aflag
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|format_chars
operator|-
name|orig_format_chars
operator|!=
name|format_length
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"embedded `\\0' in format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
operator|&&
name|params
operator|!=
literal|0
operator|&&
name|has_operand_number
operator|<=
literal|0
condition|)
block|{
name|res
operator|->
name|number_other
operator|--
expr_stmt|;
name|res
operator|->
name|number_extra_args
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|has_operand_number
operator|>
literal|0
condition|)
name|finish_dollar_format_checking
argument_list|(
name|status
argument_list|,
name|res
argument_list|,
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_DOLLAR_GAP_POINTER_OK
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|format_chars
operator|++
operator|!=
literal|'%'
condition|)
continue|continue;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"spurious trailing `%%' in format"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'%'
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
continue|continue;
block|}
name|flag_chars
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_USE_DOLLAR
operator|)
operator|&&
name|has_operand_number
operator|!=
literal|0
condition|)
block|{
comment|/* Possibly read a $ operand number at the start of the format. 	     If one was previously used, one is required here.  If one 	     is not used here, we can't immediately conclude this is a 	     format without them, since it could be printf %m or scanf %*.  */
name|int
name|opnum
decl_stmt|;
name|opnum
operator|=
name|maybe_read_dollar_number
argument_list|(
name|status
argument_list|,
operator|&
name|format_chars
argument_list|,
literal|0
argument_list|,
name|first_fillin_param
argument_list|,
operator|&
name|main_arg_params
argument_list|,
name|fki
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnum
operator|==
operator|-
literal|1
condition|)
return|return;
elseif|else
if|if
condition|(
name|opnum
operator|>
literal|0
condition|)
block|{
name|has_operand_number
operator|=
literal|1
expr_stmt|;
name|main_arg_num
operator|=
name|opnum
operator|+
name|info
operator|->
name|first_arg_num
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Read any format flags, but do not yet validate them beyond removing 	 duplicates, since in general validation depends on the rest of 	 the format.  */
while|while
condition|(
operator|*
name|format_chars
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|fki
operator|->
name|flag_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|format_flag_spec
modifier|*
name|s
init|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
operator|*
name|format_chars
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|flag_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"repeated %s in format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|format_chars
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|skip_next_char
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"missing fill character at end of strfmon format"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
operator|++
name|format_chars
expr_stmt|;
block|}
comment|/* Read any format width, possibly * or *m$.  */
if|if
condition|(
name|fki
operator|->
name|width_char
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fki
operator|->
name|width_type
operator|!=
name|NULL
operator|&&
operator|*
name|format_chars
operator|==
literal|'*'
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
name|fki
operator|->
name|width_char
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* "...a field width...may be indicated by an asterisk. 		 In this case, an int argument supplies the field width..."  */
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"too few arguments for format"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|has_operand_number
operator|!=
literal|0
condition|)
block|{
name|int
name|opnum
decl_stmt|;
name|opnum
operator|=
name|maybe_read_dollar_number
argument_list|(
name|status
argument_list|,
operator|&
name|format_chars
argument_list|,
name|has_operand_number
operator|==
literal|1
argument_list|,
name|first_fillin_param
argument_list|,
operator|&
name|params
argument_list|,
name|fki
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnum
operator|==
operator|-
literal|1
condition|)
return|return;
elseif|else
if|if
condition|(
name|opnum
operator|>
literal|0
condition|)
block|{
name|has_operand_number
operator|=
literal|1
expr_stmt|;
name|arg_num
operator|=
name|opnum
operator|+
name|info
operator|->
name|first_arg_num
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|has_operand_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_operand_number
operator|<=
literal|0
condition|)
block|{
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
name|width_wanted_type
operator|.
name|wanted_type
operator|=
operator|*
name|fki
operator|->
name|width_type
expr_stmt|;
name|width_wanted_type
operator|.
name|wanted_type_name
operator|=
name|NULL
expr_stmt|;
name|width_wanted_type
operator|.
name|pointer_count
operator|=
literal|0
expr_stmt|;
name|width_wanted_type
operator|.
name|char_lenient_flag
operator|=
literal|0
expr_stmt|;
name|width_wanted_type
operator|.
name|writing_in_flag
operator|=
literal|0
expr_stmt|;
name|width_wanted_type
operator|.
name|reading_from_flag
operator|=
literal|0
expr_stmt|;
name|width_wanted_type
operator|.
name|name
operator|=
name|_
argument_list|(
literal|"field width"
argument_list|)
expr_stmt|;
name|width_wanted_type
operator|.
name|param
operator|=
name|cur_param
expr_stmt|;
name|width_wanted_type
operator|.
name|arg_num
operator|=
name|arg_num
expr_stmt|;
name|width_wanted_type
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_wanted_type
operator|!=
literal|0
condition|)
name|last_wanted_type
operator|->
name|next
operator|=
operator|&
name|width_wanted_type
expr_stmt|;
if|if
condition|(
name|first_wanted_type
operator|==
literal|0
condition|)
name|first_wanted_type
operator|=
operator|&
name|width_wanted_type
expr_stmt|;
name|last_wanted_type
operator|=
operator|&
name|width_wanted_type
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Possibly read a numeric width.  If the width is zero, 		 we complain if appropriate.  */
name|int
name|non_zero_width_char
init|=
name|FALSE
decl_stmt|;
name|int
name|found_width
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
block|{
name|found_width
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|!=
literal|'0'
condition|)
name|non_zero_width_char
operator|=
name|TRUE
expr_stmt|;
operator|++
name|format_chars
expr_stmt|;
block|}
if|if
condition|(
name|found_width
operator|&&
operator|!
name|non_zero_width_char
operator|&&
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_ZERO_WIDTH_BAD
operator|)
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"zero width in %s format"
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_width
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
name|fki
operator|->
name|width_char
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Read any format left precision (must be a number, not *).  */
if|if
condition|(
name|fki
operator|->
name|left_precision_char
operator|!=
literal|0
operator|&&
operator|*
name|format_chars
operator|==
literal|'#'
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
name|fki
operator|->
name|left_precision_char
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"empty left precision in %s format"
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
operator|++
name|format_chars
expr_stmt|;
block|}
comment|/* Read any format precision, possibly * or *m$.  */
if|if
condition|(
name|fki
operator|->
name|precision_char
operator|!=
literal|0
operator|&&
operator|*
name|format_chars
operator|==
literal|'.'
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
name|fki
operator|->
name|precision_char
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fki
operator|->
name|precision_type
operator|!=
name|NULL
operator|&&
operator|*
name|format_chars
operator|==
literal|'*'
condition|)
block|{
comment|/* "...a...precision...may be indicated by an asterisk. 		 In this case, an int argument supplies the...precision."  */
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
name|has_operand_number
operator|!=
literal|0
condition|)
block|{
name|int
name|opnum
decl_stmt|;
name|opnum
operator|=
name|maybe_read_dollar_number
argument_list|(
name|status
argument_list|,
operator|&
name|format_chars
argument_list|,
name|has_operand_number
operator|==
literal|1
argument_list|,
name|first_fillin_param
argument_list|,
operator|&
name|params
argument_list|,
name|fki
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnum
operator|==
operator|-
literal|1
condition|)
return|return;
elseif|else
if|if
condition|(
name|opnum
operator|>
literal|0
condition|)
block|{
name|has_operand_number
operator|=
literal|1
expr_stmt|;
name|arg_num
operator|=
name|opnum
operator|+
name|info
operator|->
name|first_arg_num
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|has_operand_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"too few arguments for format"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_operand_number
operator|<=
literal|0
condition|)
block|{
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
name|precision_wanted_type
operator|.
name|wanted_type
operator|=
operator|*
name|fki
operator|->
name|precision_type
expr_stmt|;
name|precision_wanted_type
operator|.
name|wanted_type_name
operator|=
name|NULL
expr_stmt|;
name|precision_wanted_type
operator|.
name|pointer_count
operator|=
literal|0
expr_stmt|;
name|precision_wanted_type
operator|.
name|char_lenient_flag
operator|=
literal|0
expr_stmt|;
name|precision_wanted_type
operator|.
name|writing_in_flag
operator|=
literal|0
expr_stmt|;
name|precision_wanted_type
operator|.
name|reading_from_flag
operator|=
literal|0
expr_stmt|;
name|precision_wanted_type
operator|.
name|name
operator|=
name|_
argument_list|(
literal|"field precision"
argument_list|)
expr_stmt|;
name|precision_wanted_type
operator|.
name|param
operator|=
name|cur_param
expr_stmt|;
name|precision_wanted_type
operator|.
name|arg_num
operator|=
name|arg_num
expr_stmt|;
name|precision_wanted_type
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_wanted_type
operator|!=
literal|0
condition|)
name|last_wanted_type
operator|->
name|next
operator|=
operator|&
name|precision_wanted_type
expr_stmt|;
if|if
condition|(
name|first_wanted_type
operator|==
literal|0
condition|)
name|first_wanted_type
operator|=
operator|&
name|precision_wanted_type
expr_stmt|;
name|last_wanted_type
operator|=
operator|&
name|precision_wanted_type
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_EMPTY_PREC_OK
operator|)
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"empty precision in %s format"
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
operator|++
name|format_chars
expr_stmt|;
block|}
block|}
comment|/* Read any length modifier, if this kind of format has them.  */
name|fli
operator|=
name|fki
operator|->
name|length_char_specs
expr_stmt|;
name|length_chars
operator|=
name|NULL
expr_stmt|;
name|length_chars_val
operator|=
name|FMT_LEN_none
expr_stmt|;
name|length_chars_std
operator|=
name|STD_C89
expr_stmt|;
if|if
condition|(
name|fli
condition|)
block|{
while|while
condition|(
name|fli
operator|->
name|name
operator|!=
literal|0
operator|&&
name|fli
operator|->
name|name
index|[
literal|0
index|]
operator|!=
operator|*
name|format_chars
condition|)
name|fli
operator|++
expr_stmt|;
if|if
condition|(
name|fli
operator|->
name|name
operator|!=
literal|0
condition|)
block|{
name|format_chars
operator|++
expr_stmt|;
if|if
condition|(
name|fli
operator|->
name|double_name
operator|!=
literal|0
operator|&&
name|fli
operator|->
name|name
index|[
literal|0
index|]
operator|==
operator|*
name|format_chars
condition|)
block|{
name|format_chars
operator|++
expr_stmt|;
name|length_chars
operator|=
name|fli
operator|->
name|double_name
expr_stmt|;
name|length_chars_val
operator|=
name|fli
operator|->
name|double_index
expr_stmt|;
name|length_chars_std
operator|=
name|fli
operator|->
name|double_std
expr_stmt|;
block|}
else|else
block|{
name|length_chars
operator|=
name|fli
operator|->
name|name
expr_stmt|;
name|length_chars_val
operator|=
name|fli
operator|->
name|index
expr_stmt|;
name|length_chars_std
operator|=
name|fli
operator|->
name|std
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
name|fki
operator|->
name|length_code_char
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
comment|/* Warn if the length modifier is non-standard.  */
if|if
condition|(
name|ADJ_STD
argument_list|(
name|length_chars_std
argument_list|)
operator|>
name|C_STD_VER
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"%s does not support the `%s' %s length modifier"
argument_list|,
name|C_STD_NAME
argument_list|(
name|length_chars_std
argument_list|)
argument_list|,
name|length_chars
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Read any modifier (strftime E/O).  */
if|if
condition|(
name|fki
operator|->
name|modifier_chars
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|format_chars
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|fki
operator|->
name|modifier_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|flag_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|format_flag_spec
modifier|*
name|s
init|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
operator|*
name|format_chars
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"repeated %s in format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|format_chars
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|format_chars
expr_stmt|;
block|}
block|}
comment|/* Handle the scanf allocation kludge.  */
if|if
condition|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_SCANF_A_KLUDGE
condition|)
block|{
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'a'
operator|&&
operator|!
name|flag_isoc99
condition|)
block|{
if|if
condition|(
name|format_chars
index|[
literal|1
index|]
operator|==
literal|'s'
operator|||
name|format_chars
index|[
literal|1
index|]
operator|==
literal|'S'
operator|||
name|format_chars
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
comment|/* `a' is used as a flag.  */
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
literal|'a'
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|format_chars
operator|++
expr_stmt|;
block|}
block|}
block|}
name|format_char
operator|=
operator|*
name|format_chars
expr_stmt|;
if|if
condition|(
name|format_char
operator|==
literal|0
operator|||
operator|(
operator|!
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_FANCY_PERCENT_OK
operator|)
operator|&&
name|format_char
operator|==
literal|'%'
operator|)
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"conversion lacks type at end of format"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|format_chars
operator|++
expr_stmt|;
name|fci
operator|=
name|fki
operator|->
name|conversion_specs
expr_stmt|;
while|while
condition|(
name|fci
operator|->
name|format_chars
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|fci
operator|->
name|format_chars
argument_list|,
name|format_char
argument_list|)
operator|==
literal|0
condition|)
operator|++
name|fci
expr_stmt|;
if|if
condition|(
name|fci
operator|->
name|format_chars
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ISGRAPH
argument_list|(
name|format_char
argument_list|)
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"unknown conversion type character `%c' in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
else|else
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"unknown conversion type character 0x%x in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|ADJ_STD
argument_list|(
name|fci
operator|->
name|std
argument_list|)
operator|>
name|C_STD_VER
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"%s does not support the `%%%c' %s format"
argument_list|,
name|C_STD_NAME
argument_list|(
name|fci
operator|->
name|std
argument_list|)
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Validate the individual flags used, removing any that are invalid.  */
block|{
name|int
name|d
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|flag_chars
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|format_flag_spec
modifier|*
name|s
init|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|flag_chars
index|[
name|i
operator|-
name|d
index|]
operator|=
name|flag_chars
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|flag_chars
index|[
name|i
index|]
operator|==
name|fki
operator|->
name|length_code_char
condition|)
continue|continue;
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"%s used with `%%%c' %s format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
specifier|const
name|format_flag_spec
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|ADJ_STD
argument_list|(
name|s
operator|->
name|std
argument_list|)
operator|>
name|C_STD_VER
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"%s does not support %s"
argument_list|,
name|C_STD_NAME
argument_list|(
name|s
operator|->
name|std
argument_list|)
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|long_name
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|,
name|fci
operator|->
name|flags2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
operator|&&
name|ADJ_STD
argument_list|(
name|t
operator|->
name|std
argument_list|)
operator|>
name|ADJ_STD
argument_list|(
name|s
operator|->
name|std
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|long_name
init|=
operator|(
name|t
operator|->
name|long_name
operator|!=
name|NULL
condition|?
name|t
operator|->
name|long_name
else|:
name|s
operator|->
name|long_name
operator|)
decl_stmt|;
if|if
condition|(
name|ADJ_STD
argument_list|(
name|t
operator|->
name|std
argument_list|)
operator|>
name|C_STD_VER
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"%s does not support %s with the `%%%c' %s format"
argument_list|,
name|C_STD_NAME
argument_list|(
name|t
operator|->
name|std
argument_list|)
argument_list|,
name|_
argument_list|(
name|long_name
argument_list|)
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|flag_chars
index|[
name|i
operator|-
name|d
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_SCANF_A_KLUDGE
operator|)
operator|&&
name|strchr
argument_list|(
name|flag_chars
argument_list|,
literal|'a'
argument_list|)
operator|!=
literal|0
condition|)
name|aflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fki
operator|->
name|suppression_char
operator|&&
name|strchr
argument_list|(
name|flag_chars
argument_list|,
name|fki
operator|->
name|suppression_char
argument_list|)
operator|!=
literal|0
condition|)
name|suppressed
operator|=
literal|1
expr_stmt|;
comment|/* Validate the pairs of flags used.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|flag_char1
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|format_flag_spec
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|flag_chars
argument_list|,
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|flag_char1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strchr
argument_list|(
name|flag_chars
argument_list|,
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|flag_char2
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|predicate
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|predicate
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|s
operator|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|flag_char1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|flag_char2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|ignored
condition|)
block|{
if|if
condition|(
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|predicate
operator|!=
literal|0
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"%s ignored with %s and `%%%c' %s format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
name|_
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"%s ignored with %s in %s format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
name|_
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|predicate
operator|!=
literal|0
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"use of %s and %s together with `%%%c' %s format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
name|_
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"use of %s and %s together in %s format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
name|_
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Give Y2K warnings.  */
if|if
condition|(
name|warn_format_y2k
condition|)
block|{
name|int
name|y2k_level
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'4'
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|strchr
argument_list|(
name|flag_chars
argument_list|,
literal|'E'
argument_list|)
operator|!=
literal|0
condition|)
name|y2k_level
operator|=
literal|3
expr_stmt|;
else|else
name|y2k_level
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'3'
argument_list|)
operator|!=
literal|0
condition|)
name|y2k_level
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'2'
argument_list|)
operator|!=
literal|0
condition|)
name|y2k_level
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|y2k_level
operator|==
literal|3
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"`%%%c' yields only last 2 digits of year in some locales"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|y2k_level
operator|==
literal|2
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"`%%%c' yields only last 2 digits of year"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'['
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Skip over scan set, in case it happens to have '%' in it.  */
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'^'
condition|)
operator|++
name|format_chars
expr_stmt|;
comment|/* Find closing bracket; if one is hit immediately, then 	     it's part of the scan set rather than a terminator.  */
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|']'
condition|)
operator|++
name|format_chars
expr_stmt|;
while|while
condition|(
operator|*
name|format_chars
operator|&&
operator|*
name|format_chars
operator|!=
literal|']'
condition|)
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|!=
literal|']'
condition|)
comment|/* The end of the format string was reached.  */
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"no closing `]' for `%%[' format"
argument_list|)
expr_stmt|;
block|}
name|wanted_type
operator|=
literal|0
expr_stmt|;
name|wanted_type_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_ARG_CONVERT
condition|)
block|{
name|wanted_type
operator|=
operator|(
name|fci
operator|->
name|types
index|[
name|length_chars_val
index|]
operator|.
name|type
condition|?
operator|*
name|fci
operator|->
name|types
index|[
name|length_chars_val
index|]
operator|.
name|type
else|:
literal|0
operator|)
expr_stmt|;
name|wanted_type_name
operator|=
name|fci
operator|->
name|types
index|[
name|length_chars_val
index|]
operator|.
name|name
expr_stmt|;
name|wanted_type_std
operator|=
name|fci
operator|->
name|types
index|[
name|length_chars_val
index|]
operator|.
name|std
expr_stmt|;
if|if
condition|(
name|wanted_type
operator|==
literal|0
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"use of `%s' length modifier with `%c' type character"
argument_list|,
name|length_chars
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
comment|/* Heuristic: skip one argument when an invalid length/type 		 combination is encountered.  */
name|arg_num
operator|++
expr_stmt|;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"too few arguments for format"
argument_list|)
expr_stmt|;
return|return;
block|}
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|pedantic
comment|/* Warn if non-standard, provided it is more non-standard 		      than the length and type characters that may already 		      have been warned for.  */
operator|&&
name|ADJ_STD
argument_list|(
name|wanted_type_std
argument_list|)
operator|>
name|ADJ_STD
argument_list|(
name|length_chars_std
argument_list|)
operator|&&
name|ADJ_STD
argument_list|(
name|wanted_type_std
argument_list|)
operator|>
name|ADJ_STD
argument_list|(
name|fci
operator|->
name|std
argument_list|)
condition|)
block|{
if|if
condition|(
name|ADJ_STD
argument_list|(
name|wanted_type_std
argument_list|)
operator|>
name|C_STD_VER
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"%s does not support the `%%%s%c' %s format"
argument_list|,
name|C_STD_NAME
argument_list|(
name|wanted_type_std
argument_list|)
argument_list|,
name|length_chars
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Finally. . .check type of argument against desired type!  */
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|fci
operator|->
name|pointer_count
operator|==
literal|0
operator|&&
name|wanted_type
operator|==
name|void_type_node
operator|)
operator|||
name|suppressed
condition|)
block|{
if|if
condition|(
name|main_arg_num
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|suppressed
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"operand number specified with suppressed assignment"
argument_list|)
expr_stmt|;
else|else
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"operand number specified for format taking no argument"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|main_arg_num
operator|!=
literal|0
condition|)
block|{
name|arg_num
operator|=
name|main_arg_num
expr_stmt|;
name|params
operator|=
name|main_arg_params
expr_stmt|;
block|}
else|else
block|{
operator|++
name|arg_num
expr_stmt|;
if|if
condition|(
name|has_operand_number
operator|>
literal|0
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"missing $ operand number in format"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|has_operand_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"too few arguments for format"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|main_wanted_type
operator|.
name|wanted_type
operator|=
name|wanted_type
expr_stmt|;
name|main_wanted_type
operator|.
name|wanted_type_name
operator|=
name|wanted_type_name
expr_stmt|;
name|main_wanted_type
operator|.
name|pointer_count
operator|=
name|fci
operator|->
name|pointer_count
operator|+
name|aflag
expr_stmt|;
name|main_wanted_type
operator|.
name|char_lenient_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'c'
argument_list|)
operator|!=
literal|0
condition|)
name|main_wanted_type
operator|.
name|char_lenient_flag
operator|=
literal|1
expr_stmt|;
name|main_wanted_type
operator|.
name|writing_in_flag
operator|=
literal|0
expr_stmt|;
name|main_wanted_type
operator|.
name|reading_from_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|main_wanted_type
operator|.
name|writing_in_flag
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'W'
argument_list|)
operator|!=
literal|0
condition|)
name|main_wanted_type
operator|.
name|writing_in_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'R'
argument_list|)
operator|!=
literal|0
condition|)
name|main_wanted_type
operator|.
name|reading_from_flag
operator|=
literal|1
expr_stmt|;
block|}
name|main_wanted_type
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|main_wanted_type
operator|.
name|param
operator|=
name|cur_param
expr_stmt|;
name|main_wanted_type
operator|.
name|arg_num
operator|=
name|arg_num
expr_stmt|;
name|main_wanted_type
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_wanted_type
operator|!=
literal|0
condition|)
name|last_wanted_type
operator|->
name|next
operator|=
operator|&
name|main_wanted_type
expr_stmt|;
if|if
condition|(
name|first_wanted_type
operator|==
literal|0
condition|)
name|first_wanted_type
operator|=
operator|&
name|main_wanted_type
expr_stmt|;
name|last_wanted_type
operator|=
operator|&
name|main_wanted_type
expr_stmt|;
block|}
if|if
condition|(
name|first_wanted_type
operator|!=
literal|0
condition|)
name|check_format_types
argument_list|(
name|status
argument_list|,
name|first_wanted_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check the argument types from a single format conversion (possibly    including width and precision arguments).  */
end_comment

begin_function
specifier|static
name|void
name|check_format_types
parameter_list|(
name|status
parameter_list|,
name|types
parameter_list|)
name|int
modifier|*
name|status
decl_stmt|;
name|format_wanted_type
modifier|*
name|types
decl_stmt|;
block|{
for|for
control|(
init|;
name|types
operator|!=
literal|0
condition|;
name|types
operator|=
name|types
operator|->
name|next
control|)
block|{
name|tree
name|cur_param
decl_stmt|;
name|tree
name|cur_type
decl_stmt|;
name|tree
name|orig_cur_type
decl_stmt|;
name|tree
name|wanted_type
decl_stmt|;
name|tree
name|promoted_type
decl_stmt|;
name|int
name|arg_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|char_type_flag
decl_stmt|;
name|cur_param
operator|=
name|types
operator|->
name|param
expr_stmt|;
name|cur_type
operator|=
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_type
operator|==
name|error_mark_node
condition|)
continue|continue;
name|char_type_flag
operator|=
literal|0
expr_stmt|;
name|wanted_type
operator|=
name|types
operator|->
name|wanted_type
expr_stmt|;
name|arg_num
operator|=
name|types
operator|->
name|arg_num
expr_stmt|;
comment|/* The following should not occur here.  */
if|if
condition|(
name|wanted_type
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|wanted_type
operator|==
name|void_type_node
operator|&&
name|types
operator|->
name|pointer_count
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|types
operator|->
name|pointer_count
operator|==
literal|0
condition|)
block|{
name|promoted_type
operator|=
name|simple_type_promotes_to
argument_list|(
name|wanted_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|promoted_type
operator|!=
name|NULL_TREE
condition|)
name|wanted_type
operator|=
name|promoted_type
expr_stmt|;
block|}
name|STRIP_NOPS
argument_list|(
name|cur_param
argument_list|)
expr_stmt|;
comment|/* Check the types of any additional pointer arguments 	 that precede the "real" argument.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|types
operator|->
name|pointer_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|cur_type
operator|=
name|TREE_TYPE
argument_list|(
name|cur_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_type
operator|==
name|error_mark_node
condition|)
break|break;
comment|/* Check for writing through a NULL pointer.  */
if|if
condition|(
name|types
operator|->
name|writing_in_flag
operator|&&
name|i
operator|==
literal|0
operator|&&
name|cur_param
operator|!=
literal|0
operator|&&
name|integer_zerop
argument_list|(
name|cur_param
argument_list|)
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"writing through null pointer (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
comment|/* Check for reading through a NULL pointer.  */
if|if
condition|(
name|types
operator|->
name|reading_from_flag
operator|&&
name|i
operator|==
literal|0
operator|&&
name|cur_param
operator|!=
literal|0
operator|&&
name|integer_zerop
argument_list|(
name|cur_param
argument_list|)
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"reading through null pointer (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_param
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|cur_param
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|cur_param
operator|=
name|TREE_OPERAND
argument_list|(
name|cur_param
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|cur_param
operator|=
literal|0
expr_stmt|;
comment|/* See if this is an attempt to write into a const type with 		 scanf or with printf "%n".  Note: the writing in happens 		 at the first indirection only, if for example 		 void * const * is passed to scanf %p; passing 		 const void ** is simply passing an incompatible type.  */
if|if
condition|(
name|types
operator|->
name|writing_in_flag
operator|&&
name|i
operator|==
literal|0
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|cur_type
argument_list|)
operator|||
operator|(
name|cur_param
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
operator|(
name|DECL_P
argument_list|(
name|cur_param
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|cur_param
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"writing into constant object (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
comment|/* If there are extra type qualifiers beyond the first 		 indirection, then this makes the types technically 		 incompatible.  */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|pedantic
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|cur_type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|cur_type
argument_list|)
operator|||
name|TYPE_RESTRICT
argument_list|(
name|cur_type
argument_list|)
operator|)
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"extra type qualifiers in format argument (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|types
operator|->
name|pointer_count
operator|==
literal|1
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"format argument is not a pointer (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
else|else
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"format argument is not a pointer to a pointer (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|types
operator|->
name|pointer_count
condition|)
continue|continue;
name|orig_cur_type
operator|=
name|cur_type
expr_stmt|;
name|cur_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|cur_type
argument_list|)
expr_stmt|;
comment|/* Check whether the argument type is a character type.  This leniency 	 only applies to certain formats, flagged with 'c'.       */
if|if
condition|(
name|types
operator|->
name|char_lenient_flag
condition|)
name|char_type_flag
operator|=
operator|(
name|cur_type
operator|==
name|char_type_node
operator|||
name|cur_type
operator|==
name|signed_char_type_node
operator|||
name|cur_type
operator|==
name|unsigned_char_type_node
operator|)
expr_stmt|;
comment|/* Check the type of the "real" argument, if there's a type we want.  */
if|if
condition|(
name|wanted_type
operator|==
name|cur_type
condition|)
continue|continue;
comment|/* If we want `void *', allow any pointer type. 	 (Anything else would already have got a warning.) 	 With -pedantic, only allow pointers to void and to character 	 types.  */
if|if
condition|(
name|wanted_type
operator|==
name|void_type_node
operator|&&
operator|(
operator|!
name|pedantic
operator|||
operator|(
name|i
operator|==
literal|1
operator|&&
name|char_type_flag
operator|)
operator|)
condition|)
continue|continue;
comment|/* Don't warn about differences merely in signedness, unless 	 -pedantic.  With -pedantic, warn if the type is a pointer 	 target and not a character type, and for character types at 	 a second level of indirection.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|wanted_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
operator|!
name|pedantic
operator|||
name|i
operator|==
literal|0
operator|||
operator|(
name|i
operator|==
literal|1
operator|&&
name|char_type_flag
operator|)
operator|)
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|wanted_type
argument_list|)
condition|?
name|wanted_type
operator|==
name|unsigned_type
argument_list|(
name|cur_type
argument_list|)
else|:
name|wanted_type
operator|==
name|signed_type
argument_list|(
name|cur_type
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Likewise, "signed char", "unsigned char" and "char" are 	 equivalent but the above test won't consider them equivalent.  */
if|if
condition|(
name|wanted_type
operator|==
name|char_type_node
operator|&&
operator|(
operator|!
name|pedantic
operator|||
name|i
operator|<
literal|2
operator|)
operator|&&
name|char_type_flag
condition|)
continue|continue;
comment|/* Now we have a type mismatch.  */
block|{
specifier|const
name|char
modifier|*
name|this
decl_stmt|;
specifier|const
name|char
modifier|*
name|that
decl_stmt|;
name|this
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|wanted_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|that
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|orig_cur_type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|orig_cur_type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|orig_cur_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_cur_type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|orig_cur_type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|orig_cur_type
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|that
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|orig_cur_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|that
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|orig_cur_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* A nameless type can't possibly match what the format wants. 	   So there will be a warning for it. 	   Make up a string to describe vaguely what it is.  */
if|if
condition|(
name|that
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig_cur_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|that
operator|=
name|_
argument_list|(
literal|"pointer"
argument_list|)
expr_stmt|;
else|else
name|that
operator|=
name|_
argument_list|(
literal|"different type"
argument_list|)
expr_stmt|;
block|}
comment|/* Make the warning better in case of mismatch of int vs long.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig_cur_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|wanted_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|orig_cur_type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|wanted_type
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|orig_cur_type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|orig_cur_type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|that
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|orig_cur_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|this
argument_list|,
name|that
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* There may be a better name for the format, e.g. size_t, 	       but we should allow for programs with a perverse typedef 	       making size_t something other than what the compiler 	       thinks.  */
if|if
condition|(
name|types
operator|->
name|wanted_type_name
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|types
operator|->
name|wanted_type_name
argument_list|,
name|that
argument_list|)
operator|!=
literal|0
condition|)
name|this
operator|=
name|types
operator|->
name|wanted_type_name
expr_stmt|;
if|if
condition|(
name|types
operator|->
name|name
operator|!=
literal|0
condition|)
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"%s is not type %s (arg %d)"
argument_list|,
name|types
operator|->
name|name
argument_list|,
name|this
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
else|else
name|status_warning
argument_list|(
name|status
argument_list|,
literal|"%s format, %s arg (arg %d)"
argument_list|,
name|this
argument_list|,
name|that
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

