begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Check calls to formatted I/O functions (-Wformat).    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"c-format.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Set format warning options according to a -Wformat=n option.  */
end_comment

begin_function
name|void
name|set_Wformat
parameter_list|(
name|int
name|setting
parameter_list|)
block|{
name|warn_format
operator|=
name|setting
expr_stmt|;
name|warn_format_extra_args
operator|=
name|setting
expr_stmt|;
name|warn_format_zero_length
operator|=
name|setting
expr_stmt|;
if|if
condition|(
name|setting
operator|!=
literal|1
condition|)
block|{
name|warn_format_nonliteral
operator|=
name|setting
expr_stmt|;
name|warn_format_security
operator|=
name|setting
expr_stmt|;
name|warn_format_y2k
operator|=
name|setting
expr_stmt|;
block|}
comment|/* Make sure not to disable -Wnonnull if -Wformat=0 is specified.  */
if|if
condition|(
name|setting
condition|)
name|warn_nonnull
operator|=
name|setting
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle attributes associated with format checking.  */
end_comment

begin_comment
comment|/* This must be in the same order as format_types, except for    format_type_error.  Target-specific format types do not have    matching enum values.  */
end_comment

begin_enum
enum|enum
name|format_type
block|{
name|printf_format_type
block|,
name|asm_fprintf_format_type
block|,
name|gcc_diag_format_type
block|,
name|gcc_tdiag_format_type
block|,
name|gcc_cdiag_format_type
block|,
name|gcc_cxxdiag_format_type
block|,
name|gcc_gfc_format_type
block|,
name|scanf_format_type
block|,
name|strftime_format_type
block|,
name|strfmon_format_type
block|,
name|format_type_error
init|=
operator|-
literal|1
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
name|function_format_info
block|{
name|int
name|format_type
decl_stmt|;
comment|/* type of format (printf, scanf, etc.) */
name|unsigned
name|HOST_WIDE_INT
name|format_num
decl_stmt|;
comment|/* number of format argument */
name|unsigned
name|HOST_WIDE_INT
name|first_arg_num
decl_stmt|;
comment|/* number of first arg (zero for varargs) */
block|}
name|function_format_info
typedef|;
end_typedef

begin_function_decl
specifier|static
name|bool
name|decode_format_attr
parameter_list|(
name|tree
parameter_list|,
name|function_format_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decode_format_type
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|check_format_string
parameter_list|(
name|tree
name|argument
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|format_num
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|get_constant
parameter_list|(
name|tree
name|expr
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|value
parameter_list|,
name|int
name|validated_p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Handle a "format_arg" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|handle_format_arg_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|name
parameter_list|)
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|format_num_expr
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|format_num
init|=
literal|0
decl_stmt|;
name|tree
name|argument
decl_stmt|;
if|if
condition|(
operator|!
name|get_constant
argument_list|(
name|format_num_expr
argument_list|,
operator|&
name|format_num
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"format string has invalid operand number"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|argument
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument
condition|)
block|{
if|if
condition|(
operator|!
name|check_format_string
argument_list|(
name|argument
argument_list|,
name|format_num
argument_list|,
name|flags
argument_list|,
name|no_add_attrs
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_BUILT_IN
operator|)
condition|)
name|error
argument_list|(
literal|"function does not return string type"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Verify that the format_num argument is actually a string, in case    the format attribute is in error.  */
end_comment

begin_function
specifier|static
name|bool
name|check_format_string
parameter_list|(
name|tree
name|argument
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|format_num
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|!=
name|format_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argument
operator|==
literal|0
condition|)
break|break;
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|argument
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_BUILT_IN
operator|)
condition|)
name|error
argument_list|(
literal|"format string argument not a string type"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Verify EXPR is a constant, and store its value.    If validated_p is true there should be no errors.    Returns true on success, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|get_constant
parameter_list|(
name|tree
name|expr
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|value
parameter_list|,
name|int
name|validated_p
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|validated_p
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Decode the arguments to a "format" attribute into a    function_format_info structure.  It is already known that the list    is of the right length.  If VALIDATED_P is true, then these    attributes have already been validated and must not be erroneous;    if false, it will give an error message.  Returns true if the    attributes are successfully decoded, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|decode_format_attr
parameter_list|(
name|tree
name|args
parameter_list|,
name|function_format_info
modifier|*
name|info
parameter_list|,
name|int
name|validated_p
parameter_list|)
block|{
name|tree
name|format_type_id
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|tree
name|format_num_expr
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|first_arg_num_expr
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_type_id
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|validated_p
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"unrecognized format specifier"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|format_type_id
argument_list|)
decl_stmt|;
name|info
operator|->
name|format_type
operator|=
name|decode_format_type
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|format_type
operator|==
name|format_type_error
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|validated_p
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%qE is an unrecognized format function type"
argument_list|,
name|format_type_id
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|get_constant
argument_list|(
name|format_num_expr
argument_list|,
operator|&
name|info
operator|->
name|format_num
argument_list|,
name|validated_p
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"format string has invalid operand number"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|get_constant
argument_list|(
name|first_arg_num_expr
argument_list|,
operator|&
name|info
operator|->
name|first_arg_num
argument_list|,
name|validated_p
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%<...%> has invalid operand number"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
operator|&&
name|info
operator|->
name|first_arg_num
operator|<=
name|info
operator|->
name|format_num
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|validated_p
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"format string argument follows the args to be formatted"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check a call to a format function against a parameter list.  */
end_comment

begin_comment
comment|/* The C standard version C++ is treated as equivalent to    or inheriting from, for the purpose of format features supported.  */
end_comment

begin_define
define|#
directive|define
name|CPLUSPLUS_STD_VER
value|STD_C94
end_define

begin_comment
comment|/* The C standard version we are checking formats against when pedantic.  */
end_comment

begin_define
define|#
directive|define
name|C_STD_VER
value|((int) (c_dialect_cxx ()		   \ 				 ? CPLUSPLUS_STD_VER			   \ 				 : (flag_isoc99				   \ 				    ? STD_C99				   \ 				    : (flag_isoc94 ? STD_C94 : STD_C89))))
end_define

begin_comment
comment|/* The name to give to the standard version we are warning about when    pedantic.  FEATURE_VER is the version in which the feature warned out    appeared, which is higher than C_STD_VER.  */
end_comment

begin_define
define|#
directive|define
name|C_STD_NAME
parameter_list|(
name|FEATURE_VER
parameter_list|)
value|(c_dialect_cxx ()		\ 				 ? "ISO C++"			\ 				 : ((FEATURE_VER) == STD_EXT	\ 				    ? "ISO C"			\ 				    : "ISO C90"))
end_define

begin_comment
comment|/* Adjust a C standard version, which may be STD_C9L, to account for    -Wno-long-long.  Returns other standard versions unchanged.  */
end_comment

begin_define
define|#
directive|define
name|ADJ_STD
parameter_list|(
name|VER
parameter_list|)
value|((int) ((VER) == STD_C9L		      \ 				       ? (warn_long_long ? STD_C99 : STD_C89) \ 				       : (VER)))
end_define

begin_comment
comment|/* Structure describing details of a type expected in format checking,    and the type to check against it.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|format_wanted_type
block|{
comment|/* The type wanted.  */
name|tree
name|wanted_type
decl_stmt|;
comment|/* The name of this type to use in diagnostics.  */
specifier|const
name|char
modifier|*
name|wanted_type_name
decl_stmt|;
comment|/* The level of indirection through pointers at which this type occurs.  */
name|int
name|pointer_count
decl_stmt|;
comment|/* Whether, when pointer_count is 1, to allow any character type when      pedantic, rather than just the character or void type specified.  */
name|int
name|char_lenient_flag
decl_stmt|;
comment|/* Whether the argument, dereferenced once, is written into and so the      argument must not be a pointer to a const-qualified type.  */
name|int
name|writing_in_flag
decl_stmt|;
comment|/* Whether the argument, dereferenced once, is read from and so      must not be a NULL pointer.  */
name|int
name|reading_from_flag
decl_stmt|;
comment|/* If warnings should be of the form "field precision should have      type 'int'", the name to use (in this case "field precision"),      otherwise NULL, for "format expects type 'long'" type      messages.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The actual parameter to check against the wanted type.  */
name|tree
name|param
decl_stmt|;
comment|/* The argument number of that parameter.  */
name|int
name|arg_num
decl_stmt|;
comment|/* The next type to check for this format conversion, or NULL if none.  */
name|struct
name|format_wanted_type
modifier|*
name|next
decl_stmt|;
block|}
name|format_wanted_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|format_length_info
name|printf_length_specs
index|[]
init|=
block|{
block|{
literal|"h"
block|,
name|FMT_LEN_h
block|,
name|STD_C89
block|,
literal|"hh"
block|,
name|FMT_LEN_hh
block|,
name|STD_C99
block|}
block|,
block|{
literal|"l"
block|,
name|FMT_LEN_l
block|,
name|STD_C89
block|,
literal|"ll"
block|,
name|FMT_LEN_ll
block|,
name|STD_C9L
block|}
block|,
block|{
literal|"q"
block|,
name|FMT_LEN_ll
block|,
name|STD_EXT
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"L"
block|,
name|FMT_LEN_L
block|,
name|STD_C89
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"z"
block|,
name|FMT_LEN_z
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"Z"
block|,
name|FMT_LEN_z
block|,
name|STD_EXT
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"t"
block|,
name|FMT_LEN_t
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"j"
block|,
name|FMT_LEN_j
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"H"
block|,
name|FMT_LEN_H
block|,
name|STD_EXT
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"D"
block|,
name|FMT_LEN_D
block|,
name|STD_EXT
block|,
literal|"DD"
block|,
name|FMT_LEN_DD
block|,
name|STD_EXT
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length specifiers valid for asm_fprintf.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|format_length_info
name|asm_fprintf_length_specs
index|[]
init|=
block|{
block|{
literal|"l"
block|,
name|FMT_LEN_l
block|,
name|STD_C89
block|,
literal|"ll"
block|,
name|FMT_LEN_ll
block|,
name|STD_C89
block|}
block|,
block|{
literal|"w"
block|,
name|FMT_LEN_none
block|,
name|STD_C89
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length specifiers valid for GCC diagnostics.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|format_length_info
name|gcc_diag_length_specs
index|[]
init|=
block|{
block|{
literal|"l"
block|,
name|FMT_LEN_l
block|,
name|STD_C89
block|,
literal|"ll"
block|,
name|FMT_LEN_ll
block|,
name|STD_C89
block|}
block|,
block|{
literal|"w"
block|,
name|FMT_LEN_none
block|,
name|STD_C89
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The custom diagnostics all accept the same length specifiers.  */
end_comment

begin_define
define|#
directive|define
name|gcc_tdiag_length_specs
value|gcc_diag_length_specs
end_define

begin_define
define|#
directive|define
name|gcc_cdiag_length_specs
value|gcc_diag_length_specs
end_define

begin_define
define|#
directive|define
name|gcc_cxxdiag_length_specs
value|gcc_diag_length_specs
end_define

begin_comment
comment|/* This differs from printf_length_specs only in that "Z" is not accepted.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|format_length_info
name|scanf_length_specs
index|[]
init|=
block|{
block|{
literal|"h"
block|,
name|FMT_LEN_h
block|,
name|STD_C89
block|,
literal|"hh"
block|,
name|FMT_LEN_hh
block|,
name|STD_C99
block|}
block|,
block|{
literal|"l"
block|,
name|FMT_LEN_l
block|,
name|STD_C89
block|,
literal|"ll"
block|,
name|FMT_LEN_ll
block|,
name|STD_C9L
block|}
block|,
block|{
literal|"q"
block|,
name|FMT_LEN_ll
block|,
name|STD_EXT
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"L"
block|,
name|FMT_LEN_L
block|,
name|STD_C89
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"z"
block|,
name|FMT_LEN_z
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"t"
block|,
name|FMT_LEN_t
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"j"
block|,
name|FMT_LEN_j
block|,
name|STD_C99
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"H"
block|,
name|FMT_LEN_H
block|,
name|STD_EXT
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"D"
block|,
name|FMT_LEN_D
block|,
name|STD_EXT
block|,
literal|"DD"
block|,
name|FMT_LEN_DD
block|,
name|STD_EXT
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All tables for strfmon use STD_C89 everywhere, since -pedantic warnings    make no sense for a format type not part of any C standard version.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|format_length_info
name|strfmon_length_specs
index|[]
init|=
block|{
comment|/* A GNU extension.  */
block|{
literal|"L"
block|,
name|FMT_LEN_L
block|,
name|STD_C89
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|printf_flag_specs
index|[]
init|=
block|{
block|{
literal|' '
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"' ' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the ' ' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'+'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'+' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '+' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'#'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'#' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '#' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'0'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'0' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '0' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'-'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'-' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '-' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'\''
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"''' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the ''' printf flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'I'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'I' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the 'I' printf flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"field width"
argument_list|)
block|,
name|N_
argument_list|(
literal|"field width in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'p'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"precision"
argument_list|)
block|,
name|N_
argument_list|(
literal|"precision in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'L'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"length modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"length modifier in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|printf_flag_pairs
index|[]
init|=
block|{
block|{
literal|' '
block|,
literal|'+'
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'0'
block|,
literal|'-'
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'0'
block|,
literal|'p'
block|,
literal|1
block|,
literal|'i'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|asm_fprintf_flag_specs
index|[]
init|=
block|{
block|{
literal|' '
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"' ' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the ' ' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'+'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'+' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '+' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'#'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'#' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '#' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'0'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'0' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '0' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'-'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'-' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '-' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"field width"
argument_list|)
block|,
name|N_
argument_list|(
literal|"field width in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'p'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"precision"
argument_list|)
block|,
name|N_
argument_list|(
literal|"precision in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'L'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"length modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"length modifier in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|asm_fprintf_flag_pairs
index|[]
init|=
block|{
block|{
literal|' '
block|,
literal|'+'
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'0'
block|,
literal|'-'
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'0'
block|,
literal|'p'
block|,
literal|1
block|,
literal|'i'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|gcc_diag_flag_pairs
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|gcc_tdiag_flag_pairs
value|gcc_diag_flag_pairs
end_define

begin_define
define|#
directive|define
name|gcc_cdiag_flag_pairs
value|gcc_diag_flag_pairs
end_define

begin_define
define|#
directive|define
name|gcc_cxxdiag_flag_pairs
value|gcc_diag_flag_pairs
end_define

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|gcc_gfc_flag_pairs
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|gcc_diag_flag_specs
index|[]
init|=
block|{
block|{
literal|'+'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'+' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '+' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'q'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'q' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the 'q' diagnostic flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'p'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"precision"
argument_list|)
block|,
name|N_
argument_list|(
literal|"precision in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'L'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"length modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"length modifier in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|gcc_tdiag_flag_specs
value|gcc_diag_flag_specs
end_define

begin_define
define|#
directive|define
name|gcc_cdiag_flag_specs
value|gcc_diag_flag_specs
end_define

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|gcc_cxxdiag_flag_specs
index|[]
init|=
block|{
block|{
literal|'+'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'+' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '+' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'#'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'#' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '#' printf flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'q'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'q' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the 'q' diagnostic flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'p'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"precision"
argument_list|)
block|,
name|N_
argument_list|(
literal|"precision in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'L'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"length modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"length modifier in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|scanf_flag_specs
index|[]
init|=
block|{
block|{
literal|'*'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"assignment suppression"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the assignment suppression scanf feature"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'a'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'a' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the 'a' scanf flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"field width"
argument_list|)
block|,
name|N_
argument_list|(
literal|"field width in scanf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'L'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"length modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"length modifier in scanf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'\''
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"''' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the ''' scanf flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'I'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'I' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the 'I' scanf flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|scanf_flag_pairs
index|[]
init|=
block|{
block|{
literal|'*'
block|,
literal|'L'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|strftime_flag_specs
index|[]
init|=
block|{
block|{
literal|'_'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'_' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '_' strftime flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'-'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'-' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '-' strftime flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'0'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'0' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '0' strftime flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'^'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'^' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '^' strftime flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'#'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'#' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '#' strftime flag"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"field width"
argument_list|)
block|,
name|N_
argument_list|(
literal|"field width in strftime format"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|'E'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'E' modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the 'E' strftime modifier"
argument_list|)
block|,
name|STD_C99
block|}
block|,
block|{
literal|'O'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'O' modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the 'O' strftime modifier"
argument_list|)
block|,
name|STD_C99
block|}
block|,
block|{
literal|'O'
block|,
literal|'o'
block|,
literal|0
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"the 'O' modifier"
argument_list|)
block|,
name|STD_EXT
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|strftime_flag_pairs
index|[]
init|=
block|{
block|{
literal|'E'
block|,
literal|'O'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'_'
block|,
literal|'-'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'_'
block|,
literal|'0'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'-'
block|,
literal|'0'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'^'
block|,
literal|'#'
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|strfmon_flag_specs
index|[]
init|=
block|{
block|{
literal|'='
block|,
literal|0
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"fill character"
argument_list|)
block|,
name|N_
argument_list|(
literal|"fill character in strfmon format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'^'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'^' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '^' strfmon flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'+'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'+' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '+' strfmon flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'('
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'(' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '(' strfmon flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'!'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'!' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '!' strfmon flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'-'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"'-' flag"
argument_list|)
block|,
name|N_
argument_list|(
literal|"the '-' strfmon flag"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"field width"
argument_list|)
block|,
name|N_
argument_list|(
literal|"field width in strfmon format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'#'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"left precision"
argument_list|)
block|,
name|N_
argument_list|(
literal|"left precision in strfmon format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'p'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"right precision"
argument_list|)
block|,
name|N_
argument_list|(
literal|"right precision in strfmon format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'L'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"length modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"length modifier in strfmon format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|strfmon_flag_pairs
index|[]
init|=
block|{
block|{
literal|'+'
block|,
literal|'('
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|print_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"di"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|T99_SC
block|,
name|T89_S
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|TEX_LL
block|,
name|T99_SST
block|,
name|T99_PD
block|,
name|T99_IM
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp0 +'I"
block|,
literal|"i"
block|,
name|NULL
block|}
block|,
block|{
literal|"oxX"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|T99_UC
block|,
name|T89_US
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|TEX_ULL
block|,
name|T99_ST
block|,
name|T99_UPD
block|,
name|T99_UIM
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp0#"
block|,
literal|"i"
block|,
name|NULL
block|}
block|,
block|{
literal|"u"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|T99_UC
block|,
name|T89_US
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|TEX_ULL
block|,
name|T99_ST
block|,
name|T99_UPD
block|,
name|T99_UIM
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp0'I"
block|,
literal|"i"
block|,
name|NULL
block|}
block|,
block|{
literal|"fgG"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_D
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T99_D
block|,
name|BADLEN
block|,
name|T89_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|TEX_D32
block|,
name|TEX_D64
block|,
name|TEX_D128
block|}
block|,
literal|"-wp0 +#'I"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"eE"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_D
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T99_D
block|,
name|BADLEN
block|,
name|T89_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|TEX_D32
block|,
name|TEX_D64
block|,
name|TEX_D128
block|}
block|,
literal|"-wp0 +#I"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T94_WI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-w"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T94_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp"
block|,
literal|"cR"
block|,
name|NULL
block|}
block|,
block|{
literal|"p"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-w"
block|,
literal|"c"
block|,
name|NULL
block|}
block|,
block|{
literal|"n"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|T99_SC
block|,
name|T89_S
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|BADLEN
block|,
name|T99_SST
block|,
name|T99_PD
block|,
name|T99_IM
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|""
block|,
literal|"W"
block|,
name|NULL
block|}
block|,
comment|/* C99 conversion specifiers.  */
block|{
literal|"F"
block|,
literal|0
block|,
name|STD_C99
block|,
block|{
name|T99_D
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T99_D
block|,
name|BADLEN
block|,
name|T99_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|TEX_D32
block|,
name|TEX_D64
block|,
name|TEX_D128
block|}
block|,
literal|"-wp0 +#'I"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"aA"
block|,
literal|0
block|,
name|STD_C99
block|,
block|{
name|T99_D
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T99_D
block|,
name|BADLEN
block|,
name|T99_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp0 +#"
block|,
literal|""
block|,
name|NULL
block|}
block|,
comment|/* X/Open conversion specifiers.  */
block|{
literal|"C"
block|,
literal|0
block|,
name|STD_EXT
block|,
block|{
name|TEX_WI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-w"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"S"
block|,
literal|1
block|,
name|STD_EXT
block|,
block|{
name|TEX_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp"
block|,
literal|"R"
block|,
name|NULL
block|}
block|,
comment|/* GNU conversion specifiers.  */
block|{
literal|"m"
block|,
literal|0
block|,
name|STD_EXT
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|asm_fprintf_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"di"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp0 +"
block|,
literal|"i"
block|,
name|NULL
block|}
block|,
block|{
literal|"oxX"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp0#"
block|,
literal|"i"
block|,
name|NULL
block|}
block|,
block|{
literal|"u"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp0"
block|,
literal|"i"
block|,
name|NULL
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-w"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"-wp"
block|,
literal|"cR"
block|,
name|NULL
block|}
block|,
comment|/* asm_fprintf conversion specifiers.  */
block|{
literal|"O"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"R"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"I"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"L"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"U"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"r"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"@"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|gcc_diag_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"di"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"ox"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"u"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"pq"
block|,
literal|"cR"
block|,
name|NULL
block|}
block|,
block|{
literal|"p"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|"c"
block|,
name|NULL
block|}
block|,
comment|/* Custom conversion specifiers.  */
comment|/* %H will require "location_t" at runtime.  */
block|{
literal|"H"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
comment|/* These will require a "tree" at runtime.  */
block|{
literal|"J"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"<>'"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"m"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|gcc_tdiag_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"di"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"ox"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"u"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"pq"
block|,
literal|"cR"
block|,
name|NULL
block|}
block|,
block|{
literal|"p"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|"c"
block|,
name|NULL
block|}
block|,
comment|/* Custom conversion specifiers.  */
comment|/* %H will require "location_t" at runtime.  */
block|{
literal|"H"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
comment|/* These will require a "tree" at runtime.  */
block|{
literal|"DFJT"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q+"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"<>'"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"m"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|gcc_cdiag_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"di"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"ox"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"u"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"pq"
block|,
literal|"cR"
block|,
name|NULL
block|}
block|,
block|{
literal|"p"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|"c"
block|,
name|NULL
block|}
block|,
comment|/* Custom conversion specifiers.  */
comment|/* %H will require "location_t" at runtime.  */
block|{
literal|"H"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
comment|/* These will require a "tree" at runtime.  */
block|{
literal|"DEFJT"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q+"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"<>'"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"m"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|gcc_cxxdiag_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"di"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"ox"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"u"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"pq"
block|,
literal|"cR"
block|,
name|NULL
block|}
block|,
block|{
literal|"p"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|"c"
block|,
name|NULL
block|}
block|,
comment|/* Custom conversion specifiers.  */
comment|/* %H will require "location_t" at runtime.  */
block|{
literal|"H"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
comment|/* These will require a "tree" at runtime.  */
block|{
literal|"ADEFJTV"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q+#"
block|,
literal|""
block|,
name|NULL
block|}
block|,
comment|/* These accept either an 'int' or an 'enum tree_code' (which is handled as an 'int'.)  */
block|{
literal|"CLOPQ"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"<>'"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"m"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|"q"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|gcc_gfc_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"di"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|""
block|,
literal|"cR"
block|,
name|NULL
block|}
block|,
comment|/* gfc conversion specifiers.  */
block|{
literal|"C"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOARGUMENTS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
comment|/* This will require a "locus" at runtime.  */
block|{
literal|"L"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|""
block|,
literal|"R"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|scan_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"di"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|T99_SC
block|,
name|T89_S
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|TEX_LL
block|,
name|T99_SST
block|,
name|T99_PD
block|,
name|T99_IM
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w'I"
block|,
literal|"W"
block|,
name|NULL
block|}
block|,
block|{
literal|"u"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|T99_UC
block|,
name|T89_US
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|TEX_ULL
block|,
name|T99_ST
block|,
name|T99_UPD
block|,
name|T99_UIM
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w'I"
block|,
literal|"W"
block|,
name|NULL
block|}
block|,
block|{
literal|"oxX"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|T99_UC
block|,
name|T89_US
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|TEX_ULL
block|,
name|T99_ST
block|,
name|T99_UPD
block|,
name|T99_UIM
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w"
block|,
literal|"W"
block|,
name|NULL
block|}
block|,
block|{
literal|"efgEG"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_F
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_D
block|,
name|BADLEN
block|,
name|T89_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|TEX_D32
block|,
name|TEX_D64
block|,
name|TEX_D128
block|}
block|,
literal|"*w'"
block|,
literal|"W"
block|,
name|NULL
block|}
block|,
block|{
literal|"c"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T94_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w"
block|,
literal|"cW"
block|,
name|NULL
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T94_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*aw"
block|,
literal|"cW"
block|,
name|NULL
block|}
block|,
block|{
literal|"["
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T94_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*aw"
block|,
literal|"cW["
block|,
name|NULL
block|}
block|,
block|{
literal|"p"
block|,
literal|2
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w"
block|,
literal|"W"
block|,
name|NULL
block|}
block|,
block|{
literal|"n"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|T99_SC
block|,
name|T89_S
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|BADLEN
block|,
name|T99_SST
block|,
name|T99_PD
block|,
name|T99_IM
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|""
block|,
literal|"W"
block|,
name|NULL
block|}
block|,
comment|/* C99 conversion specifiers.  */
block|{
literal|"F"
block|,
literal|1
block|,
name|STD_C99
block|,
block|{
name|T99_F
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T99_D
block|,
name|BADLEN
block|,
name|T99_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|TEX_D32
block|,
name|TEX_D64
block|,
name|TEX_D128
block|}
block|,
literal|"*w'"
block|,
literal|"W"
block|,
name|NULL
block|}
block|,
block|{
literal|"aA"
block|,
literal|1
block|,
name|STD_C99
block|,
block|{
name|T99_F
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T99_D
block|,
name|BADLEN
block|,
name|T99_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w'"
block|,
literal|"W"
block|,
name|NULL
block|}
block|,
comment|/* X/Open conversion specifiers.  */
block|{
literal|"C"
block|,
literal|1
block|,
name|STD_EXT
block|,
block|{
name|TEX_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*w"
block|,
literal|"W"
block|,
name|NULL
block|}
block|,
block|{
literal|"S"
block|,
literal|1
block|,
name|STD_EXT
block|,
block|{
name|TEX_W
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"*aw"
block|,
literal|"W"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|time_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"ABZab"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"^#"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"cx"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"E"
block|,
literal|"3"
block|,
name|NULL
block|}
block|,
block|{
literal|"HIMSUWdmw"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"-_0Ow"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"j"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"-_0Ow"
block|,
literal|"o"
block|,
name|NULL
block|}
block|,
block|{
literal|"p"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"#"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"X"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"E"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"y"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"EO-_0w"
block|,
literal|"4"
block|,
name|NULL
block|}
block|,
block|{
literal|"Y"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|"-_0EOw"
block|,
literal|"o"
block|,
name|NULL
block|}
block|,
block|{
literal|"%"
block|,
literal|0
block|,
name|STD_C89
block|,
name|NOLENGTHS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
comment|/* C99 conversion specifiers.  */
block|{
literal|"C"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"-_0EOw"
block|,
literal|"o"
block|,
name|NULL
block|}
block|,
block|{
literal|"D"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|""
block|,
literal|"2"
block|,
name|NULL
block|}
block|,
block|{
literal|"eVu"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"-_0Ow"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"FRTnrt"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"g"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"O-_0w"
block|,
literal|"2o"
block|,
name|NULL
block|}
block|,
block|{
literal|"G"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"-_0Ow"
block|,
literal|"o"
block|,
name|NULL
block|}
block|,
block|{
literal|"h"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"^#"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"z"
block|,
literal|0
block|,
name|STD_C99
block|,
name|NOLENGTHS
block|,
literal|"O"
block|,
literal|"o"
block|,
name|NULL
block|}
block|,
comment|/* GNU conversion specifiers.  */
block|{
literal|"kls"
block|,
literal|0
block|,
name|STD_EXT
block|,
name|NOLENGTHS
block|,
literal|"-_0Ow"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"P"
block|,
literal|0
block|,
name|STD_EXT
block|,
name|NOLENGTHS
block|,
literal|""
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|monetary_char_table
index|[]
init|=
block|{
block|{
literal|"in"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_D
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_LD
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"=^+(!-w#p"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This must be in the same order as enum format_type.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|format_kind_info
name|format_types_orig
index|[]
init|=
block|{
block|{
literal|"printf"
block|,
name|printf_length_specs
block|,
name|print_char_table
block|,
literal|" +#0-'I"
block|,
name|NULL
block|,
name|printf_flag_specs
block|,
name|printf_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
operator||
name|FMT_FLAG_DOLLAR_MULTIPLE
operator||
name|FMT_FLAG_USE_DOLLAR
operator||
name|FMT_FLAG_EMPTY_PREC_OK
block|,
literal|'w'
block|,
literal|0
block|,
literal|'p'
block|,
literal|0
block|,
literal|'L'
block|,
operator|&
name|integer_type_node
block|,
operator|&
name|integer_type_node
block|}
block|,
block|{
literal|"asm_fprintf"
block|,
name|asm_fprintf_length_specs
block|,
name|asm_fprintf_char_table
block|,
literal|" +#0-"
block|,
name|NULL
block|,
name|asm_fprintf_flag_specs
block|,
name|asm_fprintf_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
operator||
name|FMT_FLAG_EMPTY_PREC_OK
block|,
literal|'w'
block|,
literal|0
block|,
literal|'p'
block|,
literal|0
block|,
literal|'L'
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"gcc_diag"
block|,
name|gcc_diag_length_specs
block|,
name|gcc_diag_char_table
block|,
literal|"q+"
block|,
name|NULL
block|,
name|gcc_diag_flag_specs
block|,
name|gcc_diag_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
block|,
literal|0
block|,
literal|0
block|,
literal|'p'
block|,
literal|0
block|,
literal|'L'
block|,
name|NULL
block|,
operator|&
name|integer_type_node
block|}
block|,
block|{
literal|"gcc_tdiag"
block|,
name|gcc_tdiag_length_specs
block|,
name|gcc_tdiag_char_table
block|,
literal|"q+"
block|,
name|NULL
block|,
name|gcc_tdiag_flag_specs
block|,
name|gcc_tdiag_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
block|,
literal|0
block|,
literal|0
block|,
literal|'p'
block|,
literal|0
block|,
literal|'L'
block|,
name|NULL
block|,
operator|&
name|integer_type_node
block|}
block|,
block|{
literal|"gcc_cdiag"
block|,
name|gcc_cdiag_length_specs
block|,
name|gcc_cdiag_char_table
block|,
literal|"q+"
block|,
name|NULL
block|,
name|gcc_cdiag_flag_specs
block|,
name|gcc_cdiag_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
block|,
literal|0
block|,
literal|0
block|,
literal|'p'
block|,
literal|0
block|,
literal|'L'
block|,
name|NULL
block|,
operator|&
name|integer_type_node
block|}
block|,
block|{
literal|"gcc_cxxdiag"
block|,
name|gcc_cxxdiag_length_specs
block|,
name|gcc_cxxdiag_char_table
block|,
literal|"q+#"
block|,
name|NULL
block|,
name|gcc_cxxdiag_flag_specs
block|,
name|gcc_cxxdiag_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
block|,
literal|0
block|,
literal|0
block|,
literal|'p'
block|,
literal|0
block|,
literal|'L'
block|,
name|NULL
block|,
operator|&
name|integer_type_node
block|}
block|,
block|{
literal|"gcc_gfc"
block|,
name|NULL
block|,
name|gcc_gfc_char_table
block|,
literal|""
block|,
name|NULL
block|,
name|NULL
block|,
name|gcc_gfc_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"scanf"
block|,
name|scanf_length_specs
block|,
name|scan_char_table
block|,
literal|"*'I"
block|,
name|NULL
block|,
name|scanf_flag_specs
block|,
name|scanf_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
operator||
name|FMT_FLAG_SCANF_A_KLUDGE
operator||
name|FMT_FLAG_USE_DOLLAR
operator||
name|FMT_FLAG_ZERO_WIDTH_BAD
operator||
name|FMT_FLAG_DOLLAR_GAP_POINTER_OK
block|,
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
literal|'*'
block|,
literal|'L'
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"strftime"
block|,
name|NULL
block|,
name|time_char_table
block|,
literal|"_-0^#"
block|,
literal|"EO"
block|,
name|strftime_flag_specs
block|,
name|strftime_flag_pairs
block|,
name|FMT_FLAG_FANCY_PERCENT_OK
block|,
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"strfmon"
block|,
name|strfmon_length_specs
block|,
name|monetary_char_table
block|,
literal|"=^+(!-"
block|,
name|NULL
block|,
name|strfmon_flag_specs
block|,
name|strfmon_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
block|,
literal|'w'
block|,
literal|'#'
block|,
literal|'p'
block|,
literal|0
block|,
literal|'L'
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This layer of indirection allows GCC to reassign format_types with    new data if necessary, while still allowing the original data to be    const.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|format_kind_info
modifier|*
name|format_types
init|=
name|format_types_orig
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We can modify this one.  We also add target-specific format types    to the end of the array.  */
end_comment

begin_decl_stmt
specifier|static
name|format_kind_info
modifier|*
name|dynamic_format_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_format_types
init|=
name|ARRAY_SIZE
argument_list|(
name|format_types_orig
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure detailing the results of checking a format function call    where the format expression may be a conditional expression with    many leaves resulting from nested conditional expressions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Number of leaves of the format argument that could not be checked      as they were not string literals.  */
name|int
name|number_non_literal
decl_stmt|;
comment|/* Number of leaves of the format argument that were null pointers or      string literals, but had extra format arguments.  */
name|int
name|number_extra_args
decl_stmt|;
comment|/* Number of leaves of the format argument that were null pointers or      string literals, but had extra format arguments and used $ operand      numbers.  */
name|int
name|number_dollar_extra_args
decl_stmt|;
comment|/* Number of leaves of the format argument that were wide string      literals.  */
name|int
name|number_wide
decl_stmt|;
comment|/* Number of leaves of the format argument that were empty strings.  */
name|int
name|number_empty
decl_stmt|;
comment|/* Number of leaves of the format argument that were unterminated      strings.  */
name|int
name|number_unterminated
decl_stmt|;
comment|/* Number of leaves of the format argument that were not counted above.  */
name|int
name|number_other
decl_stmt|;
block|}
name|format_check_results
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|format_check_results
modifier|*
name|res
decl_stmt|;
name|function_format_info
modifier|*
name|info
decl_stmt|;
name|tree
name|params
decl_stmt|;
block|}
name|format_check_context
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|check_format_info
parameter_list|(
name|function_format_info
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_format_arg
parameter_list|(
name|void
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_format_info_main
parameter_list|(
name|format_check_results
modifier|*
parameter_list|,
name|function_format_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_dollar_format_checking
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|maybe_read_dollar_number
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
specifier|const
name|format_kind_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|avoid_dollar_number
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_dollar_format_checking
parameter_list|(
name|format_check_results
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|format_flag_spec
modifier|*
name|get_flag_spec
parameter_list|(
specifier|const
name|format_flag_spec
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_format_types
parameter_list|(
name|format_wanted_type
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|format_type_warning
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Decode a format type from a string, returning the type, or    format_type_error if not valid, in which case the caller should print an    error message.  */
end_comment

begin_function
specifier|static
name|int
name|decode_format_type
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|slen
decl_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_format_types
condition|;
name|i
operator|++
control|)
block|{
name|int
name|alen
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|format_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
name|i
return|;
name|alen
operator|=
name|strlen
argument_list|(
name|format_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|==
name|alen
operator|+
literal|4
operator|&&
name|s
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|s
index|[
name|slen
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|s
index|[
name|slen
operator|-
literal|2
index|]
operator|==
literal|'_'
operator|&&
operator|!
name|strncmp
argument_list|(
name|s
operator|+
literal|2
argument_list|,
name|format_types
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|alen
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
name|format_type_error
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check the argument list of a call to printf, scanf, etc.    ATTRS are the attributes on the function type.    PARAMS is the list of argument values.  Also, if -Wmissing-format-attribute,    warn for calls to vprintf or vscanf in functions with no such format    attribute themselves.  */
end_comment

begin_function
name|void
name|check_function_format
parameter_list|(
name|tree
name|attrs
parameter_list|,
name|tree
name|params
parameter_list|)
block|{
name|tree
name|a
decl_stmt|;
comment|/* See if this function has any format attributes.  */
for|for
control|(
name|a
operator|=
name|attrs
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"format"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Yup; check it.  */
name|function_format_info
name|info
decl_stmt|;
name|decode_format_attr
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
operator|&
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_format
condition|)
name|check_format_info
argument_list|(
operator|&
name|info
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_missing_format_attribute
operator|&&
name|info
operator|.
name|first_arg_num
operator|==
literal|0
operator|&&
operator|(
name|format_types
index|[
name|info
operator|.
name|format_type
index|]
operator|.
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_ARG_CONVERT
operator|)
condition|)
block|{
name|tree
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
init|;
name|c
condition|;
name|c
operator|=
name|TREE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"format"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|c
argument_list|)
argument_list|)
operator|&&
operator|(
name|decode_format_type
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|info
operator|.
name|format_type
operator|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Check if the current function has a parameter to which 		     the format attribute could be attached; if not, it 		     can't be a candidate for a format attribute, despite 		     the vprintf-like or vscanf-like call.  */
name|tree
name|args
decl_stmt|;
for|for
control|(
name|args
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|args
operator|!=
literal|0
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|args
operator|!=
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wmissing_format_attribute
argument_list|,
literal|"function might "
literal|"be possible candidate for %qs format attribute"
argument_list|,
name|format_types
index|[
name|info
operator|.
name|format_type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Variables used by the checking of $ operand number formats.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dollar_arguments_used
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dollar_arguments_pointer_p
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dollar_arguments_alloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dollar_arguments_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dollar_first_arg_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dollar_max_arg_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dollar_format_warned
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the checking for a format string that may contain $    parameter number specifications; we will need to keep track of whether    each parameter has been used.  FIRST_ARG_NUM is the number of the first    argument that is a parameter to the format, or 0 for a vprintf-style    function; PARAMS is the list of arguments starting at this argument.  */
end_comment

begin_function
specifier|static
name|void
name|init_dollar_format_checking
parameter_list|(
name|int
name|first_arg_num
parameter_list|,
name|tree
name|params
parameter_list|)
block|{
name|tree
name|oparams
init|=
name|params
decl_stmt|;
name|dollar_first_arg_num
operator|=
name|first_arg_num
expr_stmt|;
name|dollar_arguments_count
operator|=
literal|0
expr_stmt|;
name|dollar_max_arg_used
operator|=
literal|0
expr_stmt|;
name|dollar_format_warned
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first_arg_num
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|params
condition|)
block|{
name|dollar_arguments_count
operator|++
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dollar_arguments_alloc
operator|<
name|dollar_arguments_count
condition|)
block|{
if|if
condition|(
name|dollar_arguments_used
condition|)
name|free
argument_list|(
name|dollar_arguments_used
argument_list|)
expr_stmt|;
if|if
condition|(
name|dollar_arguments_pointer_p
condition|)
name|free
argument_list|(
name|dollar_arguments_pointer_p
argument_list|)
expr_stmt|;
name|dollar_arguments_alloc
operator|=
name|dollar_arguments_count
expr_stmt|;
name|dollar_arguments_used
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|dollar_arguments_alloc
argument_list|)
expr_stmt|;
name|dollar_arguments_pointer_p
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|dollar_arguments_alloc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dollar_arguments_alloc
condition|)
block|{
name|memset
argument_list|(
name|dollar_arguments_used
argument_list|,
literal|0
argument_list|,
name|dollar_arguments_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_arg_num
operator|>
literal|0
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|params
operator|=
name|oparams
expr_stmt|;
while|while
condition|(
name|params
condition|)
block|{
name|dollar_arguments_pointer_p
index|[
name|i
index|]
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Look for a decimal number followed by a $ in *FORMAT.  If DOLLAR_NEEDED    is set, it is an error if one is not found; otherwise, it is OK.  If    such a number is found, check whether it is within range and mark that    numbered operand as being used for later checking.  Returns the operand    number if found and within range, zero if no such number was found and    this is OK, or -1 on error.  PARAMS points to the first operand of the    format; PARAM_PTR is made to point to the parameter referred to.  If    a $ format is found, *FORMAT is updated to point just after it.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_read_dollar_number
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|format
parameter_list|,
name|int
name|dollar_needed
parameter_list|,
name|tree
name|params
parameter_list|,
name|tree
modifier|*
name|param_ptr
parameter_list|,
specifier|const
name|format_kind_info
modifier|*
name|fki
parameter_list|)
block|{
name|int
name|argnum
decl_stmt|;
name|int
name|overflow_flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|fcp
init|=
operator|*
name|format
decl_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|fcp
argument_list|)
condition|)
block|{
if|if
condition|(
name|dollar_needed
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"missing $ operand number in format"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
name|argnum
operator|=
literal|0
expr_stmt|;
name|overflow_flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|fcp
argument_list|)
condition|)
block|{
name|int
name|nargnum
decl_stmt|;
name|nargnum
operator|=
literal|10
operator|*
name|argnum
operator|+
operator|(
operator|*
name|fcp
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|nargnum
operator|<
literal|0
operator|||
name|nargnum
operator|/
literal|10
operator|!=
name|argnum
condition|)
name|overflow_flag
operator|=
literal|1
expr_stmt|;
name|argnum
operator|=
name|nargnum
expr_stmt|;
name|fcp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|fcp
operator|!=
literal|'$'
condition|)
block|{
if|if
condition|(
name|dollar_needed
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"missing $ operand number in format"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
operator|*
name|format
operator|=
name|fcp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|dollar_format_warned
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%s does not support %%n$ operand number formats"
argument_list|,
name|C_STD_NAME
argument_list|(
name|STD_EXT
argument_list|)
argument_list|)
expr_stmt|;
name|dollar_format_warned
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|overflow_flag
operator|||
name|argnum
operator|==
literal|0
operator|||
operator|(
name|dollar_first_arg_num
operator|&&
name|argnum
operator|>
name|dollar_arguments_count
operator|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"operand number out of range in format"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|argnum
operator|>
name|dollar_max_arg_used
condition|)
name|dollar_max_arg_used
operator|=
name|argnum
expr_stmt|;
comment|/* For vprintf-style functions we may need to allocate more memory to      track which arguments are used.  */
while|while
condition|(
name|dollar_arguments_alloc
operator|<
name|dollar_max_arg_used
condition|)
block|{
name|int
name|nalloc
decl_stmt|;
name|nalloc
operator|=
literal|2
operator|*
name|dollar_arguments_alloc
operator|+
literal|16
expr_stmt|;
name|dollar_arguments_used
operator|=
name|XRESIZEVEC
argument_list|(
name|char
argument_list|,
name|dollar_arguments_used
argument_list|,
name|nalloc
argument_list|)
expr_stmt|;
name|dollar_arguments_pointer_p
operator|=
name|XRESIZEVEC
argument_list|(
name|char
argument_list|,
name|dollar_arguments_pointer_p
argument_list|,
name|nalloc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dollar_arguments_used
operator|+
name|dollar_arguments_alloc
argument_list|,
literal|0
argument_list|,
name|nalloc
operator|-
name|dollar_arguments_alloc
argument_list|)
expr_stmt|;
name|dollar_arguments_alloc
operator|=
name|nalloc
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_DOLLAR_MULTIPLE
operator|)
operator|&&
name|dollar_arguments_used
index|[
name|argnum
operator|-
literal|1
index|]
operator|==
literal|1
condition|)
block|{
name|dollar_arguments_used
index|[
name|argnum
operator|-
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"format argument %d used more than once in %s format"
argument_list|,
name|argnum
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|dollar_arguments_used
index|[
name|argnum
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dollar_first_arg_num
condition|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|param_ptr
operator|=
name|params
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argnum
operator|&&
operator|*
name|param_ptr
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
operator|*
name|param_ptr
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|param_ptr
argument_list|)
expr_stmt|;
comment|/* This case shouldn't be caught here.  */
name|gcc_assert
argument_list|(
operator|*
name|param_ptr
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|param_ptr
operator|=
literal|0
expr_stmt|;
return|return
name|argnum
return|;
block|}
end_function

begin_comment
comment|/* Ensure that FORMAT does not start with a decimal number followed by    a $; give a diagnostic and return true if it does, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|avoid_dollar_number
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|format
argument_list|)
condition|)
return|return
name|false
return|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format
argument_list|)
condition|)
name|format
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|format
operator|==
literal|'$'
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"$ operand number used after format without operand number"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Finish the checking for a format string that used $ operand number formats    instead of non-$ formats.  We check for unused operands before used ones    (a serious error, since the implementation of the format function    can't know what types to pass to va_arg to find the later arguments).    and for unused operands at the end of the format (if we know how many    arguments the format had, so not for vprintf).  If there were operand    numbers out of range on a non-vprintf-style format, we won't have reached    here.  If POINTER_GAP_OK, unused arguments are OK if all arguments are    pointers.  */
end_comment

begin_function
specifier|static
name|void
name|finish_dollar_format_checking
parameter_list|(
name|format_check_results
modifier|*
name|res
parameter_list|,
name|int
name|pointer_gap_ok
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|found_pointer_gap
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dollar_max_arg_used
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dollar_arguments_used
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|pointer_gap_ok
operator|&&
operator|(
name|dollar_first_arg_num
operator|==
literal|0
operator|||
name|dollar_arguments_pointer_p
index|[
name|i
index|]
operator|)
condition|)
name|found_pointer_gap
operator|=
name|true
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"format argument %d unused before used argument %d in $-style format"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|dollar_max_arg_used
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found_pointer_gap
operator|||
operator|(
name|dollar_first_arg_num
operator|&&
name|dollar_max_arg_used
operator|<
name|dollar_arguments_count
operator|)
condition|)
block|{
name|res
operator|->
name|number_other
operator|--
expr_stmt|;
name|res
operator|->
name|number_dollar_extra_args
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Retrieve the specification for a format flag.  SPEC contains the    specifications for format flags for the applicable kind of format.    FLAG is the flag in question.  If PREDICATES is NULL, the basic    spec for that flag must be retrieved and must exist.  If    PREDICATES is not NULL, it is a string listing possible predicates    for the spec entry; if an entry predicated on any of these is    found, it is returned, otherwise NULL is returned.  */
end_comment

begin_function
specifier|static
specifier|const
name|format_flag_spec
modifier|*
name|get_flag_spec
parameter_list|(
specifier|const
name|format_flag_spec
modifier|*
name|spec
parameter_list|,
name|int
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|predicates
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|spec
index|[
name|i
index|]
operator|.
name|flag_char
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|.
name|flag_char
operator|!=
name|flag
condition|)
continue|continue;
if|if
condition|(
name|predicates
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|.
name|predicate
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|predicates
argument_list|,
name|spec
index|[
name|i
index|]
operator|.
name|predicate
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|&
name|spec
index|[
name|i
index|]
return|;
block|}
elseif|else
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|.
name|predicate
operator|==
literal|0
condition|)
return|return
operator|&
name|spec
index|[
name|i
index|]
return|;
block|}
name|gcc_assert
argument_list|(
name|predicates
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Check the argument list of a call to printf, scanf, etc.    INFO points to the function_format_info structure.    PARAMS is the list of argument values.  */
end_comment

begin_function
specifier|static
name|void
name|check_format_info
parameter_list|(
name|function_format_info
modifier|*
name|info
parameter_list|,
name|tree
name|params
parameter_list|)
block|{
name|format_check_context
name|format_ctx
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|arg_num
decl_stmt|;
name|tree
name|format_tree
decl_stmt|;
name|format_check_results
name|res
decl_stmt|;
comment|/* Skip to format argument.  If the argument isn't available, there's      no work for us to do; prototype checking will catch the problem.  */
for|for
control|(
name|arg_num
operator|=
literal|1
init|;
condition|;
operator|++
name|arg_num
control|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|arg_num
operator|==
name|info
operator|->
name|format_num
condition|)
break|break;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
name|format_tree
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_tree
operator|==
literal|0
condition|)
return|return;
name|res
operator|.
name|number_non_literal
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_extra_args
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_dollar_extra_args
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_wide
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_empty
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_unterminated
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|number_other
operator|=
literal|0
expr_stmt|;
name|format_ctx
operator|.
name|res
operator|=
operator|&
name|res
expr_stmt|;
name|format_ctx
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|format_ctx
operator|.
name|params
operator|=
name|params
expr_stmt|;
name|check_function_arguments_recurse
argument_list|(
name|check_format_arg
argument_list|,
operator|&
name|format_ctx
argument_list|,
name|format_tree
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|number_non_literal
operator|>
literal|0
condition|)
block|{
comment|/* Functions taking a va_list normally pass a non-literal format 	 string.  These functions typically are declared with 	 first_arg_num == 0, so avoid warning in those cases.  */
if|if
condition|(
operator|!
operator|(
name|format_types
index|[
name|info
operator|->
name|format_type
index|]
operator|.
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_ARG_CONVERT
operator|)
condition|)
block|{
comment|/* For strftime-like formats, warn for not checking the format 	     string; but there are no arguments to check.  */
name|warning
argument_list|(
name|OPT_Wformat_nonliteral
argument_list|,
literal|"format not a string literal, format string not checked"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
comment|/* If there are no arguments for the format at all, we may have 	     printf (foo) which is likely to be a security hole.  */
while|while
condition|(
name|arg_num
operator|+
literal|1
operator|<
name|info
operator|->
name|first_arg_num
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
break|break;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|==
literal|0
operator|&&
name|warn_format_security
condition|)
name|warning
argument_list|(
name|OPT_Wformat_security
argument_list|,
literal|"format not a string literal and no format arguments"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|params
operator|==
literal|0
operator|&&
name|warn_format_nonliteral
condition|)
name|warning
argument_list|(
name|OPT_Wformat_nonliteral
argument_list|,
literal|"format not a string literal and no format arguments"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wformat_nonliteral
argument_list|,
literal|"format not a string literal, argument types not checked"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there were extra arguments to the format, normally warn.  However,      the standard does say extra arguments are ignored, so in the specific      case where we have multiple leaves (conditional expressions or      ngettext) allow extra arguments if at least one leaf didn't have extra      arguments, but was otherwise OK (either non-literal or checked OK).      If the format is an empty string, this should be counted similarly to the      case of extra format arguments.  */
if|if
condition|(
name|res
operator|.
name|number_extra_args
operator|>
literal|0
operator|&&
name|res
operator|.
name|number_non_literal
operator|==
literal|0
operator|&&
name|res
operator|.
name|number_other
operator|==
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wformat_extra_args
argument_list|,
literal|"too many arguments for format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|number_dollar_extra_args
operator|>
literal|0
operator|&&
name|res
operator|.
name|number_non_literal
operator|==
literal|0
operator|&&
name|res
operator|.
name|number_other
operator|==
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wformat_extra_args
argument_list|,
literal|"unused arguments in $-style format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|number_empty
operator|>
literal|0
operator|&&
name|res
operator|.
name|number_non_literal
operator|==
literal|0
operator|&&
name|res
operator|.
name|number_other
operator|==
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wformat_zero_length
argument_list|,
literal|"zero-length %s format string"
argument_list|,
name|format_types
index|[
name|info
operator|->
name|format_type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|number_wide
operator|>
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"format is a wide character string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|number_unterminated
operator|>
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"unterminated format string"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback from check_function_arguments_recurse to check a    format string.  FORMAT_TREE is the format parameter.  ARG_NUM    is the number of the format argument.  CTX points to a    format_check_context.  */
end_comment

begin_function
specifier|static
name|void
name|check_format_arg
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|tree
name|format_tree
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|arg_num
parameter_list|)
block|{
name|format_check_context
modifier|*
name|format_ctx
init|=
operator|(
name|format_check_context
operator|*
operator|)
name|ctx
decl_stmt|;
name|format_check_results
modifier|*
name|res
init|=
name|format_ctx
operator|->
name|res
decl_stmt|;
name|function_format_info
modifier|*
name|info
init|=
name|format_ctx
operator|->
name|info
decl_stmt|;
name|tree
name|params
init|=
name|format_ctx
operator|->
name|params
decl_stmt|;
name|int
name|format_length
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_chars
decl_stmt|;
name|tree
name|array_size
init|=
literal|0
decl_stmt|;
name|tree
name|array_init
decl_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|format_tree
argument_list|)
condition|)
block|{
comment|/* Skip to first argument to check, so we can see if this format 	 has any arguments (it shouldn't).  */
while|while
condition|(
name|arg_num
operator|+
literal|1
operator|<
name|info
operator|->
name|first_arg_num
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|==
literal|0
condition|)
name|res
operator|->
name|number_other
operator|++
expr_stmt|;
else|else
name|res
operator|->
name|number_extra_args
operator|++
expr_stmt|;
return|return;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|format_tree
operator|=
name|arg0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|format_tree
operator|=
name|arg1
expr_stmt|;
name|arg1
operator|=
name|arg0
expr_stmt|;
block|}
else|else
block|{
name|res
operator|->
name|number_non_literal
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|offset
operator|=
name|tree_low_cst
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|res
operator|->
name|number_non_literal
operator|++
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
block|{
name|res
operator|->
name|number_non_literal
operator|++
expr_stmt|;
return|return;
block|}
name|format_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|offset
operator|+=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|format_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|format_tree
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|array_init
operator|=
name|decl_constant_value
argument_list|(
name|format_tree
argument_list|)
operator|)
operator|!=
name|format_tree
operator|&&
name|TREE_CODE
argument_list|(
name|array_init
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* Extract the string constant initializer.  Note that this may include 	 a trailing NUL character that is not in the array (e.g. 	 const char a[3] = "foo";).  */
name|array_size
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
name|format_tree
operator|=
name|array_init
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|res
operator|->
name|number_non_literal
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|format_tree
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
condition|)
block|{
name|res
operator|->
name|number_wide
operator|++
expr_stmt|;
return|return;
block|}
name|format_chars
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
name|format_length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_size
operator|!=
literal|0
condition|)
block|{
comment|/* Variable length arrays can't be initialized.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|array_size
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|array_size
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|array_size_value
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|array_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|array_size_value
operator|>
literal|0
operator|&&
name|array_size_value
operator|==
operator|(
name|int
operator|)
name|array_size_value
operator|&&
name|format_length
operator|>
name|array_size_value
condition|)
name|format_length
operator|=
name|array_size_value
expr_stmt|;
block|}
block|}
if|if
condition|(
name|offset
condition|)
block|{
if|if
condition|(
name|offset
operator|>=
name|format_length
condition|)
block|{
name|res
operator|->
name|number_non_literal
operator|++
expr_stmt|;
return|return;
block|}
name|format_chars
operator|+=
name|offset
expr_stmt|;
name|format_length
operator|-=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|format_length
operator|<
literal|1
condition|)
block|{
name|res
operator|->
name|number_unterminated
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|format_length
operator|==
literal|1
condition|)
block|{
name|res
operator|->
name|number_empty
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|format_chars
index|[
operator|--
name|format_length
index|]
operator|!=
literal|0
condition|)
block|{
name|res
operator|->
name|number_unterminated
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Skip to first argument to check.  */
while|while
condition|(
name|arg_num
operator|+
literal|1
operator|<
name|info
operator|->
name|first_arg_num
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
comment|/* Provisionally increment res->number_other; check_format_info_main      will decrement it if it finds there are extra arguments, but this way      need not adjust it for every return.  */
name|res
operator|->
name|number_other
operator|++
expr_stmt|;
name|check_format_info_main
argument_list|(
name|res
argument_list|,
name|info
argument_list|,
name|format_chars
argument_list|,
name|format_length
argument_list|,
name|params
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do the main part of checking a call to a format function.  FORMAT_CHARS    is the NUL-terminated format string (which at this point may contain    internal NUL characters); FORMAT_LENGTH is its length (excluding the    terminating NUL character).  ARG_NUM is one less than the number of    the first format argument to check; PARAMS points to that format    argument in the list of arguments.  */
end_comment

begin_function
specifier|static
name|void
name|check_format_info_main
parameter_list|(
name|format_check_results
modifier|*
name|res
parameter_list|,
name|function_format_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|format_chars
parameter_list|,
name|int
name|format_length
parameter_list|,
name|tree
name|params
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|arg_num
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|orig_format_chars
init|=
name|format_chars
decl_stmt|;
name|tree
name|first_fillin_param
init|=
name|params
decl_stmt|;
specifier|const
name|format_kind_info
modifier|*
name|fki
init|=
operator|&
name|format_types
index|[
name|info
operator|->
name|format_type
index|]
decl_stmt|;
specifier|const
name|format_flag_spec
modifier|*
name|flag_specs
init|=
name|fki
operator|->
name|flag_specs
decl_stmt|;
specifier|const
name|format_flag_pair
modifier|*
name|bad_flag_pairs
init|=
name|fki
operator|->
name|bad_flag_pairs
decl_stmt|;
comment|/* -1 if no conversions taking an operand have been found; 0 if one has      and it didn't use $; 1 if $ formats are in use.  */
name|int
name|has_operand_number
init|=
operator|-
literal|1
decl_stmt|;
name|init_dollar_format_checking
argument_list|(
name|info
operator|->
name|first_arg_num
argument_list|,
name|first_fillin_param
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|suppressed
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|length_chars
init|=
name|NULL
decl_stmt|;
name|enum
name|format_lengths
name|length_chars_val
init|=
name|FMT_LEN_none
decl_stmt|;
name|enum
name|format_std_version
name|length_chars_std
init|=
name|STD_C89
decl_stmt|;
name|int
name|format_char
decl_stmt|;
name|tree
name|cur_param
decl_stmt|;
name|tree
name|wanted_type
decl_stmt|;
name|int
name|main_arg_num
init|=
literal|0
decl_stmt|;
name|tree
name|main_arg_params
init|=
literal|0
decl_stmt|;
name|enum
name|format_std_version
name|wanted_type_std
decl_stmt|;
specifier|const
name|char
modifier|*
name|wanted_type_name
decl_stmt|;
name|format_wanted_type
name|width_wanted_type
decl_stmt|;
name|format_wanted_type
name|precision_wanted_type
decl_stmt|;
name|format_wanted_type
name|main_wanted_type
decl_stmt|;
name|format_wanted_type
modifier|*
name|first_wanted_type
init|=
name|NULL
decl_stmt|;
name|format_wanted_type
modifier|*
name|last_wanted_type
init|=
name|NULL
decl_stmt|;
specifier|const
name|format_length_info
modifier|*
name|fli
init|=
name|NULL
decl_stmt|;
specifier|const
name|format_char_info
modifier|*
name|fci
init|=
name|NULL
decl_stmt|;
name|char
name|flag_chars
index|[
literal|256
index|]
decl_stmt|;
name|int
name|aflag
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_start
init|=
name|format_chars
decl_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|format_chars
operator|-
name|orig_format_chars
operator|!=
name|format_length
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"embedded %<\\0%> in format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
operator|&&
name|params
operator|!=
literal|0
operator|&&
name|has_operand_number
operator|<=
literal|0
condition|)
block|{
name|res
operator|->
name|number_other
operator|--
expr_stmt|;
name|res
operator|->
name|number_extra_args
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|has_operand_number
operator|>
literal|0
condition|)
name|finish_dollar_format_checking
argument_list|(
name|res
argument_list|,
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_DOLLAR_GAP_POINTER_OK
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|format_chars
operator|++
operator|!=
literal|'%'
condition|)
continue|continue;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"spurious trailing %<%%%> in format"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'%'
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
continue|continue;
block|}
name|flag_chars
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_USE_DOLLAR
operator|)
operator|&&
name|has_operand_number
operator|!=
literal|0
condition|)
block|{
comment|/* Possibly read a $ operand number at the start of the format. 	     If one was previously used, one is required here.  If one 	     is not used here, we can't immediately conclude this is a 	     format without them, since it could be printf %m or scanf %*.  */
name|int
name|opnum
decl_stmt|;
name|opnum
operator|=
name|maybe_read_dollar_number
argument_list|(
operator|&
name|format_chars
argument_list|,
literal|0
argument_list|,
name|first_fillin_param
argument_list|,
operator|&
name|main_arg_params
argument_list|,
name|fki
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnum
operator|==
operator|-
literal|1
condition|)
return|return;
elseif|else
if|if
condition|(
name|opnum
operator|>
literal|0
condition|)
block|{
name|has_operand_number
operator|=
literal|1
expr_stmt|;
name|main_arg_num
operator|=
name|opnum
operator|+
name|info
operator|->
name|first_arg_num
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fki
operator|->
name|flags
operator|&
name|FMT_FLAG_USE_DOLLAR
condition|)
block|{
if|if
condition|(
name|avoid_dollar_number
argument_list|(
name|format_chars
argument_list|)
condition|)
return|return;
block|}
comment|/* Read any format flags, but do not yet validate them beyond removing 	 duplicates, since in general validation depends on the rest of 	 the format.  */
while|while
condition|(
operator|*
name|format_chars
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|fki
operator|->
name|flag_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|format_flag_spec
modifier|*
name|s
init|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
operator|*
name|format_chars
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|flag_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"repeated %s in format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|format_chars
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|skip_next_char
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"missing fill character at end of strfmon format"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
operator|++
name|format_chars
expr_stmt|;
block|}
comment|/* Read any format width, possibly * or *m$.  */
if|if
condition|(
name|fki
operator|->
name|width_char
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fki
operator|->
name|width_type
operator|!=
name|NULL
operator|&&
operator|*
name|format_chars
operator|==
literal|'*'
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
name|fki
operator|->
name|width_char
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* "...a field width...may be indicated by an asterisk. 		 In this case, an int argument supplies the field width..."  */
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
name|has_operand_number
operator|!=
literal|0
condition|)
block|{
name|int
name|opnum
decl_stmt|;
name|opnum
operator|=
name|maybe_read_dollar_number
argument_list|(
operator|&
name|format_chars
argument_list|,
name|has_operand_number
operator|==
literal|1
argument_list|,
name|first_fillin_param
argument_list|,
operator|&
name|params
argument_list|,
name|fki
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnum
operator|==
operator|-
literal|1
condition|)
return|return;
elseif|else
if|if
condition|(
name|opnum
operator|>
literal|0
condition|)
block|{
name|has_operand_number
operator|=
literal|1
expr_stmt|;
name|arg_num
operator|=
name|opnum
operator|+
name|info
operator|->
name|first_arg_num
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|has_operand_number
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|avoid_dollar_number
argument_list|(
name|format_chars
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"too few arguments for format"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_operand_number
operator|<=
literal|0
condition|)
block|{
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
name|width_wanted_type
operator|.
name|wanted_type
operator|=
operator|*
name|fki
operator|->
name|width_type
expr_stmt|;
name|width_wanted_type
operator|.
name|wanted_type_name
operator|=
name|NULL
expr_stmt|;
name|width_wanted_type
operator|.
name|pointer_count
operator|=
literal|0
expr_stmt|;
name|width_wanted_type
operator|.
name|char_lenient_flag
operator|=
literal|0
expr_stmt|;
name|width_wanted_type
operator|.
name|writing_in_flag
operator|=
literal|0
expr_stmt|;
name|width_wanted_type
operator|.
name|reading_from_flag
operator|=
literal|0
expr_stmt|;
name|width_wanted_type
operator|.
name|name
operator|=
name|_
argument_list|(
literal|"field width"
argument_list|)
expr_stmt|;
name|width_wanted_type
operator|.
name|param
operator|=
name|cur_param
expr_stmt|;
name|width_wanted_type
operator|.
name|arg_num
operator|=
name|arg_num
expr_stmt|;
name|width_wanted_type
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_wanted_type
operator|!=
literal|0
condition|)
name|last_wanted_type
operator|->
name|next
operator|=
operator|&
name|width_wanted_type
expr_stmt|;
if|if
condition|(
name|first_wanted_type
operator|==
literal|0
condition|)
name|first_wanted_type
operator|=
operator|&
name|width_wanted_type
expr_stmt|;
name|last_wanted_type
operator|=
operator|&
name|width_wanted_type
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Possibly read a numeric width.  If the width is zero, 		 we complain if appropriate.  */
name|int
name|non_zero_width_char
init|=
name|FALSE
decl_stmt|;
name|int
name|found_width
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
block|{
name|found_width
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|!=
literal|'0'
condition|)
name|non_zero_width_char
operator|=
name|TRUE
expr_stmt|;
operator|++
name|format_chars
expr_stmt|;
block|}
if|if
condition|(
name|found_width
operator|&&
operator|!
name|non_zero_width_char
operator|&&
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_ZERO_WIDTH_BAD
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"zero width in %s format"
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_width
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
name|fki
operator|->
name|width_char
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Read any format left precision (must be a number, not *).  */
if|if
condition|(
name|fki
operator|->
name|left_precision_char
operator|!=
literal|0
operator|&&
operator|*
name|format_chars
operator|==
literal|'#'
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
name|fki
operator|->
name|left_precision_char
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"empty left precision in %s format"
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
operator|++
name|format_chars
expr_stmt|;
block|}
comment|/* Read any format precision, possibly * or *m$.  */
if|if
condition|(
name|fki
operator|->
name|precision_char
operator|!=
literal|0
operator|&&
operator|*
name|format_chars
operator|==
literal|'.'
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
name|fki
operator|->
name|precision_char
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fki
operator|->
name|precision_type
operator|!=
name|NULL
operator|&&
operator|*
name|format_chars
operator|==
literal|'*'
condition|)
block|{
comment|/* "...a...precision...may be indicated by an asterisk. 		 In this case, an int argument supplies the...precision."  */
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
name|has_operand_number
operator|!=
literal|0
condition|)
block|{
name|int
name|opnum
decl_stmt|;
name|opnum
operator|=
name|maybe_read_dollar_number
argument_list|(
operator|&
name|format_chars
argument_list|,
name|has_operand_number
operator|==
literal|1
argument_list|,
name|first_fillin_param
argument_list|,
operator|&
name|params
argument_list|,
name|fki
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnum
operator|==
operator|-
literal|1
condition|)
return|return;
elseif|else
if|if
condition|(
name|opnum
operator|>
literal|0
condition|)
block|{
name|has_operand_number
operator|=
literal|1
expr_stmt|;
name|arg_num
operator|=
name|opnum
operator|+
name|info
operator|->
name|first_arg_num
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|has_operand_number
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|avoid_dollar_number
argument_list|(
name|format_chars
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"too few arguments for format"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_operand_number
operator|<=
literal|0
condition|)
block|{
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
name|precision_wanted_type
operator|.
name|wanted_type
operator|=
operator|*
name|fki
operator|->
name|precision_type
expr_stmt|;
name|precision_wanted_type
operator|.
name|wanted_type_name
operator|=
name|NULL
expr_stmt|;
name|precision_wanted_type
operator|.
name|pointer_count
operator|=
literal|0
expr_stmt|;
name|precision_wanted_type
operator|.
name|char_lenient_flag
operator|=
literal|0
expr_stmt|;
name|precision_wanted_type
operator|.
name|writing_in_flag
operator|=
literal|0
expr_stmt|;
name|precision_wanted_type
operator|.
name|reading_from_flag
operator|=
literal|0
expr_stmt|;
name|precision_wanted_type
operator|.
name|name
operator|=
name|_
argument_list|(
literal|"field precision"
argument_list|)
expr_stmt|;
name|precision_wanted_type
operator|.
name|param
operator|=
name|cur_param
expr_stmt|;
name|precision_wanted_type
operator|.
name|arg_num
operator|=
name|arg_num
expr_stmt|;
name|precision_wanted_type
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_wanted_type
operator|!=
literal|0
condition|)
name|last_wanted_type
operator|->
name|next
operator|=
operator|&
name|precision_wanted_type
expr_stmt|;
if|if
condition|(
name|first_wanted_type
operator|==
literal|0
condition|)
name|first_wanted_type
operator|=
operator|&
name|precision_wanted_type
expr_stmt|;
name|last_wanted_type
operator|=
operator|&
name|precision_wanted_type
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_EMPTY_PREC_OK
operator|)
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"empty precision in %s format"
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
operator|++
name|format_chars
expr_stmt|;
block|}
block|}
comment|/* Read any length modifier, if this kind of format has them.  */
name|fli
operator|=
name|fki
operator|->
name|length_char_specs
expr_stmt|;
name|length_chars
operator|=
name|NULL
expr_stmt|;
name|length_chars_val
operator|=
name|FMT_LEN_none
expr_stmt|;
name|length_chars_std
operator|=
name|STD_C89
expr_stmt|;
if|if
condition|(
name|fli
condition|)
block|{
while|while
condition|(
name|fli
operator|->
name|name
operator|!=
literal|0
operator|&&
name|fli
operator|->
name|name
index|[
literal|0
index|]
operator|!=
operator|*
name|format_chars
condition|)
name|fli
operator|++
expr_stmt|;
if|if
condition|(
name|fli
operator|->
name|name
operator|!=
literal|0
condition|)
block|{
name|format_chars
operator|++
expr_stmt|;
if|if
condition|(
name|fli
operator|->
name|double_name
operator|!=
literal|0
operator|&&
name|fli
operator|->
name|name
index|[
literal|0
index|]
operator|==
operator|*
name|format_chars
condition|)
block|{
name|format_chars
operator|++
expr_stmt|;
name|length_chars
operator|=
name|fli
operator|->
name|double_name
expr_stmt|;
name|length_chars_val
operator|=
name|fli
operator|->
name|double_index
expr_stmt|;
name|length_chars_std
operator|=
name|fli
operator|->
name|double_std
expr_stmt|;
block|}
else|else
block|{
name|length_chars
operator|=
name|fli
operator|->
name|name
expr_stmt|;
name|length_chars_val
operator|=
name|fli
operator|->
name|index
expr_stmt|;
name|length_chars_std
operator|=
name|fli
operator|->
name|std
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
name|fki
operator|->
name|length_code_char
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
comment|/* Warn if the length modifier is non-standard.  */
if|if
condition|(
name|ADJ_STD
argument_list|(
name|length_chars_std
argument_list|)
operator|>
name|C_STD_VER
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%s does not support the %qs %s length modifier"
argument_list|,
name|C_STD_NAME
argument_list|(
name|length_chars_std
argument_list|)
argument_list|,
name|length_chars
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Read any modifier (strftime E/O).  */
if|if
condition|(
name|fki
operator|->
name|modifier_chars
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|format_chars
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|fki
operator|->
name|modifier_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|flag_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|format_flag_spec
modifier|*
name|s
init|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
operator|*
name|format_chars
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"repeated %s in format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|format_chars
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|format_chars
expr_stmt|;
block|}
block|}
comment|/* Handle the scanf allocation kludge.  */
if|if
condition|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_SCANF_A_KLUDGE
condition|)
block|{
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'a'
operator|&&
operator|!
name|flag_isoc99
condition|)
block|{
if|if
condition|(
name|format_chars
index|[
literal|1
index|]
operator|==
literal|'s'
operator|||
name|format_chars
index|[
literal|1
index|]
operator|==
literal|'S'
operator|||
name|format_chars
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
comment|/* 'a' is used as a flag.  */
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
literal|'a'
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|format_chars
operator|++
expr_stmt|;
block|}
block|}
block|}
name|format_char
operator|=
operator|*
name|format_chars
expr_stmt|;
if|if
condition|(
name|format_char
operator|==
literal|0
operator|||
operator|(
operator|!
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_FANCY_PERCENT_OK
operator|)
operator|&&
name|format_char
operator|==
literal|'%'
operator|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"conversion lacks type at end of format"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|format_chars
operator|++
expr_stmt|;
name|fci
operator|=
name|fki
operator|->
name|conversion_specs
expr_stmt|;
while|while
condition|(
name|fci
operator|->
name|format_chars
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|fci
operator|->
name|format_chars
argument_list|,
name|format_char
argument_list|)
operator|==
literal|0
condition|)
operator|++
name|fci
expr_stmt|;
if|if
condition|(
name|fci
operator|->
name|format_chars
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ISGRAPH
argument_list|(
name|format_char
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"unknown conversion type character %qc in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"unknown conversion type character 0x%x in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|ADJ_STD
argument_list|(
name|fci
operator|->
name|std
argument_list|)
operator|>
name|C_STD_VER
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%s does not support the %<%%%c%> %s format"
argument_list|,
name|C_STD_NAME
argument_list|(
name|fci
operator|->
name|std
argument_list|)
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Validate the individual flags used, removing any that are invalid.  */
block|{
name|int
name|d
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|flag_chars
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|format_flag_spec
modifier|*
name|s
init|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|flag_chars
index|[
name|i
operator|-
name|d
index|]
operator|=
name|flag_chars
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|flag_chars
index|[
name|i
index|]
operator|==
name|fki
operator|->
name|length_code_char
condition|)
continue|continue;
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%s used with %<%%%c%> %s format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
specifier|const
name|format_flag_spec
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|ADJ_STD
argument_list|(
name|s
operator|->
name|std
argument_list|)
operator|>
name|C_STD_VER
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%s does not support %s"
argument_list|,
name|C_STD_NAME
argument_list|(
name|s
operator|->
name|std
argument_list|)
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|long_name
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|,
name|fci
operator|->
name|flags2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
operator|&&
name|ADJ_STD
argument_list|(
name|t
operator|->
name|std
argument_list|)
operator|>
name|ADJ_STD
argument_list|(
name|s
operator|->
name|std
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|long_name
init|=
operator|(
name|t
operator|->
name|long_name
operator|!=
name|NULL
condition|?
name|t
operator|->
name|long_name
else|:
name|s
operator|->
name|long_name
operator|)
decl_stmt|;
if|if
condition|(
name|ADJ_STD
argument_list|(
name|t
operator|->
name|std
argument_list|)
operator|>
name|C_STD_VER
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%s does not support %s with the %<%%%c%> %s format"
argument_list|,
name|C_STD_NAME
argument_list|(
name|t
operator|->
name|std
argument_list|)
argument_list|,
name|_
argument_list|(
name|long_name
argument_list|)
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|flag_chars
index|[
name|i
operator|-
name|d
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_SCANF_A_KLUDGE
operator|)
operator|&&
name|strchr
argument_list|(
name|flag_chars
argument_list|,
literal|'a'
argument_list|)
operator|!=
literal|0
condition|)
name|aflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fki
operator|->
name|suppression_char
operator|&&
name|strchr
argument_list|(
name|flag_chars
argument_list|,
name|fki
operator|->
name|suppression_char
argument_list|)
operator|!=
literal|0
condition|)
name|suppressed
operator|=
literal|1
expr_stmt|;
comment|/* Validate the pairs of flags used.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|flag_char1
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|format_flag_spec
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|flag_chars
argument_list|,
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|flag_char1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strchr
argument_list|(
name|flag_chars
argument_list|,
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|flag_char2
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|predicate
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|predicate
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|s
operator|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|flag_char1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_flag_spec
argument_list|(
name|flag_specs
argument_list|,
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|flag_char2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|ignored
condition|)
block|{
if|if
condition|(
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|predicate
operator|!=
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%s ignored with %s and %<%%%c%> %s format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
name|_
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%s ignored with %s in %s format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
name|_
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bad_flag_pairs
index|[
name|i
index|]
operator|.
name|predicate
operator|!=
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"use of %s and %s together with %<%%%c%> %s format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
name|_
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"use of %s and %s together in %s format"
argument_list|,
name|_
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
name|_
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Give Y2K warnings.  */
if|if
condition|(
name|warn_format_y2k
condition|)
block|{
name|int
name|y2k_level
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'4'
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|strchr
argument_list|(
name|flag_chars
argument_list|,
literal|'E'
argument_list|)
operator|!=
literal|0
condition|)
name|y2k_level
operator|=
literal|3
expr_stmt|;
else|else
name|y2k_level
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'3'
argument_list|)
operator|!=
literal|0
condition|)
name|y2k_level
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'2'
argument_list|)
operator|!=
literal|0
condition|)
name|y2k_level
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|y2k_level
operator|==
literal|3
condition|)
name|warning
argument_list|(
name|OPT_Wformat_y2k
argument_list|,
literal|"%<%%%c%> yields only last 2 digits of "
literal|"year in some locales"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|y2k_level
operator|==
literal|2
condition|)
name|warning
argument_list|(
name|OPT_Wformat_y2k
argument_list|,
literal|"%<%%%c%> yields only last 2 digits of "
literal|"year"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'['
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Skip over scan set, in case it happens to have '%' in it.  */
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'^'
condition|)
operator|++
name|format_chars
expr_stmt|;
comment|/* Find closing bracket; if one is hit immediately, then 	     it's part of the scan set rather than a terminator.  */
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|']'
condition|)
operator|++
name|format_chars
expr_stmt|;
while|while
condition|(
operator|*
name|format_chars
operator|&&
operator|*
name|format_chars
operator|!=
literal|']'
condition|)
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|!=
literal|']'
condition|)
comment|/* The end of the format string was reached.  */
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"no closing %<]%> for %<%%[%> format"
argument_list|)
expr_stmt|;
block|}
name|wanted_type
operator|=
literal|0
expr_stmt|;
name|wanted_type_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fki
operator|->
name|flags
operator|&
operator|(
name|int
operator|)
name|FMT_FLAG_ARG_CONVERT
condition|)
block|{
name|wanted_type
operator|=
operator|(
name|fci
operator|->
name|types
index|[
name|length_chars_val
index|]
operator|.
name|type
condition|?
operator|*
name|fci
operator|->
name|types
index|[
name|length_chars_val
index|]
operator|.
name|type
else|:
literal|0
operator|)
expr_stmt|;
name|wanted_type_name
operator|=
name|fci
operator|->
name|types
index|[
name|length_chars_val
index|]
operator|.
name|name
expr_stmt|;
name|wanted_type_std
operator|=
name|fci
operator|->
name|types
index|[
name|length_chars_val
index|]
operator|.
name|std
expr_stmt|;
if|if
condition|(
name|wanted_type
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"use of %qs length modifier with %qc type character"
argument_list|,
name|length_chars
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
comment|/* Heuristic: skip one argument when an invalid length/type 		 combination is encountered.  */
name|arg_num
operator|++
expr_stmt|;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"too few arguments for format"
argument_list|)
expr_stmt|;
return|return;
block|}
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|pedantic
comment|/* Warn if non-standard, provided it is more non-standard 		      than the length and type characters that may already 		      have been warned for.  */
operator|&&
name|ADJ_STD
argument_list|(
name|wanted_type_std
argument_list|)
operator|>
name|ADJ_STD
argument_list|(
name|length_chars_std
argument_list|)
operator|&&
name|ADJ_STD
argument_list|(
name|wanted_type_std
argument_list|)
operator|>
name|ADJ_STD
argument_list|(
name|fci
operator|->
name|std
argument_list|)
condition|)
block|{
if|if
condition|(
name|ADJ_STD
argument_list|(
name|wanted_type_std
argument_list|)
operator|>
name|C_STD_VER
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%s does not support the %<%%%s%c%> %s format"
argument_list|,
name|C_STD_NAME
argument_list|(
name|wanted_type_std
argument_list|)
argument_list|,
name|length_chars
argument_list|,
name|format_char
argument_list|,
name|fki
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|main_wanted_type
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Finally. . .check type of argument against desired type!  */
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|fci
operator|->
name|pointer_count
operator|==
literal|0
operator|&&
name|wanted_type
operator|==
name|void_type_node
operator|)
operator|||
name|suppressed
condition|)
block|{
if|if
condition|(
name|main_arg_num
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|suppressed
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"operand number specified with "
literal|"suppressed assignment"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"operand number specified for format "
literal|"taking no argument"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|format_wanted_type
modifier|*
name|wanted_type_ptr
decl_stmt|;
if|if
condition|(
name|main_arg_num
operator|!=
literal|0
condition|)
block|{
name|arg_num
operator|=
name|main_arg_num
expr_stmt|;
name|params
operator|=
name|main_arg_params
expr_stmt|;
block|}
else|else
block|{
operator|++
name|arg_num
expr_stmt|;
if|if
condition|(
name|has_operand_number
operator|>
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"missing $ operand number in format"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|has_operand_number
operator|=
literal|0
expr_stmt|;
block|}
name|wanted_type_ptr
operator|=
operator|&
name|main_wanted_type
expr_stmt|;
while|while
condition|(
name|fci
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"too few arguments for format"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|wanted_type_ptr
operator|->
name|wanted_type
operator|=
name|wanted_type
expr_stmt|;
name|wanted_type_ptr
operator|->
name|wanted_type_name
operator|=
name|wanted_type_name
expr_stmt|;
name|wanted_type_ptr
operator|->
name|pointer_count
operator|=
name|fci
operator|->
name|pointer_count
operator|+
name|aflag
expr_stmt|;
name|wanted_type_ptr
operator|->
name|char_lenient_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'c'
argument_list|)
operator|!=
literal|0
condition|)
name|wanted_type_ptr
operator|->
name|char_lenient_flag
operator|=
literal|1
expr_stmt|;
name|wanted_type_ptr
operator|->
name|writing_in_flag
operator|=
literal|0
expr_stmt|;
name|wanted_type_ptr
operator|->
name|reading_from_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|wanted_type_ptr
operator|->
name|writing_in_flag
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'W'
argument_list|)
operator|!=
literal|0
condition|)
name|wanted_type_ptr
operator|->
name|writing_in_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|flags2
argument_list|,
literal|'R'
argument_list|)
operator|!=
literal|0
condition|)
name|wanted_type_ptr
operator|->
name|reading_from_flag
operator|=
literal|1
expr_stmt|;
block|}
name|wanted_type_ptr
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|wanted_type_ptr
operator|->
name|param
operator|=
name|cur_param
expr_stmt|;
name|wanted_type_ptr
operator|->
name|arg_num
operator|=
name|arg_num
expr_stmt|;
name|wanted_type_ptr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_wanted_type
operator|!=
literal|0
condition|)
name|last_wanted_type
operator|->
name|next
operator|=
name|wanted_type_ptr
expr_stmt|;
if|if
condition|(
name|first_wanted_type
operator|==
literal|0
condition|)
name|first_wanted_type
operator|=
name|wanted_type_ptr
expr_stmt|;
name|last_wanted_type
operator|=
name|wanted_type_ptr
expr_stmt|;
name|fci
operator|=
name|fci
operator|->
name|chain
expr_stmt|;
if|if
condition|(
name|fci
condition|)
block|{
name|wanted_type_ptr
operator|=
name|GGC_NEW
argument_list|(
name|format_wanted_type
argument_list|)
expr_stmt|;
name|arg_num
operator|++
expr_stmt|;
name|wanted_type
operator|=
operator|*
name|fci
operator|->
name|types
index|[
name|length_chars_val
index|]
operator|.
name|type
expr_stmt|;
name|wanted_type_name
operator|=
name|fci
operator|->
name|types
index|[
name|length_chars_val
index|]
operator|.
name|name
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|first_wanted_type
operator|!=
literal|0
condition|)
name|check_format_types
argument_list|(
name|first_wanted_type
argument_list|,
name|format_start
argument_list|,
name|format_chars
operator|-
name|format_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_wanted_type
operator|.
name|next
operator|!=
name|NULL
condition|)
block|{
name|format_wanted_type
modifier|*
name|wanted_type_ptr
init|=
name|main_wanted_type
operator|.
name|next
decl_stmt|;
while|while
condition|(
name|wanted_type_ptr
condition|)
block|{
name|format_wanted_type
modifier|*
name|next
init|=
name|wanted_type_ptr
operator|->
name|next
decl_stmt|;
name|ggc_free
argument_list|(
name|wanted_type_ptr
argument_list|)
expr_stmt|;
name|wanted_type_ptr
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check the argument types from a single format conversion (possibly    including width and precision arguments).  */
end_comment

begin_function
specifier|static
name|void
name|check_format_types
parameter_list|(
name|format_wanted_type
modifier|*
name|types
parameter_list|,
specifier|const
name|char
modifier|*
name|format_start
parameter_list|,
name|int
name|format_length
parameter_list|)
block|{
for|for
control|(
init|;
name|types
operator|!=
literal|0
condition|;
name|types
operator|=
name|types
operator|->
name|next
control|)
block|{
name|tree
name|cur_param
decl_stmt|;
name|tree
name|cur_type
decl_stmt|;
name|tree
name|orig_cur_type
decl_stmt|;
name|tree
name|wanted_type
decl_stmt|;
name|int
name|arg_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|char_type_flag
decl_stmt|;
name|cur_param
operator|=
name|types
operator|->
name|param
expr_stmt|;
name|cur_type
operator|=
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_type
operator|==
name|error_mark_node
condition|)
continue|continue;
name|orig_cur_type
operator|=
name|cur_type
expr_stmt|;
name|char_type_flag
operator|=
literal|0
expr_stmt|;
name|wanted_type
operator|=
name|types
operator|->
name|wanted_type
expr_stmt|;
name|arg_num
operator|=
name|types
operator|->
name|arg_num
expr_stmt|;
comment|/* The following should not occur here.  */
name|gcc_assert
argument_list|(
name|wanted_type
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|wanted_type
operator|!=
name|void_type_node
operator|||
name|types
operator|->
name|pointer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|types
operator|->
name|pointer_count
operator|==
literal|0
condition|)
name|wanted_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_promotes_to
argument_list|(
name|wanted_type
argument_list|)
expr_stmt|;
name|wanted_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|wanted_type
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|cur_param
argument_list|)
expr_stmt|;
comment|/* Check the types of any additional pointer arguments 	 that precede the "real" argument.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|types
operator|->
name|pointer_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|cur_type
operator|=
name|TREE_TYPE
argument_list|(
name|cur_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_type
operator|==
name|error_mark_node
condition|)
break|break;
comment|/* Check for writing through a NULL pointer.  */
if|if
condition|(
name|types
operator|->
name|writing_in_flag
operator|&&
name|i
operator|==
literal|0
operator|&&
name|cur_param
operator|!=
literal|0
operator|&&
name|integer_zerop
argument_list|(
name|cur_param
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"writing through null pointer "
literal|"(argument %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
comment|/* Check for reading through a NULL pointer.  */
if|if
condition|(
name|types
operator|->
name|reading_from_flag
operator|&&
name|i
operator|==
literal|0
operator|&&
name|cur_param
operator|!=
literal|0
operator|&&
name|integer_zerop
argument_list|(
name|cur_param
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"reading through null pointer "
literal|"(argument %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_param
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|cur_param
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|cur_param
operator|=
name|TREE_OPERAND
argument_list|(
name|cur_param
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|cur_param
operator|=
literal|0
expr_stmt|;
comment|/* See if this is an attempt to write into a const type with 		 scanf or with printf "%n".  Note: the writing in happens 		 at the first indirection only, if for example 		 void * const * is passed to scanf %p; passing 		 const void ** is simply passing an incompatible type.  */
if|if
condition|(
name|types
operator|->
name|writing_in_flag
operator|&&
name|i
operator|==
literal|0
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|cur_type
argument_list|)
operator|||
operator|(
name|cur_param
operator|!=
literal|0
operator|&&
operator|(
name|CONSTANT_CLASS_P
argument_list|(
name|cur_param
argument_list|)
operator|||
operator|(
name|DECL_P
argument_list|(
name|cur_param
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|cur_param
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"writing into constant object "
literal|"(argument %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
comment|/* If there are extra type qualifiers beyond the first 		 indirection, then this makes the types technically 		 incompatible.  */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|pedantic
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|cur_type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|cur_type
argument_list|)
operator|||
name|TYPE_RESTRICT
argument_list|(
name|cur_type
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"extra type qualifiers in format "
literal|"argument (argument %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|format_type_warning
argument_list|(
name|types
operator|->
name|name
argument_list|,
name|format_start
argument_list|,
name|format_length
argument_list|,
name|wanted_type
argument_list|,
name|types
operator|->
name|pointer_count
argument_list|,
name|types
operator|->
name|wanted_type_name
argument_list|,
name|orig_cur_type
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|types
operator|->
name|pointer_count
condition|)
continue|continue;
name|cur_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|cur_type
argument_list|)
expr_stmt|;
comment|/* Check whether the argument type is a character type.  This leniency 	 only applies to certain formats, flagged with 'c'.       */
if|if
condition|(
name|types
operator|->
name|char_lenient_flag
condition|)
name|char_type_flag
operator|=
operator|(
name|cur_type
operator|==
name|char_type_node
operator|||
name|cur_type
operator|==
name|signed_char_type_node
operator|||
name|cur_type
operator|==
name|unsigned_char_type_node
operator|)
expr_stmt|;
comment|/* Check the type of the "real" argument, if there's a type we want.  */
if|if
condition|(
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|wanted_type
argument_list|,
name|cur_type
argument_list|)
condition|)
continue|continue;
comment|/* If we want 'void *', allow any pointer type. 	 (Anything else would already have got a warning.) 	 With -pedantic, only allow pointers to void and to character 	 types.  */
if|if
condition|(
name|wanted_type
operator|==
name|void_type_node
operator|&&
operator|(
operator|!
name|pedantic
operator|||
operator|(
name|i
operator|==
literal|1
operator|&&
name|char_type_flag
operator|)
operator|)
condition|)
continue|continue;
comment|/* Don't warn about differences merely in signedness, unless 	 -pedantic.  With -pedantic, warn if the type is a pointer 	 target and not a character type, and for character types at 	 a second level of indirection.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|wanted_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
operator|!
name|pedantic
operator|||
name|i
operator|==
literal|0
operator|||
operator|(
name|i
operator|==
literal|1
operator|&&
name|char_type_flag
operator|)
operator|)
operator|&&
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|wanted_type
argument_list|)
condition|?
name|wanted_type
operator|==
name|c_common_unsigned_type
argument_list|(
name|cur_type
argument_list|)
else|:
name|wanted_type
operator|==
name|c_common_signed_type
argument_list|(
name|cur_type
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Likewise, "signed char", "unsigned char" and "char" are 	 equivalent but the above test won't consider them equivalent.  */
if|if
condition|(
name|wanted_type
operator|==
name|char_type_node
operator|&&
operator|(
operator|!
name|pedantic
operator|||
name|i
operator|<
literal|2
operator|)
operator|&&
name|char_type_flag
condition|)
continue|continue;
comment|/* Now we have a type mismatch.  */
name|format_type_warning
argument_list|(
name|types
operator|->
name|name
argument_list|,
name|format_start
argument_list|,
name|format_length
argument_list|,
name|wanted_type
argument_list|,
name|types
operator|->
name|pointer_count
argument_list|,
name|types
operator|->
name|wanted_type_name
argument_list|,
name|orig_cur_type
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Give a warning about a format argument of different type from that    expected.  DESCR is a description such as "field precision", or    NULL for an ordinary format.  For an ordinary format, FORMAT_START    points to where the format starts in the format string and    FORMAT_LENGTH is its length.  WANTED_TYPE is the type the argument    should have after POINTER_COUNT pointer dereferences.    WANTED_NAME_NAME is a possibly more friendly name of WANTED_TYPE,    or NULL if the ordinary name of the type should be used.  ARG_TYPE    is the type of the actual argument.  ARG_NUM is the number of that    argument.  */
end_comment

begin_function
specifier|static
name|void
name|format_type_warning
parameter_list|(
specifier|const
name|char
modifier|*
name|descr
parameter_list|,
specifier|const
name|char
modifier|*
name|format_start
parameter_list|,
name|int
name|format_length
parameter_list|,
name|tree
name|wanted_type
parameter_list|,
name|int
name|pointer_count
parameter_list|,
specifier|const
name|char
modifier|*
name|wanted_type_name
parameter_list|,
name|tree
name|arg_type
parameter_list|,
name|int
name|arg_num
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If ARG_TYPE is a typedef with a misleading name (for example,      size_t but not the standard size_t expected by printf %zu), avoid      printing the typedef name.  */
if|if
condition|(
name|wanted_type_name
operator|&&
name|TYPE_NAME
argument_list|(
name|arg_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|arg_type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|arg_type
argument_list|)
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|wanted_type_name
argument_list|,
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|TYPE_NAME
argument_list|(
name|arg_type
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|arg_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
comment|/* The format type and name exclude any '*' for pointers, so those      must be formatted manually.  For all the types we currently have,      this is adequate, but formats taking pointers to functions or      arrays would require the full type to be built up in order to      print it with %T.  */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|pointer_count
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointer_count
operator|==
literal|0
condition|)
name|p
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|'*'
argument_list|,
name|pointer_count
argument_list|)
expr_stmt|;
name|p
index|[
name|pointer_count
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|memset
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'*'
argument_list|,
name|pointer_count
argument_list|)
expr_stmt|;
name|p
index|[
name|pointer_count
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|wanted_type_name
condition|)
block|{
if|if
condition|(
name|descr
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%s should have type %<%s%s%>, "
literal|"but argument %d has type %qT"
argument_list|,
name|descr
argument_list|,
name|wanted_type_name
argument_list|,
name|p
argument_list|,
name|arg_num
argument_list|,
name|arg_type
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"format %q.*s expects type %<%s%s%>, "
literal|"but argument %d has type %qT"
argument_list|,
name|format_length
argument_list|,
name|format_start
argument_list|,
name|wanted_type_name
argument_list|,
name|p
argument_list|,
name|arg_num
argument_list|,
name|arg_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|descr
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"%s should have type %<%T%s%>, "
literal|"but argument %d has type %qT"
argument_list|,
name|descr
argument_list|,
name|wanted_type
argument_list|,
name|p
argument_list|,
name|arg_num
argument_list|,
name|arg_type
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"format %q.*s expects type %<%T%s%>, "
literal|"but argument %d has type %qT"
argument_list|,
name|format_length
argument_list|,
name|format_start
argument_list|,
name|wanted_type
argument_list|,
name|p
argument_list|,
name|arg_num
argument_list|,
name|arg_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a format_char_info array FCI, and a character C, this function    returns the index into the conversion_specs where that specifier's    data is located.  The character must exist.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|find_char_info_specifier_index
parameter_list|(
specifier|const
name|format_char_info
modifier|*
name|fci
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fci
operator|->
name|format_chars
condition|;
name|i
operator|++
operator|,
name|fci
operator|++
control|)
if|if
condition|(
name|strchr
argument_list|(
name|fci
operator|->
name|format_chars
argument_list|,
name|c
argument_list|)
condition|)
return|return
name|i
return|;
comment|/* We shouldn't be looking for a non-existent specifier.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a format_length_info array FLI, and a character C, this    function returns the index into the conversion_specs where that    modifier's data is located.  The character must exist.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|find_length_info_modifier_index
parameter_list|(
specifier|const
name|format_length_info
modifier|*
name|fli
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fli
operator|->
name|name
condition|;
name|i
operator|++
operator|,
name|fli
operator|++
control|)
if|if
condition|(
name|strchr
argument_list|(
name|fli
operator|->
name|name
argument_list|,
name|c
argument_list|)
condition|)
return|return
name|i
return|;
comment|/* We shouldn't be looking for a non-existent modifier.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the type of HOST_WIDE_INT in the code being compiled for    use in GCC's __asm_fprintf__ custom format attribute.  You must    have set dynamic_format_types before calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|init_dynamic_asm_fprintf_info
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|tree
name|hwi
decl_stmt|;
if|if
condition|(
operator|!
name|hwi
condition|)
block|{
name|format_length_info
modifier|*
name|new_asm_fprintf_length_specs
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Find the underlying type for HOST_WIDE_INT.  For the %w 	 length modifier to work, one must have issued: "typedef 	 HOST_WIDE_INT __gcc_host_wide_int__;" in one's source code 	 prior to using that modifier.  */
name|hwi
operator|=
name|maybe_get_identifier
argument_list|(
literal|"__gcc_host_wide_int__"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hwi
condition|)
block|{
name|error
argument_list|(
literal|"%<__gcc_host_wide_int__%> is not defined as a type"
argument_list|)
expr_stmt|;
return|return;
block|}
name|hwi
operator|=
name|identifier_global_value
argument_list|(
name|hwi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hwi
operator|||
name|TREE_CODE
argument_list|(
name|hwi
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%<__gcc_host_wide_int__%> is not defined as a type"
argument_list|)
expr_stmt|;
return|return;
block|}
name|hwi
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|hwi
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|hwi
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwi
operator|!=
name|long_integer_type_node
operator|&&
name|hwi
operator|!=
name|long_long_integer_type_node
condition|)
block|{
name|error
argument_list|(
literal|"%<__gcc_host_wide_int__%> is not defined as %<long%>"
literal|" or %<long long%>"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Create a new (writable) copy of asm_fprintf_length_specs.  */
name|new_asm_fprintf_length_specs
operator|=
operator|(
name|format_length_info
operator|*
operator|)
name|xmemdup
argument_list|(
name|asm_fprintf_length_specs
argument_list|,
sizeof|sizeof
argument_list|(
name|asm_fprintf_length_specs
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|asm_fprintf_length_specs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* HOST_WIDE_INT must be one of 'long' or 'long long'.  */
name|i
operator|=
name|find_length_info_modifier_index
argument_list|(
name|new_asm_fprintf_length_specs
argument_list|,
literal|'w'
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwi
operator|==
name|long_integer_type_node
condition|)
name|new_asm_fprintf_length_specs
index|[
name|i
index|]
operator|.
name|index
operator|=
name|FMT_LEN_l
expr_stmt|;
elseif|else
if|if
condition|(
name|hwi
operator|==
name|long_long_integer_type_node
condition|)
name|new_asm_fprintf_length_specs
index|[
name|i
index|]
operator|.
name|index
operator|=
name|FMT_LEN_ll
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* Assign the new data for use.  */
name|dynamic_format_types
index|[
name|asm_fprintf_format_type
index|]
operator|.
name|length_char_specs
operator|=
name|new_asm_fprintf_length_specs
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine the type of a "locus" in the code being compiled for use    in GCC's __gcc_gfc__ custom format attribute.  You must have set    dynamic_format_types before calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|init_dynamic_gfc_info
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|tree
name|locus
decl_stmt|;
if|if
condition|(
operator|!
name|locus
condition|)
block|{
specifier|static
name|format_char_info
modifier|*
name|gfc_fci
decl_stmt|;
comment|/* For the GCC __gcc_gfc__ custom format specifier to work, one 	 must have declared 'locus' prior to using this attribute.  If 	 we haven't seen this declarations then you shouldn't use the 	 specifier requiring that type.  */
if|if
condition|(
operator|(
name|locus
operator|=
name|maybe_get_identifier
argument_list|(
literal|"locus"
argument_list|)
operator|)
condition|)
block|{
name|locus
operator|=
name|identifier_global_value
argument_list|(
name|locus
argument_list|)
expr_stmt|;
if|if
condition|(
name|locus
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|locus
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%<locus%> is not defined as a type"
argument_list|)
expr_stmt|;
name|locus
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|locus
operator|=
name|TREE_TYPE
argument_list|(
name|locus
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Assign the new data for use.  */
comment|/* Handle the __gcc_gfc__ format specifics.  */
if|if
condition|(
operator|!
name|gfc_fci
condition|)
name|dynamic_format_types
index|[
name|gcc_gfc_format_type
index|]
operator|.
name|conversion_specs
operator|=
name|gfc_fci
operator|=
operator|(
name|format_char_info
operator|*
operator|)
name|xmemdup
argument_list|(
name|gcc_gfc_char_table
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_gfc_char_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_gfc_char_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locus
condition|)
block|{
specifier|const
name|unsigned
name|i
init|=
name|find_char_info_specifier_index
argument_list|(
name|gfc_fci
argument_list|,
literal|'L'
argument_list|)
decl_stmt|;
name|gfc_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|locus
expr_stmt|;
name|gfc_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determine the types of "tree" and "location_t" in the code being    compiled for use in GCC's diagnostic custom format attributes.  You    must have set dynamic_format_types before calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|init_dynamic_diag_info
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|tree
name|t
decl_stmt|,
name|loc
decl_stmt|,
name|hwi
decl_stmt|;
if|if
condition|(
operator|!
name|loc
operator|||
operator|!
name|t
operator|||
operator|!
name|hwi
condition|)
block|{
specifier|static
name|format_char_info
modifier|*
name|diag_fci
decl_stmt|,
modifier|*
name|tdiag_fci
decl_stmt|,
modifier|*
name|cdiag_fci
decl_stmt|,
modifier|*
name|cxxdiag_fci
decl_stmt|;
specifier|static
name|format_length_info
modifier|*
name|diag_ls
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* For the GCC-diagnostics custom format specifiers to work, one 	 must have declared 'tree' and/or 'location_t' prior to using 	 those attributes.  If we haven't seen these declarations then 	 you shouldn't use the specifiers requiring these types. 	 However we don't force a hard ICE because we may see only one 	 or the other type.  */
if|if
condition|(
operator|(
name|loc
operator|=
name|maybe_get_identifier
argument_list|(
literal|"location_t"
argument_list|)
operator|)
condition|)
block|{
name|loc
operator|=
name|identifier_global_value
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%<location_t%> is not defined as a type"
argument_list|)
expr_stmt|;
name|loc
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|loc
operator|=
name|TREE_TYPE
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We need to grab the underlying 'union tree_node' so peek into 	 an extra type level.  */
if|if
condition|(
operator|(
name|t
operator|=
name|maybe_get_identifier
argument_list|(
literal|"tree"
argument_list|)
operator|)
condition|)
block|{
name|t
operator|=
name|identifier_global_value
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%<tree%> is not defined as a type"
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"%<tree%> is not defined as a pointer type"
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Find the underlying type for HOST_WIDE_INT.  For the %w 	 length modifier to work, one must have issued: "typedef 	 HOST_WIDE_INT __gcc_host_wide_int__;" in one's source code 	 prior to using that modifier.  */
if|if
condition|(
operator|(
name|hwi
operator|=
name|maybe_get_identifier
argument_list|(
literal|"__gcc_host_wide_int__"
argument_list|)
operator|)
condition|)
block|{
name|hwi
operator|=
name|identifier_global_value
argument_list|(
name|hwi
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwi
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|hwi
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%<__gcc_host_wide_int__%> is not defined as a type"
argument_list|)
expr_stmt|;
name|hwi
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|hwi
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|hwi
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|hwi
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwi
operator|!=
name|long_integer_type_node
operator|&&
name|hwi
operator|!=
name|long_long_integer_type_node
condition|)
block|{
name|error
argument_list|(
literal|"%<__gcc_host_wide_int__%> is not defined"
literal|" as %<long%> or %<long long%>"
argument_list|)
expr_stmt|;
name|hwi
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Assign the new data for use.  */
comment|/* All the GCC diag formats use the same length specs.  */
if|if
condition|(
operator|!
name|diag_ls
condition|)
name|dynamic_format_types
index|[
name|gcc_diag_format_type
index|]
operator|.
name|length_char_specs
operator|=
name|dynamic_format_types
index|[
name|gcc_tdiag_format_type
index|]
operator|.
name|length_char_specs
operator|=
name|dynamic_format_types
index|[
name|gcc_cdiag_format_type
index|]
operator|.
name|length_char_specs
operator|=
name|dynamic_format_types
index|[
name|gcc_cxxdiag_format_type
index|]
operator|.
name|length_char_specs
operator|=
name|diag_ls
operator|=
operator|(
name|format_length_info
operator|*
operator|)
name|xmemdup
argument_list|(
name|gcc_diag_length_specs
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_diag_length_specs
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_diag_length_specs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwi
condition|)
block|{
comment|/* HOST_WIDE_INT must be one of 'long' or 'long long'.  */
name|i
operator|=
name|find_length_info_modifier_index
argument_list|(
name|diag_ls
argument_list|,
literal|'w'
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwi
operator|==
name|long_integer_type_node
condition|)
name|diag_ls
index|[
name|i
index|]
operator|.
name|index
operator|=
name|FMT_LEN_l
expr_stmt|;
elseif|else
if|if
condition|(
name|hwi
operator|==
name|long_long_integer_type_node
condition|)
name|diag_ls
index|[
name|i
index|]
operator|.
name|index
operator|=
name|FMT_LEN_ll
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Handle the __gcc_diag__ format specifics.  */
if|if
condition|(
operator|!
name|diag_fci
condition|)
name|dynamic_format_types
index|[
name|gcc_diag_format_type
index|]
operator|.
name|conversion_specs
operator|=
name|diag_fci
operator|=
operator|(
name|format_char_info
operator|*
operator|)
name|xmemdup
argument_list|(
name|gcc_diag_char_table
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_diag_char_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_diag_char_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
condition|)
block|{
name|i
operator|=
name|find_char_info_specifier_index
argument_list|(
name|diag_fci
argument_list|,
literal|'H'
argument_list|)
expr_stmt|;
name|diag_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|loc
expr_stmt|;
name|diag_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t
condition|)
block|{
name|i
operator|=
name|find_char_info_specifier_index
argument_list|(
name|diag_fci
argument_list|,
literal|'J'
argument_list|)
expr_stmt|;
name|diag_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|t
expr_stmt|;
name|diag_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Handle the __gcc_tdiag__ format specifics.  */
if|if
condition|(
operator|!
name|tdiag_fci
condition|)
name|dynamic_format_types
index|[
name|gcc_tdiag_format_type
index|]
operator|.
name|conversion_specs
operator|=
name|tdiag_fci
operator|=
operator|(
name|format_char_info
operator|*
operator|)
name|xmemdup
argument_list|(
name|gcc_tdiag_char_table
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_tdiag_char_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_tdiag_char_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
condition|)
block|{
name|i
operator|=
name|find_char_info_specifier_index
argument_list|(
name|tdiag_fci
argument_list|,
literal|'H'
argument_list|)
expr_stmt|;
name|tdiag_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|loc
expr_stmt|;
name|tdiag_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t
condition|)
block|{
comment|/* All specifiers taking a tree share the same struct.  */
name|i
operator|=
name|find_char_info_specifier_index
argument_list|(
name|tdiag_fci
argument_list|,
literal|'D'
argument_list|)
expr_stmt|;
name|tdiag_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|t
expr_stmt|;
name|tdiag_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|find_char_info_specifier_index
argument_list|(
name|tdiag_fci
argument_list|,
literal|'J'
argument_list|)
expr_stmt|;
name|tdiag_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|t
expr_stmt|;
name|tdiag_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Handle the __gcc_cdiag__ format specifics.  */
if|if
condition|(
operator|!
name|cdiag_fci
condition|)
name|dynamic_format_types
index|[
name|gcc_cdiag_format_type
index|]
operator|.
name|conversion_specs
operator|=
name|cdiag_fci
operator|=
operator|(
name|format_char_info
operator|*
operator|)
name|xmemdup
argument_list|(
name|gcc_cdiag_char_table
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_cdiag_char_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_cdiag_char_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
condition|)
block|{
name|i
operator|=
name|find_char_info_specifier_index
argument_list|(
name|cdiag_fci
argument_list|,
literal|'H'
argument_list|)
expr_stmt|;
name|cdiag_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|loc
expr_stmt|;
name|cdiag_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t
condition|)
block|{
comment|/* All specifiers taking a tree share the same struct.  */
name|i
operator|=
name|find_char_info_specifier_index
argument_list|(
name|cdiag_fci
argument_list|,
literal|'D'
argument_list|)
expr_stmt|;
name|cdiag_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|t
expr_stmt|;
name|cdiag_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|find_char_info_specifier_index
argument_list|(
name|cdiag_fci
argument_list|,
literal|'J'
argument_list|)
expr_stmt|;
name|cdiag_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|t
expr_stmt|;
name|cdiag_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Handle the __gcc_cxxdiag__ format specifics.  */
if|if
condition|(
operator|!
name|cxxdiag_fci
condition|)
name|dynamic_format_types
index|[
name|gcc_cxxdiag_format_type
index|]
operator|.
name|conversion_specs
operator|=
name|cxxdiag_fci
operator|=
operator|(
name|format_char_info
operator|*
operator|)
name|xmemdup
argument_list|(
name|gcc_cxxdiag_char_table
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_cxxdiag_char_table
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|gcc_cxxdiag_char_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
condition|)
block|{
name|i
operator|=
name|find_char_info_specifier_index
argument_list|(
name|cxxdiag_fci
argument_list|,
literal|'H'
argument_list|)
expr_stmt|;
name|cxxdiag_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|loc
expr_stmt|;
name|cxxdiag_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t
condition|)
block|{
comment|/* All specifiers taking a tree share the same struct.  */
name|i
operator|=
name|find_char_info_specifier_index
argument_list|(
name|cxxdiag_fci
argument_list|,
literal|'D'
argument_list|)
expr_stmt|;
name|cxxdiag_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|t
expr_stmt|;
name|cxxdiag_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|find_char_info_specifier_index
argument_list|(
name|cxxdiag_fci
argument_list|,
literal|'J'
argument_list|)
expr_stmt|;
name|cxxdiag_fci
index|[
name|i
index|]
operator|.
name|types
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|&
name|t
expr_stmt|;
name|cxxdiag_fci
index|[
name|i
index|]
operator|.
name|pointer_count
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_FORMAT_TYPES
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|format_kind_info
name|TARGET_FORMAT_TYPES
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle a "format" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|handle_format_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|name
parameter_list|)
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|;
name|function_format_info
name|info
decl_stmt|;
name|tree
name|argument
decl_stmt|;
ifdef|#
directive|ifdef
name|TARGET_FORMAT_TYPES
comment|/* If the target provides additional format types, we need to      add them to FORMAT_TYPES at first use.  */
if|if
condition|(
name|TARGET_FORMAT_TYPES
operator|!=
name|NULL
operator|&&
operator|!
name|dynamic_format_types
condition|)
block|{
name|dynamic_format_types
operator|=
name|xmalloc
argument_list|(
operator|(
name|n_format_types
operator|+
name|TARGET_N_FORMAT_TYPES
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dynamic_format_types
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dynamic_format_types
argument_list|,
name|format_types_orig
argument_list|,
sizeof|sizeof
argument_list|(
name|format_types_orig
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dynamic_format_types
index|[
name|n_format_types
index|]
argument_list|,
name|TARGET_FORMAT_TYPES
argument_list|,
name|TARGET_N_FORMAT_TYPES
operator|*
sizeof|sizeof
argument_list|(
name|dynamic_format_types
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|format_types
operator|=
name|dynamic_format_types
expr_stmt|;
name|n_format_types
operator|+=
name|TARGET_N_FORMAT_TYPES
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|decode_format_attr
argument_list|(
name|args
argument_list|,
operator|&
name|info
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|argument
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument
condition|)
block|{
if|if
condition|(
operator|!
name|check_format_string
argument_list|(
name|argument
argument_list|,
name|info
operator|.
name|format_num
argument_list|,
name|flags
argument_list|,
name|no_add_attrs
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|info
operator|.
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|arg_num
init|=
literal|1
decl_stmt|;
comment|/* Verify that first_arg_num points to the last arg, 	     the ...  */
while|while
condition|(
name|argument
condition|)
name|arg_num
operator|++
operator|,
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_num
operator|!=
name|info
operator|.
name|first_arg_num
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_BUILT_IN
operator|)
condition|)
name|error
argument_list|(
literal|"args to be formatted is not %<...%>"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
block|}
if|if
condition|(
name|info
operator|.
name|format_type
operator|==
name|strftime_format_type
operator|&&
name|info
operator|.
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"strftime formats cannot format arguments"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* If this is a custom GCC-internal format type, we have to      initialize certain bits a runtime.  */
if|if
condition|(
name|info
operator|.
name|format_type
operator|==
name|asm_fprintf_format_type
operator|||
name|info
operator|.
name|format_type
operator|==
name|gcc_gfc_format_type
operator|||
name|info
operator|.
name|format_type
operator|==
name|gcc_diag_format_type
operator|||
name|info
operator|.
name|format_type
operator|==
name|gcc_tdiag_format_type
operator|||
name|info
operator|.
name|format_type
operator|==
name|gcc_cdiag_format_type
operator|||
name|info
operator|.
name|format_type
operator|==
name|gcc_cxxdiag_format_type
condition|)
block|{
comment|/* Our first time through, we have to make sure that our 	 format_type data is allocated dynamically and is modifiable.  */
if|if
condition|(
operator|!
name|dynamic_format_types
condition|)
name|format_types
operator|=
name|dynamic_format_types
operator|=
operator|(
name|format_kind_info
operator|*
operator|)
name|xmemdup
argument_list|(
name|format_types_orig
argument_list|,
sizeof|sizeof
argument_list|(
name|format_types_orig
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|format_types_orig
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is format __asm_fprintf__, we have to initialize 	 GCC's notion of HOST_WIDE_INT for checking %wd.  */
if|if
condition|(
name|info
operator|.
name|format_type
operator|==
name|asm_fprintf_format_type
condition|)
name|init_dynamic_asm_fprintf_info
argument_list|()
expr_stmt|;
comment|/* If this is format __gcc_gfc__, we have to initialize GCC's 	 notion of 'locus' at runtime for %L.  */
elseif|else
if|if
condition|(
name|info
operator|.
name|format_type
operator|==
name|gcc_gfc_format_type
condition|)
name|init_dynamic_gfc_info
argument_list|()
expr_stmt|;
comment|/* If this is one of the diagnostic attributes, then we have to 	 initialize 'location_t' and 'tree' at runtime.  */
elseif|else
if|if
condition|(
name|info
operator|.
name|format_type
operator|==
name|gcc_diag_format_type
operator|||
name|info
operator|.
name|format_type
operator|==
name|gcc_tdiag_format_type
operator|||
name|info
operator|.
name|format_type
operator|==
name|gcc_cdiag_format_type
operator|||
name|info
operator|.
name|format_type
operator|==
name|gcc_cxxdiag_format_type
condition|)
name|init_dynamic_diag_info
argument_list|()
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

end_unit

