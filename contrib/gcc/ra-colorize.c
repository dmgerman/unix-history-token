begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Graph coloring register allocator    Copyright (C) 2001, 2002 Free Software Foundation, Inc.    Contributed by Michael Matz<matz@suse.de>    and Daniel Berlin<dan@cgsoftware.com>.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the    terms of the GNU General Public License as published by the Free Software    Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more    details.     You should have received a copy of the GNU General Public License along    with GCC; see the file COPYING.  If not, write to the Free Software    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ra.h"
end_include

begin_comment
comment|/* This file is part of the graph coloring register allocator.    It contains the graph colorizer.  Given an interference graph    as set up in ra-build.c the toplevel function in this file    (ra_colorize_graph) colorizes the graph, leaving a list    of colored, coalesced and spilled nodes.     The algorithm used is a merge of George& Appels iterative coalescing    and optimistic coalescing, switchable at runtime.  The current default    is "optimistic coalescing +", which is based on the normal Briggs/Cooper    framework.  We can also use biased coloring.  Most of the structure    here follows the different papers.     Additionally there is a custom step to locally improve the overall    spill cost of the colored graph (recolor_spills).  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|push_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dlist
operator|*
operator|,
expr|struct
name|dlist
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_list_end
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dlist
operator|*
operator|,
expr|struct
name|dlist
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_dlist
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dlist
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|put_web_at_end
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
expr|enum
name|node_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|put_move
name|PARAMS
argument_list|(
operator|(
expr|struct
name|move
operator|*
operator|,
expr|enum
name|move_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_worklists
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_move
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decrement_degree
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|simplify
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_move_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
expr|struct
name|move
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_move
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
expr|struct
name|move
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_worklist
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ok
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|conservative
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|unsigned
name|int
name|simplify_p
name|PARAMS
argument_list|(
operator|(
expr|enum
name|node_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|combine
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coalesce
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freeze_moves
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freeze
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|select_spill
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|color_usable_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|HARD_REG_SET
operator|,
name|HARD_REG_SET
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|get_free_reg
name|PARAMS
argument_list|(
operator|(
name|HARD_REG_SET
operator|,
name|HARD_REG_SET
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_biased_reg
name|PARAMS
argument_list|(
operator|(
name|HARD_REG_SET
operator|,
name|HARD_REG_SET
operator|,
name|HARD_REG_SET
operator|,
name|HARD_REG_SET
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_long_blocks
name|PARAMS
argument_list|(
operator|(
name|HARD_REG_SET
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hardregset_to_string
name|PARAMS
argument_list|(
operator|(
name|HARD_REG_SET
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|calculate_dont_begin
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
name|HARD_REG_SET
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|colorize_one_web
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assign_colors
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|try_recolor_web
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_coalesced_conflicts
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_webs_maxcost
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|recolor_spills
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_colors
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_conflicts_from_coalesce
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|break_coalesced_spills
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unalias_web
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|break_aliases_to_web
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|break_precolored_alias
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_web_pairs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_web_pair_cost
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|,
expr|struct
name|web
operator|*
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_web_pairs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sort_and_combine_web_pairs
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aggressive_coalesce
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extended_coalesce_2
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_uncoalesced_moves
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dlist
modifier|*
name|mv_worklist
decl_stmt|,
modifier|*
name|mv_coalesced
decl_stmt|,
modifier|*
name|mv_constrained
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dlist
modifier|*
name|mv_frozen
decl_stmt|,
modifier|*
name|mv_active
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push a node onto the front of the list.  */
end_comment

begin_function
specifier|static
name|void
name|push_list
parameter_list|(
name|x
parameter_list|,
name|list
parameter_list|)
name|struct
name|dlist
modifier|*
name|x
decl_stmt|;
name|struct
name|dlist
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|->
name|next
operator|||
name|x
operator|->
name|prev
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
operator|*
name|list
condition|)
operator|(
operator|*
name|list
operator|)
operator|->
name|prev
operator|=
name|x
expr_stmt|;
operator|*
name|list
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|push_list_end
parameter_list|(
name|x
parameter_list|,
name|list
parameter_list|)
name|struct
name|dlist
modifier|*
name|x
decl_stmt|;
name|struct
name|dlist
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|->
name|prev
operator|||
name|x
operator|->
name|next
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|list
condition|)
block|{
operator|*
name|list
operator|=
name|x
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
operator|*
name|list
operator|)
operator|->
name|next
condition|)
name|list
operator|=
operator|&
operator|(
operator|(
operator|*
name|list
operator|)
operator|->
name|next
operator|)
expr_stmt|;
name|x
operator|->
name|prev
operator|=
operator|*
name|list
expr_stmt|;
operator|(
operator|*
name|list
operator|)
operator|->
name|next
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a node from the list.  */
end_comment

begin_function
name|void
name|remove_list
parameter_list|(
name|x
parameter_list|,
name|list
parameter_list|)
name|struct
name|dlist
modifier|*
name|x
decl_stmt|;
name|struct
name|dlist
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
name|struct
name|dlist
modifier|*
name|y
init|=
name|x
operator|->
name|prev
decl_stmt|;
if|if
condition|(
name|y
condition|)
name|y
operator|->
name|next
operator|=
name|x
operator|->
name|next
expr_stmt|;
else|else
operator|*
name|list
operator|=
name|x
operator|->
name|next
expr_stmt|;
name|y
operator|=
name|x
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|y
condition|)
name|y
operator|->
name|prev
operator|=
name|x
operator|->
name|prev
expr_stmt|;
name|x
operator|->
name|next
operator|=
name|x
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the front of the list.  */
end_comment

begin_function
name|struct
name|dlist
modifier|*
name|pop_list
parameter_list|(
name|list
parameter_list|)
name|struct
name|dlist
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
name|struct
name|dlist
modifier|*
name|r
init|=
operator|*
name|list
decl_stmt|;
if|if
condition|(
name|r
condition|)
name|remove_list
argument_list|(
name|r
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Free the given double linked list.  */
end_comment

begin_function
specifier|static
name|void
name|free_dlist
parameter_list|(
name|list
parameter_list|)
name|struct
name|dlist
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The web WEB should get the given new TYPE.  Put it onto the    appropriate list.    Inline, because it's called with constant TYPE every time.  */
end_comment

begin_function
specifier|inline
name|void
name|put_web
parameter_list|(
name|web
parameter_list|,
name|type
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|INITIAL
case|:
case|case
name|FREE
case|:
case|case
name|FREEZE
case|:
case|case
name|SPILL
case|:
case|case
name|SPILLED
case|:
case|case
name|COALESCED
case|:
case|case
name|COLORED
case|:
case|case
name|SELECT
case|:
name|push_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRECOLORED
case|:
name|push_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIMPLIFY
case|:
if|if
condition|(
name|web
operator|->
name|spill_temp
condition|)
name|push_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|type
operator|=
name|SIMPLIFY_SPILL
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|web
operator|->
name|add_hardregs
condition|)
name|push_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|type
operator|=
name|SIMPLIFY_FAT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|push_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|SIMPLIFY
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|web
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After we are done with the whole pass of coloring/spilling,    we reset the lists of webs, in preparation of the next pass.    The spilled webs become free, colored webs go to the initial list,    coalesced webs become free or initial, according to what type of web    they are coalesced to.  */
end_comment

begin_function
name|void
name|reset_lists
parameter_list|()
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|WEBS
argument_list|(
name|SIMPLIFY
argument_list|)
operator|||
name|WEBS
argument_list|(
name|SIMPLIFY_SPILL
argument_list|)
operator|||
name|WEBS
argument_list|(
name|SIMPLIFY_FAT
argument_list|)
operator|||
name|WEBS
argument_list|(
name|FREEZE
argument_list|)
operator|||
name|WEBS
argument_list|(
name|SPILL
argument_list|)
operator|||
name|WEBS
argument_list|(
name|SELECT
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|COALESCED
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|aweb
init|=
name|alias
argument_list|(
name|web
argument_list|)
decl_stmt|;
comment|/* Note, how alias() becomes invalid through the two put_web()'s 	 below.  It might set the type of a web to FREE (from COALESCED), 	 which itself is a target of aliasing (i.e. in the middle of 	 an alias chain).  We can handle this by checking also for 	 type == FREE.  Note nevertheless, that alias() is invalid 	 henceforth.  */
if|if
condition|(
name|aweb
operator|->
name|type
operator|==
name|SPILLED
operator|||
name|aweb
operator|->
name|type
operator|==
name|FREE
condition|)
name|put_web
argument_list|(
name|web
argument_list|,
name|FREE
argument_list|)
expr_stmt|;
else|else
name|put_web
argument_list|(
name|web
argument_list|,
name|INITIAL
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|d
operator|=
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|put_web
argument_list|(
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
argument_list|,
name|FREE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|COLORED
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|put_web
argument_list|(
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
argument_list|,
name|INITIAL
argument_list|)
expr_stmt|;
comment|/* All free webs have no conflicts anymore.  */
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|FREE
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|BITMAP_XFREE
argument_list|(
name|web
operator|->
name|useless_conflicts
argument_list|)
expr_stmt|;
name|web
operator|->
name|useless_conflicts
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Sanity check, that we only have free, initial or precolored webs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_webs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|ID2WEB
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|INITIAL
operator|&&
name|web
operator|->
name|type
operator|!=
name|FREE
operator|&&
name|web
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|free_dlist
argument_list|(
operator|&
name|mv_worklist
argument_list|)
expr_stmt|;
name|free_dlist
argument_list|(
operator|&
name|mv_coalesced
argument_list|)
expr_stmt|;
name|free_dlist
argument_list|(
operator|&
name|mv_constrained
argument_list|)
expr_stmt|;
name|free_dlist
argument_list|(
operator|&
name|mv_frozen
argument_list|)
expr_stmt|;
name|free_dlist
argument_list|(
operator|&
name|mv_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to put_web(), but add the web to the end of the appropriate    list.  Additionally TYPE may not be SIMPLIFY.  */
end_comment

begin_function
specifier|static
name|void
name|put_web_at_end
parameter_list|(
name|web
parameter_list|,
name|type
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|PRECOLORED
condition|)
name|type
operator|=
name|INITIAL
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|SIMPLIFY
condition|)
name|abort
argument_list|()
expr_stmt|;
name|push_list_end
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|web
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unlink WEB from the list it's currently on (which corresponds to    its current type).  */
end_comment

begin_function
name|void
name|remove_web_from_list
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|remove_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|remove_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|web
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Give MOVE the TYPE, and link it into the correct list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|put_move
parameter_list|(
name|move
parameter_list|,
name|type
parameter_list|)
name|struct
name|move
modifier|*
name|move
decl_stmt|;
name|enum
name|move_type
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|WORKLIST
case|:
name|push_list
argument_list|(
name|move
operator|->
name|dlink
argument_list|,
operator|&
name|mv_worklist
argument_list|)
expr_stmt|;
break|break;
case|case
name|MV_COALESCED
case|:
name|push_list
argument_list|(
name|move
operator|->
name|dlink
argument_list|,
operator|&
name|mv_coalesced
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRAINED
case|:
name|push_list
argument_list|(
name|move
operator|->
name|dlink
argument_list|,
operator|&
name|mv_constrained
argument_list|)
expr_stmt|;
break|break;
case|case
name|FROZEN
case|:
name|push_list
argument_list|(
name|move
operator|->
name|dlink
argument_list|,
operator|&
name|mv_frozen
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTIVE
case|:
name|push_list
argument_list|(
name|move
operator|->
name|dlink
argument_list|,
operator|&
name|mv_active
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|move
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build the worklists we are going to process.  */
end_comment

begin_function
specifier|static
name|void
name|build_worklists
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|,
modifier|*
name|d_next
decl_stmt|;
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|;
comment|/* If we are not the first pass, put all stackwebs (which are still      backed by a new pseudo, but conceptually can stand for a stackslot,      i.e. it doesn't really matter if they get a color or not), on      the SELECT stack first, those with lowest cost first.  This way      they will be colored last, so do not contrain the coloring of the      normal webs.  But still those with the highest count are colored      before, i.e. get a color more probable.  The use of stackregs is      a pure optimization, and all would work, if we used real stackslots      from the begin.  */
if|if
condition|(
name|ra_pass
operator|>
literal|1
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|num
decl_stmt|,
name|max_num
decl_stmt|;
name|struct
name|web
modifier|*
modifier|*
name|order2web
decl_stmt|;
name|max_num
operator|=
name|num_webs
operator|-
name|num_subwebs
expr_stmt|;
name|order2web
operator|=
operator|(
expr|struct
name|web
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_num
operator|*
sizeof|sizeof
argument_list|(
name|order2web
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|num
operator|=
literal|0
init|;
name|i
operator|<
name|max_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|id2web
index|[
name|i
index|]
operator|->
name|regno
operator|>=
name|max_normal_pseudo
condition|)
name|order2web
index|[
name|num
operator|++
index|]
operator|=
name|id2web
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|num
condition|)
block|{
name|qsort
argument_list|(
name|order2web
argument_list|,
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|order2web
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|comp_webs_maxcost
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num
operator|-
literal|1
init|;
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|order2web
index|[
name|i
index|]
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|remove_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|SELECT
argument_list|)
expr_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|pweb
init|=
name|wl
operator|->
name|t
decl_stmt|;
name|pweb
operator|->
name|num_conflicts
operator|-=
literal|1
operator|+
name|web
operator|->
name|add_hardregs
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|free
argument_list|(
name|order2web
argument_list|)
expr_stmt|;
block|}
comment|/* For all remaining initial webs, classify them.  */
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d_next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|d_next
operator|=
name|d
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
continue|continue;
name|remove_list
argument_list|(
name|d
argument_list|,
operator|&
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|num_conflicts
operator|>=
name|NUM_REGS
argument_list|(
name|web
argument_list|)
condition|)
name|put_web
argument_list|(
name|web
argument_list|,
name|SPILL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|web
operator|->
name|moves
condition|)
name|put_web
argument_list|(
name|web
argument_list|,
name|FREEZE
argument_list|)
expr_stmt|;
else|else
name|put_web
argument_list|(
name|web
argument_list|,
name|SIMPLIFY
argument_list|)
expr_stmt|;
block|}
comment|/* And put all moves on the worklist for iterated coalescing.      Note, that if iterated coalescing is off, then wl_moves doesn't      contain any moves.  */
for|for
control|(
name|ml
operator|=
name|wl_moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
if|if
condition|(
name|ml
operator|->
name|move
condition|)
block|{
name|struct
name|move
modifier|*
name|m
init|=
name|ml
operator|->
name|move
decl_stmt|;
name|d
operator|=
operator|(
expr|struct
name|dlist
operator|*
operator|)
name|ra_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dlist
argument_list|)
argument_list|)
expr_stmt|;
name|DLIST_MOVE
argument_list|(
name|d
argument_list|)
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|dlink
operator|=
name|d
expr_stmt|;
name|put_move
argument_list|(
name|m
argument_list|,
name|WORKLIST
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enable the active moves, in which WEB takes part, to be processed.  */
end_comment

begin_function
specifier|static
name|void
name|enable_move
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|;
for|for
control|(
name|ml
operator|=
name|web
operator|->
name|moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
if|if
condition|(
name|ml
operator|->
name|move
operator|->
name|type
operator|==
name|ACTIVE
condition|)
block|{
name|remove_list
argument_list|(
name|ml
operator|->
name|move
operator|->
name|dlink
argument_list|,
operator|&
name|mv_active
argument_list|)
expr_stmt|;
name|put_move
argument_list|(
name|ml
operator|->
name|move
argument_list|,
name|WORKLIST
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decrement the degree of node WEB by the amount DEC.    Possibly change the type of WEB, if the number of conflicts is    now smaller than its freedom.  */
end_comment

begin_function
specifier|static
name|void
name|decrement_degree
parameter_list|(
name|web
parameter_list|,
name|dec
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|int
name|dec
decl_stmt|;
block|{
name|int
name|before
init|=
name|web
operator|->
name|num_conflicts
decl_stmt|;
name|web
operator|->
name|num_conflicts
operator|-=
name|dec
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|num_conflicts
operator|<
name|NUM_REGS
argument_list|(
name|web
argument_list|)
operator|&&
name|before
operator|>=
name|NUM_REGS
argument_list|(
name|web
argument_list|)
condition|)
block|{
name|struct
name|conflict_link
modifier|*
name|a
decl_stmt|;
name|enable_move
argument_list|(
name|web
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|web
operator|->
name|conflict_list
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|aweb
init|=
name|a
operator|->
name|t
decl_stmt|;
if|if
condition|(
name|aweb
operator|->
name|type
operator|!=
name|SELECT
operator|&&
name|aweb
operator|->
name|type
operator|!=
name|COALESCED
condition|)
name|enable_move
argument_list|(
name|aweb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|FREEZE
condition|)
block|{
name|remove_web_from_list
argument_list|(
name|web
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|moves
condition|)
name|put_web
argument_list|(
name|web
argument_list|,
name|FREEZE
argument_list|)
expr_stmt|;
else|else
name|put_web
argument_list|(
name|web
argument_list|,
name|SIMPLIFY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Repeatedly simplify the nodes on the simplify worklists.  */
end_comment

begin_function
specifier|static
name|void
name|simplify
parameter_list|()
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* We try hard to color all the webs resulting from spills first. 	 Without that on register starved machines (x86 e.g) with some live 	 DImode pseudos, -fPIC, and an asm requiring %edx, it might be, that 	 we do rounds over rounds, because the conflict graph says, we can 	 simplify those short webs, but later due to irregularities we can't 	 color those pseudos.  So we have to spill them, which in later rounds 	 leads to other spills.  */
name|d
operator|=
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|SIMPLIFY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|SIMPLIFY_FAT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|SIMPLIFY_SPILL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
break|break;
name|web
operator|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_PROCESS
argument_list|,
literal|" simplifying web %3d, conflicts = %d\n"
argument_list|,
name|web
operator|->
name|id
argument_list|,
name|web
operator|->
name|num_conflicts
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|SELECT
argument_list|)
expr_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|pweb
init|=
name|wl
operator|->
name|t
decl_stmt|;
if|if
condition|(
name|pweb
operator|->
name|type
operator|!=
name|SELECT
operator|&&
name|pweb
operator|->
name|type
operator|!=
name|COALESCED
condition|)
block|{
name|decrement_degree
argument_list|(
name|pweb
argument_list|,
literal|1
operator|+
name|web
operator|->
name|add_hardregs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper function to remove a move from the movelist of the web.  */
end_comment

begin_function
specifier|static
name|void
name|remove_move_1
parameter_list|(
name|web
parameter_list|,
name|move
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|struct
name|move
modifier|*
name|move
decl_stmt|;
block|{
name|struct
name|move_list
modifier|*
name|ml
init|=
name|web
operator|->
name|moves
decl_stmt|;
if|if
condition|(
operator|!
name|ml
condition|)
return|return;
if|if
condition|(
name|ml
operator|->
name|move
operator|==
name|move
condition|)
block|{
name|web
operator|->
name|moves
operator|=
name|ml
operator|->
name|next
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|ml
operator|->
name|next
operator|&&
name|ml
operator|->
name|next
operator|->
name|move
operator|!=
name|move
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|ml
operator|->
name|next
condition|)
return|return;
name|ml
operator|->
name|next
operator|=
name|ml
operator|->
name|next
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a move from the movelist of the web.  Actually this is just a    wrapper around remove_move_1(), making sure, the removed move really is    not in the list anymore.  */
end_comment

begin_function
specifier|static
name|void
name|remove_move
parameter_list|(
name|web
parameter_list|,
name|move
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|struct
name|move
modifier|*
name|move
decl_stmt|;
block|{
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|;
name|remove_move_1
argument_list|(
name|web
argument_list|,
name|move
argument_list|)
expr_stmt|;
for|for
control|(
name|ml
operator|=
name|web
operator|->
name|moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
if|if
condition|(
name|ml
operator|->
name|move
operator|==
name|move
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Merge the moves for the two webs into the first web's movelist.  */
end_comment

begin_function
name|void
name|merge_moves
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|struct
name|web
modifier|*
name|u
decl_stmt|,
decl|*
name|v
decl_stmt|;
end_function

begin_block
block|{
name|regset
name|seen
decl_stmt|;
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|,
modifier|*
name|ml_next
decl_stmt|;
name|seen
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
for|for
control|(
name|ml
operator|=
name|u
operator|->
name|moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
name|bitmap_set_bit
argument_list|(
name|seen
argument_list|,
name|INSN_UID
argument_list|(
name|ml
operator|->
name|move
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ml
operator|=
name|v
operator|->
name|moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml_next
control|)
block|{
name|ml_next
operator|=
name|ml
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|seen
argument_list|,
name|INSN_UID
argument_list|(
name|ml
operator|->
name|move
operator|->
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|ml
operator|->
name|next
operator|=
name|u
operator|->
name|moves
expr_stmt|;
name|u
operator|->
name|moves
operator|=
name|ml
expr_stmt|;
block|}
block|}
name|BITMAP_XFREE
argument_list|(
name|seen
argument_list|)
expr_stmt|;
name|v
operator|->
name|moves
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add a web to the simplify worklist, from the freeze worklist.  */
end_comment

begin_function
specifier|static
name|void
name|add_worklist
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
operator|!
name|web
operator|->
name|moves
operator|&&
name|web
operator|->
name|num_conflicts
operator|<
name|NUM_REGS
argument_list|(
name|web
argument_list|)
condition|)
block|{
name|remove_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|FREEZE
argument_list|)
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|SIMPLIFY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Precolored node coalescing heuristic.  */
end_comment

begin_function
specifier|static
name|int
name|ok
parameter_list|(
name|target
parameter_list|,
name|source
parameter_list|)
name|struct
name|web
modifier|*
name|target
decl_stmt|,
decl|*
name|source
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|color
init|=
name|source
operator|->
name|color
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Normally one would think, the next test wouldn't be needed.      We try to coalesce S and T, and S has already a color, and we checked      when processing the insns, that both have the same mode.  So naively      we could conclude, that of course that mode was valid for this color.      Hah.  But there is sparc.  Before reload there are copy insns      (e.g. the ones copying arguments to locals) which happily refer to      colors in invalid modes.  We can't coalesce those things.  */
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|source
operator|->
name|color
argument_list|,
name|GET_MODE
argument_list|(
name|target
operator|->
name|orig_x
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Sanity for funny modes.  */
name|size
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|color
argument_list|,
name|GET_MODE
argument_list|(
name|target
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
return|return
literal|0
return|;
comment|/* We can't coalesce target with a precolored register which isn't in      usable_regs.  */
for|for
control|(
name|i
operator|=
name|size
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|never_use_colors
argument_list|,
name|color
operator|+
name|i
argument_list|)
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|target
operator|->
name|usable_regs
argument_list|,
name|color
operator|+
name|i
argument_list|)
comment|/* Before usually calling ok() at all, we already test, if the 	   candidates conflict in sup_igraph.  But when wide webs are 	   coalesced to hardregs, we only test the hardweb coalesced into. 	   This is only the begin color.  When actually coalescing both, 	   it will also take the following size colors, i.e. their webs. 	   We nowhere checked if the candidate possibly conflicts with 	   one of _those_, which is possible with partial conflicts, 	   so we simply do it here (this does one bit-test more than 	   necessary, the first color).  Note, that if X is precolored 	   bit [X*num_webs + Y] can't be set (see add_conflict_edge()).  */
operator|||
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|target
operator|->
name|id
operator|*
name|num_webs
operator|+
name|hardreg2web
index|[
name|color
operator|+
name|i
index|]
operator|->
name|id
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|wl
operator|=
name|target
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|pweb
init|=
name|wl
operator|->
name|t
decl_stmt|;
if|if
condition|(
name|pweb
operator|->
name|type
operator|==
name|SELECT
operator|||
name|pweb
operator|->
name|type
operator|==
name|COALESCED
condition|)
continue|continue;
comment|/* Coalescing target (T) and source (S) is o.k, if for 	 all conflicts C of T it is true, that: 	  1) C will be colored, or 	  2) C is a hardreg (precolored), or 	  3) C already conflicts with S too, or 	  4) a web which contains C conflicts already with S. 	 XXX: we handle here only the special case of 4), that C is 	 a subreg, and the containing thing is the reg itself, i.e. 	 we dont handle the situation, were T conflicts with 	 (subreg:SI x 1), and S conflicts with (subreg:DI x 0), which 	 would be allowed also, as the S-conflict overlaps 	 the T-conflict.          So, we first test the whole web for any of these conditions, and          continue with the next C, if 1, 2 or 3 is true.  */
if|if
condition|(
name|pweb
operator|->
name|num_conflicts
operator|<
name|NUM_REGS
argument_list|(
name|pweb
argument_list|)
operator|||
name|pweb
operator|->
name|type
operator|==
name|PRECOLORED
operator|||
name|TEST_BIT
argument_list|(
name|igraph
argument_list|,
name|igraph_index
argument_list|(
name|source
operator|->
name|id
argument_list|,
name|pweb
operator|->
name|id
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* This is reached, if not one of 1, 2 or 3 was true.  In the case C has          no subwebs, 4 can't be true either, so we can't coalesce S and T.  */
if|if
condition|(
name|wl
operator|->
name|sub
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
block|{
comment|/* The main webs do _not_ conflict, only some parts of both.  This 	     means, that 4 is possibly true, so we need to check this too. 	     For this we go thru all sub conflicts between T and C, and see if 	     the target part of C already conflicts with S.  When this is not 	     the case we disallow coalescing.  */
name|struct
name|sub_conflict
modifier|*
name|sl
decl_stmt|;
for|for
control|(
name|sl
operator|=
name|wl
operator|->
name|sub
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|igraph
argument_list|,
name|igraph_index
argument_list|(
name|source
operator|->
name|id
argument_list|,
name|sl
operator|->
name|t
operator|->
name|id
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Non-precolored node coalescing heuristic.  */
end_comment

begin_function
specifier|static
name|int
name|conservative
parameter_list|(
name|target
parameter_list|,
name|source
parameter_list|)
name|struct
name|web
modifier|*
name|target
decl_stmt|,
decl|*
name|source
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|int
name|k
decl_stmt|;
name|unsigned
name|int
name|loop
decl_stmt|;
name|regset
name|seen
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|unsigned
name|int
name|num_regs
init|=
name|NUM_REGS
argument_list|(
name|target
argument_list|)
decl_stmt|;
comment|/* XXX */
comment|/* k counts the resulting conflict weight, if target and source      would be merged, and all low-degree neighbors would be      removed.  */
name|k
operator|=
literal|0
operator|*
name|MAX
argument_list|(
name|target
operator|->
name|add_hardregs
argument_list|,
name|source
operator|->
name|add_hardregs
argument_list|)
expr_stmt|;
name|seen
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
literal|2
condition|;
name|loop
operator|++
control|)
for|for
control|(
name|wl
operator|=
operator|(
operator|(
name|loop
operator|==
literal|0
operator|)
condition|?
name|target
else|:
name|source
operator|)
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|pweb
init|=
name|wl
operator|->
name|t
decl_stmt|;
if|if
condition|(
name|pweb
operator|->
name|type
operator|!=
name|SELECT
operator|&&
name|pweb
operator|->
name|type
operator|!=
name|COALESCED
operator|&&
name|pweb
operator|->
name|num_conflicts
operator|>=
name|NUM_REGS
argument_list|(
name|pweb
argument_list|)
operator|&&
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|seen
argument_list|,
name|pweb
operator|->
name|id
argument_list|)
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|seen
argument_list|,
name|pweb
operator|->
name|id
argument_list|)
expr_stmt|;
name|k
operator|+=
literal|1
operator|+
name|pweb
operator|->
name|add_hardregs
expr_stmt|;
block|}
block|}
name|BITMAP_XFREE
argument_list|(
name|seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|num_regs
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* If the web is coalesced, return it's alias.  Otherwise, return what    was passed in.  */
end_comment

begin_function
name|struct
name|web
modifier|*
name|alias
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
while|while
condition|(
name|web
operator|->
name|type
operator|==
name|COALESCED
condition|)
name|web
operator|=
name|web
operator|->
name|alias
expr_stmt|;
return|return
name|web
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero, if the TYPE belongs to one of those representing    SIMPLIFY types.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|simplify_p
parameter_list|(
name|type
parameter_list|)
name|enum
name|node_type
name|type
decl_stmt|;
block|{
return|return
name|type
operator|==
name|SIMPLIFY
operator|||
name|type
operator|==
name|SIMPLIFY_SPILL
operator|||
name|type
operator|==
name|SIMPLIFY_FAT
return|;
block|}
end_function

begin_comment
comment|/* Actually combine two webs, that can be coalesced.  */
end_comment

begin_function
specifier|static
name|void
name|combine
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|struct
name|web
modifier|*
name|u
decl_stmt|,
decl|*
name|v
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
if|if
condition|(
name|u
operator|==
name|v
operator|||
name|v
operator|->
name|type
operator|==
name|COALESCED
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|->
name|regno
operator|>=
name|max_normal_pseudo
operator|)
operator|!=
operator|(
name|v
operator|->
name|regno
operator|>=
name|max_normal_pseudo
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|remove_web_from_list
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|v
argument_list|,
name|COALESCED
argument_list|)
expr_stmt|;
name|v
operator|->
name|alias
operator|=
name|u
expr_stmt|;
name|u
operator|->
name|is_coalesced
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|is_coalesced
operator|=
literal|1
expr_stmt|;
name|u
operator|->
name|num_aliased
operator|+=
literal|1
operator|+
name|v
operator|->
name|num_aliased
expr_stmt|;
if|if
condition|(
name|flag_ra_merge_spill_costs
operator|&&
name|u
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
name|u
operator|->
name|spill_cost
operator|+=
name|v
operator|->
name|spill_cost
expr_stmt|;
comment|/*u->spill_cost = MAX (u->spill_cost, v->spill_cost);*/
name|merge_moves
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* combine add_hardregs's of U and V.  */
for|for
control|(
name|wl
operator|=
name|v
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|pweb
init|=
name|wl
operator|->
name|t
decl_stmt|;
comment|/* We don't strictly need to move conflicts between webs which are 	 already coalesced or selected, if we do iterated coalescing, or 	 better if we need not to be able to break aliases again. 	 I.e. normally we would use the condition 	 (pweb->type != SELECT&& pweb->type != COALESCED). 	 But for now we simply merge all conflicts.  It doesn't take that          much time.  */
if|if
condition|(
literal|1
condition|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|u
decl_stmt|;
name|int
name|nregs
init|=
literal|1
operator|+
name|v
operator|->
name|add_hardregs
decl_stmt|;
if|if
condition|(
name|u
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|u
operator|->
name|color
argument_list|,
name|GET_MODE
argument_list|(
name|v
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For precolored U's we need to make conflicts between V's 	     neighbors and as many hardregs from U as V needed if it gets 	     color U.  For now we approximate this by V->add_hardregs, which 	     could be too much in multi-length classes.  We should really 	     count how many hardregs are needed for V with color U.  When U 	     isn't precolored this loop breaks out after one iteration.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|u
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|web
operator|=
name|hardreg2web
index|[
name|i
operator|+
name|u
operator|->
name|color
index|]
expr_stmt|;
if|if
condition|(
name|wl
operator|->
name|sub
operator|==
name|NULL
condition|)
name|record_conflict
argument_list|(
name|web
argument_list|,
name|pweb
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|sub_conflict
modifier|*
name|sl
decl_stmt|;
comment|/* So, between V and PWEB there are sub_conflicts.  We 		     need to relocate those conflicts to be between WEB (== 		     U when it wasn't precolored) and PWEB.  In the case 		     only a part of V conflicted with (part of) PWEB we 		     nevertheless make the new conflict between the whole U 		     and the (part of) PWEB.  Later we might try to find in 		     U the correct subpart corresponding (by size and 		     offset) to the part of V (sl->s) which was the source 		     of the conflict.  */
for|for
control|(
name|sl
operator|=
name|wl
operator|->
name|sub
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
block|{
comment|/* Beware: sl->s is no subweb of web (== U) but of V. 			 We try to search a corresponding subpart of U. 			 If we found none we let it conflict with the whole U. 			 Note that find_subweb() only looks for mode and 			 subreg_byte of the REG rtx but not for the pseudo 			 reg number (otherwise it would be guaranteed to 			 _not_ find any subpart).  */
name|struct
name|web
modifier|*
name|sweb
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|SUBWEB_P
argument_list|(
name|sl
operator|->
name|s
argument_list|)
condition|)
name|sweb
operator|=
name|find_subweb
argument_list|(
name|web
argument_list|,
name|sl
operator|->
name|s
operator|->
name|orig_x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sweb
condition|)
name|sweb
operator|=
name|web
expr_stmt|;
name|record_conflict
argument_list|(
name|sweb
argument_list|,
name|sl
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|u
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
break|break;
block|}
if|if
condition|(
name|pweb
operator|->
name|type
operator|!=
name|SELECT
operator|&&
name|pweb
operator|->
name|type
operator|!=
name|COALESCED
condition|)
name|decrement_degree
argument_list|(
name|pweb
argument_list|,
literal|1
operator|+
name|v
operator|->
name|add_hardregs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now merge the usable_regs together.  */
comment|/* XXX That merging might normally make it necessary to      adjust add_hardregs, which also means to adjust neighbors.  This can      result in making some more webs trivially colorable, (or the opposite,      if this increases our add_hardregs).  Because we intersect the      usable_regs it should only be possible to decrease add_hardregs.  So a      conservative solution for now is to simply don't change it.  */
name|u
operator|->
name|use_my_regs
operator|=
literal|1
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|u
operator|->
name|usable_regs
argument_list|,
name|v
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
name|u
operator|->
name|regclass
operator|=
name|reg_class_subunion
index|[
name|u
operator|->
name|regclass
index|]
index|[
name|v
operator|->
name|regclass
index|]
expr_stmt|;
comment|/* Count number of possible hardregs.  This might make U a spillweb,      but that could also happen, if U and V together had too many      conflicts.  */
name|u
operator|->
name|num_freedom
operator|=
name|hard_regs_count
argument_list|(
name|u
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
name|u
operator|->
name|num_freedom
operator|-=
name|u
operator|->
name|add_hardregs
expr_stmt|;
comment|/* The next would mean an invalid coalesced move (both webs have no      possible hardreg in common), so abort.  */
if|if
condition|(
operator|!
name|u
operator|->
name|num_freedom
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|num_conflicts
operator|>=
name|NUM_REGS
argument_list|(
name|u
argument_list|)
operator|&&
operator|(
name|u
operator|->
name|type
operator|==
name|FREEZE
operator|||
name|simplify_p
argument_list|(
name|u
operator|->
name|type
argument_list|)
operator|)
condition|)
block|{
name|remove_web_from_list
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|u
argument_list|,
name|SPILL
argument_list|)
expr_stmt|;
block|}
comment|/* We want the most relaxed combination of spill_temp state.      I.e. if any was no spilltemp or a spilltemp2, the result is so too,      otherwise if any is short, the result is too.  It remains, when both      are normal spilltemps.  */
if|if
condition|(
name|v
operator|->
name|spill_temp
operator|==
literal|0
condition|)
name|u
operator|->
name|spill_temp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|spill_temp
operator|==
literal|2
operator|&&
name|u
operator|->
name|spill_temp
operator|!=
literal|0
condition|)
name|u
operator|->
name|spill_temp
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|spill_temp
operator|==
literal|3
operator|&&
name|u
operator|->
name|spill_temp
operator|==
literal|1
condition|)
name|u
operator|->
name|spill_temp
operator|=
literal|3
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Attempt to coalesce the first thing on the move worklist.    This is used only for iterated coalescing.  */
end_comment

begin_function
specifier|static
name|void
name|coalesce
parameter_list|()
block|{
name|struct
name|dlist
modifier|*
name|d
init|=
name|pop_list
argument_list|(
operator|&
name|mv_worklist
argument_list|)
decl_stmt|;
name|struct
name|move
modifier|*
name|m
init|=
name|DLIST_MOVE
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|source
init|=
name|alias
argument_list|(
name|m
operator|->
name|source_web
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|target
init|=
name|alias
argument_list|(
name|m
operator|->
name|target_web
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
block|{
name|struct
name|web
modifier|*
name|h
init|=
name|source
decl_stmt|;
name|source
operator|=
name|target
expr_stmt|;
name|target
operator|=
name|h
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|==
name|target
condition|)
block|{
name|remove_move
argument_list|(
name|source
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|put_move
argument_list|(
name|m
argument_list|,
name|MV_COALESCED
argument_list|)
expr_stmt|;
name|add_worklist
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|->
name|type
operator|==
name|PRECOLORED
operator|||
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|source
operator|->
name|id
operator|*
name|num_webs
operator|+
name|target
operator|->
name|id
argument_list|)
operator|||
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|target
operator|->
name|id
operator|*
name|num_webs
operator|+
name|source
operator|->
name|id
argument_list|)
condition|)
block|{
name|remove_move
argument_list|(
name|source
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|remove_move
argument_list|(
name|target
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|put_move
argument_list|(
name|m
argument_list|,
name|CONSTRAINED
argument_list|)
expr_stmt|;
name|add_worklist
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|add_worklist
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|source
operator|->
name|type
operator|==
name|PRECOLORED
operator|&&
name|ok
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
operator|)
operator|||
operator|(
name|source
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
name|conservative
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
name|remove_move
argument_list|(
name|source
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|remove_move
argument_list|(
name|target
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|put_move
argument_list|(
name|m
argument_list|,
name|MV_COALESCED
argument_list|)
expr_stmt|;
name|combine
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|add_worklist
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
else|else
name|put_move
argument_list|(
name|m
argument_list|,
name|ACTIVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Freeze the moves associated with the web.  Used for iterated coalescing.  */
end_comment

begin_function
specifier|static
name|void
name|freeze_moves
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|,
modifier|*
name|ml_next
decl_stmt|;
for|for
control|(
name|ml
operator|=
name|web
operator|->
name|moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml_next
control|)
block|{
name|struct
name|move
modifier|*
name|m
init|=
name|ml
operator|->
name|move
decl_stmt|;
name|struct
name|web
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|ml_next
operator|=
name|ml
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|type
operator|==
name|ACTIVE
condition|)
name|remove_list
argument_list|(
name|m
operator|->
name|dlink
argument_list|,
operator|&
name|mv_active
argument_list|)
expr_stmt|;
else|else
name|remove_list
argument_list|(
name|m
operator|->
name|dlink
argument_list|,
operator|&
name|mv_worklist
argument_list|)
expr_stmt|;
name|put_move
argument_list|(
name|m
argument_list|,
name|FROZEN
argument_list|)
expr_stmt|;
name|remove_move
argument_list|(
name|web
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|src
operator|=
name|alias
argument_list|(
name|m
operator|->
name|source_web
argument_list|)
expr_stmt|;
name|dest
operator|=
name|alias
argument_list|(
name|m
operator|->
name|target_web
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|src
operator|==
name|web
operator|)
condition|?
name|dest
else|:
name|src
expr_stmt|;
name|remove_move
argument_list|(
name|src
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* XXX GA use the original v, instead of alias(v) */
if|if
condition|(
operator|!
name|src
operator|->
name|moves
operator|&&
name|src
operator|->
name|num_conflicts
operator|<
name|NUM_REGS
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|remove_list
argument_list|(
name|src
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|FREEZE
argument_list|)
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|src
argument_list|,
name|SIMPLIFY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Freeze the first thing on the freeze worklist (only for iterated    coalescing).  */
end_comment

begin_function
specifier|static
name|void
name|freeze
parameter_list|()
block|{
name|struct
name|dlist
modifier|*
name|d
init|=
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|FREEZE
argument_list|)
argument_list|)
decl_stmt|;
name|put_web
argument_list|(
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
argument_list|,
name|SIMPLIFY
argument_list|)
expr_stmt|;
name|freeze_moves
argument_list|(
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The current spill heuristic.  Returns a number for a WEB.    Webs with higher numbers are selected later.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
argument_list|(
operator|*
name|spill_heuristic
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|default_spill_heuristic
name|PARAMS
argument_list|(
operator|(
expr|struct
name|web
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our default heuristic is similar to spill_cost / num_conflicts.    Just scaled for integer arithmetic, and it favors coalesced webs,    and webs which span more insns with deaths.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|default_spill_heuristic
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|ret
decl_stmt|;
name|unsigned
name|int
name|divisor
init|=
literal|1
decl_stmt|;
comment|/* Make coalesce targets cheaper to spill, because they will be broken      up again into smaller parts.  */
if|if
condition|(
name|flag_ra_break_aliases
condition|)
name|divisor
operator|+=
name|web
operator|->
name|num_aliased
expr_stmt|;
name|divisor
operator|+=
name|web
operator|->
name|num_conflicts
expr_stmt|;
name|ret
operator|=
operator|(
operator|(
name|web
operator|->
name|spill_cost
operator|<<
literal|8
operator|)
operator|+
name|divisor
operator|-
literal|1
operator|)
operator|/
name|divisor
expr_stmt|;
comment|/* It is better to spill webs that span more insns (deaths in our      case) than other webs with the otherwise same spill_cost.  So make      them a little bit cheaper.  Remember that spill_cost is unsigned.  */
if|if
condition|(
name|web
operator|->
name|span_deaths
operator|<
name|ret
condition|)
name|ret
operator|-=
name|web
operator|->
name|span_deaths
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Select the cheapest spill to be potentially spilled (we don't    *actually* spill until we need to).  */
end_comment

begin_function
specifier|static
name|void
name|select_spill
parameter_list|()
block|{
name|unsigned
name|HOST_WIDE_INT
name|best
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
decl_stmt|;
name|struct
name|dlist
modifier|*
name|bestd
init|=
name|NULL
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|best2
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
decl_stmt|;
name|struct
name|dlist
modifier|*
name|bestd2
init|=
name|NULL
decl_stmt|;
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|SPILL
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|w
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|cost
init|=
name|spill_heuristic
argument_list|(
name|w
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|w
operator|->
name|spill_temp
operator|)
operator|&&
name|cost
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|cost
expr_stmt|;
name|bestd
operator|=
name|d
expr_stmt|;
block|}
comment|/* Specially marked spill temps can be spilled.  Also coalesce 	 targets can.  Eventually they will be broken up later in the 	 colorizing process, so if we have nothing better take that.  */
elseif|else
if|if
condition|(
operator|(
name|w
operator|->
name|spill_temp
operator|==
literal|2
operator|||
name|w
operator|->
name|is_coalesced
operator|)
operator|&&
name|cost
operator|<
name|best2
condition|)
block|{
name|best2
operator|=
name|cost
expr_stmt|;
name|bestd2
operator|=
name|d
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bestd
condition|)
block|{
name|bestd
operator|=
name|bestd2
expr_stmt|;
name|best
operator|=
name|best2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bestd
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Note the potential spill.  */
name|DLIST_WEB
argument_list|(
name|bestd
argument_list|)
operator|->
name|was_spilled
operator|=
literal|1
expr_stmt|;
name|remove_list
argument_list|(
name|bestd
argument_list|,
operator|&
name|WEBS
argument_list|(
name|SPILL
argument_list|)
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|DLIST_WEB
argument_list|(
name|bestd
argument_list|)
argument_list|,
name|SIMPLIFY
argument_list|)
expr_stmt|;
name|freeze_moves
argument_list|(
name|DLIST_WEB
argument_list|(
name|bestd
argument_list|)
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_PROCESS
argument_list|,
literal|" potential spill web %3d, conflicts = %d\n"
argument_list|,
name|DLIST_WEB
argument_list|(
name|bestd
argument_list|)
operator|->
name|id
argument_list|,
name|DLIST_WEB
argument_list|(
name|bestd
argument_list|)
operator|->
name|num_conflicts
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a set of forbidden colors to begin at, and a set of still    free colors, and MODE, returns nonzero of color C is still usable.  */
end_comment

begin_function
specifier|static
name|int
name|color_usable_p
parameter_list|(
name|c
parameter_list|,
name|dont_begin_colors
parameter_list|,
name|free_colors
parameter_list|,
name|mode
parameter_list|)
name|int
name|c
decl_stmt|;
name|HARD_REG_SET
name|dont_begin_colors
decl_stmt|,
name|free_colors
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|dont_begin_colors
argument_list|,
name|c
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|free_colors
argument_list|,
name|c
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|c
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|size
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|c
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|free_colors
argument_list|,
name|c
operator|+
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
name|size
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* I don't want to clutter up the actual code with ifdef's.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
end_ifdef

begin_define
define|#
directive|define
name|INV_REG_ALLOC_ORDER
parameter_list|(
name|c
parameter_list|)
value|inv_reg_alloc_order[c]
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INV_REG_ALLOC_ORDER
parameter_list|(
name|c
parameter_list|)
value|c
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Searches in FREE_COLORS for a block of hardregs of the right length    for MODE, which doesn't begin at a hardreg mentioned in DONT_BEGIN_COLORS.    If it needs more than one hardreg it prefers blocks beginning    at an even hardreg, and only gives an odd begin reg if no other    block could be found.  */
end_comment

begin_function
name|int
name|get_free_reg
parameter_list|(
name|dont_begin_colors
parameter_list|,
name|free_colors
parameter_list|,
name|mode
parameter_list|)
name|HARD_REG_SET
name|dont_begin_colors
decl_stmt|,
name|free_colors
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|last_resort_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|pref_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|pref_reg_order
init|=
name|INT_MAX
decl_stmt|;
name|int
name|last_resort_reg_order
init|=
name|INT_MAX
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|dont_begin_colors
argument_list|,
name|c
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|free_colors
argument_list|,
name|c
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|c
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|size
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|c
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|free_colors
argument_list|,
name|c
operator|+
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|!=
name|size
condition|)
block|{
name|c
operator|+=
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|==
name|size
condition|)
block|{
if|if
condition|(
name|size
operator|<
literal|2
operator|||
operator|(
name|c
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|INV_REG_ALLOC_ORDER
argument_list|(
name|c
argument_list|)
operator|<
name|pref_reg_order
condition|)
block|{
name|pref_reg
operator|=
name|c
expr_stmt|;
name|pref_reg_order
operator|=
name|INV_REG_ALLOC_ORDER
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|INV_REG_ALLOC_ORDER
argument_list|(
name|c
argument_list|)
operator|<
name|last_resort_reg_order
condition|)
block|{
name|last_resort_reg
operator|=
name|c
expr_stmt|;
name|last_resort_reg_order
operator|=
name|INV_REG_ALLOC_ORDER
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|c
operator|+=
name|i
expr_stmt|;
block|}
return|return
name|pref_reg
operator|>=
literal|0
condition|?
name|pref_reg
else|:
name|last_resort_reg
return|;
block|}
end_function

begin_comment
comment|/* Similar to get_free_reg(), but first search in colors provided    by BIAS _and_ PREFER_COLORS, then in BIAS alone, then in PREFER_COLORS    alone, and only then for any free color.  If flag_ra_biased is zero    only do the last two steps.  */
end_comment

begin_function
specifier|static
name|int
name|get_biased_reg
parameter_list|(
name|dont_begin_colors
parameter_list|,
name|bias
parameter_list|,
name|prefer_colors
parameter_list|,
name|free_colors
parameter_list|,
name|mode
parameter_list|)
name|HARD_REG_SET
name|dont_begin_colors
decl_stmt|,
name|bias
decl_stmt|,
name|prefer_colors
decl_stmt|,
name|free_colors
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|c
init|=
operator|-
literal|1
decl_stmt|;
name|HARD_REG_SET
name|s
decl_stmt|;
if|if
condition|(
name|flag_ra_biased
condition|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|s
argument_list|,
name|dont_begin_colors
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|s
argument_list|,
name|bias
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|s
argument_list|,
name|prefer_colors
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_free_reg
argument_list|(
name|s
argument_list|,
name|free_colors
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
return|;
name|COPY_HARD_REG_SET
argument_list|(
name|s
argument_list|,
name|dont_begin_colors
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|s
argument_list|,
name|bias
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_free_reg
argument_list|(
name|s
argument_list|,
name|free_colors
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
return|;
block|}
name|COPY_HARD_REG_SET
argument_list|(
name|s
argument_list|,
name|dont_begin_colors
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|s
argument_list|,
name|prefer_colors
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_free_reg
argument_list|(
name|s
argument_list|,
name|free_colors
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
return|;
name|c
operator|=
name|get_free_reg
argument_list|(
name|dont_begin_colors
argument_list|,
name|free_colors
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Counts the number of non-overlapping bitblocks of length LEN    in FREE_COLORS.  */
end_comment

begin_function
specifier|static
name|int
name|count_long_blocks
parameter_list|(
name|free_colors
parameter_list|,
name|len
parameter_list|)
name|HARD_REG_SET
name|free_colors
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|free_colors
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|free_colors
argument_list|,
name|i
operator|+
name|j
argument_list|)
condition|)
break|break;
comment|/* Bits [i .. i+j-1] are free.  */
if|if
condition|(
name|j
operator|==
name|len
condition|)
name|count
operator|++
expr_stmt|;
name|i
operator|+=
name|j
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Given a hardreg set S, return a string representing it.    Either as 0/1 string, or as hex value depending on the implementation    of hardreg sets.  Note that this string is statically allocated.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hardregset_to_string
parameter_list|(
name|s
parameter_list|)
name|HARD_REG_SET
name|s
decl_stmt|;
block|{
specifier|static
name|char
name|string
index|[
comment|/*FIRST_PSEUDO_REGISTER + 30*/
literal|1024
index|]
decl_stmt|;
if|#
directive|if
name|FIRST_PSEUDO_REGISTER
operator|<=
name|HOST_BITS_PER_WIDE_INT
name|sprintf
argument_list|(
name|string
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|c
init|=
name|string
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|c
operator|+=
name|sprintf
argument_list|(
name|c
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HARD_REG_SET_LONGS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|;
name|j
operator|++
control|)
name|c
operator|+=
name|sprintf
argument_list|(
name|c
argument_list|,
literal|"%s"
argument_list|,
operator|(
literal|1
operator|<<
name|j
operator|)
operator|&
name|s
index|[
name|i
index|]
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|c
operator|+=
name|sprintf
argument_list|(
name|c
argument_list|,
literal|"%s"
argument_list|,
name|i
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|c
operator|+=
name|sprintf
argument_list|(
name|c
argument_list|,
literal|" }"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* For WEB, look at its already colored neighbors, and calculate    the set of hardregs which is not allowed as color for WEB.  Place    that set int *RESULT.  Note that the set of forbidden begin colors    is not the same as all colors taken up by neighbors.  E.g. suppose    two DImode webs, but only the lo-part from one conflicts with the    hipart from the other, and suppose the other gets colors 2 and 3    (it needs two SImode hardregs).  Now the first can take also color    1 or 2, although in those cases there's a partial overlap.  Only    3 can't be used as begin color.  */
end_comment

begin_function
specifier|static
name|void
name|calculate_dont_begin
parameter_list|(
name|web
parameter_list|,
name|result
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|result
decl_stmt|;
block|{
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|HARD_REG_SET
name|dont_begin
decl_stmt|;
comment|/* The bits set in dont_begin correspond to the hardregs, at which      WEB may not begin.  This differs from the set of _all_ hardregs which      are taken by WEB's conflicts in the presence of wide webs, where only      some parts conflict with others.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|dont_begin
argument_list|)
expr_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|w
decl_stmt|;
name|struct
name|web
modifier|*
name|ptarget
init|=
name|alias
argument_list|(
name|wl
operator|->
name|t
argument_list|)
decl_stmt|;
name|struct
name|sub_conflict
modifier|*
name|sl
init|=
name|wl
operator|->
name|sub
decl_stmt|;
name|w
operator|=
name|sl
condition|?
name|sl
operator|->
name|t
else|:
name|wl
operator|->
name|t
expr_stmt|;
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|ptarget
operator|->
name|type
operator|==
name|COLORED
operator|||
name|ptarget
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
block|{
name|struct
name|web
modifier|*
name|source
init|=
operator|(
name|sl
operator|)
condition|?
name|sl
operator|->
name|s
else|:
name|web
decl_stmt|;
name|unsigned
name|int
name|tsize
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|ptarget
operator|->
name|color
argument_list|,
name|GET_MODE
argument_list|(
name|w
operator|->
name|orig_x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* ssize is only a first guess for the size.  */
name|unsigned
name|int
name|ssize
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|ptarget
operator|->
name|color
argument_list|,
name|GET_MODE
argument_list|(
name|source
operator|->
name|orig_x
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tofs
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|sofs
init|=
literal|0
decl_stmt|;
comment|/* C1 and C2 can become negative, so unsigned 		 would be wrong.  */
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
name|SUBWEB_P
argument_list|(
name|w
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|w
operator|->
name|orig_x
argument_list|)
argument_list|)
operator|>=
name|UNITS_PER_WORD
condition|)
name|tofs
operator|=
operator|(
name|SUBREG_BYTE
argument_list|(
name|w
operator|->
name|orig_x
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
if|if
condition|(
name|SUBWEB_P
argument_list|(
name|source
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|source
operator|->
name|orig_x
argument_list|)
argument_list|)
operator|>=
name|UNITS_PER_WORD
condition|)
name|sofs
operator|=
operator|(
name|SUBREG_BYTE
argument_list|(
name|source
operator|->
name|orig_x
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|c1
operator|=
name|ptarget
operator|->
name|color
operator|+
name|tofs
operator|-
name|sofs
operator|-
name|ssize
operator|+
literal|1
expr_stmt|;
name|c2
operator|=
name|ptarget
operator|->
name|color
operator|+
name|tofs
operator|+
name|tsize
operator|-
literal|1
operator|-
name|sofs
expr_stmt|;
if|if
condition|(
name|c2
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|c1
operator|<
literal|0
condition|)
name|c1
operator|=
literal|0
expr_stmt|;
comment|/* Because ssize was only guessed above, which influenced our 		     begin color (c1), we need adjustment, if for that color 		     another size would be needed.  This is done by moving 		     c1 to a place, where the last of sources hardregs does not 		     overlap the first of targets colors.  */
while|while
condition|(
name|c1
operator|+
name|sofs
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|c1
argument_list|,
name|GET_MODE
argument_list|(
name|source
operator|->
name|orig_x
argument_list|)
argument_list|)
operator|-
literal|1
operator|<
name|ptarget
operator|->
name|color
operator|+
name|tofs
condition|)
name|c1
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|>
literal|0
operator|&&
name|c1
operator|+
name|sofs
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|c1
argument_list|,
name|GET_MODE
argument_list|(
name|source
operator|->
name|orig_x
argument_list|)
argument_list|)
operator|-
literal|1
operator|>
name|ptarget
operator|->
name|color
operator|+
name|tofs
condition|)
name|c1
operator|--
expr_stmt|;
for|for
control|(
init|;
name|c1
operator|<=
name|c2
condition|;
name|c1
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|dont_begin
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The next if() only gets true, if there was no wl->sub at all, in 	     which case we are only making one go thru this loop with W being 	     a whole web.  */
if|if
condition|(
operator|!
name|sl
condition|)
break|break;
name|sl
operator|=
name|sl
operator|->
name|next
expr_stmt|;
name|w
operator|=
name|sl
condition|?
name|sl
operator|->
name|t
else|:
name|NULL
expr_stmt|;
block|}
block|}
name|COPY_HARD_REG_SET
argument_list|(
operator|*
name|result
argument_list|,
name|dont_begin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to assign a color to WEB.  If HARD if nonzero, we try many    tricks to get it one color, including respilling already colored    neighbors.     We also trie very hard, to not constrain the uncolored non-spill    neighbors, which need more hardregs than we.  Consider a situation, 2    hardregs free for us (0 and 1), and one of our neighbors needs 2    hardregs, and only conflicts with us.  There are 3 hardregs at all.  Now    a simple minded method might choose 1 as color for us.  Then our neighbor    has two free colors (0 and 2) as it should, but they are not consecutive,    so coloring it later would fail.  This leads to nasty problems on    register starved machines, so we try to avoid this.  */
end_comment

begin_function
specifier|static
name|void
name|colorize_one_web
parameter_list|(
name|web
parameter_list|,
name|hard
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|int
name|hard
decl_stmt|;
block|{
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|HARD_REG_SET
name|colors
decl_stmt|,
name|dont_begin
decl_stmt|;
name|int
name|c
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bestc
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|neighbor_needs
init|=
literal|0
decl_stmt|;
name|struct
name|web
modifier|*
name|fat_neighbor
init|=
name|NULL
decl_stmt|;
name|struct
name|web
modifier|*
name|fats_parent
init|=
name|NULL
decl_stmt|;
name|int
name|num_fat
init|=
literal|0
decl_stmt|;
name|int
name|long_blocks
init|=
literal|0
decl_stmt|;
name|int
name|best_long_blocks
init|=
operator|-
literal|1
decl_stmt|;
name|HARD_REG_SET
name|fat_colors
decl_stmt|;
name|HARD_REG_SET
name|bias
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|regno
operator|>=
name|max_normal_pseudo
condition|)
name|hard
operator|=
literal|0
expr_stmt|;
comment|/* First we want to know the colors at which we can't begin.  */
name|calculate_dont_begin
argument_list|(
name|web
argument_list|,
operator|&
name|dont_begin
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|bias
argument_list|)
expr_stmt|;
comment|/* Now setup the set of colors used by our neighbors neighbors,      and search the biggest noncolored neighbor.  */
name|neighbor_needs
operator|=
name|web
operator|->
name|add_hardregs
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|w
decl_stmt|;
name|struct
name|web
modifier|*
name|ptarget
init|=
name|alias
argument_list|(
name|wl
operator|->
name|t
argument_list|)
decl_stmt|;
name|struct
name|sub_conflict
modifier|*
name|sl
init|=
name|wl
operator|->
name|sub
decl_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|bias
argument_list|,
name|ptarget
operator|->
name|bias_colors
argument_list|)
expr_stmt|;
name|w
operator|=
name|sl
condition|?
name|sl
operator|->
name|t
else|:
name|wl
operator|->
name|t
expr_stmt|;
if|if
condition|(
name|ptarget
operator|->
name|type
operator|!=
name|COLORED
operator|&&
name|ptarget
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
operator|!
name|ptarget
operator|->
name|was_spilled
condition|)
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|find_web_for_subweb
argument_list|(
name|w
argument_list|)
operator|->
name|type
operator|!=
name|COALESCED
operator|&&
name|w
operator|->
name|add_hardregs
operator|>=
name|neighbor_needs
condition|)
block|{
name|neighbor_needs
operator|=
name|w
operator|->
name|add_hardregs
expr_stmt|;
name|fat_neighbor
operator|=
name|w
expr_stmt|;
name|fats_parent
operator|=
name|ptarget
expr_stmt|;
name|num_fat
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sl
condition|)
break|break;
name|sl
operator|=
name|sl
operator|->
name|next
expr_stmt|;
name|w
operator|=
name|sl
condition|?
name|sl
operator|->
name|t
else|:
name|NULL
expr_stmt|;
block|}
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"colorize web %d [don't begin at %s]"
argument_list|,
name|web
operator|->
name|id
argument_list|,
name|hardregset_to_string
argument_list|(
name|dont_begin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there are some fat neighbors, remember their usable regs,      and how many blocks are free in it for that neighbor.  */
if|if
condition|(
name|num_fat
condition|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|fat_colors
argument_list|,
name|fats_parent
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
name|long_blocks
operator|=
name|count_long_blocks
argument_list|(
name|fat_colors
argument_list|,
name|neighbor_needs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We break out, if we found a color which doesn't constrain      neighbors, or if we can't find any colors.  */
while|while
condition|(
literal|1
condition|)
block|{
name|HARD_REG_SET
name|call_clobbered
decl_stmt|;
comment|/* Here we choose a hard-reg for the current web.  For non spill          temporaries we first search in the hardregs for it's prefered 	 class, then, if we found nothing appropriate, in those of the 	 alternate class.  For spill temporaries we only search in 	 usable_regs of this web (which is probably larger than that of 	 the preferred or alternate class).  All searches first try to 	 find a non-call-clobbered hard-reg.          XXX this should be more finegraned... First look into preferred          non-callclobbered hardregs, then _if_ the web crosses calls, in          alternate non-cc hardregs, and only _then_ also in preferred cc          hardregs (and alternate ones).  Currently we don't track the number          of calls crossed for webs.  We should.  */
if|if
condition|(
name|web
operator|->
name|use_my_regs
condition|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|colors
argument_list|,
name|web
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|colors
argument_list|,
name|usable_regs
index|[
name|reg_preferred_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|COPY_HARD_REG_SET
argument_list|(
name|colors
argument_list|,
name|usable_regs
index|[
name|reg_preferred_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_MODE
if|if
condition|(
name|web
operator|->
name|mode_changed
condition|)
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|colors
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_MODE
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|COPY_HARD_REG_SET
argument_list|(
name|call_clobbered
argument_list|,
name|colors
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|call_clobbered
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
comment|/* If this web got a color in the last pass, try to give it the 	 same color again.  This will to much better colorization 	 down the line, as we spilled for a certain coloring last time.  */
if|if
condition|(
name|web
operator|->
name|old_color
condition|)
block|{
name|c
operator|=
name|web
operator|->
name|old_color
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|color_usable_p
argument_list|(
name|c
argument_list|,
name|dont_begin
argument_list|,
name|colors
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
condition|)
name|c
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|c
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|c
operator|=
name|get_biased_reg
argument_list|(
name|dont_begin
argument_list|,
name|bias
argument_list|,
name|web
operator|->
name|prefer_colors
argument_list|,
name|call_clobbered
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|c
operator|=
name|get_biased_reg
argument_list|(
name|dont_begin
argument_list|,
name|bias
argument_list|,
name|web
operator|->
name|prefer_colors
argument_list|,
name|colors
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|web
operator|->
name|use_my_regs
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|colors
argument_list|,
name|web
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
else|else
name|IOR_HARD_REG_SET
argument_list|(
name|colors
argument_list|,
name|usable_regs
index|[
name|reg_alternate_class
argument_list|(
name|web
operator|->
name|regno
argument_list|)
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_MODE
if|if
condition|(
name|web
operator|->
name|mode_changed
condition|)
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|colors
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_MODE
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|COPY_HARD_REG_SET
argument_list|(
name|call_clobbered
argument_list|,
name|colors
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|call_clobbered
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_biased_reg
argument_list|(
name|dont_begin
argument_list|,
name|bias
argument_list|,
name|web
operator|->
name|prefer_colors
argument_list|,
name|call_clobbered
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|c
operator|=
name|get_biased_reg
argument_list|(
name|dont_begin
argument_list|,
name|bias
argument_list|,
name|web
operator|->
name|prefer_colors
argument_list|,
name|colors
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|web
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|bestc
operator|<
literal|0
condition|)
name|bestc
operator|=
name|c
expr_stmt|;
comment|/* If one of the yet uncolored neighbors, which is not a potential 	 spill needs a block of hardregs be sure, not to destroy such a block 	 by coloring one reg in the middle.  */
if|if
condition|(
name|num_fat
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|new_long
decl_stmt|;
name|HARD_REG_SET
name|colors1
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|colors1
argument_list|,
name|fat_colors
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
operator|+
name|web
operator|->
name|add_hardregs
condition|;
name|i
operator|++
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|colors1
argument_list|,
name|c
operator|+
name|i
argument_list|)
expr_stmt|;
name|new_long
operator|=
name|count_long_blocks
argument_list|(
name|colors1
argument_list|,
name|neighbor_needs
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If we changed the number of long blocks, and it's now smaller 	     than needed, we try to avoid this color.  */
if|if
condition|(
name|long_blocks
operator|!=
name|new_long
operator|&&
name|new_long
operator|<
name|num_fat
condition|)
block|{
if|if
condition|(
name|new_long
operator|>
name|best_long_blocks
condition|)
block|{
name|best_long_blocks
operator|=
name|new_long
expr_stmt|;
name|bestc
operator|=
name|c
expr_stmt|;
block|}
name|SET_HARD_REG_BIT
argument_list|(
name|dont_begin
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|" avoid %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We found a color which doesn't destroy a block.  */
break|break;
block|}
comment|/* If we havee no fat neighbors, the current color won't become 	 "better", so we've found it.  */
else|else
break|break;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|" --> got %d"
argument_list|,
name|c
operator|<
literal|0
condition|?
name|bestc
else|:
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|bestc
operator|>=
literal|0
operator|&&
name|c
operator|<
literal|0
operator|&&
operator|!
name|web
operator|->
name|was_spilled
condition|)
block|{
comment|/* This is a non-potential-spill web, which got a color, which did 	 destroy a hardreg block for one of it's neighbors.  We color 	 this web anyway and hope for the best for the neighbor, if we are 	 a spill temp.  */
if|if
condition|(
literal|1
operator|||
name|web
operator|->
name|spill_temp
condition|)
name|c
operator|=
name|bestc
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|" [constrains neighbors]"
argument_list|)
expr_stmt|;
block|}
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|/* Guard against a simplified node being spilled.  */
comment|/* Don't abort.  This can happen, when e.g. enough registers 	 are available in colors, but they are not consecutive.  This is a 	 very serious issue if this web is a short live one, because 	 even if we spill this one here, the situation won't become better 	 in the next iteration.  It probably will have the same conflicts, 	 those will have the same colors, and we would come here again, for 	 all parts, in which this one gets splitted by the spill.  This 	 can result in endless iteration spilling the same register again and 	 again.  That's why we try to find a neighbor, which spans more 	 instructions that ourself, and got a color, and try to spill _that_.  	 if (DLIST_WEB (d)->was_spilled< 0) 	 abort (); */
if|if
condition|(
name|hard
operator|&&
operator|(
operator|!
name|web
operator|->
name|was_spilled
operator|||
name|web
operator|->
name|spill_temp
operator|)
condition|)
block|{
name|unsigned
name|int
name|loop
decl_stmt|;
name|struct
name|web
modifier|*
name|try
init|=
name|NULL
decl_stmt|;
name|struct
name|web
modifier|*
name|candidates
index|[
literal|8
index|]
decl_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"  *** %d spilled, although %s ***\n"
argument_list|,
name|web
operator|->
name|id
argument_list|,
name|web
operator|->
name|spill_temp
condition|?
literal|"spilltemp"
else|:
literal|"non-spill"
argument_list|)
expr_stmt|;
comment|/* We make multiple passes over our conflicts, first trying to 	     spill those webs, which only got a color by chance, but 	     were potential spill ones, and if that isn't enough, in a second 	     pass also to spill normal colored webs.  If we still didn't find 	     a candidate, but we are a spill-temp, we make a third pass 	     and include also webs, which were targets for coalescing, and 	     spill those.  */
name|memset
argument_list|(
name|candidates
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|candidates
argument_list|)
expr_stmt|;
define|#
directive|define
name|set_cand
parameter_list|(
name|i
parameter_list|,
name|w
parameter_list|)
define|\
value|do { \ 	      if (!candidates[(i)] \ 		  || (candidates[(i)]->spill_cost< (w)->spill_cost)) \ 		candidates[(i)] = (w); \ 	  } while (0)
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|w
init|=
name|wl
operator|->
name|t
decl_stmt|;
name|struct
name|web
modifier|*
name|aw
init|=
name|alias
argument_list|(
name|w
argument_list|)
decl_stmt|;
comment|/* If we are a spill-temp, we also look at webs coalesced 		 to precolored ones.  Otherwise we only look at webs which 		 themself were colored, or coalesced to one.  */
if|if
condition|(
name|aw
operator|->
name|type
operator|==
name|PRECOLORED
operator|&&
name|w
operator|!=
name|aw
operator|&&
name|web
operator|->
name|spill_temp
operator|&&
name|flag_ra_optimistic_coalescing
condition|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|spill_temp
condition|)
name|set_cand
argument_list|(
literal|4
argument_list|,
name|w
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|web
operator|->
name|spill_temp
operator|==
literal|2
operator|&&
name|w
operator|->
name|spill_temp
operator|==
literal|2
operator|&&
name|w
operator|->
name|spill_cost
operator|<
name|web
operator|->
name|spill_cost
condition|)
name|set_cand
argument_list|(
literal|5
argument_list|,
name|w
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|web
operator|->
name|spill_temp
operator|!=
literal|2
operator|&&
operator|(
name|w
operator|->
name|spill_temp
operator|==
literal|2
operator|||
name|w
operator|->
name|spill_cost
operator|<
name|web
operator|->
name|spill_cost
operator|)
condition|)
name|set_cand
argument_list|(
literal|6
argument_list|,
name|w
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|aw
operator|->
name|type
operator|!=
name|COLORED
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|COLORED
operator|&&
operator|!
name|w
operator|->
name|spill_temp
operator|&&
operator|!
name|w
operator|->
name|is_coalesced
operator|&&
name|w
operator|->
name|was_spilled
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|spill_cost
operator|<
name|web
operator|->
name|spill_cost
condition|)
name|set_cand
argument_list|(
literal|0
argument_list|,
name|w
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|web
operator|->
name|spill_temp
condition|)
name|set_cand
argument_list|(
literal|1
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|COLORED
operator|&&
operator|!
name|w
operator|->
name|spill_temp
operator|&&
operator|!
name|w
operator|->
name|is_coalesced
operator|&&
operator|!
name|w
operator|->
name|was_spilled
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|spill_cost
operator|<
name|web
operator|->
name|spill_cost
condition|)
name|set_cand
argument_list|(
literal|2
argument_list|,
name|w
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|web
operator|->
name|spill_temp
operator|&&
name|web
operator|->
name|spill_temp
operator|!=
literal|2
condition|)
name|set_cand
argument_list|(
literal|3
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|web
operator|->
name|spill_temp
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|COLORED
operator|&&
name|w
operator|->
name|spill_temp
operator|==
literal|2
operator|&&
operator|!
name|w
operator|->
name|is_coalesced
operator|&&
operator|(
name|w
operator|->
name|spill_cost
operator|<
name|web
operator|->
name|spill_cost
operator|||
name|web
operator|->
name|spill_temp
operator|!=
literal|2
operator|)
condition|)
name|set_cand
argument_list|(
literal|4
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aw
operator|->
name|spill_temp
condition|)
name|set_cand
argument_list|(
literal|5
argument_list|,
name|aw
argument_list|)
expr_stmt|;
if|if
condition|(
name|aw
operator|->
name|spill_temp
operator|==
literal|2
operator|&&
operator|(
name|aw
operator|->
name|spill_cost
operator|<
name|web
operator|->
name|spill_cost
operator|||
name|web
operator|->
name|spill_temp
operator|!=
literal|2
operator|)
condition|)
name|set_cand
argument_list|(
literal|6
argument_list|,
name|aw
argument_list|)
expr_stmt|;
comment|/* For boehm-gc/misc.c.  If we are a difficult spilltemp, 		     also coalesced neighbors are a chance, _even_ if they 		     too are spilltemps.  At least their coalscing can be 		     broken up, which may be reset usable_regs, and makes 		     it easier colorable.  */
if|if
condition|(
name|web
operator|->
name|spill_temp
operator|!=
literal|2
operator|&&
name|aw
operator|->
name|is_coalesced
operator|&&
name|flag_ra_optimistic_coalescing
condition|)
name|set_cand
argument_list|(
literal|7
argument_list|,
name|aw
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|try
operator|==
name|NULL
operator|&&
name|loop
operator|<
literal|8
condition|;
name|loop
operator|++
control|)
if|if
condition|(
name|candidates
index|[
name|loop
index|]
condition|)
name|try
operator|=
name|candidates
index|[
name|loop
index|]
expr_stmt|;
undef|#
directive|undef
name|set_cand
if|if
condition|(
name|try
condition|)
block|{
name|int
name|old_c
init|=
name|try
operator|->
name|color
decl_stmt|;
if|if
condition|(
name|try
operator|->
name|type
operator|==
name|COALESCED
condition|)
block|{
if|if
condition|(
name|alias
argument_list|(
name|try
argument_list|)
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"  breaking alias %d -> %d\n"
argument_list|,
name|try
operator|->
name|id
argument_list|,
name|alias
argument_list|(
name|try
argument_list|)
operator|->
name|id
argument_list|)
expr_stmt|;
name|break_precolored_alias
argument_list|(
name|try
argument_list|)
expr_stmt|;
name|colorize_one_web
argument_list|(
name|web
argument_list|,
name|hard
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|remove_list
argument_list|(
name|try
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|COLORED
argument_list|)
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|try
argument_list|,
name|SPILLED
argument_list|)
expr_stmt|;
comment|/* Now try to colorize us again.  Can recursively make other 		     webs also spill, until there are no more unspilled 		     neighbors.  */
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"  trying to spill %d\n"
argument_list|,
name|try
operator|->
name|id
argument_list|)
expr_stmt|;
name|colorize_one_web
argument_list|(
name|web
argument_list|,
name|hard
argument_list|)
expr_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|COLORED
condition|)
block|{
comment|/* We tried recursively to spill all already colored 			 neighbors, but we are still uncolorable.  So it made 			 no sense to spill those neighbors.  Recolor them.  */
name|remove_list
argument_list|(
name|try
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|try
argument_list|,
name|COLORED
argument_list|)
expr_stmt|;
name|try
operator|->
name|color
operator|=
name|old_c
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"  spilling %d was useless\n"
argument_list|,
name|try
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"  to spill %d was a good idea\n"
argument_list|,
name|try
operator|->
name|id
argument_list|)
expr_stmt|;
name|remove_list
argument_list|(
name|try
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|try
operator|->
name|was_spilled
condition|)
name|colorize_one_web
argument_list|(
name|try
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|colorize_one_web
argument_list|(
name|try
argument_list|,
name|hard
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* No more chances to get a color, so give up hope and 	       spill us.  */
name|put_web
argument_list|(
name|web
argument_list|,
name|SPILLED
argument_list|)
expr_stmt|;
block|}
else|else
name|put_web
argument_list|(
name|web
argument_list|,
name|SPILLED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_web
argument_list|(
name|web
argument_list|,
name|COLORED
argument_list|)
expr_stmt|;
name|web
operator|->
name|color
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|flag_ra_biased
condition|)
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|c
argument_list|,
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|ptarget
init|=
name|alias
argument_list|(
name|wl
operator|->
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|ptarget
operator|->
name|bias_colors
argument_list|,
name|c
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|web
operator|->
name|regno
operator|>=
name|max_normal_pseudo
operator|&&
name|web
operator|->
name|type
operator|==
name|SPILLED
condition|)
block|{
name|web
operator|->
name|color
operator|=
name|an_unusable_color
expr_stmt|;
name|remove_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|COLORED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|SPILLED
operator|&&
name|flag_ra_optimistic_coalescing
operator|&&
name|web
operator|->
name|is_coalesced
condition|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"breaking aliases to web %d:"
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
name|restore_conflicts_from_coalesce
argument_list|(
name|web
argument_list|)
expr_stmt|;
name|break_aliases_to_web
argument_list|(
name|web
argument_list|)
expr_stmt|;
name|insert_coalesced_conflicts
argument_list|()
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|remove_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|SELECT
argument_list|)
expr_stmt|;
name|web
operator|->
name|color
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assign the colors to all nodes on the select stack.  And update the    colors of coalesced webs.  */
end_comment

begin_function
specifier|static
name|void
name|assign_colors
parameter_list|()
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
while|while
condition|(
name|WEBS
argument_list|(
name|SELECT
argument_list|)
condition|)
block|{
name|struct
name|web
modifier|*
name|web
decl_stmt|;
name|d
operator|=
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|SELECT
argument_list|)
argument_list|)
expr_stmt|;
name|web
operator|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|colorize_one_web
argument_list|(
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|COALESCED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|a
init|=
name|alias
argument_list|(
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
argument_list|)
decl_stmt|;
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
operator|->
name|color
operator|=
name|a
operator|->
name|color
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* WEB is a spilled web.  Look if we can improve the cost of the graph,    by coloring WEB, even if we then need to spill some of it's neighbors.    For this we calculate the cost for each color C, that results when we    _would_ give WEB color C (i.e. the cost of the then spilled neighbors).    If the lowest cost among them is smaller than the spillcost of WEB, we    do that recoloring, and instead spill the neighbors.     This can sometime help, when due to irregularities in register file,    and due to multi word pseudos, the colorization is suboptimal.  But    be aware, that currently this pass is quite slow.  */
end_comment

begin_function
specifier|static
name|void
name|try_recolor_web
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|cost_neighbors
decl_stmt|;
name|unsigned
name|int
modifier|*
name|min_color
decl_stmt|;
name|int
name|newcol
decl_stmt|,
name|c
decl_stmt|;
name|HARD_REG_SET
name|precolored_neighbors
decl_stmt|,
name|spill_temps
decl_stmt|;
name|HARD_REG_SET
name|possible_begin
decl_stmt|,
name|wide_seen
decl_stmt|;
name|cost_neighbors
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
name|xcalloc
argument_list|(
name|FIRST_PSEUDO_REGISTER
argument_list|,
sizeof|sizeof
argument_list|(
name|cost_neighbors
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each hard-regs count the number of preceding hardregs, which      would overlap this color, if used in WEB's mode.  */
name|min_color
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|FIRST_PSEUDO_REGISTER
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|possible_begin
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|c
operator|++
control|)
block|{
name|int
name|i
decl_stmt|,
name|nregs
decl_stmt|;
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|c
argument_list|,
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
condition|)
continue|continue;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|c
argument_list|,
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|c
operator|+
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|nregs
operator|||
name|nregs
operator|==
literal|0
condition|)
continue|continue;
name|SET_HARD_REG_BIT
argument_list|(
name|possible_begin
argument_list|,
name|c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nregs
operator|--
condition|;
control|)
if|if
condition|(
operator|!
name|min_color
index|[
name|c
operator|+
name|nregs
index|]
condition|)
name|min_color
index|[
name|c
operator|+
name|nregs
index|]
operator|=
literal|1
operator|+
name|c
expr_stmt|;
block|}
name|CLEAR_HARD_REG_SET
argument_list|(
name|precolored_neighbors
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|spill_temps
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|wide_seen
argument_list|)
expr_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|HARD_REG_SET
name|dont_begin
decl_stmt|;
name|struct
name|web
modifier|*
name|web2
init|=
name|alias
argument_list|(
name|wl
operator|->
name|t
argument_list|)
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|nn
decl_stmt|;
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|wide_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|wl
operator|->
name|t
operator|->
name|type
operator|==
name|COALESCED
operator|||
name|web2
operator|->
name|type
operator|!=
name|COLORED
condition|)
block|{
if|if
condition|(
name|web2
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
block|{
name|c1
operator|=
name|min_color
index|[
name|web2
operator|->
name|color
index|]
expr_stmt|;
name|c1
operator|=
operator|(
name|c1
operator|==
literal|0
operator|)
condition|?
name|web2
operator|->
name|color
else|:
operator|(
name|c1
operator|-
literal|1
operator|)
expr_stmt|;
name|c2
operator|=
name|web2
operator|->
name|color
expr_stmt|;
for|for
control|(
init|;
name|c1
operator|<=
name|c2
condition|;
name|c1
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|precolored_neighbors
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Mark colors for which some wide webs are involved.  For 	 those the independent sets are not simply one-node graphs, so 	 they can't be recolored independ from their neighborhood.  This 	 means, that our cost calculation can be incorrect (assuming it 	 can avoid spilling a web because it thinks some colors are available, 	 although it's neighbors which itself need recoloring might take 	 away exactly those colors).  */
if|if
condition|(
name|web2
operator|->
name|add_hardregs
condition|)
name|wide_p
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|nn
operator|=
name|web2
operator|->
name|conflict_list
init|;
name|nn
operator|&&
operator|!
name|wide_p
condition|;
name|nn
operator|=
name|nn
operator|->
name|next
control|)
if|if
condition|(
name|alias
argument_list|(
name|nn
operator|->
name|t
argument_list|)
operator|->
name|add_hardregs
condition|)
name|wide_p
operator|=
literal|1
expr_stmt|;
name|calculate_dont_begin
argument_list|(
name|web2
argument_list|,
operator|&
name|dont_begin
argument_list|)
expr_stmt|;
name|c1
operator|=
name|min_color
index|[
name|web2
operator|->
name|color
index|]
expr_stmt|;
comment|/* Note that min_color[] contains 1-based values (zero means 	 undef).  */
name|c1
operator|=
name|c1
operator|==
literal|0
condition|?
name|web2
operator|->
name|color
else|:
operator|(
name|c1
operator|-
literal|1
operator|)
expr_stmt|;
name|c2
operator|=
name|web2
operator|->
name|color
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|web2
operator|->
name|color
argument_list|,
name|GET_MODE
argument_list|(
name|web2
operator|->
name|orig_x
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|c1
operator|<=
name|c2
condition|;
name|c1
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|possible_begin
argument_list|,
name|c1
argument_list|)
condition|)
block|{
name|int
name|nregs
decl_stmt|;
name|HARD_REG_SET
name|colors
decl_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|c1
argument_list|,
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|colors
argument_list|,
name|web2
operator|->
name|usable_regs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nregs
operator|--
condition|;
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|colors
argument_list|,
name|c1
operator|+
name|nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide_p
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|wide_seen
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_free_reg
argument_list|(
name|dont_begin
argument_list|,
name|colors
argument_list|,
name|GET_MODE
argument_list|(
name|web2
operator|->
name|orig_x
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|web2
operator|->
name|spill_temp
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|spill_temps
argument_list|,
name|c1
argument_list|)
expr_stmt|;
else|else
name|cost_neighbors
index|[
name|c1
index|]
operator|+=
name|web2
operator|->
name|spill_cost
expr_stmt|;
block|}
block|}
block|}
name|newcol
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|possible_begin
argument_list|,
name|c
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|precolored_neighbors
argument_list|,
name|c
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|spill_temps
argument_list|,
name|c
argument_list|)
operator|&&
operator|(
name|newcol
operator|==
operator|-
literal|1
operator|||
name|cost_neighbors
index|[
name|c
index|]
operator|<
name|cost_neighbors
index|[
name|newcol
index|]
operator|)
condition|)
name|newcol
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|newcol
operator|>=
literal|0
operator|&&
name|cost_neighbors
index|[
name|newcol
index|]
operator|<
name|web
operator|->
name|spill_cost
condition|)
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|newcol
argument_list|,
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|cost
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|old_colors
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl_next
decl_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"try to set web %d to color %d\n"
argument_list|,
name|web
operator|->
name|id
argument_list|,
name|newcol
argument_list|)
expr_stmt|;
name|remove_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|COLORED
argument_list|)
expr_stmt|;
name|web
operator|->
name|color
operator|=
name|newcol
expr_stmt|;
name|old_colors
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|num_webs
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl_next
control|)
block|{
name|struct
name|web
modifier|*
name|web2
init|=
name|alias
argument_list|(
name|wl
operator|->
name|t
argument_list|)
decl_stmt|;
comment|/* If web2 is a coalesce-target, and will become spilled 	     below in colorize_one_web(), and the current conflict wl 	     between web and web2 was only the result of that coalescing 	     this conflict will be deleted, making wl invalid.  So save 	     the next conflict right now.  Note that if web2 has indeed 	     such state, then wl->next can not be deleted in this 	     iteration.  */
name|wl_next
operator|=
name|wl
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|web2
operator|->
name|type
operator|==
name|COLORED
condition|)
block|{
name|int
name|nregs2
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|web2
operator|->
name|color
argument_list|,
name|GET_MODE
argument_list|(
name|web2
operator|->
name|orig_x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|color
operator|>=
name|web2
operator|->
name|color
operator|+
name|nregs2
operator|||
name|web2
operator|->
name|color
operator|>=
name|web
operator|->
name|color
operator|+
name|nregs
condition|)
continue|continue;
name|old_colors
index|[
name|web2
operator|->
name|id
index|]
operator|=
name|web2
operator|->
name|color
operator|+
literal|1
expr_stmt|;
name|web2
operator|->
name|color
operator|=
operator|-
literal|1
expr_stmt|;
name|remove_list
argument_list|(
name|web2
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|COLORED
argument_list|)
argument_list|)
expr_stmt|;
name|web2
operator|->
name|type
operator|=
name|SELECT
expr_stmt|;
comment|/* Allow webs to be spilled.  */
if|if
condition|(
name|web2
operator|->
name|spill_temp
operator|==
literal|0
operator|||
name|web2
operator|->
name|spill_temp
operator|==
literal|2
condition|)
name|web2
operator|->
name|was_spilled
operator|=
literal|1
expr_stmt|;
name|colorize_one_web
argument_list|(
name|web2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|web2
operator|->
name|type
operator|==
name|SPILLED
condition|)
name|cost
operator|+=
name|web2
operator|->
name|spill_cost
expr_stmt|;
block|}
block|}
comment|/* The actual cost may be smaller than the guessed one, because 	 partial conflicts could result in some conflicting webs getting 	 a color, where we assumed it must be spilled.  See the comment          above what happens, when wide webs are involved, and why in that          case there might actually be some webs spilled although thought to          be colorable.  */
if|if
condition|(
name|cost
operator|>
name|cost_neighbors
index|[
name|newcol
index|]
operator|&&
name|nregs
operator|==
literal|1
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|wide_seen
argument_list|,
name|newcol
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* But if the new spill-cost is higher than our own, then really loose. 	 Respill us and recolor neighbors as before.  */
if|if
condition|(
name|cost
operator|>
name|web
operator|->
name|spill_cost
condition|)
block|{
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"reset coloring of web %d, too expensive\n"
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
name|remove_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|COLORED
argument_list|)
argument_list|)
expr_stmt|;
name|web
operator|->
name|color
operator|=
operator|-
literal|1
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|SPILLED
argument_list|)
expr_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web2
init|=
name|alias
argument_list|(
name|wl
operator|->
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_colors
index|[
name|web2
operator|->
name|id
index|]
condition|)
block|{
if|if
condition|(
name|web2
operator|->
name|type
operator|==
name|SPILLED
condition|)
block|{
name|remove_list
argument_list|(
name|web2
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
argument_list|)
expr_stmt|;
name|web2
operator|->
name|color
operator|=
name|old_colors
index|[
name|web2
operator|->
name|id
index|]
operator|-
literal|1
expr_stmt|;
name|put_web
argument_list|(
name|web2
argument_list|,
name|COLORED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|web2
operator|->
name|type
operator|==
name|COLORED
condition|)
name|web2
operator|->
name|color
operator|=
name|old_colors
index|[
name|web2
operator|->
name|id
index|]
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|web2
operator|->
name|type
operator|==
name|SELECT
condition|)
comment|/* This means, that WEB2 once was a part of a coalesced 		       web, which got spilled in the above colorize_one_web() 		       call, and whose parts then got splitted and put back 		       onto the SELECT stack.  As the cause for that splitting 		       (the coloring of WEB) was worthless, we should again 		       coalesce the parts, as they were before.  For now we 		       simply leave them SELECTed, for our caller to take 		       care.  */
empty_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|old_colors
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|min_color
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cost_neighbors
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This ensures that all conflicts of coalesced webs are seen from    the webs coalesced into.  combine() only adds the conflicts which    at the time of combining were not already SELECTed or COALESCED    to not destroy num_conflicts.  Here we add all remaining conflicts    and thereby destroy num_conflicts.  This should be used when num_conflicts    isn't used anymore, e.g. on a completely colored graph.  */
end_comment

begin_function
specifier|static
name|void
name|insert_coalesced_conflicts
parameter_list|()
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|COALESCED
argument_list|)
init|;
literal|0
operator|&&
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|aweb
init|=
name|alias
argument_list|(
name|web
argument_list|)
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|tweb
init|=
name|aweb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nregs
init|=
literal|1
operator|+
name|web
operator|->
name|add_hardregs
decl_stmt|;
if|if
condition|(
name|aweb
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|aweb
operator|->
name|color
argument_list|,
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aweb
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|tweb
operator|=
name|hardreg2web
index|[
name|i
operator|+
name|aweb
operator|->
name|color
index|]
expr_stmt|;
comment|/* There might be some conflict edges laying around 		 where the usable_regs don't intersect.  This can happen 		 when first some webs were coalesced and conflicts 		 propagated, then some combining narrowed usable_regs and 		 further coalescing ignored those conflicts.  Now there are 		 some edges to COALESCED webs but not to it's alias. 		 So abort only when they really should conflict.  */
if|if
condition|(
operator|(
operator|!
operator|(
name|tweb
operator|->
name|type
operator|==
name|PRECOLORED
operator|||
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|tweb
operator|->
name|id
operator|*
name|num_webs
operator|+
name|wl
operator|->
name|t
operator|->
name|id
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|wl
operator|->
name|t
operator|->
name|type
operator|==
name|PRECOLORED
operator|||
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|wl
operator|->
name|t
operator|->
name|id
operator|*
name|num_webs
operator|+
name|tweb
operator|->
name|id
argument_list|)
operator|)
operator|)
operator|&&
name|hard_regs_intersect_p
argument_list|(
operator|&
name|tweb
operator|->
name|usable_regs
argument_list|,
operator|&
name|wl
operator|->
name|t
operator|->
name|usable_regs
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/*if (wl->sub == NULL) 		record_conflict (tweb, wl->t); 	      else 		{ 		  struct sub_conflict *sl; 		  for (sl = wl->sub; sl; sl = sl->next) 		    record_conflict (tweb, sl->t); 		}*/
if|if
condition|(
name|aweb
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* A function suitable to pass to qsort().  Compare the spill costs    of webs W1 and W2.  When used by qsort, this would order webs with    largest cost first.  */
end_comment

begin_function
specifier|static
name|int
name|comp_webs_maxcost
parameter_list|(
name|w1
parameter_list|,
name|w2
parameter_list|)
specifier|const
name|void
modifier|*
name|w1
decl_stmt|,
decl|*
name|w2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|web
modifier|*
name|web1
init|=
operator|*
operator|(
expr|struct
name|web
operator|*
operator|*
operator|)
name|w1
decl_stmt|;
name|struct
name|web
modifier|*
name|web2
init|=
operator|*
operator|(
expr|struct
name|web
operator|*
operator|*
operator|)
name|w2
decl_stmt|;
if|if
condition|(
name|web1
operator|->
name|spill_cost
operator|>
name|web2
operator|->
name|spill_cost
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|web1
operator|->
name|spill_cost
operator|<
name|web2
operator|->
name|spill_cost
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* This tries to recolor all spilled webs.  See try_recolor_web()    how this is done.  This just calls it for each spilled web.  */
end_comment

begin_function
specifier|static
name|void
name|recolor_spills
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|num
decl_stmt|;
name|struct
name|web
modifier|*
modifier|*
name|order2web
decl_stmt|;
name|num
operator|=
name|num_webs
operator|-
name|num_subwebs
expr_stmt|;
name|order2web
operator|=
operator|(
expr|struct
name|web
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|order2web
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|order2web
index|[
name|i
index|]
operator|=
name|id2web
index|[
name|i
index|]
expr_stmt|;
comment|/* If we aren't breaking aliases, combine() wasn't merging the          spill_costs.  So do that here to have sane measures.  */
if|if
condition|(
operator|!
name|flag_ra_merge_spill_costs
operator|&&
name|id2web
index|[
name|i
index|]
operator|->
name|type
operator|==
name|COALESCED
condition|)
name|alias
argument_list|(
name|id2web
index|[
name|i
index|]
argument_list|)
operator|->
name|spill_cost
operator|+=
name|id2web
index|[
name|i
index|]
operator|->
name|spill_cost
expr_stmt|;
block|}
name|qsort
argument_list|(
name|order2web
argument_list|,
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|order2web
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|comp_webs_maxcost
argument_list|)
expr_stmt|;
name|insert_coalesced_conflicts
argument_list|()
expr_stmt|;
name|dump_graph_cost
argument_list|(
name|DUMP_COSTS
argument_list|,
literal|"before spill-recolor"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|order2web
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|==
name|SPILLED
condition|)
name|try_recolor_web
argument_list|(
name|web
argument_list|)
expr_stmt|;
block|}
comment|/* It might have been decided in try_recolor_web() (in colorize_one_web())      that a coalesced web should be spilled, so it was put on the      select stack.  Those webs need recoloring again, and all remaining      coalesced webs might need their color updated, so simply call      assign_colors() again.  */
name|assign_colors
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|order2web
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This checks the current color assignment for obvious errors,    like two conflicting webs overlapping in colors, or the used colors    not being in usable regs.  */
end_comment

begin_function
specifier|static
name|void
name|check_colors
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_webs
operator|-
name|num_subwebs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|id2web
index|[
name|i
index|]
decl_stmt|;
name|struct
name|web
modifier|*
name|aweb
init|=
name|alias
argument_list|(
name|web
argument_list|)
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|int
name|nregs
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|aweb
operator|->
name|type
operator|==
name|SPILLED
operator|||
name|web
operator|->
name|regno
operator|>=
name|max_normal_pseudo
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|aweb
operator|->
name|type
operator|==
name|COLORED
condition|)
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|aweb
operator|->
name|color
argument_list|,
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aweb
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|nregs
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* The color must be valid for the original usable_regs.  */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nregs
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|aweb
operator|->
name|color
operator|+
name|c
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Search the original (pre-coalesce) conflict list.  In the current 	 one some inprecise conflicts may be noted (due to combine() or 	 insert_coalesced_conflicts() relocating partial conflicts) making 	 it look like some wide webs are in conflict and having the same 	 color.  */
name|wl
operator|=
operator|(
name|web
operator|->
name|have_orig_conflicts
condition|?
name|web
operator|->
name|orig_conflict_list
else|:
name|web
operator|->
name|conflict_list
operator|)
expr_stmt|;
for|for
control|(
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
if|if
condition|(
name|wl
operator|->
name|t
operator|->
name|regno
operator|>=
name|max_normal_pseudo
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|wl
operator|->
name|sub
condition|)
block|{
name|struct
name|web
modifier|*
name|web2
init|=
name|alias
argument_list|(
name|wl
operator|->
name|t
argument_list|)
decl_stmt|;
name|int
name|nregs2
decl_stmt|;
if|if
condition|(
name|web2
operator|->
name|type
operator|==
name|COLORED
condition|)
name|nregs2
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|web2
operator|->
name|color
argument_list|,
name|GET_MODE
argument_list|(
name|web2
operator|->
name|orig_x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|web2
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|nregs2
operator|=
literal|1
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
name|aweb
operator|->
name|color
operator|>=
name|web2
operator|->
name|color
operator|+
name|nregs2
operator|||
name|web2
operator|->
name|color
operator|>=
name|aweb
operator|->
name|color
operator|+
name|nregs
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sub_conflict
modifier|*
name|sl
decl_stmt|;
name|int
name|scol
init|=
name|aweb
operator|->
name|color
decl_stmt|;
name|int
name|tcol
init|=
name|alias
argument_list|(
name|wl
operator|->
name|t
argument_list|)
operator|->
name|color
decl_stmt|;
if|if
condition|(
name|alias
argument_list|(
name|wl
operator|->
name|t
argument_list|)
operator|->
name|type
operator|==
name|SPILLED
condition|)
continue|continue;
for|for
control|(
name|sl
operator|=
name|wl
operator|->
name|sub
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
block|{
name|int
name|ssize
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|scol
argument_list|,
name|GET_MODE
argument_list|(
name|sl
operator|->
name|s
operator|->
name|orig_x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|tsize
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|tcol
argument_list|,
name|GET_MODE
argument_list|(
name|sl
operator|->
name|t
operator|->
name|orig_x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|sofs
init|=
literal|0
decl_stmt|,
name|tofs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SUBWEB_P
argument_list|(
name|sl
operator|->
name|t
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|sl
operator|->
name|t
operator|->
name|orig_x
argument_list|)
argument_list|)
operator|>=
name|UNITS_PER_WORD
condition|)
name|tofs
operator|=
operator|(
name|SUBREG_BYTE
argument_list|(
name|sl
operator|->
name|t
operator|->
name|orig_x
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
if|if
condition|(
name|SUBWEB_P
argument_list|(
name|sl
operator|->
name|s
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|sl
operator|->
name|s
operator|->
name|orig_x
argument_list|)
argument_list|)
operator|>=
name|UNITS_PER_WORD
condition|)
name|sofs
operator|=
operator|(
name|SUBREG_BYTE
argument_list|(
name|sl
operator|->
name|s
operator|->
name|orig_x
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tcol
operator|+
name|tofs
operator|>=
name|scol
operator|+
name|sofs
operator|+
name|ssize
operator|)
operator|||
operator|(
name|scol
operator|+
name|sofs
operator|>=
name|tcol
operator|+
name|tofs
operator|+
name|tsize
operator|)
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* WEB was a coalesced web.  Make it unaliased again, and put it    back onto SELECT stack.  */
end_comment

begin_function
specifier|static
name|void
name|unalias_web
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
name|web
operator|->
name|alias
operator|=
name|NULL
expr_stmt|;
name|web
operator|->
name|is_coalesced
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|color
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Well, initially everything was spilled, so it isn't incorrect,      that also the individual parts can be spilled.      XXX this isn't entirely correct, as we also relaxed the      spill_temp flag in combine(), which might have made components      spill, although they were a short or spilltemp web.  */
name|web
operator|->
name|was_spilled
operator|=
literal|1
expr_stmt|;
name|remove_list
argument_list|(
name|web
operator|->
name|dlink
argument_list|,
operator|&
name|WEBS
argument_list|(
name|COALESCED
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Spilltemps must be colored right now (i.e. as early as possible),      other webs can be deferred to the end (the code building the      stack assumed that in this stage only one web was colored).  */
if|if
condition|(
name|web
operator|->
name|spill_temp
operator|&&
name|web
operator|->
name|spill_temp
operator|!=
literal|2
condition|)
name|put_web
argument_list|(
name|web
argument_list|,
name|SELECT
argument_list|)
expr_stmt|;
else|else
name|put_web_at_end
argument_list|(
name|web
argument_list|,
name|SELECT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* WEB is a _target_ for coalescing which got spilled.    Break all aliases to WEB, and restore some of its member to the state    they were before coalescing.  Due to the suboptimal structure of    the interference graph we need to go through all coalesced webs.    Somewhen we'll change this to be more sane.  */
end_comment

begin_function
specifier|static
name|void
name|break_aliases_to_web
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|,
modifier|*
name|d_next
decl_stmt|;
if|if
condition|(
name|web
operator|->
name|type
operator|!=
name|SPILLED
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|COALESCED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d_next
control|)
block|{
name|struct
name|web
modifier|*
name|other
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|d_next
operator|=
name|d
operator|->
name|next
expr_stmt|;
comment|/* Beware: Don't use alias() here.  We really want to check only 	 one level of aliasing, i.e. only break up webs directly 	 aliased to WEB, not also those aliased through other webs.  */
if|if
condition|(
name|other
operator|->
name|alias
operator|==
name|web
condition|)
block|{
name|unalias_web
argument_list|(
name|other
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|" %d"
argument_list|,
name|other
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
name|web
operator|->
name|spill_temp
operator|=
name|web
operator|->
name|orig_spill_temp
expr_stmt|;
name|web
operator|->
name|spill_cost
operator|=
name|web
operator|->
name|orig_spill_cost
expr_stmt|;
comment|/* Beware: The following possibly widens usable_regs again.  While      it was narrower there might have been some conflicts added which got      ignored because of non-intersecting hardregsets.  All those conflicts      would now matter again.  Fortunately we only add conflicts when      coalescing, which is also the time of narrowing.  And we remove all      those added conflicts again now that we unalias this web.      Therefore this is safe to do.  */
name|COPY_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|web
operator|->
name|orig_usable_regs
argument_list|)
expr_stmt|;
name|web
operator|->
name|is_coalesced
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|num_aliased
operator|=
literal|0
expr_stmt|;
name|web
operator|->
name|was_spilled
operator|=
literal|1
expr_stmt|;
comment|/* Reset is_coalesced flag for webs which itself are target of coalescing.      It was cleared above if it was coalesced to WEB.  */
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|COALESCED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
operator|->
name|alias
operator|->
name|is_coalesced
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* WEB is a web coalesced into a precolored one.  Break that alias,    making WEB SELECTed again.  Also restores the conflicts which resulted    from initially coalescing both.  */
end_comment

begin_function
specifier|static
name|void
name|break_precolored_alias
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
name|struct
name|web
modifier|*
name|pre
init|=
name|web
operator|->
name|alias
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|unsigned
name|int
name|c
init|=
name|pre
operator|->
name|color
decl_stmt|;
name|unsigned
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|c
argument_list|,
name|GET_MODE
argument_list|(
name|web
operator|->
name|orig_x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pre
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
name|abort
argument_list|()
expr_stmt|;
name|unalias_web
argument_list|(
name|web
argument_list|)
expr_stmt|;
comment|/* Now we need to look at each conflict X of WEB, if it conflicts      with [PRE, PRE+nregs), and remove such conflicts, of X has not other      conflicts, which are coalesced into those precolored webs.  */
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|x
init|=
name|wl
operator|->
name|t
decl_stmt|;
name|struct
name|web
modifier|*
name|y
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl2
decl_stmt|;
name|struct
name|conflict_link
modifier|*
modifier|*
name|pcl
decl_stmt|;
name|HARD_REG_SET
name|regs
decl_stmt|;
if|if
condition|(
operator|!
name|x
operator|->
name|have_orig_conflicts
condition|)
continue|continue;
comment|/* First look at which colors can not go away, due to other coalesces 	 still existing.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs
argument_list|,
name|c
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|wl2
operator|=
name|x
operator|->
name|conflict_list
init|;
name|wl2
condition|;
name|wl2
operator|=
name|wl2
operator|->
name|next
control|)
if|if
condition|(
name|wl2
operator|->
name|t
operator|->
name|type
operator|==
name|COALESCED
operator|&&
name|alias
argument_list|(
name|wl2
operator|->
name|t
argument_list|)
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regs
argument_list|,
name|alias
argument_list|(
name|wl2
operator|->
name|t
argument_list|)
operator|->
name|color
argument_list|)
expr_stmt|;
comment|/* Now also remove the colors of those conflicts which already 	 were there before coalescing at all.  */
for|for
control|(
name|wl2
operator|=
name|x
operator|->
name|orig_conflict_list
init|;
name|wl2
condition|;
name|wl2
operator|=
name|wl2
operator|->
name|next
control|)
if|if
condition|(
name|wl2
operator|->
name|t
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regs
argument_list|,
name|wl2
operator|->
name|t
operator|->
name|color
argument_list|)
expr_stmt|;
comment|/* The colors now still set are those for which WEB was the last 	 cause, i.e. those which can be removed.  */
name|y
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs
argument_list|,
name|c
operator|+
name|i
argument_list|)
condition|)
block|{
name|struct
name|web
modifier|*
name|sub
decl_stmt|;
name|y
operator|=
name|hardreg2web
index|[
name|c
operator|+
name|i
index|]
expr_stmt|;
name|RESET_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|x
operator|->
name|id
operator|*
name|num_webs
operator|+
name|y
operator|->
name|id
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|y
operator|->
name|id
operator|*
name|num_webs
operator|+
name|x
operator|->
name|id
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|igraph
argument_list|,
name|igraph_index
argument_list|(
name|x
operator|->
name|id
argument_list|,
name|y
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|x
operator|->
name|subreg_next
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|subreg_next
control|)
name|RESET_BIT
argument_list|(
name|igraph
argument_list|,
name|igraph_index
argument_list|(
name|sub
operator|->
name|id
argument_list|,
name|y
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|y
condition|)
continue|continue;
name|pcl
operator|=
operator|&
operator|(
name|x
operator|->
name|conflict_list
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|pcl
condition|)
block|{
name|struct
name|web
modifier|*
name|y
init|=
operator|(
operator|*
name|pcl
operator|)
operator|->
name|t
decl_stmt|;
if|if
condition|(
name|y
operator|->
name|type
operator|!=
name|PRECOLORED
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|regs
argument_list|,
name|y
operator|->
name|color
argument_list|)
condition|)
name|pcl
operator|=
operator|&
operator|(
operator|(
operator|*
name|pcl
operator|)
operator|->
name|next
operator|)
expr_stmt|;
else|else
operator|*
name|pcl
operator|=
operator|(
operator|*
name|pcl
operator|)
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* WEB is a spilled web which was target for coalescing.    Delete all interference edges which were added due to that coalescing,    and break up the coalescing.  */
end_comment

begin_function
specifier|static
name|void
name|restore_conflicts_from_coalesce
parameter_list|(
name|web
parameter_list|)
name|struct
name|web
modifier|*
name|web
decl_stmt|;
block|{
name|struct
name|conflict_link
modifier|*
modifier|*
name|pcl
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|wl
decl_stmt|;
name|pcl
operator|=
operator|&
operator|(
name|web
operator|->
name|conflict_list
operator|)
expr_stmt|;
comment|/* No original conflict list means no conflict was added at all      after building the graph.  So neither we nor any neighbors have      conflicts due to this coalescing.  */
if|if
condition|(
operator|!
name|web
operator|->
name|have_orig_conflicts
condition|)
return|return;
while|while
condition|(
operator|*
name|pcl
condition|)
block|{
name|struct
name|web
modifier|*
name|other
init|=
operator|(
operator|*
name|pcl
operator|)
operator|->
name|t
decl_stmt|;
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|orig_conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
if|if
condition|(
name|wl
operator|->
name|t
operator|==
name|other
condition|)
break|break;
if|if
condition|(
name|wl
condition|)
block|{
comment|/* We found this conflict also in the original list, so this 	     was no new conflict.  */
name|pcl
operator|=
operator|&
operator|(
operator|(
operator|*
name|pcl
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a new conflict, so delete it from us and 	     the neighbor.  */
name|struct
name|conflict_link
modifier|*
modifier|*
name|opcl
decl_stmt|;
name|struct
name|conflict_link
modifier|*
name|owl
decl_stmt|;
name|struct
name|sub_conflict
modifier|*
name|sl
decl_stmt|;
name|wl
operator|=
operator|*
name|pcl
expr_stmt|;
operator|*
name|pcl
operator|=
name|wl
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|other
operator|->
name|have_orig_conflicts
operator|&&
name|other
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|owl
operator|=
name|other
operator|->
name|orig_conflict_list
init|;
name|owl
condition|;
name|owl
operator|=
name|owl
operator|->
name|next
control|)
if|if
condition|(
name|owl
operator|->
name|t
operator|==
name|web
condition|)
break|break;
if|if
condition|(
name|owl
condition|)
name|abort
argument_list|()
expr_stmt|;
name|opcl
operator|=
operator|&
operator|(
name|other
operator|->
name|conflict_list
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|opcl
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|opcl
operator|)
operator|->
name|t
operator|==
name|web
condition|)
block|{
name|owl
operator|=
operator|*
name|opcl
expr_stmt|;
operator|*
name|opcl
operator|=
name|owl
operator|->
name|next
expr_stmt|;
break|break;
block|}
else|else
block|{
name|opcl
operator|=
operator|&
operator|(
operator|(
operator|*
name|opcl
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|owl
operator|&&
name|other
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* wl and owl contain the edge data to be deleted.  */
name|RESET_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|web
operator|->
name|id
operator|*
name|num_webs
operator|+
name|other
operator|->
name|id
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|other
operator|->
name|id
operator|*
name|num_webs
operator|+
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|igraph
argument_list|,
name|igraph_index
argument_list|(
name|web
operator|->
name|id
argument_list|,
name|other
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|sl
operator|=
name|wl
operator|->
name|sub
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
name|RESET_BIT
argument_list|(
name|igraph
argument_list|,
name|igraph_index
argument_list|(
name|sl
operator|->
name|s
operator|->
name|id
argument_list|,
name|sl
operator|->
name|t
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|other
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
block|{
for|for
control|(
name|sl
operator|=
name|owl
operator|->
name|sub
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
name|RESET_BIT
argument_list|(
name|igraph
argument_list|,
name|igraph_index
argument_list|(
name|sl
operator|->
name|s
operator|->
name|id
argument_list|,
name|sl
operator|->
name|t
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* We must restore usable_regs because record_conflict will use it.  */
name|COPY_HARD_REG_SET
argument_list|(
name|web
operator|->
name|usable_regs
argument_list|,
name|web
operator|->
name|orig_usable_regs
argument_list|)
expr_stmt|;
comment|/* We might have deleted some conflicts above, which really are still      there (diamond pattern coalescing).  This is because we don't reference      count interference edges but some of them were the result of different      coalesces.  */
for|for
control|(
name|wl
operator|=
name|web
operator|->
name|conflict_list
init|;
name|wl
condition|;
name|wl
operator|=
name|wl
operator|->
name|next
control|)
if|if
condition|(
name|wl
operator|->
name|t
operator|->
name|type
operator|==
name|COALESCED
condition|)
block|{
name|struct
name|web
modifier|*
name|tweb
decl_stmt|;
for|for
control|(
name|tweb
operator|=
name|wl
operator|->
name|t
operator|->
name|alias
init|;
name|tweb
condition|;
name|tweb
operator|=
name|tweb
operator|->
name|alias
control|)
block|{
if|if
condition|(
name|wl
operator|->
name|sub
operator|==
name|NULL
condition|)
name|record_conflict
argument_list|(
name|web
argument_list|,
name|tweb
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|sub_conflict
modifier|*
name|sl
decl_stmt|;
for|for
control|(
name|sl
operator|=
name|wl
operator|->
name|sub
init|;
name|sl
condition|;
name|sl
operator|=
name|sl
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|sweb
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|SUBWEB_P
argument_list|(
name|sl
operator|->
name|t
argument_list|)
condition|)
name|sweb
operator|=
name|find_subweb
argument_list|(
name|tweb
argument_list|,
name|sl
operator|->
name|t
operator|->
name|orig_x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sweb
condition|)
name|sweb
operator|=
name|tweb
expr_stmt|;
name|record_conflict
argument_list|(
name|sl
operator|->
name|s
argument_list|,
name|sweb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tweb
operator|->
name|type
operator|!=
name|COALESCED
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Repeatedly break aliases for spilled webs, which were target for    coalescing, and recolorize the resulting parts.  Do this as long as    there are any spilled coalesce targets.  */
end_comment

begin_function
specifier|static
name|void
name|break_coalesced_spills
parameter_list|()
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|struct
name|web
modifier|*
name|web
decl_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
operator|->
name|is_coalesced
condition|)
break|break;
if|if
condition|(
operator|!
name|d
condition|)
break|break;
name|changed
operator|=
literal|1
expr_stmt|;
name|web
operator|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"breaking aliases to web %d:"
argument_list|,
name|web
operator|->
name|id
argument_list|)
expr_stmt|;
name|restore_conflicts_from_coalesce
argument_list|(
name|web
argument_list|)
expr_stmt|;
name|break_aliases_to_web
argument_list|(
name|web
argument_list|)
expr_stmt|;
comment|/* WEB was a spilled web and isn't anymore.  Everything coalesced 	 to WEB is now SELECTed and might potentially get a color. 	 If those other webs were itself targets of coalescing it might be 	 that there are still some conflicts from aliased webs missing, 	 because they were added in combine() right into the now 	 SELECTed web.  So we need to add those missing conflicts here.  */
name|insert_coalesced_conflicts
argument_list|()
expr_stmt|;
name|ra_debug_msg
argument_list|(
name|DUMP_COLORIZE
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|remove_list
argument_list|(
name|d
argument_list|,
operator|&
name|WEBS
argument_list|(
name|SPILLED
argument_list|)
argument_list|)
expr_stmt|;
name|put_web
argument_list|(
name|web
argument_list|,
name|SELECT
argument_list|)
expr_stmt|;
name|web
operator|->
name|color
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|WEBS
argument_list|(
name|SELECT
argument_list|)
condition|)
block|{
name|d
operator|=
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|SELECT
argument_list|)
argument_list|)
expr_stmt|;
name|colorize_one_web
argument_list|(
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
condition|)
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|WEBS
argument_list|(
name|COALESCED
argument_list|)
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|struct
name|web
modifier|*
name|a
init|=
name|alias
argument_list|(
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
argument_list|)
decl_stmt|;
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
operator|->
name|color
operator|=
name|a
operator|->
name|color
expr_stmt|;
block|}
block|}
name|dump_graph_cost
argument_list|(
name|DUMP_COSTS
argument_list|,
literal|"after alias-breaking"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A structure for fast hashing of a pair of webs.    Used to cumulate savings (from removing copy insns) for coalesced webs.    All the pairs are also put into a single linked list.  */
end_comment

begin_struct
struct|struct
name|web_pair
block|{
name|struct
name|web_pair
modifier|*
name|next_hash
decl_stmt|;
name|struct
name|web_pair
modifier|*
name|next_list
decl_stmt|;
name|struct
name|web
modifier|*
name|smaller
decl_stmt|;
name|struct
name|web
modifier|*
name|larger
decl_stmt|;
name|unsigned
name|int
name|conflicts
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|cost
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The actual hash table.  */
end_comment

begin_define
define|#
directive|define
name|WEB_PAIR_HASH_SIZE
value|8192
end_define

begin_decl_stmt
specifier|static
name|struct
name|web_pair
modifier|*
name|web_pair_hash
index|[
name|WEB_PAIR_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|web_pair
modifier|*
name|web_pair_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|num_web_pairs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear the hash table of web pairs.  */
end_comment

begin_function
specifier|static
name|void
name|init_web_pairs
parameter_list|()
block|{
name|memset
argument_list|(
name|web_pair_hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|web_pair_hash
argument_list|)
expr_stmt|;
name|num_web_pairs
operator|=
literal|0
expr_stmt|;
name|web_pair_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given two webs connected by a move with cost COST which together    have CONFLICTS conflicts, add that pair to the hash table, or if    already in, cumulate the costs and conflict number.  */
end_comment

begin_function
specifier|static
name|void
name|add_web_pair_cost
parameter_list|(
name|web1
parameter_list|,
name|web2
parameter_list|,
name|cost
parameter_list|,
name|conflicts
parameter_list|)
name|struct
name|web
modifier|*
name|web1
decl_stmt|,
decl|*
name|web2
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
name|HOST_WIDE_INT
name|cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|conflicts
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
name|struct
name|web_pair
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|web1
operator|->
name|id
operator|>
name|web2
operator|->
name|id
condition|)
block|{
name|struct
name|web
modifier|*
name|h
init|=
name|web1
decl_stmt|;
name|web1
operator|=
name|web2
expr_stmt|;
name|web2
operator|=
name|h
expr_stmt|;
block|}
name|hash
operator|=
operator|(
name|web1
operator|->
name|id
operator|*
name|num_webs
operator|+
name|web2
operator|->
name|id
operator|)
operator|%
name|WEB_PAIR_HASH_SIZE
expr_stmt|;
for|for
control|(
name|p
operator|=
name|web_pair_hash
index|[
name|hash
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_hash
control|)
if|if
condition|(
name|p
operator|->
name|smaller
operator|==
name|web1
operator|&&
name|p
operator|->
name|larger
operator|==
name|web2
condition|)
block|{
name|p
operator|->
name|cost
operator|+=
name|cost
expr_stmt|;
name|p
operator|->
name|conflicts
operator|+=
name|conflicts
expr_stmt|;
return|return;
block|}
name|p
operator|=
operator|(
expr|struct
name|web_pair
operator|*
operator|)
name|ra_alloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|next_hash
operator|=
name|web_pair_hash
index|[
name|hash
index|]
expr_stmt|;
name|p
operator|->
name|next_list
operator|=
name|web_pair_list
expr_stmt|;
name|p
operator|->
name|smaller
operator|=
name|web1
expr_stmt|;
name|p
operator|->
name|larger
operator|=
name|web2
expr_stmt|;
name|p
operator|->
name|conflicts
operator|=
name|conflicts
expr_stmt|;
name|p
operator|->
name|cost
operator|=
name|cost
expr_stmt|;
name|web_pair_hash
index|[
name|hash
index|]
operator|=
name|p
expr_stmt|;
name|web_pair_list
operator|=
name|p
expr_stmt|;
name|num_web_pairs
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Suitable to be passed to qsort().  Sort web pairs so, that those    with more conflicts and higher cost (which actually is a saving    when the moves are removed) come first.  */
end_comment

begin_function
specifier|static
name|int
name|comp_web_pairs
parameter_list|(
name|w1
parameter_list|,
name|w2
parameter_list|)
specifier|const
name|void
modifier|*
name|w1
decl_stmt|,
decl|*
name|w2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|web_pair
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|web_pair
operator|*
operator|*
operator|)
name|w1
decl_stmt|;
name|struct
name|web_pair
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|web_pair
operator|*
operator|*
operator|)
name|w2
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|conflicts
operator|>
name|p2
operator|->
name|conflicts
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|p1
operator|->
name|conflicts
operator|<
name|p2
operator|->
name|conflicts
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|p1
operator|->
name|cost
operator|>
name|p2
operator|->
name|cost
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|p1
operator|->
name|cost
operator|<
name|p2
operator|->
name|cost
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Given the list of web pairs, begin to combine them from the one    with the most savings.  */
end_comment

begin_function
specifier|static
name|void
name|sort_and_combine_web_pairs
parameter_list|(
name|for_move
parameter_list|)
name|int
name|for_move
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|web_pair
modifier|*
modifier|*
name|sorted
decl_stmt|;
name|struct
name|web_pair
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|num_web_pairs
condition|)
return|return;
name|sorted
operator|=
operator|(
expr|struct
name|web_pair
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|num_web_pairs
operator|*
sizeof|sizeof
argument_list|(
name|sorted
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|web_pair_list
operator|,
name|i
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_list
control|)
name|sorted
index|[
name|i
operator|++
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|num_web_pairs
condition|)
name|abort
argument_list|()
expr_stmt|;
name|qsort
argument_list|(
name|sorted
argument_list|,
name|num_web_pairs
argument_list|,
sizeof|sizeof
argument_list|(
name|sorted
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|comp_web_pairs
argument_list|)
expr_stmt|;
comment|/* After combining one pair, we actually should adjust the savings      of the other pairs, if they are connected to one of the just coalesced      pair.  Later.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_web_pairs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|w1
decl_stmt|,
modifier|*
name|w2
decl_stmt|;
name|p
operator|=
name|sorted
index|[
name|i
index|]
expr_stmt|;
name|w1
operator|=
name|alias
argument_list|(
name|p
operator|->
name|smaller
argument_list|)
expr_stmt|;
name|w2
operator|=
name|alias
argument_list|(
name|p
operator|->
name|larger
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|for_move
operator|&&
operator|(
name|w1
operator|->
name|type
operator|==
name|PRECOLORED
operator|||
name|w2
operator|->
name|type
operator|==
name|PRECOLORED
operator|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|w2
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
block|{
name|struct
name|web
modifier|*
name|h
init|=
name|w1
decl_stmt|;
name|w1
operator|=
name|w2
expr_stmt|;
name|w2
operator|=
name|h
expr_stmt|;
block|}
if|if
condition|(
name|w1
operator|!=
name|w2
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|w1
operator|->
name|id
operator|*
name|num_webs
operator|+
name|w2
operator|->
name|id
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|w2
operator|->
name|id
operator|*
name|num_webs
operator|+
name|w1
operator|->
name|id
argument_list|)
operator|&&
name|w2
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
name|hard_regs_intersect_p
argument_list|(
operator|&
name|w1
operator|->
name|usable_regs
argument_list|,
operator|&
name|w2
operator|->
name|usable_regs
argument_list|)
condition|)
block|{
if|if
condition|(
name|w1
operator|->
name|type
operator|!=
name|PRECOLORED
operator|||
operator|(
name|w1
operator|->
name|type
operator|==
name|PRECOLORED
operator|&&
name|ok
argument_list|(
name|w2
argument_list|,
name|w1
argument_list|)
operator|)
condition|)
name|combine
argument_list|(
name|w1
argument_list|,
name|w2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|w1
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|w2
operator|->
name|prefer_colors
argument_list|,
name|w1
operator|->
name|color
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Greedily coalesce all moves possible.  Begin with the web pair    giving the most saving if coalesced.  */
end_comment

begin_function
specifier|static
name|void
name|aggressive_coalesce
parameter_list|()
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
name|struct
name|move
modifier|*
name|m
decl_stmt|;
name|init_web_pairs
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|pop_list
argument_list|(
operator|&
name|mv_worklist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|m
operator|=
name|DLIST_MOVE
argument_list|(
name|d
argument_list|)
operator|)
condition|)
block|{
name|struct
name|web
modifier|*
name|s
init|=
name|alias
argument_list|(
name|m
operator|->
name|source_web
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|t
init|=
name|alias
argument_list|(
name|m
operator|->
name|target_web
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
block|{
name|struct
name|web
modifier|*
name|h
init|=
name|s
decl_stmt|;
name|s
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|h
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
name|t
operator|&&
name|t
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|s
operator|->
name|id
operator|*
name|num_webs
operator|+
name|t
operator|->
name|id
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|t
operator|->
name|id
operator|*
name|num_webs
operator|+
name|s
operator|->
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|type
operator|==
name|PRECOLORED
operator|&&
name|ok
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
operator|)
operator|||
name|s
operator|->
name|type
operator|!=
name|PRECOLORED
condition|)
block|{
name|put_move
argument_list|(
name|m
argument_list|,
name|MV_COALESCED
argument_list|)
expr_stmt|;
name|add_web_pair_cost
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
operator|->
name|frequency
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
comment|/* It is !ok(t, s).  But later when coloring the graph it might 		 be possible to take that color.  So we remember the preferred 		 color to try that first.  */
block|{
name|put_move
argument_list|(
name|m
argument_list|,
name|CONSTRAINED
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|t
operator|->
name|prefer_colors
argument_list|,
name|s
operator|->
name|color
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|put_move
argument_list|(
name|m
argument_list|,
name|CONSTRAINED
argument_list|)
expr_stmt|;
block|}
block|}
name|sort_and_combine_web_pairs
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the difference between optimistic coalescing and    optimistic coalescing+.  Extended coalesce tries to coalesce also    non-conflicting nodes, not related by a move.  The criteria here is,    the one web must be a source, the other a destination of the same insn.    This actually makes sense, as (because they are in the same insn) they    share many of their neighbors, and if they are coalesced, reduce the    number of conflicts of those neighbors by one.  For this we sort the    candidate pairs again according to savings (and this time also conflict    number).     This is also a comparatively slow operation, as we need to go through    all insns, and for each insn, through all defs and uses.  */
end_comment

begin_function
specifier|static
name|void
name|extended_coalesce_2
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|ra_insn_info
name|info
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|init_web_pairs
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|info
operator|=
name|insn_df
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|)
operator|.
name|num_defs
condition|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|info
operator|.
name|num_defs
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|dest
init|=
name|def2web
index|[
name|DF_REF_ID
argument_list|(
name|info
operator|.
name|defs
index|[
name|n
index|]
argument_list|)
index|]
decl_stmt|;
name|dest
operator|=
name|alias
argument_list|(
name|find_web_for_subweb
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
name|dest
operator|->
name|regno
operator|<
name|max_normal_pseudo
condition|)
block|{
name|unsigned
name|int
name|n2
decl_stmt|;
for|for
control|(
name|n2
operator|=
literal|0
init|;
name|n2
operator|<
name|info
operator|.
name|num_uses
condition|;
name|n2
operator|++
control|)
block|{
name|struct
name|web
modifier|*
name|source
init|=
name|use2web
index|[
name|DF_REF_ID
argument_list|(
name|info
operator|.
name|uses
index|[
name|n2
index|]
argument_list|)
index|]
decl_stmt|;
name|source
operator|=
name|alias
argument_list|(
name|find_web_for_subweb
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
name|source
operator|!=
name|dest
operator|&&
name|source
operator|->
name|regno
operator|<
name|max_normal_pseudo
comment|/* Coalesced webs end up using the same REG rtx in 			 emit_colors().  So we can only coalesce something 			 of equal modes.  */
operator|&&
name|GET_MODE
argument_list|(
name|source
operator|->
name|orig_x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|dest
operator|->
name|orig_x
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|dest
operator|->
name|id
operator|*
name|num_webs
operator|+
name|source
operator|->
name|id
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|source
operator|->
name|id
operator|*
name|num_webs
operator|+
name|dest
operator|->
name|id
argument_list|)
operator|&&
name|hard_regs_intersect_p
argument_list|(
operator|&
name|source
operator|->
name|usable_regs
argument_list|,
operator|&
name|dest
operator|->
name|usable_regs
argument_list|)
condition|)
name|add_web_pair_cost
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|->
name|frequency
argument_list|,
name|dest
operator|->
name|num_conflicts
operator|+
name|source
operator|->
name|num_conflicts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sort_and_combine_web_pairs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if we forgot to coalesce some moves.  */
end_comment

begin_function
specifier|static
name|void
name|check_uncoalesced_moves
parameter_list|()
block|{
name|struct
name|move_list
modifier|*
name|ml
decl_stmt|;
name|struct
name|move
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|ml
operator|=
name|wl_moves
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|m
operator|=
name|ml
operator|->
name|move
operator|)
condition|)
block|{
name|struct
name|web
modifier|*
name|s
init|=
name|alias
argument_list|(
name|m
operator|->
name|source_web
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|t
init|=
name|alias
argument_list|(
name|m
operator|->
name|target_web
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|PRECOLORED
condition|)
block|{
name|struct
name|web
modifier|*
name|h
init|=
name|s
decl_stmt|;
name|s
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|h
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
name|t
operator|&&
name|m
operator|->
name|type
operator|!=
name|CONSTRAINED
comment|/* Following can happen when a move was coalesced, but later 	       broken up again.  Then s!=t, but m is still MV_COALESCED.  */
operator|&&
name|m
operator|->
name|type
operator|!=
name|MV_COALESCED
operator|&&
name|t
operator|->
name|type
operator|!=
name|PRECOLORED
operator|&&
operator|(
operator|(
name|s
operator|->
name|type
operator|==
name|PRECOLORED
operator|&&
name|ok
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
operator|)
operator|||
name|s
operator|->
name|type
operator|!=
name|PRECOLORED
operator|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|s
operator|->
name|id
operator|*
name|num_webs
operator|+
name|t
operator|->
name|id
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|sup_igraph
argument_list|,
name|t
operator|->
name|id
operator|*
name|num_webs
operator|+
name|s
operator|->
name|id
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The toplevel function in this file.  Precondition is, that    the interference graph is built completely by ra-build.c.  This    produces a list of spilled, colored and coalesced nodes.  */
end_comment

begin_function
name|void
name|ra_colorize_graph
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_igraph
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|build_worklists
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/* With optimistic coalescing we coalesce everything we can.  */
if|if
condition|(
name|flag_ra_optimistic_coalescing
condition|)
block|{
name|aggressive_coalesce
argument_list|()
expr_stmt|;
name|extended_coalesce_2
argument_list|()
expr_stmt|;
block|}
comment|/* Now build the select stack.  */
do|do
block|{
name|simplify
argument_list|()
expr_stmt|;
if|if
condition|(
name|mv_worklist
condition|)
name|coalesce
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|WEBS
argument_list|(
name|FREEZE
argument_list|)
condition|)
name|freeze
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|WEBS
argument_list|(
name|SPILL
argument_list|)
condition|)
name|select_spill
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|WEBS
argument_list|(
name|SIMPLIFY
argument_list|)
operator|||
name|WEBS
argument_list|(
name|SIMPLIFY_FAT
argument_list|)
operator|||
name|WEBS
argument_list|(
name|SIMPLIFY_SPILL
argument_list|)
operator|||
name|mv_worklist
operator|||
name|WEBS
argument_list|(
name|FREEZE
argument_list|)
operator|||
name|WEBS
argument_list|(
name|SPILL
argument_list|)
condition|)
do|;
if|if
condition|(
name|flag_ra_optimistic_coalescing
condition|)
name|check_uncoalesced_moves
argument_list|()
expr_stmt|;
comment|/* Actually colorize the webs from the select stack.  */
name|assign_colors
argument_list|()
expr_stmt|;
name|check_colors
argument_list|()
expr_stmt|;
name|dump_graph_cost
argument_list|(
name|DUMP_COSTS
argument_list|,
literal|"initially"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_ra_break_aliases
condition|)
name|break_coalesced_spills
argument_list|()
expr_stmt|;
name|check_colors
argument_list|()
expr_stmt|;
comment|/* And try to improve the cost by recoloring spilled webs.  */
name|recolor_spills
argument_list|()
expr_stmt|;
name|dump_graph_cost
argument_list|(
name|DUMP_COSTS
argument_list|,
literal|"after spill-recolor"
argument_list|)
expr_stmt|;
name|check_colors
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize this module.  */
end_comment

begin_function
name|void
name|ra_colorize_init
parameter_list|()
block|{
comment|/* FIXME: Choose spill heuristic for platform if we have one */
name|spill_heuristic
operator|=
name|default_spill_heuristic
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all memory.  (Note that we don't need to free any per pass    memory).  */
end_comment

begin_function
name|void
name|ra_colorize_free_all
parameter_list|()
block|{
name|struct
name|dlist
modifier|*
name|d
decl_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|FREE
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|put_web
argument_list|(
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
argument_list|,
name|INITIAL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|pop_list
argument_list|(
operator|&
name|WEBS
argument_list|(
name|INITIAL
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|web
modifier|*
name|web
init|=
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|web
modifier|*
name|wnext
decl_stmt|;
name|web
operator|->
name|orig_conflict_list
operator|=
name|NULL
expr_stmt|;
name|web
operator|->
name|conflict_list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|web
operator|=
name|web
operator|->
name|subreg_next
init|;
name|web
condition|;
name|web
operator|=
name|wnext
control|)
block|{
name|wnext
operator|=
name|web
operator|->
name|subreg_next
expr_stmt|;
name|free
argument_list|(
name|web
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|DLIST_WEB
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* vim:cinoptions={.5s,g0,p5,t0,(0,^-0.5s,n-0.5s:tw=78:cindent:sw=4: */
end_comment

end_unit

