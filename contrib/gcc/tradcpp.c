begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C Compatible Compiler Preprocessor (CCCP) Copyright (C) 1986, 1987, 1989, 2000, 2001 Free Software Foundation, Inc.                     Written by Paul Rubin, June 1986 		    Adapted to ANSI C, Richard Stallman, Jan 1987 		    Dusted off, polished, and adapted for use as traditional 		    preprocessor only, Zack Weinberg, Jul 2000  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"cppdefault.h"
end_include

begin_include
include|#
directive|include
file|"tradcpp.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_typedef
typedef|typedef
name|unsigned
name|char
name|U_CHAR
typedef|;
end_typedef

begin_comment
comment|/* Name under which this program was invoked.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current maximum length of directory names in the search path    for include files.  (Altered as we get more of them.)  */
end_comment

begin_decl_stmt
name|size_t
name|max_include_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means copy comments into the output file.  */
end_comment

begin_decl_stmt
name|int
name|put_out_comments
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mkdeps.h opaque structure that encapsulates dependency information.  */
end_comment

begin_decl_stmt
name|struct
name|deps
modifier|*
name|deps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print the names of included files rather than    the preprocessed output.  1 means just the #include "...",    2 means #include<...> as well.  */
end_comment

begin_decl_stmt
name|int
name|print_deps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print dummy targets for each header file.  */
end_comment

begin_decl_stmt
name|int
name|print_deps_phony_targets
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If true, fopen (deps_file, "a") else fopen (deps_file, "w").  */
end_comment

begin_decl_stmt
name|int
name|deps_append
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name which deps are being written to.  This is 0 if deps are    being written to stdout.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|deps_file
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if missing .h files in -M output are assumed to be    generated files and not errors.  */
end_comment

begin_decl_stmt
name|int
name|deps_missing_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't output line number information.  */
end_comment

begin_decl_stmt
name|int
name|no_line_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means inhibit output of the preprocessed text    and instead output the definitions of all user-defined macros    in a form suitable for use as input to cccp.  */
end_comment

begin_decl_stmt
name|int
name|dump_macros
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't print warning messages.  -w.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-0 means don't output the preprocessed program.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if slash-star appears in a comment.  */
end_comment

begin_decl_stmt
name|int
name|warn_comments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero causes output not to be done,    but directives such as #define that have side effects    are still obeyed.  */
end_comment

begin_decl_stmt
name|int
name|no_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of __USER_LABEL_PREFIX__.  Target-dependent, also controlled    by -f(no-)leading-underscore.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|user_label_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/O buffer structure.    The `fname' field is nonzero for source files and #include files    and for the dummy text used for -D and -U.    It is zero for rescanning results of macro expansion    and for expanding macro arguments.  */
end_comment

begin_define
define|#
directive|define
name|INPUT_STACK_MAX
value|200
end_define

begin_struct_decl
struct_decl|struct
name|file_name_list
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|file_buf
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|int
name|length
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|bufp
decl_stmt|;
comment|/* Macro that this level is the expansion of.      Included so that we can reenable the macro      at the end of this level.  */
name|struct
name|hashnode
modifier|*
name|macro
decl_stmt|;
comment|/* Value of if_stack at start of this file.      Used to prohibit unmatched #endif (etc) in an include file.  */
name|struct
name|if_stack
modifier|*
name|if_stack
decl_stmt|;
comment|/* Object to be freed at end of input at this level.  */
name|U_CHAR
modifier|*
name|free_ptr
decl_stmt|;
comment|/* Position to start scanning for #include_next in this file.  */
name|struct
name|file_name_list
modifier|*
name|next_header_dir
decl_stmt|;
block|}
name|instack
index|[
name|INPUT_STACK_MAX
index|]
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|file_buf
name|FILE_BUF
typedef|;
end_typedef

begin_comment
comment|/* Current nesting level of input sources.    `instack[indepth]' is the level currently being read.  */
end_comment

begin_decl_stmt
name|int
name|indepth
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHECK_DEPTH
parameter_list|(
name|code
parameter_list|)
define|\
value|if (indepth>= (INPUT_STACK_MAX - 1))					\     {									\       error_with_line (line_for_error (instack[indepth].lineno),	\ 		       "macro or #include recursion too deep");		\       code;								\     }
end_define

begin_comment
comment|/* Current depth in #include directives that use<...>.  */
end_comment

begin_decl_stmt
name|int
name|system_include_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The output buffer.  Its LENGTH field is the amount of room allocated    for the buffer, not the number of chars actually present.  To get    that, subtract outbuf.buf from outbuf.bufp. */
end_comment

begin_define
define|#
directive|define
name|OUTBUF_SIZE
value|10
end_define

begin_comment
comment|/* initial size of output buffer */
end_comment

begin_decl_stmt
name|FILE_BUF
name|outbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Grow output buffer OBUF points at    so it can hold at least NEEDED more chars.  */
end_comment

begin_define
define|#
directive|define
name|check_expand
parameter_list|(
name|OBUF
parameter_list|,
name|NEEDED
parameter_list|)
value|do { \   if ((OBUF)->length - ((OBUF)->bufp - (OBUF)->buf)<= (NEEDED)) \     grow_outbuf ((OBUF), (NEEDED)); \  } while (0)
end_define

begin_struct
struct|struct
name|file_name_list
block|{
name|struct
name|file_name_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First dir to search */
end_comment

begin_comment
comment|/* First dir to search for<file> */
end_comment

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|first_bracket_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|last_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_comment
comment|/* List of included files that contained #once.  */
end_comment

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|dont_repeat_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of other included files.  */
end_comment

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|all_include_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Structure allocated for every #define.  For a simple replacement    such as    	#define foo bar ,    nargs = -1, the `pattern' list is null, and the expansion is just    the replacement text.  Nargs = 0 means a functionlike macro with no args,    e.g.,        #define getchar() getc (stdin) .    When there are args, the expansion is the replacement text with the    args squashed out, and the reflist is a list describing how to    build the output from the input: e.g., "3 chars, then the 1st arg,    then 9 chars, then the 3rd arg, then 0 chars, then the 2nd arg".    The chars here come from the expansion.  Whatever is left of the    expansion after the last arg-occurrence is copied after that arg.    Note that the reflist can be arbitrarily long---    its length depends on the number of times the arguments appear in    the replacement text, not how many args there are.  Example:    #define f(x) x+x+x+x+x+x+x would have replacement text "++++++" and    pattern list      { (0, 1), (1, 1), (1, 1), ..., (1, 1), NULL }    where (x, y) means (nchars, argno). */
end_comment

begin_typedef
typedef|typedef
name|struct
name|definition
name|DEFINITION
typedef|;
end_typedef

begin_struct
struct|struct
name|definition
block|{
name|int
name|nargs
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of expansion string */
name|U_CHAR
modifier|*
name|expansion
decl_stmt|;
struct|struct
name|reflist
block|{
name|struct
name|reflist
modifier|*
name|next
decl_stmt|;
name|char
name|stringify
decl_stmt|;
comment|/* nonzero if this arg was preceded by a 				   # operator. */
name|char
name|raw_before
decl_stmt|;
comment|/* Nonzero if a ## operator before arg. */
name|char
name|raw_after
decl_stmt|;
comment|/* Nonzero if a ## operator after arg. */
name|int
name|nchars
decl_stmt|;
comment|/* Number of literal chars to copy before 				   this arg occurrence.  */
name|int
name|argno
decl_stmt|;
comment|/* Number of arg to substitute (origin-0) */
block|}
modifier|*
name|pattern
struct|;
comment|/* Names of macro args, concatenated in reverse order      with comma-space between them.      The only use of this is that we warn on redefinition      if this differs between the old and new definitions.  */
specifier|const
name|U_CHAR
modifier|*
name|argnames
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chained list of answers to an assertion.  */
end_comment

begin_struct
struct|struct
name|answer
block|{
name|struct
name|answer
modifier|*
name|next
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|answer
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* different kinds of things that can appear in the value field    of a hash node.  Actually, this may be useless now. */
end_comment

begin_union
union|union
name|hashval
block|{
specifier|const
name|char
modifier|*
name|cpval
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|struct
name|answer
modifier|*
name|answers
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* The structure of a node in the hash table.  The hash table    has entries for all tokens defined by #define commands (type T_MACRO),    plus some special tokens like __LINE__ (these each have their own    type, and the appropriate code is run when that type of node is seen.    It does not contain control words like "#define", which are recognized    by a separate piece of code. */
end_comment

begin_comment
comment|/* different flavors of hash nodes --- also used in keyword table */
end_comment

begin_enum
enum|enum
name|node_type
block|{
name|T_DEFINE
init|=
literal|1
block|,
comment|/* `#define' */
name|T_INCLUDE
block|,
comment|/* `#include' */
name|T_INCLUDE_NEXT
block|,
comment|/* `#include_next' */
name|T_IFDEF
block|,
comment|/* `#ifdef' */
name|T_IFNDEF
block|,
comment|/* `#ifndef' */
name|T_IF
block|,
comment|/* `#if' */
name|T_ELSE
block|,
comment|/* `#else' */
name|T_ELIF
block|,
comment|/* `#elif' */
name|T_UNDEF
block|,
comment|/* `#undef' */
name|T_LINE
block|,
comment|/* `#line' */
name|T_ENDIF
block|,
comment|/* `#endif' */
name|T_ERROR
block|,
comment|/* `#error' */
name|T_WARNING
block|,
comment|/* `#warning' */
name|T_ASSERT
block|,
comment|/* `#assert' */
name|T_UNASSERT
block|,
comment|/* `#unassert' */
name|T_SPECLINE
block|,
comment|/* special symbol `__LINE__' */
name|T_DATE
block|,
comment|/* `__DATE__' */
name|T_FILE
block|,
comment|/* `__FILE__' */
name|T_BASE_FILE
block|,
comment|/* `__BASE_FILE__' */
name|T_INCLUDE_LEVEL
block|,
comment|/* `__INCLUDE_LEVEL__' */
name|T_VERSION
block|,
comment|/* `__VERSION__' */
name|T_TIME
block|,
comment|/* `__TIME__' */
name|T_CONST
block|,
comment|/* Constant value, used by `__STDC__' */
name|T_MACRO
block|,
comment|/* macro defined by `#define' */
name|T_SPEC_DEFINED
block|,
comment|/* special `defined' macro for use in #if statements */
name|T_UNUSED
comment|/* Used for something not defined.  */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|hashnode
block|{
name|struct
name|hashnode
modifier|*
name|next
decl_stmt|;
comment|/* double links for easy deletion */
name|struct
name|hashnode
modifier|*
name|prev
decl_stmt|;
name|struct
name|hashnode
modifier|*
modifier|*
name|bucket_hdr
decl_stmt|;
comment|/* also, a back pointer to this node's hash 				   chain is kept, in case the node is the head 				   of the chain and gets deleted. */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* type of special token */
name|int
name|length
decl_stmt|;
comment|/* length of token, for quick comparison */
name|U_CHAR
modifier|*
name|name
decl_stmt|;
comment|/* the actual name */
name|union
name|hashval
name|value
decl_stmt|;
comment|/* pointer to expansion, or whatever */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|hashnode
name|HASHNODE
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|HASHNODE
modifier|*
name|parse_assertion
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|,
expr|struct
name|answer
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|answer
modifier|*
modifier|*
name|find_answer
name|PARAMS
argument_list|(
operator|(
name|HASHNODE
operator|*
operator|,
specifier|const
expr|struct
name|answer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_answer
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|,
expr|struct
name|answer
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|canonicalize_text
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some definitions for the hash table.  The hash function MUST be    computed as shown in hashf () below.  That is because the rescan    loop computes the hash value `on the fly' for most tokens,    in order to avoid the overhead of a lot of procedure calls to    the hashf () function.  Hashf () only exists for the sake of    politeness, for use when speed isn't so important. */
end_comment

begin_define
define|#
directive|define
name|HASHSIZE
value|1403
end_define

begin_decl_stmt
name|HASHNODE
modifier|*
name|hashtab
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HASHSTEP
parameter_list|(
name|old
parameter_list|,
name|c
parameter_list|)
value|((old<< 2) + c)
end_define

begin_define
define|#
directive|define
name|MAKE_POS
parameter_list|(
name|v
parameter_list|)
value|(v& 0x7fffffff)
end_define

begin_comment
comment|/* make number positive */
end_comment

begin_comment
comment|/* `struct directive' defines one #-directive, including how to handle it.  */
end_comment

begin_struct
struct|struct
name|directive
block|{
specifier|const
name|int
name|length
decl_stmt|;
comment|/* Length of name */
name|void
argument_list|(
argument|*const func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Function to handle directive */
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Name of directive */
specifier|const
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* Code which describes which directive. */
block|}
struct|;
end_struct

begin_comment
comment|/* Last arg to output_line_command.  */
end_comment

begin_enum
enum|enum
name|file_change_code
block|{
name|same_file
block|,
name|enter_file
block|,
name|leave_file
block|}
enum|;
end_enum

begin_comment
comment|/* This structure represents one parsed argument in a macro call.    `raw' points to the argument text as written (`raw_length' is its length).    `expanded' points to the argument's macro-expansion    (its length is `expand_length').    `stringified_length' is the length the argument would have    if stringified.    `free1' and `free2', if nonzero, point to blocks to be freed    when the macro argument data is no longer needed.  */
end_comment

begin_struct
struct|struct
name|argdata
block|{
name|U_CHAR
modifier|*
name|raw
decl_stmt|,
modifier|*
name|expanded
decl_stmt|;
name|int
name|raw_length
decl_stmt|,
name|expand_length
decl_stmt|;
name|int
name|stringified_length
decl_stmt|;
name|U_CHAR
modifier|*
name|free1
decl_stmt|,
modifier|*
name|free2
decl_stmt|;
name|char
name|newlines
decl_stmt|;
name|char
name|comments
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The arglist structure is built by do_define to tell    collect_definition where the argument names begin.  That    is, for a define like "#define f(x,y,z) foo+x-bar*y", the arglist    would contain pointers to the strings x, y, and z.    Collect_definition would then build a DEFINITION node,    with reflist nodes pointing to the places x, y, and z had    appeared.  So the arglist is just convenience data passed    between these two routines.  It is not kept around after    the current #define has been processed and entered into the    hash table. */
end_comment

begin_struct
struct|struct
name|arglist
block|{
name|struct
name|arglist
modifier|*
name|next
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|argno
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Function prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_define
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_error
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_warning
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_line
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_include
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_include_next
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_undef
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_if
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_ifdef
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_ifndef
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_else
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_elif
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_endif
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_assert
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_unassert
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_xifdef
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
expr|enum
name|node_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hashnode
modifier|*
name|install
name|PARAMS
argument_list|(
operator|(
specifier|const
name|U_CHAR
operator|*
operator|,
name|int
operator|,
expr|enum
name|node_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hashf
name|PARAMS
argument_list|(
operator|(
specifier|const
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_defs
name|PARAMS
argument_list|(
operator|(
name|DEFINITION
operator|*
operator|,
name|DEFINITION
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_def_part
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|U_CHAR
operator|*
operator|,
name|int
operator|,
specifier|const
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_macro
name|PARAMS
argument_list|(
operator|(
name|HASHNODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First arg to v_message.  */
end_comment

begin_enum
enum|enum
name|msgtype
block|{
name|MT_WARNING
init|=
literal|0
block|,
name|MT_ERROR
block|,
name|MT_FATAL
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|v_message
name|PARAMS
argument_list|(
operator|(
expr|enum
name|msgtype
name|mtype
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
name|va_list
name|ap
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|line_for_error
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We know perfectly well which file this is, so we don't need to    use __FILE__.  */
end_comment

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_if
if|#
directive|if
operator|(
name|GCC_VERSION
operator|>=
literal|2007
operator|)
end_if

begin_define
define|#
directive|define
name|abort
parameter_list|()
value|fancy_abort(__LINE__, __FUNCTION__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|abort
parameter_list|()
value|fancy_abort(__LINE__, 0);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|macroexpand
name|PARAMS
argument_list|(
operator|(
name|HASHNODE
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|special_symbol
name|PARAMS
argument_list|(
operator|(
name|HASHNODE
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_all_macros
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_defn_1
name|PARAMS
argument_list|(
operator|(
specifier|const
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_arg_n
name|PARAMS
argument_list|(
operator|(
name|DEFINITION
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|conditional_skip
name|PARAMS
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|int
operator|,
expr|enum
name|node_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|skip_if_group
name|PARAMS
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_line_command
name|PARAMS
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|FILE_BUF
operator|*
operator|,
name|int
operator|,
expr|enum
name|file_change_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eval_if_expression
name|PARAMS
argument_list|(
operator|(
specifier|const
name|U_CHAR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_deps
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_builtins
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|run_directive
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
expr|enum
name|node_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_definition
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_undef
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_assertion
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|grow_outbuf
name|PARAMS
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|handle_directive
name|PARAMS
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_include
name|PARAMS
argument_list|(
operator|(
expr|struct
name|file_name_list
operator|*
operator|,
specifier|const
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finclude
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|file_name_list
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_dependency_output
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rescan
name|PARAMS
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|newline_fix
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|name_newline_fix
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_CHAR
modifier|*
name|macarg1
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
specifier|const
name|U_CHAR
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|macarg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|argdata
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|discard_comments
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|file_size_and_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|,
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_CHAR
modifier|*
name|skip_to_end_of_comment
name|PARAMS
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_CHAR
modifier|*
name|skip_quoted_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|U_CHAR
operator|*
operator|,
specifier|const
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convenience.  Write U"string" to get an unsigned string constant.  */
end_comment

begin_define
define|#
directive|define
name|U
value|(const unsigned char *)
end_define

begin_comment
comment|/* Here is the actual list of #-directives, most-often-used first.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|directive
name|directive_table
index|[]
init|=
block|{
block|{
literal|6
block|,
name|do_define
block|,
literal|"define"
block|,
name|T_DEFINE
block|}
block|,
block|{
literal|7
block|,
name|do_include
block|,
literal|"include"
block|,
name|T_INCLUDE
block|}
block|,
block|{
literal|5
block|,
name|do_endif
block|,
literal|"endif"
block|,
name|T_ENDIF
block|}
block|,
block|{
literal|5
block|,
name|do_ifdef
block|,
literal|"ifdef"
block|,
name|T_IFDEF
block|}
block|,
block|{
literal|2
block|,
name|do_if
block|,
literal|"if"
block|,
name|T_IF
block|,     }
block|,
block|{
literal|4
block|,
name|do_else
block|,
literal|"else"
block|,
name|T_ELSE
block|}
block|,
block|{
literal|6
block|,
name|do_ifndef
block|,
literal|"ifndef"
block|,
name|T_IFNDEF
block|}
block|,
block|{
literal|5
block|,
name|do_undef
block|,
literal|"undef"
block|,
name|T_UNDEF
block|}
block|,
block|{
literal|4
block|,
name|do_line
block|,
literal|"line"
block|,
name|T_LINE
block|}
block|,
block|{
literal|4
block|,
name|do_elif
block|,
literal|"elif"
block|,
name|T_ELIF
block|}
block|,
block|{
literal|5
block|,
name|do_error
block|,
literal|"error"
block|,
name|T_ERROR
block|}
block|,
block|{
literal|7
block|,
name|do_warning
block|,
literal|"warning"
block|,
name|T_WARNING
block|}
block|,
block|{
literal|12
block|,
name|do_include_next
block|,
literal|"include_next"
block|,
name|T_INCLUDE_NEXT
block|}
block|,
block|{
literal|6
block|,
name|do_assert
block|,
literal|"assert"
block|,
name|T_ASSERT
block|}
block|,
block|{
literal|8
block|,
name|do_unassert
block|,
literal|"unassert"
block|,
name|T_UNASSERT
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|""
block|,
name|T_UNUSED
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SKIP_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_nvspace(*p)) p++; } while (0)
end_define

begin_define
define|#
directive|define
name|SKIP_ALL_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_space(*p)) p++; } while (0)
end_define

begin_decl_stmt
name|int
name|errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error counter for exit code */
end_comment

begin_decl_stmt
specifier|static
name|FILE_BUF
name|expand_to_temp_buffer
name|PARAMS
argument_list|(
operator|(
specifier|const
name|U_CHAR
operator|*
operator|,
specifier|const
name|U_CHAR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DEFINITION
modifier|*
name|collect_expansion
name|PARAMS
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
expr|struct
name|arglist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of conditionals currently in progress    (including both successful and failing conditionals).  */
end_comment

begin_struct
struct|struct
name|if_stack
block|{
name|struct
name|if_stack
modifier|*
name|next
decl_stmt|;
comment|/* for chaining to the next stack frame */
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* copied from input when frame is made */
name|int
name|lineno
decl_stmt|;
comment|/* similarly */
name|int
name|if_succeeded
decl_stmt|;
comment|/* true if a leg of this if-group 				    has been passed through rescan */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* type of last directive seen in this group */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|if_stack
name|IF_STACK_FRAME
typedef|;
end_typedef

begin_decl_stmt
name|IF_STACK_FRAME
modifier|*
name|if_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means -I- has been seen,    so don't look for #include "foo" the source-file directory.  */
end_comment

begin_decl_stmt
name|int
name|ignore_srcdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pending directives.  */
end_comment

begin_enum
enum|enum
name|pending_dir_t
block|{
name|PD_NONE
init|=
literal|0
block|,
name|PD_DEFINE
block|,
name|PD_UNDEF
block|,
name|PD_ASSERTION
block|,
name|PD_FILE
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|struct
name|pending_dir
name|pending_dir
typedef|;
end_typedef

begin_struct
struct|struct
name|pending_dir
block|{
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|enum
name|pending_dir_t
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|st_mode
decl_stmt|;
name|long
name|st_size
decl_stmt|;
specifier|const
name|char
modifier|*
name|in_fname
decl_stmt|,
modifier|*
name|out_fname
decl_stmt|;
name|int
name|f
decl_stmt|,
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
name|pending_dir
modifier|*
name|pend
init|=
operator|(
name|pending_dir
operator|*
operator|)
name|xcalloc
argument_list|(
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
name|pending_dir
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|no_standard_includes
init|=
literal|0
decl_stmt|;
name|hex_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_STACK
comment|/* Get rid of any avoidable limit on stack size.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca (particularly stringtab      * in dbxread.c) does not fail. */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RLIMIT_STACK defined */
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|in_fname
operator|=
name|NULL
expr_stmt|;
name|out_fname
operator|=
name|NULL
expr_stmt|;
name|no_line_commands
operator|=
literal|0
expr_stmt|;
name|dump_macros
operator|=
literal|0
expr_stmt|;
name|no_output
operator|=
literal|0
expr_stmt|;
name|max_include_len
operator|=
name|cpp_GCC_INCLUDE_DIR_len
operator|+
literal|7
expr_stmt|;
comment|/* ??? */
name|gcc_init_libintl
argument_list|()
expr_stmt|;
comment|/* It's simplest to just create this struct whether or not it will      be needed.  */
name|deps
operator|=
name|deps_init
argument_list|()
expr_stmt|;
comment|/* Process switches and find input file name.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|out_fname
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"usage: %s [switches] input output"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_fname
operator|!=
name|NULL
condition|)
name|out_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
name|in_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
init|=
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'E'
case|:
case|case
literal|'$'
case|:
break|break;
comment|/* Ignore for compatibility with ISO/extended cpp.  */
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c++"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-objc++"
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"-traditional is not supported in C++"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c89"
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"-traditional and -ansi are mutually exclusive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-objc"
argument_list|)
condition|)
name|pend
index|[
name|i
index|]
operator|.
name|type
operator|=
name|PD_DEFINE
operator|,
name|pend
index|[
name|i
index|]
operator|.
name|arg
operator|=
literal|"__OBJC__"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-asm"
argument_list|)
condition|)
name|pend
index|[
name|i
index|]
operator|.
name|type
operator|=
name|PD_DEFINE
operator|,
name|pend
index|[
name|i
index|]
operator|.
name|arg
operator|=
literal|"__ASSEMBLER__"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-fortran"
argument_list|)
condition|)
name|pend
index|[
name|i
index|]
operator|.
name|type
operator|=
name|PD_DEFINE
operator|,
name|pend
index|[
name|i
index|]
operator|.
name|arg
operator|=
literal|"_LANGUAGE_FORTRAN"
expr_stmt|;
comment|/* All other possibilities ignored.  */
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-include"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"filename missing after -i option"
argument_list|)
expr_stmt|;
else|else
name|pend
index|[
name|i
index|]
operator|.
name|type
operator|=
name|PD_FILE
operator|,
name|pend
index|[
name|i
index|]
operator|.
name|arg
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|,
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iprefix"
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Ignore for compatibility */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-isystem"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iwithprefix"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iwithprefixbefore"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-idirafter"
argument_list|)
condition|)
goto|goto
name|add_include
goto|;
comment|/* best we can do */
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|out_fname
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"output filename specified twice"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"filename missing after -o option"
argument_list|)
expr_stmt|;
name|out_fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|out_fname
argument_list|,
literal|"-"
argument_list|)
condition|)
name|out_fname
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomments"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomment"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wall"
argument_list|)
condition|)
block|{
name|warn_comments
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fleading-underscore"
argument_list|)
condition|)
name|user_label_prefix
operator|=
literal|"_"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fno-leading-underscore"
argument_list|)
condition|)
name|user_label_prefix
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
block|{
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
comment|/* -MD and -MMD for tradcpp are deprecated and undocumented 	     (use -M or -MM with -MF instead), and probably should be 	     removed with the next major GCC version.  For the moment 	     we allow these for the benefit of Automake 1.4, which 	     uses these when dependency tracking is enabled.  Automake 	     1.5 will fix this.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MD"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|3
expr_stmt|;
name|print_deps
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MMD"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|4
expr_stmt|;
name|print_deps
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-M"
argument_list|)
condition|)
block|{
name|print_deps
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MM"
argument_list|)
condition|)
block|{
name|print_deps
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MG"
argument_list|)
condition|)
block|{
name|deps_missing_files
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MF"
argument_list|)
condition|)
block|{
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MP"
argument_list|)
condition|)
block|{
name|print_deps_phony_targets
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MQ"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MT"
argument_list|)
condition|)
block|{
comment|/* Add a target.  -MQ quotes for Make.  */
specifier|const
name|char
modifier|*
name|tgt
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|3
decl_stmt|;
name|int
name|quoted
init|=
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'Q'
decl_stmt|;
if|if
condition|(
operator|*
name|tgt
operator|==
literal|'\0'
operator|&&
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"target missing after %s option"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|tgt
operator|==
literal|'\0'
condition|)
name|tgt
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|deps_add_target
argument_list|(
name|deps
argument_list|,
name|tgt
argument_list|,
name|quoted
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
condition|)
name|deps_file
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"filename missing after %s option"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|deps_file
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'d'
case|:
name|dump_macros
operator|=
literal|1
expr_stmt|;
name|no_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GNU traditional CPP version %s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'U'
case|:
case|case
literal|'A'
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"macro name missing after -%c option"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'D'
condition|)
name|pend
index|[
name|i
index|]
operator|.
name|type
operator|=
name|PD_DEFINE
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'U'
condition|)
name|pend
index|[
name|i
index|]
operator|.
name|type
operator|=
name|PD_UNDEF
expr_stmt|;
else|else
name|pend
index|[
name|i
index|]
operator|.
name|type
operator|=
name|PD_ASSERTION
expr_stmt|;
name|pend
index|[
name|i
index|]
operator|.
name|arg
operator|=
name|p
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
name|put_out_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pedantic"
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"-pedantic and -traditional are mutually exclusive"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-trigraphs"
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"-trigraphs and -traditional are mutually exclusive"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|no_line_commands
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Add directory to path for includes.  */
name|add_include
label|:
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
if|if
condition|(
operator|!
name|ignore_srcdir
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
literal|"-"
argument_list|)
condition|)
name|ignore_srcdir
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
if|if
condition|(
name|include
operator|==
literal|0
condition|)
name|include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'I'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"directory name missing after -I option"
argument_list|)
expr_stmt|;
else|else
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore_srcdir
operator|&&
name|first_bracket_include
operator|==
literal|0
condition|)
name|first_bracket_include
operator|=
name|dirtmp
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* -nostdinc causes no default include directories. 	   You must specify all include-file directories with -I.  */
name|no_standard_includes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* JF handle '-' as file name meaning stdin or stdout */
if|if
condition|(
name|in_fname
operator|==
name|NULL
condition|)
block|{
name|in_fname
operator|=
literal|""
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|out_fname
operator|==
name|NULL
condition|)
block|{
name|out_fname
operator|=
literal|""
expr_stmt|;
break|break;
block|}
comment|/* else fall through into error */
default|default:
name|fatal
argument_list|(
literal|"invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|init_dependency_output
argument_list|()
expr_stmt|;
comment|/* After checking the environment variables, check if -M or -MM has      not been specified, but other -M options have.  */
if|if
condition|(
name|print_deps
operator|==
literal|0
operator|&&
operator|(
name|deps_missing_files
operator|||
name|deps_file
operator|||
name|print_deps_phony_targets
operator|)
condition|)
name|fatal
argument_list|(
literal|"you must additionally specify either -M or -MM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_label_prefix
operator|==
literal|0
condition|)
name|user_label_prefix
operator|=
name|USER_LABEL_PREFIX
expr_stmt|;
if|if
condition|(
name|print_deps
condition|)
block|{
comment|/* Set the default target (if there is none already), and 	 the dependency on the main file.  */
name|deps_add_default_target
argument_list|(
name|deps
argument_list|,
name|in_fname
argument_list|)
expr_stmt|;
name|deps_add_dep
argument_list|(
name|deps
argument_list|,
name|in_fname
argument_list|)
expr_stmt|;
block|}
comment|/* Install __LINE__, etc.  Must follow option processing.  */
name|initialize_builtins
argument_list|()
expr_stmt|;
comment|/* Do defines specified with -D and undefines specified with -U.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pend
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PD_DEFINE
condition|)
name|make_definition
argument_list|(
name|pend
index|[
name|i
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pend
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PD_UNDEF
condition|)
name|make_undef
argument_list|(
name|pend
index|[
name|i
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pend
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PD_ASSERTION
condition|)
name|make_assertion
argument_list|(
name|pend
index|[
name|i
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
comment|/* Unless -fnostdinc,      tack on the standard include file dirs to the specified list */
if|if
condition|(
operator|!
name|no_standard_includes
condition|)
block|{
specifier|const
name|struct
name|default_include
modifier|*
name|di
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|old_last_include
init|=
name|last_include
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
for|for
control|(
name|di
operator|=
name|cpp_include_defaults
init|;
name|di
operator|->
name|fname
condition|;
name|di
operator|++
control|)
block|{
if|if
condition|(
name|di
operator|->
name|cplusplus
condition|)
continue|continue;
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
if|if
condition|(
name|include
operator|==
literal|0
condition|)
name|include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
name|dirtmp
operator|->
name|fname
operator|=
name|di
operator|->
name|fname
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ignore_srcdir
operator|&&
name|first_bracket_include
operator|==
literal|0
condition|)
name|first_bracket_include
operator|=
name|old_last_include
operator|->
name|next
expr_stmt|;
block|}
comment|/* Initialize output buffer */
name|outbuf
operator|.
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|OUTBUF_SIZE
argument_list|)
expr_stmt|;
name|outbuf
operator|.
name|bufp
operator|=
name|outbuf
operator|.
name|buf
expr_stmt|;
name|outbuf
operator|.
name|length
operator|=
name|OUTBUF_SIZE
expr_stmt|;
comment|/* Scan the -i files before the main input.      Much like #including them, but with no_output set      so that only their macro definitions matter.  */
name|no_output
operator|++
expr_stmt|;
name|indepth
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pend
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PD_FILE
condition|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|pend
index|[
name|i
index|]
operator|.
name|arg
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|pend
index|[
name|i
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
return|return
name|FATAL_EXIT_CODE
return|;
block|}
comment|/* For -M, add this file to the dependencies.  */
if|if
condition|(
name|print_deps
condition|)
name|deps_add_dep
argument_list|(
name|deps
argument_list|,
name|pend
index|[
name|i
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
name|finclude
argument_list|(
name|fd
argument_list|,
name|pend
index|[
name|i
index|]
operator|.
name|arg
argument_list|,
literal|0
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
block|}
name|indepth
operator|--
expr_stmt|;
name|no_output
operator|--
expr_stmt|;
comment|/* Pending directives no longer needed.  */
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|pend
argument_list|)
expr_stmt|;
comment|/* Create an input stack level for the main input file      and copy the entire contents of the file into it.  */
name|fp
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
comment|/* JF check for stdin */
if|if
condition|(
name|in_fname
operator|==
name|NULL
operator|||
operator|*
name|in_fname
operator|==
literal|0
condition|)
block|{
name|in_fname
operator|=
literal|""
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|in_fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|sys_error
goto|;
if|if
condition|(
name|file_size_and_mode
argument_list|(
name|f
argument_list|,
operator|&
name|st_mode
argument_list|,
operator|&
name|st_size
argument_list|)
condition|)
goto|goto
name|sys_error
goto|;
name|fp
operator|->
name|fname
operator|=
name|in_fname
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
comment|/* JF all this is mine about reading pipes and ttys */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Read input from a file that is not a normal disk file.        We cannot preallocate a buffer with the correct size,        so we must read in the file a piece at the time and make it bigger.  */
name|int
name|size
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|U_CHAR
modifier|*
name|bufp
decl_stmt|;
name|bsize
operator|=
literal|2000
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cnt
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|bufp
argument_list|,
name|bsize
operator|-
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
goto|goto
name|sys_error
goto|;
comment|/* error! */
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
break|break;
comment|/* End of file */
name|size
operator|+=
name|cnt
expr_stmt|;
name|bufp
operator|+=
name|cnt
expr_stmt|;
if|if
condition|(
name|bsize
operator|==
name|size
condition|)
block|{
comment|/* Buffer is full! */
name|bsize
operator|*=
literal|2
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|fp
operator|->
name|buf
argument_list|,
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|fp
operator|->
name|buf
operator|+
name|size
expr_stmt|;
comment|/* May have moved */
block|}
block|}
name|fp
operator|->
name|length
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* Read a file whose size we can determine in advance.        For the sake of VMS, st_size is just an upper bound.  */
name|long
name|i
decl_stmt|;
name|fp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|st_size
operator|+
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|st_size
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
operator|+
name|fp
operator|->
name|length
argument_list|,
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
goto|goto
name|sys_error
goto|;
block|}
name|fp
operator|->
name|length
operator|+=
name|i
expr_stmt|;
name|st_size
operator|-=
name|i
expr_stmt|;
block|}
block|}
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
name|fp
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
comment|/* Make sure data ends with a newline.  And put a null after it.  */
if|if
condition|(
name|fp
operator|->
name|length
operator|>
literal|0
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now that we know the input file is valid, open the output.  */
if|if
condition|(
operator|!
name|out_fname
operator|||
operator|!
name|strcmp
argument_list|(
name|out_fname
argument_list|,
literal|""
argument_list|)
condition|)
name|out_fname
operator|=
literal|"stdout"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|out_fname
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
condition|)
name|pfatal_with_name
argument_list|(
name|out_fname
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
comment|/* Scan the input, processing macros and directives.  */
name|rescan
argument_list|(
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now we have processed the entire input      Write whichever kind of output has been requested.  */
if|if
condition|(
name|dump_macros
condition|)
name|dump_all_macros
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|inhibit_output
condition|)
if|if
condition|(
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|outbuf
operator|.
name|buf
argument_list|,
name|outbuf
operator|.
name|bufp
operator|-
name|outbuf
operator|.
name|buf
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"I/O error on output"
argument_list|)
expr_stmt|;
comment|/* Don't write the deps file if preprocessing has failed.  */
if|if
condition|(
name|print_deps
operator|&&
name|errors
operator|==
literal|0
condition|)
name|output_deps
argument_list|()
expr_stmt|;
comment|/* Destruct the deps object.  */
name|deps_free
argument_list|(
name|deps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"I/O error on output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
name|sys_error
label|:
name|pfatal_with_name
argument_list|(
name|in_fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up dependency-file output.  */
end_comment

begin_function
specifier|static
name|void
name|init_dependency_output
parameter_list|()
block|{
name|char
modifier|*
name|spec
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|output_file
decl_stmt|;
comment|/* Either of two environment variables can specify output of deps.      Its value is either "OUTPUT_FILE" or "OUTPUT_FILE DEPS_TARGET",      where OUTPUT_FILE is the file to write deps info to      and DEPS_TARGET is the target to mention in the deps.  */
if|if
condition|(
name|print_deps
operator|==
literal|0
condition|)
block|{
name|spec
operator|=
name|getenv
argument_list|(
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
name|print_deps
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|spec
operator|=
name|getenv
argument_list|(
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
name|print_deps
operator|=
literal|2
expr_stmt|;
else|else
return|return;
block|}
comment|/* Find the space before the DEPS_TARGET, if there is one.  */
name|s
operator|=
name|strchr
argument_list|(
name|spec
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
comment|/* Let the caller perform MAKE quoting.  */
name|deps_add_target
argument_list|(
name|deps
argument_list|,
name|s
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_file
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|s
operator|-
name|spec
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|output_file
argument_list|,
name|spec
argument_list|,
name|s
operator|-
name|spec
argument_list|)
expr_stmt|;
name|output_file
index|[
name|s
operator|-
name|spec
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|output_file
operator|=
name|spec
expr_stmt|;
comment|/* Command line overrides environment variables.  */
if|if
condition|(
name|deps_file
operator|==
literal|0
condition|)
name|deps_file
operator|=
name|output_file
expr_stmt|;
name|deps_append
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If dependencies go to standard output, or -MG is used, we should      suppress output.  The user may be requesting other stuff to      stdout, with -dM, -v etc.  We let them shoot themselves in the      foot.  */
if|if
condition|(
name|deps_file
operator|==
literal|0
operator|||
name|deps_missing_files
condition|)
name|inhibit_output
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use mkdeps.c to output dependency information.  */
end_comment

begin_function
specifier|static
name|void
name|output_deps
parameter_list|()
block|{
comment|/* Stream on which to print the dependency information.  */
name|FILE
modifier|*
name|deps_stream
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|deps_mode
init|=
name|deps_append
condition|?
literal|"a"
else|:
literal|"w"
decl_stmt|;
if|if
condition|(
name|deps_file
operator|==
literal|0
condition|)
name|deps_stream
operator|=
name|stdout
expr_stmt|;
else|else
block|{
name|deps_stream
operator|=
name|fopen
argument_list|(
name|deps_file
argument_list|,
name|deps_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|deps_stream
operator|==
literal|0
condition|)
block|{
name|error_from_errno
argument_list|(
name|deps_file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|deps_write
argument_list|(
name|deps
argument_list|,
name|deps_stream
argument_list|,
literal|72
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_deps_phony_targets
condition|)
name|deps_phony_targets
argument_list|(
name|deps
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
comment|/* Don't close stdout.  */
if|if
condition|(
name|deps_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|deps_stream
argument_list|)
operator|||
name|fclose
argument_list|(
name|deps_stream
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"I/O error on output"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Move all backslash-newline pairs out of embarrassing places.    Exchange all such pairs following BP    with any potentially-embarrasing characters that follow them.    Potentially-embarrassing characters are / and *    (because a backslash-newline inside a comment delimiter    would cause it not to be recognized).  */
end_comment

begin_function
specifier|static
name|void
name|newline_fix
parameter_list|(
name|bp
parameter_list|)
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|bp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* First count the backslash-newline pairs here.  */
while|while
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\\'
operator|&&
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|count
operator|++
expr_stmt|;
name|p
operator|=
name|bp
operator|+
name|count
operator|*
literal|2
expr_stmt|;
comment|/* Exit if what follows the backslash-newlines is not embarrassing.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|||
operator|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|'*'
operator|)
condition|)
return|return;
comment|/* Copy all potentially embarrassing characters      that follow the backslash-newline pairs      down to where the pairs originally started.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Now write the same number of pairs after the embarrassing chars.  */
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like newline_fix but for use within a directive-name.    Move any backslash-newlines up past any following symbol constituents.  */
end_comment

begin_function
specifier|static
name|void
name|name_newline_fix
parameter_list|(
name|bp
parameter_list|)
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|bp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* First count the backslash-newline pairs here.  */
while|while
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\\'
operator|&&
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|count
operator|++
expr_stmt|;
name|p
operator|=
name|bp
operator|+
name|count
operator|*
literal|2
expr_stmt|;
comment|/* What follows the backslash-newlines is not embarrassing.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|||
operator|!
name|is_idchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return;
comment|/* Copy all potentially embarrassing characters      that follow the backslash-newline pairs      down to where the pairs originally started.  */
while|while
condition|(
name|is_idchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Now write the same number of pairs after the embarrassing chars.  */
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * The main loop of the program.  *  * Read characters from the input stack, transferring them to the  * output buffer OP.  *  * Macros are expanded and push levels on the input stack.  * At the end of such a level it is popped off and we keep reading.  * At the end of any other kind of level, we return.  * #-directives are handled, except within macros.  *  * If OUTPUT_MARKS is nonzero, keep Newline markers found in the input  * and insert them when appropriate.  This is set while scanning macro  * arguments before substitution.  It is zero when scanning for final output.  *   There are three types of Newline markers:  *   * Newline -  follows a macro name that was not expanded  *     because it appeared inside an expansion of the same macro.  *     This marker prevents future expansion of that identifier.  *     When the input is rescanned into the final output, these are deleted.  *     These are also deleted by ## concatenation.  *   * Newline Space (or Newline and any other whitespace character)  *     stands for a place that tokens must be separated or whitespace  *     is otherwise desirable, but where the ANSI standard specifies there  *     is no whitespace.  This marker turns into a Space (or whichever other  *     whitespace char appears in the marker) in the final output,  *     but it turns into nothing in an argument that is stringified with #.  *     Such stringified arguments are the only place where the ANSI standard  *     specifies with precision that whitespace may not appear.  *  * During this function, IP->bufp is kept cached in IBP for speed of access.  * Likewise, OP->bufp is kept in OBP.  Before calling a subroutine  * IBP, IP and OBP must be copied back to memory.  IP and IBP are  * copied back with the RECACHE macro.  OBP must be copied back from OP->bufp  * explicitly, and before RECACHE, since RECACHE uses OBP.  */
end_comment

begin_function
specifier|static
name|void
name|rescan
parameter_list|(
name|op
parameter_list|,
name|output_marks
parameter_list|)
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
name|int
name|output_marks
decl_stmt|;
block|{
comment|/* Character being scanned in main loop.  */
name|U_CHAR
name|c
decl_stmt|;
comment|/* Length of pending accumulated identifier.  */
name|int
name|ident_length
init|=
literal|0
decl_stmt|;
comment|/* Hash code of pending accumulated identifier.  */
name|int
name|hash
init|=
literal|0
decl_stmt|;
comment|/* Current input level (&instack[indepth]).  */
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
comment|/* Pointer for scanning input.  */
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
comment|/* Pointer to end of input.  End of scan is controlled by LIMIT.  */
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
comment|/* Pointer for storing output.  */
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
comment|/* REDO_CHAR is nonzero if we are processing an identifier      after backing up over the terminating character.      Sometimes we process an identifier without backing up over      the terminating character, if the terminating character      is not special.  Backing up is done so that the terminating character      will be dispatched on again once the identifier is dealt with.  */
name|int
name|redo_char
init|=
literal|0
decl_stmt|;
comment|/* 1 if within an identifier inside of which a concatenation      marker (Newline -) has been seen.  */
name|int
name|concatenated
init|=
literal|0
decl_stmt|;
comment|/* While scanning a comment or a string constant,      this records the line it started on, for error messages.  */
name|int
name|start_line
decl_stmt|;
comment|/* Record position of last `real' newline.  */
name|U_CHAR
modifier|*
name|beg_of_line
decl_stmt|;
comment|/* This has to be a global bacause of RECACHE.  */
name|U_CHAR
modifier|*
name|obufp_before_macroname
init|=
name|NULL
decl_stmt|;
comment|/* Pop the innermost input stack level, assuming it is a macro expansion.  */
define|#
directive|define
name|POPMACRO
define|\
value|do { ip->macro->type = T_MACRO;		\      if (ip->free_ptr) free (ip->free_ptr);	\      --indepth; } while (0)
comment|/* Reload `rescan's local variables that describe the current    level of the input stack.  */
define|#
directive|define
name|RECACHE
define|\
value|do { ip =&instack[indepth];		\      ibp = ip->bufp;			\      limit = ip->buf + ip->length;	\      op->bufp = obp;			\      check_expand (op, limit - ibp);	\      beg_of_line = 0;			\      obufp_before_macroname += op->bufp - obp;  \      obp = op->bufp; } while (0)
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
operator|!=
literal|0
condition|)
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
comment|/* Our caller must always put a null after the end of      the input at each input stack level.  */
if|if
condition|(
operator|*
name|limit
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
break|break;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
comment|/* Always merge lines ending with backslash-newline, 	   even in middle of identifier.  */
operator|++
name|ibp
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|--
name|obp
expr_stmt|;
comment|/* remove backslash from obuf */
break|break;
block|}
comment|/* Otherwise, backslash suppresses specialness of following char, 	 so copy it here to prevent the switch from seeing it. 	 But first get any pending identifier processed.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* If this is expanding a macro definition, don't recognize 	 preprocessor directives.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
comment|/* # keyword: a # must be the first char on the line */
if|if
condition|(
name|beg_of_line
operator|==
literal|0
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|beg_of_line
operator|+
literal|1
operator|!=
name|ibp
condition|)
goto|goto
name|randomchar
goto|;
comment|/* This # can start a directive.  */
operator|--
name|obp
expr_stmt|;
comment|/* Don't copy the '#' */
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
if|if
condition|(
operator|!
name|handle_directive
argument_list|(
name|ip
argument_list|,
name|op
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Not a known directive: treat it as ordinary text. 	   IP, OP, IBP, etc. have not been changed.  */
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
condition|)
block|{
comment|/* If not generating expanded output, 	     what we do with ordinary text is skip it. 	     Discard everything until next # directive.  */
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
break|break;
block|}
operator|++
name|obp
expr_stmt|;
comment|/* Copy the '#' after all */
goto|goto
name|randomchar
goto|;
block|}
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A # directive has been successfully processed.  */
comment|/* If not generating expanded output, ignore everything until 	 next # directive.  */
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
condition|)
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
comment|/* skip quoted string */
case|case
literal|'\''
case|:
comment|/* A single quoted string is treated like a double -- some 	 programs (e.g., troff) are perverse this way */
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
name|start_line
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* Skip ahead to a matching quote.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
comment|/* try harder: this string crosses a macro expansion boundary */
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
expr_stmt|;
switch|switch
condition|(
operator|*
name|ibp
operator|++
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
comment|/* Traditionally, end of line ends a string constant with no error. 	     So exit the loop and record the new line.  */
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
goto|goto
name|while2end
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
break|break;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
comment|/* Backslash newline is replaced by nothing at all, 	       but keep the line counts correct.  */
operator|--
name|obp
expr_stmt|;
operator|++
name|ibp
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
else|else
block|{
comment|/* ANSI stupidly requires that in \\ the second \ 	       is *not* prevented from combining with a newline.  */
while|while
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ibp
operator|+=
literal|2
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
if|if
condition|(
name|ibp
index|[
operator|-
literal|1
index|]
operator|==
name|c
condition|)
goto|goto
name|while2end
goto|;
break|break;
block|}
block|}
name|while2end
label|:
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
comment|/* Don't look for comments inside a macro definition.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
goto|goto
name|randomchar
goto|;
comment|/* A comment constitutes white space, so it can terminate an identifier. 	 Process the identifier, if any.  */
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
if|if
condition|(
operator|*
name|ibp
operator|!=
literal|'*'
condition|)
goto|goto
name|randomchar
goto|;
comment|/* We have a comment.  Skip it, optionally copying it to output.  */
name|start_line
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|ibp
expr_stmt|;
comment|/* Skip the star. */
comment|/* In K+R C, a comment is equivalent to nothing.  Note that we 	  already output the slash; we might not want it.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
name|obp
operator|--
expr_stmt|;
else|else
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|{
name|U_CHAR
modifier|*
name|before_bp
init|=
name|ibp
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
switch|switch
condition|(
operator|*
name|ibp
operator|++
condition|)
block|{
case|case
literal|'/'
case|:
if|if
condition|(
name|warn_comments
operator|&&
name|ibp
operator|<
name|limit
operator|&&
operator|*
name|ibp
operator|==
literal|'*'
condition|)
name|warning
argument_list|(
literal|"`/*' within comment"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
operator|>=
name|limit
operator|||
operator|*
name|ibp
operator|==
literal|'/'
condition|)
goto|goto
name|comment_end
goto|;
break|break;
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* Copy the newline into the output buffer, in order to 	       avoid the pain of a #line every time a multiline comment 	       is seen.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
block|}
name|comment_end
label|:
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
else|else
block|{
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|put_out_comments
condition|)
block|{
name|memcpy
argument_list|(
name|obp
argument_list|,
name|before_bp
argument_list|,
name|ibp
operator|-
name|before_bp
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|ibp
operator|-
name|before_bp
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* If digit is not part of identifier, it starts a number, 	 which means that following letters are not an identifier. 	 "0x5" does not refer to an identifier "x5". 	 So copy all alphanumerics that follow without accumulating 	 as an identifier.  Periods also, for sake of "3.e7".  */
if|if
condition|(
name|ident_length
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
while|while
condition|(
name|ibp
operator|<
name|limit
operator|&&
name|ibp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|ibp
operator|+=
literal|2
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISIDNUM
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'.'
condition|)
block|{
operator|--
name|ibp
expr_stmt|;
break|break;
block|}
operator|*
name|obp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* A sign can be part of a preprocessing number 	     if it follows an e.  */
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
while|while
condition|(
name|ibp
operator|<
name|limit
operator|&&
name|ibp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|ibp
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ibp
operator|<
name|limit
operator|&&
operator|(
operator|*
name|ibp
operator|==
literal|'+'
operator|||
operator|*
name|ibp
operator|==
literal|'-'
operator|)
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
comment|/* Traditional C does not let the token go past the sign.  */
break|break;
block|}
block|}
block|}
break|break;
block|}
comment|/* fall through */
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
name|ident_length
operator|++
expr_stmt|;
comment|/* Compute step of hash function, to avoid a proc call on every token */
name|hash
operator|=
name|HASHSTEP
argument_list|(
name|hash
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
comment|/* If reprocessing a macro expansion, newline is a special marker.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
comment|/* Newline White is a "funny space" to separate tokens that are 	   supposed to be separate but without space between. 	   Here White means any horizontal whitespace character. 	   Newline - marks a recursive macro use that is not 	   supposed to be expandable.  */
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'-'
condition|)
block|{
comment|/* Newline - inhibits expansion of preceding token. 	     If expanding a macro arg, we keep the newline -. 	     In final output, it is deleted.  */
if|if
condition|(
operator|!
name|concatenated
condition|)
block|{
name|ident_length
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
name|obp
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* If expanding a macro arg, keep the newline -.  */
operator|*
name|obp
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_space
argument_list|(
operator|*
name|ibp
argument_list|)
condition|)
block|{
comment|/* Newline Space does not prevent expansion of preceding token 	     so expand the preceding token and then come back.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
comment|/* If generating final output, newline space makes a space.  */
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
name|obp
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
comment|/* And Newline Newline makes a newline, so count it.  */
if|if
condition|(
name|obp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* If expanding a macro arg, keep the newline space. 	       If the arg gets stringified, newline space makes nothing.  */
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Newline followed by something random?  */
break|break;
block|}
comment|/* If there is a pending identifier, handle it and come back here.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
comment|/* Update the line counts and output a #line if necessary.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|lineno
operator|!=
name|op
operator|->
name|lineno
condition|)
block|{
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
block|}
break|break;
comment|/* Come here either after (1) a null character that is part of the input 	 or (2) at the end of the input, because there is a null there.  */
case|case
literal|0
case|:
if|if
condition|(
name|ibp
operator|<=
name|limit
condition|)
comment|/* Our input really contains a null character.  */
goto|goto
name|randomchar
goto|;
comment|/* At end of a macro-expansion level, pop it and read next level.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|--
expr_stmt|;
comment|/* If we have an identifier that ends here, process it now, so 	   we get the right error for recursion.  */
if|if
condition|(
name|ident_length
operator|&&
operator|!
name|is_idchar
argument_list|(
operator|*
name|instack
index|[
name|indepth
operator|-
literal|1
index|]
operator|.
name|bufp
argument_list|)
condition|)
block|{
name|redo_char
operator|=
literal|1
expr_stmt|;
goto|goto
name|randomchar
goto|;
block|}
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
break|break;
block|}
comment|/* If we don't have a pending identifier, 	 return at end of input.  */
if|if
condition|(
name|ident_length
operator|==
literal|0
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|--
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
goto|goto
name|ending
goto|;
block|}
comment|/* If we do have a pending identifier, just consider this null 	 a special character and arrange to dispatch on it again. 	 The second time, IDENT_LENGTH will be zero so we will return.  */
comment|/* Fall through */
name|specialchar
label|:
comment|/* Handle the case of a character such as /, ', " or null 	 seen following an identifier.  Back over it so that 	 after the identifier is processed the special char 	 will be dispatched on again.  */
name|ibp
operator|--
expr_stmt|;
name|obp
operator|--
expr_stmt|;
name|redo_char
operator|=
literal|1
expr_stmt|;
default|default:
name|randomchar
label|:
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
comment|/* We have just seen an identifier end.  If it's a macro, expand it.  	   IDENT_LENGTH is the length of the identifier 	   and HASH is its hash code.  	   The identifier has already been copied to the output, 	   so if it is a macro we must remove it.  	   If REDO_CHAR is 0, the char that terminated the identifier 	   has been skipped in the output and the input. 	   OBP-IDENT_LENGTH-1 points to the identifier. 	   If the identifier is a macro, we must back over the terminator.  	   If REDO_CHAR is 1, the terminating char has already been 	   backed over.  OBP-IDENT_LENGTH points to the identifier.  */
for|for
control|(
name|hp
operator|=
name|hashtab
index|[
name|MAKE_POS
argument_list|(
name|hash
argument_list|)
operator|%
name|HASHSIZE
index|]
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|length
operator|==
name|ident_length
condition|)
block|{
comment|/* obufp_before_macroname is used only in this block,                but it has to be global because of RECACHE.  */
name|int
name|op_lineno_before_macroname
decl_stmt|;
name|int
name|i
init|=
name|ident_length
decl_stmt|;
name|U_CHAR
modifier|*
name|p
init|=
name|hp
operator|->
name|name
decl_stmt|;
name|U_CHAR
modifier|*
name|q
init|=
name|obp
operator|-
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|redo_char
condition|)
name|q
operator|--
expr_stmt|;
do|do
block|{
comment|/* All this to avoid a strncmp () */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|q
operator|++
condition|)
goto|goto
name|hashcollision
goto|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
comment|/* We found a use of a macro name. 	       see if the context shows it is a macro call.  */
comment|/* Back up over terminating character if not already done.  */
if|if
condition|(
operator|!
name|redo_char
condition|)
block|{
name|ibp
operator|--
expr_stmt|;
name|obp
operator|--
expr_stmt|;
block|}
name|obufp_before_macroname
operator|=
name|obp
operator|-
name|ident_length
expr_stmt|;
name|op_lineno_before_macroname
operator|=
name|op
operator|->
name|lineno
expr_stmt|;
comment|/* If macro wants an arglist, verify that a '(' follows. 	       first skip all whitespace, copying it to the output 	       after the macro name.  Then, if there is no '(', 	       decide this is not a macro call and leave things that way.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|&&
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Scan forward over whitespace, copying it to the output.  */
if|if
condition|(
name|ibp
operator|==
name|limit
operator|&&
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
block|}
comment|/* A comment: copy it unchanged or discard it.  */
elseif|else
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'/'
operator|&&
name|ibp
operator|+
literal|1
operator|!=
name|limit
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|put_out_comments
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
name|ibp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|ibp
operator|+
literal|1
operator|!=
name|limit
operator|&&
operator|!
operator|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
comment|/* We need not worry about newline-marks, 			 since they are never found in comments.  */
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
comment|/* Newline in a file.  Count it.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
if|if
condition|(
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
else|else
name|ibp
operator|++
expr_stmt|;
block|}
name|ibp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|put_out_comments
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_space
argument_list|(
operator|*
name|ibp
argument_list|)
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|ibp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|macro
operator|==
literal|0
condition|)
block|{
comment|/* Newline in a file.  Count it.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
comment|/* A newline mark, and we don't want marks 			   in the output.  If it is newline-hyphen, 			   discard it entirely.  Otherwise, it is 			   newline-whitechar, so keep the whitechar.  */
name|obp
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'-'
condition|)
name|ibp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A newline mark; copy both chars to the output.  */
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|ibp
operator|!=
literal|'('
condition|)
break|break;
block|}
comment|/* This is now known to be a macro call. 	       Discard the macro name from the output, 	       along with any following whitespace just copied.  */
name|obp
operator|=
name|obufp_before_macroname
expr_stmt|;
name|op
operator|->
name|lineno
operator|=
name|op_lineno_before_macroname
expr_stmt|;
comment|/* Expand the macro, reading arguments as needed, 	       and push the expansion on the input stack.  */
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|macroexpand
argument_list|(
name|hp
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Reexamine input stack, since macroexpand has pushed 	       a new level on it.  */
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
break|break;
block|}
name|hashcollision
label|:
empty_stmt|;
block|}
comment|/* End hash-table-search loop */
name|ident_length
operator|=
name|hash
operator|=
literal|0
expr_stmt|;
comment|/* Stop collecting identifier */
name|redo_char
operator|=
literal|0
expr_stmt|;
name|concatenated
operator|=
literal|0
expr_stmt|;
block|}
comment|/* End if (ident_length> 0) */
block|}
comment|/* End switch */
block|}
comment|/* End per-char loop */
comment|/* Come here to return -- but first give an error message      if there was an unterminated successful conditional.  */
name|ending
label|:
if|if
condition|(
name|if_stack
operator|!=
name|ip
operator|->
name|if_stack
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
switch|switch
condition|(
name|if_stack
operator|->
name|type
condition|)
block|{
case|case
name|T_IF
case|:
name|str
operator|=
literal|"if"
expr_stmt|;
break|break;
case|case
name|T_IFDEF
case|:
name|str
operator|=
literal|"ifdef"
expr_stmt|;
break|break;
case|case
name|T_IFNDEF
case|:
name|str
operator|=
literal|"ifndef"
expr_stmt|;
break|break;
case|case
name|T_ELSE
case|:
name|str
operator|=
literal|"else"
expr_stmt|;
break|break;
case|case
name|T_ELIF
case|:
name|str
operator|=
literal|"elif"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|if_stack
operator|->
name|lineno
argument_list|)
argument_list|,
literal|"unterminated #%s conditional"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|=
name|ip
operator|->
name|if_stack
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Rescan a string into a temporary buffer and return the result  * as a FILE_BUF.  Note this function returns a struct, not a pointer.  *  * OUTPUT_MARKS nonzero means keep Newline markers found in the input  * and insert such markers when appropriate.  See `rescan' for details.  * OUTPUT_MARKS is 1 for macroexpanding a macro argument separately  * before substitution; it is 0 for other uses.  */
end_comment

begin_function
specifier|static
name|FILE_BUF
name|expand_to_temp_buffer
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|output_marks
parameter_list|)
specifier|const
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|output_marks
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|FILE_BUF
name|obuf
decl_stmt|;
name|int
name|length
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|buf1
decl_stmt|;
name|int
name|odepth
init|=
name|indepth
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Set up the input on the input stack.  */
name|buf1
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
specifier|const
name|U_CHAR
modifier|*
name|p1
init|=
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|p2
init|=
name|buf1
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|limit
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
name|buf1
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Set up to receive the output.  */
name|obuf
operator|.
name|length
operator|=
name|length
operator|*
literal|2
operator|+
literal|100
expr_stmt|;
comment|/* Usually enough.  Why be stingy?  */
name|obuf
operator|.
name|bufp
operator|=
name|obuf
operator|.
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|obuf
operator|.
name|length
argument_list|)
expr_stmt|;
name|obuf
operator|.
name|fname
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|macro
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|CHECK_DEPTH
argument_list|(
argument|{return obuf;}
argument_list|)
empty_stmt|;
operator|++
name|indepth
expr_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|buf1
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
name|obuf
operator|.
name|lineno
operator|=
literal|1
expr_stmt|;
comment|/* Scan the input, create the output.  */
name|rescan
argument_list|(
operator|&
name|obuf
argument_list|,
name|output_marks
argument_list|)
expr_stmt|;
comment|/* Pop input stack to original state.  */
operator|--
name|indepth
expr_stmt|;
if|if
condition|(
name|indepth
operator|!=
name|odepth
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Record the output.  */
name|obuf
operator|.
name|length
operator|=
name|obuf
operator|.
name|bufp
operator|-
name|obuf
operator|.
name|buf
expr_stmt|;
return|return
name|obuf
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Process a # directive.  Expects IP->bufp to point to the '#', as in  * `#define foo bar'.  Passes to the command handler  * (do_define, do_include, etc.): the addresses of the 1st and  * last chars of the command (starting immediately after the #  * keyword), plus op and the keyword table pointer.  If the command  * contains comments it is copied into a temporary buffer sans comments  * and the temporary buffer is passed to the command handler instead.  * Likewise for backslash-newlines.  *  * Returns nonzero if this was a known # directive.  * Otherwise, returns zero, without advancing the input pointer.  */
end_comment

begin_function
specifier|static
name|int
name|handle_directive
parameter_list|(
name|ip
parameter_list|,
name|op
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
decl|*
name|op
decl_stmt|;
end_function

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|const
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|int
name|ident_length
decl_stmt|;
name|U_CHAR
modifier|*
name|resume_p
decl_stmt|;
comment|/* Nonzero means we must copy the entire command      to get rid of comments or backslash-newlines.  */
name|int
name|copy_command
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|ident
decl_stmt|,
modifier|*
name|after_ident
decl_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* Skip whitespace and \-newline.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_nvspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
operator|(
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
operator|,
name|bp
index|[
literal|1
index|]
operator|)
operator|==
literal|'*'
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Now find end of directive name.      If we encounter a backslash-newline, exchange it with any following      symbol-constituents so that we end up with a contiguous name.  */
name|cp
operator|=
name|bp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_idchar
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|name_newline_fix
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_idchar
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
else|else
break|break;
block|}
block|}
name|ident_length
operator|=
name|cp
operator|-
name|bp
expr_stmt|;
name|ident
operator|=
name|bp
expr_stmt|;
name|after_ident
operator|=
name|cp
expr_stmt|;
comment|/* A line of just `#' becomes blank.  */
if|if
condition|(
name|ident_length
operator|==
literal|0
operator|&&
operator|*
name|after_ident
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|after_ident
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*    * Decode the keyword and call the appropriate expansion    * routine, after moving the input pointer up to the next line.    */
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|length
operator|>
literal|0
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|length
operator|==
name|ident_length
operator|&&
operator|!
name|strncmp
argument_list|(
name|kt
operator|->
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ident
argument_list|,
name|ident_length
argument_list|)
condition|)
block|{
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
name|int
name|unterminated
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means do not delete comments within the directive. 	 #define needs this to detect traditional token paste.  */
name|int
name|keep_comments
init|=
name|kt
operator|->
name|type
operator|==
name|T_DEFINE
decl_stmt|;
comment|/* Find the end of this command (first newline not backslashed 	 and not in a string or comment). 	 Set COPY_COMMAND if the command must be copied 	 (it contains a backslash-newline or a comment).  */
name|buf
operator|=
name|bp
operator|=
name|after_ident
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
name|U_CHAR
name|c
init|=
operator|*
name|bp
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|copy_command
operator|=
literal|1
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
name|bp
operator|=
name|skip_quoted_string
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
name|limit
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|copy_command
argument_list|,
operator|&
name|unterminated
argument_list|)
expr_stmt|;
if|if
condition|(
name|unterminated
condition|)
block|{
comment|/* Traditional preprocessing permits unterminated strings.  */
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
break|break;
comment|/*<...> is special for #include.  */
case|case
literal|'<'
case|:
if|if
condition|(
name|kt
operator|->
name|type
operator|!=
name|T_INCLUDE
condition|)
break|break;
while|while
condition|(
operator|*
name|bp
operator|&&
operator|*
name|bp
operator|!=
literal|'>'
condition|)
name|bp
operator|++
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
condition|)
block|{
name|U_CHAR
modifier|*
name|obp
init|=
name|bp
operator|-
literal|1
decl_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* No need to copy the command because of a comment at the end; 	       just don't include the comment in the directive.  */
if|if
condition|(
name|bp
operator|==
name|limit
operator|||
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|=
name|obp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
comment|/* Don't remove the comments if this is #define.  */
if|if
condition|(
operator|!
name|keep_comments
condition|)
name|copy_command
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
operator|--
name|bp
expr_stmt|;
comment|/* Point to the newline */
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|endloop1
label|:
name|resume_p
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* BP is the end of the directive. 	 RESUME_P is the next interesting data after the directive. 	 A comment may come between.  */
if|if
condition|(
name|copy_command
condition|)
block|{
name|U_CHAR
modifier|*
name|xp
init|=
name|buf
decl_stmt|;
comment|/* Need to copy entire command into temp buffer before dispatching */
name|cp
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|bp
operator|-
name|buf
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* room for cmd plus 						  some slop */
name|buf
operator|=
name|cp
expr_stmt|;
comment|/* Copy to the new buffer, deleting comments 	   and backslash-newlines (and whitespace surrounding the latter).  */
while|while
condition|(
name|xp
operator|<
name|bp
condition|)
block|{
name|U_CHAR
name|c
init|=
operator|*
name|xp
operator|++
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
break|break;
comment|/*<...> is special for #include.  */
case|case
literal|'<'
case|:
if|if
condition|(
name|kt
operator|->
name|type
operator|!=
name|T_INCLUDE
condition|)
break|break;
while|while
condition|(
name|xp
operator|<
name|bp
operator|&&
name|c
operator|!=
literal|'>'
condition|)
block|{
name|c
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|xp
operator|<
name|bp
operator|&&
operator|*
name|xp
operator|==
literal|'\n'
condition|)
name|xp
operator|++
operator|,
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
else|else
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|xp
operator|==
literal|'\n'
condition|)
block|{
name|xp
operator|++
expr_stmt|;
name|cp
operator|--
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|buf
operator|&&
name|is_space
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|cp
operator|!=
name|buf
operator|&&
name|is_space
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cp
operator|--
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_nvspace
argument_list|(
operator|*
name|xp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
block|{
specifier|const
name|U_CHAR
modifier|*
name|bp1
init|=
name|skip_quoted_string
argument_list|(
name|xp
operator|-
literal|1
argument_list|,
name|limit
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|xp
operator|!=
name|bp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|xp
operator|==
literal|'*'
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|xp
operator|+
literal|1
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_comments
condition|)
while|while
condition|(
name|xp
operator|!=
name|ip
operator|->
name|bufp
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
comment|/* Delete the slash.  */
else|else
name|cp
operator|--
expr_stmt|;
name|xp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
block|}
block|}
comment|/* Null-terminate the copy.  */
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|resume_p
expr_stmt|;
comment|/* Call the appropriate command handler.  buf now points to 	 either the appropriate place in the input buffer, or to 	 the temp buffer if it was necessary to make one.  cp 	 points to the first char after the contents of the (possibly 	 copied) command, in either case. */
call|(
modifier|*
name|kt
operator|->
name|func
call|)
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|monthnames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * expand things like __FILE__.  Place the expansion into the output  * buffer *without* rescanning.  */
end_comment

begin_function
specifier|static
name|void
name|special_symbol
parameter_list|(
name|hp
parameter_list|,
name|op
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|true_indepth
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|tm
modifier|*
name|timebuf
init|=
name|NULL
decl_stmt|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
comment|/* For special `defined' keyword */
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"not in any file?!"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|type
condition|)
block|{
case|case
name|T_FILE
case|:
case|case
name|T_BASE_FILE
case|:
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_FILE
condition|)
name|string
operator|=
name|ip
operator|->
name|fname
expr_stmt|;
else|else
name|string
operator|=
name|instack
index|[
literal|0
index|]
operator|.
name|fname
expr_stmt|;
if|if
condition|(
name|string
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"\"%s\""
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|buf
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|buf
operator|=
literal|""
expr_stmt|;
break|break;
block|}
case|case
name|T_INCLUDE_LEVEL
case|:
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|8
argument_list|)
decl_stmt|;
comment|/* Eigth bytes ought to be more than enough */
name|true_indepth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
name|true_indepth
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%d"
argument_list|,
name|true_indepth
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
case|case
name|T_VERSION
case|:
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|version_string
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"\"%s\""
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|buf
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
case|case
name|T_CONST
case|:
name|buf
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
expr_stmt|;
break|break;
case|case
name|T_SPECLINE
case|:
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%d"
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|buf
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
case|case
name|T_DATE
case|:
case|case
name|T_TIME
case|:
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|20
argument_list|)
decl_stmt|;
if|if
condition|(
name|timebuf
operator|==
name|NULL
condition|)
block|{
name|t
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|timebuf
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_DATE
condition|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"\"%s %2d %4d\""
argument_list|,
name|monthnames
index|[
name|timebuf
operator|->
name|tm_mon
index|]
argument_list|,
name|timebuf
operator|->
name|tm_mday
argument_list|,
name|timebuf
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"\"%02d:%02d:%02d\""
argument_list|,
name|timebuf
operator|->
name|tm_hour
argument_list|,
name|timebuf
operator|->
name|tm_min
argument_list|,
name|timebuf
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|buf
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
case|case
name|T_SPEC_DEFINED
case|:
name|buf
operator|=
literal|" 0 "
expr_stmt|;
comment|/* Assume symbol is not defined */
name|ip
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|==
literal|'('
condition|)
block|{
name|paren
operator|++
expr_stmt|;
name|ip
operator|->
name|bufp
operator|++
expr_stmt|;
comment|/* Skip over the paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_idstart
argument_list|(
operator|*
name|ip
operator|->
name|bufp
argument_list|)
condition|)
goto|goto
name|oops
goto|;
block|{
name|HASHNODE
modifier|*
name|hp
init|=
name|lookup
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|hp
operator|&&
name|hp
operator|->
name|type
operator|!=
name|T_UNUSED
operator|&&
name|hp
operator|->
name|type
operator|!=
name|T_SPEC_DEFINED
condition|)
name|buf
operator|=
literal|" 1 "
expr_stmt|;
block|}
while|while
condition|(
name|is_idchar
argument_list|(
operator|*
name|ip
operator|->
name|bufp
argument_list|)
condition|)
operator|++
name|ip
operator|->
name|bufp
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|!=
literal|')'
condition|)
goto|goto
name|oops
goto|;
operator|++
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
break|break;
name|oops
label|:
name|error
argument_list|(
literal|"`defined' must be followed by ident or (ident)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"cccp error: invalid special hash type"
argument_list|)
expr_stmt|;
comment|/* time for gdb */
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|op
operator|->
name|bufp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines to handle #directives */
end_comment

begin_comment
comment|/*  * Process include file by reading it in and calling rescan.  * Expects to see "fname" or<fname> on the input.  */
end_comment

begin_function
specifier|static
name|void
name|do_include
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|fbeg
decl_stmt|,
modifier|*
name|fend
decl_stmt|;
comment|/* Beginning and end of fname */
name|struct
name|file_name_list
modifier|*
name|stackp
init|=
name|include
decl_stmt|;
comment|/* Chain of dirs to search */
name|struct
name|file_name_list
name|dsp
index|[
literal|1
index|]
decl_stmt|;
comment|/* First in chain, if #include "..." */
name|int
name|flen
decl_stmt|;
name|int
name|retried
init|=
literal|0
decl_stmt|;
comment|/* Have already tried macro 				   expanding the include line*/
name|FILE_BUF
name|trybuf
decl_stmt|;
comment|/* It got expanded into here */
name|int
name|system_header_p
init|=
literal|0
decl_stmt|;
comment|/* 0 for "...", 1 for<...> */
name|get_filename
label|:
name|fbeg
operator|=
name|buf
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|fbeg
argument_list|)
expr_stmt|;
comment|/* Discard trailing whitespace so we can easily see      if we have parsed all the significant chars we were given.  */
while|while
condition|(
name|limit
operator|!=
name|fbeg
operator|&&
name|is_nvspace
argument_list|(
name|limit
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|limit
operator|--
expr_stmt|;
switch|switch
condition|(
operator|*
name|fbeg
operator|++
condition|)
block|{
case|case
literal|'\"'
case|:
name|fend
operator|=
name|fbeg
expr_stmt|;
while|while
condition|(
name|fend
operator|!=
name|limit
operator|&&
operator|*
name|fend
operator|!=
literal|'\"'
condition|)
name|fend
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fend
operator|==
literal|'\"'
operator|&&
name|fend
operator|+
literal|1
operator|==
name|limit
condition|)
block|{
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
comment|/* We have "filename".  Figure out directory this source 	 file is coming from and put it on the front of the list. */
comment|/* If -I- was specified, don't search current dir, only spec'd ones. */
if|if
condition|(
name|ignore_srcdir
condition|)
break|break;
for|for
control|(
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
init|;
name|fp
operator|>=
name|instack
condition|;
name|fp
operator|--
control|)
block|{
name|size_t
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nam
decl_stmt|;
if|if
condition|(
operator|(
name|nam
operator|=
name|fp
operator|->
name|fname
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Found a named file.  Figure out dir of the file, 	       and put it in front of the search list.  */
name|dsp
index|[
literal|0
index|]
operator|.
name|next
operator|=
name|stackp
expr_stmt|;
name|stackp
operator|=
name|dsp
expr_stmt|;
name|ep
operator|=
name|strrchr
argument_list|(
name|nam
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|f
decl_stmt|;
name|n
operator|=
name|ep
operator|-
name|nam
expr_stmt|;
name|f
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|f
argument_list|,
name|nam
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|f
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|=
literal|0
expr_stmt|;
comment|/* Current directory */
block|}
break|break;
block|}
block|}
break|break;
block|}
goto|goto
name|fail
goto|;
case|case
literal|'<'
case|:
name|fend
operator|=
name|fbeg
expr_stmt|;
while|while
condition|(
name|fend
operator|!=
name|limit
operator|&&
operator|*
name|fend
operator|!=
literal|'>'
condition|)
name|fend
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fend
operator|==
literal|'>'
operator|&&
name|fend
operator|+
literal|1
operator|==
name|limit
condition|)
block|{
name|system_header_p
operator|=
literal|1
expr_stmt|;
comment|/* If -I-, start with the first -I dir after the -I-.  */
if|if
condition|(
name|first_bracket_include
condition|)
name|stackp
operator|=
name|first_bracket_include
expr_stmt|;
break|break;
block|}
goto|goto
name|fail
goto|;
default|default:
name|fail
label|:
if|if
condition|(
name|retried
condition|)
block|{
name|error
argument_list|(
literal|"#include expects \"fname\" or<fname>"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|trybuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|trybuf
operator|.
name|buf
argument_list|,
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|limit
operator|=
name|buf
operator|+
operator|(
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
operator|)
expr_stmt|;
name|free
argument_list|(
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|retried
operator|++
expr_stmt|;
goto|goto
name|get_filename
goto|;
block|}
block|}
name|flen
operator|=
name|fend
operator|-
name|fbeg
expr_stmt|;
name|process_include
argument_list|(
name|stackp
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|,
name|system_header_p
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|do_include_next
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|fbeg
decl_stmt|,
modifier|*
name|fend
decl_stmt|;
comment|/* Beginning and end of fname */
name|struct
name|file_name_list
modifier|*
name|stackp
decl_stmt|;
comment|/* Chain of dirs to search */
name|int
name|flen
decl_stmt|;
name|int
name|retried
init|=
literal|0
decl_stmt|;
comment|/* Have already tried macro 				   expanding the include line*/
name|FILE_BUF
name|trybuf
decl_stmt|;
comment|/* It got expanded into here */
name|int
name|system_header_p
init|=
literal|0
decl_stmt|;
comment|/* 0 for "...", 1 for<...> */
comment|/* Treat as plain #include if we don't know where to start      looking.  */
name|stackp
operator|=
name|instack
index|[
name|indepth
index|]
operator|.
name|next_header_dir
expr_stmt|;
if|if
condition|(
name|stackp
operator|==
literal|0
condition|)
block|{
name|do_include
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|get_filename
label|:
name|fbeg
operator|=
name|buf
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|fbeg
argument_list|)
expr_stmt|;
comment|/* Discard trailing whitespace so we can easily see      if we have parsed all the significant chars we were given.  */
while|while
condition|(
name|limit
operator|!=
name|fbeg
operator|&&
name|is_nvspace
argument_list|(
name|limit
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|limit
operator|--
expr_stmt|;
switch|switch
condition|(
operator|*
name|fbeg
operator|++
condition|)
block|{
case|case
literal|'\"'
case|:
name|fend
operator|=
name|fbeg
expr_stmt|;
while|while
condition|(
name|fend
operator|!=
name|limit
operator|&&
operator|*
name|fend
operator|!=
literal|'\"'
condition|)
name|fend
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fend
operator|==
literal|'\"'
operator|&&
name|fend
operator|+
literal|1
operator|==
name|limit
condition|)
break|break;
goto|goto
name|fail
goto|;
case|case
literal|'<'
case|:
name|fend
operator|=
name|fbeg
expr_stmt|;
while|while
condition|(
name|fend
operator|!=
name|limit
operator|&&
operator|*
name|fend
operator|!=
literal|'>'
condition|)
name|fend
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fend
operator|==
literal|'>'
operator|&&
name|fend
operator|+
literal|1
operator|==
name|limit
condition|)
block|{
name|system_header_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
goto|goto
name|fail
goto|;
default|default:
name|fail
label|:
if|if
condition|(
name|retried
condition|)
block|{
name|error
argument_list|(
literal|"#include expects \"fname\" or<fname>"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|trybuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|trybuf
operator|.
name|buf
argument_list|,
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|limit
operator|=
name|buf
operator|+
operator|(
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
operator|)
expr_stmt|;
name|free
argument_list|(
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|retried
operator|++
expr_stmt|;
goto|goto
name|get_filename
goto|;
block|}
block|}
name|flen
operator|=
name|fend
operator|-
name|fbeg
expr_stmt|;
name|process_include
argument_list|(
name|stackp
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|,
name|system_header_p
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|process_include
parameter_list|(
name|stackp
parameter_list|,
name|fbeg
parameter_list|,
name|flen
parameter_list|,
name|system_header_p
parameter_list|,
name|op
parameter_list|)
name|struct
name|file_name_list
modifier|*
name|stackp
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|fbeg
decl_stmt|;
name|int
name|flen
decl_stmt|;
name|int
name|system_header_p
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|f
init|=
operator|-
literal|1
decl_stmt|;
comment|/* file number */
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_include_len
operator|+
name|flen
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* + 2 above for slash and terminating null.  */
comment|/* If specified file name is absolute, just open it.  */
if|if
condition|(
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|fbeg
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|fname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Search directory path, trying to open the file.        Copy each filename tried into FNAME.  */
for|for
control|(
init|;
name|stackp
condition|;
name|stackp
operator|=
name|stackp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|stackp
operator|->
name|fname
condition|)
block|{
name|strcpy
argument_list|(
name|fname
argument_list|,
name|stackp
operator|->
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|fname
index|[
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
name|flen
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|strncat
argument_list|(
name|fname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|fname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|deps_missing_files
operator|&&
name|print_deps
operator|>
operator|(
name|system_header_p
operator|||
operator|(
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* If requested as a system header, assume it belongs in 	 the first system header directory. */
if|if
condition|(
name|first_bracket_include
condition|)
name|stackp
operator|=
name|first_bracket_include
expr_stmt|;
else|else
name|stackp
operator|=
name|include
expr_stmt|;
if|if
condition|(
operator|!
name|system_header_p
operator|||
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|fbeg
argument_list|)
operator|||
operator|!
name|stackp
operator|->
name|fname
condition|)
name|deps_add_dep
argument_list|(
name|deps
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|stackp
operator|->
name|fname
argument_list|)
decl_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
name|flen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|stackp
operator|->
name|fname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|+
name|len
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|len
operator|+=
name|flen
expr_stmt|;
name|p
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|deps_add_dep
argument_list|(
name|deps
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|print_deps
operator|&&
name|print_deps
operator|<=
operator|(
name|system_header_p
operator|||
operator|(
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|"no include path in which to find %.*s"
argument_list|,
name|flen
argument_list|,
name|fbeg
argument_list|)
expr_stmt|;
else|else
name|error_from_errno
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check to see if this include file is a once-only include file.        If so, give up.  */
name|struct
name|file_name_list
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|dont_repeat_files
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|fname
argument_list|,
name|fname
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
comment|/* This file was once'd. */
block|}
block|}
for|for
control|(
name|ptr
operator|=
name|all_include_files
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|fname
argument_list|,
name|fname
argument_list|)
condition|)
break|break;
comment|/* This file was included before. */
block|}
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
block|{
comment|/* This is the first time for this file.  */
comment|/* Add it to list of files included.  */
name|ptr
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|all_include_files
expr_stmt|;
name|all_include_files
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|->
name|fname
operator|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* For -M, add this file to the dependencies.  */
if|if
condition|(
name|print_deps
operator|>
operator|(
name|system_header_p
operator|||
operator|(
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
condition|)
name|deps_add_dep
argument_list|(
name|deps
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|system_header_p
condition|)
name|system_include_depth
operator|++
expr_stmt|;
comment|/* Actually process the file.  */
name|finclude
argument_list|(
name|f
argument_list|,
name|fname
argument_list|,
name|stackp
operator|->
name|next
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|system_header_p
condition|)
name|system_include_depth
operator|--
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process the contents of include file FNAME, already open on descriptor F,    with output to OP.  */
end_comment

begin_function
specifier|static
name|void
name|finclude
parameter_list|(
name|f
parameter_list|,
name|fname
parameter_list|,
name|nhd
parameter_list|,
name|op
parameter_list|)
name|int
name|f
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|nhd
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|int
name|st_mode
decl_stmt|;
name|long
name|st_size
decl_stmt|;
name|long
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
comment|/* For input stack frame */
name|CHECK_DEPTH
argument_list|(
argument|return;
argument_list|)
empty_stmt|;
if|if
condition|(
name|file_size_and_mode
argument_list|(
name|f
argument_list|,
operator|&
name|st_mode
argument_list|,
operator|&
name|st_size
argument_list|)
condition|)
goto|goto
name|nope
goto|;
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
operator|+
literal|1
index|]
expr_stmt|;
name|memset
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|FILE_BUF
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|fp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|fp
operator|->
name|next_header_dir
operator|=
name|nhd
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st_mode
argument_list|)
condition|)
block|{
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|st_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
comment|/* Read the file contents, knowing that st_size is an upper bound        on the number of bytes we can read.  */
while|while
condition|(
name|st_size
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
operator|+
name|fp
operator|->
name|length
argument_list|,
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
goto|goto
name|nope
goto|;
block|}
name|fp
operator|->
name|length
operator|+=
name|i
expr_stmt|;
name|st_size
operator|-=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Cannot count its file size before reading.  */
name|U_CHAR
modifier|*
name|bufp
decl_stmt|;
name|U_CHAR
modifier|*
name|basep
decl_stmt|;
name|int
name|bsize
init|=
literal|2000
decl_stmt|;
name|st_size
operator|=
literal|0
expr_stmt|;
name|basep
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|basep
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|bufp
argument_list|,
name|bsize
operator|-
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
comment|/* error! */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
comment|/* End of file */
name|st_size
operator|+=
name|i
expr_stmt|;
name|bufp
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|bsize
operator|==
name|st_size
condition|)
block|{
comment|/* Buffer is full! */
name|bsize
operator|*=
literal|2
expr_stmt|;
name|basep
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|basep
argument_list|,
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|basep
operator|+
name|st_size
expr_stmt|;
comment|/* May have moved */
block|}
block|}
name|fp
operator|->
name|buf
operator|=
name|basep
expr_stmt|;
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
name|fp
operator|->
name|length
operator|=
name|st_size
expr_stmt|;
block|}
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Make sure data ends with a newline.  And put a null after it.  */
if|if
condition|(
name|fp
operator|->
name|length
operator|>
literal|0
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|indepth
operator|++
expr_stmt|;
name|output_line_command
argument_list|(
name|fp
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|enter_file
argument_list|)
expr_stmt|;
name|rescan
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indepth
operator|--
expr_stmt|;
name|instack
index|[
name|indepth
index|]
operator|.
name|lineno
operator|++
expr_stmt|;
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
operator|++
expr_stmt|;
comment|/* Skip the new line.  */
name|output_line_command
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|leave_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return;
name|nope
label|:
name|perror_with_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a #define command. BUF points to the contents of the #define command, as a continguous string. LIMIT points to the first character past the end of the definition. KEYWORD is the keyword-table entry for #define.  */
end_comment

begin_function
specifier|static
name|void
name|do_define
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* temp ptr into input buffer */
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|int
name|arglengths
init|=
literal|0
decl_stmt|;
comment|/* Accumulate lengths of arg names 				   plus number of args.  */
name|int
name|hashcode
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|is_nvspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
name|symname
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts */
while|while
condition|(
name|is_idchar
argument_list|(
operator|*
name|bp
argument_list|)
operator|&&
name|bp
operator|<
name|limit
condition|)
block|{
name|bp
operator|++
expr_stmt|;
block|}
name|sym_length
operator|=
name|bp
operator|-
name|symname
expr_stmt|;
if|if
condition|(
name|sym_length
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid macro name"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_idstart
argument_list|(
operator|*
name|symname
argument_list|)
condition|)
block|{
name|U_CHAR
modifier|*
name|msg
decl_stmt|;
comment|/* what pain... */
name|msg
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|sym_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|msg
argument_list|,
name|symname
argument_list|,
name|sym_length
argument_list|)
expr_stmt|;
name|msg
index|[
name|sym_length
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"invalid macro name `%s'"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|symname
argument_list|,
literal|"defined"
argument_list|,
literal|7
argument_list|)
operator|&&
name|sym_length
operator|==
literal|7
condition|)
block|{
name|error
argument_list|(
literal|"\"defined\" cannot be used as a macro name"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* lossage will occur if identifiers or control keywords are broken      across lines using backslash.  This is not the right place to take      care of that. */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'('
condition|)
block|{
name|struct
name|arglist
modifier|*
name|arg_ptrs
init|=
name|NULL
decl_stmt|;
name|int
name|argno
init|=
literal|0
decl_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* skip '(' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Loop over macro argument names.  */
while|while
condition|(
operator|*
name|bp
operator|!=
literal|')'
condition|)
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|arglist
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|bp
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|arg_ptrs
expr_stmt|;
name|temp
operator|->
name|argno
operator|=
name|argno
operator|++
expr_stmt|;
name|arg_ptrs
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|warning
argument_list|(
literal|"parameter name starts with a digit in #define"
argument_list|)
expr_stmt|;
comment|/* Find the end of the arg name.  */
while|while
condition|(
name|is_idchar
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
name|bp
operator|++
expr_stmt|;
block|}
name|temp
operator|->
name|length
operator|=
name|bp
operator|-
name|temp
operator|->
name|name
expr_stmt|;
name|arglengths
operator|+=
name|temp
operator|->
name|length
operator|+
literal|2
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|length
operator|==
literal|0
operator|||
operator|(
operator|*
name|bp
operator|!=
literal|','
operator|&&
operator|*
name|bp
operator|!=
literal|')'
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"badly punctuated parameter list in #define"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|','
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error
argument_list|(
literal|"unterminated parameter list in #define"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
operator|++
name|bp
expr_stmt|;
comment|/* skip paren */
while|while
condition|(
name|is_nvspace
argument_list|(
operator|*
name|bp
argument_list|)
operator|&&
name|bp
operator|<
name|limit
condition|)
comment|/* and leading whitespace */
operator|++
name|bp
expr_stmt|;
comment|/* now everything from bp before limit is the definition. */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|bp
argument_list|,
name|limit
argument_list|,
name|argno
argument_list|,
name|arg_ptrs
argument_list|)
expr_stmt|;
comment|/* Now set defn->argnames to the result of concatenating        the argument names in reverse order        with comma-space between them.  */
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|tmp
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|arglengths
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|arg_ptrs
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|tmp
index|[
name|i
index|]
argument_list|,
name|temp
operator|->
name|name
argument_list|,
name|temp
operator|->
name|length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|temp
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|next
operator|!=
literal|0
condition|)
block|{
name|tmp
index|[
name|i
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|tmp
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
name|tmp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|defn
operator|->
name|argnames
operator|=
name|tmp
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* simple expansion or empty definition; skip leading whitespace */
while|while
condition|(
name|is_nvspace
argument_list|(
operator|*
name|bp
argument_list|)
operator|&&
name|bp
operator|<
name|limit
condition|)
operator|++
name|bp
expr_stmt|;
comment|/* now everything from bp before limit is the definition. */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|bp
argument_list|,
name|limit
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defn
operator|->
name|argnames
operator|=
operator|(
specifier|const
name|U_CHAR
operator|*
operator|)
literal|""
expr_stmt|;
block|}
name|hashcode
operator|=
name|hashf
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|hp
operator|=
name|install
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|T_MACRO
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
operator|||
name|compare_defs
argument_list|(
name|defn
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
argument_list|)
condition|)
name|warning
argument_list|(
literal|"\"%.*s\" redefined"
argument_list|,
name|sym_length
argument_list|,
name|symname
argument_list|)
expr_stmt|;
comment|/* Replace the old definition.  */
name|hp
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
block|}
name|hp
operator|->
name|value
operator|.
name|defn
operator|=
name|defn
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * return zero if two DEFINITIONs are isomorphic  */
end_comment

begin_function
specifier|static
name|int
name|compare_defs
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|DEFINITION
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|reflist
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
name|U_CHAR
modifier|*
name|p1
init|=
name|d1
operator|->
name|expansion
decl_stmt|;
name|U_CHAR
modifier|*
name|p2
init|=
name|d2
operator|->
name|expansion
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|d1
operator|->
name|nargs
operator|!=
name|d2
operator|->
name|nargs
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|d1
operator|->
name|argnames
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|d2
operator|->
name|argnames
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|a1
operator|=
name|d1
operator|->
name|pattern
operator|,
name|a2
operator|=
name|d2
operator|->
name|pattern
init|;
name|a1
operator|&&
name|a2
condition|;
name|a1
operator|=
name|a1
operator|->
name|next
operator|,
name|a2
operator|=
name|a2
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|a1
operator|->
name|nchars
operator|==
name|a2
operator|->
name|nchars
operator|&&
operator|!
name|strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p1
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|p2
argument_list|,
name|a1
operator|->
name|nchars
argument_list|)
operator|)
operator|||
operator|!
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|a1
operator|->
name|nchars
argument_list|,
name|p2
argument_list|,
name|a2
operator|->
name|nchars
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
name|a1
operator|->
name|argno
operator|!=
name|a2
operator|->
name|argno
operator|||
name|a1
operator|->
name|stringify
operator|!=
name|a2
operator|->
name|stringify
operator|||
name|a1
operator|->
name|raw_before
operator|!=
name|a2
operator|->
name|raw_before
operator|||
name|a1
operator|->
name|raw_after
operator|!=
name|a2
operator|->
name|raw_after
condition|)
return|return
literal|1
return|;
name|first
operator|=
literal|0
expr_stmt|;
name|p1
operator|+=
name|a1
operator|->
name|nchars
expr_stmt|;
name|p2
operator|+=
name|a2
operator|->
name|nchars
expr_stmt|;
block|}
if|if
condition|(
name|a1
operator|!=
name|a2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|d1
operator|->
name|length
operator|-
operator|(
name|p1
operator|-
name|d1
operator|->
name|expansion
operator|)
argument_list|,
name|p2
argument_list|,
name|d2
operator|->
name|length
operator|-
operator|(
name|p2
operator|-
name|d2
operator|->
name|expansion
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Return 1 if two parts of two macro definitions are effectively different.    One of the parts starts at BEG1 and has LEN1 chars;    the other has LEN2 chars at BEG2.    Any sequence of whitespace matches any other sequence of whitespace.    FIRST means these parts are the first of a macro definition;     so ignore leading whitespace entirely.    LAST means these parts are the last of a macro definition;     so ignore trailing whitespace entirely.  */
end_comment

begin_function
specifier|static
name|int
name|comp_def_part
parameter_list|(
name|first
parameter_list|,
name|beg1
parameter_list|,
name|len1
parameter_list|,
name|beg2
parameter_list|,
name|len2
parameter_list|,
name|last
parameter_list|)
name|int
name|first
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|beg1
decl_stmt|,
decl|*
name|beg2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|U_CHAR
modifier|*
name|end1
init|=
name|beg1
operator|+
name|len1
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|end2
init|=
name|beg2
operator|+
name|len2
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
argument_list|(
operator|*
name|beg1
argument_list|)
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
argument_list|(
operator|*
name|beg2
argument_list|)
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
argument_list|(
name|end1
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|end1
operator|--
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
argument_list|(
name|end2
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|end2
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|beg2
operator|!=
name|end2
condition|)
block|{
if|if
condition|(
name|is_space
argument_list|(
operator|*
name|beg1
argument_list|)
operator|&&
name|is_space
argument_list|(
operator|*
name|beg2
argument_list|)
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
argument_list|(
operator|*
name|beg1
argument_list|)
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
argument_list|(
operator|*
name|beg2
argument_list|)
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|beg1
operator|==
operator|*
name|beg2
condition|)
block|{
name|beg1
operator|++
expr_stmt|;
name|beg2
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|beg1
operator|!=
name|end1
operator|)
operator|||
operator|(
name|beg2
operator|!=
name|end2
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Read a replacement list for a macro with parameters.    Build the DEFINITION structure.    Reads characters of text starting at BUF until LIMIT.    ARGLIST specifies the formal parameters to look for    in the text of the definition; NARGS is the number of args    in that list, or -1 for a macro name that wants no argument list.    MACRONAME is the macro name itself (so we can avoid recursive expansion)    and NAMELEN is its length in characters.     Note that comments and backslash-newlines have already been deleted from the argument.  */
end_comment

begin_comment
comment|/* Leading and trailing Space, Tab, etc. are converted to markers    Newline Space, Newline Tab, etc.    Newline Space makes a space in the final output    but is discarded if stringified.  (Newline Tab is similar but    makes a Tab instead.)     If there is no trailing whitespace, a Newline Space is added at the end    to prevent concatenation that would be contrary to the standard.  */
end_comment

begin_function
specifier|static
name|DEFINITION
modifier|*
name|collect_expansion
parameter_list|(
name|buf
parameter_list|,
name|end
parameter_list|,
name|nargs
parameter_list|,
name|arglist
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|end
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arglist
modifier|*
name|arglist
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|limit
decl_stmt|,
modifier|*
name|lastp
decl_stmt|,
modifier|*
name|exp_p
decl_stmt|;
name|struct
name|reflist
modifier|*
name|endpat
init|=
name|NULL
decl_stmt|;
comment|/* Pointer to first nonspace after last ## seen.  */
name|U_CHAR
modifier|*
name|concat
init|=
literal|0
decl_stmt|;
comment|/* Pointer to first nonspace after last single-# seen.  */
name|U_CHAR
modifier|*
name|stringify
init|=
literal|0
decl_stmt|;
name|int
name|maxsize
decl_stmt|;
name|int
name|expected_delimiter
init|=
literal|'\0'
decl_stmt|;
comment|/* Scan thru the replacement list, ignoring comments and quoted      strings, picking up on the macro calls.  It does a linear search      thru the arg list on every potential symbol.  Profiling might say      that something smarter should happen. */
if|if
condition|(
name|end
operator|<
name|buf
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the beginning of the trailing whitespace.  */
comment|/* Find end of leading whitespace.  */
name|limit
operator|=
name|end
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
argument_list|(
name|limit
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|limit
operator|--
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Allocate space for the text in the macro definition.      Leading and trailing whitespace chars need 2 bytes each.      Each other input char may or may not need 1 byte,      so this is an upper bound.      The extra 2 are for invented trailing newline-marker and final null.  */
name|maxsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
operator|+
literal|2
operator|*
operator|(
name|end
operator|-
name|limit
operator|)
operator|+
literal|2
operator|*
operator|(
name|p
operator|-
name|buf
operator|)
operator|+
operator|(
name|limit
operator|-
name|p
operator|)
operator|+
literal|3
operator|)
expr_stmt|;
name|defn
operator|=
operator|(
name|DEFINITION
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
name|defn
operator|->
name|nargs
operator|=
name|nargs
expr_stmt|;
name|exp_p
operator|=
name|defn
operator|->
name|expansion
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|defn
operator|+
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
expr_stmt|;
name|lastp
operator|=
name|exp_p
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
comment|/* Convert leading whitespace to Newline-markers.  */
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
comment|/* Process the main body of the definition.  */
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
name|int
name|skipped_arg
init|=
literal|0
decl_stmt|;
name|U_CHAR
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
operator|*
name|exp_p
operator|++
operator|=
name|c
expr_stmt|;
comment|/* In -traditional mode, recognize arguments inside strings and        and character constants, and ignore special properties of #.        Arguments inside strings are considered "stringified", but no        extra quote marks are supplied.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|expected_delimiter
condition|)
name|expected_delimiter
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|expected_delimiter
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Backslash quotes delimiters and itself, but not macro args.  */
if|if
condition|(
name|expected_delimiter
operator|!=
literal|0
operator|&&
name|p
operator|<
name|limit
operator|&&
operator|(
operator|*
name|p
operator|==
name|expected_delimiter
operator|||
operator|*
name|p
operator|==
literal|'\\'
operator|)
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
comment|/* No comments inside strings.  */
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
comment|/* If we find a comment that wasn't removed by handle_directive, 	   this must be -traditional.  So replace the comment with 	   nothing at all.  */
name|exp_p
operator|--
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
operator|!
operator|(
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|is_idchar
argument_list|(
name|c
argument_list|)
operator|&&
name|nargs
operator|>
literal|0
condition|)
block|{
name|U_CHAR
modifier|*
name|id_beg
init|=
name|p
operator|-
literal|1
decl_stmt|;
name|int
name|id_len
decl_stmt|;
operator|--
name|exp_p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|limit
operator|&&
name|is_idchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|id_len
operator|=
name|p
operator|-
name|id_beg
expr_stmt|;
if|if
condition|(
name|is_idstart
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|struct
name|arglist
modifier|*
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|arglist
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|next
control|)
block|{
name|struct
name|reflist
modifier|*
name|tpat
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|c
operator|&&
name|arg
operator|->
name|length
operator|==
name|id_len
operator|&&
name|strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|arg
operator|->
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|id_beg
argument_list|,
name|id_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* make a pat node for this arg and append it to the end of 	       the pat list */
name|tpat
operator|=
operator|(
expr|struct
name|reflist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reflist
argument_list|)
argument_list|)
expr_stmt|;
name|tpat
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tpat
operator|->
name|raw_before
operator|=
name|concat
operator|==
name|id_beg
expr_stmt|;
name|tpat
operator|->
name|raw_after
operator|=
literal|0
expr_stmt|;
name|tpat
operator|->
name|stringify
operator|=
name|expected_delimiter
operator|!=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|endpat
operator|==
name|NULL
condition|)
name|defn
operator|->
name|pattern
operator|=
name|tpat
expr_stmt|;
else|else
name|endpat
operator|->
name|next
operator|=
name|tpat
expr_stmt|;
name|endpat
operator|=
name|tpat
expr_stmt|;
name|tpat
operator|->
name|argno
operator|=
name|arg
operator|->
name|argno
expr_stmt|;
name|tpat
operator|->
name|nchars
operator|=
name|exp_p
operator|-
name|lastp
expr_stmt|;
block|{
name|U_CHAR
modifier|*
name|p1
init|=
name|p
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|+
literal|2
operator|<=
name|limit
operator|&&
name|p1
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
name|tpat
operator|->
name|raw_after
operator|=
literal|1
expr_stmt|;
block|}
name|lastp
operator|=
name|exp_p
expr_stmt|;
comment|/* place to start copying from next time */
name|skipped_arg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If this was not a macro arg, copy it into the expansion.  */
if|if
condition|(
operator|!
name|skipped_arg
condition|)
block|{
name|U_CHAR
modifier|*
name|lim1
init|=
name|p
decl_stmt|;
name|p
operator|=
name|id_beg
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|lim1
condition|)
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|stringify
operator|==
name|id_beg
condition|)
name|error
argument_list|(
literal|"# operator should be followed by a macro argument name"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|limit
operator|<
name|end
condition|)
block|{
comment|/* Convert trailing whitespace to Newline-markers.  */
while|while
condition|(
name|limit
operator|<
name|end
operator|&&
name|is_space
argument_list|(
operator|*
name|limit
argument_list|)
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|limit
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|exp_p
operator|=
literal|'\0'
expr_stmt|;
name|defn
operator|->
name|length
operator|=
name|exp_p
operator|-
name|defn
operator|->
name|expansion
expr_stmt|;
comment|/* Crash now if we overrun the allocated size.  */
if|if
condition|(
name|defn
operator|->
name|length
operator|+
literal|1
operator|>
name|maxsize
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|defn
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * interpret #line command.  Remembers previously seen fnames  * in its very own hash table.  */
end_comment

begin_define
define|#
directive|define
name|FNAME_HASHSIZE
value|37
end_define

begin_function
specifier|static
name|void
name|do_line
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|FILE_BUF
name|tem
decl_stmt|;
name|int
name|new_lineno
decl_stmt|;
name|enum
name|file_change_code
name|file_change
init|=
name|same_file
decl_stmt|;
comment|/* Expand any macros.  */
name|tem
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Point to macroexpanded line, which is null-terminated now.  */
name|bp
operator|=
name|tem
operator|.
name|buf
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid format #line command"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The Newline at the end of this line remains to be processed.      To put the next line at the specified line number,      we must store a line number now that is one less.  */
name|new_lineno
operator|=
name|atoi
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
comment|/* skip over the line number.  */
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\"'
condition|)
block|{
specifier|static
name|HASHNODE
modifier|*
name|fname_table
index|[
name|FNAME_HASHSIZE
index|]
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|,
modifier|*
modifier|*
name|hash_bucket
decl_stmt|;
name|U_CHAR
modifier|*
name|fname
decl_stmt|;
name|int
name|fname_length
decl_stmt|;
name|fname
operator|=
operator|++
name|bp
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|&&
operator|*
name|bp
operator|!=
literal|'\"'
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'\"'
condition|)
block|{
name|error
argument_list|(
literal|"invalid format #line command"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fname_length
operator|=
name|bp
operator|-
name|fname
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'1'
condition|)
name|file_change
operator|=
name|enter_file
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'2'
condition|)
name|file_change
operator|=
name|leave_file
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"invalid format #line command"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
condition|)
block|{
name|error
argument_list|(
literal|"invalid format #line command"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|hash_bucket
operator|=
operator|&
name|fname_table
index|[
name|hashf
argument_list|(
name|fname
argument_list|,
name|fname_length
argument_list|,
name|FNAME_HASHSIZE
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|*
name|hash_bucket
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
if|if
condition|(
name|hp
operator|->
name|length
operator|==
name|fname_length
operator|&&
name|strncmp
argument_list|(
name|hp
operator|->
name|value
operator|.
name|cpval
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|fname
argument_list|,
name|fname_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hp
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Didn't find it; cons up a new one.  */
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|fname_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hp
operator|->
name|next
operator|=
operator|*
name|hash_bucket
expr_stmt|;
operator|*
name|hash_bucket
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|fname_length
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
operator|=
name|q
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|q
argument_list|,
name|fname
argument_list|,
name|fname_length
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
condition|)
block|{
name|error
argument_list|(
literal|"invalid format #line command"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|->
name|lineno
operator|=
name|new_lineno
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|file_change
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|++
expr_stmt|;
comment|/* Skip the new line.  */
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * remove all definitions of symbol from symbol table.  * according to un*x /lib/cpp, it is not an error to undef  * something that has no definitions, so it isn't one here either.  */
end_comment

begin_function
specifier|static
name|void
name|do_undef
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|"defined"
argument_list|,
literal|7
argument_list|)
operator|&&
operator|!
name|is_idchar
argument_list|(
name|buf
index|[
literal|7
index|]
argument_list|)
condition|)
name|warning
argument_list|(
literal|"undefining `defined'"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
name|warning
argument_list|(
literal|"undefining `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
name|delete_macro
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read the tokens of the answer into the macro pool.  Only commit the    memory if we intend it as permanent storage, i.e. the #assert case.    Returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|parse_answer
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|answerp
parameter_list|,
name|type
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|answer
modifier|*
modifier|*
name|answerp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Skip leading whitespace.  */
if|if
condition|(
name|buf
operator|<
name|limit
operator|&&
operator|*
name|buf
operator|==
literal|' '
condition|)
name|buf
operator|++
expr_stmt|;
comment|/* Parentheses are optional here.  */
if|if
condition|(
name|buf
operator|==
name|limit
operator|&&
name|type
operator|==
name|T_UNASSERT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|buf
operator|==
name|limit
operator|||
operator|*
name|buf
operator|++
operator|!=
literal|'('
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|T_IF
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
literal|"missing '(' after predicate"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Drop whitespace at start.  */
while|while
condition|(
name|buf
operator|<
name|limit
operator|&&
operator|*
name|buf
operator|==
literal|' '
condition|)
name|buf
operator|++
expr_stmt|;
name|start
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|limit
operator|&&
operator|*
name|buf
operator|!=
literal|')'
condition|)
name|buf
operator|++
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|limit
condition|)
block|{
name|error
argument_list|(
literal|"missing ')' to complete answer"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|buf
operator|==
name|start
condition|)
block|{
name|error
argument_list|(
literal|"predicate's answer is empty"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|type
operator|==
name|T_ASSERT
operator|||
name|type
operator|==
name|T_UNASSERT
operator|)
operator|&&
name|buf
operator|+
literal|1
operator|!=
name|limit
condition|)
block|{
name|error
argument_list|(
literal|"extra text at end of directive"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Lose trailing whitespace.  */
if|if
condition|(
name|buf
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|buf
operator|--
expr_stmt|;
operator|*
name|answerp
operator|=
operator|(
expr|struct
name|answer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|answer
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|answerp
operator|)
operator|->
name|answer
operator|=
name|start
expr_stmt|;
operator|(
operator|*
name|answerp
operator|)
operator|->
name|len
operator|=
name|buf
operator|-
name|start
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Parses an assertion, returning a pointer to the hash node of the    predicate, or 0 on error.  If an answer was supplied, it is placed    in ANSWERP, otherwise it is set to 0.  */
end_comment

begin_function
specifier|static
name|HASHNODE
modifier|*
name|parse_assertion
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|answerp
parameter_list|,
name|type
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|answer
modifier|*
modifier|*
name|answerp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HASHNODE
modifier|*
name|result
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|climit
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|symname
init|=
name|canonicalize_text
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
operator|&
name|climit
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|bp
operator|=
name|symname
expr_stmt|;
if|if
condition|(
name|bp
operator|<
name|climit
operator|&&
name|is_idstart
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
do|do
name|bp
operator|++
expr_stmt|;
do|while
condition|(
name|bp
operator|<
name|climit
operator|&&
name|is_idchar
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
do|;
block|}
name|len
operator|=
name|bp
operator|-
name|symname
expr_stmt|;
operator|*
name|answerp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symname
operator|==
name|climit
condition|)
name|error
argument_list|(
literal|"assertion without predicate"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"predicate must be an identifier"
argument_list|)
expr_stmt|;
block|}
comment|/* Unfortunately, because of the way we handle #if, we don't avoid      macro expansion in answers.  This is not easy to fix.  */
elseif|else
if|if
condition|(
name|parse_answer
argument_list|(
name|bp
argument_list|,
name|climit
argument_list|,
name|answerp
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|sym
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
comment|/* Prefix '#' to get it out of macro namespace.  */
name|sym
index|[
literal|0
index|]
operator|=
literal|'#'
expr_stmt|;
name|memcpy
argument_list|(
name|sym
operator|+
literal|1
argument_list|,
name|symname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hashcode
operator|=
name|hashf
argument_list|(
name|sym
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|result
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|install
argument_list|(
name|sym
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|T_UNUSED
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Test an assertion within a preprocessor conditional.  Returns zero    on error or failure, one on success.  */
end_comment

begin_function
name|int
name|test_assertion
parameter_list|(
name|pbuf
parameter_list|)
name|unsigned
name|char
modifier|*
modifier|*
name|pbuf
decl_stmt|;
comment|/* NUL-terminated.  */
block|{
name|unsigned
name|char
modifier|*
name|buf
init|=
operator|*
name|pbuf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|limit
init|=
name|buf
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
decl_stmt|;
name|struct
name|answer
modifier|*
name|answer
decl_stmt|;
name|HASHNODE
modifier|*
name|node
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|node
operator|=
name|parse_assertion
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
operator|&
name|answer
argument_list|,
name|T_IF
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|result
operator|=
operator|(
name|node
operator|->
name|type
operator|==
name|T_ASSERT
operator|&&
operator|(
name|answer
operator|==
literal|0
operator|||
operator|*
name|find_answer
argument_list|(
name|node
argument_list|,
name|answer
argument_list|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* Yuk.  We update pbuf to point after the assertion test. 	 First, move past the identifier.  */
if|if
condition|(
name|is_space
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
name|buf
operator|++
expr_stmt|;
while|while
condition|(
name|is_idchar
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
name|buf
operator|++
expr_stmt|;
comment|/* If we have an answer, we need to move past the parentheses.  */
if|if
condition|(
name|answer
condition|)
while|while
condition|(
operator|*
name|buf
operator|++
operator|!=
literal|')'
condition|)
empty_stmt|;
operator|*
name|pbuf
operator|=
name|buf
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Handle a #error directive.  */
end_comment

begin_function
specifier|static
name|void
name|do_error
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|error
argument_list|(
literal|"#error%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|limit
operator|-
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a #warning directive.  */
end_comment

begin_function
specifier|static
name|void
name|do_warning
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|warning
argument_list|(
literal|"#warning%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|limit
operator|-
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a #assert directive.  */
end_comment

begin_function
specifier|static
name|void
name|do_assert
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|answer
modifier|*
name|new_answer
decl_stmt|;
name|HASHNODE
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|parse_assertion
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
operator|&
name|new_answer
argument_list|,
name|T_ASSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
comment|/* Place the new answer in the answer list.  First check there          is not a duplicate.  */
name|new_answer
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|T_ASSERT
condition|)
block|{
if|if
condition|(
operator|*
name|find_answer
argument_list|(
name|node
argument_list|,
name|new_answer
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|new_answer
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"\"%s\" re-asserted"
argument_list|,
name|node
operator|->
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_answer
operator|->
name|next
operator|=
name|node
operator|->
name|value
operator|.
name|answers
expr_stmt|;
block|}
name|node
operator|->
name|type
operator|=
name|T_ASSERT
expr_stmt|;
name|node
operator|->
name|value
operator|.
name|answers
operator|=
name|new_answer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function body to be provided later.  */
end_comment

begin_function
specifier|static
name|void
name|do_unassert
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HASHNODE
modifier|*
name|node
decl_stmt|;
name|struct
name|answer
modifier|*
name|answer
decl_stmt|;
name|node
operator|=
name|parse_assertion
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
operator|&
name|answer
argument_list|,
name|T_UNASSERT
argument_list|)
expr_stmt|;
comment|/* It isn't an error to #unassert something that isn't asserted.  */
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|T_ASSERT
condition|)
block|{
if|if
condition|(
name|answer
condition|)
block|{
name|struct
name|answer
modifier|*
modifier|*
name|p
init|=
name|find_answer
argument_list|(
name|node
argument_list|,
name|answer
argument_list|)
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
comment|/* Remove the answer from the list.  */
name|temp
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|temp
condition|)
operator|*
name|p
operator|=
name|temp
operator|->
name|next
expr_stmt|;
comment|/* Did we free the last answer?  */
if|if
condition|(
name|node
operator|->
name|value
operator|.
name|answers
operator|==
literal|0
condition|)
name|delete_macro
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|delete_macro
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns a pointer to the pointer to the answer in the answer chain,    or a pointer to NULL if the answer is not in the chain.  */
end_comment

begin_function
specifier|static
name|struct
name|answer
modifier|*
modifier|*
name|find_answer
parameter_list|(
name|node
parameter_list|,
name|candidate
parameter_list|)
name|HASHNODE
modifier|*
name|node
decl_stmt|;
specifier|const
name|struct
name|answer
modifier|*
name|candidate
decl_stmt|;
block|{
name|struct
name|answer
modifier|*
modifier|*
name|result
decl_stmt|;
for|for
control|(
name|result
operator|=
operator|&
name|node
operator|->
name|value
operator|.
name|answers
init|;
operator|*
name|result
condition|;
name|result
operator|=
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|next
control|)
block|{
name|struct
name|answer
modifier|*
name|answer
init|=
operator|*
name|result
decl_stmt|;
if|if
condition|(
name|answer
operator|->
name|len
operator|==
name|candidate
operator|->
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|answer
operator|->
name|answer
argument_list|,
name|candidate
operator|->
name|answer
argument_list|,
name|answer
operator|->
name|len
argument_list|)
condition|)
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return a malloced buffer with leading and trailing whitespace    removed, and all instances of internal whitespace reduced to a    single space.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|canonicalize_text
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|climit
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|,
modifier|*
modifier|*
name|climit
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|int
name|len
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|result
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
for|for
control|(
name|dest
operator|=
name|result
init|;
name|buf
operator|<
name|limit
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|is_space
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|++
name|buf
operator|<
name|limit
operator|&&
name|is_space
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|dest
operator|!=
name|result
operator|&&
name|buf
operator|!=
name|limit
condition|)
operator|*
name|dest
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
operator|*
name|climit
operator|=
name|dest
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*  * handle #if command by  *   1) inserting special `defined' keyword into the hash table  *	that gets turned into 0 or 1 by special_symbol (thus,  *	if the luser has a symbol called `defined' already, it won't  *      work inside the #if command)  *   2) rescan the input into a temporary output buffer  *   3) pass the output buffer to the yacc parser and collect a value  *   4) clean up the mess left from steps 1 and 2.  *   5) call conditional_skip to skip til the next #endif (etc.),  *      or not, depending on the value from step 3.  */
end_comment

begin_function
specifier|static
name|void
name|do_if
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|value
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|value
operator|=
name|eval_if_expression
argument_list|(
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
name|conditional_skip
argument_list|(
name|ip
argument_list|,
name|value
operator|==
literal|0
argument_list|,
name|T_IF
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * handle a #elif directive by not changing  if_stack  either.  * see the comment above do_else.  */
end_comment

begin_function
specifier|static
name|void
name|do_elif
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|value
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"#elif not within a conditional"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|error
argument_list|(
literal|"#elif after #else"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_stack
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|ip
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|->
name|type
operator|=
name|T_ELIF
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
name|eval_if_expression
argument_list|(
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * evaluate a #if expression in BUF, of length LENGTH,  * then parse the result as a C expression and return the value as an int.  */
end_comment

begin_function
specifier|static
name|int
name|eval_if_expression
parameter_list|(
name|buf
parameter_list|,
name|length
parameter_list|)
specifier|const
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|FILE_BUF
name|temp_obuf
decl_stmt|;
name|HASHNODE
modifier|*
name|save_defined
decl_stmt|;
name|int
name|value
decl_stmt|;
name|save_defined
operator|=
name|install
argument_list|(
literal|U"defined"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SPEC_DEFINED
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|temp_obuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_macro
argument_list|(
name|save_defined
argument_list|)
expr_stmt|;
comment|/* clean up special symbol */
name|value
operator|=
name|parse_c_expression
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|temp_obuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_obuf
operator|.
name|buf
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/*  * routine to handle ifdef/ifndef.  Try to look up the symbol,  * then do or don't skip to the #endif/#else/#elif depending  * on what directive is actually being processed.  */
end_comment

begin_function
specifier|static
name|void
name|do_xifdef
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|type
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|node_type
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|skip
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|U_CHAR
modifier|*
name|end
decl_stmt|;
comment|/* Discard leading and trailing whitespace.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|limit
operator|!=
name|buf
operator|&&
name|is_nvspace
argument_list|(
name|limit
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Find the end of the identifier at the beginning.  */
for|for
control|(
name|end
operator|=
name|buf
init|;
name|is_idchar
argument_list|(
operator|*
name|end
argument_list|)
condition|;
name|end
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|end
operator|==
name|buf
condition|)
name|skip
operator|=
operator|(
name|type
operator|==
name|T_IFDEF
operator|)
expr_stmt|;
else|else
name|skip
operator|=
operator|(
name|lookup
argument_list|(
name|buf
argument_list|,
name|end
operator|-
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NULL
operator|)
operator|^
operator|(
name|type
operator|==
name|T_IFNDEF
operator|)
expr_stmt|;
name|conditional_skip
argument_list|(
name|ip
argument_list|,
name|skip
argument_list|,
name|T_IF
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|do_ifdef
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|do_xifdef
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|T_IFDEF
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|do_ifndef
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|do_xifdef
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|T_IFNDEF
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * push TYPE on stack; then, if SKIP is nonzero, skip ahead.  */
end_comment

begin_function
specifier|static
name|void
name|conditional_skip
parameter_list|(
name|ip
parameter_list|,
name|skip
parameter_list|,
name|type
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|ip
operator|->
name|fname
expr_stmt|;
name|temp
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|temp
expr_stmt|;
name|if_stack
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * skip to #endif, #else, or #elif.  adjust line numbers, etc.  * leaves input ptr at the sharp sign found.  * If ANY is nonzero, return at next directive of any sort.  */
end_comment

begin_function
specifier|static
name|void
name|skip_if_group
parameter_list|(
name|ip
parameter_list|,
name|any
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
name|any
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|bp
init|=
name|ip
operator|->
name|bufp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|U_CHAR
modifier|*
name|endb
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
specifier|const
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|IF_STACK_FRAME
modifier|*
name|save_if_stack
init|=
name|if_stack
decl_stmt|;
comment|/* don't pop past here */
name|U_CHAR
modifier|*
name|beg_of_line
init|=
name|bp
decl_stmt|;
while|while
condition|(
name|bp
operator|<
name|endb
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* possible comment */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
operator|++
name|bp
expr_stmt|;
name|bp
operator|=
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
name|bp
operator|=
name|skip_quoted_string
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
name|endb
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Char after backslash loses its special meaning.  */
if|if
condition|(
name|bp
operator|<
name|endb
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* But do update the line-count.  */
name|bp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|beg_of_line
operator|=
name|bp
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
comment|/* # keyword: a # must be first nonblank char on the line */
if|if
condition|(
name|beg_of_line
operator|==
literal|0
condition|)
break|break;
comment|/* Scan from start of line, skipping whitespace, comments 	 and backslash-newlines, and see if we reach this #. 	 If not, this # is not special.  */
name|bp
operator|=
name|beg_of_line
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_nvspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|bp
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|bp
operator|!=
name|ip
operator|->
name|bufp
condition|)
block|{
name|bp
operator|=
name|ip
operator|->
name|bufp
operator|+
literal|1
expr_stmt|;
comment|/* Reset bp to after the #.  */
break|break;
block|}
name|bp
operator|=
name|ip
operator|->
name|bufp
operator|+
literal|1
expr_stmt|;
comment|/* Point after '#'.  */
comment|/* Skip whitespace and \-newline.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_nvspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|bp
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
name|bp
operator|++
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
break|break;
block|}
name|cp
operator|=
name|bp
expr_stmt|;
comment|/* Now find end of directive name. 	 If we encounter a backslash-newline, exchange it with any following 	 symbol-constituents so that we end up with a contiguous name.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_idchar
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|name_newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_idchar
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
else|else
break|break;
block|}
block|}
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|length
operator|>=
literal|0
condition|;
name|kt
operator|++
control|)
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cp
argument_list|,
name|kt
operator|->
name|name
argument_list|,
name|kt
operator|->
name|length
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_idchar
argument_list|(
name|cp
index|[
name|kt
operator|->
name|length
index|]
argument_list|)
condition|)
block|{
comment|/* If we are asked to return on next directive, 	     do so now.  */
if|if
condition|(
name|any
condition|)
return|return;
switch|switch
condition|(
name|kt
operator|->
name|type
condition|)
block|{
case|case
name|T_IF
case|:
case|case
name|T_IFDEF
case|:
case|case
name|T_IFNDEF
case|:
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|ip
operator|->
name|fname
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
case|case
name|T_ELSE
case|:
case|case
name|T_ENDIF
case|:
case|case
name|T_ELIF
case|:
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"#%s not within a conditional"
argument_list|,
name|kt
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|if_stack
operator|==
name|save_if_stack
condition|)
return|return;
comment|/* found what we came for */
if|if
condition|(
name|kt
operator|->
name|type
operator|!=
name|T_ENDIF
condition|)
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|==
name|T_ELSE
condition|)
name|error
argument_list|(
literal|"#else or #elif after #else"
argument_list|)
expr_stmt|;
name|if_stack
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
block|}
name|temp
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|if_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Anything else is ignored.  */
break|break;
block|}
break|break;
block|}
block|}
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
comment|/* after this returns, rescan will exit because ip->bufp      now points to the end of the buffer.      rescan is responsible for the error message also.  */
block|}
end_function

begin_comment
comment|/*  * handle a #else directive.  Do this by just continuing processing  * without changing  if_stack ;  this is so that the error message  * for missing #endif's etc. will point to the original #if.  It  * is possible that something different would be better.  */
end_comment

begin_function
specifier|static
name|void
name|do_else
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"#else not within a conditional"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|error
argument_list|(
literal|"#else after #else"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|->
name|type
operator|=
name|T_ELSE
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * unstack after #endif command  */
end_comment

begin_function
specifier|static
name|void
name|do_endif
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
name|error
argument_list|(
literal|"unbalanced #endif"
argument_list|)
expr_stmt|;
else|else
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
init|=
name|if_stack
decl_stmt|;
name|if_stack
operator|=
name|if_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Skip a comment, assuming the input ptr immediately follows the  * initial slash-star.  Bump line counter as necessary.  * (The canonical line counter is&ip->lineno).  * Don't use this routine (or the next one) if bumping the line  * counter is not sufficient to deal with newlines in the string.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|skip_to_end_of_comment
parameter_list|(
name|ip
parameter_list|,
name|line_counter
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
modifier|*
name|line_counter
decl_stmt|;
comment|/* place to remember newlines, or NULL */
block|{
name|U_CHAR
modifier|*
name|limit
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
name|U_CHAR
modifier|*
name|bp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
init|=
operator|&
name|outbuf
decl_stmt|;
comment|/* JF */
name|int
name|output
init|=
name|put_out_comments
operator|&&
operator|!
name|line_counter
decl_stmt|;
comment|/* JF this line_counter stuff is a crock to make sure the 	   comment is only put out once, no matter how many times 	   the comment is skipped.  It almost works */
if|if
condition|(
name|output
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'/'
case|:
if|if
condition|(
name|warn_comments
operator|&&
name|bp
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|==
literal|'*'
condition|)
name|warning
argument_list|(
literal|"`/*' within comment"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|line_counter
operator|!=
name|NULL
condition|)
operator|++
operator|*
name|line_counter
expr_stmt|;
if|if
condition|(
name|output
condition|)
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
operator|++
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
break|break;
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * Skip over a quoted string.  BP points to the opening quote.  * Returns a pointer after the closing quote.  Don't go past LIMIT.  * START_LINE is the line number of the starting point (but it need  * not be valid if the starting point is inside a macro expansion).  *  * The input stack state is not changed.  *  * If COUNT_NEWLINES is nonzero, it points to an int to increment  * for each newline passed.  *  * If BACKSLASH_NEWLINES_P is nonzero, store 1 thru it  * if we pass a backslash-newline.  *  * If EOFP is nonzero, set *EOFP to 1 if the string is unterminated.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|skip_quoted_string
parameter_list|(
name|bp
parameter_list|,
name|limit
parameter_list|,
name|start_line
parameter_list|,
name|count_newlines
parameter_list|,
name|backslash_newlines_p
parameter_list|,
name|eofp
parameter_list|)
specifier|const
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
name|start_line
decl_stmt|;
name|int
modifier|*
name|count_newlines
decl_stmt|;
name|int
modifier|*
name|backslash_newlines_p
decl_stmt|;
name|int
modifier|*
name|eofp
decl_stmt|;
block|{
name|U_CHAR
name|c
decl_stmt|,
name|match
decl_stmt|;
name|match
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
while|while
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|backslash_newlines_p
condition|)
operator|*
name|backslash_newlines_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|count_newlines
condition|)
operator|++
operator|*
name|count_newlines
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
operator|&&
name|count_newlines
condition|)
block|{
if|if
condition|(
name|backslash_newlines_p
condition|)
operator|*
name|backslash_newlines_p
operator|=
literal|1
expr_stmt|;
operator|++
operator|*
name|count_newlines
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* Unterminated strings and character constants are 'legal'.  */
name|bp
operator|--
expr_stmt|;
comment|/* Don't consume the newline. */
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|match
condition|)
break|break;
block|}
return|return
operator|(
name|U_CHAR
operator|*
operator|)
name|bp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * write out a #line command, for instance, after an #include file.  * If CONDITIONAL is nonzero, we can omit the #line if it would  * appear to be a no-op, and we can output a few newlines instead  * if we want to increase the line number by a small amount.  * FILE_CHANGE says whether we are entering a file, leaving, or neither.  */
end_comment

begin_function
specifier|static
name|void
name|output_line_command
parameter_list|(
name|ip
parameter_list|,
name|op
parameter_list|,
name|conditional
parameter_list|,
name|file_change
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
decl|*
name|op
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|conditional
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|file_change_code
name|file_change
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|char
name|line_cmd_buf
index|[
literal|500
index|]
decl_stmt|;
if|if
condition|(
name|no_line_commands
operator|||
name|ip
operator|->
name|fname
operator|==
name|NULL
operator|||
name|no_output
condition|)
block|{
name|op
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|conditional
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|lineno
operator|==
name|op
operator|->
name|lineno
condition|)
return|return;
comment|/* If the inherited line number is a little too small,        output some newlines instead of a #line command.  */
if|if
condition|(
name|ip
operator|->
name|lineno
operator|>
name|op
operator|->
name|lineno
operator|&&
name|ip
operator|->
name|lineno
operator|<
name|op
operator|->
name|lineno
operator|+
literal|8
condition|)
block|{
name|check_expand
argument_list|(
name|op
argument_list|,
literal|10
argument_list|)
expr_stmt|;
while|while
condition|(
name|ip
operator|->
name|lineno
operator|>
name|op
operator|->
name|lineno
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
return|return;
block|}
block|}
name|sprintf
argument_list|(
name|line_cmd_buf
argument_list|,
literal|"# %d \"%s\""
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_change
operator|!=
name|same_file
condition|)
name|strcat
argument_list|(
name|line_cmd_buf
argument_list|,
name|file_change
operator|==
name|enter_file
condition|?
literal|" 1"
else|:
literal|" 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|system_include_depth
operator|>
literal|0
condition|)
name|strcat
argument_list|(
name|line_cmd_buf
argument_list|,
literal|" 3"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|line_cmd_buf
argument_list|)
expr_stmt|;
name|line_cmd_buf
index|[
name|len
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|bufp
operator|>
name|op
operator|->
name|buf
operator|&&
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|memcpy
argument_list|(
name|op
operator|->
name|bufp
argument_list|,
name|line_cmd_buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
name|op
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Expand a macro call.    HP points to the symbol that is the macro being called.    Put the result of expansion onto the input stack    so that subsequent input by our caller will use it.     If macro wants arguments, caller has already verified that    an argument list follows; arguments come from the input stack.  */
end_comment

begin_function
specifier|static
name|void
name|macroexpand
parameter_list|(
name|hp
parameter_list|,
name|op
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|int
name|nargs
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
name|U_CHAR
modifier|*
name|xbuf
decl_stmt|;
name|int
name|xbuf_len
decl_stmt|;
name|int
name|start_line
init|=
name|instack
index|[
name|indepth
index|]
operator|.
name|lineno
decl_stmt|;
name|CHECK_DEPTH
argument_list|(
argument|return;
argument_list|)
empty_stmt|;
comment|/* it might not actually be a macro.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
block|{
name|special_symbol
argument_list|(
name|hp
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|nargs
operator|=
name|defn
operator|->
name|nargs
expr_stmt|;
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|argdata
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|parse_error
init|=
literal|0
decl_stmt|;
name|args
operator|=
operator|(
expr|struct
name|argdata
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|argdata
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|raw
operator|=
name|args
index|[
name|i
index|]
operator|.
name|expanded
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
literal|""
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|raw_length
operator|=
name|args
index|[
name|i
index|]
operator|.
name|expand_length
operator|=
name|args
index|[
name|i
index|]
operator|.
name|stringified_length
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|free1
operator|=
name|args
index|[
name|i
index|]
operator|.
name|free2
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Parse all the macro args that are supplied.  I counts them.        The first NARGS args are stored in ARGS.        The rest are discarded.  */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Discard the open-parenthesis or comma before the next arg.  */
operator|++
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
expr_stmt|;
name|parse_error
operator|=
name|macarg
argument_list|(
operator|(
name|i
operator|<
name|nargs
operator|||
operator|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|==
literal|0
operator|)
operator|)
condition|?
operator|&
name|args
index|[
name|i
index|]
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_error
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|parse_error
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
operator|!=
literal|')'
condition|)
do|;
comment|/* If we got one arg but it was just whitespace, call that 0 args.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
specifier|const
name|U_CHAR
modifier|*
name|bp
init|=
name|args
index|[
literal|0
index|]
operator|.
name|raw
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|lim
init|=
name|bp
operator|+
name|args
index|[
literal|0
index|]
operator|.
name|raw_length
decl_stmt|;
while|while
condition|(
name|bp
operator|!=
name|lim
operator|&&
name|is_space
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|lim
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"arguments given to macro `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
block|{
comment|/* traditional C allows foo() if foo wants one argument.  */
if|if
condition|(
name|nargs
operator|==
literal|1
operator|&&
name|i
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"no args to macro `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"only 1 arg to macro `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"only %d args to macro `%s'"
argument_list|,
name|i
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|nargs
condition|)
name|error
argument_list|(
literal|"too many (%d) args to macro `%s'"
argument_list|,
name|i
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Swallow the closeparen.  */
operator|++
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
expr_stmt|;
comment|/* If macro wants zero args, we parsed the arglist for checking only.        Read directly from the macro definition.  */
if|if
condition|(
name|nargs
operator|==
literal|0
condition|)
block|{
name|xbuf
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
name|U_CHAR
modifier|*
name|exp
init|=
name|defn
operator|->
name|expansion
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* offset in expansion, 				   copied a piece at a time */
name|int
name|totlen
decl_stmt|;
comment|/* total amount of exp buffer filled so far */
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|;
comment|/* Macro really takes args.  Compute the expansion of this call.  */
comment|/* Compute length in characters of the macro's expansion.  */
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|stringify
condition|)
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|stringified_length
expr_stmt|;
else|else
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw_length
expr_stmt|;
block|}
name|xbuf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|xbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Generate in XBUF the complete expansion 	 with arguments substituted in. 	 TOTLEN is the total size generated so far. 	 OFFSET is the index in the definition 	 of where we are copying from.  */
name|offset
operator|=
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
name|struct
name|argdata
modifier|*
name|arg
init|=
operator|&
name|args
index|[
name|ap
operator|->
name|argno
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|nchars
condition|;
name|i
operator|++
control|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|offset
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|stringify
operator|!=
literal|0
condition|)
block|{
name|int
name|arglen
init|=
name|arg
operator|->
name|raw_length
decl_stmt|;
name|int
name|escaped
init|=
literal|0
decl_stmt|;
name|int
name|in_string
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|arglen
operator|&&
operator|(
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
operator|,
name|is_space
argument_list|(
name|c
argument_list|)
operator|)
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|arglen
operator|&&
operator|(
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|arglen
operator|-
literal|1
index|]
operator|,
name|is_space
argument_list|(
name|c
argument_list|)
operator|)
condition|)
name|arglen
operator|--
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|arglen
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
expr_stmt|;
comment|/* Special markers Newline Space 	       generate nothing for a stringified argument.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Internal sequences of whitespace are replaced by one space 	       except within an string or char token.  */
if|if
condition|(
operator|!
name|in_string
operator|&&
operator|(
name|c
operator|==
literal|'\n'
condition|?
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
else|:
name|is_space
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Note that Newline Space does occur within whitespace 		   sequences; consider it part of the sequence.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|is_space
argument_list|(
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
name|i
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|is_space
argument_list|(
name|c
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
else|else
break|break;
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|escaped
condition|)
name|escaped
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|escaped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|in_string
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|in_string
condition|)
name|in_string
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\''
condition|)
name|in_string
operator|=
name|c
expr_stmt|;
block|}
comment|/* Escape these chars */
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
operator|(
name|in_string
operator|&&
name|c
operator|==
literal|'\\'
operator|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|xbuf
index|[
name|totlen
index|]
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|totlen
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
specifier|const
name|U_CHAR
modifier|*
name|p1
init|=
name|arg
operator|->
name|raw
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|l1
init|=
name|p1
operator|+
name|arg
operator|->
name|raw_length
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|raw_before
condition|)
block|{
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_space
argument_list|(
operator|*
name|p1
argument_list|)
condition|)
name|p1
operator|++
expr_stmt|;
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_idchar
argument_list|(
operator|*
name|p1
argument_list|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
comment|/* Delete any no-reexpansion marker that follows 	       an identifier at the beginning of the argument 	       if the argument is concatenated with what precedes it.  */
if|if
condition|(
name|p1
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|p1
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|raw_after
condition|)
block|{
comment|/* Arg is concatenated after: delete trailing whitespace, 	       whitespace markers, and no-reexpansion markers.  */
while|while
condition|(
name|p1
operator|!=
name|l1
condition|)
block|{
if|if
condition|(
name|is_space
argument_list|(
name|l1
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|l1
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|l1
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
specifier|const
name|U_CHAR
modifier|*
name|p2
init|=
name|l1
operator|-
literal|1
decl_stmt|;
comment|/* If a `-' is preceded by an odd number of newlines then it 		   and the last newline are a no-reexpansion marker.  */
while|while
condition|(
name|p2
operator|!=
name|p1
operator|&&
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p2
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|-
literal|1
operator|-
name|p2
operator|)
operator|&
literal|1
condition|)
block|{
name|l1
operator|-=
literal|2
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
break|break;
block|}
block|}
name|memmove
argument_list|(
name|xbuf
operator|+
name|totlen
argument_list|,
name|p1
argument_list|,
name|l1
operator|-
name|p1
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l1
operator|-
name|p1
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>
name|xbuf_len
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* if there is anything left of the definition 	 after handling the arg list, copy that in too. */
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|<
name|defn
operator|->
name|length
condition|;
name|i
operator|++
control|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|i
index|]
expr_stmt|;
name|xbuf
index|[
name|totlen
index|]
operator|=
literal|0
expr_stmt|;
name|xbuf_len
operator|=
name|totlen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|free1
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|free1
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|free2
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|free2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|xbuf
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
block|}
comment|/* Now put the expansion on the input stack      so our caller will commence reading from it.  */
block|{
name|FILE_BUF
modifier|*
name|ip2
decl_stmt|;
name|ip2
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip2
operator|->
name|fname
operator|=
literal|0
expr_stmt|;
name|ip2
operator|->
name|lineno
operator|=
literal|0
expr_stmt|;
name|ip2
operator|->
name|buf
operator|=
name|xbuf
expr_stmt|;
name|ip2
operator|->
name|length
operator|=
name|xbuf_len
expr_stmt|;
name|ip2
operator|->
name|bufp
operator|=
name|xbuf
expr_stmt|;
name|ip2
operator|->
name|free_ptr
operator|=
operator|(
name|nargs
operator|>
literal|0
operator|)
condition|?
name|xbuf
else|:
literal|0
expr_stmt|;
name|ip2
operator|->
name|macro
operator|=
name|hp
expr_stmt|;
name|ip2
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Parse a macro argument and store the info on it into *ARGPTR.  * Return nonzero to indicate a syntax error.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|macarg
parameter_list|(
name|argptr
parameter_list|)
name|struct
name|argdata
modifier|*
name|argptr
decl_stmt|;
block|{
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
name|int
name|newlines
init|=
literal|0
decl_stmt|;
name|int
name|comments
init|=
literal|0
decl_stmt|;
comment|/* Try to parse as much of the argument as exists at this      input stack level.  */
name|U_CHAR
modifier|*
name|bp
init|=
name|macarg1
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
argument_list|,
operator|&
name|paren
argument_list|,
operator|&
name|newlines
argument_list|,
operator|&
name|comments
argument_list|)
decl_stmt|;
comment|/* If we find the end of the argument at this level,      set up *ARGPTR to point at it in the input stack.  */
if|if
condition|(
operator|!
operator|(
name|ip
operator|->
name|fname
operator|!=
literal|0
operator|&&
operator|(
name|newlines
operator|!=
literal|0
operator|||
name|comments
operator|!=
literal|0
operator|)
operator|)
operator|&&
name|bp
operator|!=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
name|argptr
operator|->
name|raw
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
name|argptr
operator|->
name|raw_length
operator|=
name|bp
operator|-
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
comment|/* This input stack level ends before the macro argument does.        We must pop levels and keep parsing.        Therefore, we must allocate a temporary buffer and copy        the macro argument into it.  */
name|int
name|bufsize
init|=
name|bp
operator|-
name|ip
operator|->
name|bufp
decl_stmt|;
name|int
name|extra
init|=
name|newlines
decl_stmt|;
name|U_CHAR
modifier|*
name|buffer
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufsize
operator|+
name|extra
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|final_start
init|=
literal|0
decl_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|ip
operator|->
name|bufp
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|lineno
operator|+=
name|newlines
expr_stmt|;
while|while
condition|(
name|bp
operator|==
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|instack
index|[
name|indepth
index|]
operator|.
name|macro
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|"unterminated macro call"
return|;
block|}
name|ip
operator|->
name|macro
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|free_ptr
condition|)
name|free
argument_list|(
name|ip
operator|->
name|free_ptr
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
operator|--
name|indepth
index|]
expr_stmt|;
name|newlines
operator|=
literal|0
expr_stmt|;
name|comments
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|macarg1
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
argument_list|,
operator|&
name|paren
argument_list|,
operator|&
name|newlines
argument_list|,
operator|&
name|comments
argument_list|)
expr_stmt|;
name|final_start
operator|=
name|bufsize
expr_stmt|;
name|bufsize
operator|+=
name|bp
operator|-
name|ip
operator|->
name|bufp
expr_stmt|;
name|extra
operator|+=
name|newlines
expr_stmt|;
name|buffer
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
operator|+
name|extra
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufsize
operator|-
operator|(
name|bp
operator|-
name|ip
operator|->
name|bufp
operator|)
argument_list|,
name|ip
operator|->
name|bufp
argument_list|,
name|bp
operator|-
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|lineno
operator|+=
name|newlines
expr_stmt|;
block|}
comment|/* Now, if arg is actually wanted, record its raw form,        discarding comments and duplicating newlines in whatever        part of it did not come from a macro expansion.        EXTRA space has been preallocated for duplicating the newlines.        FINAL_START is the index of the start of that part.  */
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
name|argptr
operator|->
name|raw
operator|=
name|buffer
expr_stmt|;
name|argptr
operator|->
name|raw_length
operator|=
name|bufsize
expr_stmt|;
name|argptr
operator|->
name|free1
operator|=
name|buffer
expr_stmt|;
name|argptr
operator|->
name|newlines
operator|=
name|newlines
expr_stmt|;
name|argptr
operator|->
name|comments
operator|=
name|comments
expr_stmt|;
if|if
condition|(
operator|(
name|newlines
operator|||
name|comments
operator|)
operator|&&
name|ip
operator|->
name|fname
operator|!=
literal|0
condition|)
name|argptr
operator|->
name|raw_length
operator|=
name|final_start
operator|+
name|discard_comments
argument_list|(
name|argptr
operator|->
name|raw
operator|+
name|final_start
argument_list|,
name|argptr
operator|->
name|raw_length
operator|-
name|final_start
argument_list|,
name|newlines
argument_list|)
expr_stmt|;
name|argptr
operator|->
name|raw
index|[
name|argptr
operator|->
name|raw_length
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argptr
operator|->
name|raw_length
operator|>
name|bufsize
operator|+
name|extra
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If we are not discarding this argument,      macroexpand it and compute its length as stringified.      All this info goes into *ARGPTR.  */
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
name|FILE_BUF
name|obuf
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
name|int
name|totlen
decl_stmt|;
name|obuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|argptr
operator|->
name|raw
argument_list|,
name|argptr
operator|->
name|raw
operator|+
name|argptr
operator|->
name|raw_length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argptr
operator|->
name|expanded
operator|=
name|obuf
operator|.
name|buf
expr_stmt|;
name|argptr
operator|->
name|expand_length
operator|=
name|obuf
operator|.
name|length
expr_stmt|;
name|argptr
operator|->
name|free2
operator|=
name|obuf
operator|.
name|buf
expr_stmt|;
name|buf
operator|=
name|argptr
operator|->
name|raw
expr_stmt|;
name|lim
operator|=
name|buf
operator|+
name|argptr
operator|->
name|raw_length
expr_stmt|;
name|totlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
operator|!=
name|lim
condition|)
block|{
name|U_CHAR
name|c
init|=
operator|*
name|buf
operator|++
decl_stmt|;
name|totlen
operator|++
expr_stmt|;
comment|/* Internal sequences of whitespace are replaced by one space 	 in most cases, but not always.  So count all the whitespace 	 in case we need to keep it all.  */
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
comment|/* escape these chars */
name|totlen
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|totlen
operator|+=
literal|3
expr_stmt|;
block|}
name|argptr
operator|->
name|stringified_length
operator|=
name|totlen
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Scan text from START (inclusive) up to LIMIT (exclusive),    counting parens in *DEPTHPTR,    and return if reach LIMIT    or before a `)' that would make *DEPTHPTR negative    or before a comma when *DEPTHPTR is zero.    Single and double quotes are matched and termination    is inhibited within them.  Comments also inhibit it.    Value returned is pointer to stopping place.     Increment *NEWLINES each time a newline is passed.    Set *COMMENTS to 1 if a comment is seen.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|macarg1
parameter_list|(
name|start
parameter_list|,
name|limit
parameter_list|,
name|depthptr
parameter_list|,
name|newlines
parameter_list|,
name|comments
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
modifier|*
name|depthptr
decl_stmt|,
decl|*
name|newlines
decl_stmt|,
modifier|*
name|comments
decl_stmt|;
end_function

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
init|=
name|start
decl_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
literal|'('
case|:
operator|(
operator|*
name|depthptr
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|--
operator|(
operator|*
name|depthptr
operator|)
operator|<
literal|0
condition|)
return|return
name|bp
return|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Traditionally, backslash makes following char not special.  */
if|if
condition|(
name|bp
operator|+
literal|1
operator|<
name|limit
condition|)
block|{
name|bp
operator|++
expr_stmt|;
comment|/* But count source lines anyway.  */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
operator|++
operator|*
name|newlines
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|!=
literal|'*'
operator|||
name|bp
operator|+
literal|1
operator|>=
name|limit
condition|)
break|break;
operator|*
name|comments
operator|=
literal|1
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|bp
operator|+
literal|1
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
name|bp
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
block|{
name|int
name|quotec
decl_stmt|;
for|for
control|(
name|quotec
operator|=
operator|*
name|bp
operator|++
init|;
name|bp
operator|+
literal|1
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|!=
name|quotec
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
condition|)
block|{
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
operator|++
operator|*
name|newlines
expr_stmt|;
if|if
condition|(
name|quotec
operator|==
literal|'\''
condition|)
break|break;
block|}
block|}
block|}
break|break;
case|case
literal|','
case|:
if|if
condition|(
operator|(
operator|*
name|depthptr
operator|)
operator|==
literal|0
condition|)
return|return
name|bp
return|;
break|break;
block|}
name|bp
operator|++
expr_stmt|;
block|}
return|return
name|bp
return|;
block|}
end_block

begin_comment
comment|/* Discard comments and duplicate newlines    in the string of length LENGTH at START,    except inside of string constants.    The string is copied into itself with its beginning staying fixed.       NEWLINES is the number of newlines that must be duplicated.    We assume that that much extra space is available past the end    of the string.  */
end_comment

begin_function
specifier|static
name|int
name|discard_comments
parameter_list|(
name|start
parameter_list|,
name|length
parameter_list|,
name|newlines
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|newlines
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* If we have newlines to duplicate, copy everything      that many characters up.  Then, in the second part,      we will have room to insert the newlines      while copying down.      NEWLINES may actually be too large, because it counts      newlines in string constants, and we don't duplicate those.      But that does no harm.  */
if|if
condition|(
name|newlines
operator|>
literal|0
condition|)
block|{
name|ibp
operator|=
name|start
operator|+
name|length
expr_stmt|;
name|obp
operator|=
name|ibp
operator|+
name|newlines
expr_stmt|;
name|limit
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|limit
operator|!=
name|ibp
condition|)
operator|*
operator|--
name|obp
operator|=
operator|*
operator|--
name|ibp
expr_stmt|;
block|}
name|ibp
operator|=
name|start
operator|+
name|newlines
expr_stmt|;
name|limit
operator|=
name|start
operator|+
name|length
operator|+
name|newlines
expr_stmt|;
name|obp
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* Duplicate the newline.  */
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
comment|/* Delete any comment.  */
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|||
name|ibp
operator|+
literal|1
operator|>=
name|limit
condition|)
break|break;
name|obp
operator|--
expr_stmt|;
name|ibp
operator|++
expr_stmt|;
while|while
condition|(
name|ibp
operator|+
literal|1
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
name|ibp
operator|++
expr_stmt|;
block|}
name|ibp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
comment|/* Notice and skip strings, so that we don't 	 think that comments start inside them, 	 and so we don't duplicate newlines in them.  */
block|{
name|int
name|quotec
init|=
name|c
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quotec
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|quotec
operator|==
literal|'\''
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|ibp
operator|<
name|limit
condition|)
block|{
while|while
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|ibp
operator|+=
literal|2
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
block|}
return|return
name|obp
operator|-
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Core error handling routine.  */
end_comment

begin_function
specifier|static
name|void
name|v_message
parameter_list|(
name|mtype
parameter_list|,
name|line
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|enum
name|msgtype
name|mtype
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fname
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mtype
operator|==
name|MT_WARNING
operator|&&
name|inhibit_warnings
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|line
operator|=
name|instack
index|[
name|i
index|]
operator|.
name|lineno
expr_stmt|;
name|fname
operator|=
name|instack
index|[
name|i
index|]
operator|.
name|fname
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fname
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|fname
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtype
operator|==
name|MT_WARNING
condition|)
name|fputs
argument_list|(
name|_
argument_list|(
literal|"warning: "
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtype
operator|==
name|MT_ERROR
condition|)
name|errors
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * error - print error message and increment count of errors.  */
end_comment

begin_decl_stmt
name|void
name|error
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|v_message
argument_list|(
name|MT_ERROR
argument_list|,
literal|0
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|error_with_line
name|VPARAMS
argument_list|(
operator|(
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|v_message
argument_list|(
name|MT_ERROR
argument_list|,
name|line
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Error including a message from `errno'.  */
end_comment

begin_function
name|void
name|error_from_errno
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|error
argument_list|(
literal|"%s: %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print error message but don't count it.  */
end_comment

begin_decl_stmt
name|void
name|warning
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|v_message
argument_list|(
name|MT_WARNING
argument_list|,
literal|0
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|fatal
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|v_message
argument_list|(
name|MT_FATAL
argument_list|,
literal|0
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the location at which we died.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|(
name|line
parameter_list|,
name|func
parameter_list|)
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"internal error in %s, at tradcpp.c:%d\n\ Please submit a full bug report.\n\ See %s for instructions."
argument_list|,
name|func
argument_list|,
name|line
argument_list|,
name|GCCBUGURL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|perror_with_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the line at which an error occurred.    The error is not necessarily associated with the current spot    in the input stack, so LINE says where.  LINE will have been    copied from ip->lineno for the current input level.    If the current level is for a file, we return LINE.    But if the current level is not for a file, LINE is meaningless.    In that case, we return the lineno of the innermost file.  */
end_comment

begin_function
specifier|static
name|int
name|line_for_error
parameter_list|(
name|line
parameter_list|)
name|int
name|line
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|line1
init|=
name|line
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
literal|0
condition|)
return|return
name|line1
return|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|line1
operator|=
name|instack
index|[
name|i
index|]
operator|.
name|lineno
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * If OBUF doesn't have NEEDED bytes after OPTR, make it bigger.  *  * As things stand, nothing is ever placed in the output buffer to be  * removed again except when it's KNOWN to be part of an identifier,  * so flushing and moving down everything left, instead of expanding,  * should work ok.  */
end_comment

begin_function
specifier|static
name|void
name|grow_outbuf
parameter_list|(
name|obuf
parameter_list|,
name|needed
parameter_list|)
name|FILE_BUF
modifier|*
name|obuf
decl_stmt|;
name|int
name|needed
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|int
name|minsize
decl_stmt|;
if|if
condition|(
name|obuf
operator|->
name|length
operator|-
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
operator|>
name|needed
condition|)
return|return;
comment|/* Make it at least twice as big as it is now.  */
name|obuf
operator|->
name|length
operator|*=
literal|2
expr_stmt|;
comment|/* Make it have at least 150% of the free space we will need.  */
name|minsize
operator|=
operator|(
literal|3
operator|*
name|needed
operator|)
operator|/
literal|2
operator|+
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
expr_stmt|;
if|if
condition|(
name|minsize
operator|>
name|obuf
operator|->
name|length
condition|)
name|obuf
operator|->
name|length
operator|=
name|minsize
expr_stmt|;
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|obuf
operator|->
name|buf
argument_list|,
name|obuf
operator|->
name|length
argument_list|)
expr_stmt|;
name|obuf
operator|->
name|bufp
operator|=
name|p
operator|+
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
expr_stmt|;
name|obuf
operator|->
name|buf
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Symbol table for macro names and special symbols */
end_comment

begin_comment
comment|/*  * install a name in the main hash table, even if it is already there.  *   name stops with first non alphanumeric, except leading '#'.  * caller must check against redefinition if that is desired.  * delete_macro () removes things installed by install () in fifo order.  * this is important because of the `defined' special symbol used  * in #if, and also if pushdef/popdef directives are ever implemented.  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.  *  * caller must set the value, if any is desired.  */
end_comment

begin_function
specifier|static
name|HASHNODE
modifier|*
name|install
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|,
name|hash
parameter_list|)
specifier|const
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
name|int
name|hash
decl_stmt|;
comment|/* watch out here if sizeof (U_CHAR *) != sizeof (int) */
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|int
name|bucket
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|U_CHAR
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
name|is_idchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hash
expr_stmt|;
name|hp
operator|->
name|bucket_hdr
operator|=
operator|&
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hp
operator|->
name|next
operator|=
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hashtab
index|[
name|bucket
index|]
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|hp
operator|->
name|name
operator|=
name|q
operator|=
operator|(
operator|(
name|U_CHAR
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|q
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|q
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/*  * find the most recent hash node for name name (ending with first  * non-identifier char) installed by install  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.  */
end_comment

begin_function
name|HASHNODE
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
specifier|const
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|const
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
name|HASHNODE
modifier|*
name|bucket
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|bp
operator|=
name|name
init|;
name|is_idchar
argument_list|(
operator|*
name|bp
argument_list|)
condition|;
name|bp
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|bp
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hashtab
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|length
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|bucket
operator|->
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bucket
return|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a hash node.  Some weirdness to free junk from macros.  * More such weirdness will have to be added if you define more hash  * types that need it.  */
end_comment

begin_comment
comment|/* Note that the DEFINITION of a macro is removed from the hash table    but its storage is not freed.  This would be a storage leak    except that it is not reasonable to keep undefining and redefining    large numbers of macros many times.    In any case, this is necessary, because a macro can be #undef'd    in the middle of reading the arguments to a call to it.    If #undef freed the DEFINITION, that would crash.  */
end_comment

begin_function
specifier|static
name|void
name|delete_macro
parameter_list|(
name|hp
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
if|if
condition|(
name|hp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|prev
operator|->
name|next
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
operator|->
name|prev
expr_stmt|;
comment|/* make sure that the bucket chain header that      the deleted guy was on points to the right thing afterwards. */
if|if
condition|(
name|hp
operator|==
operator|*
name|hp
operator|->
name|bucket_hdr
condition|)
operator|*
name|hp
operator|->
name|bucket_hdr
operator|=
name|hp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return hash function on name.  must be compatible with the one  * computed a step at a time, elsewhere  */
end_comment

begin_function
specifier|static
name|int
name|hashf
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hashsize
parameter_list|)
specifier|const
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hashsize
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|r
operator|=
name|HASHSTEP
argument_list|(
name|r
argument_list|,
operator|*
name|name
operator|++
argument_list|)
expr_stmt|;
return|return
name|MAKE_POS
argument_list|(
name|r
argument_list|)
operator|%
name|hashsize
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dump all macro definitions as #defines to stdout.  */
end_comment

begin_function
specifier|static
name|void
name|dump_all_macros
parameter_list|()
block|{
name|int
name|bucket
decl_stmt|;
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|HASHSIZE
condition|;
name|bucket
operator|++
control|)
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|hashtab
index|[
name|bucket
index|]
init|;
name|hp
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
block|{
name|DEFINITION
modifier|*
name|defn
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|concat
decl_stmt|;
comment|/* Print the definition of the macro HP.  */
name|printf
argument_list|(
literal|"#define %s"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|defn
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|dump_arg_n
argument_list|(
name|defn
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|defn
operator|->
name|nargs
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|concat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
name|dump_defn_1
argument_list|(
name|defn
operator|->
name|expansion
argument_list|,
name|offset
argument_list|,
name|ap
operator|->
name|nchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|nchars
operator|!=
literal|0
condition|)
name|concat
operator|=
literal|0
expr_stmt|;
name|offset
operator|+=
name|ap
operator|->
name|nchars
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|stringify
condition|)
name|printf
argument_list|(
literal|" #"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|&&
operator|!
name|concat
condition|)
name|printf
argument_list|(
literal|" ## "
argument_list|)
expr_stmt|;
name|concat
operator|=
literal|0
expr_stmt|;
name|dump_arg_n
argument_list|(
name|defn
argument_list|,
name|ap
operator|->
name|argno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|raw_after
condition|)
block|{
name|printf
argument_list|(
literal|" ## "
argument_list|)
expr_stmt|;
name|concat
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|dump_defn_1
argument_list|(
name|defn
operator|->
name|expansion
argument_list|,
name|offset
argument_list|,
name|defn
operator|->
name|length
operator|-
name|offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output to stdout a substring of a macro definition.    BASE is the beginning of the definition.    Output characters START thru LENGTH.    Discard newlines outside of strings, thus    converting funny-space markers to ordinary spaces.  */
end_comment

begin_function
specifier|static
name|void
name|dump_defn_1
parameter_list|(
name|base
parameter_list|,
name|start
parameter_list|,
name|length
parameter_list|)
specifier|const
name|U_CHAR
modifier|*
name|base
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|const
name|U_CHAR
modifier|*
name|p
init|=
name|base
operator|+
name|start
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|limit
init|=
name|base
operator|+
name|start
operator|+
name|length
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\"'
operator|||
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
specifier|const
name|U_CHAR
modifier|*
name|p1
init|=
name|skip_quoted_string
argument_list|(
name|p
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fwrite
argument_list|(
name|p
argument_list|,
name|p1
operator|-
name|p
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
operator|-
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the name of argument number ARGNUM of macro definition DEFN.    Recall that DEFN->argnames contains all the arg names    concatenated in reverse order with comma-space in between.  */
end_comment

begin_function
specifier|static
name|void
name|dump_arg_n
parameter_list|(
name|defn
parameter_list|,
name|argnum
parameter_list|)
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|int
name|argnum
decl_stmt|;
block|{
specifier|const
name|U_CHAR
modifier|*
name|p
init|=
name|defn
operator|->
name|argnames
decl_stmt|;
while|while
condition|(
name|argnum
operator|+
literal|1
operator|<
name|defn
operator|->
name|nargs
condition|)
block|{
name|p
operator|=
operator|(
specifier|const
name|U_CHAR
operator|*
operator|)
name|strchr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|argnum
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the built-in macros.  */
end_comment

begin_define
define|#
directive|define
name|DSC
parameter_list|(
name|x
parameter_list|)
value|U x, sizeof x - 1
end_define

begin_define
define|#
directive|define
name|install_spec
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
define|\
value|install(DSC(name), type, -1);
end_define

begin_define
define|#
directive|define
name|install_value
parameter_list|(
name|name
parameter_list|,
name|val
parameter_list|)
define|\
value|hp = install(DSC(name), T_CONST, -1); hp->value.cpval = val;
end_define

begin_function
specifier|static
name|void
name|initialize_builtins
parameter_list|()
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|install_spec
argument_list|(
literal|"__BASE_FILE__"
argument_list|,
name|T_BASE_FILE
argument_list|)
expr_stmt|;
name|install_spec
argument_list|(
literal|"__DATE__"
argument_list|,
name|T_DATE
argument_list|)
expr_stmt|;
name|install_spec
argument_list|(
literal|"__FILE__"
argument_list|,
name|T_FILE
argument_list|)
expr_stmt|;
name|install_spec
argument_list|(
literal|"__TIME__"
argument_list|,
name|T_TIME
argument_list|)
expr_stmt|;
name|install_spec
argument_list|(
literal|"__VERSION__"
argument_list|,
name|T_VERSION
argument_list|)
expr_stmt|;
name|install_spec
argument_list|(
literal|"__INCLUDE_LEVEL__"
argument_list|,
name|T_INCLUDE_LEVEL
argument_list|)
expr_stmt|;
name|install_spec
argument_list|(
literal|"__LINE__"
argument_list|,
name|T_SPECLINE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
name|install_value
argument_list|(
literal|"__SIZE_TYPE__"
argument_list|,
name|SIZE_TYPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
name|install_value
argument_list|(
literal|"__PTRDIFF_TYPE__"
argument_list|,
name|PTRDIFF_TYPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_WCHAR_TYPE
name|install_value
argument_list|(
literal|"__WCHAR_TYPE__"
argument_list|,
name|WCHAR_TYPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_WINT_TYPE
name|install_value
argument_list|(
literal|"__WINT_TYPE__"
argument_list|,
name|WINT_TYPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|install_value
argument_list|(
literal|"__REGISTER_PREFIX__"
argument_list|,
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
name|install_value
argument_list|(
literal|"__USER_LABEL_PREFIX__"
argument_list|,
name|user_label_prefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|DSC
end_undef

begin_undef
undef|#
directive|undef
name|install_spec
end_undef

begin_undef
undef|#
directive|undef
name|install_value
end_undef

begin_escape
end_escape

begin_comment
comment|/* Common handler of command line directives -U, -D and -A.  */
end_comment

begin_function
specifier|static
name|void
name|run_directive
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
block|{
specifier|const
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
decl_stmt|;
name|ip
operator|->
name|fname
operator|=
literal|"*command line*"
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|str
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|type
operator|!=
name|type
condition|;
name|kt
operator|++
control|)
empty_stmt|;
call|(
modifier|*
name|kt
operator|->
name|func
call|)
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
name|str
argument_list|,
operator|(
name|U_CHAR
operator|*
operator|)
name|str
operator|+
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the -D option.  If STR is just an identifier, define it with  * value 1.  If STR has anything after the identifier, then it should  * be identifier-space-definition.  */
end_comment

begin_function
specifier|static
name|void
name|make_definition
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|count
decl_stmt|;
comment|/* Copy the entire option so we can modify it.       Change the first "=" in the string to a space.  If there is none,      tack " 1" on the end.  */
comment|/* Length including the null.  */
name|count
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|buf
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|' '
expr_stmt|;
else|else
block|{
name|buf
index|[
name|count
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|buf
index|[
name|count
operator|++
index|]
operator|=
literal|'1'
expr_stmt|;
block|}
name|run_directive
argument_list|(
name|buf
argument_list|,
name|count
argument_list|,
name|T_DEFINE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the -U option.  */
end_comment

begin_function
specifier|static
name|void
name|make_undef
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|run_directive
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|T_UNDEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handles the #assert (-A) and #unassert (-A-) command line options.  */
end_comment

begin_function
specifier|static
name|void
name|make_assertion
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|enum
name|node_type
name|type
init|=
name|T_ASSERT
decl_stmt|;
name|size_t
name|count
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|type
operator|=
name|T_UNASSERT
expr_stmt|;
block|}
name|count
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
comment|/* Copy the entire option so we can modify it.  Change the first 	 "=" in the string to a '(', and tack a ')' on the end.  */
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|'('
expr_stmt|;
name|buf
index|[
name|count
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
name|str
operator|=
name|buf
expr_stmt|;
block|}
name|run_directive
argument_list|(
name|str
argument_list|,
name|count
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the file-mode and data size of the file open on FD    and store them in *MODE_POINTER and *SIZE_POINTER.  */
end_comment

begin_function
specifier|static
name|int
name|file_size_and_mode
parameter_list|(
name|fd
parameter_list|,
name|mode_pointer
parameter_list|,
name|size_pointer
parameter_list|)
name|int
name|fd
decl_stmt|;
name|int
modifier|*
name|mode_pointer
decl_stmt|;
name|long
modifier|*
name|size_pointer
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|mode_pointer
condition|)
operator|*
name|mode_pointer
operator|=
name|sbuf
operator|.
name|st_mode
expr_stmt|;
if|if
condition|(
name|size_pointer
condition|)
operator|*
name|size_pointer
operator|=
name|sbuf
operator|.
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

