begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CFG cleanup for trees.    Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_comment
comment|/* Remove any fallthru edge from EV.  Return true if an edge was removed.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|remove_fallthru_edge
argument_list|(
name|VEC
argument_list|(
name|edge
argument_list|,
name|gc
argument_list|)
operator|*
name|ev
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ev
argument_list|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|!=
literal|0
condition|)
block|{
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Disconnect an unreachable block in the control expression starting    at block BB.  */
end_comment

begin_function
specifier|static
name|bool
name|cleanup_control_expr_graph
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|block_stmt_iterator
name|bsi
parameter_list|)
block|{
name|edge
name|taken_edge
decl_stmt|;
name|bool
name|retval
init|=
name|false
decl_stmt|;
name|tree
name|expr
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bool
name|warned
decl_stmt|;
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|COND_EXPR
case|:
name|val
operator|=
name|fold
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SWITCH_EXPR
case|:
name|val
operator|=
name|fold
argument_list|(
name|SWITCH_COND
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|taken_edge
operator|=
name|find_taken_edge
argument_list|(
name|bb
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|taken_edge
condition|)
block|{
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Remove all the edges except the one that is always executed.  */
name|warned
operator|=
name|false
expr_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|e
operator|!=
name|taken_edge
condition|)
block|{
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|fold_undefer_overflow_warnings
argument_list|(
name|true
argument_list|,
name|expr
argument_list|,
name|WARN_STRICT_OVERFLOW_CONDITIONAL
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
name|taken_edge
operator|->
name|probability
operator|+=
name|e
operator|->
name|probability
expr_stmt|;
name|taken_edge
operator|->
name|count
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|retval
operator|=
name|true
expr_stmt|;
block|}
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|warned
condition|)
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
if|if
condition|(
name|taken_edge
operator|->
name|probability
operator|>
name|REG_BR_PROB_BASE
condition|)
name|taken_edge
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
block|}
else|else
name|taken_edge
operator|=
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|taken_edge
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
comment|/* We removed some paths from the cfg.  */
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* A list of all the noreturn calls passed to modify_stmt.    cleanup_control_flow uses it to detect cases where a mid-block    indirect call has been turned into a noreturn call.  When this    happens, all the instructions after the call are no longer    reachable and must be deleted as dead.  */
end_comment

begin_expr_stmt
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|modified_noreturn_calls
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Try to remove superfluous control structures.  */
end_comment

begin_function
specifier|static
name|bool
name|cleanup_control_flow
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|bool
name|retval
init|=
name|false
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
comment|/* Detect cases where a mid-block call is now known not to return.  */
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|modified_noreturn_calls
argument_list|)
condition|)
block|{
name|stmt
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|modified_noreturn_calls
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|!=
name|NULL
operator|&&
name|last_stmt
argument_list|(
name|bb
argument_list|)
operator|!=
name|stmt
operator|&&
name|noreturn_call_p
argument_list|(
name|stmt
argument_list|)
condition|)
name|split_block
argument_list|(
name|bb
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* If the last statement of the block could throw and now cannot, 	 we need to prune cfg.  */
name|retval
operator||=
name|tree_purge_dead_eh_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
continue|continue;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
name|retval
operator||=
name|cleanup_control_expr_graph
argument_list|(
name|bb
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
comment|/* If we had a computed goto which has a compile-time determinable 	 destination, then we can eliminate the goto.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|GOTO_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
operator|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|tree
name|label
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|target_block
decl_stmt|;
name|bool
name|removed_edge
init|=
name|false
decl_stmt|;
comment|/* First look at all the outgoing edges.  Delete any outgoing 	     edges which do not go to the right block.  For the one 	     edge which goes to the right block, fix up its flags.  */
name|label
operator|=
name|TREE_OPERAND
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target_block
operator|=
name|label_to_block
argument_list|(
name|label
argument_list|)
expr_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|target_block
condition|)
block|{
name|removed_edge
operator|=
name|true
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Turn off the EDGE_ABNORMAL flag.  */
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_ABNORMAL
expr_stmt|;
comment|/* And set EDGE_FALLTHRU.  */
name|e
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we removed one or more edges, then we will need to fix the 	     dominators.  It may be possible to incrementally update them.  */
if|if
condition|(
name|removed_edge
condition|)
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Remove the GOTO_EXPR as it is not needed.  The CFG has all the 	     relevant information we need.  */
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|retval
operator|=
name|true
expr_stmt|;
block|}
comment|/* Check for indirect calls that have been turned into 	 noreturn calls.  */
elseif|else
if|if
condition|(
name|noreturn_call_p
argument_list|(
name|stmt
argument_list|)
operator|&&
name|remove_fallthru_edge
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
condition|)
block|{
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|retval
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Return true if basic block BB does nothing except pass control    flow to another block and that we can safely insert a label at    the start of the successor block.     As a precondition, we require that BB be not equal to    ENTRY_BLOCK_PTR.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_forwarder_block_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|bool
name|phi_wanted
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|succ
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
comment|/* BB must have a single outgoing edge.  */
if|if
condition|(
name|single_succ_p
argument_list|(
name|bb
argument_list|)
operator|!=
literal|1
comment|/* If PHI_WANTED is false, BB must not have any PHI nodes. 	 Otherwise, BB must have PHI nodes.  */
operator|||
operator|(
name|phi_nodes
argument_list|(
name|bb
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|!=
name|phi_wanted
comment|/* BB may not be a predecessor of EXIT_BLOCK_PTR.  */
operator|||
name|single_succ
argument_list|(
name|bb
argument_list|)
operator|==
name|EXIT_BLOCK_PTR
comment|/* Nor should this be an infinite loop.  */
operator|||
name|single_succ
argument_list|(
name|bb
argument_list|)
operator|==
name|bb
comment|/* BB may not have an abnormal outgoing edge.  */
operator|||
operator|(
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
condition|)
return|return
name|false
return|;
if|#
directive|if
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|bb
operator|!=
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now walk through the statements backward.  We can ignore labels,      anything else means this is not a forwarder block.  */
for|for
control|(
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|LABEL_EXPR
case|:
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|find_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|bb
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|current_loops
condition|)
block|{
name|basic_block
name|dest
decl_stmt|;
comment|/* Protect loop latches, headers and preheaders.  */
if|if
condition|(
name|bb
operator|->
name|loop_father
operator|->
name|header
operator|==
name|bb
condition|)
return|return
name|false
return|;
name|dest
operator|=
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|loop_father
operator|->
name|header
operator|==
name|dest
condition|)
return|return
name|false
return|;
block|}
comment|/* If we have an EH edge leaving this block, make sure that the      destination of this block has only one predecessor.  This ensures      that we don't get into the situation where we try to remove two      forwarders that go to the same basic block but are handlers for      different EH regions.  */
name|succ
operator|=
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|dest
operator|=
name|succ
operator|->
name|dest
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
block|{
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if BB has at least one abnormal incoming edge.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|has_abnormal_incoming_edge_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* If all the PHI nodes in DEST have alternatives for E1 and E2 and    those alternatives are equal in each of the PHI nodes, then return    true, else return false.  */
end_comment

begin_function
specifier|static
name|bool
name|phi_alternatives_equal
parameter_list|(
name|basic_block
name|dest
parameter_list|,
name|edge
name|e1
parameter_list|,
name|edge
name|e2
parameter_list|)
block|{
name|int
name|n1
init|=
name|e1
operator|->
name|dest_idx
decl_stmt|;
name|int
name|n2
init|=
name|e2
operator|->
name|dest_idx
decl_stmt|;
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|val1
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|n1
argument_list|)
decl_stmt|;
name|tree
name|val2
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|n2
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|val1
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|val2
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operand_equal_for_phi_arg_p
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Removes forwarder block BB.  Returns false if this failed.  If a new    forwarder block is created due to redirection of edges, it is    stored to worklist.  */
end_comment

begin_function
specifier|static
name|bool
name|remove_forwarder_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
modifier|*
modifier|*
name|worklist
parameter_list|)
block|{
name|edge
name|succ
init|=
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
decl_stmt|,
name|e
decl_stmt|,
name|s
decl_stmt|;
name|basic_block
name|dest
init|=
name|succ
operator|->
name|dest
decl_stmt|;
name|tree
name|label
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|,
name|bsi_to
decl_stmt|;
name|bool
name|seen_abnormal_edge
init|=
name|false
decl_stmt|;
comment|/* We check for infinite loops already in tree_forwarder_block_p.      However it may happen that the infinite loop is created      afterwards due to removal of forwarders.  */
if|if
condition|(
name|dest
operator|==
name|bb
condition|)
return|return
name|false
return|;
comment|/* If the destination block consists of a nonlocal label, do not merge      it.  */
name|label
operator|=
name|first_stmt
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|&&
name|TREE_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|LABEL_EXPR
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|label
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If there is an abnormal edge to basic block BB, but not into      dest, problems might occur during removal of the phi node at out      of ssa due to overlapping live ranges of registers.       If there is an abnormal edge in DEST, the problems would occur      anyway since cleanup_dead_labels would then merge the labels for      two different eh regions, and rest of exception handling code      does not like it.       So if there is an abnormal edge to BB, proceed only if there is      no abnormal edge to DEST and there are no phi nodes in DEST.  */
if|if
condition|(
name|has_abnormal_incoming_edge_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|seen_abnormal_edge
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|has_abnormal_incoming_edge_p
argument_list|(
name|dest
argument_list|)
operator|||
name|phi_nodes
argument_list|(
name|dest
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|false
return|;
block|}
comment|/* If there are phi nodes in DEST, and some of the blocks that are      predecessors of BB are also predecessors of DEST, check that the      phi node arguments match.  */
if|if
condition|(
name|phi_nodes
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
name|s
operator|=
name|find_edge
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
continue|continue;
if|if
condition|(
operator|!
name|phi_alternatives_equal
argument_list|(
name|dest
argument_list|,
name|succ
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* Redirect the edges.  */
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
comment|/* If there is an abnormal edge, redirect it anyway, and 	     move the labels to the new block to make it legal.  */
name|s
operator|=
name|redirect_edge_succ_nodup
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|=
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|e
condition|)
block|{
comment|/* Create arguments for the phi nodes, since the edge was not 	     here before.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|succ
operator|->
name|dest_idx
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The source basic block might become a forwarder.  We know 	     that it was not a forwarder before, since it used to have 	     at least two outgoing edges, so we may just add it to 	     worklist.  */
if|if
condition|(
name|tree_forwarder_block_p
argument_list|(
name|s
operator|->
name|src
argument_list|,
name|false
argument_list|)
condition|)
operator|*
operator|(
operator|*
name|worklist
operator|)
operator|++
operator|=
name|s
operator|->
name|src
expr_stmt|;
block|}
block|}
if|if
condition|(
name|seen_abnormal_edge
condition|)
block|{
comment|/* Move the labels to the new block, so that the redirection of 	 the abnormal edges works.  */
name|bsi_to
operator|=
name|bsi_start
argument_list|(
name|dest
argument_list|)
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
control|)
block|{
name|label
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|LABEL_EXPR
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi_to
argument_list|,
name|label
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update the dominators.  */
if|if
condition|(
name|dom_info_available_p
argument_list|(
name|CDI_DOMINATORS
argument_list|)
condition|)
block|{
name|basic_block
name|dom
decl_stmt|,
name|dombb
decl_stmt|,
name|domdest
decl_stmt|;
name|dombb
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|domdest
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|domdest
operator|==
name|bb
condition|)
block|{
comment|/* Shortcut to avoid calling (relatively expensive) 	     nearest_common_dominator unless necessary.  */
name|dom
operator|=
name|dombb
expr_stmt|;
block|}
else|else
name|dom
operator|=
name|nearest_common_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|domdest
argument_list|,
name|dombb
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dest
argument_list|,
name|dom
argument_list|)
expr_stmt|;
block|}
comment|/* And kill the forwarder block.  */
name|delete_basic_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Removes forwarder blocks.  */
end_comment

begin_function
specifier|static
name|bool
name|cleanup_forwarder_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|basic_block
modifier|*
name|worklist
init|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|current
init|=
name|worklist
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|tree_forwarder_block_p
argument_list|(
name|bb
argument_list|,
name|false
argument_list|)
condition|)
operator|*
name|current
operator|++
operator|=
name|bb
expr_stmt|;
block|}
while|while
condition|(
name|current
operator|!=
name|worklist
condition|)
block|{
name|bb
operator|=
operator|*
operator|--
name|current
expr_stmt|;
name|changed
operator||=
name|remove_forwarder_block
argument_list|(
name|bb
argument_list|,
operator|&
name|current
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Do one round of CFG cleanup.  */
end_comment

begin_function
specifier|static
name|bool
name|cleanup_tree_cfg_1
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|retval
decl_stmt|;
name|retval
operator|=
name|cleanup_control_flow
argument_list|()
expr_stmt|;
name|retval
operator||=
name|delete_unreachable_blocks
argument_list|()
expr_stmt|;
comment|/* Forwarder blocks can carry line number information which is      useful when debugging, so we only clean them up when      optimizing.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
comment|/* cleanup_forwarder_blocks can redirect edges out of 	 SWITCH_EXPRs, which can get expensive.  So we want to enable 	 recording of edge to CASE_LABEL_EXPR mappings around the call 	 to cleanup_forwarder_blocks.  */
name|start_recording_case_labels
argument_list|()
expr_stmt|;
name|retval
operator||=
name|cleanup_forwarder_blocks
argument_list|()
expr_stmt|;
name|end_recording_case_labels
argument_list|()
expr_stmt|;
block|}
comment|/* Merging the blocks may create new opportunities for folding      conditional branches (due to the elimination of single-valued PHI      nodes).  */
name|retval
operator||=
name|merge_seq_blocks
argument_list|()
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Remove unreachable blocks and other miscellaneous clean up work.    Return true if the flowgraph was modified, false otherwise.  */
end_comment

begin_function
name|bool
name|cleanup_tree_cfg
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|retval
decl_stmt|,
name|changed
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_TREE_CLEANUP_CFG
argument_list|)
expr_stmt|;
comment|/* Iterate until there are no more cleanups left to do.  If any      iteration changed the flowgraph, set CHANGED to true.  */
name|changed
operator|=
name|false
expr_stmt|;
do|do
block|{
name|retval
operator|=
name|cleanup_tree_cfg_1
argument_list|()
expr_stmt|;
name|changed
operator||=
name|retval
expr_stmt|;
block|}
do|while
condition|(
name|retval
condition|)
do|;
name|compact_blocks
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|timevar_pop
argument_list|(
name|TV_TREE_CLEANUP_CFG
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Cleanup cfg and repair loop structures.  */
end_comment

begin_function
name|void
name|cleanup_tree_cfg_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|changed
init|=
name|cleanup_tree_cfg
argument_list|()
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|bitmap
name|changed_bbs
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|fix_loop_structure
argument_list|(
name|current_loops
argument_list|,
name|changed_bbs
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* This usually does nothing.  But sometimes parts of cfg that originally 	 were inside a loop get out of it due to edge removal (since they 	 become unreachable by back edges from latch).  */
name|rewrite_into_loop_closed_ssa
argument_list|(
name|changed_bbs
argument_list|,
name|TODO_update_ssa
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|changed_bbs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_loop_structure
argument_list|(
name|current_loops
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scev_reset
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Merge the PHI nodes at BB into those at BB's sole successor.  */
end_comment

begin_function
specifier|static
name|void
name|remove_forwarder_block_with_phi
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|succ
init|=
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|basic_block
name|dest
init|=
name|succ
operator|->
name|dest
decl_stmt|;
name|tree
name|label
decl_stmt|;
name|basic_block
name|dombb
decl_stmt|,
name|domdest
decl_stmt|,
name|dom
decl_stmt|;
comment|/* We check for infinite loops already in tree_forwarder_block_p.      However it may happen that the infinite loop is created      afterwards due to removal of forwarders.  */
if|if
condition|(
name|dest
operator|==
name|bb
condition|)
return|return;
comment|/* If the destination block consists of a nonlocal label, do not      merge it.  */
name|label
operator|=
name|first_stmt
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|&&
name|TREE_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|LABEL_EXPR
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|label
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Redirect each incoming edge to BB to DEST.  */
while|while
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
operator|>
literal|0
condition|)
block|{
name|edge
name|e
init|=
name|EDGE_PRED
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|s
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|s
operator|=
name|find_edge
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
comment|/* We already have an edge S from E->src to DEST.  If S and 	     E->dest's sole successor edge have the same PHI arguments 	     at DEST, redirect S to DEST.  */
if|if
condition|(
name|phi_alternatives_equal
argument_list|(
name|dest
argument_list|,
name|s
argument_list|,
name|succ
argument_list|)
condition|)
block|{
name|e
operator|=
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
continue|continue;
block|}
comment|/* PHI arguments are different.  Create a forwarder block by 	     splitting E so that we can merge PHI arguments on E to 	     DEST.  */
name|e
operator|=
name|single_succ_edge
argument_list|(
name|split_edge
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* redirect_edge_and_branch must not create a new edge.  */
name|gcc_assert
argument_list|(
name|s
operator|==
name|e
argument_list|)
expr_stmt|;
comment|/* Add to the PHI nodes at DEST each PHI argument removed at the 	 destination of E.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|def
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|succ
operator|->
name|dest_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|var
decl_stmt|;
comment|/* If DEF is one of the results of PHI nodes removed during 		 redirection, replace it with the PHI argument that used 		 to be on E.  */
for|for
control|(
name|var
operator|=
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
init|;
name|var
condition|;
name|var
operator|=
name|TREE_CHAIN
argument_list|(
name|var
argument_list|)
control|)
block|{
name|tree
name|old_arg
init|=
name|TREE_PURPOSE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|tree
name|new_arg
init|=
name|TREE_VALUE
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|def
operator|==
name|old_arg
condition|)
block|{
name|def
operator|=
name|new_arg
expr_stmt|;
break|break;
block|}
block|}
block|}
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|def
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Update the dominators.  */
name|dombb
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|domdest
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|domdest
operator|==
name|bb
condition|)
block|{
comment|/* Shortcut to avoid calling (relatively expensive) 	 nearest_common_dominator unless necessary.  */
name|dom
operator|=
name|dombb
expr_stmt|;
block|}
else|else
name|dom
operator|=
name|nearest_common_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|domdest
argument_list|,
name|dombb
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dest
argument_list|,
name|dom
argument_list|)
expr_stmt|;
comment|/* Remove BB since all of BB's incoming edges have been redirected      to DEST.  */
name|delete_basic_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This pass merges PHI nodes if one feeds into another.  For example,    suppose we have the following:    goto<bb 9> (<L9>);<L8>:;   tem_17 = foo ();    # tem_6 = PHI<tem_17(8), tem_23(7)>;<L9>:;    # tem_3 = PHI<tem_6(9), tem_2(5)>;<L10>:;    Then we merge the first PHI node into the second one like so:    goto<bb 9> (<L10>);<L8>:;   tem_17 = foo ();    # tem_3 = PHI<tem_23(7), tem_2(5), tem_17(8)>;<L10>:; */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|merge_phi_nodes
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
modifier|*
name|worklist
init|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|current
init|=
name|worklist
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Find all PHI nodes that we may be able to merge.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|basic_block
name|dest
decl_stmt|;
comment|/* Look for a forwarder block with PHI nodes.  */
if|if
condition|(
operator|!
name|tree_forwarder_block_p
argument_list|(
name|bb
argument_list|,
name|true
argument_list|)
condition|)
continue|continue;
name|dest
operator|=
name|single_succ
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* We have to feed into another basic block with PHI 	 nodes.  */
if|if
condition|(
operator|!
name|phi_nodes
argument_list|(
name|dest
argument_list|)
comment|/* We don't want to deal with a basic block with 	     abnormal edges.  */
operator|||
name|has_abnormal_incoming_edge_p
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dest
argument_list|,
name|bb
argument_list|)
condition|)
block|{
comment|/* If BB does not dominate DEST, then the PHI nodes at 	     DEST must be the only users of the results of the PHI 	     nodes at BB.  */
operator|*
name|current
operator|++
operator|=
name|bb
expr_stmt|;
block|}
else|else
block|{
name|tree
name|phi
decl_stmt|;
name|unsigned
name|int
name|dest_idx
init|=
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|dest_idx
decl_stmt|;
comment|/* BB dominates DEST.  There may be many users of the PHI 	     nodes in BB.  However, there is still a trivial case we 	     can handle.  If the result of every PHI in BB is used 	     only by a PHI in DEST, then we can trivially merge the 	     PHI nodes from BB into DEST.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|result
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|use_operand_p
name|imm_use
decl_stmt|;
name|tree
name|use_stmt
decl_stmt|;
comment|/* If the PHI's result is never used, then we can just 		 ignore it.  */
if|if
condition|(
name|has_zero_uses
argument_list|(
name|result
argument_list|)
condition|)
continue|continue;
comment|/* Get the single use of the result of this PHI node.  */
if|if
condition|(
operator|!
name|single_imm_use
argument_list|(
name|result
argument_list|,
operator|&
name|imm_use
argument_list|,
operator|&
name|use_stmt
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|!=
name|PHI_NODE
operator|||
name|bb_for_stmt
argument_list|(
name|use_stmt
argument_list|)
operator|!=
name|dest
operator|||
name|PHI_ARG_DEF
argument_list|(
name|use_stmt
argument_list|,
name|dest_idx
argument_list|)
operator|!=
name|result
condition|)
break|break;
block|}
comment|/* If the loop above iterated through all the PHI nodes 	     in BB, then we can merge the PHIs from BB into DEST.  */
if|if
condition|(
operator|!
name|phi
condition|)
operator|*
name|current
operator|++
operator|=
name|bb
expr_stmt|;
block|}
block|}
comment|/* Now let's drain WORKLIST.  */
while|while
condition|(
name|current
operator|!=
name|worklist
condition|)
block|{
name|bb
operator|=
operator|*
operator|--
name|current
expr_stmt|;
name|remove_forwarder_block_with_phi
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_merge_phi
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_merge_phi
init|=
block|{
literal|"mergephi"
block|,
comment|/* name */
name|gate_merge_phi
block|,
comment|/* gate */
name|merge_phi_nodes
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_MERGE_PHI
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
comment|/* todo_flags_finish */
operator||
name|TODO_verify_ssa
block|,
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

