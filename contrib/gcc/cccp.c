begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C Compatible Compiler Preprocessor (CCCP)    Copyright (C) 1986, 87, 89, 92-98, 1999 Free Software Foundation, Inc.    Written by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|unsigned
name|char
name|U_CHAR
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"pcp.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"prefix.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|"mbchar.h"
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE_CHARS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GET_ENV_PATH_LIST
end_ifndef

begin_define
define|#
directive|define
name|GET_ENV_PATH_LIST
parameter_list|(
name|VAR
parameter_list|,
name|NAME
parameter_list|)
value|do { (VAR) = getenv (NAME); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_INCLUDE_DIR
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_INCLUDE_DIR
value|"/usr/include"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default, colon separates directories in a path.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default, a slash separates directory names.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DIR_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|DIR_SEPARATOR
value|'/'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default, the suffix for object files is ".o".  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_SUFFIX
end_ifdef

begin_define
define|#
directive|define
name|HAVE_OBJECT_SUFFIX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OBJECT_SUFFIX
value|".o"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS-specific definitions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<descrip.h>
end_include

begin_include
include|#
directive|include
file|<ssdef.h>
end_include

begin_include
include|#
directive|include
file|<syidef.h>
end_include

begin_define
define|#
directive|define
name|open
parameter_list|(
name|fname
parameter_list|,
name|mode
parameter_list|,
name|prot
parameter_list|)
value|VMS_open (fname,mode,prot)
end_define

begin_define
define|#
directive|define
name|fopen
parameter_list|(
name|fname
parameter_list|,
name|mode
parameter_list|)
value|VMS_fopen (fname,mode)
end_define

begin_define
define|#
directive|define
name|freopen
parameter_list|(
name|fname
parameter_list|,
name|mode
parameter_list|,
name|ofile
parameter_list|)
value|VMS_freopen (fname,mode,ofile)
end_define

begin_define
define|#
directive|define
name|fstat
parameter_list|(
name|fd
parameter_list|,
name|stbuf
parameter_list|)
value|VMS_fstat (fd,stbuf)
end_define

begin_decl_stmt
specifier|static
name|int
name|VMS_fstat
argument_list|()
decl_stmt|,
name|VMS_stat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|VMS_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|VMS_fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|VMS_freopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hack_vms_include_specification
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(!bcmp((char *)&(a), (char *)&(b), sizeof (a)))
end_define

begin_define
define|#
directive|define
name|INO_T_HASH
parameter_list|(
name|a
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|INCLUDE_LEN_FUDGE
value|12
end_define

begin_comment
comment|/* leave room for VMS syntax conversion */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/* Windows does not natively support inodes, and neither does MSDOS.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_UWIN
argument_list|)
operator|)
expr|\
operator|||
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
end_if

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INO_T_EQ
end_ifndef

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) == (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INO_T_HASH
end_ifndef

begin_define
define|#
directive|define
name|INO_T_HASH
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INCLUDE_LEN_FUDGE
end_ifndef

begin_define
define|#
directive|define
name|INCLUDE_LEN_FUDGE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* External declarations.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDEST_INT
name|parse_escape
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|HOST_WIDEST_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDEST_INT
name|parse_c_expression
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Name under which this program was invoked.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use extra default include directories for C++.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cplusplus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means handle cplusplus style comments */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cplusplus_comments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means handle #import, for objective C.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|objc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means this is an assembly file, and allow    unknown directives, which could be comments.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lang_asm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current maximum length of directory names in the search path    for include files.  (Altered as we get more of them.)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_include_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means turn NOTREACHED into #pragma NOTREACHED etc */
end_comment

begin_decl_stmt
specifier|static
name|int
name|for_lint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means copy comments into the output file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|put_out_comments
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't process the ANSI trigraph sequences.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_trigraphs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print the names of included files rather than    the preprocessed output.  1 means just the #include "...",    2 means #include<...> as well.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_deps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if missing .h files in -M output are assumed to be generated    files and not errors.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_deps_missing_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print names of header files (-H).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_include_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't output line number information.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_line_directives
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means output the text in failing conditionals,    inside #failed ... #endfailed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_conditionals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dump_only means inhibit output of the preprocessed text              and instead output the definitions of all user-defined              macros in a form suitable for use as input to cccp.    dump_names means pass #define and the macro name through to output.    dump_definitions means pass the whole definition (plus #define) through */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|dump_none
block|,
name|dump_only
block|,
name|dump_names
block|,
name|dump_definitions
block|}
name|dump_macros
init|=
name|dump_none
enum|;
end_enum

begin_comment
comment|/* Nonzero means pass all #define and #undef directives which we actually    process through to the output stream.  This feature is used primarily    to allow cc1 to record the #defines and #undefs for the sake of    debuggers which understand about preprocessor macros, but it may    also be useful with -E to figure out how symbols are defined, and    where they are defined.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means pass #include lines through to the output,    even if they are ifdefed out.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_includes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero indicates special processing used by the pcp program.  The    special effects of this mode are:             Inhibit all macro expansion, except those inside #if directives.       Process #define directives normally, and output their contents       to the output file.       Output preconditions to pcp_outfile indicating all the relevant      preconditions for use of this file in a later cpp run. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|pcp_outfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we are inside an IF during a -pcp run.  In this mode    macro expansion is done, and preconditions are output for all macro    uses requiring them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pcp_inside_if
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means never to include precompiled files.    This is 1 since there's no way now to make precompiled files,    so it's not worth testing for them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_precomp
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give all the error messages the ANSI standard requires.  */
end_comment

begin_decl_stmt
name|int
name|pedantic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means try to make failure to fit ANSI C an error.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pedantic_errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't print warning messages.  -w.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inhibit_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if slash-star appears in a slash-star comment,    or if newline-backslash appears in a slash-slash comment.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_comments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if a macro argument is (or would be)    stringified with -traditional.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_stringify
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if there are any trigraphs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_trigraphs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if undefined identifiers are evaluated in an #if.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_undef
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if #import is used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_import
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means turn warnings into errors.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warnings_are_errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means try to imitate old fashioned non-ANSI preprocessor.  */
end_comment

begin_decl_stmt
name|int
name|traditional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for the 1989 C Standard, including corrigenda and amendments.  */
end_comment

begin_decl_stmt
name|int
name|c89
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for the 199x C Standard.  */
end_comment

begin_decl_stmt
name|int
name|c9x
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero causes output not to be done,    but directives such as #define that have side effects    are still obeyed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we should look for header.gcc files that remap file names.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means this file was included with a -imacros or -include    command line and should not be recorded as an include file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_record_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that we have finished processing the command line options.    This flag is used to decide whether or not to issue certain errors    and/or warnings.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|done_initializing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line where a newline was first seen in a string constant.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|multiline_string_line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* I/O buffer structure.    The `fname' field is nonzero for source files and #include files    and for the dummy text used for -D and -U.    It is zero for rescanning results of macro expansion    and for expanding macro arguments.  */
end_comment

begin_define
define|#
directive|define
name|INPUT_STACK_MAX
value|400
end_define

begin_struct
specifier|static
struct|struct
name|file_buf
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Filename specified with #line directive.  */
name|char
modifier|*
name|nominal_fname
decl_stmt|;
comment|/* The length of nominal_fname, which may contain embedded NULs.  */
name|size_t
name|nominal_fname_len
decl_stmt|;
comment|/* Include file description.  */
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|;
comment|/* Record where in the search path this file was found.      For #include_next.  */
name|struct
name|file_name_list
modifier|*
name|dir
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|int
name|length
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|bufp
decl_stmt|;
comment|/* Macro that this level is the expansion of.      Included so that we can reenable the macro      at the end of this level.  */
name|struct
name|hashnode
modifier|*
name|macro
decl_stmt|;
comment|/* Value of if_stack at start of this file.      Used to prohibit unmatched #endif (etc) in an include file.  */
name|struct
name|if_stack
modifier|*
name|if_stack
decl_stmt|;
comment|/* Object to be freed at end of input at this level.  */
name|U_CHAR
modifier|*
name|free_ptr
decl_stmt|;
comment|/* True if this is a system header file; see is_system_include.  */
name|char
name|system_header_p
decl_stmt|;
block|}
name|instack
index|[
name|INPUT_STACK_MAX
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|last_error_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented each time we print it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|input_file_stack_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented when the status changes.  */
end_comment

begin_comment
comment|/* Current nesting level of input sources.    `instack[indepth]' is the level currently being read.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|indepth
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHECK_DEPTH
parameter_list|(
name|code
parameter_list|)
define|\
value|if (indepth>= (INPUT_STACK_MAX - 1))					\     {									\       error_with_line (line_for_error (instack[indepth].lineno),	\ 		       "macro or `#include' recursion too deep");	\       code;								\     }
end_define

begin_comment
comment|/* Current depth in #include directives that use<...>.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|system_include_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|file_buf
name|FILE_BUF
typedef|;
end_typedef

begin_comment
comment|/* The output buffer.  Its LENGTH field is the amount of room allocated    for the buffer, not the number of chars actually present.  To get    that, subtract outbuf.buf from outbuf.bufp.  */
end_comment

begin_define
define|#
directive|define
name|OUTBUF_SIZE
value|10
end_define

begin_comment
comment|/* initial size of output buffer */
end_comment

begin_decl_stmt
specifier|static
name|FILE_BUF
name|outbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Grow output buffer OBUF points at    so it can hold at least NEEDED more chars.  */
end_comment

begin_define
define|#
directive|define
name|check_expand
parameter_list|(
name|OBUF
parameter_list|,
name|NEEDED
parameter_list|)
define|\
value|(((OBUF)->length - ((OBUF)->bufp - (OBUF)->buf)<= (NEEDED))   \    ? grow_outbuf ((OBUF), (NEEDED)) : 0)
end_define

begin_struct
struct|struct
name|file_name_list
block|{
name|struct
name|file_name_list
modifier|*
name|next
decl_stmt|;
comment|/* If the following is 1, it is a C-language system include        directory.  */
name|int
name|c_system_include_path
decl_stmt|;
comment|/* Mapping of file names for this directory.  */
name|struct
name|file_name_map
modifier|*
name|name_map
decl_stmt|;
comment|/* Non-zero if name_map is valid.  */
name|int
name|got_name_map
decl_stmt|;
comment|/* The include directory status.  */
name|struct
name|stat
name|st
decl_stmt|;
comment|/* The include prefix: "" denotes the working directory,        otherwise fname must end in '/'.        The actual size is dynamically allocated.  */
name|char
name|fname
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* #include "file" looks in source file dir, then stack.  */
end_comment

begin_comment
comment|/* #include<file> just looks in the stack.  */
end_comment

begin_comment
comment|/* -I directories are added to the end, then the defaults are added.  */
end_comment

begin_comment
comment|/* The */
end_comment

begin_struct
specifier|static
struct|struct
name|default_include
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* The name of the directory.  */
name|char
modifier|*
name|component
decl_stmt|;
comment|/* The component containing the directory */
name|int
name|cplusplus
decl_stmt|;
comment|/* Only look here if we're compiling C++.  */
name|int
name|cxx_aware
decl_stmt|;
comment|/* Includes in this directory don't need to 				   be wrapped in extern "C" when compiling 				   C++.  */
name|int
name|included
decl_stmt|;
comment|/* Set if the directory is acceptable.  */
block|}
name|include_defaults_array
index|[]
ifdef|#
directive|ifdef
name|INCLUDE_DEFAULTS
init|=
name|INCLUDE_DEFAULTS
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|=
block|{
comment|/* Pick up GNU C++ specific include files.  */
block|{
name|GPLUSPLUS_INCLUDE_DIR
block|,
literal|"G++"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|CROSS_COMPILE
comment|/* This is the dir for fixincludes.  Put it just before        the files that we fix.  */
block|{
name|GCC_INCLUDE_DIR
block|,
literal|"GCC"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* For cross-compilation, this dir name is generated        automatically in Makefile.in.  */
block|{
name|CROSS_INCLUDE_DIR
block|,
literal|"GCC"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|TOOL_INCLUDE_DIR
comment|/* This is another place that the target system's headers might be.  */
block|{
name|TOOL_INCLUDE_DIR
block|,
literal|"BINUTILS"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
else|#
directive|else
comment|/* not CROSS_COMPILE */
ifdef|#
directive|ifdef
name|LOCAL_INCLUDE_DIR
comment|/* This should be /usr/local/include and should come before        the fixincludes-fixed header files.  */
block|{
name|LOCAL_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TOOL_INCLUDE_DIR
comment|/* This is here ahead of GCC_INCLUDE_DIR because assert.h goes here.        Likewise, behind LOCAL_INCLUDE_DIR, where glibc puts its assert.h.  */
block|{
name|TOOL_INCLUDE_DIR
block|,
literal|"BINUTILS"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* This is the dir for fixincludes.  Put it just before        the files that we fix.  */
block|{
name|GCC_INCLUDE_DIR
block|,
literal|"GCC"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Some systems have an extra dir of include files.  */
ifdef|#
directive|ifdef
name|SYSTEM_INCLUDE_DIR
block|{
name|SYSTEM_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|STANDARD_INCLUDE_COMPONENT
define|#
directive|define
name|STANDARD_INCLUDE_COMPONENT
value|0
endif|#
directive|endif
block|{
name|STANDARD_INCLUDE_DIR
block|,
name|STANDARD_INCLUDE_COMPONENT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* not CROSS_COMPILE */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no INCLUDE_DEFAULTS */
end_comment

begin_comment
comment|/* The code looks at the defaults through this pointer, rather than through    the constant structure above.  This pointer gets changed if an environment    variable specifies other defaults.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|default_include
modifier|*
name|include_defaults
init|=
name|include_defaults_array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First dir to search */
end_comment

begin_comment
comment|/* First dir to search for<file> */
end_comment

begin_comment
comment|/* This is the first element to use for #include<...>.    If it is 0, use the entire chain for such includes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|first_bracket_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the first element in the chain that corresponds to    a directory of system header files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|first_system_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|last_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_comment
comment|/* Chain of include directories to put at the end of the other chain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|after_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|last_after_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_comment
comment|/* Chain to put at the start of the system include files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|before_system
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|last_before_system
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_comment
comment|/* Directory prefix that should replace `/usr' in the standard    include file directories.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|include_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maintain and search list of included files.  */
end_comment

begin_struct
struct|struct
name|include_file
block|{
name|struct
name|include_file
modifier|*
name|next
decl_stmt|;
comment|/* for include_hashtab */
name|struct
name|include_file
modifier|*
name|next_ino
decl_stmt|;
comment|/* for include_ino_hashtab */
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* If the following is the empty string, it means #pragma once      was seen in this include file, or #import was applied to the file.      Otherwise, if it is nonzero, it is a macro name.      Don't include the file again if that macro is defined.  */
name|U_CHAR
modifier|*
name|control_macro
decl_stmt|;
comment|/* Nonzero if the dependency on this include file has been output.  */
name|int
name|deps_output
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hash tables of files already included with #include or #import.    include_hashtab is by full name; include_ino_hashtab is by inode number.  */
end_comment

begin_define
define|#
directive|define
name|INCLUDE_HASHSIZE
value|61
end_define

begin_decl_stmt
specifier|static
name|struct
name|include_file
modifier|*
name|include_hashtab
index|[
name|INCLUDE_HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|include_file
modifier|*
name|include_ino_hashtab
index|[
name|INCLUDE_HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global list of strings read in from precompiled files.  This list    is kept in the order the strings are read in, with new strings being    added at the end through stringlist_tailp.  We use this list to output    the strings at the end of the run.  */
end_comment

begin_decl_stmt
specifier|static
name|STRINGDEF
modifier|*
name|stringlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|STRINGDEF
modifier|*
modifier|*
name|stringlist_tailp
init|=
operator|&
name|stringlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure returned by create_definition */
end_comment

begin_typedef
typedef|typedef
name|struct
name|macrodef
name|MACRODEF
typedef|;
end_typedef

begin_struct
struct|struct
name|macrodef
block|{
name|struct
name|definition
modifier|*
name|defn
decl_stmt|;
name|U_CHAR
modifier|*
name|symnam
decl_stmt|;
name|int
name|symlen
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_enum
enum|enum
name|sharp_token_type
block|{
name|NO_SHARP_TOKEN
init|=
literal|0
block|,
comment|/* token not present */
name|SHARP_TOKEN
init|=
literal|'#'
block|,
comment|/* token spelled with # only */
name|WHITE_SHARP_TOKEN
block|,
comment|/* token spelled with # and white space */
name|PERCENT_COLON_TOKEN
init|=
literal|'%'
block|,
comment|/* token spelled with %: only */
name|WHITE_PERCENT_COLON_TOKEN
comment|/* token spelled with %: and white space */
block|}
enum|;
end_enum

begin_comment
comment|/* Structure allocated for every #define.  For a simple replacement    such as    	#define foo bar ,    nargs = -1, the `pattern' list is null, and the expansion is just    the replacement text.  Nargs = 0 means a functionlike macro with no args,    e.g.,        #define getchar() getc (stdin) .    When there are args, the expansion is the replacement text with the    args squashed out, and the reflist is a list describing how to    build the output from the input: e.g., "3 chars, then the 1st arg,    then 9 chars, then the 3rd arg, then 0 chars, then the 2nd arg".    The chars here come from the expansion.  Whatever is left of the    expansion after the last arg-occurrence is copied after that arg.    Note that the reflist can be arbitrarily long---    its length depends on the number of times the arguments appear in    the replacement text, not how many args there are.  Example:    #define f(x) x+x+x+x+x+x+x would have replacement text "++++++" and    pattern list      { (0, 1), (1, 1), (1, 1), ..., (1, 1), NULL }    where (x, y) means (nchars, argno).  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|definition
name|DEFINITION
typedef|;
end_typedef

begin_struct
struct|struct
name|definition
block|{
name|int
name|nargs
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of expansion string */
name|int
name|predefined
decl_stmt|;
comment|/* True if the macro was builtin or */
comment|/* came from the command line */
name|U_CHAR
modifier|*
name|expansion
decl_stmt|;
name|int
name|line
decl_stmt|;
comment|/* Line number of definition */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* File of definition */
name|size_t
name|file_len
decl_stmt|;
comment|/* Length of file (which can contain NULs) */
name|char
name|rest_args
decl_stmt|;
comment|/* Nonzero if last arg. absorbs the rest */
struct|struct
name|reflist
block|{
name|struct
name|reflist
modifier|*
name|next
decl_stmt|;
name|enum
name|sharp_token_type
name|stringify
decl_stmt|;
comment|/* set if a # operator before arg */
name|enum
name|sharp_token_type
name|raw_before
decl_stmt|;
comment|/* set if a ## operator before arg */
name|enum
name|sharp_token_type
name|raw_after
decl_stmt|;
comment|/* set if a ## operator after arg */
name|char
name|rest_args
decl_stmt|;
comment|/* Nonzero if this arg. absorbs the rest */
name|int
name|nchars
decl_stmt|;
comment|/* Number of literal chars to copy before 				   this arg occurrence.  */
name|int
name|argno
decl_stmt|;
comment|/* Number of arg to substitute (origin-0) */
block|}
modifier|*
name|pattern
struct|;
union|union
block|{
comment|/* Names of macro args, concatenated in reverse order        with comma-space between them.        The only use of this is that we warn on redefinition        if this differs between the old and new definitions.  */
name|U_CHAR
modifier|*
name|argnames
decl_stmt|;
block|}
name|args
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* different kinds of things that can appear in the value field    of a hash node.  Actually, this may be useless now.  */
end_comment

begin_union
union|union
name|hashval
block|{
name|char
modifier|*
name|cpval
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|KEYDEF
modifier|*
name|keydef
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/*  * special extension string that can be added to the last macro argument to   * allow it to absorb the "rest" of the arguments when expanded.  Ex:  * 		#define wow(a, b...)		process (b, a, b)  *		{ wow (1, 2, 3); }	->	{ process (2, 3, 1, 2, 3); }  *		{ wow (one, two); }	->	{ process (two, one, two); }  * if this "rest_arg" is used with the concat token '##' and if it is not  * supplied then the token attached to with ## will not be outputted.  Ex:  * 		#define wow (a, b...)		process (b ## , a, ## b)  *		{ wow (1, 2); }		->	{ process (2, 1, 2); }  *		{ wow (one); }		->	{ process (one); {  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rest_extension
index|[]
init|=
literal|"..."
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REST_EXTENSION_LENGTH
value|(sizeof (rest_extension) - 1)
end_define

begin_comment
comment|/* This is the implicit parameter name when using variable number of    parameters for macros using the ISO C 9x extension.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|va_args_name
index|[]
init|=
literal|"__VA_ARGS__"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VA_ARGS_NAME_LENGTH
value|(sizeof (va_args_name) - 1)
end_define

begin_comment
comment|/* The structure of a node in the hash table.  The hash table    has entries for all tokens defined by #define directives (type T_MACRO),    plus some special tokens like __LINE__ (these each have their own    type, and the appropriate code is run when that type of node is seen.    It does not contain control words like "#define", which are recognized    by a separate piece of code.  */
end_comment

begin_comment
comment|/* different flavors of hash nodes --- also used in keyword table */
end_comment

begin_enum
enum|enum
name|node_type
block|{
name|T_DEFINE
init|=
literal|1
block|,
comment|/* the `#define' keyword */
name|T_INCLUDE
block|,
comment|/* the `#include' keyword */
name|T_INCLUDE_NEXT
block|,
comment|/* the `#include_next' keyword */
name|T_IMPORT
block|,
comment|/* the `#import' keyword */
name|T_IFDEF
block|,
comment|/* the `#ifdef' keyword */
name|T_IFNDEF
block|,
comment|/* the `#ifndef' keyword */
name|T_IF
block|,
comment|/* the `#if' keyword */
name|T_ELSE
block|,
comment|/* `#else' */
name|T_PRAGMA
block|,
comment|/* `#pragma' */
name|T_ELIF
block|,
comment|/* `#elif' */
name|T_UNDEF
block|,
comment|/* `#undef' */
name|T_LINE
block|,
comment|/* `#line' */
name|T_ERROR
block|,
comment|/* `#error' */
name|T_WARNING
block|,
comment|/* `#warning' */
name|T_ENDIF
block|,
comment|/* `#endif' */
name|T_SCCS
block|,
comment|/* `#sccs', used on system V.  */
name|T_IDENT
block|,
comment|/* `#ident', used on system V.  */
name|T_ASSERT
block|,
comment|/* `#assert', taken from system V.  */
name|T_UNASSERT
block|,
comment|/* `#unassert', taken from system V.  */
name|T_SPECLINE
block|,
comment|/* special symbol `__LINE__' */
name|T_DATE
block|,
comment|/* `__DATE__' */
name|T_FILE
block|,
comment|/* `__FILE__' */
name|T_BASE_FILE
block|,
comment|/* `__BASE_FILE__' */
name|T_INCLUDE_LEVEL
block|,
comment|/* `__INCLUDE_LEVEL__' */
name|T_VERSION
block|,
comment|/* `__VERSION__' */
name|T_SIZE_TYPE
block|,
comment|/* `__SIZE_TYPE__' */
name|T_PTRDIFF_TYPE
block|,
comment|/* `__PTRDIFF_TYPE__' */
name|T_WCHAR_TYPE
block|,
comment|/* `__WCHAR_TYPE__' */
name|T_USER_LABEL_PREFIX_TYPE
block|,
comment|/* `__USER_LABEL_PREFIX__' */
name|T_REGISTER_PREFIX_TYPE
block|,
comment|/* `__REGISTER_PREFIX__' */
name|T_IMMEDIATE_PREFIX_TYPE
block|,
comment|/* `__IMMEDIATE_PREFIX__' */
name|T_TIME
block|,
comment|/* `__TIME__' */
name|T_CONST
block|,
comment|/* Constant value, used by `__STDC__' */
name|T_MACRO
block|,
comment|/* macro defined by `#define' */
name|T_DISABLED
block|,
comment|/* macro temporarily turned off for rescan */
name|T_SPEC_DEFINED
block|,
comment|/* special `defined' macro for use in #if statements */
name|T_PCSTRING
block|,
comment|/* precompiled string (hashval is KEYDEF *) */
name|T_UNUSED
comment|/* Used for something not defined.  */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|hashnode
block|{
name|struct
name|hashnode
modifier|*
name|next
decl_stmt|;
comment|/* double links for easy deletion */
name|struct
name|hashnode
modifier|*
name|prev
decl_stmt|;
name|struct
name|hashnode
modifier|*
modifier|*
name|bucket_hdr
decl_stmt|;
comment|/* also, a back pointer to this node's hash 				   chain is kept, in case the node is the head 				   of the chain and gets deleted.  */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* type of special token */
name|int
name|length
decl_stmt|;
comment|/* length of token, for quick comparison */
name|U_CHAR
modifier|*
name|name
decl_stmt|;
comment|/* the actual name */
name|union
name|hashval
name|value
decl_stmt|;
comment|/* pointer to expansion, or whatever */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|hashnode
name|HASHNODE
typedef|;
end_typedef

begin_comment
comment|/* Some definitions for the hash table.  The hash function MUST be    computed as shown in hashf () below.  That is because the rescan    loop computes the hash value `on the fly' for most tokens,    in order to avoid the overhead of a lot of procedure calls to    the hashf () function.  Hashf () only exists for the sake of    politeness, for use when speed isn't so important.  */
end_comment

begin_define
define|#
directive|define
name|HASHSIZE
value|1403
end_define

begin_decl_stmt
specifier|static
name|HASHNODE
modifier|*
name|hashtab
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HASHSTEP
parameter_list|(
name|old
parameter_list|,
name|c
parameter_list|)
value|((old<< 2) + c)
end_define

begin_define
define|#
directive|define
name|MAKE_POS
parameter_list|(
name|v
parameter_list|)
value|(v& 0x7fffffff)
end_define

begin_comment
comment|/* make number positive */
end_comment

begin_escape
end_escape

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_comment
comment|/* The string value for __SIZE_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __PTRDIFF_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRDIFF_TYPE
value|"long int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __WCHAR_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|wchar_type
init|=
name|WCHAR_TYPE
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|WCHAR_TYPE
end_undef

begin_comment
comment|/* The string value for __USER_LABEL_PREFIX__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USER_LABEL_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|USER_LABEL_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|user_label_prefix
init|=
name|USER_LABEL_PREFIX
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|USER_LABEL_PREFIX
end_undef

begin_comment
comment|/* The string value for __REGISTER_PREFIX__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __IMMEDIATE_PREFIX__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IMMEDIATE_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|IMMEDIATE_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* In the definition of a #assert name, this structure forms    a list of the individual values asserted.    Each value is itself a list of "tokens".    These are strings that are compared by name.  */
end_comment

begin_struct
struct|struct
name|tokenlist_list
block|{
name|struct
name|tokenlist_list
modifier|*
name|next
decl_stmt|;
name|struct
name|arglist
modifier|*
name|tokens
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|assertion_hashnode
block|{
name|struct
name|assertion_hashnode
modifier|*
name|next
decl_stmt|;
comment|/* double links for easy deletion */
name|struct
name|assertion_hashnode
modifier|*
name|prev
decl_stmt|;
comment|/* also, a back pointer to this node's hash      chain is kept, in case the node is the head      of the chain and gets deleted.  */
name|struct
name|assertion_hashnode
modifier|*
modifier|*
name|bucket_hdr
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of token, for quick comparison */
name|U_CHAR
modifier|*
name|name
decl_stmt|;
comment|/* the actual name */
comment|/* List of token-sequences.  */
name|struct
name|tokenlist_list
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|assertion_hashnode
name|ASSERTION_HASHNODE
typedef|;
end_typedef

begin_comment
comment|/* Some definitions for the hash table.  The hash function MUST be    computed as shown in hashf below.  That is because the rescan    loop computes the hash value `on the fly' for most tokens,    in order to avoid the overhead of a lot of procedure calls to    the hashf function.  hashf only exists for the sake of    politeness, for use when speed isn't so important.  */
end_comment

begin_define
define|#
directive|define
name|ASSERTION_HASHSIZE
value|37
end_define

begin_decl_stmt
specifier|static
name|ASSERTION_HASHNODE
modifier|*
name|assertion_hashtab
index|[
name|ASSERTION_HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means inhibit macroexpansion of what seem to be    assertion tests, in rescan.  For #if.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|assertions_flag
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* `struct directive' defines one #-directive, including how to handle it.  */
end_comment

begin_define
define|#
directive|define
name|DO_PROTO
value|PROTO((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *))
end_define

begin_struct
struct|struct
name|directive
block|{
name|int
name|length
decl_stmt|;
comment|/* Length of name */
name|int
argument_list|(
argument|*func
argument_list|)
name|DO_PROTO
expr_stmt|;
comment|/* Function to handle directive */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of directive */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* Code which describes which directive.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IS_INCLUDE_DIRECTIVE_TYPE
parameter_list|(
name|t
parameter_list|)
define|\
value|((int) T_INCLUDE<= (int) (t)&& (int) (t)<= (int) T_IMPORT)
end_define

begin_comment
comment|/* These functions are declared to return int instead of void since they    are going to be placed in the table and some old compilers have trouble with    pointers to functions returning void.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_assert
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_define
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_elif
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_else
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_endif
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_error
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_ident
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_if
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_include
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_line
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_pragma
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|do_sccs
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|do_unassert
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_undef
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_warning
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_xifdef
name|DO_PROTO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is the actual list of #-directives, most-often-used first.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|directive
name|directive_table
index|[]
init|=
block|{
block|{
literal|6
block|,
name|do_define
block|,
literal|"define"
block|,
name|T_DEFINE
block|}
block|,
block|{
literal|2
block|,
name|do_if
block|,
literal|"if"
block|,
name|T_IF
block|}
block|,
block|{
literal|5
block|,
name|do_xifdef
block|,
literal|"ifdef"
block|,
name|T_IFDEF
block|}
block|,
block|{
literal|6
block|,
name|do_xifdef
block|,
literal|"ifndef"
block|,
name|T_IFNDEF
block|}
block|,
block|{
literal|5
block|,
name|do_endif
block|,
literal|"endif"
block|,
name|T_ENDIF
block|}
block|,
block|{
literal|4
block|,
name|do_else
block|,
literal|"else"
block|,
name|T_ELSE
block|}
block|,
block|{
literal|4
block|,
name|do_elif
block|,
literal|"elif"
block|,
name|T_ELIF
block|}
block|,
block|{
literal|4
block|,
name|do_line
block|,
literal|"line"
block|,
name|T_LINE
block|}
block|,
block|{
literal|7
block|,
name|do_include
block|,
literal|"include"
block|,
name|T_INCLUDE
block|}
block|,
block|{
literal|12
block|,
name|do_include
block|,
literal|"include_next"
block|,
name|T_INCLUDE_NEXT
block|}
block|,
block|{
literal|6
block|,
name|do_include
block|,
literal|"import"
block|,
name|T_IMPORT
block|}
block|,
block|{
literal|5
block|,
name|do_undef
block|,
literal|"undef"
block|,
name|T_UNDEF
block|}
block|,
block|{
literal|5
block|,
name|do_error
block|,
literal|"error"
block|,
name|T_ERROR
block|}
block|,
block|{
literal|7
block|,
name|do_warning
block|,
literal|"warning"
block|,
name|T_WARNING
block|}
block|,
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
block|{
literal|4
block|,
name|do_sccs
block|,
literal|"sccs"
block|,
name|T_SCCS
block|}
block|,
endif|#
directive|endif
block|{
literal|6
block|,
name|do_pragma
block|,
literal|"pragma"
block|,
name|T_PRAGMA
block|}
block|,
block|{
literal|5
block|,
name|do_ident
block|,
literal|"ident"
block|,
name|T_IDENT
block|}
block|,
block|{
literal|6
block|,
name|do_assert
block|,
literal|"assert"
block|,
name|T_ASSERT
block|}
block|,
block|{
literal|8
block|,
name|do_unassert
block|,
literal|"unassert"
block|,
name|T_UNASSERT
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|""
block|,
name|T_UNUSED
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When a directive handler is called,    this points to the # (or the : of the %:) that started the directive.  */
end_comment

begin_decl_stmt
name|U_CHAR
modifier|*
name|directive_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if char can be part of a C identifier.  */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idchar
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if char can be first char of a c identifier.  */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idstart
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if c is horizontal space.  */
end_comment

begin_decl_stmt
specifier|static
name|U_CHAR
name|is_hor_space
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if c is horizontal or vertical space.  */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_space
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SKIP_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_hor_space[*p]) p++; } while (0)
end_define

begin_define
define|#
directive|define
name|SKIP_ALL_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_space[*p]) p++; } while (0)
end_define

begin_decl_stmt
specifier|static
name|int
name|errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error counter for exit code */
end_comment

begin_comment
comment|/* Name of output file, for error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|out_fname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to ignore \ in string constants.  Use to treat #line 1 "A:\file.h    as a non-form feed.  If you want it to be a form feed, you must use    # 1 "\f".  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore_escape_flag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of conditionals currently in progress    (including both successful and failing conditionals).  */
end_comment

begin_struct
struct|struct
name|if_stack
block|{
name|struct
name|if_stack
modifier|*
name|next
decl_stmt|;
comment|/* for chaining to the next stack frame */
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* copied from input when frame is made */
name|size_t
name|fname_len
decl_stmt|;
comment|/* similarly */
name|int
name|lineno
decl_stmt|;
comment|/* similarly */
name|int
name|if_succeeded
decl_stmt|;
comment|/* true if a leg of this if-group 				    has been passed through rescan */
name|U_CHAR
modifier|*
name|control_macro
decl_stmt|;
comment|/* For #ifndef at start of file, 				   this is the macro name tested.  */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* type of last directive seen in this group */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|if_stack
name|IF_STACK_FRAME
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|IF_STACK_FRAME
modifier|*
name|if_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer of -M output.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|deps_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes allocated in above.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deps_allocated_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deps_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes since the last newline.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deps_column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means -I- has been seen,    so don't look for #include "foo" the source-file directory.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore_srcdir
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|safe_read
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|safe_write
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eprint_string
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
decl|main
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|path_include
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_CHAR
modifier|*
name|index0
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trigraph_pcp
name|PROTO
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|newline_fix
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|name_newline_fix
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_lintcmd
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rescan
name|PROTO
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE_BUF
name|expand_to_temp_buffer
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|handle_directive
name|PROTO
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tm
modifier|*
name|timestamp
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|special_symbol
name|PROTO
argument_list|(
operator|(
name|HASHNODE
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_system_include
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|base_name
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|absolute_filename
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|simplify_filename
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_filename_string
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|open_include_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|file_name_list
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
expr|struct
name|include_file
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|remap_include_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|file_name_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lookup_ino_include
name|PROTO
argument_list|(
operator|(
expr|struct
name|include_file
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finclude
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|include_file
operator|*
operator|,
name|FILE_BUF
operator|*
operator|,
name|int
operator|,
expr|struct
name|file_name_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_control_macro
name|PROTO
argument_list|(
operator|(
expr|struct
name|include_file
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|check_precompiled
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|stat
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_preconditions
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pcfinclude
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pcstring_used
name|PROTO
argument_list|(
operator|(
name|HASHNODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_output
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pass_thru_directive
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|MACRODEF
name|create_definition
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_macro_name
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_defs
name|PROTO
argument_list|(
operator|(
name|DEFINITION
operator|*
operator|,
name|DEFINITION
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_def_part
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DEFINITION
modifier|*
name|collect_expansion
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
expr|struct
name|arglist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|check_assertion
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|arglist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_token_lists
name|PROTO
argument_list|(
operator|(
expr|struct
name|arglist
operator|*
operator|,
expr|struct
name|arglist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|arglist
modifier|*
name|read_token_list
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_token_list
name|PROTO
argument_list|(
operator|(
expr|struct
name|arglist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ASSERTION_HASHNODE
modifier|*
name|assertion_install
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ASSERTION_HASHNODE
modifier|*
name|assertion_lookup
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_assertion
name|PROTO
argument_list|(
operator|(
name|ASSERTION_HASHNODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_once
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDEST_INT
name|eval_if_expression
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|conditional_skip
name|PROTO
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|int
operator|,
expr|enum
name|node_type
operator|,
name|U_CHAR
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|skip_if_group
name|PROTO
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|int
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_else
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_CHAR
modifier|*
name|skip_to_end_of_comment
name|PROTO
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_CHAR
modifier|*
name|skip_quoted_string
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|quote_string
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_CHAR
modifier|*
name|skip_paren_group
name|PROTO
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last arg to output_line_directive.  */
end_comment

begin_enum
enum|enum
name|file_change_code
block|{
name|same_file
block|,
name|enter_file
block|,
name|leave_file
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|output_line_directive
name|PROTO
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|FILE_BUF
operator|*
operator|,
name|int
operator|,
expr|enum
name|file_change_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|macroexpand
name|PROTO
argument_list|(
operator|(
name|HASHNODE
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|argdata
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|int
name|macarg
name|PROTO
argument_list|(
operator|(
expr|struct
name|argdata
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_CHAR
modifier|*
name|macarg1
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
expr|struct
name|hashnode
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|discard_comments
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|change_newlines
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|my_strerror
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|notice
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vnotice
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|error
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|verror
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error_from_errno
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|warning
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vwarning
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error_with_line
name|PVPROTO
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|verror_with_line
name|PROTO
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vwarning_with_line
name|PROTO
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warning_with_line
name|PVPROTO
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pedwarn
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pedwarn_with_line
name|PVPROTO
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pedwarn_with_file_and_line
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pedwarn_strange_white_space
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_containing_files
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|line_for_error
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|grow_outbuf
name|PROTO
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HASHNODE
modifier|*
name|install
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|,
expr|enum
name|node_type
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HASHNODE
modifier|*
name|lookup
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_macro
name|PROTO
argument_list|(
operator|(
name|HASHNODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hashf
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_single_macro
name|PROTO
argument_list|(
operator|(
name|HASHNODE
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_all_macros
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_defn_1
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_arg_n
name|PROTO
argument_list|(
operator|(
name|DEFINITION
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_char_syntax
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_builtins
name|PROTO
argument_list|(
operator|(
name|FILE_BUF
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_definition
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_undef
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|FILE_BUF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_assertion
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|new_include_prefix
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_name_list
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_include_chain
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_name_list
operator|*
operator|,
expr|struct
name|file_name_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|quote_string_for_make
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|deps_output
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fancy_abort
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|perror_with_name
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pfatal_with_name
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pipe_closed
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|memory_full
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_help
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,    retrying if necessary.  If MAX_READ_LEN is defined, read at most    that bytes at a time.  Return a negative value if an error occurs,    otherwise return the actual number of bytes read,    which must be LEN unless end-of-file was reached.  */
end_comment

begin_function
specifier|static
name|int
name|safe_read
parameter_list|(
name|desc
parameter_list|,
name|ptr
parameter_list|,
name|len
parameter_list|)
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|left
decl_stmt|,
name|rcount
decl_stmt|,
name|nchars
decl_stmt|;
name|left
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|rcount
operator|=
name|left
expr_stmt|;
ifdef|#
directive|ifdef
name|MAX_READ_LEN
if|if
condition|(
name|rcount
operator|>
name|MAX_READ_LEN
condition|)
name|rcount
operator|=
name|MAX_READ_LEN
expr_stmt|;
endif|#
directive|endif
name|nchars
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|ptr
argument_list|,
name|rcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
return|return
name|nchars
return|;
block|}
if|if
condition|(
name|nchars
operator|==
literal|0
condition|)
break|break;
name|ptr
operator|+=
name|nchars
expr_stmt|;
name|left
operator|-=
name|nchars
expr_stmt|;
block|}
return|return
name|len
operator|-
name|left
return|;
block|}
end_function

begin_comment
comment|/* Write LEN bytes at PTR to descriptor DESC,    retrying if necessary, and treating any real error as fatal.    If MAX_WRITE_LEN is defined, write at most that many bytes at a time.  */
end_comment

begin_function
specifier|static
name|void
name|safe_write
parameter_list|(
name|desc
parameter_list|,
name|ptr
parameter_list|,
name|len
parameter_list|)
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|wcount
decl_stmt|,
name|written
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|wcount
operator|=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|MAX_WRITE_LEN
if|if
condition|(
name|wcount
operator|>
name|MAX_WRITE_LEN
condition|)
name|wcount
operator|=
name|MAX_WRITE_LEN
expr_stmt|;
endif|#
directive|endif
name|written
operator|=
name|write
argument_list|(
name|desc
argument_list|,
name|ptr
argument_list|,
name|wcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
name|pfatal_with_name
argument_list|(
name|out_fname
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|+=
name|written
expr_stmt|;
name|len
operator|-=
name|written
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a string to stderr, with extra handling in case it contains    embedded NUL characters.  Any present are written as is.     Using fwrite for this purpose produces undesireable results on VMS    when stderr happens to be a record oriented file, such as a batch log    file, rather than a stream oriented one.  */
end_comment

begin_function
specifier|static
name|void
name|eprint_string
parameter_list|(
name|string
parameter_list|,
name|length
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|length
decl_stmt|;
block|{
name|size_t
name|segment_length
decl_stmt|;
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|length
operator|-=
operator|(
name|segment_length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|fputc
argument_list|(
literal|'\0'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|length
operator|-=
literal|1
expr_stmt|;
comment|/* Advance past the portion which has already been printed.  */
name|string
operator|+=
name|segment_length
operator|+
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|length
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_help
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Usage: %s [switches] input output\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Switches:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -include<file>           Include the contents of<file> before other files\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -imacros<file>           Accept definition of marcos in<file>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -iprefix<path>           Specify<path> as a prefix for next two options\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -iwithprefix<dir>        Add<dir> to the end of the system include paths\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -iwithprefixbefore<dir>  Add<dir> to the end of the main include paths\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -isystem<dir>            Add<dir> to the start of the system include paths\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -idirafter<dir>          Add<dir> to the end of the system include paths\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -I<dir>                  Add<dir> to the end of the main include paths\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -nostdinc                 Do not search the system include directories\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -nostdinc++               Do not search the system include directories for C++\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -o<file>                 Put output into<file>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -pedantic                 Issue all warnings demanded by strict ANSI C\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -traditional              Follow K&R pre-processor behaviour\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -trigraphs                Support ANSI C trigraphs\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-c                   Assume that the input sources are in C\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-c89                 Assume that the input is C89; depricated\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-c++                 Assume that the input sources are in C++\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-objc                Assume that the input sources are in ObjectiveC\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-objc++              Assume that the input sources are in ObjectiveC++\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-asm                 Assume that the input sources are in assembler\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-chill               Assume that the input sources are in Chill\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -std=<std name>           Specify the conformance standard; one of:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                            gnu89, gnu9x, c89, c9x, iso9899:1990,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                            iso9899:199409, iso9899:199x\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -+                        Allow parsing of C++ style features\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -w                        Inhibit warning messages\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wtrigraphs               Warn if trigraphs are encountered\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-trigraphs            Do not warn about trigraphs\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wcomment{s}              Warn if one comment starts inside another\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-comment{s}           Do not warn about comments\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wtraditional             Warn if a macro argument is/would be turned into\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                             a string if -traditional is specified\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-traditional          Do not warn about stringification\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wundef                   Warn if an undefined macro is used by #if\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-undef                Do not warn about testing undefined macros\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wimport                  Warn about the use of the #import directive\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-import               Do not warn about the use of #import\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Werror                   Treat all warnings as errors\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-error                Do not treat warnings as errors\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wall                     Enable all preprocessor warnings\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -M                        Generate make dependencies\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -MM                       As -M, but ignore system header files\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -MD                       As -M, but put output in a .d file\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -MMD                      As -MD, but ignore system header files\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -MG                       Treat missing header file as generated files\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -g                        Include #define and #undef directives in the output\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -D<macro>                 Define a<macro> with string '1' as its value\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -D<macro>=<val>           Define a<macro> with<val> as its value\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -A<question> (<answer>)   Assert the<answer> to<question>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -U<macro>                 Undefine<macro> \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -u or -undef              Do not predefine any macros\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -v                        Display the version number\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -H                        Print the name of header files as they are used\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -C                        Do not discard comments\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -dM                       Display a list of macro definitions active at end\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -dD                       Preserve macro definitions in output\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -dN                       As -dD except that only the names are preserved\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -dI                       Include #include directives in the output\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -ifoutput                 Describe skipped code blocks in output \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -P                        Do not generate #line directives\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -$                        Do not include '$' in identifiers\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -remap                    Remap file names when including files.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -h or --help              Display this information\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|in_fname
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|f
decl_stmt|,
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_files
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_defs
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_undefs
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_assertions
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_includes
decl_stmt|;
comment|/* Record the option used with each element of pend_assertions.      This is preparation for supporting more than one option for making      an assertion.  */
name|char
modifier|*
modifier|*
name|pend_assertion_options
decl_stmt|;
name|int
name|no_standard_includes
init|=
literal|0
decl_stmt|;
name|int
name|no_standard_cplusplus_includes
init|=
literal|0
decl_stmt|;
name|int
name|missing_newline
init|=
literal|0
decl_stmt|;
comment|/* Non-0 means don't output the preprocessed program.  */
name|int
name|inhibit_output
init|=
literal|0
decl_stmt|;
comment|/* Non-0 means -v, so print the full set of include dirs.  */
name|int
name|verbose
init|=
literal|0
decl_stmt|;
comment|/* File name which deps are being written to.      This is 0 if deps are being written to stdout.  */
name|char
modifier|*
name|deps_file
init|=
literal|0
decl_stmt|;
comment|/* Fopen file mode to open deps_file with.  */
name|char
modifier|*
name|deps_mode
init|=
literal|"a"
decl_stmt|;
comment|/* Stream on which to print the dependency information.  */
name|FILE
modifier|*
name|deps_stream
init|=
literal|0
decl_stmt|;
comment|/* Target-name to write with the dependency information.  */
name|char
modifier|*
name|deps_target
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|RLIMIT_STACK
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_GETRLIMIT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SETRLIMIT
argument_list|)
comment|/* Get rid of any avoidable limit on stack size.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca (particularly stringtab        in dbxread.c) does not fail.  */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_closed
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LC_MESSAGES
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|localedir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|progname
operator|=
name|base_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
block|{
comment|/* Remove extension from PROGNAME.  */
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|progname
operator|=
name|xstrdup
argument_list|(
name|progname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|';'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip version number */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
literal|0
comment|/* strip type iff ".exe" */
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'e'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'x'
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|'X'
operator|)
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'e'
operator|||
name|p
index|[
literal|3
index|]
operator|==
literal|'E'
operator|)
operator|&&
operator|!
name|p
index|[
literal|4
index|]
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Do not invoke xmalloc before this point, since locale and      progname need to be set first, in case a diagnostic is issued.  */
name|pend_files
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pend_defs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pend_undefs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pend_assertions
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pend_includes
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pend_assertion_options
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|in_fname
operator|=
name|NULL
expr_stmt|;
name|out_fname
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize is_idchar.  */
name|initialize_char_syntax
argument_list|()
expr_stmt|;
name|no_line_directives
operator|=
literal|0
expr_stmt|;
name|no_trigraphs
operator|=
literal|1
expr_stmt|;
name|dump_macros
operator|=
name|dump_none
expr_stmt|;
name|no_output
operator|=
literal|0
expr_stmt|;
name|cplusplus
operator|=
literal|0
expr_stmt|;
name|cplusplus_comments
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pend_files
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pend_defs
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pend_undefs
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pend_assertions
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pend_includes
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Change to the native locale for multibyte conversions.  */
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|literal_codeset
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Process switches and find input file name.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|out_fname
operator|!=
name|NULL
condition|)
block|{
name|print_help
argument_list|()
expr_stmt|;
name|fatal
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_fname
operator|!=
name|NULL
condition|)
name|out_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
name|in_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-include"
argument_list|)
condition|)
block|{
name|int
name|temp
init|=
name|i
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after `-include' option"
argument_list|)
expr_stmt|;
else|else
name|simplify_filename
argument_list|(
name|pend_includes
index|[
name|temp
index|]
operator|=
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-imacros"
argument_list|)
condition|)
block|{
name|int
name|temp
init|=
name|i
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after `-imacros' option"
argument_list|)
expr_stmt|;
else|else
name|simplify_filename
argument_list|(
name|pend_files
index|[
name|temp
index|]
operator|=
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iprefix"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after `-iprefix' option"
argument_list|)
expr_stmt|;
else|else
name|include_prefix
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-ifoutput"
argument_list|)
condition|)
block|{
name|output_conditionals
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-isystem"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dirtmp
operator|=
name|new_include_prefix
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
literal|""
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
operator|)
condition|)
break|break;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|before_system
operator|==
literal|0
condition|)
name|before_system
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_before_system
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_before_system
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
block|}
comment|/* Add directory to end of path for includes, 	   with the default prefix at the front of its name.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iwithprefix"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|include_prefix
operator|!=
literal|0
condition|)
name|prefix
operator|=
name|include_prefix
expr_stmt|;
else|else
block|{
name|prefix
operator|=
name|xstrdup
argument_list|(
name|GCC_INCLUDE_DIR
argument_list|)
expr_stmt|;
comment|/* Remove the `include' from /usr/local/lib/gcc.../include.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prefix
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|8
argument_list|,
literal|"/include"
argument_list|)
condition|)
name|prefix
index|[
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|7
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|dirtmp
operator|=
name|new_include_prefix
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|prefix
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|after_include
operator|==
literal|0
condition|)
name|after_include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_after_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_after_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
block|}
comment|/* Add directory to main path for includes, 	   with the default prefix at the front of its name.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iwithprefixbefore"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|include_prefix
operator|!=
literal|0
condition|)
name|prefix
operator|=
name|include_prefix
expr_stmt|;
else|else
block|{
name|prefix
operator|=
name|xstrdup
argument_list|(
name|GCC_INCLUDE_DIR
argument_list|)
expr_stmt|;
comment|/* Remove the `include' from /usr/local/lib/gcc.../include.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prefix
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|8
argument_list|,
literal|"/include"
argument_list|)
condition|)
name|prefix
index|[
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|7
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dirtmp
operator|=
name|new_include_prefix
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|prefix
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|append_include_chain
argument_list|(
name|dirtmp
argument_list|,
name|dirtmp
argument_list|)
expr_stmt|;
block|}
comment|/* Add directory to end of path for includes.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-idirafter"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dirtmp
operator|=
name|new_include_prefix
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
literal|""
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|after_include
operator|==
literal|0
condition|)
name|after_include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_after_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_after_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|out_fname
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Output filename specified twice"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after -o option"
argument_list|)
expr_stmt|;
name|out_fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|out_fname
argument_list|,
literal|"-"
argument_list|)
condition|)
name|out_fname
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pedantic"
argument_list|)
condition|)
name|pedantic
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pedantic-errors"
argument_list|)
condition|)
block|{
name|pedantic
operator|=
literal|1
expr_stmt|;
name|pedantic_errors
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pcp"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pcp_fname
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after -pcp option"
argument_list|)
expr_stmt|;
name|pcp_fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|pcp_outfile
operator|=
operator|(
operator|(
name|pcp_fname
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|pcp_fname
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|?
name|fopen
argument_list|(
name|pcp_fname
argument_list|,
literal|"w"
argument_list|)
else|:
name|stdout
operator|)
expr_stmt|;
if|if
condition|(
name|pcp_outfile
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|pcp_fname
argument_list|)
expr_stmt|;
name|no_precomp
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-traditional"
argument_list|)
condition|)
block|{
name|traditional
operator|=
literal|1
expr_stmt|;
name|cplusplus_comments
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-trigraphs"
argument_list|)
condition|)
block|{
name|no_trigraphs
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c"
argument_list|)
condition|)
name|cplusplus
operator|=
literal|0
operator|,
name|cplusplus_comments
operator|=
literal|1
operator|,
name|c89
operator|=
literal|0
operator|,
name|c9x
operator|=
literal|1
operator|,
name|objc
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c89"
argument_list|)
condition|)
name|cplusplus
operator|=
literal|0
operator|,
name|cplusplus_comments
operator|=
literal|0
operator|,
name|c89
operator|=
literal|1
operator|,
name|c9x
operator|=
literal|0
operator|,
name|objc
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c++"
argument_list|)
condition|)
name|cplusplus
operator|=
literal|1
operator|,
name|cplusplus_comments
operator|=
literal|1
operator|,
name|c89
operator|=
literal|0
operator|,
name|c9x
operator|=
literal|0
operator|,
name|objc
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-objc"
argument_list|)
condition|)
name|cplusplus
operator|=
literal|0
operator|,
name|cplusplus_comments
operator|=
literal|1
operator|,
name|c89
operator|=
literal|0
operator|,
name|c9x
operator|=
literal|0
operator|,
name|objc
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-objc++"
argument_list|)
condition|)
name|cplusplus
operator|=
literal|1
operator|,
name|cplusplus_comments
operator|=
literal|1
operator|,
name|c89
operator|=
literal|0
operator|,
name|c9x
operator|=
literal|0
operator|,
name|objc
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-asm"
argument_list|)
condition|)
name|lang_asm
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lint"
argument_list|)
condition|)
name|for_lint
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|cplusplus
operator|=
literal|1
operator|,
name|cplusplus_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=iso9899:1990"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=iso9899:199409"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=c89"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=gnu89"
argument_list|)
condition|)
name|cplusplus
operator|=
literal|0
operator|,
name|cplusplus_comments
operator|=
literal|0
operator|,
name|c89
operator|=
literal|1
operator|,
name|c9x
operator|=
literal|0
operator|,
name|objc
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=iso9899:199x"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=c9x"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-std=gnu9x"
argument_list|)
condition|)
name|cplusplus
operator|=
literal|0
operator|,
name|cplusplus_comments
operator|=
literal|1
operator|,
name|c89
operator|=
literal|0
operator|,
name|c9x
operator|=
literal|1
operator|,
name|objc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wtrigraphs"
argument_list|)
condition|)
name|warn_trigraphs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-trigraphs"
argument_list|)
condition|)
name|warn_trigraphs
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomment"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-comment"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomments"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-comments"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wtraditional"
argument_list|)
condition|)
name|warn_stringify
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-traditional"
argument_list|)
condition|)
name|warn_stringify
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wundef"
argument_list|)
condition|)
name|warn_undef
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-undef"
argument_list|)
condition|)
name|warn_undef
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wimport"
argument_list|)
condition|)
name|warn_import
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-import"
argument_list|)
condition|)
name|warn_import
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Werror"
argument_list|)
condition|)
name|warnings_are_errors
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-error"
argument_list|)
condition|)
name|warnings_are_errors
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wall"
argument_list|)
condition|)
block|{
name|warn_trigraphs
operator|=
literal|1
expr_stmt|;
name|warn_comments
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fleading-underscore"
argument_list|)
condition|)
name|user_label_prefix
operator|=
literal|"_"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fno-leading-underscore"
argument_list|)
condition|)
name|user_label_prefix
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* The style of the choices here is a bit mixed. 	   The chosen scheme is a hybrid of keeping all options in one string 	   and specifying each option in a separate argument: 	   -M|-MM|-MD file|-MMD file [-MG].  An alternative is: 	   -M|-MM|-MD file|-MMD file|-MG|-MMG; or more concisely: 	   -M[M][G][D file].  This is awkward to handle in specs, and is not 	   as extensible.  */
comment|/* ??? -MG must be specified in addition to one of -M or -MM. 	   This can be relaxed in the future without breaking anything. 	   The converse isn't true.  */
comment|/* -MG isn't valid with -MD or -MMD.  This is checked for later.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MG"
argument_list|)
condition|)
block|{
name|print_deps_missing_files
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-M"
argument_list|)
condition|)
name|print_deps
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MM"
argument_list|)
condition|)
name|print_deps
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MD"
argument_list|)
condition|)
name|print_deps
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MMD"
argument_list|)
condition|)
name|print_deps
operator|=
literal|1
expr_stmt|;
comment|/* For -MD and -MMD options, write deps on file named by next arg.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MD"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MMD"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after %s option"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|deps_file
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|deps_mode
operator|=
literal|"w"
expr_stmt|;
block|}
else|else
block|{
comment|/* For -M and -MM, write deps on standard output 	     and suppress the usual output.  */
name|deps_stream
operator|=
name|stdout
expr_stmt|;
name|inhibit_output
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
block|{
name|char
modifier|*
name|p
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
block|{
comment|/* Arg to -d specifies what parts of macros to dump */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'M'
case|:
name|dump_macros
operator|=
name|dump_only
expr_stmt|;
name|no_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|dump_macros
operator|=
name|dump_names
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|dump_macros
operator|=
name|dump_definitions
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|dump_includes
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'3'
condition|)
name|debug_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--help"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|i
return|;
name|print_help
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|notice
argument_list|(
literal|"GNU CPP version %s"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|print_include_names
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|pend_defs
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Macro name missing after -D option"
argument_list|)
expr_stmt|;
else|else
name|i
operator|++
operator|,
name|pend_defs
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Assertion missing after -A option"
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
comment|/* -A- eliminates all predefined macros and assertions. 	       Let's include also any that were specified earlier 	       on the command line.  That way we can get rid of any 	       that were passed automatically in from GCC.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|pend_defs
index|[
name|j
index|]
operator|=
name|pend_assertions
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pend_assertions
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|pend_assertion_options
index|[
name|i
index|]
operator|=
literal|"-A"
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'U'
case|:
comment|/* JF #undef something */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|pend_undefs
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Macro name missing after -U option"
argument_list|)
expr_stmt|;
else|else
name|pend_undefs
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|,
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|put_out_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* -E comes from cc -E; ignore it.  */
break|break;
case|case
literal|'P'
case|:
name|no_line_directives
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* Don't include $ in identifiers.  */
name|is_idchar
index|[
literal|'$'
index|]
operator|=
name|is_idstart
index|[
literal|'$'
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Add directory to path for includes.  */
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
if|if
condition|(
operator|!
name|ignore_srcdir
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|ignore_srcdir
operator|=
literal|1
expr_stmt|;
comment|/* Don't use any preceding -I directories for #include<...>.  */
name|first_bracket_include
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dirtmp
operator|=
name|new_include_prefix
argument_list|(
name|last_include
argument_list|,
name|NULL_PTR
argument_list|,
literal|""
argument_list|,
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|?
name|argv
index|[
name|i
index|]
operator|+
literal|2
else|:
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|append_include_chain
argument_list|(
name|dirtmp
argument_list|,
name|dirtmp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nostdinc"
argument_list|)
condition|)
comment|/* -nostdinc causes no default include directories. 	     You must specify all include-file directories with -I.  */
name|no_standard_includes
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nostdinc++"
argument_list|)
condition|)
comment|/* -nostdinc++ causes no default C++-specific include directories. */
name|no_standard_cplusplus_includes
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-noprecomp"
argument_list|)
condition|)
name|no_precomp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-remap"
argument_list|)
condition|)
name|remap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* JF handle '-' as file name meaning stdin or stdout */
if|if
condition|(
name|in_fname
operator|==
name|NULL
condition|)
block|{
name|in_fname
operator|=
literal|""
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|out_fname
operator|==
name|NULL
condition|)
block|{
name|out_fname
operator|=
literal|""
expr_stmt|;
break|break;
block|}
comment|/* else fall through into error */
default|default:
name|fatal
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Add dirs from CPATH after dirs from -I.  */
comment|/* There seems to be confusion about what CPATH should do,      so for the moment it is not documented.  */
comment|/* Some people say that CPATH should replace the standard include dirs,      but that seems pointless: it comes before them, so it overrides them      anyway.  */
name|GET_ENV_PATH_LIST
argument_list|(
name|cp
argument_list|,
literal|"CPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
operator|!
name|no_standard_includes
condition|)
name|path_include
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* Initialize output buffer */
name|outbuf
operator|.
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|OUTBUF_SIZE
argument_list|)
expr_stmt|;
name|outbuf
operator|.
name|bufp
operator|=
name|outbuf
operator|.
name|buf
expr_stmt|;
name|outbuf
operator|.
name|length
operator|=
name|OUTBUF_SIZE
expr_stmt|;
comment|/* Do partial setup of input buffer for the sake of generating      early #line directives (when -g is in effect).  */
name|fp
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
if|if
condition|(
name|in_fname
operator|==
name|NULL
condition|)
name|in_fname
operator|=
literal|""
expr_stmt|;
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|in_fname
expr_stmt|;
name|fp
operator|->
name|nominal_fname_len
operator|=
name|strlen
argument_list|(
name|in_fname
argument_list|)
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|0
expr_stmt|;
comment|/* In C++, wchar_t is a distinct basic type, and we can expect      __wchar_t to be defined by cc1plus.  */
if|if
condition|(
name|cplusplus
condition|)
name|wchar_type
operator|=
literal|"__wchar_t"
expr_stmt|;
comment|/* Install __LINE__, etc.  Must follow initialize_char_syntax      and option processing.  */
name|initialize_builtins
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
comment|/* Now handle the command line options.  */
comment|/* Do -U's, -D's and -A's in the order they were seen.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pend_undefs
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|debug_output
condition|)
name|output_line_directive
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|make_undef
argument_list|(
name|pend_undefs
index|[
name|i
index|]
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pend_defs
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|debug_output
condition|)
name|output_line_directive
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|make_definition
argument_list|(
name|pend_defs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pend_assertions
index|[
name|i
index|]
condition|)
name|make_assertion
argument_list|(
name|pend_assertion_options
index|[
name|i
index|]
argument_list|,
name|pend_assertions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|done_initializing
operator|=
literal|1
expr_stmt|;
block|{
comment|/* Read the appropriate environment variable and if it exists        replace include_defaults with the listed path.  */
name|char
modifier|*
name|epath
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
operator|(
name|objc
operator|<<
literal|1
operator|)
operator|+
name|cplusplus
condition|)
block|{
case|case
literal|0
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|epath
argument_list|,
literal|"C_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|epath
argument_list|,
literal|"CPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|epath
argument_list|,
literal|"OBJC_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|GET_ENV_PATH_LIST
argument_list|(
name|epath
argument_list|,
literal|"OBJCPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If the environment var for this language is set,        add to the default list of include directories.  */
if|if
condition|(
name|epath
condition|)
block|{
name|int
name|num_dirs
decl_stmt|;
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
for|for
control|(
name|num_dirs
operator|=
literal|1
operator|,
name|startp
operator|=
name|epath
init|;
operator|*
name|startp
condition|;
name|startp
operator|++
control|)
if|if
condition|(
operator|*
name|startp
operator|==
name|PATH_SEPARATOR
condition|)
name|num_dirs
operator|++
expr_stmt|;
name|include_defaults
operator|=
operator|(
expr|struct
name|default_include
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|num_dirs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|default_include
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|include_defaults_array
argument_list|)
argument_list|)
expr_stmt|;
name|startp
operator|=
name|endp
operator|=
name|epath
expr_stmt|;
name|num_dirs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|c
init|=
operator|*
name|endp
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|PATH_SEPARATOR
operator|||
operator|!
name|c
condition|)
block|{
name|endp
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|include_defaults
index|[
name|num_dirs
index|]
operator|.
name|fname
operator|=
name|startp
operator|==
name|endp
condition|?
literal|"."
else|:
name|xstrdup
argument_list|(
name|startp
argument_list|)
expr_stmt|;
name|endp
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|include_defaults
index|[
name|num_dirs
index|]
operator|.
name|component
operator|=
literal|0
expr_stmt|;
name|include_defaults
index|[
name|num_dirs
index|]
operator|.
name|cplusplus
operator|=
name|cplusplus
expr_stmt|;
name|include_defaults
index|[
name|num_dirs
index|]
operator|.
name|cxx_aware
operator|=
literal|1
expr_stmt|;
name|num_dirs
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
name|startp
operator|=
name|endp
expr_stmt|;
block|}
block|}
comment|/* Put the usual defaults back in at the end.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|include_defaults_array
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|include_defaults
index|[
name|num_dirs
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|include_defaults_array
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|append_include_chain
argument_list|(
name|before_system
argument_list|,
name|last_before_system
argument_list|)
expr_stmt|;
name|first_system_include
operator|=
name|before_system
expr_stmt|;
comment|/* Unless -fnostdinc,      tack on the standard include file dirs to the specified list */
if|if
condition|(
operator|!
name|no_standard_includes
condition|)
block|{
name|struct
name|default_include
modifier|*
name|p
init|=
name|include_defaults
decl_stmt|;
name|char
modifier|*
name|specd_prefix
init|=
name|include_prefix
decl_stmt|;
name|char
modifier|*
name|default_prefix
init|=
name|xstrdup
argument_list|(
name|GCC_INCLUDE_DIR
argument_list|)
decl_stmt|;
name|int
name|default_len
init|=
literal|0
decl_stmt|;
comment|/* Remove the `include' from /usr/local/lib/gcc.../include.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|default_prefix
operator|+
name|strlen
argument_list|(
name|default_prefix
argument_list|)
operator|-
literal|8
argument_list|,
literal|"/include"
argument_list|)
condition|)
block|{
name|default_len
operator|=
name|strlen
argument_list|(
name|default_prefix
argument_list|)
operator|-
literal|7
expr_stmt|;
name|default_prefix
index|[
name|default_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Search "translated" versions of GNU directories.        These have /usr/local/lib/gcc... replaced by specd_prefix.  */
if|if
condition|(
name|specd_prefix
operator|!=
literal|0
operator|&&
name|default_len
operator|!=
literal|0
condition|)
for|for
control|(
name|p
operator|=
name|include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|cplusplus
operator|&&
operator|!
name|no_standard_cplusplus_includes
operator|)
condition|)
block|{
comment|/* Does this dir start with the prefix?  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|default_prefix
argument_list|,
name|default_len
argument_list|)
condition|)
block|{
comment|/* Yes; change prefix and add to search list.  */
name|struct
name|file_name_list
modifier|*
name|new
init|=
name|new_include_prefix
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|specd_prefix
argument_list|,
name|p
operator|->
name|fname
operator|+
name|default_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|new
operator|->
name|c_system_include_path
operator|=
operator|!
name|p
operator|->
name|cxx_aware
expr_stmt|;
name|append_include_chain
argument_list|(
name|new
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_system_include
operator|==
literal|0
condition|)
name|first_system_include
operator|=
name|new
expr_stmt|;
name|p
operator|->
name|included
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Search ordinary names for GNU include directories.  */
for|for
control|(
name|p
operator|=
name|include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|cplusplus
operator|&&
operator|!
name|no_standard_cplusplus_includes
operator|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|new
init|=
name|new_include_prefix
argument_list|(
name|NULL_PTR
argument_list|,
name|p
operator|->
name|component
argument_list|,
literal|""
argument_list|,
name|p
operator|->
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|new
operator|->
name|c_system_include_path
operator|=
operator|!
name|p
operator|->
name|cxx_aware
expr_stmt|;
name|append_include_chain
argument_list|(
name|new
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_system_include
operator|==
literal|0
condition|)
name|first_system_include
operator|=
name|new
expr_stmt|;
name|p
operator|->
name|included
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Tack the after_include chain at the end of the include chain.  */
name|append_include_chain
argument_list|(
name|after_include
argument_list|,
name|last_after_include
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_system_include
operator|==
literal|0
condition|)
name|first_system_include
operator|=
name|after_include
expr_stmt|;
comment|/* With -v, print the list of dirs to search.  */
if|if
condition|(
name|verbose
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|p
decl_stmt|;
name|notice
argument_list|(
literal|"#include \"...\" search starts here:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|include
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|first_bracket_include
condition|)
name|notice
argument_list|(
literal|"#include<...> search starts here:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|fname
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" .\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|fname
argument_list|,
literal|"/"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|fname
argument_list|,
literal|"//"
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|p
operator|->
name|fname
argument_list|)
expr_stmt|;
else|else
comment|/* Omit trailing '/'.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|p
operator|->
name|fname
argument_list|)
operator|-
literal|1
argument_list|,
name|p
operator|->
name|fname
argument_list|)
expr_stmt|;
block|}
name|notice
argument_list|(
literal|"End of search list.\n"
argument_list|)
expr_stmt|;
block|{
name|struct
name|default_include
modifier|*
name|d
decl_stmt|;
name|notice
argument_list|(
literal|"The following default directories have been omitted from the search path:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|include_defaults
init|;
name|d
operator|->
name|fname
condition|;
name|d
operator|++
control|)
if|if
condition|(
operator|!
name|d
operator|->
name|included
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|d
operator|->
name|fname
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"End of omitted list.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* -MG doesn't select the form of output and must be specified with one of      -M or -MM.  -MG doesn't make sense with -MD or -MMD since they don't      inhibit compilation.  */
if|if
condition|(
name|print_deps_missing_files
operator|&&
operator|(
name|print_deps
operator|==
literal|0
operator|||
operator|!
name|inhibit_output
operator|)
condition|)
name|fatal
argument_list|(
literal|"-MG must be specified with one of -M or -MM"
argument_list|)
expr_stmt|;
comment|/* Either of two environment variables can specify output of deps.      Its value is either "OUTPUT_FILE" or "OUTPUT_FILE DEPS_TARGET",      where OUTPUT_FILE is the file to write deps info to      and DEPS_TARGET is the target to mention in the deps.  */
if|if
condition|(
name|print_deps
operator|==
literal|0
operator|&&
operator|(
name|getenv
argument_list|(
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
operator|!=
literal|0
operator|||
name|getenv
argument_list|(
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|spec
init|=
name|getenv
argument_list|(
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|output_file
decl_stmt|;
if|if
condition|(
name|spec
operator|==
literal|0
condition|)
block|{
name|spec
operator|=
name|getenv
argument_list|(
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
expr_stmt|;
name|print_deps
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|print_deps
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|spec
expr_stmt|;
comment|/* Find the space before the DEPS_TARGET, if there is one.  */
comment|/* This should use index.  (mrs) */
while|while
condition|(
operator|*
name|s
operator|!=
literal|0
operator|&&
operator|*
name|s
operator|!=
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
name|deps_target
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|output_file
operator|=
name|xmalloc
argument_list|(
name|s
operator|-
name|spec
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|spec
argument_list|,
name|output_file
argument_list|,
name|s
operator|-
name|spec
argument_list|)
expr_stmt|;
name|output_file
index|[
name|s
operator|-
name|spec
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|deps_target
operator|=
literal|0
expr_stmt|;
name|output_file
operator|=
name|spec
expr_stmt|;
block|}
name|deps_file
operator|=
name|output_file
expr_stmt|;
name|deps_mode
operator|=
literal|"a"
expr_stmt|;
block|}
comment|/* For -M, print the expected object file name      as the target of this Make-rule.  */
if|if
condition|(
name|print_deps
condition|)
block|{
name|deps_allocated_size
operator|=
literal|200
expr_stmt|;
name|deps_buffer
operator|=
name|xmalloc
argument_list|(
name|deps_allocated_size
argument_list|)
expr_stmt|;
name|deps_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|deps_size
operator|=
literal|0
expr_stmt|;
name|deps_column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|deps_target
condition|)
block|{
name|deps_output
argument_list|(
name|deps_target
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|in_fname
operator|==
literal|0
condition|)
block|{
name|deps_output
argument_list|(
literal|"-"
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|len
decl_stmt|;
name|q
operator|=
name|base_name
argument_list|(
name|in_fname
argument_list|)
expr_stmt|;
comment|/* Copy remainder to mungable area.  */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|q
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Output P, but remove known suffixes.  */
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|2
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|index
argument_list|(
literal|"cCsSm"
argument_list|,
name|p
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|q
operator|=
name|p
operator|+
operator|(
name|len
operator|-
literal|2
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>=
literal|3
operator|&&
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'c'
condition|)
name|q
operator|=
name|p
operator|+
operator|(
name|len
operator|-
literal|3
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>=
literal|4
operator|&&
name|p
index|[
name|len
operator|-
literal|4
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|==
literal|'c'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'x'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'x'
condition|)
name|q
operator|=
name|p
operator|+
operator|(
name|len
operator|-
literal|4
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>=
literal|4
operator|&&
name|p
index|[
name|len
operator|-
literal|4
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|==
literal|'c'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'p'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'p'
condition|)
name|q
operator|=
name|p
operator|+
operator|(
name|len
operator|-
literal|4
operator|)
expr_stmt|;
comment|/* Supply our own suffix.  */
name|strcpy
argument_list|(
name|q
argument_list|,
name|OBJECT_SUFFIX
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
name|in_fname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Scan the -imacros files before the main input.      Much like #including them, but with no_output set      so that only their macro definitions matter.  */
name|no_output
operator|++
expr_stmt|;
name|no_record_file
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pend_files
index|[
name|i
index|]
condition|)
block|{
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|;
name|int
name|fd
init|=
name|open_include_file
argument_list|(
name|pend_files
index|[
name|i
index|]
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
operator|&
name|inc
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|pend_files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|FATAL_EXIT_CODE
return|;
block|}
name|finclude
argument_list|(
name|fd
argument_list|,
name|inc
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|no_output
operator|--
expr_stmt|;
name|no_record_file
operator|--
expr_stmt|;
comment|/* Copy the entire contents of the main input file into      the stacked input buffer previously allocated for it.  */
comment|/* JF check for stdin */
if|if
condition|(
name|in_fname
operator|==
name|NULL
operator|||
operator|*
name|in_fname
operator|==
literal|0
condition|)
block|{
name|in_fname
operator|=
literal|""
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|in_fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|perror
goto|;
if|if
condition|(
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|in_fname
argument_list|)
expr_stmt|;
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|in_fname
expr_stmt|;
name|fp
operator|->
name|nominal_fname_len
operator|=
name|strlen
argument_list|(
name|in_fname
argument_list|)
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
comment|/* JF all this is mine about reading pipes and ttys */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Read input from a file that is not a normal disk file.        We cannot preallocate a buffer with the correct size,        so we must read in the file a piece at the time and make it bigger.  */
name|int
name|size
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|cnt
decl_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Input file `%s' is a directory"
argument_list|,
name|in_fname
argument_list|)
expr_stmt|;
name|bsize
operator|=
literal|2000
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cnt
operator|=
name|safe_read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|buf
operator|+
name|size
argument_list|,
name|bsize
operator|-
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
goto|goto
name|perror
goto|;
comment|/* error! */
name|size
operator|+=
name|cnt
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|bsize
condition|)
break|break;
comment|/* End of file */
name|bsize
operator|*=
literal|2
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|fp
operator|->
name|buf
argument_list|,
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|length
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* Read a file whose size we can determine in advance.        For the sake of VMS, st.st_size is just an upper bound.  */
name|size_t
name|s
init|=
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|st
operator|.
name|st_size
operator|||
name|s
operator|+
literal|2
operator|<
name|s
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|s
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fp
operator|->
name|length
operator|=
name|safe_read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|length
operator|<
literal|0
condition|)
goto|goto
name|perror
goto|;
block|}
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
name|fp
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
comment|/* Make sure data ends with a newline.  And put a null after it.  */
if|if
condition|(
operator|(
name|fp
operator|->
name|length
operator|>
literal|0
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
comment|/* Backslash-newline at end is not good enough.  */
operator|||
operator|(
name|fp
operator|->
name|length
operator|>
literal|1
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|2
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|missing_newline
operator|=
literal|1
expr_stmt|;
block|}
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Unless inhibited, convert trigraphs in the input.  */
if|if
condition|(
operator|!
name|no_trigraphs
condition|)
name|trigraph_pcp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Now that we know the input file is valid, open the output.  */
if|if
condition|(
operator|!
name|out_fname
operator|||
operator|!
name|strcmp
argument_list|(
name|out_fname
argument_list|,
literal|""
argument_list|)
condition|)
name|out_fname
operator|=
literal|"stdout"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|out_fname
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
condition|)
name|pfatal_with_name
argument_list|(
name|out_fname
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
comment|/* Scan the -include files before the main input.  */
name|no_record_file
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pend_includes
index|[
name|i
index|]
condition|)
block|{
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|;
name|int
name|fd
init|=
name|open_include_file
argument_list|(
name|pend_includes
index|[
name|i
index|]
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
operator|&
name|inc
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|pend_includes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|FATAL_EXIT_CODE
return|;
block|}
name|finclude
argument_list|(
name|fd
argument_list|,
name|inc
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|no_record_file
operator|--
expr_stmt|;
comment|/* Scan the input, processing macros and directives.  */
name|rescan
argument_list|(
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|missing_newline
condition|)
name|fp
operator|->
name|lineno
operator|--
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|missing_newline
condition|)
name|pedwarn
argument_list|(
literal|"file does not end in newline"
argument_list|)
expr_stmt|;
comment|/* Now we have processed the entire input      Write whichever kind of output has been requested.  */
if|if
condition|(
name|dump_macros
operator|==
name|dump_only
condition|)
name|dump_all_macros
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|inhibit_output
condition|)
block|{
name|write_output
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|print_deps
condition|)
block|{
comment|/* Don't actually write the deps file if compilation has failed.  */
if|if
condition|(
name|errors
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|deps_file
operator|&&
operator|!
operator|(
name|deps_stream
operator|=
name|fopen
argument_list|(
name|deps_file
argument_list|,
name|deps_mode
argument_list|)
operator|)
condition|)
name|pfatal_with_name
argument_list|(
name|deps_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|deps_buffer
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|deps_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|deps_stream
argument_list|)
operator|||
name|fclose
argument_list|(
name|deps_stream
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"I/O error on output"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pcp_outfile
operator|&&
name|pcp_outfile
operator|!=
name|stdout
operator|&&
operator|(
name|ferror
argument_list|(
name|pcp_outfile
argument_list|)
operator|||
name|fclose
argument_list|(
name|pcp_outfile
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|fatal
argument_list|(
literal|"I/O error on `-pcp' output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"I/O error on output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
name|perror
label|:
name|pfatal_with_name
argument_list|(
name|in_fname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a colon-separated list of file names PATH,    add all the names to the search path for include files.  */
end_comment

begin_function
specifier|static
name|void
name|path_include
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
comment|/* Find the end of this name.  */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|q
operator|++
operator|)
operator|!=
name|PATH_SEPARATOR
operator|&&
name|c
condition|)
continue|continue;
name|q
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|=
name|new_include_prefix
argument_list|(
name|last_include
argument_list|,
name|NULL_PTR
argument_list|,
literal|""
argument_list|,
name|p
operator|==
name|q
condition|?
literal|"."
else|:
name|p
argument_list|)
expr_stmt|;
name|q
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|append_include_chain
argument_list|(
name|dirtmp
argument_list|,
name|dirtmp
argument_list|)
expr_stmt|;
comment|/* Advance past this name.  */
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the address of the first character in S that equals C.    S is an array of length N, possibly containing '\0's, and followed by '\0'.    Return 0 if there is no such character.  Assume that C itself is not '\0'.    If we knew we could use memchr, we could just invoke memchr (S, C, N),    but unfortunately memchr isn't autoconfigured yet.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|index0
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|)
name|U_CHAR
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|s
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|q
init|=
name|index
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
condition|)
return|return
operator|(
name|U_CHAR
operator|*
operator|)
name|q
return|;
else|else
block|{
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|n
condition|)
return|return
literal|0
return|;
name|l
operator|++
expr_stmt|;
name|p
operator|+=
name|l
expr_stmt|;
name|n
operator|-=
name|l
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pre-C-Preprocessor to translate ANSI trigraph idiocy in BUF    before main CCCP processing.  Name `pcp' is also in honor of the    drugs the trigraph designers must have been on.     Using an extra pass through the buffer takes a little extra time,    but is infinitely less hairy than trying to handle trigraphs inside    strings, etc. everywhere, and also makes sure that trigraphs are    only translated in the top level of processing.  */
end_comment

begin_function
specifier|static
name|void
name|trigraph_pcp
parameter_list|(
name|buf
parameter_list|)
name|FILE_BUF
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|U_CHAR
name|c
decl_stmt|,
modifier|*
name|fptr
decl_stmt|,
modifier|*
name|bptr
decl_stmt|,
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|lptr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|fptr
operator|=
name|bptr
operator|=
name|sptr
operator|=
name|buf
operator|->
name|buf
expr_stmt|;
name|lptr
operator|=
name|fptr
operator|+
name|buf
operator|->
name|length
expr_stmt|;
while|while
condition|(
operator|(
name|sptr
operator|=
name|index0
argument_list|(
name|sptr
argument_list|,
literal|'?'
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|lptr
operator|-
name|sptr
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|sptr
operator|!=
literal|'?'
condition|)
continue|continue;
switch|switch
condition|(
operator|*
operator|++
name|sptr
condition|)
block|{
case|case
literal|'='
case|:
name|c
operator|=
literal|'#'
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|c
operator|=
literal|'['
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|c
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|c
operator|=
literal|']'
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|c
operator|=
literal|'^'
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|c
operator|=
literal|'{'
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|c
operator|=
literal|'|'
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|c
operator|=
literal|'}'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|c
operator|=
literal|'~'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|sptr
operator|--
expr_stmt|;
continue|continue;
default|default:
continue|continue;
block|}
name|len
operator|=
name|sptr
operator|-
name|fptr
operator|-
literal|2
expr_stmt|;
comment|/* BSD doc says bcopy () works right for overlapping strings.  In ANSI        C, this will be memmove ().  */
if|if
condition|(
name|bptr
operator|!=
name|fptr
operator|&&
name|len
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|len
expr_stmt|;
operator|*
name|bptr
operator|++
operator|=
name|c
expr_stmt|;
name|fptr
operator|=
operator|++
name|sptr
expr_stmt|;
block|}
name|len
operator|=
name|buf
operator|->
name|length
operator|-
operator|(
name|fptr
operator|-
name|buf
operator|->
name|buf
operator|)
expr_stmt|;
if|if
condition|(
name|bptr
operator|!=
name|fptr
operator|&&
name|len
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|->
name|length
operator|-=
name|fptr
operator|-
name|bptr
expr_stmt|;
name|buf
operator|->
name|buf
index|[
name|buf
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|warn_trigraphs
operator|&&
name|fptr
operator|!=
name|bptr
condition|)
name|warning_with_line
argument_list|(
literal|0
argument_list|,
literal|"%lu trigraph(s) encountered"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|fptr
operator|-
name|bptr
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Move all backslash-newline pairs out of embarrassing places.    Exchange all such pairs following BP    with any potentially-embarrassing characters that follow them.    Potentially-embarrassing characters are / and *    (because a backslash-newline inside a comment delimiter    would cause it not to be recognized).  */
end_comment

begin_function
specifier|static
name|void
name|newline_fix
parameter_list|(
name|bp
parameter_list|)
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|bp
decl_stmt|;
comment|/* First count the backslash-newline pairs here.  */
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* What follows the backslash-newlines is not embarrassing.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|'*'
condition|)
return|return;
comment|/* Copy all potentially embarrassing characters      that follow the backslash-newline pairs      down to where the pairs originally started.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Now write the same number of pairs after the embarrassing chars.  */
while|while
condition|(
name|bp
operator|<
name|p
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like newline_fix but for use within a directive-name.    Move any backslash-newlines up past any following symbol constituents.  */
end_comment

begin_function
specifier|static
name|void
name|name_newline_fix
parameter_list|(
name|bp
parameter_list|)
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|bp
decl_stmt|;
comment|/* First count the backslash-newline pairs here.  */
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* What follows the backslash-newlines is not embarrassing.  */
if|if
condition|(
operator|!
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
return|return;
comment|/* Copy all potentially embarrassing characters      that follow the backslash-newline pairs      down to where the pairs originally started.  */
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Now write the same number of pairs after the embarrassing chars.  */
while|while
condition|(
name|bp
operator|<
name|p
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look for lint commands in comments.     When we come in here, ibp points into a comment.  Limit is as one expects.    scan within the comment -- it should start, after lwsp, with a lint command.    If so that command is returned as a (constant) string.     Upon return, any arg will be pointed to with argstart and will be    arglen long.  Note that we don't parse that arg since it will just    be printed out again.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_lintcmd
parameter_list|(
name|ibp
parameter_list|,
name|limit
parameter_list|,
name|argstart
parameter_list|,
name|arglen
parameter_list|,
name|cmdlen
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|U_CHAR
modifier|*
modifier|*
name|argstart
decl_stmt|;
comment|/* point to command arg */
name|int
modifier|*
name|arglen
decl_stmt|,
decl|*
name|cmdlen
decl_stmt|;
end_function

begin_comment
comment|/* how long they are */
end_comment

begin_block
block|{
name|HOST_WIDEST_INT
name|linsize
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|numptr
decl_stmt|;
comment|/* temp for arg parsing */
operator|*
name|arglen
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
return|return
name|NULL
return|;
name|linsize
operator|=
name|limit
operator|-
name|ibp
expr_stmt|;
comment|/* Oh, I wish C had lexical functions... hell, I'll just open-code the set */
if|if
condition|(
operator|(
name|linsize
operator|>=
literal|10
operator|)
operator|&&
operator|!
name|bcmp
argument_list|(
name|ibp
argument_list|,
literal|"NOTREACHED"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
operator|*
name|cmdlen
operator|=
literal|10
expr_stmt|;
return|return
literal|"NOTREACHED"
return|;
block|}
if|if
condition|(
operator|(
name|linsize
operator|>=
literal|8
operator|)
operator|&&
operator|!
name|bcmp
argument_list|(
name|ibp
argument_list|,
literal|"ARGSUSED"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
operator|*
name|cmdlen
operator|=
literal|8
expr_stmt|;
return|return
literal|"ARGSUSED"
return|;
block|}
if|if
condition|(
operator|(
name|linsize
operator|>=
literal|11
operator|)
operator|&&
operator|!
name|bcmp
argument_list|(
name|ibp
argument_list|,
literal|"LINTLIBRARY"
argument_list|,
literal|11
argument_list|)
condition|)
block|{
operator|*
name|cmdlen
operator|=
literal|11
expr_stmt|;
return|return
literal|"LINTLIBRARY"
return|;
block|}
if|if
condition|(
operator|(
name|linsize
operator|>=
literal|7
operator|)
operator|&&
operator|!
name|bcmp
argument_list|(
name|ibp
argument_list|,
literal|"VARARGS"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
operator|*
name|cmdlen
operator|=
literal|7
expr_stmt|;
name|ibp
operator|+=
literal|7
expr_stmt|;
name|linsize
operator|-=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|linsize
operator|==
literal|0
operator|)
operator|||
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|ibp
argument_list|)
condition|)
return|return
literal|"VARARGS"
return|;
comment|/* OK, read a number */
for|for
control|(
name|numptr
operator|=
operator|*
name|argstart
operator|=
name|ibp
init|;
operator|(
name|numptr
operator|<
name|limit
operator|)
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|numptr
argument_list|)
condition|;
name|numptr
operator|++
control|)
empty_stmt|;
operator|*
name|arglen
operator|=
name|numptr
operator|-
operator|*
name|argstart
expr_stmt|;
return|return
literal|"VARARGS"
return|;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * The main loop of the program.  *  * Read characters from the input stack, transferring them to the  * output buffer OP.  *  * Macros are expanded and push levels on the input stack.  * At the end of such a level it is popped off and we keep reading.  * At the end of any other kind of level, we return.  * #-directives are handled, except within macros.  *  * If OUTPUT_MARKS is nonzero, keep Newline markers found in the input  * and insert them when appropriate.  This is set while scanning macro  * arguments before substitution.  It is zero when scanning for final output.  *   There are three types of Newline markers:  *   * Newline -  follows a macro name that was not expanded  *     because it appeared inside an expansion of the same macro.  *     This marker prevents future expansion of that identifier.  *     When the input is rescanned into the final output, these are deleted.  *     These are also deleted by ## concatenation.  *   * Newline Space (or Newline and any other whitespace character)  *     stands for a place that tokens must be separated or whitespace  *     is otherwise desirable, but where the ANSI standard specifies there  *     is no whitespace.  This marker turns into a Space (or whichever other  *     whitespace char appears in the marker) in the final output,  *     but it turns into nothing in an argument that is stringified with #.  *     Such stringified arguments are the only place where the ANSI standard  *     specifies with precision that whitespace may not appear.  *  * During this function, IP->bufp is kept cached in IBP for speed of access.  * Likewise, OP->bufp is kept in OBP.  Before calling a subroutine  * IBP, IP and OBP must be copied back to memory.  IP and IBP are  * copied back with the RECACHE macro.  OBP must be copied back from OP->bufp  * explicitly, and before RECACHE, since RECACHE uses OBP.  */
end_comment

begin_function
specifier|static
name|void
name|rescan
parameter_list|(
name|op
parameter_list|,
name|output_marks
parameter_list|)
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
name|int
name|output_marks
decl_stmt|;
block|{
comment|/* Character being scanned in main loop.  */
specifier|register
name|U_CHAR
name|c
decl_stmt|;
comment|/* Length of pending accumulated identifier.  */
specifier|register
name|int
name|ident_length
init|=
literal|0
decl_stmt|;
comment|/* Hash code of pending accumulated identifier.  */
specifier|register
name|int
name|hash
init|=
literal|0
decl_stmt|;
comment|/* Current input level (&instack[indepth]).  */
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
comment|/* Pointer for scanning input.  */
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
comment|/* Pointer to end of input.  End of scan is controlled by LIMIT.  */
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
comment|/* Pointer for storing output.  */
specifier|register
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
comment|/* REDO_CHAR is nonzero if we are processing an identifier      after backing up over the terminating character.      Sometimes we process an identifier without backing up over      the terminating character, if the terminating character      is not special.  Backing up is done so that the terminating character      will be dispatched on again once the identifier is dealt with.  */
name|int
name|redo_char
init|=
literal|0
decl_stmt|;
comment|/* 1 if within an identifier inside of which a concatenation      marker (Newline -) has been seen.  */
name|int
name|concatenated
init|=
literal|0
decl_stmt|;
comment|/* While scanning a comment or a string constant,      this records the line it started on, for error messages.  */
name|int
name|start_line
decl_stmt|;
comment|/* Record position of last `real' newline.  */
name|U_CHAR
modifier|*
name|beg_of_line
decl_stmt|;
comment|/* Pop the innermost input stack level, assuming it is a macro expansion.  */
define|#
directive|define
name|POPMACRO
define|\
value|do { ip->macro->type = T_MACRO;		\      if (ip->free_ptr) free (ip->free_ptr);	\      --indepth; } while (0)
comment|/* Reload `rescan's local variables that describe the current    level of the input stack.  */
define|#
directive|define
name|RECACHE
define|\
value|do { ip =&instack[indepth];		\      ibp = ip->bufp;			\      limit = ip->buf + ip->length;	\      op->bufp = obp;			\      check_expand (op, limit - ibp);	\      beg_of_line = 0;			\      obp = op->bufp; } while (0)
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
operator|!=
literal|0
condition|)
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
comment|/* Our caller must always put a null after the end of      the input at each input stack level.  */
if|if
condition|(
operator|*
name|limit
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
operator|&&
operator|!
name|ip
operator|->
name|macro
condition|)
block|{
comment|/* At the top level, always merge lines ending with backslash-newline, 	   even in middle of identifier.  But do not merge lines in a macro, 	   since backslash might be followed by a newline-space marker.  */
operator|++
name|ibp
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|--
name|obp
expr_stmt|;
comment|/* remove backslash from obuf */
break|break;
block|}
comment|/* If ANSI, backslash is just another character outside a string.  */
if|if
condition|(
operator|!
name|traditional
condition|)
goto|goto
name|randomchar
goto|;
comment|/* Otherwise, backslash suppresses specialness of following char, 	 so copy it here to prevent the switch from seeing it. 	 But first get any pending identifier processed.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
if|if
condition|(
name|ibp
operator|<
name|limit
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|ident_length
operator|||
name|ip
operator|->
name|macro
operator|||
name|traditional
condition|)
goto|goto
name|randomchar
goto|;
while|while
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ibp
operator|+=
literal|2
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ibp
operator|!=
literal|':'
condition|)
break|break;
comment|/* Treat this %: digraph as if it were #.  */
comment|/* Fall through.  */
case|case
literal|'#'
case|:
if|if
condition|(
name|assertions_flag
condition|)
block|{
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
comment|/* Copy #foo (bar lose) without macro expansion.  */
name|obp
index|[
operator|-
literal|1
index|]
operator|=
literal|'#'
expr_stmt|;
comment|/* In case it was '%'.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|ibp
index|]
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'('
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
name|skip_paren_group
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ibp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
name|ip
operator|->
name|bufp
operator|-
name|ibp
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|ip
operator|->
name|bufp
operator|-
name|ibp
expr_stmt|;
name|ibp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
break|break;
block|}
comment|/* If this is expanding a macro definition, don't recognize 	 preprocessing directives.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
goto|goto
name|randomchar
goto|;
comment|/* If this is expand_into_temp_buffer, 	 don't recognize them either.  Warn about them 	 only after an actual newline at this level, 	 not at the beginning of the input level.  */
if|if
condition|(
operator|!
name|ip
operator|->
name|fname
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|buf
operator|!=
name|beg_of_line
condition|)
name|warning
argument_list|(
literal|"preprocessing directive not recognized within macro arg"
argument_list|)
expr_stmt|;
goto|goto
name|randomchar
goto|;
block|}
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
comment|/* # keyword: a # must be first nonblank char on the line */
if|if
condition|(
name|beg_of_line
operator|==
literal|0
condition|)
goto|goto
name|randomchar
goto|;
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* Scan from start of line, skipping whitespace, comments 	   and backslash-newlines, and see if we reach this #. 	   If not, this # is not special.  */
name|bp
operator|=
name|beg_of_line
expr_stmt|;
comment|/* If -traditional, require # to be at beginning of line.  */
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|bp
argument_list|,
name|limit
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|bp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bp
operator|++
expr_stmt|;
block|}
block|}
comment|/* There is no point in trying to deal with C++ // comments here, 	       because if there is one, then this # must be part of the 	       comment and we would never reach here.  */
else|else
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|!=
literal|'%'
condition|)
break|break;
while|while
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|bp
operator|+
literal|1
operator|!=
name|ibp
condition|)
break|break;
comment|/* %: appears at start of line; skip past the ':' too.  */
name|bp
operator|++
expr_stmt|;
name|ibp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
operator|+
literal|1
operator|!=
name|ibp
condition|)
goto|goto
name|randomchar
goto|;
block|}
comment|/* This # can start a directive.  */
operator|--
name|obp
expr_stmt|;
comment|/* Don't copy the '#' */
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
if|if
condition|(
operator|!
name|handle_directive
argument_list|(
name|ip
argument_list|,
name|op
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Not a known directive: treat it as ordinary text. 	   IP, OP, IBP, etc. have not been changed.  */
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
condition|)
block|{
comment|/* If not generating expanded output, 	     what we do with ordinary text is skip it. 	     Discard everything until next # directive.  */
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
break|break;
block|}
operator|*
name|obp
operator|++
operator|=
literal|'#'
expr_stmt|;
comment|/* Copy # (even if it was originally %:).  */
comment|/* Don't expand an identifier that could be a macro directive. 	   (Section 3.8.3 of the ANSI C standard)			*/
name|SKIP_WHITE_SPACE
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_idstart
index|[
operator|*
name|ibp
index|]
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|ibp
index|]
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
goto|goto
name|randomchar
goto|;
block|}
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A # directive has been successfully processed.  */
comment|/* If not generating expanded output, ignore everything until 	 next # directive.  */
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
condition|)
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
comment|/* skip quoted string */
case|case
literal|'\''
case|:
comment|/* A single quoted string is treated like a double -- some 	 programs (e.g., troff) are perverse this way */
comment|/* Handle any pending identifier; 	 but the L in L'...' or L"..." is not an identifier.  */
if|if
condition|(
name|ident_length
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ident_length
operator|==
literal|1
operator|&&
name|hash
operator|==
name|HASHSTEP
argument_list|(
literal|0
argument_list|,
literal|'L'
argument_list|)
operator|)
condition|)
goto|goto
name|specialchar
goto|;
name|ident_length
operator|=
name|hash
operator|=
literal|0
expr_stmt|;
block|}
name|start_line
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* Skip ahead to a matching quote.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
comment|/* try harder: this string crosses a macro expansion boundary. 	       This can happen naturally if -traditional. 	       Otherwise, only -D can make a macro with an unmatched quote.  */
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|multiline_string_line
condition|)
block|{
name|error_with_line
argument_list|(
name|multiline_string_line
argument_list|,
literal|"possible real start of unterminated constant"
argument_list|)
expr_stmt|;
name|multiline_string_line
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
block|}
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
expr_stmt|;
switch|switch
condition|(
operator|*
name|ibp
operator|++
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
comment|/* Traditionally, end of line ends a string constant with no error. 	     So exit the loop and record the new line.  */
if|if
condition|(
name|traditional
condition|)
block|{
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
goto|goto
name|while2end
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated character constant"
argument_list|)
expr_stmt|;
goto|goto
name|while2end
goto|;
block|}
if|if
condition|(
name|multiline_string_line
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"string constant runs past end of line"
argument_list|)
expr_stmt|;
name|multiline_string_line
operator|=
name|ip
operator|->
name|lineno
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
comment|/* Backslash newline is replaced by nothing at all, but 	       keep the line counts correct.  But if we are reading 	       from a macro, keep the backslash newline, since backslash 	       newlines have already been processed.  */
if|if
condition|(
name|ip
operator|->
name|macro
condition|)
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
else|else
operator|--
name|obp
expr_stmt|;
operator|++
name|ibp
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
else|else
block|{
comment|/* ANSI stupidly requires that in \\ the second \ 	       is *not* prevented from combining with a newline.  */
if|if
condition|(
operator|!
name|ip
operator|->
name|macro
condition|)
block|{
while|while
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ibp
operator|+=
literal|2
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
block|}
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
if|if
condition|(
name|ibp
index|[
operator|-
literal|1
index|]
operator|==
name|c
condition|)
goto|goto
name|while2end
goto|;
break|break;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
default|default:
block|{
name|int
name|length
decl_stmt|;
operator|--
name|ibp
expr_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|ibp
argument_list|,
name|limit
operator|-
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
operator|--
name|obp
expr_stmt|;
name|bcopy
argument_list|(
name|ibp
argument_list|,
name|obp
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|length
expr_stmt|;
name|ibp
operator|+=
name|length
expr_stmt|;
block|}
else|else
operator|++
name|ibp
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
block|}
block|}
name|while2end
label|:
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ibp
operator|!=
literal|'*'
operator|&&
operator|!
operator|(
name|cplusplus_comments
operator|&&
operator|*
name|ibp
operator|==
literal|'/'
operator|)
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'/'
condition|)
block|{
comment|/* C++ style comment...  */
name|start_line
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* Comments are equivalent to spaces.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
name|obp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|{
name|U_CHAR
modifier|*
name|before_bp
init|=
name|ibp
decl_stmt|;
while|while
condition|(
operator|++
name|ibp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|put_out_comments
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|before_bp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
name|ibp
operator|-
name|before_bp
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|ibp
operator|-
name|before_bp
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|ibp
operator|+
literal|1
operator|<
name|limit
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|warn_comments
condition|)
name|warning
argument_list|(
literal|"multiline `//' comment"
argument_list|)
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* Copy the newline into the output buffer, in order to 		       avoid the pain of a #line every time a multiline comment 		       is seen.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
operator|++
name|ibp
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|ibp
argument_list|,
name|limit
operator|-
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|ibp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
break|break;
block|}
block|}
comment|/* Ordinary C comment.  Skip it, optionally copying it to output.  */
name|start_line
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|ibp
expr_stmt|;
comment|/* Skip the star.  */
comment|/* If this cpp is for lint, we peek inside the comments: */
if|if
condition|(
name|for_lint
condition|)
block|{
name|U_CHAR
modifier|*
name|argbp
decl_stmt|;
name|int
name|cmdlen
decl_stmt|,
name|arglen
decl_stmt|;
name|char
modifier|*
name|lintcmd
init|=
name|get_lintcmd
argument_list|(
name|ibp
argument_list|,
name|limit
argument_list|,
operator|&
name|argbp
argument_list|,
operator|&
name|arglen
argument_list|,
operator|&
name|cmdlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|lintcmd
operator|!=
name|NULL
condition|)
block|{
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|cmdlen
operator|+
name|arglen
operator|+
literal|14
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
comment|/* I believe it is always safe to emit this newline: */
name|obp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|bcopy
argument_list|(
literal|"#pragma lint "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|obp
operator|+=
literal|13
expr_stmt|;
name|bcopy
argument_list|(
name|lintcmd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
name|cmdlen
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|cmdlen
expr_stmt|;
if|if
condition|(
name|arglen
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|obp
operator|++
operator|)
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
name|argbp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
name|arglen
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|arglen
expr_stmt|;
block|}
comment|/* OK, now bring us back to the state we were in before we entered 	     this branch.  We need #line because the #pragma's newline always 	     messes up the line count.  */
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|output_line_directive
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|limit
operator|-
name|ibp
operator|+
literal|2
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
operator|*
operator|(
name|obp
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
comment|/* Comments are equivalent to spaces. 	 Note that we already output the slash; we might not want it. 	 For -traditional, a comment is equivalent to nothing.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
name|obp
operator|--
expr_stmt|;
else|else
name|obp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
else|else
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|{
name|U_CHAR
modifier|*
name|before_bp
init|=
name|ibp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|ibp
operator|++
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|ibp
index|[
operator|-
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|warn_comments
condition|)
name|warning
argument_list|(
literal|"`/*' within comment"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'/'
condition|)
goto|goto
name|comment_end
goto|;
break|break;
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* Copy the newline into the output buffer, in order to 	       avoid the pain of a #line every time a multiline comment 	       is seen.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|limit
operator|<
name|ibp
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
goto|goto
name|limit_reached
goto|;
block|}
break|break;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
default|default:
block|{
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|ibp
argument_list|,
name|limit
operator|-
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|ibp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
block|}
block|}
name|comment_end
label|:
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|put_out_comments
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|before_bp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
name|ibp
operator|-
name|before_bp
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|ibp
operator|-
name|before_bp
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
name|is_idchar
index|[
literal|'$'
index|]
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"`$' in identifier"
argument_list|)
expr_stmt|;
goto|goto
name|letter
goto|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* If digit is not part of identifier, it starts a number, 	 which means that following letters are not an identifier. 	 "0x5" does not refer to an identifier "x5". 	 So copy all alphanumerics that follow without accumulating 	 as an identifier.  Periods also, for sake of "3.e7".  */
if|if
condition|(
name|ident_length
operator|==
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|ip
operator|->
name|macro
condition|)
block|{
while|while
condition|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|ibp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|is_idchar
index|[
name|c
index|]
operator|&&
name|c
operator|!=
literal|'.'
condition|)
block|{
operator|--
name|ibp
expr_stmt|;
break|break;
block|}
operator|*
name|obp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* A sign can be part of a preprocessing number 	     if it follows an `e' or `p'.  */
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'P'
condition|)
block|{
if|if
condition|(
operator|!
name|ip
operator|->
name|macro
condition|)
block|{
while|while
condition|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|ibp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'+'
operator|||
operator|*
name|ibp
operator|==
literal|'-'
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
comment|/* But traditional C does not let the token go past the sign, 		 and C89 does not allow `p'.  */
if|if
condition|(
name|traditional
operator|||
operator|(
name|c89
operator|&&
operator|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'P'
operator|)
operator|)
condition|)
break|break;
block|}
block|}
block|}
break|break;
block|}
comment|/* fall through */
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
name|letter
label|:
name|ident_length
operator|++
expr_stmt|;
comment|/* Compute step of hash function, to avoid a proc call on every token */
name|hash
operator|=
name|HASHSTEP
argument_list|(
name|hash
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|ip
operator|->
name|fname
operator|==
literal|0
operator|&&
operator|*
name|ibp
operator|==
literal|'-'
condition|)
block|{
comment|/* Newline - inhibits expansion of preceding token. 	   If expanding a macro arg, we keep the newline -. 	   In final output, it is deleted. 	   We recognize Newline - in macro bodies and macro args.  */
if|if
condition|(
operator|!
name|concatenated
condition|)
block|{
name|ident_length
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
name|obp
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* If expanding a macro arg, keep the newline -.  */
operator|*
name|obp
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
break|break;
block|}
comment|/* If reprocessing a macro expansion, newline is a special marker.  */
elseif|else
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
comment|/* Newline White is a "funny space" to separate tokens that are 	   supposed to be separate but without space between. 	   Here White means any whitespace character. 	   Newline - marks a recursive macro use that is not 	   supposed to be expandable.  */
if|if
condition|(
name|is_space
index|[
operator|*
name|ibp
index|]
condition|)
block|{
comment|/* Newline Space does not prevent expansion of preceding token 	     so expand the preceding token and then come back.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
comment|/* If generating final output, newline space makes a space.  */
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
name|obp
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
comment|/* And Newline Newline makes a newline, so count it.  */
if|if
condition|(
name|obp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* If expanding a macro arg, keep the newline space. 	       If the arg gets stringified, newline space makes nothing.  */
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Newline followed by something random?  */
break|break;
block|}
comment|/* If there is a pending identifier, handle it and come back here.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
comment|/* Update the line counts and output a #line if necessary.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|lineno
operator|!=
name|op
operator|->
name|lineno
condition|)
block|{
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|output_line_directive
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|limit
operator|-
name|ibp
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
block|}
break|break;
comment|/* Come here either after (1) a null character that is part of the input 	 or (2) at the end of the input, because there is a null there.  */
case|case
literal|0
case|:
if|if
condition|(
name|ibp
operator|<=
name|limit
condition|)
comment|/* Our input really contains a null character.  */
goto|goto
name|randomchar
goto|;
name|limit_reached
label|:
comment|/* At end of a macro-expansion level, pop it and read next level.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|--
expr_stmt|;
comment|/* If traditional, and we have an identifier that ends here, 	   process it now, so we get the right error for recursion.  */
if|if
condition|(
name|traditional
operator|&&
name|ident_length
operator|&&
operator|!
name|is_idchar
index|[
operator|*
name|instack
index|[
name|indepth
operator|-
literal|1
index|]
operator|.
name|bufp
index|]
condition|)
block|{
name|redo_char
operator|=
literal|1
expr_stmt|;
goto|goto
name|randomchar
goto|;
block|}
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
break|break;
block|}
comment|/* If we don't have a pending identifier, 	 return at end of input.  */
if|if
condition|(
name|ident_length
operator|==
literal|0
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|--
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
goto|goto
name|ending
goto|;
block|}
comment|/* If we do have a pending identifier, just consider this null 	 a special character and arrange to dispatch on it again. 	 The second time, IDENT_LENGTH will be zero so we will return.  */
comment|/* Fall through */
name|specialchar
label|:
comment|/* Handle the case of a character such as /, ', " or null 	 seen following an identifier.  Back over it so that 	 after the identifier is processed the special char 	 will be dispatched on again.  */
name|ibp
operator|--
expr_stmt|;
name|obp
operator|--
expr_stmt|;
name|redo_char
operator|=
literal|1
expr_stmt|;
default|default:
name|randomchar
label|:
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
comment|/* We have just seen an identifier end.  If it's a macro, expand it.  	   IDENT_LENGTH is the length of the identifier 	   and HASH is its hash code.  	   The identifier has already been copied to the output, 	   so if it is a macro we must remove it.  	   If REDO_CHAR is 0, the char that terminated the identifier 	   has been skipped in the output and the input. 	   OBP-IDENT_LENGTH-1 points to the identifier. 	   If the identifier is a macro, we must back over the terminator.  	   If REDO_CHAR is 1, the terminating char has already been 	   backed over.  OBP-IDENT_LENGTH points to the identifier.  */
if|if
condition|(
operator|!
name|pcp_outfile
operator|||
name|pcp_inside_if
condition|)
block|{
for|for
control|(
name|hp
operator|=
name|hashtab
index|[
name|MAKE_POS
argument_list|(
name|hash
argument_list|)
operator|%
name|HASHSIZE
index|]
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|length
operator|==
name|ident_length
condition|)
block|{
name|int
name|obufp_before_macroname
decl_stmt|;
name|int
name|op_lineno_before_macroname
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|ident_length
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|hp
operator|->
name|name
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|q
init|=
name|obp
operator|-
name|i
decl_stmt|;
name|int
name|disabled
decl_stmt|;
if|if
condition|(
operator|!
name|redo_char
condition|)
name|q
operator|--
expr_stmt|;
do|do
block|{
comment|/* All this to avoid a strncmp () */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|q
operator|++
condition|)
goto|goto
name|hashcollision
goto|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
comment|/* We found a use of a macro name. 		 see if the context shows it is a macro call.  */
comment|/* Back up over terminating character if not already done.  */
if|if
condition|(
operator|!
name|redo_char
condition|)
block|{
name|ibp
operator|--
expr_stmt|;
name|obp
operator|--
expr_stmt|;
block|}
comment|/* Save this as a displacement from the beginning of the output 		 buffer.  We can not save this as a position in the output 		 buffer, because it may get realloc'ed by RECACHE.  */
name|obufp_before_macroname
operator|=
operator|(
name|obp
operator|-
name|op
operator|->
name|buf
operator|)
operator|-
name|ident_length
expr_stmt|;
name|op_lineno_before_macroname
operator|=
name|op
operator|->
name|lineno
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_PCSTRING
condition|)
block|{
name|pcstring_used
argument_list|(
name|hp
argument_list|)
expr_stmt|;
comment|/* Mark the definition of this key 				       as needed, ensuring that it 				       will be output.  */
break|break;
comment|/* Exit loop, since the key cannot have a 				   definition any longer.  */
block|}
comment|/* Record whether the macro is disabled.  */
name|disabled
operator|=
name|hp
operator|->
name|type
operator|==
name|T_DISABLED
expr_stmt|;
comment|/* This looks like a macro ref, but if the macro was disabled, 		 just copy its name and put in a marker if requested.  */
if|if
condition|(
name|disabled
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This error check caught useful cases such as 		   #define foo(x,y) bar (x (y,0), y) 		   foo (foo, baz)  */
block|if (traditional) 		  error ("recursive use of macro `%s'", hp->name);
endif|#
directive|endif
if|if
condition|(
name|output_marks
condition|)
block|{
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|limit
operator|-
name|ibp
operator|+
literal|2
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
break|break;
block|}
comment|/* If macro wants an arglist, verify that a '(' follows. 		 first skip all whitespace, copying it to the output 		 after the macro name.  Then, if there is no '(', 		 decide this is not a macro call and leave things that way.  */
if|if
condition|(
operator|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|||
name|hp
operator|->
name|type
operator|==
name|T_DISABLED
operator|)
operator|&&
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
name|U_CHAR
modifier|*
name|old_ibp
init|=
name|ibp
decl_stmt|;
name|U_CHAR
modifier|*
name|old_obp
init|=
name|obp
decl_stmt|;
name|int
name|old_iln
init|=
name|ip
operator|->
name|lineno
decl_stmt|;
name|int
name|old_oln
init|=
name|op
operator|->
name|lineno
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Scan forward over whitespace, copying it to the output.  */
if|if
condition|(
name|ibp
operator|==
name|limit
operator|&&
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
name|old_ibp
operator|=
name|ibp
expr_stmt|;
name|old_obp
operator|=
name|obp
expr_stmt|;
name|old_iln
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|old_oln
operator|=
name|op
operator|->
name|lineno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_space
index|[
operator|*
name|ibp
index|]
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|ibp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|macro
operator|==
literal|0
condition|)
block|{
comment|/* Newline in a file.  Count it.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
comment|/* A newline mark, and we don't want marks 			     in the output.  If it is newline-hyphen, 			     discard it entirely.  Otherwise, it is 			     newline-whitechar, so keep the whitechar.  */
name|obp
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'-'
condition|)
name|ibp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A newline mark; copy both chars to the output.  */
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ip
operator|->
name|macro
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'/'
condition|)
block|{
comment|/* If a comment, copy it unchanged or discard it.  */
if|if
condition|(
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|put_out_comments
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
for|for
control|(
name|ibp
operator|+=
literal|2
init|;
name|ibp
operator|<
name|limit
condition|;
name|ibp
operator|++
control|)
block|{
comment|/* We need not worry about newline-marks, 			     since they are never found in comments.  */
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|ibp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|put_out_comments
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
comment|/* Newline in a file.  Count it.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|ibp
argument_list|,
name|limit
operator|-
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|put_out_comments
condition|)
block|{
name|bcopy
argument_list|(
name|ibp
argument_list|,
name|obp
argument_list|,
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
name|ibp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ibp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|cplusplus_comments
condition|)
block|{
if|if
condition|(
name|put_out_comments
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
for|for
control|(
name|ibp
operator|+=
literal|2
init|;
condition|;
name|ibp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|ibp
argument_list|,
name|limit
operator|-
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|put_out_comments
condition|)
block|{
name|bcopy
argument_list|(
name|ibp
argument_list|,
name|obp
argument_list|,
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
name|ibp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ibp
operator|+=
literal|2
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|ibp
operator|!=
literal|'('
condition|)
block|{
comment|/* It isn't a macro call. 		       Put back the space that we just skipped.  */
name|ibp
operator|=
name|old_ibp
expr_stmt|;
name|obp
operator|=
name|old_obp
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
name|old_iln
expr_stmt|;
name|op
operator|->
name|lineno
operator|=
name|old_oln
expr_stmt|;
comment|/* Exit the for loop.  */
break|break;
block|}
block|}
comment|/* This is now known to be a macro call. 		 Discard the macro name from the output, 		 along with any following whitespace just copied, 		 but preserve newlines if not outputting marks since this 		 is more likely to do the right thing with line numbers.  */
name|obp
operator|=
name|op
operator|->
name|buf
operator|+
name|obufp_before_macroname
expr_stmt|;
if|if
condition|(
name|output_marks
condition|)
name|op
operator|->
name|lineno
operator|=
name|op_lineno_before_macroname
expr_stmt|;
else|else
block|{
name|int
name|newlines
init|=
name|op
operator|->
name|lineno
operator|-
name|op_lineno_before_macroname
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|newlines
operator|--
condition|)
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
comment|/* Prevent accidental token-pasting with a character 		 before the macro call.  */
if|if
condition|(
operator|!
name|traditional
operator|&&
name|obp
operator|!=
name|op
operator|->
name|buf
condition|)
block|{
switch|switch
condition|(
name|obp
index|[
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'%'
case|:
case|case
literal|'&'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'.'
case|:
case|case
literal|'/'
case|:
case|case
literal|':'
case|:
case|case
literal|'<'
case|:
case|case
literal|'='
case|:
case|case
literal|'>'
case|:
case|case
literal|'^'
case|:
case|case
literal|'|'
case|:
comment|/* If we are expanding a macro arg, make a newline marker 		     to separate the tokens.  If we are making real output, 		     a plain space will do.  */
if|if
condition|(
name|output_marks
condition|)
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
comment|/* Expand the macro, reading arguments as needed, 		 and push the expansion on the input stack.  */
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|macroexpand
argument_list|(
name|hp
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Reexamine input stack, since macroexpand has pushed 		 a new level on it.  */
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
break|break;
block|}
name|hashcollision
label|:
empty_stmt|;
block|}
comment|/* End hash-table-search loop */
block|}
name|ident_length
operator|=
name|hash
operator|=
literal|0
expr_stmt|;
comment|/* Stop collecting identifier */
name|redo_char
operator|=
literal|0
expr_stmt|;
name|concatenated
operator|=
literal|0
expr_stmt|;
block|}
comment|/* End if (ident_length> 0) */
block|}
comment|/* End switch */
block|}
comment|/* End per-char loop */
comment|/* Come here to return -- but first give an error message      if there was an unterminated successful conditional.  */
name|ending
label|:
if|if
condition|(
name|if_stack
operator|!=
name|ip
operator|->
name|if_stack
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
switch|switch
condition|(
name|if_stack
operator|->
name|type
condition|)
block|{
case|case
name|T_IF
case|:
name|str
operator|=
literal|"if"
expr_stmt|;
break|break;
case|case
name|T_IFDEF
case|:
name|str
operator|=
literal|"ifdef"
expr_stmt|;
break|break;
case|case
name|T_IFNDEF
case|:
name|str
operator|=
literal|"ifndef"
expr_stmt|;
break|break;
case|case
name|T_ELSE
case|:
name|str
operator|=
literal|"else"
expr_stmt|;
break|break;
case|case
name|T_ELIF
case|:
name|str
operator|=
literal|"elif"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|if_stack
operator|->
name|lineno
argument_list|)
argument_list|,
literal|"unterminated `#%s' conditional"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|=
name|ip
operator|->
name|if_stack
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Rescan a string into a temporary buffer and return the result  * as a FILE_BUF.  Note this function returns a struct, not a pointer.  *  * OUTPUT_MARKS nonzero means keep Newline markers found in the input  * and insert such markers when appropriate.  See `rescan' for details.  * OUTPUT_MARKS is 1 for macroexpanding a macro argument separately  * before substitution; it is 0 for other uses.  */
end_comment

begin_function
specifier|static
name|FILE_BUF
name|expand_to_temp_buffer
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|output_marks
parameter_list|,
name|assertions
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|output_marks
decl_stmt|,
name|assertions
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|FILE_BUF
name|obuf
decl_stmt|;
name|int
name|length
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|buf1
decl_stmt|;
name|int
name|odepth
init|=
name|indepth
decl_stmt|;
name|int
name|save_assertions_flag
init|=
name|assertions_flag
decl_stmt|;
name|assertions_flag
operator|=
name|assertions
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Set up the input on the input stack.  */
name|buf1
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|buf
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p2
init|=
name|buf1
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|limit
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
name|buf1
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Set up to receive the output.  */
name|obuf
operator|.
name|length
operator|=
name|length
operator|*
literal|2
operator|+
literal|100
expr_stmt|;
comment|/* Usually enough.  Why be stingy?  */
name|obuf
operator|.
name|bufp
operator|=
name|obuf
operator|.
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|obuf
operator|.
name|length
argument_list|)
expr_stmt|;
name|obuf
operator|.
name|nominal_fname
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|inc
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|dir
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|fname
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|macro
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|if_stack
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|system_header_p
operator|=
literal|0
expr_stmt|;
name|CHECK_DEPTH
argument_list|(
argument|{return obuf;}
argument_list|)
empty_stmt|;
operator|++
name|indepth
expr_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|nominal_fname_len
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|inc
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|buf1
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
name|obuf
operator|.
name|lineno
operator|=
literal|1
expr_stmt|;
comment|/* Scan the input, create the output.  */
name|rescan
argument_list|(
operator|&
name|obuf
argument_list|,
name|output_marks
argument_list|)
expr_stmt|;
comment|/* Pop input stack to original state.  */
operator|--
name|indepth
expr_stmt|;
if|if
condition|(
name|indepth
operator|!=
name|odepth
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Record the output.  */
name|obuf
operator|.
name|length
operator|=
name|obuf
operator|.
name|bufp
operator|-
name|obuf
operator|.
name|buf
expr_stmt|;
name|assertions_flag
operator|=
name|save_assertions_flag
expr_stmt|;
return|return
name|obuf
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Process a # directive.  Expects IP->bufp to point after the '#', as in  * `#define foo bar'.  Passes to the directive handler  * (do_define, do_include, etc.): the addresses of the 1st and  * last chars of the directive (starting immediately after the #  * keyword), plus op and the keyword table pointer.  If the directive  * contains comments it is copied into a temporary buffer sans comments  * and the temporary buffer is passed to the directive handler instead.  * Likewise for backslash-newlines.  *  * Returns nonzero if this was a known # directive.  * Otherwise, returns zero, without advancing the input pointer.  */
end_comment

begin_function
specifier|static
name|int
name|handle_directive
parameter_list|(
name|ip
parameter_list|,
name|op
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
decl|*
name|op
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
specifier|register
name|int
name|ident_length
decl_stmt|;
name|U_CHAR
modifier|*
name|resume_p
decl_stmt|;
comment|/* Nonzero means we must copy the entire directive      to get rid of comments or backslash-newlines.  */
name|int
name|copy_directive
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|ident
decl_stmt|,
modifier|*
name|after_ident
decl_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* Record where the directive started.  do_xifdef needs this.  */
name|directive_start
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
name|ignore_escape_flag
operator|=
literal|1
expr_stmt|;
comment|/* Skip whitespace and \-newline.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|!=
literal|' '
operator|&&
operator|*
name|bp
operator|!=
literal|'\t'
operator|&&
name|pedantic
condition|)
name|pedwarn_strange_white_space
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus_comments
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
break|break;
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|+
literal|2
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Now find end of directive name.      If we encounter a backslash-newline, exchange it with any following      symbol-constituents so that we end up with a contiguous name.  */
name|cp
operator|=
name|bp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_idchar
index|[
operator|*
name|cp
index|]
condition|)
name|cp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|name_newline_fix
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_idchar
index|[
operator|*
name|cp
index|]
condition|)
name|cp
operator|++
expr_stmt|;
else|else
break|break;
block|}
block|}
name|ident_length
operator|=
name|cp
operator|-
name|bp
expr_stmt|;
name|ident
operator|=
name|bp
expr_stmt|;
name|after_ident
operator|=
name|cp
expr_stmt|;
comment|/* A line of just `#' becomes blank.  */
if|if
condition|(
name|ident_length
operator|==
literal|0
operator|&&
operator|*
name|after_ident
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|after_ident
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ident_length
operator|==
literal|0
operator|||
operator|!
name|is_idstart
index|[
operator|*
name|ident
index|]
condition|)
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|ident
decl_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Handle # followed by a line number.  */
if|if
condition|(
name|p
operator|!=
name|ident
operator|&&
operator|!
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
block|{
specifier|static
name|struct
name|directive
name|line_directive_table
index|[]
init|=
block|{
block|{
literal|4
block|,
name|do_line
block|,
literal|"line"
block|,
name|T_LINE
block|}
block|,       }
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"`#' followed by integer"
argument_list|)
expr_stmt|;
name|after_ident
operator|=
name|ident
expr_stmt|;
name|kt
operator|=
name|line_directive_table
expr_stmt|;
name|ignore_escape_flag
operator|=
literal|0
expr_stmt|;
goto|goto
name|old_linenum
goto|;
block|}
comment|/* Avoid error for `###' and similar cases unless -pedantic.  */
if|if
condition|(
name|p
operator|==
name|ident
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|'#'
operator|||
name|is_hor_space
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lang_asm
condition|)
name|warning
argument_list|(
literal|"invalid preprocessing directive"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|lang_asm
condition|)
name|error
argument_list|(
literal|"invalid preprocessing directive name"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * Decode the keyword and call the appropriate expansion    * routine, after moving the input pointer up to the next line.    */
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|length
operator|>
literal|0
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|length
operator|==
name|ident_length
operator|&&
operator|!
name|bcmp
argument_list|(
name|kt
operator|->
name|name
argument_list|,
name|ident
argument_list|,
name|ident_length
argument_list|)
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
name|unterminated
decl_stmt|;
name|int
name|junk
decl_stmt|;
name|int
modifier|*
name|already_output
decl_stmt|;
comment|/* Nonzero means do not delete comments within the directive. 	 #define needs this when -traditional.  */
name|int
name|keep_comments
decl_stmt|;
name|old_linenum
label|:
name|limit
operator|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
expr_stmt|;
name|unterminated
operator|=
literal|0
expr_stmt|;
name|already_output
operator|=
literal|0
expr_stmt|;
name|keep_comments
operator|=
name|traditional
operator|&&
name|kt
operator|->
name|type
operator|==
name|T_DEFINE
expr_stmt|;
comment|/* #import is defined only in Objective C, or when on the NeXT.  */
if|if
condition|(
name|kt
operator|->
name|type
operator|==
name|T_IMPORT
operator|&&
operator|!
operator|(
name|objc
operator|||
name|lookup
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__NeXT__"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
condition|)
break|break;
comment|/* Find the end of this directive (first newline not backslashed 	 and not in a string or comment). 	 Set COPY_DIRECTIVE if the directive must be copied 	 (it contains a backslash-newline or a comment).  */
name|buf
operator|=
name|bp
operator|=
name|after_ident
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|bp
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|copy_directive
operator|=
literal|1
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|traditional
condition|)
name|bp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'"'
case|:
comment|/* "..." is special for #include.  */
if|if
condition|(
name|IS_INCLUDE_DIRECTIVE_TYPE
argument_list|(
name|kt
operator|->
name|type
argument_list|)
condition|)
block|{
while|while
condition|(
name|bp
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'"'
condition|)
block|{
name|bp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|copy_directive
operator|=
literal|1
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
break|break;
block|}
comment|/* Fall through.  */
case|case
literal|'\''
case|:
name|bp
operator|=
name|skip_quoted_string
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
name|limit
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|copy_directive
argument_list|,
operator|&
name|unterminated
argument_list|)
expr_stmt|;
comment|/* Don't bother calling the directive if we already got an error 	     message due to unterminated string.  Skip everything and pretend 	     we called the directive.  */
if|if
condition|(
name|unterminated
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
block|{
comment|/* Traditional preprocessing permits unterminated strings.  */
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
comment|/*<...> is special for #include.  */
case|case
literal|'<'
case|:
if|if
condition|(
operator|!
name|IS_INCLUDE_DIRECTIVE_TYPE
argument_list|(
name|kt
operator|->
name|type
argument_list|)
condition|)
break|break;
while|while
condition|(
name|bp
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|!=
literal|'>'
operator|&&
operator|*
name|bp
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|copy_directive
operator|=
literal|1
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus_comments
operator|&&
operator|*
name|bp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|U_CHAR
modifier|*
name|obp
init|=
name|bp
operator|-
literal|1
decl_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* No need to copy the directive because of a comment at the end; 	       just don't include the comment in the directive.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
block|{
name|U_CHAR
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|bp
init|;
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|=
name|obp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
block|}
comment|/* Don't remove the comments if -traditional.  */
if|if
condition|(
operator|!
name|keep_comments
condition|)
name|copy_directive
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\v'
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn_strange_white_space
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
operator|--
name|bp
expr_stmt|;
comment|/* Point to the newline */
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|endloop1
label|:
name|resume_p
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* BP is the end of the directive. 	 RESUME_P is the next interesting data after the directive. 	 A comment may come between.  */
comment|/* If a directive should be copied through, and -C was given, 	 pass it through before removing comments.  */
if|if
condition|(
operator|!
name|no_output
operator|&&
name|put_out_comments
operator|&&
operator|(
operator|(
name|kt
operator|->
name|type
operator|==
name|T_DEFINE
operator|||
name|kt
operator|->
name|type
operator|==
name|T_UNDEF
operator|)
condition|?
name|dump_macros
operator|==
name|dump_definitions
else|:
name|IS_INCLUDE_DIRECTIVE_TYPE
argument_list|(
name|kt
operator|->
name|type
argument_list|)
condition|?
name|dump_includes
else|:
name|kt
operator|->
name|type
operator|==
name|T_PRAGMA
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Output directive name.  */
name|check_expand
argument_list|(
name|op
argument_list|,
name|kt
operator|->
name|length
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Make sure # is at the start of a line */
if|if
condition|(
name|op
operator|->
name|bufp
operator|>
name|op
operator|->
name|buf
operator|&&
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'#'
expr_stmt|;
name|bcopy
argument_list|(
name|kt
operator|->
name|name
argument_list|,
name|op
operator|->
name|bufp
argument_list|,
name|kt
operator|->
name|length
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|kt
operator|->
name|length
expr_stmt|;
comment|/* Output arguments.  */
name|len
operator|=
operator|(
name|bp
operator|-
name|buf
operator|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
comment|/* Take account of any (escaped) newlines just output.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
name|buf
index|[
name|len
index|]
operator|==
literal|'\n'
condition|)
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
name|already_output
operator|=
operator|&
name|junk
expr_stmt|;
block|}
comment|/* Don't we need a newline or #line? */
if|if
condition|(
name|copy_directive
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|xp
init|=
name|buf
decl_stmt|;
comment|/* Need to copy entire directive into temp buffer before dispatching */
name|cp
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|bp
operator|-
name|buf
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* room for directive plus 						  some slop */
name|buf
operator|=
name|cp
expr_stmt|;
comment|/* Copy to the new buffer, deleting comments 	   and backslash-newlines (and whitespace surrounding the latter).  */
while|while
condition|(
name|xp
operator|<
name|bp
condition|)
block|{
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|xp
operator|++
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* A bare newline should never part of the line.  */
break|break;
comment|/*<...> is special for #include.  */
case|case
literal|'<'
case|:
if|if
condition|(
operator|!
name|IS_INCLUDE_DIRECTIVE_TYPE
argument_list|(
name|kt
operator|->
name|type
argument_list|)
condition|)
break|break;
while|while
condition|(
name|xp
operator|<
name|bp
operator|&&
name|c
operator|!=
literal|'>'
condition|)
block|{
name|c
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|xp
operator|<
name|bp
operator|&&
operator|*
name|xp
operator|==
literal|'\n'
condition|)
name|xp
operator|++
expr_stmt|;
else|else
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|xp
operator|==
literal|'\n'
condition|)
block|{
name|xp
operator|++
expr_stmt|;
name|cp
operator|--
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|buf
operator|&&
name|is_hor_space
index|[
name|cp
index|[
operator|-
literal|1
index|]
index|]
condition|)
block|{
while|while
condition|(
name|cp
operator|-
literal|1
operator|!=
name|buf
operator|&&
name|is_hor_space
index|[
name|cp
index|[
operator|-
literal|2
index|]
index|]
condition|)
name|cp
operator|--
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|xp
index|]
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|traditional
operator|&&
name|xp
operator|<
name|bp
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
block|{
name|int
name|backslash_newlines_p
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|bp1
init|=
name|skip_quoted_string
argument_list|(
name|xp
operator|-
literal|1
argument_list|,
name|bp
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
name|NULL_PTR
argument_list|,
operator|&
name|backslash_newlines_p
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
if|if
condition|(
name|backslash_newlines_p
condition|)
while|while
condition|(
name|xp
operator|!=
name|bp1
condition|)
block|{
comment|/* With something like:  			 #define X "a\ 			 b"  		       we should still remove the backslash-newline 		       pair as part of phase two.  */
if|if
condition|(
name|xp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|xp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|xp
operator|+=
literal|2
expr_stmt|;
else|else
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
block|}
else|else
comment|/* This is the same as the loop above, but taking 		   advantage of the fact that we know there are no 		   backslash-newline pairs.  */
while|while
condition|(
name|xp
operator|!=
name|bp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|xp
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus_comments
operator|&&
operator|*
name|xp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|xp
operator|+
literal|1
expr_stmt|;
comment|/* If we already copied the directive through, 		 already_output != 0 prevents outputting comment now.  */
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
name|already_output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_comments
condition|)
while|while
condition|(
name|xp
operator|!=
name|ip
operator|->
name|bufp
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
comment|/* Delete or replace the slash.  */
elseif|else
if|if
condition|(
name|traditional
condition|)
name|cp
operator|--
expr_stmt|;
else|else
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|xp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
block|}
block|}
comment|/* Null-terminate the copy.  */
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|resume_p
expr_stmt|;
comment|/* Some directives should be written out for cc1 to process, 	 just as if they were not defined.  And sometimes we're copying 	 directives through.  */
if|if
condition|(
operator|!
name|no_output
operator|&&
name|already_output
operator|==
literal|0
operator|&&
operator|(
name|kt
operator|->
name|type
operator|==
name|T_DEFINE
condition|?
operator|(
name|int
operator|)
name|dump_names
operator|<=
operator|(
name|int
operator|)
name|dump_macros
else|:
name|IS_INCLUDE_DIRECTIVE_TYPE
argument_list|(
name|kt
operator|->
name|type
argument_list|)
condition|?
name|dump_includes
else|:
name|kt
operator|->
name|type
operator|==
name|T_PRAGMA
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Output directive name.  */
name|check_expand
argument_list|(
name|op
argument_list|,
name|kt
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'#'
expr_stmt|;
name|bcopy
argument_list|(
name|kt
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|kt
operator|->
name|length
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|kt
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|type
operator|==
name|T_DEFINE
operator|&&
name|dump_macros
operator|==
name|dump_names
condition|)
block|{
comment|/* Output `#define name' only.  */
name|U_CHAR
modifier|*
name|xp
init|=
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|yp
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|yp
operator|=
name|xp
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|xp
index|]
condition|)
name|xp
operator|++
expr_stmt|;
name|len
operator|=
operator|(
name|xp
operator|-
name|yp
operator|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
name|yp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output entire directive.  */
name|len
operator|=
operator|(
name|cp
operator|-
name|buf
operator|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Don't we need a newline or #line? */
comment|/* Call the appropriate directive handler.  buf now points to 	 either the appropriate place in the input buffer, or to 	 the temp buffer if it was necessary to make one.  cp 	 points to the first char after the contents of the (possibly 	 copied) directive, in either case.  */
call|(
modifier|*
name|kt
operator|->
name|func
call|)
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|,
name|op
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* It is deliberate that we don't warn about undefined directives.      That is the responsibility of cc1.  */
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|tm
modifier|*
name|timestamp
parameter_list|()
block|{
specifier|static
name|struct
name|tm
modifier|*
name|timebuf
decl_stmt|;
if|if
condition|(
operator|!
name|timebuf
condition|)
block|{
name|time_t
name|t
init|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|timebuf
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|timebuf
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|monthnames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|, 			    }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * expand things like __FILE__.  Place the expansion into the output  * buffer *without* rescanning.  */
end_comment

begin_function
specifier|static
name|void
name|special_symbol
parameter_list|(
name|hp
parameter_list|,
name|op
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|true_indepth
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|tm
modifier|*
name|timebuf
decl_stmt|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
comment|/* For special `defined' keyword */
if|if
condition|(
name|pcp_outfile
operator|&&
name|pcp_inside_if
operator|&&
name|hp
operator|->
name|type
operator|!=
name|T_SPEC_DEFINED
operator|&&
name|hp
operator|->
name|type
operator|!=
name|T_CONST
condition|)
name|error
argument_list|(
literal|"Predefined macro `%s' used inside `#if' during precompilation"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"cccp error: not in any file?!"
argument_list|)
expr_stmt|;
return|return;
comment|/* the show must go on */
block|}
switch|switch
condition|(
name|hp
operator|->
name|type
condition|)
block|{
case|case
name|T_FILE
case|:
case|case
name|T_BASE_FILE
case|:
block|{
name|FILE_BUF
modifier|*
name|p
init|=
name|hp
operator|->
name|type
operator|==
name|T_FILE
condition|?
name|ip
else|:
operator|&
name|instack
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|string
init|=
name|p
operator|->
name|nominal_fname
decl_stmt|;
if|if
condition|(
name|string
condition|)
block|{
name|size_t
name|string_len
init|=
name|p
operator|->
name|nominal_fname_len
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
literal|4
operator|*
name|string_len
argument_list|)
expr_stmt|;
name|quote_string
argument_list|(
name|buf
argument_list|,
name|string
argument_list|,
name|string_len
argument_list|)
expr_stmt|;
block|}
else|else
name|buf
operator|=
literal|"\"\""
expr_stmt|;
break|break;
block|}
case|case
name|T_INCLUDE_LEVEL
case|:
name|true_indepth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
name|true_indepth
operator|++
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* Eight bytes ought to be more than enough */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|true_indepth
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_VERSION
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|version_string
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%s\""
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
case|case
name|T_SIZE_TYPE
case|:
name|buf
operator|=
name|SIZE_TYPE
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
case|case
name|T_PTRDIFF_TYPE
case|:
name|buf
operator|=
name|PTRDIFF_TYPE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_WCHAR_TYPE
case|:
name|buf
operator|=
name|wchar_type
expr_stmt|;
break|break;
case|case
name|T_USER_LABEL_PREFIX_TYPE
case|:
name|buf
operator|=
name|user_label_prefix
expr_stmt|;
break|break;
case|case
name|T_REGISTER_PREFIX_TYPE
case|:
name|buf
operator|=
name|REGISTER_PREFIX
expr_stmt|;
break|break;
case|case
name|T_IMMEDIATE_PREFIX_TYPE
case|:
name|buf
operator|=
name|IMMEDIATE_PREFIX
expr_stmt|;
break|break;
case|case
name|T_CONST
case|:
name|buf
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
expr_stmt|;
ifdef|#
directive|ifdef
name|STDC_0_IN_SYSTEM_HEADERS
if|if
condition|(
name|ip
operator|->
name|system_header_p
operator|&&
name|hp
operator|->
name|length
operator|==
literal|8
operator|&&
name|bcmp
argument_list|(
name|hp
operator|->
name|name
argument_list|,
literal|"__STDC__"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|lookup
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__STRICT_ANSI__"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|buf
operator|=
literal|"0"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pcp_inside_if
operator|&&
name|pcp_outfile
condition|)
comment|/* Output a precondition for this macro use */
name|fprintf
argument_list|(
name|pcp_outfile
argument_list|,
literal|"#define %s %s\n"
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SPECLINE
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_DATE
case|:
case|case
name|T_TIME
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|timebuf
operator|=
name|timestamp
argument_list|()
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_DATE
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%s %2d %4d\""
argument_list|,
name|monthnames
index|[
name|timebuf
operator|->
name|tm_mon
index|]
argument_list|,
name|timebuf
operator|->
name|tm_mday
argument_list|,
name|timebuf
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%02d:%02d:%02d\""
argument_list|,
name|timebuf
operator|->
name|tm_hour
argument_list|,
name|timebuf
operator|->
name|tm_min
argument_list|,
name|timebuf
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SPEC_DEFINED
case|:
name|buf
operator|=
literal|" 0 "
expr_stmt|;
comment|/* Assume symbol is not defined */
name|ip
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|==
literal|'('
condition|)
block|{
name|paren
operator|++
expr_stmt|;
name|ip
operator|->
name|bufp
operator|++
expr_stmt|;
comment|/* Skip over the paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|ip
operator|->
name|bufp
index|]
condition|)
goto|goto
name|oops
goto|;
if|if
condition|(
name|ip
operator|->
name|bufp
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
operator|(
name|ip
operator|->
name|bufp
index|[
literal|1
index|]
operator|==
literal|'\''
operator|||
name|ip
operator|->
name|bufp
index|[
literal|1
index|]
operator|==
literal|'"'
operator|)
condition|)
goto|goto
name|oops
goto|;
if|if
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pcp_outfile
operator|&&
name|pcp_inside_if
operator|&&
operator|(
name|hp
operator|->
name|type
operator|==
name|T_CONST
operator|||
operator|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|&&
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|predefined
operator|)
operator|)
condition|)
comment|/* Output a precondition for this macro use.  */
name|fprintf
argument_list|(
name|pcp_outfile
argument_list|,
literal|"#define %s\n"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
name|buf
operator|=
literal|" 1 "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pcp_outfile
operator|&&
name|pcp_inside_if
condition|)
block|{
comment|/* Output a precondition for this macro use */
name|U_CHAR
modifier|*
name|cp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|fprintf
argument_list|(
name|pcp_outfile
argument_list|,
literal|"#undef "
argument_list|)
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|cp
index|]
condition|)
comment|/* Ick! */
name|fputc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|pcp_outfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pcp_outfile
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|is_idchar
index|[
operator|*
name|ip
operator|->
name|bufp
index|]
condition|)
operator|++
name|ip
operator|->
name|bufp
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|!=
literal|')'
condition|)
goto|goto
name|oops
goto|;
operator|++
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
break|break;
name|oops
label|:
name|error
argument_list|(
literal|"`defined' without an identifier"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"cccp error: invalid special hash type"
argument_list|)
expr_stmt|;
comment|/* time for gdb */
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines to handle #directives */
end_comment

begin_comment
comment|/* Handle #include and #import.    This function expects to see "fname" or<fname> on the input.  */
end_comment

begin_function
specifier|static
name|int
name|do_include
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|importing
init|=
name|keyword
operator|->
name|type
operator|==
name|T_IMPORT
condition|?
operator|(
name|U_CHAR
operator|*
operator|)
literal|""
else|:
operator|(
name|U_CHAR
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|skip_dirs
init|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_INCLUDE_NEXT
operator|)
decl_stmt|;
specifier|static
name|int
name|import_warning
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Dynamically allocated fname buffer */
name|char
modifier|*
name|pcftry
decl_stmt|;
name|char
modifier|*
name|pcfname
decl_stmt|;
name|char
modifier|*
name|fbeg
decl_stmt|,
modifier|*
name|fend
decl_stmt|;
comment|/* Beginning and end of fname */
name|U_CHAR
modifier|*
name|fin
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|search_start
init|=
name|include
decl_stmt|;
comment|/* Chain of dirs to search */
name|struct
name|file_name_list
modifier|*
name|dsp
decl_stmt|;
comment|/* First in chain, if #include "..." */
name|struct
name|file_name_list
modifier|*
name|searchptr
init|=
literal|0
decl_stmt|;
name|size_t
name|flen
decl_stmt|;
name|int
name|f
init|=
operator|-
literal|3
decl_stmt|;
comment|/* file number */
name|struct
name|include_file
modifier|*
name|inc
init|=
literal|0
decl_stmt|;
name|int
name|retried
init|=
literal|0
decl_stmt|;
comment|/* Have already tried macro 				   expanding the include line*/
name|int
name|angle_brackets
init|=
literal|0
decl_stmt|;
comment|/* 0 for "...", 1 for<...> */
ifdef|#
directive|ifdef
name|VMS
name|int
name|vaxc_include
init|=
literal|0
decl_stmt|;
comment|/* 1 for token without punctuation */
endif|#
directive|endif
name|int
name|pcf
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|pcfbuf
decl_stmt|;
name|char
modifier|*
name|pcfbuflimit
decl_stmt|;
name|int
name|pcfnum
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
block|{
if|if
condition|(
name|importing
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow `#import'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_dirs
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow `#include_next'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|importing
operator|&&
name|warn_import
operator|&&
operator|!
name|inhibit_warnings
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
operator|&&
operator|!
name|import_warning
condition|)
block|{
name|import_warning
operator|=
literal|1
expr_stmt|;
name|warning
argument_list|(
literal|"using `#import' is not recommended"
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"The fact that a certain header file need not be processed more than once\n\ should be indicated in the header file, not where it is used.\n\ The best way to do this is with a conditional of this form:\n\ \n\   #ifndef _FOO_H_INCLUDED\n\   #define _FOO_H_INCLUDED\n\   ...<real contents of file> ...\n\   #endif /* Not _FOO_H_INCLUDED */\n\ \n\ Then users can use `#include' any number of times.\n\ GNU C automatically avoids processing the file more than once\n\ when it is equipped with such a conditional.\n"
argument_list|)
expr_stmt|;
block|}
name|get_filename
label|:
name|fin
operator|=
name|buf
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|fin
argument_list|)
expr_stmt|;
comment|/* Discard trailing whitespace so we can easily see      if we have parsed all the significant chars we were given.  */
while|while
condition|(
name|limit
operator|!=
name|fin
operator|&&
name|is_hor_space
index|[
name|limit
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|limit
operator|--
expr_stmt|;
name|fbeg
operator|=
name|fend
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|limit
operator|-
name|fin
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|fin
operator|++
condition|)
block|{
case|case
literal|'\"'
case|:
block|{
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
comment|/* Copy the operand text, concatenating the strings.  */
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fin
operator|==
name|limit
condition|)
goto|goto
name|invalid_include_file_name
goto|;
operator|*
name|fend
operator|=
operator|*
name|fin
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fend
operator|==
literal|'"'
condition|)
break|break;
name|fend
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fin
operator|==
name|limit
condition|)
break|break;
comment|/* If not at the end, there had better be another string.  */
comment|/* Skip just horiz space, and don't go past limit.  */
while|while
condition|(
name|fin
operator|!=
name|limit
operator|&&
name|is_hor_space
index|[
operator|*
name|fin
index|]
condition|)
name|fin
operator|++
expr_stmt|;
if|if
condition|(
name|fin
operator|!=
name|limit
operator|&&
operator|*
name|fin
operator|==
literal|'\"'
condition|)
name|fin
operator|++
expr_stmt|;
else|else
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* We have "filename".  Figure out directory this source 	 file is coming from and put it on the front of the list.  */
comment|/* If -I- was specified, don't search current dir, only spec'd ones.  */
if|if
condition|(
name|ignore_srcdir
condition|)
break|break;
for|for
control|(
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
init|;
name|fp
operator|>=
name|instack
condition|;
name|fp
operator|--
control|)
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|nam
decl_stmt|;
if|if
condition|(
operator|(
name|nam
operator|=
name|fp
operator|->
name|nominal_fname
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Found a named file.  Figure out dir of the file, 	       and put it in front of the search list.  */
name|dsp
operator|=
operator|(
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
operator|+
name|fp
operator|->
name|nominal_fname_len
argument_list|)
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|dsp
operator|->
name|fname
argument_list|,
name|nam
argument_list|)
expr_stmt|;
name|simplify_filename
argument_list|(
name|dsp
operator|->
name|fname
argument_list|)
expr_stmt|;
name|nam
operator|=
name|base_name
argument_list|(
name|dsp
operator|->
name|fname
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* for hack_vms_include_specification(), a local 	       dir specification must start with "./" on VMS.  */
if|if
condition|(
name|nam
operator|==
name|dsp
operator|->
name|fname
condition|)
block|{
operator|*
name|nam
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|nam
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|nam
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* But for efficiency's sake, do not insert the dir 	       if it matches the search list's first dir.  */
name|dsp
operator|->
name|next
operator|=
name|search_start
expr_stmt|;
if|if
condition|(
operator|!
name|search_start
operator|||
name|strcmp
argument_list|(
name|dsp
operator|->
name|fname
argument_list|,
name|search_start
operator|->
name|fname
argument_list|)
condition|)
block|{
name|search_start
operator|=
name|dsp
expr_stmt|;
name|n
operator|=
name|nam
operator|-
name|dsp
operator|->
name|fname
expr_stmt|;
if|if
condition|(
name|n
operator|+
name|INCLUDE_LEN_FUDGE
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|n
operator|+
name|INCLUDE_LEN_FUDGE
expr_stmt|;
block|}
name|dsp
index|[
literal|0
index|]
operator|.
name|got_name_map
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
case|case
literal|'<'
case|:
while|while
condition|(
name|fin
operator|!=
name|limit
operator|&&
operator|*
name|fin
operator|!=
literal|'>'
condition|)
operator|*
name|fend
operator|++
operator|=
operator|*
name|fin
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fin
operator|==
literal|'>'
operator|&&
name|fin
operator|+
literal|1
operator|==
name|limit
condition|)
block|{
name|angle_brackets
operator|=
literal|1
expr_stmt|;
comment|/* If -I-, start with the first -I dir after the -I-.  */
name|search_start
operator|=
name|first_bracket_include
expr_stmt|;
break|break;
block|}
goto|goto
name|fail
goto|;
default|default:
ifdef|#
directive|ifdef
name|VMS
comment|/*      * Support '#include xyz' like VAX-C to allow for easy use of all the      * decwindow include files. It defaults to '#include<xyz.h>' (so the      * code from case '<' is repeated here) and generates a warning.      * (Note: macro expansion of `xyz' takes precedence.)      */
comment|/* Note: The argument of ISALPHA() can be evaluated twice, so do        the pre-decrement outside of the macro. */
if|if
condition|(
name|retried
operator|&&
operator|(
operator|--
name|fin
operator|,
name|ISALPHA
argument_list|(
operator|*
operator|(
name|U_CHAR
operator|*
operator|)
operator|(
name|fin
operator|)
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|fin
operator|!=
name|limit
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|fin
argument_list|)
operator|)
condition|)
operator|*
name|fend
operator|++
operator|=
operator|*
name|fin
operator|++
expr_stmt|;
name|warning
argument_list|(
literal|"VAX-C-style include specification found, use '#include<filename.h>' !"
argument_list|)
expr_stmt|;
name|vaxc_include
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fin
operator|==
name|limit
condition|)
block|{
name|angle_brackets
operator|=
literal|1
expr_stmt|;
comment|/* If -I-, start with the first -I dir after the -I-.  */
name|search_start
operator|=
name|first_bracket_include
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|fail
label|:
if|if
condition|(
operator|!
name|retried
condition|)
block|{
comment|/* Expand buffer and then remove any newline markers. 	 We can't just tell expand_to_temp_buffer to omit the markers, 	 since it would put extra spaces in include file names.  */
name|FILE_BUF
name|trybuf
decl_stmt|;
name|U_CHAR
modifier|*
name|src
decl_stmt|;
name|int
name|errors_before_expansion
init|=
name|errors
decl_stmt|;
name|trybuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
operator|!=
name|errors_before_expansion
condition|)
block|{
name|free
argument_list|(
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|invalid_include_file_name
goto|;
block|}
name|src
operator|=
name|trybuf
operator|.
name|buf
expr_stmt|;
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|limit
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|src
operator|!=
name|trybuf
operator|.
name|bufp
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|limit
operator|++
operator|=
operator|*
name|src
operator|++
operator|)
condition|)
block|{
case|case
literal|'\n'
case|:
name|limit
operator|--
expr_stmt|;
name|src
operator|++
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
block|{
name|U_CHAR
modifier|*
name|src1
init|=
name|skip_quoted_string
argument_list|(
name|src
operator|-
literal|1
argument_list|,
name|trybuf
operator|.
name|bufp
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
while|while
condition|(
name|src
operator|!=
name|src1
condition|)
operator|*
name|limit
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
operator|*
name|limit
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|retried
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_filename
goto|;
block|}
name|invalid_include_file_name
label|:
name|error
argument_list|(
literal|"`#%s' expects \"FILENAME\" or<FILENAME>"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* For #include_next, skip in the search path      past the dir in which the containing file was found.  */
if|if
condition|(
name|skip_dirs
condition|)
block|{
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
init|;
name|fp
operator|>=
name|instack
condition|;
name|fp
operator|--
control|)
if|if
condition|(
name|fp
operator|->
name|fname
operator|!=
name|NULL
condition|)
block|{
comment|/* fp->dir is null if the containing file was specified 	   with an absolute file name.  In that case, don't skip anything.  */
if|if
condition|(
name|fp
operator|->
name|dir
condition|)
name|search_start
operator|=
name|fp
operator|->
name|dir
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|fend
operator|=
literal|0
expr_stmt|;
name|flen
operator|=
name|simplify_filename
argument_list|(
name|fbeg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flen
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"empty file name in `#%s'"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Allocate this permanently, because it gets stored in the definitions      of macros.  */
name|fname
operator|=
name|xmalloc
argument_list|(
name|max_include_len
operator|+
name|flen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* + 1 above for terminating null.  */
name|system_include_depth
operator|+=
name|angle_brackets
expr_stmt|;
comment|/* If specified file name is absolute, just open it.  */
if|if
condition|(
name|absolute_filename
argument_list|(
name|fbeg
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|)
expr_stmt|;
name|f
operator|=
name|open_include_file
argument_list|(
name|fname
argument_list|,
name|NULL_PTR
argument_list|,
name|importing
argument_list|,
operator|&
name|inc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
struct|struct
name|bypass_dir
block|{
name|struct
name|bypass_dir
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|searchptr
decl_stmt|;
block|}
modifier|*
modifier|*
name|bypass_slot
init|=
literal|0
struct|;
comment|/* Search directory path, trying to open the file.        Copy each filename tried into FNAME.  */
for|for
control|(
name|searchptr
operator|=
name|search_start
init|;
name|searchptr
condition|;
name|searchptr
operator|=
name|searchptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|searchptr
operator|==
name|first_bracket_include
condition|)
block|{
comment|/* Go to bypass directory if we know we've seen this file before.  */
specifier|static
name|struct
name|bypass_dir
modifier|*
name|bypass_hashtab
index|[
name|INCLUDE_HASHSIZE
index|]
decl_stmt|;
name|struct
name|bypass_dir
modifier|*
name|p
decl_stmt|;
name|bypass_slot
operator|=
operator|&
name|bypass_hashtab
index|[
name|hashf
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
name|fbeg
argument_list|,
name|flen
argument_list|,
name|INCLUDE_HASHSIZE
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|bypass_slot
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fbeg
argument_list|,
name|p
operator|->
name|fname
argument_list|)
condition|)
block|{
name|searchptr
operator|=
name|p
operator|->
name|searchptr
expr_stmt|;
name|bypass_slot
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|VMS
comment|/* Change this 1/2 Unix 1/2 VMS file specification into a          full VMS file specification */
if|if
condition|(
name|searchptr
operator|->
name|fname
index|[
literal|0
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|fname
argument_list|,
name|searchptr
operator|->
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
index|[
name|strlen
argument_list|(
name|fname
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|slashp
decl_stmt|;
name|slashp
operator|=
name|strchr
argument_list|(
name|fbeg
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* start at root-dir of logical device if no path given.  */
if|if
condition|(
name|slashp
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"[000000]"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|)
expr_stmt|;
comment|/* Fix up the filename */
name|hack_vms_include_specification
argument_list|(
name|fname
argument_list|,
name|vaxc_include
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a normal VMS filespec, so use it unchanged.  */
name|strcpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|)
expr_stmt|;
comment|/* if it's '#include filename', add the missing .h */
if|if
condition|(
name|vaxc_include
operator|&&
name|index
argument_list|(
name|fname
argument_list|,
literal|'.'
argument_list|)
operator|==
name|NULL
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|".h"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|strcpy
argument_list|(
name|fname
argument_list|,
name|searchptr
operator|->
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|f
operator|=
name|open_include_file
argument_list|(
name|fname
argument_list|,
name|searchptr
argument_list|,
name|importing
argument_list|,
operator|&
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|bypass_slot
operator|&&
name|searchptr
operator|!=
name|first_bracket_include
condition|)
block|{
comment|/* This is the first time we found this include file, 	     and we found it after first_bracket_include. 	     Record its location so that we can bypass to here next time.  */
name|struct
name|bypass_dir
modifier|*
name|p
init|=
operator|(
expr|struct
name|bypass_dir
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bypass_dir
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|next
operator|=
operator|*
name|bypass_slot
expr_stmt|;
name|p
operator|->
name|fname
operator|=
name|fname
operator|+
name|strlen
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
expr_stmt|;
name|p
operator|->
name|searchptr
operator|=
name|searchptr
expr_stmt|;
operator|*
name|bypass_slot
operator|=
name|p
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|VMS
comment|/* Our VMS hacks can produce invalid filespecs, so don't worry 	 about errors other than EACCES.  */
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
break|break;
else|#
directive|else
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|&&
name|errno
operator|!=
name|ENOTDIR
condition|)
break|break;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|f
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* The file was already included.  */
comment|/* If generating dependencies and -MG was specified, we assume missing        files are leaf files, living in the same directory as the source file        or other similar place; these missing files may be generated from        other files and may not exist yet (eg: y.tab.h).  */
block|}
elseif|else
if|if
condition|(
name|print_deps_missing_files
operator|&&
operator|(
name|system_include_depth
operator|!=
literal|0
operator|)
operator|<
name|print_deps
condition|)
block|{
comment|/* If it was requested as a system header file, 	   then assume it belongs in the first place to look for such.  */
if|if
condition|(
name|angle_brackets
condition|)
block|{
if|if
condition|(
name|search_start
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|search_start
operator|->
name|fname
argument_list|)
operator|+
name|strlen
argument_list|(
name|fbeg
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|search_start
operator|->
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|fbeg
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise, omit the directory, as if the file existed 	       in the directory with the source.  */
name|deps_output
argument_list|(
name|fbeg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If -M was specified, and this header file won't be added to the        dependency list, then don't count this as an error, because we can        still produce correct output.  Otherwise, we can't produce correct        output, because there may be dependencies we need inside the missing        file, and we don't know what directory this missing file exists in.  */
elseif|else
if|if
condition|(
literal|0
operator|<
name|print_deps
operator|&&
name|print_deps
operator|<=
operator|(
name|system_include_depth
operator|!=
literal|0
operator|)
condition|)
name|warning
argument_list|(
literal|"No include path in which to find %s"
argument_list|,
name|fbeg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|!=
operator|-
literal|3
condition|)
name|error_from_errno
argument_list|(
name|fbeg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No include path in which to find %s"
argument_list|,
name|fbeg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Actually process the file.  */
name|pcftry
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|pcfbuf
operator|=
literal|0
expr_stmt|;
name|pcfnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|no_precomp
condition|)
block|{
do|do
block|{
name|sprintf
argument_list|(
name|pcftry
argument_list|,
literal|"%s%d"
argument_list|,
name|fname
argument_list|,
name|pcfnum
operator|++
argument_list|)
expr_stmt|;
name|pcf
operator|=
name|open
argument_list|(
name|pcftry
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcf
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|pcf
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|pcftry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INO_T_EQ
argument_list|(
name|inc
operator|->
name|st
operator|.
name|st_ino
argument_list|,
name|s
operator|.
name|st_ino
argument_list|)
operator|||
name|inc
operator|->
name|st
operator|.
name|st_dev
operator|!=
name|s
operator|.
name|st_dev
condition|)
block|{
name|pcfbuf
operator|=
name|check_precompiled
argument_list|(
name|pcf
argument_list|,
operator|&
name|s
argument_list|,
name|fname
argument_list|,
operator|&
name|pcfbuflimit
argument_list|)
expr_stmt|;
comment|/* Don't need it any more.  */
name|close
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't need it at all.  */
name|close
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|pcf
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|pcfbuf
condition|)
do|;
block|}
comment|/* Actually process the file */
if|if
condition|(
name|pcfbuf
condition|)
block|{
name|pcfname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|pcftry
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pcfname
argument_list|,
name|pcftry
argument_list|)
expr_stmt|;
name|pcfinclude
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
name|pcfbuf
argument_list|,
operator|(
name|U_CHAR
operator|*
operator|)
name|fname
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
name|finclude
argument_list|(
name|f
argument_list|,
name|inc
argument_list|,
name|op
argument_list|,
name|is_system_include
argument_list|(
name|fname
argument_list|)
argument_list|,
name|searchptr
argument_list|)
expr_stmt|;
block|}
name|system_include_depth
operator|-=
name|angle_brackets
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Return nonzero if the given FILENAME is an absolute pathname which    designates a file within one of the known "system" include file    directories.  We assume here that if the given FILENAME looks like    it is the name of a file which resides either directly in a "system"    include file directory, or within any subdirectory thereof, then the    given file must be a "system" include file.  This function tells us    if we should suppress pedantic errors/warnings for the given FILENAME.     The value is 2 if the file is a C-language system header file    for which C++ should (on most systems) assume `extern "C"'.  */
end_comment

begin_function
specifier|static
name|int
name|is_system_include
parameter_list|(
name|filename
parameter_list|)
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|file_name_list
modifier|*
name|searchptr
decl_stmt|;
for|for
control|(
name|searchptr
operator|=
name|first_system_include
init|;
name|searchptr
condition|;
name|searchptr
operator|=
name|searchptr
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|,
name|filename
argument_list|,
name|strlen
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
argument_list|)
condition|)
return|return
name|searchptr
operator|->
name|c_system_include_path
operator|+
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Yield the non-directory suffix of a file name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|base_name
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|fname
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
if|if
condition|(
name|ISALPHA
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|s
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Skip device.  */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|']'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Skip directory.  */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|'>'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Skip alternate (int'n'l) dir.  */
if|if
condition|(
name|s
operator|!=
name|fname
condition|)
return|return
name|s
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DIR_SEPARATOR
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
name|DIR_SEPARATOR
argument_list|)
operator|)
condition|)
name|s
operator|=
name|p
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Yield nonzero if FILENAME is absolute (i.e. not relative).  */
end_comment

begin_function
specifier|static
name|int
name|absolute_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_UWIN
argument_list|)
operator|)
if|if
condition|(
name|ISALPHA
argument_list|(
name|filename
index|[
literal|0
index|]
argument_list|)
operator|&&
name|filename
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|filename
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* At present, any path that begins with a drive spec is absolute.  */
if|if
condition|(
name|ISALPHA
argument_list|(
name|filename
index|[
literal|0
index|]
argument_list|)
operator|&&
name|filename
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|index
argument_list|(
name|filename
argument_list|,
literal|':'
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|DIR_SEPARATOR
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
name|DIR_SEPARATOR
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns whether or not a given character is a directory separator.    Used by simplify_filename.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_dir_separator
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
return|return
operator|(
name|ch
operator|==
name|DIR_SEPARATOR
operator|)
if|#
directive|if
name|defined
argument_list|(
name|DIR_SEPARATOR_2
argument_list|)
operator|||
operator|(
name|ch
operator|==
name|DIR_SEPARATOR_2
operator|)
endif|#
directive|endif
return|;
block|}
end_function

begin_comment
comment|/* Remove unnecessary characters from FILENAME in place,    to avoid unnecessary filename aliasing.    Return the length of the resulting string.     Do only the simplifications allowed by Posix.    It is OK to miss simplifications on non-Posix hosts,    since this merely leads to suboptimal results.  */
end_comment

begin_function
specifier|static
name|size_t
name|simplify_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|from
init|=
name|filename
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
init|=
name|filename
decl_stmt|;
name|char
modifier|*
name|to0
decl_stmt|;
comment|/* Remove redundant initial /s.  */
if|if
condition|(
name|is_dir_separator
argument_list|(
operator|*
name|from
argument_list|)
condition|)
block|{
operator|*
name|to
operator|++
operator|=
name|DIR_SEPARATOR
expr_stmt|;
if|if
condition|(
name|is_dir_separator
argument_list|(
operator|*
operator|++
name|from
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_dir_separator
argument_list|(
operator|*
operator|++
name|from
argument_list|)
condition|)
block|{
comment|/* 3 or more initial /s are equivalent to 1 /.  */
while|while
condition|(
name|is_dir_separator
argument_list|(
operator|*
operator|++
name|from
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* On some hosts // differs from /; Posix allows this.  */
operator|*
name|to
operator|++
operator|=
name|DIR_SEPARATOR
expr_stmt|;
block|}
block|}
block|}
name|to0
operator|=
name|to
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|from
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|from
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|from
operator|+=
literal|2
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* Copy this component and trailing DIR_SEPARATOR, if any.  */
while|while
condition|(
operator|!
name|is_dir_separator
argument_list|(
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|to
index|[
operator|-
literal|1
index|]
condition|)
block|{
comment|/* Trim . component at end of nonempty name.  */
name|to
operator|-=
name|filename
operator|<=
name|to
operator|-
literal|3
operator|&&
name|to
index|[
operator|-
literal|3
index|]
operator|==
name|DIR_SEPARATOR
operator|&&
name|to
index|[
operator|-
literal|2
index|]
operator|==
literal|'.'
expr_stmt|;
comment|/* Trim unnecessary trailing /s.  */
while|while
condition|(
name|to0
operator|<
operator|--
name|to
operator|&&
name|to
index|[
operator|-
literal|1
index|]
operator|==
name|DIR_SEPARATOR
condition|)
continue|continue;
operator|*
name|to
operator|=
literal|0
expr_stmt|;
return|return
name|to
operator|-
name|filename
return|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|DIR_SEPARATOR_2
argument_list|)
comment|/* Simplify to one directory separator.  */
name|to
index|[
operator|-
literal|1
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Skip /s after a /.  */
while|while
condition|(
name|is_dir_separator
argument_list|(
operator|*
name|from
argument_list|)
condition|)
name|from
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The file_name_map structure holds a mapping of file names for a    particular directory.  This mapping is read from the file named    FILE_NAME_MAP_FILE in that directory.  Such a file can be used to    map filenames on a file system with severe filename restrictions,    such as DOS.  The format of the file name map file is just a series    of lines with two tokens on each line.  The first token is the name    to map, and the second token is the actual name to use.  */
end_comment

begin_struct
struct|struct
name|file_name_map
block|{
name|struct
name|file_name_map
modifier|*
name|map_next
decl_stmt|;
name|char
modifier|*
name|map_from
decl_stmt|;
name|char
modifier|*
name|map_to
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FILE_NAME_MAP_FILE
value|"header.gcc"
end_define

begin_comment
comment|/* Read a space delimited string of unlimited length from a stdio    file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_filename_string
parameter_list|(
name|ch
parameter_list|,
name|f
parameter_list|)
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|char
modifier|*
name|alloc
decl_stmt|,
modifier|*
name|set
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|20
expr_stmt|;
name|set
operator|=
name|alloc
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_space
index|[
name|ch
index|]
condition|)
block|{
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|!
name|is_space
index|[
name|ch
index|]
condition|)
block|{
if|if
condition|(
name|set
operator|-
name|alloc
operator|==
name|len
condition|)
block|{
name|len
operator|*=
literal|2
expr_stmt|;
name|alloc
operator|=
name|xrealloc
argument_list|(
name|alloc
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set
operator|=
name|alloc
operator|+
name|len
operator|/
literal|2
expr_stmt|;
block|}
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
operator|*
name|set
operator|=
literal|'\0'
expr_stmt|;
name|ungetc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|alloc
return|;
block|}
end_function

begin_comment
comment|/* Read the file name map file for DIRNAME.    If DIRNAME is empty, read the map file for the working directory;    otherwise DIRNAME must end in '/'.  */
end_comment

begin_function
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
parameter_list|(
name|dirname
parameter_list|)
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
comment|/* This structure holds a linked list of file name maps, one per      directory.  */
struct|struct
name|file_name_map_list
block|{
name|struct
name|file_name_map_list
modifier|*
name|map_list_next
decl_stmt|;
name|char
modifier|*
name|map_list_name
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|map_list_map
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|file_name_map_list
modifier|*
name|map_list
decl_stmt|;
specifier|register
name|struct
name|file_name_map_list
modifier|*
name|map_list_ptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|size_t
name|dirlen
decl_stmt|;
for|for
control|(
name|map_list_ptr
operator|=
name|map_list
init|;
name|map_list_ptr
condition|;
name|map_list_ptr
operator|=
name|map_list_ptr
operator|->
name|map_list_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map_list_ptr
operator|->
name|map_list_name
argument_list|,
name|dirname
argument_list|)
condition|)
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
name|map_list_ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_name
operator|=
name|xstrdup
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|NULL
expr_stmt|;
name|dirlen
operator|=
name|strlen
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|dirlen
operator|+
name|strlen
argument_list|(
name|FILE_NAME_MAP_FILE
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|FILE_NAME_MAP_FILE
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|tolen
decl_stmt|;
if|if
condition|(
name|is_space
index|[
name|ch
index|]
condition|)
continue|continue;
name|from
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|is_hor_space
index|[
name|ch
index|]
condition|)
empty_stmt|;
name|to
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|simplify_filename
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|tolen
operator|=
name|simplify_filename
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ptr
operator|->
name|map_from
operator|=
name|from
expr_stmt|;
comment|/* Make the real filename absolute.  */
if|if
condition|(
name|absolute_filename
argument_list|(
name|to
argument_list|)
condition|)
name|ptr
operator|->
name|map_to
operator|=
name|to
expr_stmt|;
else|else
block|{
name|ptr
operator|->
name|map_to
operator|=
name|xmalloc
argument_list|(
name|dirlen
operator|+
name|tolen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
operator|->
name|map_to
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ptr
operator|->
name|map_to
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|->
name|map_next
operator|=
name|map_list_ptr
operator|->
name|map_list_map
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|map_list_ptr
operator|->
name|map_list_next
operator|=
name|map_list
expr_stmt|;
name|map_list
operator|=
name|map_list_ptr
expr_stmt|;
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
block|}
end_function

begin_comment
comment|/* Try to open include file FILENAME.  SEARCHPTR is the directory    being tried from the include file search path.    IMPORTING is "" if we are importing, null otherwise.    Return -2 if found, either a matching name or a matching inode.    Otherwise, open the file and return a file descriptor if successful    or -1 if unsuccessful.    Unless unsuccessful, put a descriptor of the included file into *PINC.    This function maps filenames on file systems based on information read by    read_name_map.  */
end_comment

begin_function
specifier|static
name|int
name|open_include_file
parameter_list|(
name|filename
parameter_list|,
name|searchptr
parameter_list|,
name|importing
parameter_list|,
name|pinc
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|searchptr
decl_stmt|;
name|U_CHAR
modifier|*
name|importing
decl_stmt|;
name|struct
name|include_file
modifier|*
modifier|*
name|pinc
decl_stmt|;
block|{
name|char
modifier|*
name|fname
init|=
name|remap
condition|?
name|remap_include_file
argument_list|(
name|filename
argument_list|,
name|searchptr
argument_list|)
else|:
name|filename
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|2
decl_stmt|;
comment|/* Look up FNAME in include_hashtab.  */
name|struct
name|include_file
modifier|*
modifier|*
name|phead
init|=
operator|&
name|include_hashtab
index|[
name|hashf
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|,
name|INCLUDE_HASHSIZE
argument_list|)
index|]
decl_stmt|;
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|,
modifier|*
name|head
init|=
operator|*
name|phead
decl_stmt|;
for|for
control|(
name|inc
operator|=
name|head
init|;
name|inc
condition|;
name|inc
operator|=
name|inc
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fname
argument_list|,
name|inc
operator|->
name|fname
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|inc
operator|||
operator|!
name|inc
operator|->
name|control_macro
operator|||
operator|(
name|inc
operator|->
name|control_macro
index|[
literal|0
index|]
operator|&&
operator|!
name|lookup
argument_list|(
name|inc
operator|->
name|control_macro
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
comment|/* if #include<dir/file> fails, try again with hacked spec.  */
if|if
condition|(
operator|!
name|hack_vms_include_specification
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fd
return|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
endif|#
directive|endif
return|return
name|fd
return|;
block|}
if|if
condition|(
operator|!
name|inc
condition|)
block|{
comment|/* FNAME was not in include_hashtab; insert a new entry.  */
name|inc
operator|=
operator|(
expr|struct
name|include_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|include_file
argument_list|)
argument_list|)
expr_stmt|;
name|inc
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|inc
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|inc
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|inc
operator|->
name|deps_output
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|inc
operator|->
name|st
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
operator|*
name|phead
operator|=
name|inc
expr_stmt|;
comment|/* Look for another file with the same inode and device.  */
if|if
condition|(
name|lookup_ino_include
argument_list|(
name|inc
argument_list|)
operator|&&
name|inc
operator|->
name|control_macro
operator|&&
operator|(
operator|!
name|inc
operator|->
name|control_macro
index|[
literal|0
index|]
operator|||
name|lookup
argument_list|(
name|inc
operator|->
name|control_macro
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
comment|/* For -M, add this file to the dependencies.  */
if|if
condition|(
operator|!
name|inc
operator|->
name|deps_output
operator|&&
operator|(
name|system_include_depth
operator|!=
literal|0
operator|)
operator|<
name|print_deps
condition|)
block|{
name|inc
operator|->
name|deps_output
operator|=
literal|1
expr_stmt|;
name|deps_output
argument_list|(
name|fname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* Handle -H option.  */
if|if
condition|(
name|print_include_names
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s%s\n"
argument_list|,
name|indepth
argument_list|,
literal|""
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|importing
condition|)
name|inc
operator|->
name|control_macro
operator|=
name|importing
expr_stmt|;
operator|*
name|pinc
operator|=
name|inc
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* Return the remapped name of the include file FILENAME.    SEARCHPTR is the directory being tried from the include file path.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|remap_include_file
parameter_list|(
name|filename
parameter_list|,
name|searchptr
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|searchptr
decl_stmt|;
block|{
specifier|register
name|struct
name|file_name_map
modifier|*
name|map
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
if|if
condition|(
name|searchptr
condition|)
block|{
if|if
condition|(
operator|!
name|searchptr
operator|->
name|got_name_map
condition|)
block|{
name|searchptr
operator|->
name|name_map
operator|=
name|read_name_map
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
expr_stmt|;
name|searchptr
operator|->
name|got_name_map
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check the mapping for the directory we are using.  */
name|from
operator|=
name|filename
operator|+
name|strlen
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
expr_stmt|;
for|for
control|(
name|map
operator|=
name|searchptr
operator|->
name|name_map
init|;
name|map
condition|;
name|map
operator|=
name|map
operator|->
name|map_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map
operator|->
name|map_from
argument_list|,
name|from
argument_list|)
condition|)
return|return
name|map
operator|->
name|map_to
return|;
block|}
name|from
operator|=
name|base_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|!=
name|filename
operator|||
operator|!
name|searchptr
condition|)
block|{
comment|/* Try to find a mapping file for the particular directory we are 	 looking in.  Thus #include<sys/types.h> will look up sys/types.h 	 in /usr/include/header.gcc and look up types.h in 	 /usr/include/sys/header.gcc.  */
name|char
modifier|*
name|dir
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|from
operator|-
name|filename
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|filename
argument_list|,
name|dir
argument_list|,
name|from
operator|-
name|filename
argument_list|)
expr_stmt|;
name|dir
index|[
name|from
operator|-
name|filename
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|map
operator|=
name|read_name_map
argument_list|(
name|dir
argument_list|)
init|;
name|map
condition|;
name|map
operator|=
name|map
operator|->
name|map_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map
operator|->
name|map_from
argument_list|,
name|from
argument_list|)
condition|)
return|return
name|map
operator|->
name|map_to
return|;
block|}
return|return
name|filename
return|;
block|}
end_function

begin_comment
comment|/* Insert INC into the include file table, hashed by device and inode number.    If a file with different name but same dev+ino was already in the table,    return 1 and set INC's control macro to the already-known macro.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_ino_include
parameter_list|(
name|inc
parameter_list|)
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|;
block|{
name|int
name|hash
init|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|inc
operator|->
name|st
operator|.
name|st_dev
operator|+
name|INO_T_HASH
argument_list|(
name|inc
operator|->
name|st
operator|.
name|st_ino
argument_list|)
argument_list|)
operator|%
name|INCLUDE_HASHSIZE
operator|)
decl_stmt|;
name|struct
name|include_file
modifier|*
name|i
init|=
name|include_ino_hashtab
index|[
name|hash
index|]
decl_stmt|;
name|inc
operator|->
name|next_ino
operator|=
name|i
expr_stmt|;
name|include_ino_hashtab
index|[
name|hash
index|]
operator|=
name|inc
expr_stmt|;
for|for
control|(
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next_ino
control|)
if|if
condition|(
name|INO_T_EQ
argument_list|(
name|inc
operator|->
name|st
operator|.
name|st_ino
argument_list|,
name|i
operator|->
name|st
operator|.
name|st_ino
argument_list|)
operator|&&
name|inc
operator|->
name|st
operator|.
name|st_dev
operator|==
name|i
operator|->
name|st
operator|.
name|st_dev
condition|)
block|{
name|inc
operator|->
name|control_macro
operator|=
name|i
operator|->
name|control_macro
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process file descriptor F, which corresponds to include file INC,    with output to OP.    SYSTEM_HEADER_P is 1 if this file resides in any one of the known    "system" include directories (as decided by the `is_system_include'    function above).    DIRPTR is the link in the dir path through which this file was found,    or 0 if the file name was absolute.  */
end_comment

begin_function
specifier|static
name|void
name|finclude
parameter_list|(
name|f
parameter_list|,
name|inc
parameter_list|,
name|op
parameter_list|,
name|system_header_p
parameter_list|,
name|dirptr
parameter_list|)
name|int
name|f
decl_stmt|;
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
name|int
name|system_header_p
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|dirptr
decl_stmt|;
block|{
name|char
modifier|*
name|fname
init|=
name|inc
operator|->
name|fname
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
comment|/* For input stack frame */
name|int
name|missing_newline
init|=
literal|0
decl_stmt|;
name|CHECK_DEPTH
argument_list|(
argument|return;
argument_list|)
empty_stmt|;
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
operator|+
literal|1
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|FILE_BUF
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|fp
operator|->
name|nominal_fname_len
operator|=
name|strlen
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|fp
operator|->
name|inc
operator|=
name|inc
expr_stmt|;
name|fp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|fp
operator|->
name|system_header_p
operator|=
name|system_header_p
expr_stmt|;
name|fp
operator|->
name|dir
operator|=
name|dirptr
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|inc
operator|->
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|size_t
name|s
init|=
operator|(
name|size_t
operator|)
name|inc
operator|->
name|st
operator|.
name|st_size
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|inc
operator|->
name|st
operator|.
name|st_size
operator|||
name|s
operator|+
literal|2
operator|<
name|s
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|s
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
comment|/* Read the file contents, knowing that s is an upper bound        on the number of bytes we can read.  */
name|fp
operator|->
name|length
operator|=
name|safe_read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|length
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|inc
operator|->
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"directory `%s' specified in #include"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Cannot count its file size before reading.        First read the entire file into heap and        copy them into buffer on stack.  */
name|int
name|bsize
init|=
literal|2000
decl_stmt|;
name|int
name|st_size
init|=
literal|0
decl_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|safe_read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|buf
operator|+
name|st_size
argument_list|,
name|bsize
operator|-
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
comment|/* error! */
name|st_size
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|st_size
operator|!=
name|bsize
condition|)
break|break;
comment|/* End of file */
name|bsize
operator|*=
literal|2
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|fp
operator|->
name|buf
argument_list|,
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
name|fp
operator|->
name|length
operator|=
name|st_size
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fp
operator|->
name|length
operator|>
literal|0
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
comment|/* Backslash-newline at end is not good enough.  */
operator|||
operator|(
name|fp
operator|->
name|length
operator|>
literal|1
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|2
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|missing_newline
operator|=
literal|1
expr_stmt|;
block|}
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Close descriptor now, so nesting does not use lots of descriptors.  */
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Must do this before calling trigraph_pcp, so that the correct file name      will be printed in warning messages.  */
name|indepth
operator|++
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|no_trigraphs
condition|)
name|trigraph_pcp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
name|fp
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|enter_file
argument_list|)
expr_stmt|;
name|rescan
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|missing_newline
condition|)
name|fp
operator|->
name|lineno
operator|--
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|missing_newline
condition|)
name|pedwarn
argument_list|(
literal|"file does not end in newline"
argument_list|)
expr_stmt|;
name|indepth
operator|--
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
name|output_line_directive
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|leave_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return;
name|nope
label|:
name|perror_with_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that inclusion of the include file INC    should be controlled by the macro named MACRO_NAME.    This means that trying to include the file again    will do something if that macro is defined.  */
end_comment

begin_function
specifier|static
name|void
name|record_control_macro
parameter_list|(
name|inc
parameter_list|,
name|macro_name
parameter_list|)
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|;
name|U_CHAR
modifier|*
name|macro_name
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|inc
operator|->
name|control_macro
operator|||
name|inc
operator|->
name|control_macro
index|[
literal|0
index|]
condition|)
name|inc
operator|->
name|control_macro
operator|=
name|macro_name
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load the specified precompiled header into core, and verify its    preconditions.  PCF indicates the file descriptor to read, which must    be a regular file.  *ST is its file status.    FNAME indicates the file name of the original header.    *LIMIT will be set to an address one past the end of the file.    If the preconditions of the file are not satisfied, the buffer is     freed and we return 0.  If the preconditions are satisfied, return    the address of the buffer following the preconditions.  The buffer, in    this case, should never be freed because various pieces of it will    be referred to until all precompiled strings are output at the end of    the run.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|check_precompiled
parameter_list|(
name|pcf
parameter_list|,
name|st
parameter_list|,
name|fname
parameter_list|,
name|limit
parameter_list|)
name|int
name|pcf
decl_stmt|;
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
name|char
modifier|*
name|fname
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
modifier|*
name|limit
decl_stmt|;
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|pcp_outfile
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
block|{
name|size_t
name|s
init|=
operator|(
name|size_t
operator|)
name|st
operator|->
name|st_size
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|st
operator|->
name|st_size
operator|||
name|s
operator|+
literal|2
operator|<
name|s
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|s
operator|+
literal|2
argument_list|)
expr_stmt|;
name|length
operator|=
name|safe_read
argument_list|(
name|pcf
argument_list|,
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
name|buf
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|buf
index|[
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|limit
operator|=
name|buf
operator|+
name|length
expr_stmt|;
comment|/* File is in core.  Check the preconditions.  */
if|if
condition|(
operator|!
name|check_preconditions
argument_list|(
name|buf
argument_list|)
condition|)
goto|goto
name|nope
goto|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
empty_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PCP
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using preinclude %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|cp
operator|+
literal|1
return|;
name|nope
label|:
ifdef|#
directive|ifdef
name|DEBUG_PCP
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot use preinclude %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* PREC (null terminated) points to the preconditions of a    precompiled header.  These are a series of #define and #undef    lines which must match the current contents of the hash    table.  */
end_comment

begin_function
specifier|static
name|int
name|check_preconditions
parameter_list|(
name|prec
parameter_list|)
name|char
modifier|*
name|prec
decl_stmt|;
block|{
name|MACRODEF
name|mdef
decl_stmt|;
name|char
modifier|*
name|lineend
decl_stmt|;
while|while
condition|(
operator|*
name|prec
condition|)
block|{
name|lineend
operator|=
name|index
argument_list|(
name|prec
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prec
operator|++
operator|!=
literal|'#'
condition|)
block|{
name|error
argument_list|(
literal|"Bad format encountered while reading precompiled file"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|prec
argument_list|,
literal|"define"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|prec
operator|+=
literal|6
expr_stmt|;
name|mdef
operator|=
name|create_definition
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
name|prec
argument_list|,
operator|(
name|U_CHAR
operator|*
operator|)
name|lineend
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdef
operator|.
name|defn
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
operator|&&
name|hp
operator|->
name|type
operator|!=
name|T_CONST
operator|)
operator|||
operator|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|&&
operator|!
name|compare_defs
argument_list|(
name|mdef
operator|.
name|defn
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
argument_list|)
operator|&&
operator|(
name|mdef
operator|.
name|defn
operator|->
name|length
operator|!=
literal|2
operator|||
name|mdef
operator|.
name|defn
operator|->
name|expansion
index|[
literal|0
index|]
operator|!=
literal|'\n'
operator|||
name|mdef
operator|.
name|defn
operator|->
name|expansion
index|[
literal|1
index|]
operator|!=
literal|' '
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|prec
argument_list|,
literal|"undef"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|prec
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|(
name|U_CHAR
operator|)
operator|*
name|prec
index|]
condition|)
name|prec
operator|++
expr_stmt|;
name|name
operator|=
name|prec
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|(
name|U_CHAR
operator|)
operator|*
name|prec
index|]
condition|)
name|prec
operator|++
expr_stmt|;
name|len
operator|=
name|prec
operator|-
name|name
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
name|name
argument_list|,
name|len
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Bad format encountered while reading precompiled file"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|prec
operator|=
name|lineend
operator|+
literal|1
expr_stmt|;
block|}
comment|/* They all passed successfully */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Process the main body of a precompiled file.  BUF points to the    string section of the file, following the preconditions.  LIMIT is one    character past the end.  NAME is the name of the file being read    in.  OP is the main output buffer.  */
end_comment

begin_function
specifier|static
name|void
name|pcfinclude
parameter_list|(
name|buf
parameter_list|,
name|name
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
name|tmpbuf
decl_stmt|;
name|int
name|nstrings
decl_stmt|;
name|U_CHAR
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
comment|/* First in the file comes 4 bytes indicating the number of strings, */
comment|/* in network byte order. (MSB first).  */
name|nstrings
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|nstrings
operator|=
operator|(
name|nstrings
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
name|nstrings
operator|=
operator|(
name|nstrings
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
name|nstrings
operator|=
operator|(
name|nstrings
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* Looping over each string...  */
while|while
condition|(
name|nstrings
operator|--
condition|)
block|{
name|U_CHAR
modifier|*
name|string_start
decl_stmt|;
name|U_CHAR
modifier|*
name|endofthiskey
decl_stmt|;
name|STRINGDEF
modifier|*
name|str
decl_stmt|;
name|int
name|nkeys
decl_stmt|;
comment|/* Each string starts with a STRINGDEF structure (str), followed */
comment|/* by the text of the string (string_start) */
comment|/* First skip to a longword boundary */
comment|/* ??? Why a 4-byte boundary?  On all machines? */
comment|/* NOTE: This works correctly even if size_t        is narrower than a pointer.        Do not try risky measures here to get another type to use!        Do not include stddef.h--it will fail!  */
if|if
condition|(
operator|(
name|size_t
operator|)
name|cp
operator|&
literal|3
condition|)
name|cp
operator|+=
literal|4
operator|-
operator|(
operator|(
name|size_t
operator|)
name|cp
operator|&
literal|3
operator|)
expr_stmt|;
comment|/* Now get the string.  */
name|str
operator|=
operator|(
name|STRINGDEF
operator|*
operator|)
operator|(
name|GENERIC_PTR
operator|)
name|cp
expr_stmt|;
name|string_start
operator|=
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|STRINGDEF
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
comment|/* skip the string */
empty_stmt|;
comment|/* We need to macro expand the string here to ensure that the        proper definition environment is in place.  If it were only        expanded when we find out it is needed, macros necessary for        its proper expansion might have had their definitions changed.  */
name|tmpbuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|string_start
argument_list|,
name|cp
operator|++
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Lineno is already set in the precompiled file */
name|str
operator|->
name|contents
operator|=
name|tmpbuf
operator|.
name|buf
expr_stmt|;
name|str
operator|->
name|len
operator|=
name|tmpbuf
operator|.
name|length
expr_stmt|;
name|str
operator|->
name|writeflag
operator|=
literal|0
expr_stmt|;
name|str
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|str
operator|->
name|output_mark
operator|=
name|outbuf
operator|.
name|bufp
operator|-
name|outbuf
operator|.
name|buf
expr_stmt|;
name|str
operator|->
name|chain
operator|=
literal|0
expr_stmt|;
operator|*
name|stringlist_tailp
operator|=
name|str
expr_stmt|;
name|stringlist_tailp
operator|=
operator|&
name|str
operator|->
name|chain
expr_stmt|;
comment|/* Next comes a fourbyte number indicating the number of keys        for this string.  */
name|nkeys
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|nkeys
operator|=
operator|(
name|nkeys
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
name|nkeys
operator|=
operator|(
name|nkeys
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
name|nkeys
operator|=
operator|(
name|nkeys
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* If this number is -1, then the string is mandatory.  */
if|if
condition|(
name|nkeys
operator|==
operator|-
literal|1
condition|)
name|str
operator|->
name|writeflag
operator|=
literal|1
expr_stmt|;
else|else
comment|/* Otherwise, for each key, */
for|for
control|(
init|;
name|nkeys
operator|--
condition|;
name|free
argument_list|(
name|tmpbuf
operator|.
name|buf
argument_list|)
operator|,
name|cp
operator|=
name|endofthiskey
operator|+
literal|1
control|)
block|{
name|KEYDEF
modifier|*
name|kp
init|=
operator|(
name|KEYDEF
operator|*
operator|)
operator|(
name|GENERIC_PTR
operator|)
name|cp
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
comment|/* It starts with a KEYDEF structure */
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|KEYDEF
argument_list|)
expr_stmt|;
comment|/* Find the end of the key.  At the end of this for loop we 	   advance CP to the start of the next key using this variable.  */
name|endofthiskey
operator|=
name|cp
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
name|kp
operator|->
name|str
operator|=
name|str
expr_stmt|;
comment|/* Expand the key, and enter it into the hash table.  */
name|tmpbuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|cp
argument_list|,
name|endofthiskey
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmpbuf
operator|.
name|bufp
operator|=
name|tmpbuf
operator|.
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|tmpbuf
operator|.
name|bufp
index|]
condition|)
name|tmpbuf
operator|.
name|bufp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|tmpbuf
operator|.
name|bufp
index|]
operator|||
name|tmpbuf
operator|.
name|bufp
operator|==
name|tmpbuf
operator|.
name|buf
operator|+
name|tmpbuf
operator|.
name|length
condition|)
block|{
name|str
operator|->
name|writeflag
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|hp
operator|=
name|lookup
argument_list|(
name|tmpbuf
operator|.
name|bufp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|kp
operator|->
name|chain
operator|=
literal|0
expr_stmt|;
name|install
argument_list|(
name|tmpbuf
operator|.
name|bufp
argument_list|,
operator|-
literal|1
argument_list|,
name|T_PCSTRING
argument_list|,
operator|(
name|char
operator|*
operator|)
name|kp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_PCSTRING
condition|)
block|{
name|kp
operator|->
name|chain
operator|=
name|hp
operator|->
name|value
operator|.
name|keydef
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|keydef
operator|=
name|kp
expr_stmt|;
block|}
else|else
name|str
operator|->
name|writeflag
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* This output_line_directive serves to switch us back to the current      input file in case some of these strings get output (which will       result in line directives for the header file being output).   */
name|output_line_directive
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|enter_file
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Called from rescan when it hits a key for strings.  Mark them all    used and clean up.  */
end_comment

begin_function
specifier|static
name|void
name|pcstring_used
parameter_list|(
name|hp
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
name|KEYDEF
modifier|*
name|kp
decl_stmt|;
for|for
control|(
name|kp
operator|=
name|hp
operator|->
name|value
operator|.
name|keydef
init|;
name|kp
condition|;
name|kp
operator|=
name|kp
operator|->
name|chain
control|)
name|kp
operator|->
name|str
operator|->
name|writeflag
operator|=
literal|1
expr_stmt|;
name|delete_macro
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the output, interspersing precompiled strings in their    appropriate places.  */
end_comment

begin_function
specifier|static
name|void
name|write_output
parameter_list|()
block|{
name|STRINGDEF
modifier|*
name|next_string
decl_stmt|;
name|U_CHAR
modifier|*
name|cur_buf_loc
decl_stmt|;
name|int
name|line_directive_len
init|=
literal|80
decl_stmt|;
name|char
modifier|*
name|line_directive
init|=
name|xmalloc
argument_list|(
name|line_directive_len
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* In each run through the loop, either cur_buf_loc ==      next_string_loc, in which case we print a series of strings, or      it is less than next_string_loc, in which case we write some of      the buffer.  */
name|cur_buf_loc
operator|=
name|outbuf
operator|.
name|buf
expr_stmt|;
name|next_string
operator|=
name|stringlist
expr_stmt|;
while|while
condition|(
name|cur_buf_loc
operator|<
name|outbuf
operator|.
name|bufp
operator|||
name|next_string
condition|)
block|{
if|if
condition|(
name|next_string
operator|&&
name|cur_buf_loc
operator|-
name|outbuf
operator|.
name|buf
operator|==
name|next_string
operator|->
name|output_mark
condition|)
block|{
if|if
condition|(
name|next_string
operator|->
name|writeflag
condition|)
block|{
name|len
operator|=
literal|4
operator|*
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|next_string
operator|->
name|filename
argument_list|)
operator|+
literal|32
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|line_directive_len
condition|)
name|line_directive
operator|=
name|xrealloc
argument_list|(
name|line_directive
argument_list|,
name|line_directive_len
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line_directive
argument_list|,
literal|"\n# %d "
argument_list|,
name|next_string
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|quote_string
argument_list|(
name|line_directive
operator|+
name|strlen
argument_list|(
name|line_directive
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|next_string
operator|->
name|filename
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|next_string
operator|->
name|filename
argument_list|)
argument_list|)
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|safe_write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|line_directive
argument_list|,
name|strlen
argument_list|(
name|line_directive
argument_list|)
argument_list|)
expr_stmt|;
name|safe_write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|next_string
operator|->
name|contents
argument_list|,
name|next_string
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|next_string
operator|=
name|next_string
operator|->
name|chain
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
operator|(
name|next_string
condition|?
operator|(
name|next_string
operator|->
name|output_mark
operator|-
operator|(
name|cur_buf_loc
operator|-
name|outbuf
operator|.
name|buf
operator|)
operator|)
else|:
name|outbuf
operator|.
name|bufp
operator|-
name|cur_buf_loc
operator|)
expr_stmt|;
name|safe_write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cur_buf_loc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cur_buf_loc
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|line_directive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass a directive through to the output file.    BUF points to the contents of the directive, as a contiguous string.    LIMIT points to the first character past the end of the directive.    KEYWORD is the keyword-table entry for the directive.  */
end_comment

begin_function
specifier|static
name|void
name|pass_thru_directive
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|keyword_length
init|=
name|keyword
operator|->
name|length
decl_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
literal|1
operator|+
name|keyword_length
operator|+
operator|(
name|limit
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'#'
expr_stmt|;
name|bcopy
argument_list|(
name|keyword
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|keyword_length
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|keyword_length
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
name|buf
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
operator|(
name|limit
operator|-
name|buf
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|*op->bufp++ = '\n';
comment|/* Count the line we have just made in the output,      to get in sync properly.  */
block|op->lineno++;
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The arglist structure is built by do_define to tell    collect_definition where the argument names begin.  That    is, for a define like "#define f(x,y,z) foo+x-bar*y", the arglist    would contain pointers to the strings x, y, and z.    Collect_definition would then build a DEFINITION node,    with reflist nodes pointing to the places x, y, and z had    appeared.  So the arglist is just convenience data passed    between these two routines.  It is not kept around after    the current #define has been processed and entered into the    hash table.  */
end_comment

begin_struct
struct|struct
name|arglist
block|{
name|struct
name|arglist
modifier|*
name|next
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|argno
decl_stmt|;
name|char
name|rest_args
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Create a DEFINITION node from a #define directive.  Arguments are     as for do_define.  */
end_comment

begin_function
specifier|static
name|MACRODEF
name|create_definition
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* temp ptr into input buffer */
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|int
name|line
init|=
name|instack
index|[
name|indepth
index|]
operator|.
name|lineno
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|instack
index|[
name|indepth
index|]
operator|.
name|nominal_fname
decl_stmt|;
name|size_t
name|file_len
init|=
name|instack
index|[
name|indepth
index|]
operator|.
name|nominal_fname_len
decl_stmt|;
name|int
name|rest_args
init|=
literal|0
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|int
name|arglengths
init|=
literal|0
decl_stmt|;
comment|/* Accumulate lengths of arg names 				   plus number of args.  */
name|MACRODEF
name|mdef
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
name|symname
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts */
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|sym_length
expr_stmt|;
comment|/* Lossage will occur if identifiers or control keywords are broken      across lines using backslash.  This is not the right place to take      care of that.  */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'('
condition|)
block|{
name|struct
name|arglist
modifier|*
name|arg_ptrs
init|=
name|NULL
decl_stmt|;
name|int
name|argno
init|=
literal|0
decl_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* skip '(' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Loop over macro argument names.  */
while|while
condition|(
operator|*
name|bp
operator|!=
literal|')'
condition|)
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|arglist
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|bp
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|arg_ptrs
expr_stmt|;
name|temp
operator|->
name|argno
operator|=
name|argno
operator|++
expr_stmt|;
name|temp
operator|->
name|rest_args
operator|=
literal|0
expr_stmt|;
name|arg_ptrs
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|rest_args
condition|)
name|pedwarn
argument_list|(
literal|"another parameter follows `%s'"
argument_list|,
name|rest_extension
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|bp
index|]
condition|)
block|{
if|if
condition|(
name|c9x
operator|&&
name|limit
operator|-
name|bp
operator|>
operator|(
name|long
operator|)
name|REST_EXTENSION_LENGTH
operator|&&
name|bcmp
argument_list|(
name|rest_extension
argument_list|,
name|bp
argument_list|,
name|REST_EXTENSION_LENGTH
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is the ISO C 9x way to write macros with variable 		 number of arguments.  */
name|rest_args
operator|=
literal|1
expr_stmt|;
name|temp
operator|->
name|rest_args
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|pedwarn
argument_list|(
literal|"invalid character in macro parameter name"
argument_list|)
expr_stmt|;
block|}
comment|/* Find the end of the arg name.  */
while|while
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
block|{
name|bp
operator|++
expr_stmt|;
comment|/* do we have a "special" rest-args extension here? */
if|if
condition|(
name|limit
operator|-
name|bp
operator|>
operator|(
name|long
operator|)
name|REST_EXTENSION_LENGTH
operator|&&
name|bcmp
argument_list|(
name|rest_extension
argument_list|,
name|bp
argument_list|,
name|REST_EXTENSION_LENGTH
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow macro with variable arguments"
argument_list|)
expr_stmt|;
name|rest_args
operator|=
literal|1
expr_stmt|;
name|temp
operator|->
name|rest_args
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bp
operator|==
name|temp
operator|->
name|name
operator|&&
name|rest_args
operator|==
literal|1
condition|)
block|{
comment|/* This is the ISO C 9x style.  */
name|temp
operator|->
name|name
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|va_args_name
expr_stmt|;
name|temp
operator|->
name|length
operator|=
name|VA_ARGS_NAME_LENGTH
expr_stmt|;
block|}
else|else
name|temp
operator|->
name|length
operator|=
name|bp
operator|-
name|temp
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|rest_args
operator|==
literal|1
condition|)
name|bp
operator|+=
name|REST_EXTENSION_LENGTH
expr_stmt|;
name|arglengths
operator|+=
name|temp
operator|->
name|length
operator|+
literal|2
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|length
operator|==
literal|0
operator|||
operator|(
operator|*
name|bp
operator|!=
literal|','
operator|&&
operator|*
name|bp
operator|!=
literal|')'
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"badly punctuated parameter list in `#define'"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|','
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* A comma at this point can only be followed by an identifier.  */
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|bp
index|]
operator|&&
operator|!
operator|(
name|c9x
operator|&&
name|limit
operator|-
name|bp
operator|>
operator|(
name|long
operator|)
name|REST_EXTENSION_LENGTH
operator|&&
name|bcmp
argument_list|(
name|rest_extension
argument_list|,
name|bp
argument_list|,
name|REST_EXTENSION_LENGTH
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"badly punctuated parameter list in `#define'"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|}
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error
argument_list|(
literal|"unterminated parameter list in `#define'"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|{
name|struct
name|arglist
modifier|*
name|otemp
decl_stmt|;
for|for
control|(
name|otemp
operator|=
name|temp
operator|->
name|next
init|;
name|otemp
operator|!=
name|NULL
condition|;
name|otemp
operator|=
name|otemp
operator|->
name|next
control|)
if|if
condition|(
name|temp
operator|->
name|length
operator|==
name|otemp
operator|->
name|length
operator|&&
name|bcmp
argument_list|(
name|temp
operator|->
name|name
argument_list|,
name|otemp
operator|->
name|name
argument_list|,
name|temp
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"duplicate argument name `%.*s' in `#define'"
argument_list|,
name|temp
operator|->
name|length
argument_list|,
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
name|rest_args
operator|==
literal|0
operator|&&
name|temp
operator|->
name|length
operator|==
name|VA_ARGS_NAME_LENGTH
operator|&&
name|bcmp
argument_list|(
name|temp
operator|->
name|name
argument_list|,
name|va_args_name
argument_list|,
name|VA_ARGS_NAME_LENGTH
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"\ reserved name `%s' used as argument name in `#define'"
argument_list|,
name|va_args_name
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|}
block|}
operator|++
name|bp
expr_stmt|;
comment|/* skip paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* now everything from bp before limit is the definition.  */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|bp
argument_list|,
name|limit
argument_list|,
name|argno
argument_list|,
name|arg_ptrs
argument_list|)
expr_stmt|;
name|defn
operator|->
name|rest_args
operator|=
name|rest_args
expr_stmt|;
comment|/* Now set defn->args.argnames to the result of concatenating        the argument names in reverse order        with comma-space between them.  */
name|defn
operator|->
name|args
operator|.
name|argnames
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|arglengths
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|arg_ptrs
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
name|bcopy
argument_list|(
name|temp
operator|->
name|name
argument_list|,
operator|&
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
index|]
argument_list|,
name|temp
operator|->
name|length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|temp
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|next
operator|!=
literal|0
condition|)
block|{
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Simple expansion or empty definition.  */
if|if
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_length
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'"'
case|:
case|case
literal|'#'
case|:
case|case
literal|'%'
case|:
case|case
literal|'&'
case|:
case|case
literal|'\''
case|:
case|case
literal|')'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|','
case|:
case|case
literal|'-'
case|:
case|case
literal|'.'
case|:
case|case
literal|'/'
case|:
case|case
literal|':'
case|:
case|case
literal|';'
case|:
case|case
literal|'<'
case|:
case|case
literal|'='
case|:
case|case
literal|'>'
case|:
case|case
literal|'?'
case|:
case|case
literal|'['
case|:
case|case
literal|'\\'
case|:
case|case
literal|']'
case|:
case|case
literal|'^'
case|:
case|case
literal|'{'
case|:
case|case
literal|'|'
case|:
case|case
literal|'}'
case|:
case|case
literal|'~'
case|:
name|warning
argument_list|(
literal|"missing white space after `#define %.*s'"
argument_list|,
name|sym_length
argument_list|,
name|symname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pedwarn
argument_list|(
literal|"missing white space after `#define %.*s'"
argument_list|,
name|sym_length
argument_list|,
name|symname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Now everything from bp before limit is the definition.  */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|bp
argument_list|,
name|limit
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|defn
operator|->
name|args
operator|.
name|argnames
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
literal|""
expr_stmt|;
block|}
name|defn
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|defn
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|defn
operator|->
name|file_len
operator|=
name|file_len
expr_stmt|;
comment|/* OP is null if this is a predefinition */
name|defn
operator|->
name|predefined
operator|=
operator|!
name|op
expr_stmt|;
name|mdef
operator|.
name|defn
operator|=
name|defn
expr_stmt|;
name|mdef
operator|.
name|symnam
operator|=
name|symname
expr_stmt|;
name|mdef
operator|.
name|symlen
operator|=
name|sym_length
expr_stmt|;
return|return
name|mdef
return|;
name|nope
label|:
name|mdef
operator|.
name|defn
operator|=
literal|0
expr_stmt|;
return|return
name|mdef
return|;
block|}
end_block

begin_comment
comment|/* Process a #define directive. BUF points to the contents of the #define directive, as a contiguous string. LIMIT points to the first character past the end of the definition. KEYWORD is the keyword-table entry for #define.  */
end_comment

begin_function
specifier|static
name|int
name|do_define
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|hashcode
decl_stmt|;
name|MACRODEF
name|mdef
decl_stmt|;
comment|/* If this is a precompiler run (with -pcp) pass thru #define directives.  */
if|if
condition|(
name|pcp_outfile
operator|&&
name|op
condition|)
name|pass_thru_directive
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|mdef
operator|=
name|create_definition
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdef
operator|.
name|defn
operator|==
literal|0
condition|)
goto|goto
name|nope
goto|;
name|hashcode
operator|=
name|hashf
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|hashcode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
comment|/* Redefining a precompiled key is ok.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_PCSTRING
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
comment|/* Redefining a macro is ok if the definitions are the same.  */
elseif|else
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
name|ok
operator|=
operator|!
name|compare_defs
argument_list|(
name|mdef
operator|.
name|defn
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
argument_list|)
expr_stmt|;
comment|/* Redefining a constant is ok with -D.  */
elseif|else
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_CONST
condition|)
name|ok
operator|=
operator|!
name|done_initializing
expr_stmt|;
comment|/* Print the warning if it's not ok.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
comment|/* If we are passing through #define and #undef directives, do 	   that for this re-definition now.  */
if|if
condition|(
name|debug_output
operator|&&
name|op
condition|)
name|pass_thru_directive
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"`%.*s' redefined"
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|mdef
operator|.
name|symnam
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
name|pedwarn_with_file_and_line
argument_list|(
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|file
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|file_len
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|line
argument_list|,
literal|"this is the location of the previous definition"
argument_list|)
expr_stmt|;
block|}
comment|/* Replace the old definition.  */
name|hp
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|defn
operator|=
name|mdef
operator|.
name|defn
expr_stmt|;
block|}
else|else
block|{
comment|/* If we are passing through #define and #undef directives, do 	 that for this new definition now.  */
if|if
condition|(
name|debug_output
operator|&&
name|op
condition|)
name|pass_thru_directive
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|install
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|T_MACRO
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mdef
operator|.
name|defn
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
name|nope
label|:
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Check a purported macro name SYMNAME, and yield its length.    ASSERTION is nonzero if this is really for an assertion name.  */
end_comment

begin_function
specifier|static
name|int
name|check_macro_name
parameter_list|(
name|symname
parameter_list|,
name|assertion
parameter_list|)
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
name|int
name|assertion
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|int
name|sym_length
decl_stmt|;
for|for
control|(
name|p
operator|=
name|symname
init|;
name|is_idchar
index|[
operator|*
name|p
index|]
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|sym_length
operator|=
name|p
operator|-
name|symname
expr_stmt|;
if|if
condition|(
name|sym_length
operator|==
literal|0
operator|||
operator|(
name|sym_length
operator|==
literal|1
operator|&&
operator|*
name|symname
operator|==
literal|'L'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
operator|)
operator|)
condition|)
name|error
argument_list|(
name|assertion
condition|?
literal|"invalid assertion name"
else|:
literal|"invalid macro name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|symname
index|]
operator|||
operator|(
name|sym_length
operator|==
literal|7
operator|&&
operator|!
name|bcmp
argument_list|(
name|symname
argument_list|,
literal|"defined"
argument_list|,
literal|7
argument_list|)
operator|)
condition|)
name|error
argument_list|(
operator|(
name|assertion
condition|?
literal|"invalid assertion name `%.*s'"
else|:
literal|"invalid macro name `%.*s'"
operator|)
argument_list|,
name|sym_length
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
name|sym_length
return|;
block|}
end_function

begin_comment
comment|/* Return zero if two DEFINITIONs are isomorphic.  */
end_comment

begin_function
specifier|static
name|int
name|compare_defs
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|DEFINITION
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|reflist
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|d1
operator|->
name|expansion
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p2
init|=
name|d2
operator|->
name|expansion
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|d1
operator|->
name|nargs
operator|!=
name|d2
operator|->
name|nargs
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|pedantic
operator|&&
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d1
operator|->
name|args
operator|.
name|argnames
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d2
operator|->
name|args
operator|.
name|argnames
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|a1
operator|=
name|d1
operator|->
name|pattern
operator|,
name|a2
operator|=
name|d2
operator|->
name|pattern
init|;
name|a1
operator|&&
name|a2
condition|;
name|a1
operator|=
name|a1
operator|->
name|next
operator|,
name|a2
operator|=
name|a2
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|a1
operator|->
name|nchars
operator|==
name|a2
operator|->
name|nchars
operator|&&
operator|!
name|bcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|a1
operator|->
name|nchars
argument_list|)
operator|)
operator|||
operator|!
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|a1
operator|->
name|nchars
argument_list|,
name|p2
argument_list|,
name|a2
operator|->
name|nchars
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
name|a1
operator|->
name|argno
operator|!=
name|a2
operator|->
name|argno
operator|||
name|a1
operator|->
name|stringify
operator|!=
name|a2
operator|->
name|stringify
operator|||
name|a1
operator|->
name|raw_before
operator|!=
name|a2
operator|->
name|raw_before
operator|||
name|a1
operator|->
name|raw_after
operator|!=
name|a2
operator|->
name|raw_after
condition|)
return|return
literal|1
return|;
name|first
operator|=
literal|0
expr_stmt|;
name|p1
operator|+=
name|a1
operator|->
name|nchars
expr_stmt|;
name|p2
operator|+=
name|a2
operator|->
name|nchars
expr_stmt|;
block|}
if|if
condition|(
name|a1
operator|!=
name|a2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|d1
operator|->
name|length
operator|-
operator|(
name|p1
operator|-
name|d1
operator|->
name|expansion
operator|)
argument_list|,
name|p2
argument_list|,
name|d2
operator|->
name|length
operator|-
operator|(
name|p2
operator|-
name|d2
operator|->
name|expansion
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Return 1 if two parts of two macro definitions are effectively different.    One of the parts starts at BEG1 and has LEN1 chars;    the other has LEN2 chars at BEG2.    Any sequence of whitespace matches any other sequence of whitespace.    FIRST means these parts are the first of a macro definition;     so ignore leading whitespace entirely.    LAST means these parts are the last of a macro definition;     so ignore trailing whitespace entirely.  */
end_comment

begin_function
specifier|static
name|int
name|comp_def_part
parameter_list|(
name|first
parameter_list|,
name|beg1
parameter_list|,
name|len1
parameter_list|,
name|beg2
parameter_list|,
name|len2
parameter_list|,
name|last
parameter_list|)
name|int
name|first
decl_stmt|;
name|U_CHAR
modifier|*
name|beg1
decl_stmt|,
decl|*
name|beg2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|end1
init|=
name|beg1
operator|+
name|len1
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|end2
init|=
name|beg2
operator|+
name|len2
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
operator|*
name|beg1
index|]
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
name|end1
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|end1
operator|--
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
name|end2
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|end2
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|beg2
operator|!=
name|end2
condition|)
block|{
if|if
condition|(
name|is_space
index|[
operator|*
name|beg1
index|]
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
operator|*
name|beg1
index|]
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|beg1
operator|==
operator|*
name|beg2
condition|)
block|{
name|beg1
operator|++
expr_stmt|;
name|beg2
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|beg1
operator|!=
name|end1
operator|)
operator|||
operator|(
name|beg2
operator|!=
name|end2
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read a replacement list for a macro with parameters.    Build the DEFINITION structure.    Reads characters of text starting at BUF until END.    ARGLIST specifies the formal parameters to look for    in the text of the definition; NARGS is the number of args    in that list, or -1 for a macro name that wants no argument list.    MACRONAME is the macro name itself (so we can avoid recursive expansion)    and NAMELEN is its length in characters.     Note that comments, backslash-newlines, and leading white space have already been deleted from the argument.  */
end_comment

begin_comment
comment|/* If there is no trailing whitespace, a Newline Space is added at the end    to prevent concatenation that would be contrary to the standard.  */
end_comment

begin_function
specifier|static
name|DEFINITION
modifier|*
name|collect_expansion
parameter_list|(
name|buf
parameter_list|,
name|end
parameter_list|,
name|nargs
parameter_list|,
name|arglist
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|end
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arglist
modifier|*
name|arglist
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|limit
decl_stmt|,
modifier|*
name|lastp
decl_stmt|,
modifier|*
name|exp_p
decl_stmt|;
name|struct
name|reflist
modifier|*
name|endpat
init|=
name|NULL
decl_stmt|;
comment|/* Pointer to first nonspace after last ## seen.  */
name|U_CHAR
modifier|*
name|concat
init|=
literal|0
decl_stmt|;
comment|/* Pointer to first nonspace after last single-# seen.  */
name|U_CHAR
modifier|*
name|stringify
init|=
literal|0
decl_stmt|;
comment|/* How those tokens were spelled.  */
name|enum
name|sharp_token_type
name|concat_sharp_token_type
init|=
name|NO_SHARP_TOKEN
decl_stmt|;
name|enum
name|sharp_token_type
name|stringify_sharp_token_type
init|=
name|NO_SHARP_TOKEN
decl_stmt|;
name|int
name|maxsize
decl_stmt|;
name|int
name|expected_delimiter
init|=
literal|'\0'
decl_stmt|;
comment|/* Scan thru the replacement list, ignoring comments and quoted      strings, picking up on the macro calls.  It does a linear search      thru the arg list on every potential symbol.  Profiling might say      that something smarter should happen.  */
if|if
condition|(
name|end
operator|<
name|buf
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the beginning of the trailing whitespace.  */
name|limit
operator|=
name|end
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
index|[
name|limit
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Allocate space for the text in the macro definition.      Each input char may or may not need 1 byte,      so this is an upper bound.      The extra 3 are for invented trailing newline-marker and final null.  */
name|maxsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
operator|+
operator|(
name|limit
operator|-
name|p
operator|)
operator|+
literal|3
operator|)
expr_stmt|;
name|defn
operator|=
operator|(
name|DEFINITION
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
name|defn
operator|->
name|nargs
operator|=
name|nargs
expr_stmt|;
name|exp_p
operator|=
name|defn
operator|->
name|expansion
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|defn
operator|+
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
expr_stmt|;
name|lastp
operator|=
name|exp_p
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'#'
condition|?
name|p
index|[
literal|1
index|]
operator|==
literal|'#'
else|:
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|':'
condition|)
block|{
name|error
argument_list|(
literal|"`##' at start of macro definition"
argument_list|)
expr_stmt|;
name|p
operator|+=
name|p
index|[
literal|0
index|]
operator|==
literal|'#'
condition|?
literal|2
else|:
literal|4
expr_stmt|;
block|}
comment|/* Process the main body of the definition.  */
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
name|int
name|skipped_arg
init|=
literal|0
decl_stmt|;
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
operator|*
name|exp_p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|expected_delimiter
condition|)
name|expected_delimiter
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|expected_delimiter
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|p
operator|<
name|limit
operator|&&
name|expected_delimiter
condition|)
block|{
comment|/* In a string, backslash goes through 	     and makes next char ordinary.  */
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
operator|!
name|expected_delimiter
operator|&&
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
comment|/* %: is not a digraph if preceded by an odd number of '<'s.  */
name|U_CHAR
modifier|*
name|p0
init|=
name|p
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|buf
operator|<
name|p0
operator|&&
name|p0
index|[
operator|-
literal|1
index|]
operator|==
literal|'<'
condition|)
name|p0
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|-
name|p0
operator|)
operator|&
literal|1
condition|)
block|{
comment|/* Treat %:%: as ## and %: as #.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
goto|goto
name|sharp_sharp_token
goto|;
block|}
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
name|p
operator|++
expr_stmt|;
goto|goto
name|sharp_token
goto|;
block|}
block|}
block|}
break|break;
case|case
literal|'#'
case|:
comment|/* # is ordinary inside a string.  */
if|if
condition|(
name|expected_delimiter
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
name|sharp_sharp_token
label|:
comment|/* ##: concatenate preceding and following tokens.  */
comment|/* Take out the first #, discard preceding whitespace.  */
name|exp_p
operator|--
expr_stmt|;
while|while
condition|(
name|exp_p
operator|>
name|lastp
operator|&&
name|is_hor_space
index|[
name|exp_p
index|[
operator|-
literal|1
index|]
index|]
condition|)
operator|--
name|exp_p
expr_stmt|;
comment|/* Skip the second #.  */
name|p
operator|++
expr_stmt|;
name|concat_sharp_token_type
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|p
index|]
condition|)
block|{
name|concat_sharp_token_type
operator|=
name|c
operator|+
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|concat
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|limit
condition|)
name|error
argument_list|(
literal|"`##' at end of macro definition"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
comment|/* Single #: stringify following argument ref. 	     Don't leave the # in the expansion.  */
name|sharp_token
label|:
name|exp_p
operator|--
expr_stmt|;
name|stringify_sharp_token_type
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|p
index|]
condition|)
block|{
name|stringify_sharp_token_type
operator|=
name|c
operator|+
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|p
index|]
operator|||
name|nargs
operator|==
literal|0
operator|||
operator|(
operator|*
name|p
operator|==
literal|'L'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\''
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'"'
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"`#' operator is not followed by a macro argument name"
argument_list|)
expr_stmt|;
else|else
name|stringify
operator|=
name|p
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
comment|/* In -traditional mode, recognize arguments inside strings and 	 character constants, and ignore special properties of #. 	 Arguments inside strings are considered "stringified", but no 	 extra quote marks are supplied.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|expected_delimiter
condition|)
name|expected_delimiter
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|expected_delimiter
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Backslash quotes delimiters and itself, but not macro args.  */
if|if
condition|(
name|expected_delimiter
operator|!=
literal|0
operator|&&
name|p
operator|<
name|limit
operator|&&
operator|(
operator|*
name|p
operator|==
name|expected_delimiter
operator|||
operator|*
name|p
operator|==
literal|'\\'
operator|)
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
comment|/* No comments inside strings.  */
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
comment|/* If we find a comment that wasn't removed by handle_directive, 	     this must be -traditional.  So replace the comment with 	     nothing at all.  */
name|exp_p
operator|--
expr_stmt|;
while|while
condition|(
operator|++
name|p
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Mark this as a concatenation-point, as if it had been ##.  */
block|concat = p;
endif|#
directive|endif
block|}
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Handle multibyte characters inside string and character literals.  */
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|length
decl_stmt|;
operator|--
name|p
expr_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|p
argument_list|,
name|limit
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
block|{
operator|--
name|exp_p
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|exp_p
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|length
expr_stmt|;
name|exp_p
operator|+=
name|length
expr_stmt|;
continue|continue;
block|}
operator|++
name|p
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Handle the start of a symbol.  */
if|if
condition|(
name|is_idchar
index|[
name|c
index|]
operator|&&
name|nargs
operator|>
literal|0
condition|)
block|{
name|U_CHAR
modifier|*
name|id_beg
init|=
name|p
operator|-
literal|1
decl_stmt|;
name|int
name|id_len
decl_stmt|;
operator|--
name|exp_p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|limit
operator|&&
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|id_len
operator|=
name|p
operator|-
name|id_beg
expr_stmt|;
if|if
condition|(
name|is_idstart
index|[
name|c
index|]
operator|&&
operator|!
operator|(
name|id_len
operator|==
literal|1
operator|&&
name|c
operator|==
literal|'L'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
operator|)
operator|)
condition|)
block|{
specifier|register
name|struct
name|arglist
modifier|*
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|arglist
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|next
control|)
block|{
name|struct
name|reflist
modifier|*
name|tpat
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|c
operator|&&
name|arg
operator|->
name|length
operator|==
name|id_len
operator|&&
name|bcmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
name|id_beg
argument_list|,
name|id_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|enum
name|sharp_token_type
name|tpat_stringify
decl_stmt|;
if|if
condition|(
name|expected_delimiter
condition|)
block|{
if|if
condition|(
name|warn_stringify
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
block|{
name|warning
argument_list|(
literal|"macro argument `%.*s' is stringified."
argument_list|,
name|id_len
argument_list|,
name|arg
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"macro arg `%.*s' would be stringified with -traditional."
argument_list|,
name|id_len
argument_list|,
name|arg
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If ANSI, don't actually substitute inside a string.  */
if|if
condition|(
operator|!
name|traditional
condition|)
break|break;
name|tpat_stringify
operator|=
name|SHARP_TOKEN
expr_stmt|;
block|}
else|else
block|{
name|tpat_stringify
operator|=
operator|(
name|stringify
operator|==
name|id_beg
condition|?
name|stringify_sharp_token_type
else|:
name|NO_SHARP_TOKEN
operator|)
expr_stmt|;
block|}
comment|/* make a pat node for this arg and append it to the end of 	       the pat list */
name|tpat
operator|=
operator|(
expr|struct
name|reflist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reflist
argument_list|)
argument_list|)
expr_stmt|;
name|tpat
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tpat
operator|->
name|raw_before
operator|=
name|concat
operator|==
name|id_beg
condition|?
name|concat_sharp_token_type
else|:
name|NO_SHARP_TOKEN
expr_stmt|;
name|tpat
operator|->
name|raw_after
operator|=
name|NO_SHARP_TOKEN
expr_stmt|;
name|tpat
operator|->
name|rest_args
operator|=
name|arg
operator|->
name|rest_args
expr_stmt|;
name|tpat
operator|->
name|stringify
operator|=
name|tpat_stringify
expr_stmt|;
if|if
condition|(
name|endpat
operator|==
name|NULL
condition|)
name|defn
operator|->
name|pattern
operator|=
name|tpat
expr_stmt|;
else|else
name|endpat
operator|->
name|next
operator|=
name|tpat
expr_stmt|;
name|endpat
operator|=
name|tpat
expr_stmt|;
name|tpat
operator|->
name|argno
operator|=
name|arg
operator|->
name|argno
expr_stmt|;
name|tpat
operator|->
name|nchars
operator|=
name|exp_p
operator|-
name|lastp
expr_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|p
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
index|[
literal|0
index|]
operator|==
literal|'#'
condition|?
name|p1
index|[
literal|1
index|]
operator|==
literal|'#'
else|:
name|p1
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|p1
index|[
literal|2
index|]
operator|==
literal|'%'
operator|&&
name|p1
index|[
literal|3
index|]
operator|==
literal|':'
condition|)
name|tpat
operator|->
name|raw_after
operator|=
name|p1
index|[
literal|0
index|]
operator|+
operator|(
name|p
operator|!=
name|p1
operator|)
expr_stmt|;
block|}
name|lastp
operator|=
name|exp_p
expr_stmt|;
comment|/* place to start copying from next time */
name|skipped_arg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If this was not a macro arg, copy it into the expansion.  */
if|if
condition|(
operator|!
name|skipped_arg
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|lim1
init|=
name|p
decl_stmt|;
name|p
operator|=
name|id_beg
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|lim1
condition|)
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|stringify
operator|==
name|id_beg
condition|)
name|error
argument_list|(
literal|"`#' operator should be followed by a macro argument name"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|traditional
operator|&&
name|expected_delimiter
operator|==
literal|0
condition|)
block|{
comment|/* If ANSI, put in a newline-space marker to prevent token pasting.        But not if "inside a string" (which in ANSI mode happens only for        -D option).  */
operator|*
name|exp_p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|exp_p
operator|=
literal|'\0'
expr_stmt|;
name|defn
operator|->
name|length
operator|=
name|exp_p
operator|-
name|defn
operator|->
name|expansion
expr_stmt|;
comment|/* Crash now if we overrun the allocated size.  */
if|if
condition|(
name|defn
operator|->
name|length
operator|+
literal|1
operator|>
name|maxsize
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This isn't worth the time it takes.  */
comment|/* give back excess storage */
block|defn->expansion = (U_CHAR *) xrealloc (defn->expansion, defn->length + 1);
endif|#
directive|endif
return|return
name|defn
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|int
name|do_assert
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* temp ptr into input buffer */
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|struct
name|arglist
modifier|*
name|tokens
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|done_initializing
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow `#assert'"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
name|symname
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts */
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|sym_length
expr_stmt|;
comment|/* #define doesn't do this, but we should.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Lossage will occur if identifiers or control tokens are broken      across lines using backslash.  This is not the right place to take      care of that.  */
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'('
condition|)
block|{
name|error
argument_list|(
literal|"missing token-sequence in `#assert'"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|{
name|int
name|error_flag
init|=
literal|0
decl_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* skip '(' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|tokens
operator|=
name|read_token_list
argument_list|(
operator|&
name|bp
argument_list|,
name|limit
argument_list|,
operator|&
name|error_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_flag
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|tokens
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"empty token-sequence in `#assert'"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|++
name|bp
expr_stmt|;
comment|/* skip paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* If this name isn't already an assertion name, make it one.      Error if it was already in use in some other way.  */
block|{
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
name|int
name|hashcode
init|=
name|hashf
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|ASSERTION_HASHSIZE
argument_list|)
decl_stmt|;
name|struct
name|tokenlist_list
modifier|*
name|value
init|=
operator|(
expr|struct
name|tokenlist_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tokenlist_list
argument_list|)
argument_list|)
decl_stmt|;
name|hp
operator|=
name|assertion_lookup
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sym_length
operator|==
literal|7
operator|&&
operator|!
name|bcmp
argument_list|(
name|symname
argument_list|,
literal|"defined"
argument_list|,
literal|7
argument_list|)
condition|)
name|error
argument_list|(
literal|"`defined' redefined as assertion"
argument_list|)
expr_stmt|;
name|hp
operator|=
name|assertion_install
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
block|}
comment|/* Add the spec'd token-sequence to the list of such.  */
name|value
operator|->
name|tokens
operator|=
name|tokens
expr_stmt|;
name|value
operator|->
name|next
operator|=
name|hp
operator|->
name|value
expr_stmt|;
name|hp
operator|->
name|value
operator|=
name|value
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|int
name|do_unassert
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* temp ptr into input buffer */
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|struct
name|arglist
modifier|*
name|tokens
init|=
name|NULL
decl_stmt|;
name|int
name|tokens_specified
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|done_initializing
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow `#unassert'"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
name|symname
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts */
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|sym_length
expr_stmt|;
comment|/* #define doesn't do this, but we should.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Lossage will occur if identifiers or control tokens are broken      across lines using backslash.  This is not the right place to take      care of that.  */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'('
condition|)
block|{
name|int
name|error_flag
init|=
literal|0
decl_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* skip '(' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|tokens
operator|=
name|read_token_list
argument_list|(
operator|&
name|bp
argument_list|,
name|limit
argument_list|,
operator|&
name|error_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_flag
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|tokens
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"empty token list in `#unassert'"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|tokens_specified
operator|=
literal|1
expr_stmt|;
operator|++
name|bp
expr_stmt|;
comment|/* skip paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|{
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
name|int
name|hashcode
init|=
name|hashf
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|ASSERTION_HASHSIZE
argument_list|)
decl_stmt|;
name|struct
name|tokenlist_list
modifier|*
name|tail
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|hp
operator|=
name|assertion_lookup
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* If no token list was specified, then eliminate this assertion        entirely.  */
if|if
condition|(
operator|!
name|tokens_specified
condition|)
block|{
name|struct
name|tokenlist_list
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|hp
operator|->
name|value
init|;
name|tail
condition|;
name|tail
operator|=
name|next
control|)
block|{
name|next
operator|=
name|tail
operator|->
name|next
expr_stmt|;
name|free_token_list
argument_list|(
name|tail
operator|->
name|tokens
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
name|delete_assertion
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If a list of tokens was given, then delete any matching list.  */
name|tail
operator|=
name|hp
operator|->
name|value
expr_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tail
condition|)
block|{
name|struct
name|tokenlist_list
modifier|*
name|next
init|=
name|tail
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|compare_token_lists
argument_list|(
name|tail
operator|->
name|tokens
argument_list|,
name|tokens
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
else|else
name|hp
operator|->
name|value
operator|=
name|tail
operator|->
name|next
expr_stmt|;
name|free_token_list
argument_list|(
name|tail
operator|->
name|tokens
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|tail
expr_stmt|;
block|}
name|tail
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Test whether there is an assertion named NAME    and optionally whether it has an asserted token list TOKENS.    NAME is not null terminated; its length is SYM_LENGTH.    If TOKENS_SPECIFIED is 0, then don't check for any token list.  */
end_comment

begin_function
name|int
name|check_assertion
parameter_list|(
name|name
parameter_list|,
name|sym_length
parameter_list|,
name|tokens_specified
parameter_list|,
name|tokens
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|sym_length
decl_stmt|;
name|int
name|tokens_specified
decl_stmt|;
name|struct
name|arglist
modifier|*
name|tokens
decl_stmt|;
block|{
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
name|int
name|hashcode
init|=
name|hashf
argument_list|(
name|name
argument_list|,
name|sym_length
argument_list|,
name|ASSERTION_HASHSIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow testing assertions"
argument_list|)
expr_stmt|;
name|hp
operator|=
name|assertion_lookup
argument_list|(
name|name
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
comment|/* It is not an assertion; just return false.  */
return|return
literal|0
return|;
comment|/* If no token list was specified, then value is 1.  */
if|if
condition|(
operator|!
name|tokens_specified
condition|)
return|return
literal|1
return|;
block|{
name|struct
name|tokenlist_list
modifier|*
name|tail
decl_stmt|;
name|tail
operator|=
name|hp
operator|->
name|value
expr_stmt|;
comment|/* If a list of tokens was given,        then succeed if the assertion records a matching list.  */
while|while
condition|(
name|tail
condition|)
block|{
if|if
condition|(
name|compare_token_lists
argument_list|(
name|tail
operator|->
name|tokens
argument_list|,
name|tokens
argument_list|)
condition|)
return|return
literal|1
return|;
name|tail
operator|=
name|tail
operator|->
name|next
expr_stmt|;
block|}
comment|/* Fail if the assertion has no matching list.  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two lists of tokens for equality including order of tokens.  */
end_comment

begin_function
specifier|static
name|int
name|compare_token_lists
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|struct
name|arglist
modifier|*
name|l1
decl_stmt|,
decl|*
name|l2
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|l1
operator|&&
name|l2
condition|)
block|{
if|if
condition|(
name|l1
operator|->
name|length
operator|!=
name|l2
operator|->
name|length
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bcmp
argument_list|(
name|l1
operator|->
name|name
argument_list|,
name|l2
operator|->
name|name
argument_list|,
name|l1
operator|->
name|length
argument_list|)
condition|)
return|return
literal|0
return|;
name|l1
operator|=
name|l1
operator|->
name|next
expr_stmt|;
name|l2
operator|=
name|l2
operator|->
name|next
expr_stmt|;
block|}
comment|/* Succeed if both lists end at the same time.  */
return|return
name|l1
operator|==
name|l2
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read a space-separated list of tokens ending in a close parenthesis.    Return a list of strings, in the order they were written.    (In case of error, return 0 and store -1 in *ERROR_FLAG.)    Parse the text starting at *BPP, and update *BPP.    Don't parse beyond LIMIT.  */
end_comment

begin_function
specifier|static
name|struct
name|arglist
modifier|*
name|read_token_list
parameter_list|(
name|bpp
parameter_list|,
name|limit
parameter_list|,
name|error_flag
parameter_list|)
name|U_CHAR
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
modifier|*
name|error_flag
decl_stmt|;
block|{
name|struct
name|arglist
modifier|*
name|token_ptrs
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|bp
init|=
operator|*
name|bpp
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
operator|*
name|error_flag
operator|=
literal|0
expr_stmt|;
comment|/* Loop over the assertion value tokens.  */
while|while
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|int
name|eofp
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|beg
init|=
name|bp
decl_stmt|;
comment|/* Find the end of the token.  */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'('
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|depth
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|')'
condition|)
block|{
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
break|break;
name|bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'"'
operator|||
operator|*
name|bp
operator|==
literal|'\''
condition|)
name|bp
operator|=
name|skip_quoted_string
argument_list|(
name|bp
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
operator|&
name|eofp
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|!
name|is_hor_space
index|[
operator|*
name|bp
index|]
operator|&&
operator|*
name|bp
operator|!=
literal|'('
operator|&&
operator|*
name|bp
operator|!=
literal|')'
operator|&&
operator|*
name|bp
operator|!=
literal|'"'
operator|&&
operator|*
name|bp
operator|!=
literal|'\''
operator|&&
name|bp
operator|!=
name|limit
condition|)
name|bp
operator|++
expr_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|arglist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bp
operator|-
name|beg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|beg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|temp
operator|->
name|name
argument_list|,
name|bp
operator|-
name|beg
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
index|[
name|bp
operator|-
name|beg
index|]
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|token_ptrs
expr_stmt|;
name|token_ptrs
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|length
operator|=
name|bp
operator|-
name|beg
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error
argument_list|(
literal|"unterminated token sequence in `#assert' or `#unassert'"
argument_list|)
expr_stmt|;
operator|*
name|error_flag
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
comment|/* We accumulated the names in reverse order.      Now reverse them to get the proper order.  */
block|{
specifier|register
name|struct
name|arglist
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|this
operator|=
name|token_ptrs
init|;
name|this
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|this
operator|->
name|next
expr_stmt|;
name|this
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|this
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_token_list
parameter_list|(
name|tokens
parameter_list|)
name|struct
name|arglist
modifier|*
name|tokens
decl_stmt|;
block|{
while|while
condition|(
name|tokens
condition|)
block|{
name|struct
name|arglist
modifier|*
name|next
init|=
name|tokens
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|tokens
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
name|tokens
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Install a name in the assertion hash table.     If LEN is>= 0, it is the length of the name.    Otherwise, compute the length by scanning the entire name.     If HASH is>= 0, it is the precomputed hash code.    Otherwise, compute the hash code.  */
end_comment

begin_function
specifier|static
name|ASSERTION_HASHNODE
modifier|*
name|assertion_install
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|bucket
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|ASSERTION_HASHNODE
argument_list|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|hp
operator|=
operator|(
name|ASSERTION_HASHNODE
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hash
expr_stmt|;
name|hp
operator|->
name|bucket_hdr
operator|=
operator|&
name|assertion_hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hp
operator|->
name|next
operator|=
name|assertion_hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|assertion_hashtab
index|[
name|bucket
index|]
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|hp
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|name
operator|=
operator|(
operator|(
name|U_CHAR
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|ASSERTION_HASHNODE
argument_list|)
expr_stmt|;
name|p
operator|=
name|hp
operator|->
name|name
expr_stmt|;
name|q
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
name|hp
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/* Find the most recent hash node for name "name" (ending with first    non-identifier char) installed by install     If LEN is>= 0, it is the length of the name.    Otherwise, compute the length by scanning the entire name.     If HASH is>= 0, it is the precomputed hash code.    Otherwise, compute the hash code.  */
end_comment

begin_function
specifier|static
name|ASSERTION_HASHNODE
modifier|*
name|assertion_lookup
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|ASSERTION_HASHNODE
modifier|*
name|bucket
decl_stmt|;
name|bucket
operator|=
name|assertion_hashtab
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|length
operator|==
name|len
operator|&&
name|bcmp
argument_list|(
name|bucket
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bucket
return|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_assertion
parameter_list|(
name|hp
parameter_list|)
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
if|if
condition|(
name|hp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|prev
operator|->
name|next
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
operator|->
name|prev
expr_stmt|;
comment|/* Make sure that the bucket chain header that the deleted guy was      on points to the right thing afterwards.  */
if|if
condition|(
name|hp
operator|==
operator|*
name|hp
operator|->
name|bucket_hdr
condition|)
operator|*
name|hp
operator|->
name|bucket_hdr
operator|=
name|hp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * interpret #line directive.  Remembers previously seen fnames  * in its very own hash table.  */
end_comment

begin_define
define|#
directive|define
name|FNAME_HASHSIZE
value|37
end_define

begin_function
specifier|static
name|int
name|do_line
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|FILE_BUF
name|tem
decl_stmt|;
name|int
name|new_lineno
decl_stmt|;
name|enum
name|file_change_code
name|file_change
init|=
name|same_file
decl_stmt|;
comment|/* Expand any macros.  */
name|tem
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Point to macroexpanded line, which is null-terminated now.  */
name|bp
operator|=
name|tem
operator|.
name|buf
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid format `#line' directive"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* The Newline at the end of this line remains to be processed.      To put the next line at the specified line number,      we must store a line number now that is one less.  */
name|new_lineno
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* NEW_LINENO is one less than the actual line number here.  */
if|if
condition|(
name|pedantic
operator|&&
name|new_lineno
operator|<
literal|0
condition|)
name|pedwarn
argument_list|(
literal|"line number out of range in `#line' directive"
argument_list|)
expr_stmt|;
comment|/* skip over the line number.  */
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|/* #line 10"foo.c" is supposed to be allowed.  */
block|if (*bp&& !is_space[*bp]) {     error ("invalid format `#line' directive");     return;   }
endif|#
directive|endif
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\"'
condition|)
block|{
specifier|static
name|HASHNODE
modifier|*
name|fname_table
index|[
name|FNAME_HASHSIZE
index|]
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|,
modifier|*
modifier|*
name|hash_bucket
decl_stmt|;
name|U_CHAR
modifier|*
name|fname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|fname_length
decl_stmt|;
name|fname
operator|=
operator|++
name|bp
expr_stmt|;
comment|/* Turn the file name, which is a character string literal,        into a null-terminated string.  Do this in place.  */
name|p
operator|=
name|bp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
operator|)
condition|)
block|{
case|case
literal|'\0'
case|:
name|error
argument_list|(
literal|"invalid format `#line' directive"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|!
name|ignore_escape_flag
condition|)
block|{
name|char
modifier|*
name|bpc
init|=
operator|(
name|char
operator|*
operator|)
name|bp
decl_stmt|;
name|HOST_WIDEST_INT
name|c
init|=
name|parse_escape
argument_list|(
operator|&
name|bpc
argument_list|,
call|(
name|HOST_WIDEST_INT
call|)
argument_list|(
name|U_CHAR
argument_list|)
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|bp
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|bpc
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|p
operator|--
expr_stmt|;
else|else
name|p
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
goto|goto
name|fname_done
goto|;
block|}
name|fname_done
label|:
name|fname_length
operator|=
name|p
operator|-
name|fname
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"garbage at end of `#line' directive"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'1'
condition|)
name|file_change
operator|=
name|enter_file
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'2'
condition|)
name|file_change
operator|=
name|leave_file
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'3'
condition|)
name|ip
operator|->
name|system_header_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'4'
condition|)
name|ip
operator|->
name|system_header_p
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"invalid format `#line' directive"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'3'
condition|)
block|{
name|ip
operator|->
name|system_header_p
operator|=
literal|1
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'4'
condition|)
block|{
name|ip
operator|->
name|system_header_p
operator|=
literal|2
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bp
condition|)
block|{
name|error
argument_list|(
literal|"invalid format `#line' directive"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|hash_bucket
operator|=
operator|&
name|fname_table
index|[
name|hashf
argument_list|(
name|fname
argument_list|,
name|fname_length
argument_list|,
name|FNAME_HASHSIZE
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|*
name|hash_bucket
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
if|if
condition|(
name|hp
operator|->
name|length
operator|==
name|fname_length
operator|&&
name|bcmp
argument_list|(
name|hp
operator|->
name|value
operator|.
name|cpval
argument_list|,
name|fname
argument_list|,
name|fname_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|nominal_fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
expr_stmt|;
name|ip
operator|->
name|nominal_fname_len
operator|=
name|fname_length
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hp
operator|==
literal|0
condition|)
block|{
comment|/* Didn't find it; cons up a new one.  */
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|fname_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hp
operator|->
name|next
operator|=
operator|*
name|hash_bucket
expr_stmt|;
operator|*
name|hash_bucket
operator|=
name|hp
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|ip
operator|->
name|nominal_fname_len
operator|=
name|hp
operator|->
name|length
operator|=
name|fname_length
expr_stmt|;
name|bcopy
argument_list|(
name|fname
argument_list|,
name|hp
operator|->
name|value
operator|.
name|cpval
argument_list|,
name|fname_length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
condition|)
block|{
name|error
argument_list|(
literal|"invalid format `#line' directive"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ip
operator|->
name|lineno
operator|=
name|new_lineno
expr_stmt|;
name|output_line_directive
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|file_change
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Remove the definition of a symbol from the symbol table.    according to un*x /lib/cpp, it is not an error to undef    something that has no definitions, so it isn't one here either.  */
end_comment

begin_function
specifier|static
name|int
name|do_undef
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sym_length
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|U_CHAR
modifier|*
name|orig_buf
init|=
name|buf
decl_stmt|;
comment|/* If this is a precompiler run (with -pcp) pass thru #undef directives.  */
if|if
condition|(
name|pcp_outfile
operator|&&
name|op
condition|)
name|pass_thru_directive
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|buf
argument_list|,
name|sym_length
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* If we are generating additional info for debugging (with -g) we        need to pass through all effective #undef directives.  */
if|if
condition|(
name|debug_output
operator|&&
name|op
condition|)
name|pass_thru_directive
argument_list|(
name|orig_buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
name|warning
argument_list|(
literal|"undefining `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
name|delete_macro
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
name|buf
operator|+=
name|sym_length
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|limit
condition|)
name|pedwarn
argument_list|(
literal|"garbage after `#undef' directive"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Report an error detected by the program we are processing.    Use the text of the line in the error message.    (We use error because it prints the filename& line#.)  */
end_comment

begin_function
specifier|static
name|int
name|do_error
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|copy
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|copy
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|copy
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"#error %s"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Report a warning detected by the program we are processing.    Use the text of the line in the warning message, then continue.    (We use error because it prints the filename& line#.)  */
end_comment

begin_function
specifier|static
name|int
name|do_warning
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|copy
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|copy
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|copy
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow `#warning'"
argument_list|)
expr_stmt|;
comment|/* Use `pedwarn' not `warning', because #warning isn't in the C Standard;      if -pedantic-errors is given, #warning should cause an error.  */
name|pedwarn
argument_list|(
literal|"#warning %s"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Remember the name of the current file being read from so that we can    avoid ever including it again.  */
end_comment

begin_function
specifier|static
name|void
name|do_once
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|inc
condition|)
block|{
name|record_control_macro
argument_list|(
name|instack
index|[
name|i
index|]
operator|.
name|inc
argument_list|,
operator|(
name|U_CHAR
operator|*
operator|)
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Report program identification.  */
end_comment

begin_function
specifier|static
name|int
name|do_ident
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
name|trybuf
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Allow #ident in system headers, since that's not user's fault.  */
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow `#ident'"
argument_list|)
expr_stmt|;
name|trybuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
name|trybuf
operator|.
name|buf
expr_stmt|;
name|len
operator|=
name|trybuf
operator|.
name|bufp
operator|-
name|buf
expr_stmt|;
comment|/* Output expanded directive.  */
name|check_expand
argument_list|(
name|op
argument_list|,
literal|7
operator|+
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"#ident "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
literal|7
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* #pragma and its argument line have already been copied to the output file.    Just check for some recognized pragmas that need validation here.  */
end_comment

begin_function
specifier|static
name|int
name|do_pragma
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|"once"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* Allow #pragma once in system headers, since that's not the user's        fault.  */
if|if
condition|(
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|warning
argument_list|(
literal|"`#pragma once' is obsolete"
argument_list|)
expr_stmt|;
name|do_once
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|"implementation"
argument_list|,
literal|14
argument_list|)
condition|)
block|{
comment|/* Be quiet about `#pragma implementation' for a file only if it hasn't        been included yet.  */
name|int
name|h
decl_stmt|;
name|U_CHAR
modifier|*
name|p
init|=
name|buf
operator|+
literal|14
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\"'
condition|)
return|return
literal|0
return|;
name|fname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|index
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fname
argument_list|,
literal|'\"'
argument_list|)
operator|)
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|INCLUDE_HASHSIZE
condition|;
name|h
operator|++
control|)
block|{
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|;
for|for
control|(
name|inc
operator|=
name|include_hashtab
index|[
name|h
index|]
init|;
name|inc
condition|;
name|inc
operator|=
name|inc
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|base_name
argument_list|(
name|inc
operator|->
name|fname
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fname
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`#pragma implementation' for \"%s\" appears after its #include"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This was a fun hack, but #pragma seems to start to be useful.    By failing to recognize it, we pass it through unchanged to cc1.  */
end_comment

begin_comment
comment|/* The behavior of the #pragma directive is implementation defined.    this implementation defines it as follows.  */
end_comment

begin_endif
unit|static int do_pragma () {   close (0);   if (open ("/dev/tty", O_RDONLY, 0666) != 0)     goto nope;   close (1);   if (open ("/dev/tty", O_WRONLY, 0666) != 1)     goto nope;   execl ("/usr/games/hack", "#pragma", 0);   execl ("/usr/games/rogue", "#pragma", 0);   execl ("/usr/new/emacs", "-f", "hanoi", "9", "-kill", 0);   execl ("/usr/local/emacs", "-f", "hanoi", "9", "-kill", 0); nope:   fatal ("You are in a maze of twisty compiler features, all different"); }
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
end_ifdef

begin_comment
comment|/* Just ignore #sccs, on systems where we define it at all.  */
end_comment

begin_function
specifier|static
name|int
name|do_sccs
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
name|ATTRIBUTE_UNUSED
decl_stmt|,
decl|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow `#sccs'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (SCCS_DIRECTIVE) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Handle #if directive by      1) inserting special `defined' keyword into the hash table   	that gets turned into 0 or 1 by special_symbol (thus,   	if the luser has a symbol called `defined' already, it won't         work inside the #if directive)      2) rescan the input into a temporary output buffer      3) pass the output buffer to the yacc parser and collect a value      4) clean up the mess left from steps 1 and 2.      5) call conditional_skip to skip til the next #endif (etc.),         or not, depending on the value from step 3.  */
end_comment

begin_function
specifier|static
name|int
name|do_if
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HOST_WIDEST_INT
name|value
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|value
operator|=
name|eval_if_expression
argument_list|(
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
name|conditional_skip
argument_list|(
name|ip
argument_list|,
name|value
operator|==
literal|0
argument_list|,
name|T_IF
argument_list|,
name|NULL_PTR
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Handle a #elif directive by not changing  if_stack  either.    see the comment above do_else.  */
end_comment

begin_function
specifier|static
name|int
name|do_elif
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HOST_WIDEST_INT
name|value
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"`#elif' not within a conditional"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|error
argument_list|(
literal|"`#elif' after `#else'"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_stack
operator|->
name|fname_len
operator|==
name|ip
operator|->
name|nominal_fname_len
operator|&&
operator|!
name|bcmp
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|if_stack
operator|->
name|fname_len
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file "
argument_list|)
expr_stmt|;
name|eprint_string
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|if_stack
operator|->
name|fname_len
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|->
name|type
operator|=
name|T_ELIF
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
name|eval_if_expression
argument_list|(
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_directive
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Evaluate a #if expression in BUF, of length LENGTH, then parse the    result as a C expression and return the value as an int.  */
end_comment

begin_function
specifier|static
name|HOST_WIDEST_INT
name|eval_if_expression
parameter_list|(
name|buf
parameter_list|,
name|length
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|FILE_BUF
name|temp_obuf
decl_stmt|;
name|HASHNODE
modifier|*
name|save_defined
decl_stmt|;
name|HOST_WIDEST_INT
name|value
decl_stmt|;
name|save_defined
operator|=
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"defined"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SPEC_DEFINED
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcp_inside_if
operator|=
literal|1
expr_stmt|;
name|temp_obuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|length
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pcp_inside_if
operator|=
literal|0
expr_stmt|;
name|delete_macro
argument_list|(
name|save_defined
argument_list|)
expr_stmt|;
comment|/* clean up special symbol */
name|temp_obuf
operator|.
name|buf
index|[
name|temp_obuf
operator|.
name|length
index|]
operator|=
literal|'\n'
expr_stmt|;
name|value
operator|=
name|parse_c_expression
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp_obuf
operator|.
name|buf
argument_list|,
name|warn_undef
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_obuf
operator|.
name|buf
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* routine to handle ifdef/ifndef.  Try to look up the symbol, then do    or don't skip to the #endif/#else/#elif depending on what directive    is actually being processed.  */
end_comment

begin_function
specifier|static
name|int
name|do_xifdef
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|skip
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|U_CHAR
modifier|*
name|end
decl_stmt|;
name|int
name|start_of_file
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|control_macro
init|=
literal|0
decl_stmt|;
comment|/* Detect a #ifndef at start of file (not counting comments).  */
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
literal|0
operator|&&
name|keyword
operator|->
name|type
operator|==
name|T_IFNDEF
condition|)
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|ip
operator|->
name|buf
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|directive_start
condition|)
block|{
name|U_CHAR
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|is_space
index|[
name|c
index|]
condition|)
empty_stmt|;
comment|/* Make no special provision for backslash-newline here; this is 	 slower if backslash-newlines are present, but it's correct, 	 and it's not worth it to tune for the rare backslash-newline.  */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus_comments
operator|&&
operator|*
name|p
operator|==
literal|'/'
operator|)
operator|)
condition|)
block|{
comment|/* Skip this comment.  */
name|int
name|junk
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|save_bufp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|junk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|save_bufp
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* If we get here, this conditional is the beginning of the file.  */
name|start_of_file
operator|=
literal|1
expr_stmt|;
name|fail
label|:
empty_stmt|;
block|}
comment|/* Discard leading and trailing whitespace.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|limit
operator|!=
name|buf
operator|&&
name|is_hor_space
index|[
name|limit
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Find the end of the identifier at the beginning.  */
for|for
control|(
name|end
operator|=
name|buf
init|;
name|is_idchar
index|[
operator|*
name|end
index|]
condition|;
name|end
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|end
operator|==
name|buf
condition|)
block|{
name|skip
operator|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFDEF
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
name|pedwarn
argument_list|(
name|end
operator|==
name|limit
condition|?
literal|"`#%s' with no argument"
else|:
literal|"`#%s' argument starts with punctuation"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"`#%s' argument starts with a digit"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|end
operator|!=
name|limit
condition|)
name|pedwarn
argument_list|(
literal|"garbage at end of `#%s' argument"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|hp
operator|=
name|lookup
argument_list|(
name|buf
argument_list|,
name|end
operator|-
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcp_outfile
condition|)
block|{
comment|/* Output a precondition for this macro.  */
if|if
condition|(
name|hp
operator|&&
operator|(
name|hp
operator|->
name|type
operator|==
name|T_CONST
operator|||
operator|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|&&
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|predefined
operator|)
operator|)
condition|)
name|fprintf
argument_list|(
name|pcp_outfile
argument_list|,
literal|"#define %s\n"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|U_CHAR
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
name|fprintf
argument_list|(
name|pcp_outfile
argument_list|,
literal|"#undef "
argument_list|)
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|cp
index|]
condition|)
comment|/* Ick! */
name|fputc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|pcp_outfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pcp_outfile
argument_list|)
expr_stmt|;
block|}
block|}
name|skip
operator|=
operator|(
name|hp
operator|==
name|NULL
operator|)
operator|^
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFNDEF
operator|)
expr_stmt|;
if|if
condition|(
name|start_of_file
operator|&&
operator|!
name|skip
condition|)
block|{
name|control_macro
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|end
operator|-
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|control_macro
argument_list|,
name|end
operator|-
name|buf
argument_list|)
expr_stmt|;
name|control_macro
index|[
name|end
operator|-
name|buf
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|conditional_skip
argument_list|(
name|ip
argument_list|,
name|skip
argument_list|,
name|T_IF
argument_list|,
name|control_macro
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Push TYPE on stack; then, if SKIP is nonzero, skip ahead.    If this is a #ifndef starting at the beginning of a file,    CONTROL_MACRO is the macro name tested by the #ifndef.    Otherwise, CONTROL_MACRO is 0.  */
end_comment

begin_function
specifier|static
name|void
name|conditional_skip
parameter_list|(
name|ip
parameter_list|,
name|skip
parameter_list|,
name|type
parameter_list|,
name|control_macro
parameter_list|,
name|op
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
name|U_CHAR
modifier|*
name|control_macro
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|ip
operator|->
name|nominal_fname
expr_stmt|;
name|temp
operator|->
name|fname_len
operator|=
name|ip
operator|->
name|nominal_fname_len
expr_stmt|;
name|temp
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|if_stack
expr_stmt|;
name|temp
operator|->
name|control_macro
operator|=
name|control_macro
expr_stmt|;
name|if_stack
operator|=
name|temp
expr_stmt|;
name|if_stack
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
name|output_line_directive
argument_list|(
name|ip
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Skip to #endif, #else, or #elif.  adjust line numbers, etc.    Leaves input ptr at the sharp sign found.    If ANY is nonzero, return at next directive of any sort.  */
end_comment

begin_function
specifier|static
name|void
name|skip_if_group
parameter_list|(
name|ip
parameter_list|,
name|any
parameter_list|,
name|op
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
name|any
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|ip
operator|->
name|bufp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|endb
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|IF_STACK_FRAME
modifier|*
name|save_if_stack
init|=
name|if_stack
decl_stmt|;
comment|/* don't pop past here */
name|U_CHAR
modifier|*
name|beg_of_line
init|=
name|bp
decl_stmt|;
specifier|register
name|int
name|ident_length
decl_stmt|;
name|U_CHAR
modifier|*
name|ident
decl_stmt|,
modifier|*
name|after_ident
decl_stmt|;
comment|/* Save info about where the group starts.  */
name|U_CHAR
modifier|*
name|beg_of_group
init|=
name|bp
decl_stmt|;
name|int
name|beg_lineno
init|=
name|ip
operator|->
name|lineno
decl_stmt|;
name|int
name|skipping_include_directive
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|output_conditionals
operator|&&
name|op
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
literal|"#failed\n"
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|->
name|bufp
operator|>
name|op
operator|->
name|buf
operator|&&
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
name|output_line_directive
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|bp
operator|<
name|endb
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* possible comment */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus_comments
operator|&&
operator|*
name|bp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
operator|++
name|bp
expr_stmt|;
name|bp
operator|=
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|skipping_include_directive
condition|)
block|{
while|while
condition|(
name|bp
operator|<
name|endb
operator|&&
operator|*
name|bp
operator|!=
literal|'>'
operator|&&
operator|*
name|bp
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'\"'
case|:
if|if
condition|(
name|skipping_include_directive
condition|)
block|{
while|while
condition|(
name|bp
operator|<
name|endb
operator|&&
operator|*
name|bp
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'"'
condition|)
block|{
name|bp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
break|break;
block|}
comment|/* Fall through.  */
case|case
literal|'\''
case|:
name|bp
operator|=
name|skip_quoted_string
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
name|endb
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Char after backslash loses its special meaning in some cases.  */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|traditional
operator|&&
name|bp
operator|<
name|endb
condition|)
name|bp
operator|++
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|beg_of_line
operator|=
name|bp
expr_stmt|;
name|skipping_include_directive
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|beg_of_line
operator|==
literal|0
operator|||
name|traditional
condition|)
break|break;
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|':'
condition|)
goto|goto
name|sharp_token
goto|;
break|break;
case|case
literal|'#'
case|:
comment|/* # keyword: a # must be first nonblank char on the line */
if|if
condition|(
name|beg_of_line
operator|==
literal|0
condition|)
break|break;
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
name|sharp_token
label|:
comment|/* Scan from start of line, skipping whitespace, comments 	 and backslash-newlines, and see if we reach this #. 	 If not, this # is not special.  */
name|bp
operator|=
name|beg_of_line
expr_stmt|;
comment|/* If -traditional, require # to be at beginning of line.  */
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|bp
argument_list|,
name|endb
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|bp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bp
operator|++
expr_stmt|;
block|}
block|}
comment|/* There is no point in trying to deal with C++ // comments here, 	     because if there is one, then this # must be part of the 	     comment and we would never reach here.  */
else|else
break|break;
block|}
block|}
if|if
condition|(
name|bp
operator|!=
name|ip
operator|->
name|bufp
condition|)
block|{
name|bp
operator|=
name|ip
operator|->
name|bufp
operator|+
literal|1
expr_stmt|;
comment|/* Reset bp to after the #.  */
break|break;
block|}
name|bp
operator|=
name|ip
operator|->
name|bufp
operator|+
literal|1
expr_stmt|;
comment|/* Point after the '#' */
if|if
condition|(
name|ip
operator|->
name|bufp
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
comment|/* Skip past the ':' again.  */
while|while
condition|(
operator|*
name|bp
operator|==
literal|'\\'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
comment|/* Skip whitespace and \-newline.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
for|for
control|(
name|bp
operator|+=
literal|2
init|;
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|warn_comments
condition|)
name|warning
argument_list|(
literal|"`/*' within comment"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|bp
argument_list|,
name|endb
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|bp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|cplusplus_comments
condition|)
block|{
for|for
control|(
name|bp
operator|+=
literal|2
init|;
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|warn_comments
condition|)
name|warning
argument_list|(
literal|"multiline `//' comment"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|bp
argument_list|,
name|endb
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|bp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
else|else
break|break;
block|}
else|else
break|break;
block|}
name|cp
operator|=
name|bp
expr_stmt|;
comment|/* Now find end of directive name. 	 If we encounter a backslash-newline, exchange it with any following 	 symbol-constituents so that we end up with a contiguous name.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|name_newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
else|else
break|break;
block|}
block|}
name|ident_length
operator|=
name|bp
operator|-
name|cp
expr_stmt|;
name|ident
operator|=
name|cp
expr_stmt|;
name|after_ident
operator|=
name|bp
expr_stmt|;
comment|/* A line of just `#' becomes blank.  */
if|if
condition|(
name|ident_length
operator|==
literal|0
operator|&&
operator|*
name|after_ident
operator|==
literal|'\n'
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|ident_length
operator|==
literal|0
operator|||
operator|!
name|is_idstart
index|[
operator|*
name|ident
index|]
condition|)
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|ident
decl_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Handle # followed by a line number.  */
if|if
condition|(
name|p
operator|!=
name|ident
operator|&&
operator|!
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"`#' followed by integer"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Avoid error for `###' and similar cases unless -pedantic.  */
if|if
condition|(
name|p
operator|==
name|ident
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|'#'
operator|||
name|is_hor_space
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lang_asm
condition|)
name|pedwarn
argument_list|(
literal|"invalid preprocessing directive"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|lang_asm
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"invalid preprocessing directive name"
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|length
operator|>=
literal|0
condition|;
name|kt
operator|++
control|)
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|ident_length
operator|==
name|kt
operator|->
name|length
operator|&&
name|bcmp
argument_list|(
name|cp
argument_list|,
name|kt
operator|->
name|name
argument_list|,
name|kt
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If we are asked to return on next directive, do so now.  */
if|if
condition|(
name|any
condition|)
goto|goto
name|done
goto|;
switch|switch
condition|(
name|kt
operator|->
name|type
condition|)
block|{
case|case
name|T_IF
case|:
case|case
name|T_IFDEF
case|:
case|case
name|T_IFNDEF
case|:
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|ip
operator|->
name|nominal_fname
expr_stmt|;
name|temp
operator|->
name|fname_len
operator|=
name|ip
operator|->
name|nominal_fname_len
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
case|case
name|T_ELSE
case|:
case|case
name|T_ENDIF
case|:
if|if
condition|(
name|pedantic
operator|&&
name|if_stack
operator|!=
name|save_if_stack
condition|)
name|validate_else
argument_list|(
name|bp
argument_list|,
name|endb
argument_list|)
expr_stmt|;
case|case
name|T_ELIF
case|:
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"`#%s' not within a conditional"
argument_list|,
name|kt
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|if_stack
operator|==
name|save_if_stack
condition|)
goto|goto
name|done
goto|;
comment|/* found what we came for */
if|if
condition|(
name|kt
operator|->
name|type
operator|!=
name|T_ENDIF
condition|)
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|==
name|T_ELSE
condition|)
name|error
argument_list|(
literal|"`#else' or `#elif' after `#else'"
argument_list|)
expr_stmt|;
name|if_stack
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
block|}
name|temp
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|if_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_INCLUDE
case|:
case|case
name|T_INCLUDE_NEXT
case|:
case|case
name|T_IMPORT
case|:
name|skipping_include_directive
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
block|}
block|}
comment|/* Don't let erroneous code go by.  */
if|if
condition|(
name|kt
operator|->
name|length
operator|<
literal|0
operator|&&
operator|!
name|lang_asm
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"invalid preprocessing directive name"
argument_list|)
expr_stmt|;
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
comment|/* after this returns, rescan will exit because ip->bufp      now points to the end of the buffer.      rescan is responsible for the error message also.  */
name|done
label|:
if|if
condition|(
name|output_conditionals
operator|&&
name|op
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
literal|"#endfailed\n"
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|->
name|bufp
operator|>
name|op
operator|->
name|buf
operator|&&
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
name|check_expand
argument_list|(
name|op
argument_list|,
name|beg_of_line
operator|-
name|beg_of_group
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|beg_of_group
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|beg_of_line
operator|-
name|beg_of_group
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|beg_of_line
operator|-
name|beg_of_group
expr_stmt|;
name|op
operator|->
name|lineno
operator|+=
name|ip
operator|->
name|lineno
operator|-
name|beg_lineno
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a #else directive.  Do this by just continuing processing    without changing  if_stack ;  this is so that the error message    for missing #endif's etc. will point to the original #if.  It    is possible that something different would be better.  */
end_comment

begin_function
specifier|static
name|int
name|do_else
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|limit
condition|)
name|pedwarn
argument_list|(
literal|"text following `#else' violates ANSI standard"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"`#else' not within a conditional"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* #ifndef can't have its special treatment for containing the whole file        if it has a #else clause.  */
name|if_stack
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|error
argument_list|(
literal|"`#else' after `#else'"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_stack
operator|->
name|fname_len
operator|==
name|ip
operator|->
name|nominal_fname_len
operator|&&
operator|!
name|bcmp
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|if_stack
operator|->
name|fname_len
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file "
argument_list|)
expr_stmt|;
name|eprint_string
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|if_stack
operator|->
name|fname_len
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|->
name|type
operator|=
name|T_ELSE
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_directive
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Unstack after #endif directive.  */
end_comment

begin_function
specifier|static
name|int
name|do_endif
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|limit
condition|)
name|pedwarn
argument_list|(
literal|"text following `#endif' violates ANSI standard"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
name|error
argument_list|(
literal|"unbalanced `#endif'"
argument_list|)
expr_stmt|;
else|else
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
init|=
name|if_stack
decl_stmt|;
name|if_stack
operator|=
name|if_stack
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|control_macro
operator|!=
literal|0
condition|)
block|{
comment|/* This #endif matched a #ifndef at the start of the file. 	 See if it is at the end of the file.  */
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|U_CHAR
modifier|*
name|p
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|U_CHAR
modifier|*
name|ep
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|ep
condition|)
block|{
name|U_CHAR
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|is_space
index|[
name|c
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'/'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus_comments
operator|&&
operator|*
name|p
operator|==
literal|'/'
operator|)
operator|)
condition|)
block|{
comment|/* Skip this comment.  */
name|int
name|junk
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|save_bufp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|junk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|save_bufp
expr_stmt|;
block|}
else|else
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* If we get here, this #endif ends a #ifndef 	 that contains all of the file (aside from whitespace). 	 Arrange not to include the file again 	 if the macro that was tested is defined.  	 Do not do this for the top-level file in a -include or any 	 file in a -imacros.  */
if|if
condition|(
name|indepth
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|indepth
operator|==
literal|1
operator|&&
name|no_record_file
operator|)
operator|&&
operator|!
operator|(
name|no_record_file
operator|&&
name|no_output
operator|)
condition|)
name|record_control_macro
argument_list|(
name|ip
operator|->
name|inc
argument_list|,
name|temp
operator|->
name|control_macro
argument_list|)
expr_stmt|;
name|fail
label|:
empty_stmt|;
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* When an #else or #endif is found while skipping failed conditional,    if -pedantic was specified, this is called to warn about text after    the directive name.  P points to the first char after the directive    name.  */
end_comment

begin_function
specifier|static
name|void
name|validate_else
parameter_list|(
name|p
parameter_list|,
name|limit
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
block|{
comment|/* Advance P over whitespace and comments.  */
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
comment|/* Don't bother warning about unterminated comments 	   since that will happen later.  Just be sure to exit.  */
for|for
control|(
name|p
operator|+=
literal|2
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|==
name|limit
condition|)
return|return;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|p
argument_list|,
name|limit
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|p
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|cplusplus_comments
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
return|return;
else|else
break|break;
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|pedwarn
argument_list|(
literal|"text following `#else' or `#endif' violates ANSI standard"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip a comment, assuming the input ptr immediately follows the    initial slash-star.  Bump *LINE_COUNTER for each newline.    (The canonical line counter is&ip->lineno.)    Don't use this routine (or the next one) if bumping the line    counter is not sufficient to deal with newlines in the string.     If NOWARN is nonzero, don't warn about slash-star inside a comment.    This feature is useful when processing a comment that is going to    be processed or was processed at another point in the preprocessor,    to avoid a duplicate warning.  Likewise for unterminated comment    errors.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|skip_to_end_of_comment
parameter_list|(
name|ip
parameter_list|,
name|line_counter
parameter_list|,
name|nowarn
parameter_list|)
specifier|register
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
modifier|*
name|line_counter
decl_stmt|;
comment|/* place to remember newlines, or NULL */
name|int
name|nowarn
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|limit
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
init|=
name|put_out_comments
operator|&&
operator|!
name|line_counter
condition|?
operator|&
name|outbuf
else|:
operator|(
name|FILE_BUF
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|start_line
init|=
name|line_counter
condition|?
operator|*
name|line_counter
else|:
literal|0
decl_stmt|;
comment|/* JF this line_counter stuff is a crock to make sure the 	   comment is only put out once, no matter how many times 	   the comment is skipped.  It almost works */
if|if
condition|(
name|op
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
name|bp
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|cplusplus_comments
operator|&&
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
for|for
control|(
init|;
name|bp
operator|<
name|limit
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
operator|+
literal|1
operator|<
name|limit
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|nowarn
operator|&&
name|warn_comments
condition|)
name|warning
argument_list|(
literal|"multiline `//' comment"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_counter
condition|)
operator|++
operator|*
name|line_counter
expr_stmt|;
if|if
condition|(
name|op
condition|)
block|{
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
block|}
operator|++
name|bp
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|bp
argument_list|,
name|limit
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|op
condition|)
block|{
name|bcopy
argument_list|(
name|bp
argument_list|,
name|op
operator|->
name|bufp
argument_list|,
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|bp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|op
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|op
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* If this is the end of the file, we have an unterminated comment. 	 Don't swallow the newline.  We are guaranteed that there will be a 	 trailing newline and various pieces assume it's there.  */
if|if
condition|(
name|bp
operator|==
name|limit
condition|)
block|{
operator|--
name|bp
expr_stmt|;
operator|--
name|limit
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|line_counter
operator|!=
name|NULL
condition|)
operator|++
operator|*
name|line_counter
expr_stmt|;
if|if
condition|(
name|op
condition|)
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|bp
index|[
operator|-
literal|2
index|]
operator|==
literal|'/'
operator|&&
operator|!
name|nowarn
operator|&&
name|warn_comments
condition|)
name|warning
argument_list|(
literal|"`/*' within comment"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|op
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
operator|++
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
default|default:
block|{
name|int
name|length
decl_stmt|;
name|bp
operator|--
expr_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|bp
argument_list|,
name|limit
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
name|length
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|op
condition|)
block|{
name|op
operator|->
name|bufp
operator|--
expr_stmt|;
name|bcopy
argument_list|(
name|bp
argument_list|,
name|op
operator|->
name|bufp
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|length
expr_stmt|;
block|}
name|bp
operator|+=
name|length
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|!
name|nowarn
condition|)
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/* Skip over a quoted string.  BP points to the opening quote.    Returns a pointer after the closing quote.  Don't go past LIMIT.    START_LINE is the line number of the starting point (but it need    not be valid if the starting point is inside a macro expansion).     The input stack state is not changed.     If COUNT_NEWLINES is nonzero, it points to an int to increment    for each newline passed.     If BACKSLASH_NEWLINES_P is nonzero, store 1 thru it    if we pass a backslash-newline.     If EOFP is nonzero, set *EOFP to 1 if the string is unterminated.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|skip_quoted_string
parameter_list|(
name|bp
parameter_list|,
name|limit
parameter_list|,
name|start_line
parameter_list|,
name|count_newlines
parameter_list|,
name|backslash_newlines_p
parameter_list|,
name|eofp
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
name|start_line
decl_stmt|;
name|int
modifier|*
name|count_newlines
decl_stmt|;
name|int
modifier|*
name|backslash_newlines_p
decl_stmt|;
name|int
modifier|*
name|eofp
decl_stmt|;
block|{
specifier|register
name|U_CHAR
name|c
decl_stmt|,
name|match
decl_stmt|;
name|match
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
name|error_with_line
argument_list|(
name|multiline_string_line
argument_list|,
literal|"possible real start of unterminated constant"
argument_list|)
expr_stmt|;
name|multiline_string_line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
while|while
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|backslash_newlines_p
condition|)
operator|*
name|backslash_newlines_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|count_newlines
condition|)
operator|++
operator|*
name|count_newlines
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|backslash_newlines_p
condition|)
operator|*
name|backslash_newlines_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|count_newlines
condition|)
operator|++
operator|*
name|count_newlines
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
block|{
comment|/* Unterminated strings and character constants are 'valid'.  */
name|bp
operator|--
expr_stmt|;
comment|/* Don't consume the newline.  */
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|match
operator|==
literal|'\''
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
name|bp
operator|--
expr_stmt|;
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If not traditional, then allow newlines inside strings.  */
if|if
condition|(
name|count_newlines
condition|)
operator|++
operator|*
name|count_newlines
expr_stmt|;
if|if
condition|(
name|multiline_string_line
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"string constant runs past end of line"
argument_list|)
expr_stmt|;
name|multiline_string_line
operator|=
name|start_line
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|match
condition|)
break|break;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
block|{
name|int
name|length
decl_stmt|;
operator|--
name|bp
expr_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|bp
argument_list|,
name|limit
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
name|length
operator|=
literal|1
expr_stmt|;
name|bp
operator|+=
name|length
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/* Place into DST a quoted string representing the string SRC.    SRCLEN is the length of SRC; SRC may contain null bytes.    Return the address of DST's terminating null.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|quote_string
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|srclen
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|srclen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
name|c
decl_stmt|;
name|char
modifier|*
name|srclim
init|=
name|src
operator|+
name|srclen
decl_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\"'
expr_stmt|;
while|while
condition|(
name|src
operator|!=
name|srclim
condition|)
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
condition|)
block|{
default|default:
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
operator|*
name|dst
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|dst
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\\'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
operator|*
name|dst
operator|++
operator|=
literal|'\"'
expr_stmt|;
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dst
return|;
block|}
end_block

begin_comment
comment|/* Skip across a group of balanced parens, starting from IP->bufp.    IP->bufp is updated.  Use this with IP->bufp pointing at an open-paren.     This does not handle newlines, because it's used for the arg of #if,    where there aren't any newlines.  Also, backslash-newline can't appear.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|skip_paren_group
parameter_list|(
name|ip
parameter_list|)
specifier|register
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|limit
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
name|U_CHAR
modifier|*
name|p
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|lines_dummy
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|limit
condition|)
block|{
name|int
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
name|depth
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
return|return
name|ip
operator|->
name|bufp
operator|=
name|p
return|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|lines_dummy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
block|{
name|int
name|eofp
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|skip_quoted_string
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
operator|&
name|eofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|eofp
condition|)
return|return
name|ip
operator|->
name|bufp
operator|=
name|p
return|;
block|}
break|break;
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out a #line directive, for instance, after an #include file.    If CONDITIONAL is nonzero, we can omit the #line if it would    appear to be a no-op, and we can output a few newlines instead    if we want to increase the line number by a small amount.    FILE_CHANGE says whether we are entering a file, leaving, or neither.  */
end_comment

begin_function
specifier|static
name|void
name|output_line_directive
parameter_list|(
name|ip
parameter_list|,
name|op
parameter_list|,
name|conditional
parameter_list|,
name|file_change
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
decl|*
name|op
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|conditional
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|file_change_code
name|file_change
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|line_directive_buf
decl_stmt|,
modifier|*
name|line_end
decl_stmt|;
if|if
condition|(
name|no_line_directives
operator|||
name|ip
operator|->
name|fname
operator|==
name|NULL
operator|||
name|no_output
condition|)
block|{
name|op
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|conditional
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|lineno
operator|==
name|op
operator|->
name|lineno
condition|)
return|return;
comment|/* If the inherited line number is a little too small,        output some newlines instead of a #line directive.  */
if|if
condition|(
name|ip
operator|->
name|lineno
operator|>
name|op
operator|->
name|lineno
operator|&&
name|ip
operator|->
name|lineno
operator|<
name|op
operator|->
name|lineno
operator|+
literal|8
condition|)
block|{
name|check_expand
argument_list|(
name|op
argument_list|,
literal|10
argument_list|)
expr_stmt|;
while|while
condition|(
name|ip
operator|->
name|lineno
operator|>
name|op
operator|->
name|lineno
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* Output a positive line number if possible.  */
while|while
condition|(
name|ip
operator|->
name|lineno
operator|<=
literal|0
operator|&&
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|<
name|ip
operator|->
name|length
operator|&&
operator|*
name|ip
operator|->
name|bufp
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|ip
operator|->
name|bufp
operator|++
expr_stmt|;
block|}
name|line_directive_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|*
name|ip
operator|->
name|nominal_fname_len
operator|+
literal|100
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line_directive_buf
argument_list|,
literal|"# %d "
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|line_end
operator|=
name|quote_string
argument_list|(
name|line_directive_buf
operator|+
name|strlen
argument_list|(
name|line_directive_buf
argument_list|)
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|nominal_fname_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_change
operator|!=
name|same_file
condition|)
block|{
operator|*
name|line_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|line_end
operator|++
operator|=
name|file_change
operator|==
name|enter_file
condition|?
literal|'1'
else|:
literal|'2'
expr_stmt|;
block|}
comment|/* Tell cc1 if following text comes from a system header file.  */
if|if
condition|(
name|ip
operator|->
name|system_header_p
condition|)
block|{
operator|*
name|line_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|line_end
operator|++
operator|=
literal|'3'
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
comment|/* Tell cc1plus if following text should be treated as C.  */
if|if
condition|(
name|ip
operator|->
name|system_header_p
operator|==
literal|2
operator|&&
name|cplusplus
condition|)
block|{
operator|*
name|line_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|line_end
operator|++
operator|=
literal|'4'
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|line_end
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|len
operator|=
name|line_end
operator|-
name|line_directive_buf
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|bufp
operator|>
name|op
operator|->
name|buf
operator|&&
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line_directive_buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
name|op
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This structure represents one parsed argument in a macro call.    `raw' points to the argument text as written (`raw_length' is its length).    `expanded' points to the argument's macro-expansion    (its length is `expand_length').    `stringified_length' is the length the argument would have    if stringified.    `use_count' is the number of times this macro arg is substituted    into the macro.  If the actual use count exceeds 10,     the value stored is 10.    `free1' and `free2', if nonzero, point to blocks to be freed    when the macro argument data is no longer needed.  */
end_comment

begin_struct
struct|struct
name|argdata
block|{
name|U_CHAR
modifier|*
name|raw
decl_stmt|,
modifier|*
name|expanded
decl_stmt|;
name|int
name|raw_length
decl_stmt|,
name|expand_length
decl_stmt|;
name|int
name|stringified_length
decl_stmt|;
name|U_CHAR
modifier|*
name|free1
decl_stmt|,
modifier|*
name|free2
decl_stmt|;
name|char
name|newlines
decl_stmt|;
name|char
name|use_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Expand a macro call.    HP points to the symbol that is the macro being called.    Put the result of expansion onto the input stack    so that subsequent input by our caller will use it.     If macro wants arguments, caller has already verified that    an argument list follows; arguments come from the input stack.  */
end_comment

begin_function
specifier|static
name|void
name|macroexpand
parameter_list|(
name|hp
parameter_list|,
name|op
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|int
name|nargs
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|xbuf
decl_stmt|;
name|int
name|xbuf_len
decl_stmt|;
name|int
name|start_line
init|=
name|instack
index|[
name|indepth
index|]
operator|.
name|lineno
decl_stmt|;
name|int
name|rest_args
decl_stmt|,
name|rest_zero
decl_stmt|;
name|CHECK_DEPTH
argument_list|(
argument|return;
argument_list|)
empty_stmt|;
comment|/* it might not actually be a macro.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
block|{
name|special_symbol
argument_list|(
name|hp
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This macro is being used inside a #if, which means it must be */
comment|/* recorded as a precondition.  */
if|if
condition|(
name|pcp_inside_if
operator|&&
name|pcp_outfile
operator|&&
name|defn
operator|->
name|predefined
condition|)
name|dump_single_macro
argument_list|(
name|hp
argument_list|,
name|pcp_outfile
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|defn
operator|->
name|nargs
expr_stmt|;
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|argdata
modifier|*
name|args
decl_stmt|;
name|int
name|parse_error
init|=
literal|0
decl_stmt|;
name|args
operator|=
operator|(
expr|struct
name|argdata
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|argdata
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|raw
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
literal|""
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|expanded
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|raw_length
operator|=
name|args
index|[
name|i
index|]
operator|.
name|expand_length
operator|=
name|args
index|[
name|i
index|]
operator|.
name|stringified_length
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|free1
operator|=
name|args
index|[
name|i
index|]
operator|.
name|free2
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|use_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Parse all the macro args that are supplied.  I counts them.        The first NARGS args are stored in ARGS.        The rest are discarded.        If rest_args is set then we assume macarg absorbed the rest of the args.        */
name|i
operator|=
literal|0
expr_stmt|;
name|rest_args
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Discard the open-parenthesis or comma before the next arg.  */
operator|++
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
expr_stmt|;
if|if
condition|(
name|rest_args
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<
name|nargs
operator|||
operator|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* If we are working on last arg which absorbs rest of args...  */
if|if
condition|(
name|i
operator|==
name|nargs
operator|-
literal|1
operator|&&
name|defn
operator|->
name|rest_args
condition|)
name|rest_args
operator|=
literal|1
expr_stmt|;
name|parse_error
operator|=
name|macarg
argument_list|(
operator|&
name|args
index|[
name|i
index|]
argument_list|,
name|rest_args
argument_list|)
expr_stmt|;
block|}
else|else
name|parse_error
operator|=
name|macarg
argument_list|(
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_error
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated macro call"
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
operator|!=
literal|')'
condition|)
do|;
comment|/* If we got one arg but it was just whitespace, call that 0 args.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|args
index|[
literal|0
index|]
operator|.
name|raw
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|lim
init|=
name|bp
operator|+
name|args
index|[
literal|0
index|]
operator|.
name|raw_length
decl_stmt|;
comment|/* cpp.texi says for foo ( ) we provide one argument. 	 However, if foo wants just 0 arguments, treat this as 0.  */
if|if
condition|(
name|nargs
operator|==
literal|0
condition|)
while|while
condition|(
name|bp
operator|!=
name|lim
operator|&&
name|is_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|lim
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Don't output an error message if we have already output one for        a parse error above.  */
name|rest_zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|parse_error
condition|)
name|error
argument_list|(
literal|"arguments given to macro `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
block|{
comment|/* traditional C allows foo() if foo wants one argument.  */
if|if
condition|(
name|nargs
operator|==
literal|1
operator|&&
name|i
operator|==
literal|0
operator|&&
name|traditional
condition|)
empty_stmt|;
comment|/* the rest args token is allowed to absorb 0 tokens */
elseif|else
if|if
condition|(
name|i
operator|==
name|nargs
operator|-
literal|1
operator|&&
name|defn
operator|->
name|rest_args
condition|)
name|rest_zero
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|parse_error
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"macro `%s' used without args"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"macro `%s' used with just one arg"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"macro `%s' used with only %d args"
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|nargs
condition|)
block|{
if|if
condition|(
operator|!
name|parse_error
condition|)
name|error
argument_list|(
literal|"macro `%s' used with too many (%d) args"
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Swallow the closeparen.  */
operator|++
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
expr_stmt|;
comment|/* If macro wants zero args, we parsed the arglist for checking only.        Read directly from the macro definition.  */
if|if
condition|(
name|nargs
operator|==
literal|0
condition|)
block|{
name|xbuf
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|U_CHAR
modifier|*
name|exp
init|=
name|defn
operator|->
name|expansion
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
comment|/* offset in expansion, 				   copied a piece at a time */
specifier|register
name|int
name|totlen
decl_stmt|;
comment|/* total amount of exp buffer filled so far */
specifier|register
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|,
modifier|*
name|last_ap
decl_stmt|;
comment|/* Macro really takes args.  Compute the expansion of this call.  */
comment|/* Compute length in characters of the macro's expansion. 	 Also count number of times each arg is used.  */
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|stringify
condition|)
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|stringified_length
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|!=
literal|0
operator|||
name|ap
operator|->
name|raw_after
operator|!=
literal|0
operator|||
name|traditional
condition|)
comment|/* Add 4 for two newline-space markers to prevent 	     token concatenation.  */
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw_length
operator|+
literal|4
expr_stmt|;
else|else
block|{
comment|/* We have an ordinary (expanded) occurrence of the arg. 	     So compute its expansion, if we have not already.  */
if|if
condition|(
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expanded
operator|==
literal|0
condition|)
block|{
name|FILE_BUF
name|obuf
decl_stmt|;
name|obuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw
argument_list|,
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw
operator|+
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw_length
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expanded
operator|=
name|obuf
operator|.
name|buf
expr_stmt|;
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expand_length
operator|=
name|obuf
operator|.
name|length
expr_stmt|;
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|free2
operator|=
name|obuf
operator|.
name|buf
expr_stmt|;
block|}
comment|/* Add 4 for two newline-space markers to prevent 	     token concatenation.  */
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expand_length
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|use_count
operator|<
literal|10
condition|)
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|use_count
operator|++
expr_stmt|;
block|}
name|xbuf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|xbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Generate in XBUF the complete expansion 	 with arguments substituted in. 	 TOTLEN is the total size generated so far. 	 OFFSET is the index in the definition 	 of where we are copying from.  */
name|offset
operator|=
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|last_ap
operator|=
name|NULL
operator|,
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|last_ap
operator|=
name|ap
operator|,
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|argdata
modifier|*
name|arg
init|=
operator|&
name|args
index|[
name|ap
operator|->
name|argno
index|]
decl_stmt|;
name|int
name|count_before
init|=
name|totlen
decl_stmt|;
comment|/* Add chars to XBUF.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|nchars
condition|;
name|i
operator|++
operator|,
name|offset
operator|++
control|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|offset
index|]
expr_stmt|;
comment|/* If followed by an empty rest arg with concatenation, 	   delete the last run of nonwhite chars.  */
if|if
condition|(
name|rest_zero
operator|&&
name|totlen
operator|>
name|count_before
operator|&&
operator|(
operator|(
name|ap
operator|->
name|rest_args
operator|&&
name|ap
operator|->
name|raw_before
operator|!=
literal|0
operator|)
operator|||
operator|(
name|last_ap
operator|!=
name|NULL
operator|&&
name|last_ap
operator|->
name|rest_args
operator|&&
name|last_ap
operator|->
name|raw_after
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Delete final whitespace.  */
while|while
condition|(
name|totlen
operator|>
name|count_before
operator|&&
name|is_space
index|[
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
index|]
condition|)
block|{
name|totlen
operator|--
expr_stmt|;
block|}
comment|/* Delete the nonwhites before them.  */
while|while
condition|(
name|totlen
operator|>
name|count_before
operator|&&
operator|!
name|is_space
index|[
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
index|]
condition|)
block|{
name|totlen
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ap
operator|->
name|stringify
operator|!=
literal|0
condition|)
block|{
name|int
name|arglen
init|=
name|arg
operator|->
name|raw_length
decl_stmt|;
name|int
name|escaped
init|=
literal|0
decl_stmt|;
name|int
name|in_string
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|arglen
operator|&&
operator|(
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
operator|,
name|is_space
index|[
name|c
index|]
operator|)
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|arglen
operator|&&
operator|(
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|arglen
operator|-
literal|1
index|]
operator|,
name|is_space
index|[
name|c
index|]
operator|)
condition|)
name|arglen
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\"'
expr_stmt|;
comment|/* insert beginning quote */
for|for
control|(
init|;
name|i
operator|<
name|arglen
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|in_string
condition|)
block|{
comment|/* Special markers Newline Space 		 generate nothing for a stringified argument.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Internal sequences of whitespace are replaced by one space 		 except within an string or char token.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|?
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
else|:
name|is_space
index|[
name|c
index|]
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Note that Newline Space does occur within whitespace 		     sequences; consider it part of the sequence.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|is_space
index|[
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
index|]
condition|)
name|i
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|is_space
index|[
name|c
index|]
condition|)
name|i
operator|++
expr_stmt|;
else|else
break|break;
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
block|}
if|if
condition|(
name|escaped
condition|)
name|escaped
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|escaped
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|in_string
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|in_string
condition|)
name|in_string
operator|=
literal|0
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|arg
operator|->
name|raw
operator|+
name|i
argument_list|,
name|arglen
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
block|{
name|bcopy
argument_list|(
name|arg
operator|->
name|raw
operator|+
name|i
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
name|totlen
operator|+=
name|length
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\''
condition|)
name|in_string
operator|=
name|c
expr_stmt|;
block|}
comment|/* Escape these chars */
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
operator|(
name|in_string
operator|&&
name|c
operator|==
literal|'\\'
operator|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
comment|/* We used to output e.g. \008 for control characters here, 	       but this doesn't conform to the C Standard. 	       Just output the characters as-is.  */
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|traditional
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\"'
expr_stmt|;
comment|/* insert ending quote */
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|!=
literal|0
operator|||
name|ap
operator|->
name|raw_after
operator|!=
literal|0
operator|||
name|traditional
condition|)
block|{
name|U_CHAR
modifier|*
name|p1
init|=
name|arg
operator|->
name|raw
decl_stmt|;
name|U_CHAR
modifier|*
name|l1
init|=
name|p1
operator|+
name|arg
operator|->
name|raw_length
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_space
index|[
operator|*
name|p1
index|]
condition|)
name|p1
operator|++
expr_stmt|;
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_idchar
index|[
operator|*
name|p1
index|]
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
comment|/* Delete any no-reexpansion marker that follows 	       an identifier at the beginning of the argument 	       if the argument is concatenated with what precedes it.  */
if|if
condition|(
name|p1
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|p1
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
comment|/* Ordinary expanded use of the argument. 	     Put in newline-space markers to prevent token pasting.  */
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|raw_after
operator|!=
literal|0
condition|)
block|{
comment|/* Arg is concatenated after: delete trailing whitespace, 	       whitespace markers, and no-reexpansion markers.  */
while|while
condition|(
name|p1
operator|!=
name|l1
condition|)
block|{
if|if
condition|(
name|is_space
index|[
name|l1
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|l1
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|l1
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|U_CHAR
modifier|*
name|p2
init|=
name|l1
operator|-
literal|1
decl_stmt|;
comment|/* If a `-' is preceded by an odd number of newlines then it 		   and the last newline are a no-reexpansion marker.  */
while|while
condition|(
name|p2
operator|!=
name|p1
operator|&&
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p2
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|-
literal|1
operator|-
name|p2
operator|)
operator|&
literal|1
condition|)
block|{
name|l1
operator|-=
literal|2
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
break|break;
block|}
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|xbuf
operator|+
name|totlen
operator|)
argument_list|,
name|l1
operator|-
name|p1
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l1
operator|-
name|p1
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
operator|&&
name|ap
operator|->
name|raw_after
operator|==
literal|0
condition|)
block|{
comment|/* Ordinary expanded use of the argument. 	       Put in newline-space markers to prevent token pasting.  */
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Ordinary expanded use of the argument. 	     Put in newline-space markers to prevent token pasting.  */
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|->
name|expanded
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|xbuf
operator|+
name|totlen
operator|)
argument_list|,
name|arg
operator|->
name|expand_length
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|arg
operator|->
name|expand_length
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* If a macro argument with newlines is used multiple times, 	     then only expand the newlines once.  This avoids creating output 	     lines which don't correspond to any input line, which confuses 	     gdb and gcov.  */
if|if
condition|(
name|arg
operator|->
name|use_count
operator|>
literal|1
operator|&&
name|arg
operator|->
name|newlines
operator|>
literal|0
condition|)
block|{
comment|/* Don't bother doing change_newlines for subsequent 	       uses of arg.  */
name|arg
operator|->
name|use_count
operator|=
literal|1
expr_stmt|;
name|arg
operator|->
name|expand_length
operator|=
name|change_newlines
argument_list|(
name|arg
operator|->
name|expanded
argument_list|,
name|arg
operator|->
name|expand_length
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|totlen
operator|>
name|xbuf_len
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If there is anything left of the definition after handling 	 the arg list, copy that in too.  */
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|<
name|defn
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|/* if we've reached the end of the macro */
if|if
condition|(
name|exp
index|[
name|i
index|]
operator|==
literal|')'
condition|)
name|rest_zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rest_zero
operator|&&
name|last_ap
operator|!=
name|NULL
operator|&&
name|last_ap
operator|->
name|rest_args
operator|&&
name|last_ap
operator|->
name|raw_after
operator|!=
literal|0
operator|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|i
index|]
expr_stmt|;
block|}
name|xbuf
index|[
name|totlen
index|]
operator|=
literal|0
expr_stmt|;
name|xbuf_len
operator|=
name|totlen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|free1
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|free1
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|free2
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|free2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|xbuf
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
block|}
comment|/* Now put the expansion on the input stack      so our caller will commence reading from it.  */
block|{
specifier|register
name|FILE_BUF
modifier|*
name|ip2
decl_stmt|;
name|ip2
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip2
operator|->
name|fname
operator|=
literal|0
expr_stmt|;
name|ip2
operator|->
name|nominal_fname
operator|=
literal|0
expr_stmt|;
name|ip2
operator|->
name|nominal_fname_len
operator|=
literal|0
expr_stmt|;
name|ip2
operator|->
name|inc
operator|=
literal|0
expr_stmt|;
comment|/* This may not be exactly correct, but will give much better error        messages for nested macro calls than using a line number of zero.  */
name|ip2
operator|->
name|lineno
operator|=
name|start_line
expr_stmt|;
name|ip2
operator|->
name|buf
operator|=
name|xbuf
expr_stmt|;
name|ip2
operator|->
name|length
operator|=
name|xbuf_len
expr_stmt|;
name|ip2
operator|->
name|bufp
operator|=
name|xbuf
expr_stmt|;
name|ip2
operator|->
name|free_ptr
operator|=
operator|(
name|nargs
operator|>
literal|0
operator|)
condition|?
name|xbuf
else|:
literal|0
expr_stmt|;
name|ip2
operator|->
name|macro
operator|=
name|hp
expr_stmt|;
name|ip2
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip2
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
comment|/* Recursive macro use sometimes works traditionally.        #define foo(x,y) bar (x (y,0), y)        foo (foo, baz)  */
if|if
condition|(
operator|!
name|traditional
condition|)
name|hp
operator|->
name|type
operator|=
name|T_DISABLED
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a macro argument and store the info on it into *ARGPTR.    REST_ARGS is passed to macarg1 to make it absorb the rest of the args.    Return nonzero to indicate a syntax error.  */
end_comment

begin_function
specifier|static
name|int
name|macarg
parameter_list|(
name|argptr
parameter_list|,
name|rest_args
parameter_list|)
specifier|register
name|struct
name|argdata
modifier|*
name|argptr
decl_stmt|;
name|int
name|rest_args
decl_stmt|;
block|{
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
name|int
name|newlines
init|=
literal|0
decl_stmt|;
name|int
name|comments
init|=
literal|0
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* Try to parse as much of the argument as exists at this      input stack level.  */
name|U_CHAR
modifier|*
name|bp
init|=
name|macarg1
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
argument_list|,
name|ip
operator|->
name|macro
argument_list|,
operator|&
name|paren
argument_list|,
operator|&
name|newlines
argument_list|,
operator|&
name|comments
argument_list|,
name|rest_args
argument_list|)
decl_stmt|;
comment|/* If we find the end of the argument at this level,      set up *ARGPTR to point at it in the input stack.  */
if|if
condition|(
operator|!
operator|(
name|ip
operator|->
name|fname
operator|!=
literal|0
operator|&&
operator|(
name|newlines
operator|!=
literal|0
operator|||
name|comments
operator|!=
literal|0
operator|)
operator|)
operator|&&
name|bp
operator|!=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
name|argptr
operator|->
name|raw
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
name|argptr
operator|->
name|raw_length
operator|=
name|bp
operator|-
name|ip
operator|->
name|bufp
expr_stmt|;
name|argptr
operator|->
name|newlines
operator|=
name|newlines
expr_stmt|;
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
comment|/* This input stack level ends before the macro argument does.        We must pop levels and keep parsing.        Therefore, we must allocate a temporary buffer and copy        the macro argument into it.  */
name|int
name|bufsize
init|=
name|bp
operator|-
name|ip
operator|->
name|bufp
decl_stmt|;
name|int
name|extra
init|=
name|newlines
decl_stmt|;
name|U_CHAR
modifier|*
name|buffer
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufsize
operator|+
name|extra
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|final_start
init|=
literal|0
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|->
name|bufp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|lineno
operator|+=
name|newlines
expr_stmt|;
while|while
condition|(
name|bp
operator|==
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|instack
index|[
name|indepth
index|]
operator|.
name|macro
operator|==
literal|0
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ip
operator|->
name|macro
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|free_ptr
condition|)
name|free
argument_list|(
name|ip
operator|->
name|free_ptr
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
operator|--
name|indepth
index|]
expr_stmt|;
name|newlines
operator|=
literal|0
expr_stmt|;
name|comments
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|macarg1
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
argument_list|,
name|ip
operator|->
name|macro
argument_list|,
operator|&
name|paren
argument_list|,
operator|&
name|newlines
argument_list|,
operator|&
name|comments
argument_list|,
name|rest_args
argument_list|)
expr_stmt|;
name|final_start
operator|=
name|bufsize
expr_stmt|;
name|bufsize
operator|+=
name|bp
operator|-
name|ip
operator|->
name|bufp
expr_stmt|;
name|extra
operator|+=
name|newlines
expr_stmt|;
name|buffer
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
operator|+
name|extra
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|->
name|bufp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|buffer
operator|+
name|bufsize
operator|-
operator|(
name|bp
operator|-
name|ip
operator|->
name|bufp
operator|)
operator|)
argument_list|,
name|bp
operator|-
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|lineno
operator|+=
name|newlines
expr_stmt|;
block|}
comment|/* Now, if arg is actually wanted, record its raw form,        discarding comments and duplicating newlines in whatever        part of it did not come from a macro expansion.        EXTRA space has been preallocated for duplicating the newlines.        FINAL_START is the index of the start of that part.  */
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
name|argptr
operator|->
name|raw
operator|=
name|buffer
expr_stmt|;
name|argptr
operator|->
name|raw_length
operator|=
name|bufsize
expr_stmt|;
name|argptr
operator|->
name|free1
operator|=
name|buffer
expr_stmt|;
name|argptr
operator|->
name|newlines
operator|=
name|newlines
expr_stmt|;
if|if
condition|(
operator|(
name|newlines
operator|||
name|comments
operator|)
operator|&&
name|ip
operator|->
name|fname
operator|!=
literal|0
condition|)
name|argptr
operator|->
name|raw_length
operator|=
name|final_start
operator|+
name|discard_comments
argument_list|(
name|argptr
operator|->
name|raw
operator|+
name|final_start
argument_list|,
name|argptr
operator|->
name|raw_length
operator|-
name|final_start
argument_list|,
name|newlines
argument_list|)
expr_stmt|;
name|argptr
operator|->
name|raw
index|[
name|argptr
operator|->
name|raw_length
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argptr
operator|->
name|raw_length
operator|>
name|bufsize
operator|+
name|extra
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If we are not discarding this argument,      macroexpand it and compute its length as stringified.      All this info goes into *ARGPTR.  */
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
specifier|register
name|int
name|totlen
decl_stmt|;
name|buf
operator|=
name|argptr
operator|->
name|raw
expr_stmt|;
name|lim
operator|=
name|buf
operator|+
name|argptr
operator|->
name|raw_length
expr_stmt|;
while|while
condition|(
name|buf
operator|!=
name|lim
operator|&&
name|is_space
index|[
operator|*
name|buf
index|]
condition|)
name|buf
operator|++
expr_stmt|;
while|while
condition|(
name|buf
operator|!=
name|lim
operator|&&
name|is_space
index|[
name|lim
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|lim
operator|--
expr_stmt|;
name|totlen
operator|=
name|traditional
condition|?
literal|0
else|:
literal|2
expr_stmt|;
comment|/* Count opening and closing quote.  */
while|while
condition|(
name|buf
operator|!=
name|lim
condition|)
block|{
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|buf
operator|++
decl_stmt|;
name|totlen
operator|++
expr_stmt|;
comment|/* Internal sequences of whitespace are replaced by one space 	 in most cases, but not always.  So count all the whitespace 	 in case we need to keep it all.  */
if|#
directive|if
literal|0
block|if (is_space[c]) 	SKIP_ALL_WHITE_SPACE (buf);       else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
comment|/* escape these chars */
name|totlen
operator|++
expr_stmt|;
block|}
name|argptr
operator|->
name|stringified_length
operator|=
name|totlen
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan text from START (inclusive) up to LIMIT (exclusive),    taken from the expansion of MACRO,    counting parens in *DEPTHPTR,    and return if reach LIMIT    or before a `)' that would make *DEPTHPTR negative    or before a comma when *DEPTHPTR is zero.    Single and double quotes are matched and termination    is inhibited within them.  Comments also inhibit it.    Value returned is pointer to stopping place.     Increment *NEWLINES each time a newline is passed.    REST_ARGS notifies macarg1 that it should absorb the rest of the args.    Set *COMMENTS to 1 if a comment is seen.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|macarg1
parameter_list|(
name|start
parameter_list|,
name|limit
parameter_list|,
name|macro
parameter_list|,
name|depthptr
parameter_list|,
name|newlines
parameter_list|,
name|comments
parameter_list|,
name|rest_args
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|struct
name|hashnode
modifier|*
name|macro
decl_stmt|;
name|int
modifier|*
name|depthptr
decl_stmt|,
decl|*
name|newlines
decl_stmt|,
modifier|*
name|comments
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|rest_args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|start
decl_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
literal|'('
case|:
operator|(
operator|*
name|depthptr
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|--
operator|(
operator|*
name|depthptr
operator|)
operator|<
literal|0
condition|)
return|return
name|bp
return|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Traditionally, backslash makes following char not special.  */
if|if
condition|(
name|traditional
operator|&&
name|bp
operator|+
literal|1
operator|<
name|limit
operator|&&
name|bp
index|[
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|bp
operator|++
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
operator|++
operator|*
name|newlines
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|macro
condition|)
break|break;
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
operator|*
name|comments
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|bp
operator|+=
literal|2
init|;
name|bp
operator|<
name|limit
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|warn_comments
condition|)
name|warning
argument_list|(
literal|"`/*' within comment"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|bp
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|bp
argument_list|,
name|limit
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|bp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|cplusplus_comments
condition|)
block|{
operator|*
name|comments
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|bp
operator|+=
literal|2
init|;
name|bp
operator|<
name|limit
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
operator|++
operator|*
name|newlines
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
operator|+
literal|1
operator|<
name|limit
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|++
operator|*
name|newlines
expr_stmt|;
if|if
condition|(
name|warn_comments
condition|)
name|warning
argument_list|(
literal|"multiline `//' comment"
argument_list|)
expr_stmt|;
operator|++
name|bp
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|bp
argument_list|,
name|limit
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|bp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
block|{
name|int
name|quotec
decl_stmt|;
for|for
control|(
name|quotec
operator|=
operator|*
name|bp
operator|++
init|;
name|bp
operator|+
literal|1
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|!=
name|quotec
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
condition|)
block|{
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
if|if
condition|(
operator|!
name|macro
condition|)
block|{
while|while
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
operator|++
operator|*
name|newlines
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
operator|++
operator|*
name|newlines
expr_stmt|;
if|if
condition|(
name|quotec
operator|==
literal|'\''
condition|)
break|break;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|bp
argument_list|,
name|limit
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|bp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
break|break;
case|case
literal|','
case|:
comment|/* if we've returned to lowest level and we aren't absorbing all args */
if|if
condition|(
operator|(
operator|*
name|depthptr
operator|)
operator|==
literal|0
operator|&&
name|rest_args
operator|==
literal|0
condition|)
return|return
name|bp
return|;
break|break;
block|}
name|bp
operator|++
expr_stmt|;
block|}
return|return
name|bp
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Discard comments and duplicate newlines    in the string of length LENGTH at START,    except inside of string constants.    The string is copied into itself with its beginning staying fixed.       NEWLINES is the number of newlines that must be duplicated.    We assume that that much extra space is available past the end    of the string.  */
end_comment

begin_function
specifier|static
name|int
name|discard_comments
parameter_list|(
name|start
parameter_list|,
name|length
parameter_list|,
name|newlines
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|newlines
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* If we have newlines to duplicate, copy everything      that many characters up.  Then, in the second part,      we will have room to insert the newlines      while copying down.      NEWLINES may actually be too large, because it counts      newlines in string constants, and we don't duplicate those.      But that does no harm.  */
if|if
condition|(
name|newlines
operator|>
literal|0
condition|)
block|{
name|ibp
operator|=
name|start
operator|+
name|length
expr_stmt|;
name|obp
operator|=
name|ibp
operator|+
name|newlines
expr_stmt|;
name|limit
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|limit
operator|!=
name|ibp
condition|)
operator|*
operator|--
name|obp
operator|=
operator|*
operator|--
name|ibp
expr_stmt|;
block|}
name|ibp
operator|=
name|start
operator|+
name|newlines
expr_stmt|;
name|limit
operator|=
name|start
operator|+
name|length
operator|+
name|newlines
expr_stmt|;
name|obp
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* Duplicate the newline.  */
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
comment|/* Delete any comment.  */
if|if
condition|(
name|cplusplus_comments
operator|&&
name|ibp
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Comments are equivalent to spaces.  */
name|obp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|ibp
operator|++
expr_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
operator|+
literal|1
operator|<
name|limit
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|ibp
operator|++
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
init|=
name|local_mblen
argument_list|(
name|ibp
argument_list|,
name|limit
operator|-
name|ibp
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|ibp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ibp
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|||
name|ibp
operator|+
literal|1
operator|>=
name|limit
condition|)
break|break;
comment|/* Comments are equivalent to spaces. 	 For -traditional, a comment is equivalent to nothing.  */
if|if
condition|(
name|traditional
condition|)
name|obp
operator|--
expr_stmt|;
else|else
name|obp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|++
name|ibp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|ibp
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
init|=
name|local_mblen
argument_list|(
name|ibp
argument_list|,
name|limit
operator|-
name|ibp
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|ibp
operator|+=
operator|(
name|length
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
comment|/* Notice and skip strings, so that we don't 	 think that comments start inside them, 	 and so we don't duplicate newlines in them.  */
block|{
name|int
name|quotec
init|=
name|c
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quotec
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|quotec
operator|==
literal|'\''
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|ibp
operator|<
name|limit
operator|&&
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
name|ibp
operator|++
expr_stmt|;
name|obp
operator|--
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|ibp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ibp
operator|<
name|limit
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|ibp
operator|--
expr_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|ibp
argument_list|,
name|limit
operator|-
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|bcopy
argument_list|(
name|ibp
argument_list|,
name|obp
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ibp
operator|+=
name|length
expr_stmt|;
name|obp
operator|+=
name|length
expr_stmt|;
block|}
else|else
name|ibp
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
break|break;
block|}
block|}
return|return
name|obp
operator|-
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Turn newlines to spaces in the string of length LENGTH at START,    except inside of string constants.    The string is copied into itself with its beginning staying fixed.  */
end_comment

begin_function
specifier|static
name|int
name|change_newlines
parameter_list|(
name|start
parameter_list|,
name|length
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|ibp
operator|=
name|start
expr_stmt|;
name|limit
operator|=
name|start
operator|+
name|length
expr_stmt|;
name|obp
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* If this is a NEWLINE NEWLINE, then this is a real newline in the 	 string.  Skip past the newline and its duplicate. 	 Put a space in the output.  */
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
name|ibp
operator|++
expr_stmt|;
name|obp
operator|--
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
comment|/* Notice and skip strings, so that we don't delete newlines in them.  */
block|{
name|int
name|quotec
init|=
name|c
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quotec
condition|)
break|break;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|ibp
operator|<
name|limit
operator|&&
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|quotec
operator|==
literal|'\''
condition|)
break|break;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|length
decl_stmt|;
name|ibp
operator|--
expr_stmt|;
name|length
operator|=
name|local_mblen
argument_list|(
name|ibp
argument_list|,
name|limit
operator|-
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|1
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|bcopy
argument_list|(
name|ibp
argument_list|,
name|obp
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ibp
operator|+=
name|length
expr_stmt|;
name|obp
operator|+=
name|length
expr_stmt|;
block|}
else|else
name|ibp
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
break|break;
block|}
block|}
return|return
name|obp
operator|-
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* my_strerror - return the descriptive text associated with an    `errno' code.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|my_strerror
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
ifndef|#
directive|ifndef
name|VMS
ifndef|#
directive|ifndef
name|HAVE_STRERROR
name|result
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|errnum
operator|<
name|sys_nerr
operator|)
condition|?
name|sys_errlist
index|[
name|errnum
index|]
else|:
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* VMS */
comment|/* VAXCRTL's strerror() takes an optional second argument, which only      matters when the first argument is EVMSERR.  However, it's simplest      just to pass it unconditionally.  `vaxc$errno' is declared in<errno.h>, and maintained by the library in parallel with `errno'.      We assume that caller's `errnum' either matches the last setting of      `errno' by the library or else does not have the value `EVMSERR'.  */
name|result
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|,
name|vaxc$errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
literal|"errno = ?"
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* notice - output message to stderr */
end_comment

begin_decl_stmt
specifier|static
name|void
name|notice
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|args
decl_stmt|;
name|VA_START
argument_list|(
name|args
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vnotice
argument_list|(
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|vnotice
parameter_list|(
name|msgid
parameter_list|,
name|args
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* error - print error message and increment count of errors.  */
end_comment

begin_decl_stmt
name|void
name|error
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|args
decl_stmt|;
name|VA_START
argument_list|(
name|args
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|verror
argument_list|(
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|verror
parameter_list|(
name|msgid
parameter_list|,
name|args
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|print_containing_files
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|eprint_string
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|nominal_fname_len
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":%d: "
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
name|vnotice
argument_list|(
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Error including a message from `errno'.  */
end_comment

begin_function
specifier|static
name|void
name|error_from_errno
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|print_containing_files
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|eprint_string
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|nominal_fname_len
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":%d: "
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|name
argument_list|,
name|my_strerror
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print error message but don't count it.  */
end_comment

begin_decl_stmt
name|void
name|warning
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|args
decl_stmt|;
name|VA_START
argument_list|(
name|args
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vwarning
argument_list|(
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|vwarning
parameter_list|(
name|msgid
parameter_list|,
name|args
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|inhibit_warnings
condition|)
return|return;
if|if
condition|(
name|warnings_are_errors
condition|)
name|errors
operator|++
expr_stmt|;
name|print_containing_files
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|eprint_string
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|nominal_fname_len
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":%d: "
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
name|notice
argument_list|(
literal|"warning: "
argument_list|)
expr_stmt|;
name|vnotice
argument_list|(
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|error_with_line
name|VPROTO
argument_list|(
operator|(
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|args
decl_stmt|;
name|VA_START
argument_list|(
name|args
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|line
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|verror_with_line
argument_list|(
name|line
argument_list|,
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|verror_with_line
parameter_list|(
name|line
parameter_list|,
name|msgid
parameter_list|,
name|args
parameter_list|)
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|print_containing_files
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|eprint_string
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|nominal_fname_len
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":%d: "
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|vnotice
argument_list|(
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|warning_with_line
name|VPROTO
argument_list|(
operator|(
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|args
decl_stmt|;
name|VA_START
argument_list|(
name|args
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|line
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vwarning_with_line
argument_list|(
name|line
argument_list|,
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|vwarning_with_line
parameter_list|(
name|line
parameter_list|,
name|msgid
parameter_list|,
name|args
parameter_list|)
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|inhibit_warnings
condition|)
return|return;
if|if
condition|(
name|warnings_are_errors
condition|)
name|errors
operator|++
expr_stmt|;
name|print_containing_files
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|eprint_string
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|nominal_fname_len
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|line
condition|?
literal|":%d: "
else|:
literal|": "
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|notice
argument_list|(
literal|"warning: "
argument_list|)
expr_stmt|;
name|vnotice
argument_list|(
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message and maybe count it.  */
end_comment

begin_decl_stmt
name|void
name|pedwarn
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|args
decl_stmt|;
name|VA_START
argument_list|(
name|args
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pedantic_errors
condition|)
name|verror
argument_list|(
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|vwarning
argument_list|(
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|pedwarn_with_line
name|VPROTO
argument_list|(
operator|(
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|args
decl_stmt|;
name|VA_START
argument_list|(
name|args
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|line
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pedantic_errors
condition|)
name|verror_with_line
argument_list|(
name|line
argument_list|,
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|vwarning_with_line
argument_list|(
name|line
argument_list|,
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a warning (or an error if pedantic_errors)    giving specified file name and line number, not current.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|pedwarn_with_file_and_line
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|size_t
name|file_len
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|size_t
name|file_len
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|pedantic_errors
operator|&&
name|inhibit_warnings
condition|)
return|return;
name|VA_START
argument_list|(
name|args
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|file
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|file_len
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|line
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|file
condition|)
block|{
name|eprint_string
argument_list|(
name|file
argument_list|,
name|file_len
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":%d: "
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic_errors
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|pedantic_errors
condition|)
name|notice
argument_list|(
literal|"warning: "
argument_list|)
expr_stmt|;
name|vnotice
argument_list|(
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|pedwarn_strange_white_space
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\f'
case|:
name|pedwarn
argument_list|(
literal|"formfeed in preprocessing directive"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|pedwarn
argument_list|(
literal|"carriage return in preprocessing directive"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|pedwarn
argument_list|(
literal|"vertical tab in preprocessing directive"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the file names and line numbers of the #include    directives which led to the current file.  */
end_comment

begin_function
specifier|static
name|void
name|print_containing_files
parameter_list|()
block|{
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* If stack of files hasn't changed since we last printed      this info, don't repeat it.  */
if|if
condition|(
name|last_error_tick
operator|==
name|input_file_stack_tick
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
comment|/* Give up if we don't find a source file.  */
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return;
comment|/* Find the other, outer source files.  */
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|notice
argument_list|(
literal|"In file included from "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notice
argument_list|(
literal|",\n                 from "
argument_list|)
expr_stmt|;
block|}
name|eprint_string
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|nominal_fname_len
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":%d"
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
comment|/* Record we have printed the status as of this time.  */
name|last_error_tick
operator|=
name|input_file_stack_tick
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the line at which an error occurred.    The error is not necessarily associated with the current spot    in the input stack, so LINE says where.  LINE will have been    copied from ip->lineno for the current input level.    If the current level is for a file, we return LINE.    But if the current level is not for a file, LINE is meaningless.    In that case, we return the lineno of the innermost file.  */
end_comment

begin_function
specifier|static
name|int
name|line_for_error
parameter_list|(
name|line
parameter_list|)
name|int
name|line
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|line1
init|=
name|line
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
literal|0
condition|)
return|return
name|line1
return|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|line1
operator|=
name|instack
index|[
name|i
index|]
operator|.
name|lineno
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * If OBUF doesn't have NEEDED bytes after OPTR, make it bigger.  *  * As things stand, nothing is ever placed in the output buffer to be  * removed again except when it's KNOWN to be part of an identifier,  * so flushing and moving down everything left, instead of expanding,  * should work ok.  */
end_comment

begin_comment
comment|/* You might think void was cleaner for the return type,    but that would get type mismatch in check_expand in strict ANSI.  */
end_comment

begin_function
specifier|static
name|int
name|grow_outbuf
parameter_list|(
name|obuf
parameter_list|,
name|needed
parameter_list|)
specifier|register
name|FILE_BUF
modifier|*
name|obuf
decl_stmt|;
specifier|register
name|int
name|needed
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|int
name|minsize
decl_stmt|;
if|if
condition|(
name|obuf
operator|->
name|length
operator|-
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
operator|>
name|needed
condition|)
return|return
literal|0
return|;
comment|/* Make it at least twice as big as it is now.  */
name|obuf
operator|->
name|length
operator|*=
literal|2
expr_stmt|;
comment|/* Make it have at least 150% of the free space we will need.  */
name|minsize
operator|=
operator|(
literal|3
operator|*
name|needed
operator|)
operator|/
literal|2
operator|+
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
expr_stmt|;
if|if
condition|(
name|minsize
operator|>
name|obuf
operator|->
name|length
condition|)
name|obuf
operator|->
name|length
operator|=
name|minsize
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|obuf
operator|->
name|buf
argument_list|,
name|obuf
operator|->
name|length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|obuf
operator|->
name|bufp
operator|=
name|p
operator|+
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
expr_stmt|;
name|obuf
operator|->
name|buf
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Symbol table for macro names and special symbols */
end_comment

begin_comment
comment|/*  * install a name in the main hash table, even if it is already there.  *   name stops with first non alphanumeric, except leading '#'.  * caller must check against redefinition if that is desired.  * delete_macro () removes things installed by install () in fifo order.  * this is important because of the `defined' special symbol used  * in #if, and also if pushdef/popdef directives are ever implemented.  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.   */
end_comment

begin_function
specifier|static
name|HASHNODE
modifier|*
name|install
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|,
name|hash
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|bucket
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hash
expr_stmt|;
name|hp
operator|->
name|bucket_hdr
operator|=
operator|&
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hp
operator|->
name|next
operator|=
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hashtab
index|[
name|bucket
index|]
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|cpval
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|name
operator|=
operator|(
operator|(
name|U_CHAR
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|p
operator|=
name|hp
operator|->
name|name
expr_stmt|;
name|q
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
name|hp
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/*  * find the most recent hash node for name "name" (ending with first  * non-identifier char) installed by install  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.  */
end_comment

begin_function
name|HASHNODE
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
specifier|register
name|HASHNODE
modifier|*
name|bucket
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|bp
operator|=
name|name
init|;
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|;
name|bp
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|bp
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hashtab
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|length
operator|==
name|len
operator|&&
name|bcmp
argument_list|(
name|bucket
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bucket
return|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a hash node.  Some weirdness to free junk from macros.  * More such weirdness will have to be added if you define more hash  * types that need it.  */
end_comment

begin_comment
comment|/* Note that the DEFINITION of a macro is removed from the hash table    but its storage is not freed.  This would be a storage leak    except that it is not reasonable to keep undefining and redefining    large numbers of macros many times.    In any case, this is necessary, because a macro can be #undef'd    in the middle of reading the arguments to a call to it.    If #undef freed the DEFINITION, that would crash.  */
end_comment

begin_function
specifier|static
name|void
name|delete_macro
parameter_list|(
name|hp
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
if|if
condition|(
name|hp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|prev
operator|->
name|next
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
operator|->
name|prev
expr_stmt|;
comment|/* Make sure that the bucket chain header that the deleted guy was      on points to the right thing afterwards.  */
if|if
condition|(
name|hp
operator|==
operator|*
name|hp
operator|->
name|bucket_hdr
condition|)
operator|*
name|hp
operator|->
name|bucket_hdr
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|#
directive|if
literal|0
block|if (hp->type == T_MACRO) {     DEFINITION *d = hp->value.defn;     struct reflist *ap, *nextap;      for (ap = d->pattern; ap != NULL; ap = nextap) {       nextap = ap->next;       free (ap);     }     free (d);   }
endif|#
directive|endif
name|free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return hash function on name.  must be compatible with the one  * computed a step at a time, elsewhere  */
end_comment

begin_function
specifier|static
name|int
name|hashf
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hashsize
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|hashsize
decl_stmt|;
block|{
specifier|register
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|r
operator|=
name|HASHSTEP
argument_list|(
name|r
argument_list|,
operator|*
name|name
operator|++
argument_list|)
expr_stmt|;
return|return
name|MAKE_POS
argument_list|(
name|r
argument_list|)
operator|%
name|hashsize
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dump the definition of a single macro HP to OF.  */
end_comment

begin_function
specifier|static
name|void
name|dump_single_macro
parameter_list|(
name|hp
parameter_list|,
name|of
parameter_list|)
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|FILE
modifier|*
name|of
decl_stmt|;
block|{
specifier|register
name|DEFINITION
modifier|*
name|defn
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|concat
decl_stmt|;
comment|/* Print the definition of the macro HP.  */
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"#define %s"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|defn
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|dump_arg_n
argument_list|(
name|defn
argument_list|,
name|i
argument_list|,
name|of
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|defn
operator|->
name|nargs
condition|)
name|fprintf
argument_list|(
name|of
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|of
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|of
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|concat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
name|dump_defn_1
argument_list|(
name|defn
operator|->
name|expansion
argument_list|,
name|offset
argument_list|,
name|ap
operator|->
name|nchars
argument_list|,
name|of
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ap
operator|->
name|nchars
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|nchars
operator|!=
literal|0
condition|)
name|concat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|stringify
condition|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|stringify
condition|)
block|{
case|case
name|SHARP_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"#"
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHITE_SHARP_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"# "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PERCENT_COLON_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"%%:"
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHITE_PERCENT_COLON_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"%%: "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|concat
condition|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|raw_before
condition|)
block|{
case|case
name|WHITE_SHARP_TOKEN
case|:
case|case
name|WHITE_PERCENT_COLON_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|ap
operator|->
name|raw_before
condition|)
block|{
case|case
name|SHARP_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"##"
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHITE_SHARP_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"## "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PERCENT_COLON_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"%%:%%:"
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHITE_PERCENT_COLON_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"%%:%%: "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|concat
operator|=
literal|0
expr_stmt|;
block|}
name|dump_arg_n
argument_list|(
name|defn
argument_list|,
name|ap
operator|->
name|argno
argument_list|,
name|of
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
operator|&&
name|ap
operator|->
name|raw_after
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|raw_after
condition|)
block|{
case|case
name|SHARP_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"##"
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHITE_SHARP_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|" ##"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PERCENT_COLON_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"%%:%%:"
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHITE_PERCENT_COLON_TOKEN
case|:
name|fprintf
argument_list|(
name|of
argument_list|,
literal|" %%:%%:"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|concat
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|dump_defn_1
argument_list|(
name|defn
operator|->
name|expansion
argument_list|,
name|offset
argument_list|,
name|defn
operator|->
name|length
operator|-
name|offset
argument_list|,
name|of
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump all macro definitions as #defines to stdout.  */
end_comment

begin_function
specifier|static
name|void
name|dump_all_macros
parameter_list|()
block|{
name|int
name|bucket
decl_stmt|;
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|HASHSIZE
condition|;
name|bucket
operator|++
control|)
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|hashtab
index|[
name|bucket
index|]
init|;
name|hp
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
name|dump_single_macro
argument_list|(
name|hp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output to OF a substring of a macro definition.    BASE is the beginning of the definition.    Output characters START thru LENGTH.    Unless traditional, discard newlines outside of strings, thus    converting funny-space markers to ordinary spaces.  */
end_comment

begin_function
specifier|static
name|void
name|dump_defn_1
parameter_list|(
name|base
parameter_list|,
name|start
parameter_list|,
name|length
parameter_list|,
name|of
parameter_list|)
name|U_CHAR
modifier|*
name|base
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
name|FILE
modifier|*
name|of
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|base
operator|+
name|start
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
init|=
name|base
operator|+
name|start
operator|+
name|length
decl_stmt|;
if|if
condition|(
name|traditional
condition|)
name|fwrite
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|length
argument_list|,
name|of
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\"'
operator|||
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
name|U_CHAR
modifier|*
name|p1
init|=
name|skip_quoted_string
argument_list|(
name|p
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
name|fwrite
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|p1
operator|-
name|p
argument_list|,
name|of
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|of
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print the name of argument number ARGNUM of macro definition DEFN    to OF.    Recall that DEFN->args.argnames contains all the arg names    concatenated in reverse order with comma-space in between.  */
end_comment

begin_function
specifier|static
name|void
name|dump_arg_n
parameter_list|(
name|defn
parameter_list|,
name|argnum
parameter_list|,
name|of
parameter_list|)
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|FILE
modifier|*
name|of
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|defn
operator|->
name|args
operator|.
name|argnames
decl_stmt|;
while|while
condition|(
name|argnum
operator|+
literal|1
operator|<
name|defn
operator|->
name|nargs
condition|)
block|{
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|index
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|argnum
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|of
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize syntactic classifications of characters.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_char_syntax
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/*    * Set up is_idchar and is_idstart tables.  These should be    * faster than saying (is_alpha (c) || c == '_'), etc.    * Set up these things before calling any routines tthat    * refer to them.    */
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
block|{
name|is_idchar
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
name|is_idchar
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'_'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'_'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'$'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'$'
index|]
operator|=
literal|1
expr_stmt|;
comment|/* horizontal space table */
name|is_hor_space
index|[
literal|' '
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\r'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|' '
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\n'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\r'
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the built-in macros.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_builtins
parameter_list|(
name|inp
parameter_list|,
name|outp
parameter_list|)
name|FILE_BUF
modifier|*
name|inp
decl_stmt|;
name|FILE_BUF
modifier|*
name|outp
decl_stmt|;
block|{
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__LINE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SPECLINE
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__DATE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_DATE
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__FILE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_FILE
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__BASE_FILE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_BASE_FILE
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__INCLUDE_LEVEL__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_INCLUDE_LEVEL
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__VERSION__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_VERSION
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__SIZE_TYPE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SIZE_TYPE
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__PTRDIFF_TYPE__ "
argument_list|,
operator|-
literal|1
argument_list|,
name|T_PTRDIFF_TYPE
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__WCHAR_TYPE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_WCHAR_TYPE
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__USER_LABEL_PREFIX__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_USER_LABEL_PREFIX_TYPE
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__REGISTER_PREFIX__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_REGISTER_PREFIX_TYPE
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__IMMEDIATE_PREFIX__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_IMMEDIATE_PREFIX_TYPE
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__TIME__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_TIME
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__STDC__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_CONST
argument_list|,
literal|"1"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__STDC_VERSION__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_CONST
argument_list|,
literal|"199409L"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  This is supplied using a -D by the compiler driver     so that it is present only when truly compiling with GNU C.  */
comment|/*  install ((U_CHAR *) "__GNUC__", -1, T_CONST, "2", -1);  */
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__HAVE_BUILTIN_SETJMP__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_CONST
argument_list|,
literal|"1"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_output
condition|)
block|{
name|char
name|directive
index|[
literal|2048
index|]
decl_stmt|;
name|U_CHAR
modifier|*
name|udirective
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|directive
decl_stmt|;
specifier|register
name|struct
name|directive
modifier|*
name|dp
init|=
operator|&
name|directive_table
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|timebuf
init|=
name|timestamp
argument_list|()
decl_stmt|;
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __BASE_FILE__ \"%s\"\n"
argument_list|,
name|instack
index|[
literal|0
index|]
operator|.
name|nominal_fname
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|udirective
argument_list|,
operator|&
name|udirective
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __VERSION__ \"%s\"\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|udirective
argument_list|,
operator|&
name|udirective
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __SIZE_TYPE__ %s\n"
argument_list|,
name|SIZE_TYPE
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|udirective
argument_list|,
operator|&
name|udirective
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __PTRDIFF_TYPE__ %s\n"
argument_list|,
name|PTRDIFF_TYPE
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|udirective
argument_list|,
operator|&
name|udirective
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __WCHAR_TYPE__ %s\n"
argument_list|,
name|wchar_type
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|udirective
argument_list|,
operator|&
name|udirective
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __DATE__ \"%s %2d %4d\"\n"
argument_list|,
name|monthnames
index|[
name|timebuf
operator|->
name|tm_mon
index|]
argument_list|,
name|timebuf
operator|->
name|tm_mday
argument_list|,
name|timebuf
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|udirective
argument_list|,
operator|&
name|udirective
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __TIME__ \"%02d:%02d:%02d\"\n"
argument_list|,
name|timebuf
operator|->
name|tm_hour
argument_list|,
name|timebuf
operator|->
name|tm_min
argument_list|,
name|timebuf
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|udirective
argument_list|,
operator|&
name|udirective
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __STDC__ 1"
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|udirective
argument_list|,
operator|&
name|udirective
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objc
condition|)
block|{
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __OBJC__ 1"
argument_list|)
expr_stmt|;
name|output_line_directive
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|udirective
argument_list|,
operator|&
name|udirective
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * process a given definition string, for initialization  * If STR is just an identifier, define it with value 1.  * If STR has anything after the identifier, then it should  * be identifier=definition.  */
end_comment

begin_function
specifier|static
name|void
name|make_definition
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|p
index|]
condition|)
block|{
name|error
argument_list|(
literal|"malformed option `-D %s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|is_idchar
index|[
operator|*
operator|++
name|p
index|]
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
while|while
condition|(
name|is_idchar
index|[
operator|*
operator|++
name|p
index|]
operator|||
operator|*
name|p
operator|==
literal|','
operator|||
name|is_hor_space
index|[
operator|*
name|p
index|]
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|')'
condition|)
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|str
expr_stmt|;
comment|/* Error */
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|" 1"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|!=
literal|'='
condition|)
block|{
name|error
argument_list|(
literal|"malformed option `-D %s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|U_CHAR
modifier|*
name|q
decl_stmt|;
comment|/* Copy the entire option so we can modify it.  */
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
literal|2
operator|*
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|str
argument_list|,
name|p
operator|-
operator|(
name|U_CHAR
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
comment|/* Change the = to a space.  */
name|buf
index|[
name|p
operator|-
operator|(
name|U_CHAR
operator|*
operator|)
name|str
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Scan for any backslash-newline and remove it.  */
name|p
operator|++
expr_stmt|;
name|q
operator|=
operator|&
name|buf
index|[
name|p
operator|-
operator|(
name|U_CHAR
operator|*
operator|)
name|str
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\"'
operator|||
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
name|int
name|unterminated
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|p1
init|=
name|skip_quoted_string
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
operator|&
name|unterminated
argument_list|)
decl_stmt|;
if|if
condition|(
name|unterminated
condition|)
return|return;
while|while
condition|(
name|p
operator|!=
name|p1
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Change newline chars into newline-markers.  */
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
block|}
name|ip
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
name|ip
operator|->
name|fname
operator|=
literal|"*Initialization*"
expr_stmt|;
name|ip
operator|->
name|nominal_fname_len
operator|=
name|strlen
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|)
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|buf
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|type
operator|!=
name|T_DEFINE
condition|;
name|kt
operator|++
control|)
empty_stmt|;
comment|/* Pass NULL instead of OP, since this is a "predefined" macro.  */
name|do_define
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|kt
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* JF, this does the work for the -U option */
end_comment

begin_function
specifier|static
name|void
name|make_undef
parameter_list|(
name|str
parameter_list|,
name|op
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
name|ip
operator|->
name|fname
operator|=
literal|"*undef*"
expr_stmt|;
name|ip
operator|->
name|nominal_fname_len
operator|=
name|strlen
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|)
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|str
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|type
operator|!=
name|T_UNDEF
condition|;
name|kt
operator|++
control|)
empty_stmt|;
name|do_undef
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
name|str
argument_list|,
operator|(
name|U_CHAR
operator|*
operator|)
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|op
argument_list|,
name|kt
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the string STR as if it appeared as the body of a #assert.    OPTION is the option name for which STR was the argument.  */
end_comment

begin_function
specifier|static
name|void
name|make_assertion
parameter_list|(
name|option
parameter_list|,
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|option
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Copy the entire option so we can modify it.  */
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Scan for any backslash-newline and remove it.  */
name|p
operator|=
name|q
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|p
index|]
condition|)
block|{
name|error
argument_list|(
literal|"malformed option `%s %s'"
argument_list|,
name|option
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|is_idchar
index|[
operator|*
operator|++
name|p
index|]
condition|)
empty_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'('
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"malformed option `%s %s'"
argument_list|,
name|option
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
name|ip
operator|->
name|fname
operator|=
literal|"*Initialization*"
expr_stmt|;
name|ip
operator|->
name|nominal_fname_len
operator|=
name|strlen
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|)
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|buf
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|type
operator|!=
name|T_ASSERT
condition|;
name|kt
operator|++
control|)
empty_stmt|;
comment|/* Pass NULL as output ptr to do_define since we KNOW it never does      any output....  */
name|do_assert
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|kt
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The previous include prefix, if any, is PREV_FILE_NAME.    Translate any pathnames with COMPONENT.    Allocate a new include prefix whose name is the    simplified concatenation of PREFIX and NAME,    with a trailing / added if needed.    But return 0 if the include prefix should be ignored,    e.g. because it is a duplicate of PREV_FILE_NAME.  */
end_comment

begin_function
specifier|static
name|struct
name|file_name_list
modifier|*
name|new_include_prefix
parameter_list|(
name|prev_file_name
parameter_list|,
name|component
parameter_list|,
name|prefix
parameter_list|,
name|name
parameter_list|)
name|struct
name|file_name_list
modifier|*
name|prev_file_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|component
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"Directory name missing after command line option"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|0
condition|)
comment|/* Ignore the empty string.  */
return|return
literal|0
return|;
name|prefix
operator|=
name|update_path
argument_list|(
name|prefix
argument_list|,
name|component
argument_list|)
expr_stmt|;
name|name
operator|=
name|update_path
argument_list|(
name|name
argument_list|,
name|component
argument_list|)
expr_stmt|;
block|{
name|struct
name|file_name_list
modifier|*
name|dir
init|=
operator|(
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
operator|)
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|strcpy
argument_list|(
name|dir
operator|->
name|fname
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir
operator|->
name|fname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|simplify_filename
argument_list|(
name|dir
operator|->
name|fname
argument_list|)
expr_stmt|;
comment|/* Convert directory name to a prefix.  */
if|if
condition|(
name|len
operator|&&
name|dir
operator|->
name|fname
index|[
name|len
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|dir
operator|->
name|fname
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|len
operator|=
literal|0
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|VMS
comment|/* must be '/', hack_vms_include_specification triggers on it.  */
name|dir
operator|->
name|fname
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
else|#
directive|else
name|dir
operator|->
name|fname
index|[
name|len
operator|++
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
endif|#
directive|endif
name|dir
operator|->
name|fname
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ignore a directory whose name matches the previous one.  */
if|if
condition|(
name|prev_file_name
operator|&&
operator|!
name|strcmp
argument_list|(
name|prev_file_name
operator|->
name|fname
argument_list|,
name|dir
operator|->
name|fname
argument_list|)
condition|)
block|{
comment|/* But treat `-Idir -I- -Idir' as `-I- -Idir'.  */
if|if
condition|(
operator|!
name|first_bracket_include
condition|)
name|first_bracket_include
operator|=
name|prev_file_name
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|VMS
comment|/* VMS can't stat dir prefixes, so skip these optimizations in VMS.  */
comment|/* Add a trailing "." if there is a filename.  This increases the number        of systems that can stat directories.  We remove it below.  */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|dir
operator|->
name|fname
index|[
name|len
index|]
operator|=
literal|'.'
expr_stmt|;
name|dir
operator|->
name|fname
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ignore a nonexistent directory.  */
if|if
condition|(
name|stat
argument_list|(
name|len
condition|?
name|dir
operator|->
name|fname
else|:
literal|"."
argument_list|,
operator|&
name|dir
operator|->
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|&&
name|errno
operator|!=
name|ENOTDIR
condition|)
name|error_from_errno
argument_list|(
name|dir
operator|->
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|dir
operator|->
name|fname
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Ignore a directory whose identity matches the previous one.  */
if|if
condition|(
name|prev_file_name
operator|&&
name|INO_T_EQ
argument_list|(
name|prev_file_name
operator|->
name|st
operator|.
name|st_ino
argument_list|,
name|dir
operator|->
name|st
operator|.
name|st_ino
argument_list|)
operator|&&
name|prev_file_name
operator|->
name|st
operator|.
name|st_dev
operator|==
name|dir
operator|->
name|st
operator|.
name|st_dev
condition|)
block|{
comment|/* But treat `-Idir -I- -Idir' as `-I- -Idir'.  */
if|if
condition|(
operator|!
name|first_bracket_include
condition|)
name|first_bracket_include
operator|=
name|prev_file_name
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* ! VMS */
name|dir
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|dir
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
name|dir
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
return|return
name|dir
return|;
block|}
block|}
end_function

begin_comment
comment|/* Append a chain of `struct file_name_list's    to the end of the main include chain.    FIRST is the beginning of the chain to append, and LAST is the end.  */
end_comment

begin_function
specifier|static
name|void
name|append_include_chain
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|struct
name|file_name_list
modifier|*
name|first
decl_stmt|,
decl|*
name|last
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|file_name_list
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|first
operator|||
operator|!
name|last
condition|)
return|return;
if|if
condition|(
name|include
operator|==
literal|0
condition|)
name|include
operator|=
name|first
expr_stmt|;
else|else
name|last_include
operator|->
name|next
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|first_bracket_include
operator|==
literal|0
condition|)
name|first_bracket_include
operator|=
name|first
expr_stmt|;
for|for
control|(
name|dir
operator|=
name|first
init|;
condition|;
name|dir
operator|=
name|dir
operator|->
name|next
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|dir
operator|->
name|fname
argument_list|)
operator|+
name|INCLUDE_LEN_FUDGE
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|last
condition|)
break|break;
block|}
name|last
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|last_include
operator|=
name|last
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Place into DST a representation of the file named SRC that is suitable    for `make'.  Do not null-terminate DST.  Return its length.  */
end_comment

begin_function
specifier|static
name|int
name|quote_string_for_make
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|src
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
block|{
comment|/* GNU make uses a weird quoting scheme for white space. 	       A space or tab preceded by 2N+1 backslashes represents 	       N backslashes followed by space; a space or tab 	       preceded by 2N backslashes represents N backslashes at 	       the end of a file name; and backslashes in other 	       contexts should not be doubled.  */
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|-
literal|1
init|;
name|src
operator|<
name|q
operator|&&
name|q
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|;
name|q
operator|--
control|)
block|{
if|if
condition|(
name|dst
condition|)
name|dst
index|[
name|i
index|]
operator|=
literal|'\\'
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|i
return|;
if|if
condition|(
name|dst
condition|)
name|dst
index|[
name|i
index|]
operator|=
literal|'\\'
expr_stmt|;
name|i
operator|++
expr_stmt|;
goto|goto
name|ordinary_char
goto|;
case|case
literal|'$'
case|:
if|if
condition|(
name|dst
condition|)
name|dst
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* Fall through.  This can mishandle things like "$(" but 	     there's no easy fix.  */
default|default:
name|ordinary_char
label|:
comment|/* This can mishandle characters in the string "\0\n%*?[\\~"; 	     exactly which chars are mishandled depends on the `make' version. 	     We know of no portable solution for this; 	     even GNU make 3.76.1 doesn't solve the problem entirely. 	     (Also, '\0' is mishandled due to our calling conventions.)  */
if|if
condition|(
name|dst
condition|)
name|dst
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add output to `deps_buffer' for the -M switch.    STRING points to the text to be output.    SPACER is ':' for targets, ' ' for dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|deps_output
parameter_list|(
name|string
parameter_list|,
name|spacer
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|spacer
decl_stmt|;
block|{
name|int
name|size
init|=
name|quote_string_for_make
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
ifndef|#
directive|ifndef
name|MAX_OUTPUT_COLUMNS
define|#
directive|define
name|MAX_OUTPUT_COLUMNS
value|72
endif|#
directive|endif
if|if
condition|(
name|MAX_OUTPUT_COLUMNS
operator|-
literal|1
comment|/*spacer*/
operator|-
literal|2
comment|/*` \'*/
operator|<
name|deps_column
operator|+
name|size
operator|&&
literal|1
operator|<
name|deps_column
condition|)
block|{
name|bcopy
argument_list|(
literal|" \\\n "
argument_list|,
operator|&
name|deps_buffer
index|[
name|deps_size
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|deps_size
operator|+=
literal|4
expr_stmt|;
name|deps_column
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|spacer
operator|==
literal|' '
condition|)
name|spacer
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|deps_size
operator|+
literal|2
operator|*
name|size
operator|+
literal|8
operator|>
name|deps_allocated_size
condition|)
block|{
name|deps_allocated_size
operator|=
operator|(
name|deps_size
operator|+
literal|2
operator|*
name|size
operator|+
literal|50
operator|)
operator|*
literal|2
expr_stmt|;
name|deps_buffer
operator|=
name|xrealloc
argument_list|(
name|deps_buffer
argument_list|,
name|deps_allocated_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spacer
operator|==
literal|' '
condition|)
block|{
name|deps_buffer
index|[
name|deps_size
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|deps_column
operator|++
expr_stmt|;
block|}
name|quote_string_for_make
argument_list|(
operator|&
name|deps_buffer
index|[
name|deps_size
index|]
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|deps_size
operator|+=
name|size
expr_stmt|;
name|deps_column
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|spacer
operator|==
literal|':'
condition|)
block|{
name|deps_buffer
index|[
name|deps_size
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|deps_column
operator|++
expr_stmt|;
block|}
name|deps_buffer
index|[
name|deps_size
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|args
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|VA_START
argument_list|(
name|args
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vnotice
argument_list|(
name|msgid
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|perror_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|,
name|my_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|exit
argument_list|(
name|vaxc$errno
argument_list|)
expr_stmt|;
else|#
directive|else
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Handler for SIGPIPE.  */
end_comment

begin_function
specifier|static
name|void
name|pipe_closed
parameter_list|(
name|signo
parameter_list|)
comment|/* If this is missing, some compilers complain.  */
name|int
name|signo
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"output pipe has been closed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|memory_full
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Memory exhausted."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|ptr
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|memory_full
argument_list|()
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|PTR
name|old
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|ptr
decl_stmt|;
if|if
condition|(
name|old
condition|)
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|memory_full
argument_list|()
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|PTR
name|xcalloc
parameter_list|(
name|number
parameter_list|,
name|size
parameter_list|)
name|size_t
name|number
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|size_t
name|total
init|=
name|number
operator|*
name|size
decl_stmt|;
specifier|register
name|PTR
name|ptr
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|ptr
argument_list|,
name|total
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xstrdup
parameter_list|(
name|input
parameter_list|)
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
block|{
specifier|register
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|input
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|output
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|output
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* Under VMS we need to fix up the "include" specification filename.     Rules for possible conversions  	fullname		tried paths  	name			name 	./dir/name		[.dir]name 	/dir/name		dir:name 	/name			[000000]name, name 	dir/name		dir:[000000]name, dir:name, dir/name 	dir1/dir2/name		dir1:[dir2]name, dir1:[000000.dir2]name 	path:/name		path:[000000]name, path:name 	path:/dir/name		path:[000000.dir]name, path:[dir]name 	path:dir/name		path:[dir]name 	[path]:[dir]name	[path.dir]name 	path/[dir]name		[path.dir]name     The path:/name input is constructed when expanding<> includes.     return 1 if name was changed, 0 else.  */
end_comment

begin_function
specifier|static
name|int
name|hack_vms_include_specification
parameter_list|(
name|fullname
parameter_list|,
name|vaxc_include
parameter_list|)
name|char
modifier|*
name|fullname
decl_stmt|;
name|int
name|vaxc_include
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|basename
decl_stmt|,
modifier|*
name|unixname
decl_stmt|,
modifier|*
name|local_ptr
decl_stmt|,
modifier|*
name|first_slash
decl_stmt|;
name|int
name|f
decl_stmt|,
name|check_filename_before_returning
decl_stmt|,
name|must_revert
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
name|check_filename_before_returning
operator|=
literal|0
expr_stmt|;
name|must_revert
operator|=
literal|0
expr_stmt|;
comment|/* See if we can find a 1st slash. If not, there's no path information.  */
name|first_slash
operator|=
name|index
argument_list|(
name|fullname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_slash
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Nothing to do!!! */
comment|/* construct device spec if none given.  */
if|if
condition|(
name|index
argument_list|(
name|fullname
argument_list|,
literal|':'
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If fullname has a slash, take it as device spec.  */
if|if
condition|(
name|first_slash
operator|==
name|fullname
condition|)
block|{
name|first_slash
operator|=
name|index
argument_list|(
name|fullname
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* 2nd slash ? */
if|if
condition|(
name|first_slash
condition|)
operator|*
name|first_slash
operator|=
literal|':'
expr_stmt|;
comment|/* make device spec  */
for|for
control|(
name|basename
operator|=
name|fullname
init|;
operator|*
name|basename
operator|!=
literal|0
condition|;
name|basename
operator|++
control|)
operator|*
name|basename
operator|=
operator|*
operator|(
name|basename
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* remove leading slash  */
block|}
elseif|else
if|if
condition|(
operator|(
name|first_slash
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|)
comment|/* keep ':/', './' */
operator|&&
operator|(
name|first_slash
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
operator|)
operator|&&
operator|(
name|first_slash
index|[
operator|-
literal|1
index|]
operator|!=
literal|']'
operator|)
condition|)
comment|/* or a vms path  */
block|{
operator|*
name|first_slash
operator|=
literal|':'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|first_slash
index|[
literal|1
index|]
operator|==
literal|'['
operator|)
comment|/* skip './' in './[dir'  */
operator|&&
operator|(
name|first_slash
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
name|fullname
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Get part after first ':' (basename[-1] == ':')      or last '/' (basename[-1] == '/').  */
name|basename
operator|=
name|base_name
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
comment|/*    * Check if we have a vax-c style '#include filename'    * and add the missing .h    */
if|if
condition|(
name|vaxc_include
operator|&&
operator|!
name|index
argument_list|(
name|basename
argument_list|,
literal|'.'
argument_list|)
condition|)
name|strcat
argument_list|(
name|basename
argument_list|,
literal|".h"
argument_list|)
expr_stmt|;
name|local_ptr
operator|=
name|Local
expr_stmt|;
comment|/* initialize */
comment|/* We are trying to do a number of things here.  First of all, we are      trying to hammer the filenames into a standard format, such that later      processing can handle them.            If the file name contains something like [dir.], then it recognizes this      as a root, and strips the ".]".  Later processing will add whatever is      needed to get things working properly.            If no device is specified, then the first directory name is taken to be      a device name (or a rooted logical).  */
comment|/* Point to the UNIX filename part (which needs to be fixed!)      but skip vms path information.      [basename != fullname since first_slash != 0].  */
if|if
condition|(
operator|(
name|basename
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|)
comment|/* vms path spec.  */
operator|||
operator|(
name|basename
index|[
operator|-
literal|1
index|]
operator|==
literal|']'
operator|)
operator|||
operator|(
name|basename
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
operator|)
condition|)
name|unixname
operator|=
name|basename
expr_stmt|;
else|else
name|unixname
operator|=
name|fullname
expr_stmt|;
if|if
condition|(
operator|*
name|unixname
operator|==
literal|'/'
condition|)
name|unixname
operator|++
expr_stmt|;
comment|/* If the directory spec is not rooted, we can just copy      the UNIX filename part and we are done.  */
if|if
condition|(
operator|(
operator|(
name|basename
operator|-
name|fullname
operator|)
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|basename
index|[
operator|-
literal|1
index|]
operator|==
literal|']'
operator|)
operator|||
operator|(
name|basename
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|basename
index|[
operator|-
literal|2
index|]
operator|!=
literal|'.'
condition|)
block|{
comment|/* The VMS part ends in a `]', and the preceding character is not a `.'. 	   -> PATH]:/name (basename = '/name', unixname = 'name') 	   We strip the `]', and then splice the two parts of the name in the 	   usual way.  Given the default locations for include files in cccp.c, 	   we will only use this code if the user specifies alternate locations 	   with the /include (-I) switch on the command line.  */
name|basename
operator|-=
literal|1
expr_stmt|;
comment|/* Strip "]" */
name|unixname
operator|--
expr_stmt|;
comment|/* backspace */
block|}
else|else
block|{
comment|/* The VMS part has a ".]" at the end, and this will not do.  Later 	   processing will add a second directory spec, and this would be a syntax 	   error.  Thus we strip the ".]", and thus merge the directory specs. 	   We also backspace unixname, so that it points to a '/'.  This inhibits the 	   generation of the 000000 root directory spec (which does not belong here 	   in this case).  */
name|basename
operator|-=
literal|2
expr_stmt|;
comment|/* Strip ".]" */
name|unixname
operator|--
expr_stmt|;
comment|/* backspace */
block|}
block|}
else|else
block|{
comment|/* We drop in here if there is no VMS style directory specification yet.          If there is no device specification either, we make the first dir a          device and try that.  If we do not do this, then we will be essentially          searching the users default directory (as if they did a #include "asdf.h").                   Then all we need to do is to push a '[' into the output string. Later          processing will fill this in, and close the bracket.  */
if|if
condition|(
operator|(
name|unixname
operator|!=
name|fullname
operator|)
comment|/* vms path spec found.  */
operator|&&
operator|(
name|basename
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
operator|)
condition|)
operator|*
name|local_ptr
operator|++
operator|=
literal|':'
expr_stmt|;
comment|/* dev not in spec.  take first dir */
operator|*
name|local_ptr
operator|++
operator|=
literal|'['
expr_stmt|;
comment|/* Open the directory specification */
block|}
if|if
condition|(
name|unixname
operator|==
name|fullname
condition|)
comment|/* no vms dir spec.  */
block|{
name|must_revert
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|first_slash
operator|!=
literal|0
operator|)
comment|/* unix dir spec.  */
operator|&&
operator|(
operator|*
name|unixname
operator|!=
literal|'/'
operator|)
comment|/* not beginning with '/'  */
operator|&&
operator|(
operator|*
name|unixname
operator|!=
literal|'.'
operator|)
condition|)
comment|/* or './' or '../'  */
operator|*
name|local_ptr
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* dir is local !  */
block|}
comment|/* at this point we assume that we have the device spec, and (at least      the opening "[" for a directory specification.  We may have directories      specified already.       If there are no other slashes then the filename will be      in the "root" directory.  Otherwise, we need to add      directory specifications.  */
if|if
condition|(
name|index
argument_list|(
name|unixname
argument_list|,
literal|'/'
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* if no directories specified yet and none are following.  */
if|if
condition|(
name|local_ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
comment|/* Just add "000000]" as the directory string */
name|strcpy
argument_list|(
name|local_ptr
argument_list|,
literal|"000000]"
argument_list|)
expr_stmt|;
name|local_ptr
operator|+=
name|strlen
argument_list|(
name|local_ptr
argument_list|)
expr_stmt|;
name|check_filename_before_returning
operator|=
literal|1
expr_stmt|;
comment|/* we might need to fool with this later */
block|}
block|}
else|else
block|{
comment|/* As long as there are still subdirectories to add, do them.  */
while|while
condition|(
name|index
argument_list|(
name|unixname
argument_list|,
literal|'/'
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* If this token is "." we can ignore it 	       if it's not at the beginning of a path.  */
if|if
condition|(
operator|(
name|unixname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|unixname
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
comment|/* remove it at beginning of path.  */
if|if
condition|(
operator|(
operator|(
name|unixname
operator|==
name|fullname
operator|)
comment|/* no device spec  */
operator|&&
operator|(
name|fullname
operator|+
literal|2
operator|!=
name|basename
operator|)
operator|)
comment|/* starts with ./ */
comment|/* or  */
operator|||
operator|(
operator|(
name|basename
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|)
comment|/* device spec  */
operator|&&
operator|(
name|unixname
operator|-
literal|1
operator|==
name|basename
operator|)
operator|)
condition|)
comment|/* and ./ afterwards  */
operator|*
name|local_ptr
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* make '[.' start of path.  */
name|unixname
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
comment|/* Add a subdirectory spec. Do not duplicate "." */
if|if
condition|(
name|local_ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|&&
name|local_ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'['
operator|&&
name|local_ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'<'
condition|)
operator|*
name|local_ptr
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* If this is ".." then the spec becomes "-" */
if|if
condition|(
operator|(
name|unixname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|unixname
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|unixname
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
comment|/* Add "-" and skip the ".." */
if|if
condition|(
operator|(
name|local_ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|local_ptr
index|[
operator|-
literal|2
index|]
operator|==
literal|'['
operator|)
condition|)
name|local_ptr
operator|--
expr_stmt|;
comment|/* prevent [.-  */
operator|*
name|local_ptr
operator|++
operator|=
literal|'-'
expr_stmt|;
name|unixname
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
comment|/* Copy the subdirectory */
while|while
condition|(
operator|*
name|unixname
operator|!=
literal|'/'
condition|)
operator|*
name|local_ptr
operator|++
operator|=
operator|*
name|unixname
operator|++
expr_stmt|;
name|unixname
operator|++
expr_stmt|;
comment|/* Skip the "/" */
block|}
comment|/* Close the directory specification */
if|if
condition|(
name|local_ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
comment|/* no trailing periods */
name|local_ptr
operator|--
expr_stmt|;
if|if
condition|(
name|local_ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'['
condition|)
comment|/* no dir needed */
name|local_ptr
operator|--
expr_stmt|;
else|else
operator|*
name|local_ptr
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
comment|/* Now add the filename.  */
while|while
condition|(
operator|*
name|unixname
condition|)
operator|*
name|local_ptr
operator|++
operator|=
operator|*
name|unixname
operator|++
expr_stmt|;
operator|*
name|local_ptr
operator|=
literal|0
expr_stmt|;
comment|/* Now append it to the original VMS spec.  */
name|strcpy
argument_list|(
operator|(
name|must_revert
operator|==
literal|1
operator|)
condition|?
name|fullname
else|:
name|basename
argument_list|,
name|Local
argument_list|)
expr_stmt|;
comment|/* If we put a [000000] in the filename, try to open it first. If this fails,      remove the [000000], and return that name.  This provides flexibility      to the user in that they can use both rooted and non-rooted logical names      to point to the location of the file.  */
if|if
condition|(
name|check_filename_before_returning
condition|)
block|{
name|f
operator|=
name|open
argument_list|(
name|fullname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
comment|/* The file name is OK as it is, so return it as is.  */
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* The filename did not work.  Try to remove the [000000] from the name, 	 and return it.  */
name|basename
operator|=
name|index
argument_list|(
name|fullname
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
name|local_ptr
operator|=
name|index
argument_list|(
name|fullname
argument_list|,
literal|']'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|basename
argument_list|,
name|local_ptr
argument_list|)
expr_stmt|;
comment|/* this gets rid of it */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* The following wrapper functions supply additional arguments to the VMS    I/O routines to optimize performance with file handling.  The arguments    are:      "mbc=16" - Set multi-block count to 16 (use a 8192 byte buffer).      "deq=64" - When extending the file, extend it in chunks of 32Kbytes.      "fop=tef"- Truncate unused portions of file when closing file.      "shr=nil"- Disallow file sharing while file is open.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|VMS_freopen
parameter_list|(
name|fname
parameter_list|,
name|type
parameter_list|,
name|oldfile
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|FILE
modifier|*
name|oldfile
decl_stmt|;
block|{
undef|#
directive|undef
name|freopen
comment|/* Get back the real freopen routine.  */
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"w"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|freopen
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
name|oldfile
argument_list|,
literal|"mbc=16"
argument_list|,
literal|"deq=64"
argument_list|,
literal|"fop=tef"
argument_list|,
literal|"shr=nil"
argument_list|)
return|;
return|return
name|freopen
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
name|oldfile
argument_list|,
literal|"mbc=16"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|VMS_fopen
parameter_list|(
name|fname
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
block|{
undef|#
directive|undef
name|fopen
comment|/* Get back the real fopen routine.  */
comment|/* The gcc-vms-1.42 distribution's header files prototype fopen with two      fixed arguments, which matches ANSI's specification but not VAXCRTL's      pre-ANSI implementation.  This hack circumvents the mismatch problem.  */
name|FILE
modifier|*
function_decl|(
modifier|*
name|vmslib_fopen
function_decl|)
parameter_list|()
init|=
operator|(
name|FILE
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|fopen
function_decl|;
if|if
condition|(
operator|*
name|type
operator|==
literal|'w'
condition|)
return|return
call|(
modifier|*
name|vmslib_fopen
call|)
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
literal|"mbc=32"
argument_list|,
literal|"deq=64"
argument_list|,
literal|"fop=tef"
argument_list|,
literal|"shr=nil"
argument_list|)
return|;
else|else
return|return
call|(
modifier|*
name|vmslib_fopen
call|)
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
literal|"mbc=32"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|VMS_open
parameter_list|(
name|fname
parameter_list|,
name|flags
parameter_list|,
name|prot
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|prot
decl_stmt|;
block|{
undef|#
directive|undef
name|open
comment|/* Get back the real open routine.  */
return|return
name|open
argument_list|(
name|fname
argument_list|,
name|flags
argument_list|,
name|prot
argument_list|,
literal|"mbc=16"
argument_list|,
literal|"deq=64"
argument_list|,
literal|"fop=tef"
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* more VMS hackery */
end_comment

begin_include
include|#
directive|include
file|<fab.h>
end_include

begin_include
include|#
directive|include
file|<nam.h>
end_include

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|SYS$PARSE
argument_list|()
decl_stmt|,
name|SYS$SEARCH
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Work around another library bug.  If a file is located via a searchlist,    and if the device it's on is not the same device as the one specified    in the first element of that searchlist, then both stat() and fstat()    will fail to return info about it.  `errno' will be set to EVMSERR, and    `vaxc$errno' will be set to SS$_NORMAL due yet another bug in stat()!    We can get around this by fully parsing the filename and then passing    that absolute name to stat().     Without this fix, we can end up failing to find header files, which is    bad enough, but then compounding the problem by reporting the reason for    failure as "normal successful completion."  */
end_comment

begin_undef
undef|#
directive|undef
name|fstat
end_undef

begin_comment
comment|/* Get back to the library version.  */
end_comment

begin_function
specifier|static
name|int
name|VMS_fstat
parameter_list|(
name|fd
parameter_list|,
name|statbuf
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|stat
modifier|*
name|statbuf
decl_stmt|;
block|{
name|int
name|result
init|=
name|fstat
argument_list|(
name|fd
argument_list|,
name|statbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|nambuf
index|[
name|NAM$C_MAXRSS
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|fgetname
argument_list|(
name|fp
argument_list|,
name|nambuf
argument_list|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|VMS_stat
argument_list|(
name|nambuf
argument_list|,
name|statbuf
argument_list|)
expr_stmt|;
comment|/* No fclose(fp) here; that would close(fd) as well.  */
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|VMS_stat
parameter_list|(
name|name
parameter_list|,
name|statbuf
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|stat
modifier|*
name|statbuf
decl_stmt|;
block|{
name|int
name|result
init|=
name|stat
argument_list|(
name|name
argument_list|,
name|statbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|struct
name|FAB
name|fab
decl_stmt|;
name|struct
name|NAM
name|nam
decl_stmt|;
name|char
name|exp_nam
index|[
name|NAM$C_MAXRSS
operator|+
literal|1
index|]
decl_stmt|,
comment|/* expanded name buffer for SYS$PARSE */
name|res_nam
index|[
name|NAM$C_MAXRSS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* resultant name buffer for SYS$SEARCH */
name|fab
operator|=
name|cc$rms_fab
expr_stmt|;
name|fab
operator|.
name|fab$l_fna
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
name|fab
operator|.
name|fab$b_fns
operator|=
operator|(
name|unsigned
name|char
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fab
operator|.
name|fab$l_nam
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nam
expr_stmt|;
name|nam
operator|=
name|cc$rms_nam
expr_stmt|;
name|nam
operator|.
name|nam$l_esa
operator|=
name|exp_nam
operator|,
name|nam
operator|.
name|nam$b_ess
operator|=
sizeof|sizeof
name|exp_nam
operator|-
literal|1
expr_stmt|;
name|nam
operator|.
name|nam$l_rsa
operator|=
name|res_nam
operator|,
name|nam
operator|.
name|nam$b_rss
operator|=
sizeof|sizeof
name|res_nam
operator|-
literal|1
expr_stmt|;
name|nam
operator|.
name|nam$b_nop
operator|=
name|NAM$M_PWD
operator||
name|NAM$M_NOCONCEAL
expr_stmt|;
if|if
condition|(
name|SYS$PARSE
argument_list|(
operator|&
name|fab
argument_list|)
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|SYS$SEARCH
argument_list|(
operator|&
name|fab
argument_list|)
operator|&
literal|1
condition|)
block|{
name|res_nam
index|[
name|nam
operator|.
name|nam$b_rsl
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|stat
argument_list|(
name|res_nam
argument_list|,
name|statbuf
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up searchlist context cached by the system.  */
name|nam
operator|.
name|nam$b_nop
operator|=
name|NAM$M_SYNCHK
expr_stmt|;
name|fab
operator|.
name|fab$l_fna
operator|=
literal|0
operator|,
name|fab
operator|.
name|fab$b_fns
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|SYS$PARSE
argument_list|(
operator|&
name|fab
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

end_unit

