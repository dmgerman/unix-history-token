begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for Value Range Propagation (VRP).    Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.    Contributed by Diego Novillo<dnovillo@redhat.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_comment
comment|/* Set of SSA names found during the dominator traversal of a    sub-graph in find_assert_locations.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|found_in_subgraph
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|compare_values
parameter_list|(
name|tree
name|val1
parameter_list|,
name|tree
name|val2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_values_warnv
parameter_list|(
name|tree
name|val1
parameter_list|,
name|tree
name|val2
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vrp_evaluate_conditional_warnv
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Location information for ASSERT_EXPRs.  Each instance of this    structure describes an ASSERT_EXPR for an SSA name.  Since a single    SSA name may have more than one assertion associated with it, these    locations are kept in a linked list attached to the corresponding    SSA name.  */
end_comment

begin_struct
struct|struct
name|assert_locus_d
block|{
comment|/* Basic block where the assertion would be inserted.  */
name|basic_block
name|bb
decl_stmt|;
comment|/* Some assertions need to be inserted on an edge (e.g., assertions      generated by COND_EXPRs).  In those cases, BB will be NULL.  */
name|edge
name|e
decl_stmt|;
comment|/* Pointer to the statement that generated this assertion.  */
name|block_stmt_iterator
name|si
decl_stmt|;
comment|/* Predicate code for the ASSERT_EXPR.  Must be COMPARISON_CLASS_P.  */
name|enum
name|tree_code
name|comp_code
decl_stmt|;
comment|/* Value being compared against.  */
name|tree
name|val
decl_stmt|;
comment|/* Next node in the linked list.  */
name|struct
name|assert_locus_d
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|assert_locus_d
modifier|*
name|assert_locus_t
typedef|;
end_typedef

begin_comment
comment|/* If bit I is present, it means that SSA name N_i has a list of    assertions that should be inserted in the IL.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|need_assert_for
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of locations lists where to insert assertions.  ASSERTS_FOR[I]    holds a list of ASSERT_LOCUS_T nodes that describe where    ASSERT_EXPRs for SSA name N_I should be inserted.  */
end_comment

begin_decl_stmt
specifier|static
name|assert_locus_t
modifier|*
name|asserts_for
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of blocks visited in find_assert_locations.  Used to avoid    visiting the same block more than once.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|blocks_visited
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value range array.  After propagation, VR_VALUE[I] holds the range    of values that SSA name N_I may take.  */
end_comment

begin_decl_stmt
specifier|static
name|value_range_t
modifier|*
modifier|*
name|vr_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return whether TYPE should use an overflow infinity distinct from    TYPE_{MIN,MAX}_VALUE.  We use an overflow infinity value to    represent a signed overflow during VRP computations.  An infinity    is distinct from a half-range, which will go from some number to    TYPE_{MIN,MAX}_VALUE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|needs_overflow_infinity
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_OVERFLOW_WRAPS
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether TYPE can support our overflow infinity    representation: we use the TREE_OVERFLOW flag, which only exists    for constants.  If TYPE doesn't support this, we don't optimize    cases which would require signed overflow--we drop them to    VARYING.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|supports_overflow_infinity
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|needs_overflow_infinity
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|CONSTANT_CLASS_P
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|CONSTANT_CLASS_P
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VAL is the maximum or minimum value of a type.  Return a    corresponding overflow infinity.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|make_overflow_infinity
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|val
operator|!=
name|NULL_TREE
operator|&&
name|CONSTANT_CLASS_P
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|copy_node
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return a negative overflow infinity for TYPE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|negative_overflow_infinity
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|supports_overflow_infinity
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|make_overflow_infinity
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a positive overflow infinity for TYPE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|positive_overflow_infinity
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|supports_overflow_infinity
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|make_overflow_infinity
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether VAL is a negative overflow infinity.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_negative_overflow_infinity
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
return|return
operator|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|&&
name|CONSTANT_CLASS_P
argument_list|(
name|val
argument_list|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|val
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|val
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether VAL is a positive overflow infinity.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_positive_overflow_infinity
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
return|return
operator|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|&&
name|CONSTANT_CLASS_P
argument_list|(
name|val
argument_list|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|val
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|val
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether VAL is a positive or negative overflow infinity.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_overflow_infinity
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
return|return
operator|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|&&
name|CONSTANT_CLASS_P
argument_list|(
name|val
argument_list|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|val
argument_list|)
operator|&&
operator|(
name|operand_equal_p
argument_list|(
name|val
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
name|operand_equal_p
argument_list|(
name|val
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If VAL is now an overflow infinity, return VAL.  Otherwise, return    the same value with TREE_OVERFLOW clear.  This can be used to avoid    confusing a regular value with an overflow value.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|avoid_overflow_infinity
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_overflow_infinity
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|val
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|val
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
else|else
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|operand_equal_p
argument_list|(
name|val
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return whether VAL is equal to the maximum value of its type.  This    will be true for a positive overflow infinity.  We can't do a    simple equality comparison with TYPE_MAX_VALUE because C typedefs    and Ada subtypes can produce types whose TYPE_MAX_VALUE is not ==    to the integer constant with the same value in the type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|vrp_val_is_max
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
name|tree
name|type_max
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|val
operator|==
name|type_max
operator|||
operator|(
name|type_max
operator|!=
name|NULL_TREE
operator|&&
name|operand_equal_p
argument_list|(
name|val
argument_list|,
name|type_max
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether VAL is equal to the minimum value of its type.  This    will be true for a negative overflow infinity.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|vrp_val_is_min
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
name|tree
name|type_min
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|val
operator|==
name|type_min
operator|||
operator|(
name|type_min
operator|!=
name|NULL_TREE
operator|&&
name|operand_equal_p
argument_list|(
name|val
argument_list|,
name|type_min
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if ARG is marked with the nonnull attribute in the    current function signature.  */
end_comment

begin_function
specifier|static
name|bool
name|nonnull_arg_p
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|attrs
decl_stmt|,
name|fntype
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|arg_num
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The static chain decl is always non null.  */
if|if
condition|(
name|arg
operator|==
name|cfun
operator|->
name|static_chain_decl
condition|)
return|return
name|true
return|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|lookup_attribute
argument_list|(
literal|"nonnull"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If "nonnull" wasn't specified, we know nothing about the argument.  */
if|if
condition|(
name|attrs
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
comment|/* If "nonnull" applies to all the arguments, then ARG is non-null.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|attrs
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|true
return|;
comment|/* Get the position number for ARG in the function signature.  */
for|for
control|(
name|arg_num
operator|=
literal|1
operator|,
name|t
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|arg_num
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|==
name|arg
condition|)
break|break;
block|}
name|gcc_assert
argument_list|(
name|t
operator|==
name|arg
argument_list|)
expr_stmt|;
comment|/* Now see if ARG_NUM is mentioned in the nonnull list.  */
for|for
control|(
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|attrs
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|compare_tree_int
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|arg_num
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Set value range VR to {T, MIN, MAX, EQUIV}.  */
end_comment

begin_function
specifier|static
name|void
name|set_value_range
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|enum
name|value_range_type
name|t
parameter_list|,
name|tree
name|min
parameter_list|,
name|tree
name|max
parameter_list|,
name|bitmap
name|equiv
parameter_list|)
block|{
if|#
directive|if
name|defined
name|ENABLE_CHECKING
comment|/* Check the validity of the range.  */
if|if
condition|(
name|t
operator|==
name|VR_RANGE
operator|||
name|t
operator|==
name|VR_ANTI_RANGE
condition|)
block|{
name|int
name|cmp
decl_stmt|;
name|gcc_assert
argument_list|(
name|min
operator|&&
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|min
argument_list|)
argument_list|)
operator|&&
name|t
operator|==
name|VR_ANTI_RANGE
condition|)
name|gcc_assert
argument_list|(
operator|!
name|vrp_val_is_min
argument_list|(
name|min
argument_list|)
operator|||
operator|!
name|vrp_val_is_max
argument_list|(
name|max
argument_list|)
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|compare_values
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|cmp
operator|==
literal|0
operator|||
name|cmp
operator|==
operator|-
literal|1
operator|||
name|cmp
operator|==
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|min
argument_list|)
argument_list|)
condition|)
name|gcc_assert
argument_list|(
operator|!
name|is_overflow_infinity
argument_list|(
name|min
argument_list|)
operator|||
operator|!
name|is_overflow_infinity
argument_list|(
name|max
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|VR_UNDEFINED
operator|||
name|t
operator|==
name|VR_VARYING
condition|)
name|gcc_assert
argument_list|(
name|min
operator|==
name|NULL_TREE
operator|&&
name|max
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|VR_UNDEFINED
operator|||
name|t
operator|==
name|VR_VARYING
condition|)
name|gcc_assert
argument_list|(
name|equiv
operator|==
name|NULL
operator|||
name|bitmap_empty_p
argument_list|(
name|equiv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vr
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|vr
operator|->
name|min
operator|=
name|min
expr_stmt|;
name|vr
operator|->
name|max
operator|=
name|max
expr_stmt|;
comment|/* Since updating the equivalence set involves deep copying the      bitmaps, only do it if absolutely necessary.  */
if|if
condition|(
name|vr
operator|->
name|equiv
operator|==
name|NULL
condition|)
name|vr
operator|->
name|equiv
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|equiv
operator|!=
name|vr
operator|->
name|equiv
condition|)
block|{
if|if
condition|(
name|equiv
operator|&&
operator|!
name|bitmap_empty_p
argument_list|(
name|equiv
argument_list|)
condition|)
name|bitmap_copy
argument_list|(
name|vr
operator|->
name|equiv
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
else|else
name|bitmap_clear
argument_list|(
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy value range FROM into value range TO.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|copy_value_range
parameter_list|(
name|value_range_t
modifier|*
name|to
parameter_list|,
name|value_range_t
modifier|*
name|from
parameter_list|)
block|{
name|set_value_range
argument_list|(
name|to
argument_list|,
name|from
operator|->
name|type
argument_list|,
name|from
operator|->
name|min
argument_list|,
name|from
operator|->
name|max
argument_list|,
name|from
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set value range VR to VR_VARYING.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_value_range_to_varying
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|)
block|{
name|vr
operator|->
name|type
operator|=
name|VR_VARYING
expr_stmt|;
name|vr
operator|->
name|min
operator|=
name|vr
operator|->
name|max
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|vr
operator|->
name|equiv
condition|)
name|bitmap_clear
argument_list|(
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set value range VR to a single value.  This function is only called    with values we get from statements, and exists to clear the    TREE_OVERFLOW flag so that we don't think we have an overflow    infinity when we shouldn't.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_value_range_to_value
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|tree
name|val
parameter_list|,
name|bitmap
name|equiv
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|avoid_overflow_infinity
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|set_value_range
argument_list|(
name|vr
argument_list|,
name|VR_RANGE
argument_list|,
name|val
argument_list|,
name|val
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set value range VR to a non-negative range of type TYPE.    OVERFLOW_INFINITY indicates whether to use a overflow infinity    rather than TYPE_MAX_VALUE; this should be true if we determine    that the range is nonnegative based on the assumption that signed    overflow does not occur.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_value_range_to_nonnegative
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|overflow_infinity
parameter_list|)
block|{
name|tree
name|zero
decl_stmt|;
if|if
condition|(
name|overflow_infinity
operator|&&
operator|!
name|supports_overflow_infinity
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
name|zero
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_value_range
argument_list|(
name|vr
argument_list|,
name|VR_RANGE
argument_list|,
name|zero
argument_list|,
operator|(
name|overflow_infinity
condition|?
name|positive_overflow_infinity
argument_list|(
name|type
argument_list|)
else|:
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|)
argument_list|,
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set value range VR to a non-NULL range of type TYPE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_value_range_to_nonnull
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|zero
init|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|set_value_range
argument_list|(
name|vr
argument_list|,
name|VR_ANTI_RANGE
argument_list|,
name|zero
argument_list|,
name|zero
argument_list|,
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set value range VR to a NULL range of type TYPE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_value_range_to_null
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|set_value_range_to_value
argument_list|(
name|vr
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set value range VR to VR_UNDEFINED.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_value_range_to_undefined
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|)
block|{
name|vr
operator|->
name|type
operator|=
name|VR_UNDEFINED
expr_stmt|;
name|vr
operator|->
name|min
operator|=
name|vr
operator|->
name|max
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|vr
operator|->
name|equiv
condition|)
name|bitmap_clear
argument_list|(
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return value range information for VAR.       If we have no values ranges recorded (ie, VRP is not running), then    return NULL.  Otherwise create an empty range if none existed for VAR.  */
end_comment

begin_function
specifier|static
name|value_range_t
modifier|*
name|get_value_range
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|value_range_t
modifier|*
name|vr
decl_stmt|;
name|tree
name|sym
decl_stmt|;
name|unsigned
name|ver
init|=
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
decl_stmt|;
comment|/* If we have no recorded ranges, then return NULL.  */
if|if
condition|(
operator|!
name|vr_value
condition|)
return|return
name|NULL
return|;
name|vr
operator|=
name|vr_value
index|[
name|ver
index|]
expr_stmt|;
if|if
condition|(
name|vr
condition|)
return|return
name|vr
return|;
comment|/* Create a default value range.  */
name|vr_value
index|[
name|ver
index|]
operator|=
name|vr
operator|=
name|XNEW
argument_list|(
name|value_range_t
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|vr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate an equivalence set.  */
name|vr
operator|->
name|equiv
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* If VAR is a default definition, the variable can take any value      in VAR's type.  */
name|sym
operator|=
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|==
name|default_def
argument_list|(
name|sym
argument_list|)
condition|)
block|{
comment|/* Try to use the "nonnull" attribute to create ~[0, 0] 	 anti-ranges for pointers.  Note that this is only valid with 	 default definitions of PARM_DECLs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sym
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&&
name|nonnull_arg_p
argument_list|(
name|sym
argument_list|)
condition|)
name|set_value_range_to_nonnull
argument_list|(
name|vr
argument_list|,
name|TREE_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
block|}
return|return
name|vr
return|;
block|}
end_function

begin_comment
comment|/* Return true, if VAL1 and VAL2 are equal values for VRP purposes.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|vrp_operand_equal_p
parameter_list|(
name|tree
name|val1
parameter_list|,
name|tree
name|val2
parameter_list|)
block|{
if|if
condition|(
name|val1
operator|==
name|val2
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|val1
operator|||
operator|!
name|val2
operator|||
operator|!
name|operand_equal_p
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|is_overflow_infinity
argument_list|(
name|val1
argument_list|)
condition|)
return|return
name|is_overflow_infinity
argument_list|(
name|val2
argument_list|)
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true, if the bitmaps B1 and B2 are equal.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|vrp_bitmap_equal_p
parameter_list|(
name|bitmap
name|b1
parameter_list|,
name|bitmap
name|b2
parameter_list|)
block|{
return|return
operator|(
name|b1
operator|==
name|b2
operator|||
operator|(
name|b1
operator|&&
name|b2
operator|&&
name|bitmap_equal_p
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Update the value range and equivalence set for variable VAR to    NEW_VR.  Return true if NEW_VR is different from VAR's previous    value.     NOTE: This function assumes that NEW_VR is a temporary value range    object created for the sole purpose of updating VAR's range.  The    storage used by the equivalence set from NEW_VR will be freed by    this function.  Do not call update_value_range when NEW_VR    is the range object associated with another SSA name.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|update_value_range
parameter_list|(
name|tree
name|var
parameter_list|,
name|value_range_t
modifier|*
name|new_vr
parameter_list|)
block|{
name|value_range_t
modifier|*
name|old_vr
decl_stmt|;
name|bool
name|is_new
decl_stmt|;
comment|/* Update the value range, if necessary.  */
name|old_vr
operator|=
name|get_value_range
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|is_new
operator|=
name|old_vr
operator|->
name|type
operator|!=
name|new_vr
operator|->
name|type
operator|||
operator|!
name|vrp_operand_equal_p
argument_list|(
name|old_vr
operator|->
name|min
argument_list|,
name|new_vr
operator|->
name|min
argument_list|)
operator|||
operator|!
name|vrp_operand_equal_p
argument_list|(
name|old_vr
operator|->
name|max
argument_list|,
name|new_vr
operator|->
name|max
argument_list|)
operator|||
operator|!
name|vrp_bitmap_equal_p
argument_list|(
name|old_vr
operator|->
name|equiv
argument_list|,
name|new_vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_new
condition|)
name|set_value_range
argument_list|(
name|old_vr
argument_list|,
name|new_vr
operator|->
name|type
argument_list|,
name|new_vr
operator|->
name|min
argument_list|,
name|new_vr
operator|->
name|max
argument_list|,
name|new_vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|new_vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
name|new_vr
operator|->
name|equiv
operator|=
name|NULL
expr_stmt|;
return|return
name|is_new
return|;
block|}
end_function

begin_comment
comment|/* Add VAR and VAR's equivalence set to EQUIV.  */
end_comment

begin_function
specifier|static
name|void
name|add_equivalence
parameter_list|(
name|bitmap
name|equiv
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|unsigned
name|ver
init|=
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|value_range_t
modifier|*
name|vr
init|=
name|vr_value
index|[
name|ver
index|]
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|equiv
argument_list|,
name|ver
argument_list|)
expr_stmt|;
if|if
condition|(
name|vr
operator|&&
name|vr
operator|->
name|equiv
condition|)
name|bitmap_ior_into
argument_list|(
name|equiv
argument_list|,
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if VR is ~[0, 0].  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|range_is_nonnull
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|)
block|{
return|return
name|vr
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
operator|&&
name|integer_zerop
argument_list|(
name|vr
operator|->
name|min
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|vr
operator|->
name|max
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if VR is [0, 0].  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|range_is_null
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|)
block|{
return|return
name|vr
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
name|integer_zerop
argument_list|(
name|vr
operator|->
name|min
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|vr
operator|->
name|max
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if value range VR involves at least one symbol.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|symbolic_range_p
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|)
block|{
return|return
operator|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|vr
operator|->
name|min
argument_list|)
operator|||
operator|!
name|is_gimple_min_invariant
argument_list|(
name|vr
operator|->
name|max
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if value range VR uses a overflow infinity.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|overflow_infinity_range_p
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|)
block|{
return|return
operator|(
name|vr
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
operator|(
name|is_overflow_infinity
argument_list|(
name|vr
operator|->
name|min
argument_list|)
operator|||
name|is_overflow_infinity
argument_list|(
name|vr
operator|->
name|max
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return false if we can not make a valid comparison based on VR;    this will be the case if it uses an overflow infinity and overflow    is not undefined (i.e., -fno-strict-overflow is in effect).    Otherwise return true, and set *STRICT_OVERFLOW_P to true if VR    uses an overflow infinity.  */
end_comment

begin_function
specifier|static
name|bool
name|usable_range_p
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|vr
operator|->
name|type
operator|==
name|VR_RANGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overflow_infinity
argument_list|(
name|vr
operator|->
name|min
argument_list|)
condition|)
block|{
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|vr
operator|->
name|min
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|is_overflow_infinity
argument_list|(
name|vr
operator|->
name|max
argument_list|)
condition|)
block|{
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|vr
operator|->
name|max
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Like tree_expr_nonnegative_warnv_p, but this function uses value    ranges obtained so far.  */
end_comment

begin_function
specifier|static
name|bool
name|vrp_expr_computes_nonnegative
parameter_list|(
name|tree
name|expr
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
return|return
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|expr
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like tree_expr_nonzero_warnv_p, but this function uses value ranges    obtained so far.  */
end_comment

begin_function
specifier|static
name|bool
name|vrp_expr_computes_nonzero
parameter_list|(
name|tree
name|expr
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
if|if
condition|(
name|tree_expr_nonzero_warnv_p
argument_list|(
name|expr
argument_list|,
name|strict_overflow_p
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If we have an expression of the form&X->a, then the expression      is nonnull if X is nonnull.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|base
init|=
name|get_base_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|value_range_t
modifier|*
name|vr
init|=
name|get_value_range
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|range_is_nonnull
argument_list|(
name|vr
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns true if EXPR is a valid value (as expected by compare_values) --    a gimple invariant, or SSA_NAME +- CST.  */
end_comment

begin_function
specifier|static
name|bool
name|valid_value_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
return|return
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
return|;
return|return
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare two values VAL1 and VAL2.  Return        	-2 if VAL1 and VAL2 cannot be compared at compile-time,    	-1 if VAL1< VAL2,    	 0 if VAL1 == VAL2, 	+1 if VAL1> VAL2, and 	+2 if VAL1 != VAL2     This is similar to tree_int_cst_compare but supports pointer values    and values that cannot be compared at compile time.     If STRICT_OVERFLOW_P is not NULL, then set *STRICT_OVERFLOW_P to    true if the return value is only valid if we assume that signed    overflow is undefined.  */
end_comment

begin_function
specifier|static
name|int
name|compare_values_warnv
parameter_list|(
name|tree
name|val1
parameter_list|,
name|tree
name|val2
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
if|if
condition|(
name|val1
operator|==
name|val2
condition|)
return|return
literal|0
return|;
comment|/* Below we rely on the fact that VAL1 and VAL2 are both pointers or      both integers.  */
name|gcc_assert
argument_list|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val1
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|val1
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|TREE_CODE
argument_list|(
name|val1
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|val1
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|val2
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|TREE_CODE
argument_list|(
name|val2
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|val2
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
condition|)
block|{
name|tree
name|n1
decl_stmt|,
name|c1
decl_stmt|,
name|n2
decl_stmt|,
name|c2
decl_stmt|;
name|enum
name|tree_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
comment|/* If VAL1 and VAL2 are of the form 'NAME [+-] CST' or 'NAME', 	 return -1 or +1 accordingly.  If VAL1 and VAL2 don't use the 	 same name, return -2.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val1
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|code1
operator|=
name|SSA_NAME
expr_stmt|;
name|n1
operator|=
name|val1
expr_stmt|;
name|c1
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|val1
argument_list|)
expr_stmt|;
name|n1
operator|=
name|TREE_OPERAND
argument_list|(
name|val1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c1
operator|=
name|TREE_OPERAND
argument_list|(
name|val1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|c1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|is_negative_overflow_infinity
argument_list|(
name|c1
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
name|c1
operator|=
name|fold_unary_to_constant
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|c1
argument_list|)
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c1
condition|)
return|return
operator|-
literal|2
return|;
name|code1
operator|=
name|code1
operator|==
name|MINUS_EXPR
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val2
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|code2
operator|=
name|SSA_NAME
expr_stmt|;
name|n2
operator|=
name|val2
expr_stmt|;
name|c2
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|val2
argument_list|)
expr_stmt|;
name|n2
operator|=
name|TREE_OPERAND
argument_list|(
name|val2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c2
operator|=
name|TREE_OPERAND
argument_list|(
name|val2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|c2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|is_negative_overflow_infinity
argument_list|(
name|c2
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
name|c2
operator|=
name|fold_unary_to_constant
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|c2
argument_list|)
argument_list|,
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c2
condition|)
return|return
operator|-
literal|2
return|;
name|code2
operator|=
name|code2
operator|==
name|MINUS_EXPR
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
expr_stmt|;
block|}
block|}
comment|/* Both values must use the same name.  */
if|if
condition|(
name|n1
operator|!=
name|n2
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|code1
operator|==
name|SSA_NAME
operator|&&
name|code2
operator|==
name|SSA_NAME
condition|)
comment|/* NAME == NAME  */
return|return
literal|0
return|;
comment|/* If overflow is defined we cannot simplify more.  */
if|if
condition|(
operator|!
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|val1
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|strict_overflow_p
operator|!=
name|NULL
operator|&&
operator|(
name|code1
operator|==
name|SSA_NAME
operator|||
operator|!
name|TREE_NO_WARNING
argument_list|(
name|val1
argument_list|)
operator|)
operator|&&
operator|(
name|code2
operator|==
name|SSA_NAME
operator|||
operator|!
name|TREE_NO_WARNING
argument_list|(
name|val2
argument_list|)
operator|)
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|code2
operator|==
name|PLUS_EXPR
condition|)
comment|/* NAME< NAME + CST  */
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|MINUS_EXPR
condition|)
comment|/* NAME> NAME - CST  */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|PLUS_EXPR
condition|)
block|{
if|if
condition|(
name|code2
operator|==
name|SSA_NAME
condition|)
comment|/* NAME + CST> NAME  */
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|PLUS_EXPR
condition|)
comment|/* NAME + CST1> NAME + CST2, if CST1> CST2  */
return|return
name|compare_values_warnv
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|MINUS_EXPR
condition|)
comment|/* NAME + CST1> NAME - CST2  */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|MINUS_EXPR
condition|)
block|{
if|if
condition|(
name|code2
operator|==
name|SSA_NAME
condition|)
comment|/* NAME - CST< NAME  */
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|PLUS_EXPR
condition|)
comment|/* NAME - CST1< NAME + CST2  */
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|MINUS_EXPR
condition|)
comment|/* NAME - CST1> NAME - CST2, if CST1< CST2.  Notice that 	       C1 and C2 are swapped in the call to compare_values.  */
return|return
name|compare_values_warnv
argument_list|(
name|c2
argument_list|,
name|c1
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* We cannot compare non-constants.  */
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|val1
argument_list|)
operator|||
operator|!
name|is_gimple_min_invariant
argument_list|(
name|val2
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We cannot compare overflowed values, except for overflow 	 infinities.  */
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|val1
argument_list|)
operator|||
name|TREE_OVERFLOW
argument_list|(
name|val2
argument_list|)
condition|)
block|{
if|if
condition|(
name|strict_overflow_p
operator|!=
name|NULL
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|is_negative_overflow_infinity
argument_list|(
name|val1
argument_list|)
condition|)
return|return
name|is_negative_overflow_infinity
argument_list|(
name|val2
argument_list|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|is_negative_overflow_infinity
argument_list|(
name|val2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_positive_overflow_infinity
argument_list|(
name|val1
argument_list|)
condition|)
return|return
name|is_positive_overflow_infinity
argument_list|(
name|val2
argument_list|)
condition|?
literal|0
else|:
literal|1
return|;
elseif|else
if|if
condition|(
name|is_positive_overflow_infinity
argument_list|(
name|val2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|-
literal|2
return|;
block|}
return|return
name|tree_int_cst_compare
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|t
decl_stmt|;
comment|/* First see if VAL1 and VAL2 are not the same.  */
if|if
condition|(
name|val1
operator|==
name|val2
operator|||
name|operand_equal_p
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If VAL1 is a lower address than VAL2, return -1.  */
name|t
operator|=
name|fold_binary
argument_list|(
name|LT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|boolean_true_node
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If VAL1 is a higher address than VAL2, return +1.  */
name|t
operator|=
name|fold_binary
argument_list|(
name|GT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|boolean_true_node
condition|)
return|return
literal|1
return|;
comment|/* If VAL1 is different than VAL2, return +2.  */
name|t
operator|=
name|fold_binary
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|boolean_true_node
condition|)
return|return
literal|2
return|;
return|return
operator|-
literal|2
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compare values like compare_values_warnv, but treat comparisons of    nonconstants which rely on undefined overflow as incomparable.  */
end_comment

begin_function
specifier|static
name|int
name|compare_values
parameter_list|(
name|tree
name|val1
parameter_list|,
name|tree
name|val2
parameter_list|)
block|{
name|bool
name|sop
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|sop
operator|=
name|false
expr_stmt|;
name|ret
operator|=
name|compare_values_warnv
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|,
operator|&
name|sop
argument_list|)
expr_stmt|;
if|if
condition|(
name|sop
operator|&&
operator|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|val1
argument_list|)
operator|||
operator|!
name|is_gimple_min_invariant
argument_list|(
name|val2
argument_list|)
operator|)
condition|)
name|ret
operator|=
operator|-
literal|2
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if VAL is inside value range VR (VR->MIN<= VAL<= VR->MAX),           0 if VAL is not inside VR, 	 -2 if we cannot tell either way.     FIXME, the current semantics of this functions are a bit quirky 	  when taken in the context of VRP.  In here we do not care 	  about VR's type.  If VR is the anti-range ~[3, 5] the call 	  value_inside_range (4, VR) will return 1.  	  This is counter-intuitive in a strict sense, but the callers 	  currently expect this.  They are calling the function 	  merely to determine whether VR->MIN<= VAL<= VR->MAX.  The 	  callers are applying the VR_RANGE/VR_ANTI_RANGE semantics 	  themselves.  	  This also applies to value_ranges_intersect_p and 	  range_includes_zero_p.  The semantics of VR_RANGE and 	  VR_ANTI_RANGE should be encoded here, but that also means 	  adapting the users of these functions to the new semantics.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|value_inside_range
parameter_list|(
name|tree
name|val
parameter_list|,
name|value_range_t
modifier|*
name|vr
parameter_list|)
block|{
name|tree
name|cmp1
decl_stmt|,
name|cmp2
decl_stmt|;
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
name|cmp1
operator|=
name|fold_binary_to_constant
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|val
argument_list|,
name|vr
operator|->
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp1
condition|)
block|{
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|cmp2
operator|=
name|fold_binary_to_constant
argument_list|(
name|LE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|val
argument_list|,
name|vr
operator|->
name|max
argument_list|)
expr_stmt|;
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cmp2
condition|)
return|return
operator|-
literal|2
return|;
return|return
name|cmp1
operator|==
name|boolean_true_node
operator|&&
name|cmp2
operator|==
name|boolean_true_node
return|;
block|}
end_function

begin_comment
comment|/* Return true if value ranges VR0 and VR1 have a non-empty    intersection.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|value_ranges_intersect_p
parameter_list|(
name|value_range_t
modifier|*
name|vr0
parameter_list|,
name|value_range_t
modifier|*
name|vr1
parameter_list|)
block|{
return|return
operator|(
name|value_inside_range
argument_list|(
name|vr1
operator|->
name|min
argument_list|,
name|vr0
argument_list|)
operator|==
literal|1
operator|||
name|value_inside_range
argument_list|(
name|vr1
operator|->
name|max
argument_list|,
name|vr0
argument_list|)
operator|==
literal|1
operator|||
name|value_inside_range
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr1
argument_list|)
operator|==
literal|1
operator|||
name|value_inside_range
argument_list|(
name|vr0
operator|->
name|max
argument_list|,
name|vr1
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if VR includes the value zero, false otherwise.  FIXME,    currently this will return false for an anti-range like ~[-4, 3].    This will be wrong when the semantics of value_inside_range are    modified (currently the users of this function expect these    semantics).  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|range_includes_zero_p
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|)
block|{
name|tree
name|zero
decl_stmt|;
name|gcc_assert
argument_list|(
name|vr
operator|->
name|type
operator|!=
name|VR_UNDEFINED
operator|&&
name|vr
operator|->
name|type
operator|!=
name|VR_VARYING
operator|&&
operator|!
name|symbolic_range_p
argument_list|(
name|vr
argument_list|)
argument_list|)
expr_stmt|;
name|zero
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|vr
operator|->
name|min
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|value_inside_range
argument_list|(
name|zero
argument_list|,
name|vr
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if T, an SSA_NAME, is known to be nonnegative.  Return    false otherwise or if no value range information is available.  */
end_comment

begin_function
name|bool
name|ssa_name_nonnegative_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|value_range_t
modifier|*
name|vr
init|=
name|get_value_range
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vr
condition|)
return|return
name|false
return|;
comment|/* Testing for VR_ANTI_RANGE is not useful here as any anti-range      which would return a useful value should be encoded as a VR_RANGE.  */
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_RANGE
condition|)
block|{
name|int
name|result
init|=
name|compare_values
argument_list|(
name|vr
operator|->
name|min
argument_list|,
name|integer_zero_node
argument_list|)
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|0
operator|||
name|result
operator|==
literal|1
operator|)
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if T, an SSA_NAME, is known to be nonzero.  Return    false otherwise or if no value range information is available.  */
end_comment

begin_function
name|bool
name|ssa_name_nonzero_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|value_range_t
modifier|*
name|vr
init|=
name|get_value_range
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vr
condition|)
return|return
name|false
return|;
comment|/* A VR_RANGE which does not include zero is a nonzero value.  */
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
operator|!
name|symbolic_range_p
argument_list|(
name|vr
argument_list|)
condition|)
return|return
operator|!
name|range_includes_zero_p
argument_list|(
name|vr
argument_list|)
return|;
comment|/* A VR_ANTI_RANGE which does include zero is a nonzero value.  */
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
operator|&&
operator|!
name|symbolic_range_p
argument_list|(
name|vr
argument_list|)
condition|)
return|return
name|range_includes_zero_p
argument_list|(
name|vr
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Extract value range information from an ASSERT_EXPR EXPR and store    it in *VR_P.  */
end_comment

begin_function
specifier|static
name|void
name|extract_range_from_assert
parameter_list|(
name|value_range_t
modifier|*
name|vr_p
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|var
decl_stmt|,
name|cond
decl_stmt|,
name|limit
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|,
name|type
decl_stmt|;
name|value_range_t
modifier|*
name|var_vr
decl_stmt|,
modifier|*
name|limit_vr
decl_stmt|;
name|enum
name|tree_code
name|cond_code
decl_stmt|;
name|var
operator|=
name|ASSERT_EXPR_VAR
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|cond
operator|=
name|ASSERT_EXPR_COND
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find VAR in the ASSERT_EXPR conditional.  */
if|if
condition|(
name|var
operator|==
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If the predicate is of the form VAR COMP LIMIT, then we just 	 take LIMIT from the RHS and use the same comparison code.  */
name|limit
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cond_code
operator|=
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the predicate is of the form LIMIT COMP VAR, then we need 	 to flip around the comparison code to create the proper range 	 for VAR.  */
name|limit
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond_code
operator|=
name|swap_tree_comparison
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|limit
operator|=
name|avoid_overflow_infinity
argument_list|(
name|limit
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|limit
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|limit
operator|!=
name|var
argument_list|)
expr_stmt|;
comment|/* For pointer arithmetic, we only keep track of pointer equality      and inequality.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|cond_code
operator|!=
name|NE_EXPR
operator|&&
name|cond_code
operator|!=
name|EQ_EXPR
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr_p
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If LIMIT is another SSA name and LIMIT has a range of its own,      try to use LIMIT's range to avoid creating symbolic ranges      unnecessarily. */
name|limit_vr
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|limit
argument_list|)
operator|==
name|SSA_NAME
operator|)
condition|?
name|get_value_range
argument_list|(
name|limit
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* LIMIT's range is only interesting if it has any useful information.  */
if|if
condition|(
name|limit_vr
operator|&&
operator|(
name|limit_vr
operator|->
name|type
operator|==
name|VR_UNDEFINED
operator|||
name|limit_vr
operator|->
name|type
operator|==
name|VR_VARYING
operator|||
name|symbolic_range_p
argument_list|(
name|limit_vr
argument_list|)
operator|)
condition|)
name|limit_vr
operator|=
name|NULL
expr_stmt|;
comment|/* Initially, the new range has the same set of equivalences of      VAR's range.  This will be revised before returning the final      value.  Since assertions may be chained via mutually exclusive      predicates, we will need to trim the set of equivalences before      we are done.  */
name|gcc_assert
argument_list|(
name|vr_p
operator|->
name|equiv
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|vr_p
operator|->
name|equiv
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|add_equivalence
argument_list|(
name|vr_p
operator|->
name|equiv
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* Extract a new range based on the asserted comparison for VAR and      LIMIT's value range.  Notice that if LIMIT has an anti-range, we      will only use it for equality comparisons (EQ_EXPR).  For any      other kind of assertion, we cannot derive a range from LIMIT's      anti-range that can be used to describe the new range.  For      instance, ASSERT_EXPR<x_2, x_2<= b_4>.  If b_4 is ~[2, 10],      then b_4 takes on the ranges [-INF, 1] and [11, +INF].  There is      no single range for x_2 that could describe LE_EXPR, so we might      as well build the range [b_4, +INF] for it.  */
if|if
condition|(
name|cond_code
operator|==
name|EQ_EXPR
condition|)
block|{
name|enum
name|value_range_type
name|range_type
decl_stmt|;
if|if
condition|(
name|limit_vr
condition|)
block|{
name|range_type
operator|=
name|limit_vr
operator|->
name|type
expr_stmt|;
name|min
operator|=
name|limit_vr
operator|->
name|min
expr_stmt|;
name|max
operator|=
name|limit_vr
operator|->
name|max
expr_stmt|;
block|}
else|else
block|{
name|range_type
operator|=
name|VR_RANGE
expr_stmt|;
name|min
operator|=
name|limit
expr_stmt|;
name|max
operator|=
name|limit
expr_stmt|;
block|}
name|set_value_range
argument_list|(
name|vr_p
argument_list|,
name|range_type
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|vr_p
operator|->
name|equiv
argument_list|)
expr_stmt|;
comment|/* When asserting the equality VAR == LIMIT and LIMIT is another 	 SSA name, the new range will also inherit the equivalence set 	 from LIMIT.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|limit
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|add_equivalence
argument_list|(
name|vr_p
operator|->
name|equiv
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cond_code
operator|==
name|NE_EXPR
condition|)
block|{
comment|/* As described above, when LIMIT's range is an anti-range and 	 this assertion is an inequality (NE_EXPR), then we cannot 	 derive anything from the anti-range.  For instance, if 	 LIMIT's range was ~[0, 0], the assertion 'VAR != LIMIT' does 	 not imply that VAR's range is [0, 0].  So, in the case of 	 anti-ranges, we just assert the inequality using LIMIT and 	 not its anti-range.  	 If LIMIT_VR is a range, we can only use it to build a new 	 anti-range if LIMIT_VR is a single-valued range.  For 	 instance, if LIMIT_VR is [0, 1], the predicate 	 VAR != [0, 1] does not mean that VAR's range is ~[0, 1]. 	 Rather, it means that for value 0 VAR should be ~[0, 0] 	 and for value 1, VAR should be ~[1, 1].  We cannot 	 represent these ranges.  	 The only situation in which we can build a valid 	 anti-range is when LIMIT_VR is a single-valued range 	 (i.e., LIMIT_VR->MIN == LIMIT_VR->MAX).  In that case,  	 build the anti-range ~[LIMIT_VR->MIN, LIMIT_VR->MAX].  */
if|if
condition|(
name|limit_vr
operator|&&
name|limit_vr
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
name|compare_values
argument_list|(
name|limit_vr
operator|->
name|min
argument_list|,
name|limit_vr
operator|->
name|max
argument_list|)
operator|==
literal|0
condition|)
block|{
name|min
operator|=
name|limit_vr
operator|->
name|min
expr_stmt|;
name|max
operator|=
name|limit_vr
operator|->
name|max
expr_stmt|;
block|}
else|else
block|{
comment|/* In any other case, we cannot use LIMIT's range to build a 	     valid anti-range.  */
name|min
operator|=
name|max
operator|=
name|limit
expr_stmt|;
block|}
comment|/* If MIN and MAX cover the whole range for their type, then 	 just use the original LIMIT.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|vrp_val_is_min
argument_list|(
name|min
argument_list|)
operator|&&
name|vrp_val_is_max
argument_list|(
name|max
argument_list|)
condition|)
name|min
operator|=
name|max
operator|=
name|limit
expr_stmt|;
name|set_value_range
argument_list|(
name|vr_p
argument_list|,
name|VR_ANTI_RANGE
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|vr_p
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cond_code
operator|==
name|LE_EXPR
operator|||
name|cond_code
operator|==
name|LT_EXPR
condition|)
block|{
name|min
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit_vr
operator|==
name|NULL
operator|||
name|limit_vr
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
name|max
operator|=
name|limit
expr_stmt|;
else|else
block|{
comment|/* If LIMIT_VR is of the form [N1, N2], we need to build the 	     range [MIN, N2] for LE_EXPR and [MIN, N2 - 1] for 	     LT_EXPR.  */
name|max
operator|=
name|limit_vr
operator|->
name|max
expr_stmt|;
block|}
comment|/* If the maximum value forces us to be out of bounds, simply punt. 	 It would be pointless to try and do anything more since this 	 all should be optimized away above us.  */
if|if
condition|(
operator|(
name|cond_code
operator|==
name|LT_EXPR
operator|&&
name|compare_values
argument_list|(
name|max
argument_list|,
name|min
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|is_overflow_infinity
argument_list|(
name|max
argument_list|)
condition|)
name|set_value_range_to_varying
argument_list|(
name|vr_p
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* For LT_EXPR, we create the range [MIN, MAX - 1].  */
if|if
condition|(
name|cond_code
operator|==
name|LT_EXPR
condition|)
block|{
name|tree
name|one
init|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|max
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|max
argument_list|,
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|max
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|max
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|set_value_range
argument_list|(
name|vr_p
argument_list|,
name|VR_RANGE
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|vr_p
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cond_code
operator|==
name|GE_EXPR
operator|||
name|cond_code
operator|==
name|GT_EXPR
condition|)
block|{
name|max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit_vr
operator|==
name|NULL
operator|||
name|limit_vr
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
name|min
operator|=
name|limit
expr_stmt|;
else|else
block|{
comment|/* If LIMIT_VR is of the form [N1, N2], we need to build the 	     range [N1, MAX] for GE_EXPR and [N1 + 1, MAX] for 	     GT_EXPR.  */
name|min
operator|=
name|limit_vr
operator|->
name|min
expr_stmt|;
block|}
comment|/* If the minimum value forces us to be out of bounds, simply punt. 	 It would be pointless to try and do anything more since this 	 all should be optimized away above us.  */
if|if
condition|(
operator|(
name|cond_code
operator|==
name|GT_EXPR
operator|&&
name|compare_values
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|is_overflow_infinity
argument_list|(
name|min
argument_list|)
condition|)
name|set_value_range_to_varying
argument_list|(
name|vr_p
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* For GT_EXPR, we create the range [MIN + 1, MAX].  */
if|if
condition|(
name|cond_code
operator|==
name|GT_EXPR
condition|)
block|{
name|tree
name|one
init|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|min
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|min
argument_list|,
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|min
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|min
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|set_value_range
argument_list|(
name|vr_p
argument_list|,
name|VR_RANGE
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|vr_p
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* If VAR already had a known range, it may happen that the new      range we have computed and VAR's range are not compatible.  For      instance,  	if (p_5 == NULL) 	  p_6 = ASSERT_EXPR<p_5, p_5 == NULL>; 	  x_7 = p_6->fld; 	  p_8 = ASSERT_EXPR<p_6, p_6 != NULL>;       While the above comes from a faulty program, it will cause an ICE      later because p_8 and p_6 will have incompatible ranges and at      the same time will be considered equivalent.  A similar situation      would arise from       	if (i_5> 10) 	  i_6 = ASSERT_EXPR<i_5, i_5> 10>; 	  if (i_5< 5) 	    i_7 = ASSERT_EXPR<i_6, i_6< 5>;       Again i_6 and i_7 will have incompatible ranges.  It would be      pointless to try and do anything with i_7's range because      anything dominated by 'if (i_5< 5)' will be optimized away.      Note, due to the wa in which simulation proceeds, the statement      i_7 = ASSERT_EXPR<...> we would never be visited because the      conditional 'if (i_5< 5)' always evaluates to false.  However,      this extra check does not hurt and may protect against future      changes to VRP that may get into a situation similar to the      NULL pointer dereference example.       Note that these compatibility tests are only needed when dealing      with ranges or a mix of range and anti-range.  If VAR_VR and VR_P      are both anti-ranges, they will always be compatible, because two      anti-ranges will always have a non-empty intersection.  */
name|var_vr
operator|=
name|get_value_range
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* We may need to make adjustments when VR_P and VAR_VR are numeric      ranges or anti-ranges.  */
if|if
condition|(
name|vr_p
operator|->
name|type
operator|==
name|VR_VARYING
operator|||
name|vr_p
operator|->
name|type
operator|==
name|VR_UNDEFINED
operator|||
name|var_vr
operator|->
name|type
operator|==
name|VR_VARYING
operator|||
name|var_vr
operator|->
name|type
operator|==
name|VR_UNDEFINED
operator|||
name|symbolic_range_p
argument_list|(
name|vr_p
argument_list|)
operator|||
name|symbolic_range_p
argument_list|(
name|var_vr
argument_list|)
condition|)
return|return;
if|if
condition|(
name|var_vr
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
name|vr_p
operator|->
name|type
operator|==
name|VR_RANGE
condition|)
block|{
comment|/* If the two ranges have a non-empty intersection, we can 	 refine the resulting range.  Since the assert expression 	 creates an equivalency and at the same time it asserts a 	 predicate, we can take the intersection of the two ranges to 	 get better precision.  */
if|if
condition|(
name|value_ranges_intersect_p
argument_list|(
name|var_vr
argument_list|,
name|vr_p
argument_list|)
condition|)
block|{
comment|/* Use the larger of the two minimums.  */
if|if
condition|(
name|compare_values
argument_list|(
name|vr_p
operator|->
name|min
argument_list|,
name|var_vr
operator|->
name|min
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|min
operator|=
name|var_vr
operator|->
name|min
expr_stmt|;
else|else
name|min
operator|=
name|vr_p
operator|->
name|min
expr_stmt|;
comment|/* Use the smaller of the two maximums.  */
if|if
condition|(
name|compare_values
argument_list|(
name|vr_p
operator|->
name|max
argument_list|,
name|var_vr
operator|->
name|max
argument_list|)
operator|==
literal|1
condition|)
name|max
operator|=
name|var_vr
operator|->
name|max
expr_stmt|;
else|else
name|max
operator|=
name|vr_p
operator|->
name|max
expr_stmt|;
name|set_value_range
argument_list|(
name|vr_p
argument_list|,
name|vr_p
operator|->
name|type
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|vr_p
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The two ranges do not intersect, set the new range to 	     VARYING, because we will not be able to do anything 	     meaningful with it.  */
name|set_value_range_to_varying
argument_list|(
name|vr_p
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|var_vr
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
name|vr_p
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
operator|)
operator|||
operator|(
name|var_vr
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
operator|&&
name|vr_p
operator|->
name|type
operator|==
name|VR_RANGE
operator|)
condition|)
block|{
comment|/* A range and an anti-range will cancel each other only if 	 their ends are the same.  For instance, in the example above, 	 p_8's range ~[0, 0] and p_6's range [0, 0] are incompatible, 	 so VR_P should be set to VR_VARYING.  */
if|if
condition|(
name|compare_values
argument_list|(
name|var_vr
operator|->
name|min
argument_list|,
name|vr_p
operator|->
name|min
argument_list|)
operator|==
literal|0
operator|&&
name|compare_values
argument_list|(
name|var_vr
operator|->
name|max
argument_list|,
name|vr_p
operator|->
name|max
argument_list|)
operator|==
literal|0
condition|)
name|set_value_range_to_varying
argument_list|(
name|vr_p
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|min
decl_stmt|,
name|max
decl_stmt|,
name|anti_min
decl_stmt|,
name|anti_max
decl_stmt|,
name|real_min
decl_stmt|,
name|real_max
decl_stmt|;
comment|/* We want to compute the logical AND of the two ranges; 	     there are three cases to consider.   	     1. The VR_ANTI_RANGE range is completely within the  		VR_RANGE and the endpoints of the ranges are 		different.  In that case the resulting range 		should be whichever range is more precise. 		Typically that will be the VR_RANGE.  	     2. The VR_ANTI_RANGE is completely disjoint from 		the VR_RANGE.  In this case the resulting range 		should be the VR_RANGE.  	     3. There is some overlap between the VR_ANTI_RANGE 		and the VR_RANGE.  		3a. If the high limit of the VR_ANTI_RANGE resides 		    within the VR_RANGE, then the result is a new 		    VR_RANGE starting at the high limit of the 		    the VR_ANTI_RANGE + 1 and extending to the 		    high limit of the original VR_RANGE.  		3b. If the low limit of the VR_ANTI_RANGE resides 		    within the VR_RANGE, then the result is a new 		    VR_RANGE starting at the low limit of the original 		    VR_RANGE and extending to the low limit of the 		    VR_ANTI_RANGE - 1.  */
if|if
condition|(
name|vr_p
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
block|{
name|anti_min
operator|=
name|vr_p
operator|->
name|min
expr_stmt|;
name|anti_max
operator|=
name|vr_p
operator|->
name|max
expr_stmt|;
name|real_min
operator|=
name|var_vr
operator|->
name|min
expr_stmt|;
name|real_max
operator|=
name|var_vr
operator|->
name|max
expr_stmt|;
block|}
else|else
block|{
name|anti_min
operator|=
name|var_vr
operator|->
name|min
expr_stmt|;
name|anti_max
operator|=
name|var_vr
operator|->
name|max
expr_stmt|;
name|real_min
operator|=
name|vr_p
operator|->
name|min
expr_stmt|;
name|real_max
operator|=
name|vr_p
operator|->
name|max
expr_stmt|;
block|}
comment|/* Case 1, VR_ANTI_RANGE completely within VR_RANGE, 	     not including any endpoints.  */
if|if
condition|(
name|compare_values
argument_list|(
name|anti_max
argument_list|,
name|real_max
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|compare_values
argument_list|(
name|anti_min
argument_list|,
name|real_min
argument_list|)
operator|==
literal|1
condition|)
block|{
name|set_value_range
argument_list|(
name|vr_p
argument_list|,
name|VR_RANGE
argument_list|,
name|real_min
argument_list|,
name|real_max
argument_list|,
name|vr_p
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
comment|/* Case 2, VR_ANTI_RANGE completely disjoint from 	     VR_RANGE.  */
elseif|else
if|if
condition|(
name|compare_values
argument_list|(
name|anti_min
argument_list|,
name|real_max
argument_list|)
operator|==
literal|1
operator|||
name|compare_values
argument_list|(
name|anti_max
argument_list|,
name|real_min
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|set_value_range
argument_list|(
name|vr_p
argument_list|,
name|VR_RANGE
argument_list|,
name|real_min
argument_list|,
name|real_max
argument_list|,
name|vr_p
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
comment|/* Case 3a, the anti-range extends into the low 	     part of the real range.  Thus creating a new 	     low for the real range.  */
elseif|else
if|if
condition|(
operator|(
name|compare_values
argument_list|(
name|anti_max
argument_list|,
name|real_min
argument_list|)
operator|==
literal|1
operator|||
name|compare_values
argument_list|(
name|anti_max
argument_list|,
name|real_min
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|compare_values
argument_list|(
name|anti_max
argument_list|,
name|real_max
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|is_positive_overflow_infinity
argument_list|(
name|anti_max
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|anti_max
argument_list|)
argument_list|)
operator|&&
name|vrp_val_is_max
argument_list|(
name|anti_max
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|var_vr
operator|->
name|min
argument_list|)
argument_list|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr_p
argument_list|)
expr_stmt|;
return|return;
block|}
name|min
operator|=
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|var_vr
operator|->
name|min
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|min
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|var_vr
operator|->
name|min
argument_list|)
argument_list|,
name|anti_max
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|var_vr
operator|->
name|min
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
name|real_max
expr_stmt|;
name|set_value_range
argument_list|(
name|vr_p
argument_list|,
name|VR_RANGE
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|vr_p
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
comment|/* Case 3b, the anti-range extends into the high 	     part of the real range.  Thus creating a new 	     higher for the real range.  */
elseif|else
if|if
condition|(
name|compare_values
argument_list|(
name|anti_min
argument_list|,
name|real_min
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|compare_values
argument_list|(
name|anti_min
argument_list|,
name|real_max
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|compare_values
argument_list|(
name|anti_min
argument_list|,
name|real_max
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|is_negative_overflow_infinity
argument_list|(
name|anti_min
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|anti_min
argument_list|)
argument_list|)
operator|&&
name|vrp_val_is_min
argument_list|(
name|anti_min
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|var_vr
operator|->
name|min
argument_list|)
argument_list|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr_p
argument_list|)
expr_stmt|;
return|return;
block|}
name|max
operator|=
name|negative_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|var_vr
operator|->
name|min
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|max
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|var_vr
operator|->
name|min
argument_list|)
argument_list|,
name|anti_min
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|var_vr
operator|->
name|min
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|min
operator|=
name|real_min
expr_stmt|;
name|set_value_range
argument_list|(
name|vr_p
argument_list|,
name|VR_RANGE
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|vr_p
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Extract range information from SSA name VAR and store it in VR.  If    VAR has an interesting range, use it.  Otherwise, create the    range [VAR, VAR] and return it.  This is useful in situations where    we may have conditionals testing values of VARYING names.  For    instance,     	x_3 = y_5; 	if (x_3> y_5) 	  ...      Even if y_5 is deemed VARYING, we can determine that x_3> y_5 is     always false.  */
end_comment

begin_function
specifier|static
name|void
name|extract_range_from_ssa_name
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|value_range_t
modifier|*
name|var_vr
init|=
name|get_value_range
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|var_vr
operator|->
name|type
operator|!=
name|VR_UNDEFINED
operator|&&
name|var_vr
operator|->
name|type
operator|!=
name|VR_VARYING
condition|)
name|copy_value_range
argument_list|(
name|vr
argument_list|,
name|var_vr
argument_list|)
expr_stmt|;
else|else
name|set_value_range
argument_list|(
name|vr
argument_list|,
name|VR_RANGE
argument_list|,
name|var
argument_list|,
name|var
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_equivalence
argument_list|(
name|vr
operator|->
name|equiv
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper around int_const_binop.  If the operation overflows and we    are not using wrapping arithmetic, then adjust the result to be    -INF or +INF depending on CODE, VAL1 and VAL2.  This can return    NULL_TREE if we need to use an overflow infinity representation but    the type does not support it.  */
end_comment

begin_function
specifier|static
name|tree
name|vrp_int_const_binop
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|val1
parameter_list|,
name|tree
name|val2
parameter_list|)
block|{
name|tree
name|res
decl_stmt|;
name|res
operator|=
name|int_const_binop
argument_list|(
name|code
argument_list|,
name|val1
argument_list|,
name|val2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we are not using wrapping arithmetic, operate symbolically      on -INF and +INF.  */
if|if
condition|(
name|TYPE_OVERFLOW_WRAPS
argument_list|(
name|TREE_TYPE
argument_list|(
name|val1
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|checkz
init|=
name|compare_values
argument_list|(
name|res
argument_list|,
name|val1
argument_list|)
decl_stmt|;
name|bool
name|overflow
init|=
name|false
decl_stmt|;
comment|/* Ensure that res = val1 [+*] val2>= val1          or that res = val1 - val2<= val1.  */
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
operator|!
operator|(
name|checkz
operator|==
literal|1
operator|||
name|checkz
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
operator|!
operator|(
name|checkz
operator|==
literal|0
operator|||
name|checkz
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|overflow
operator|=
name|true
expr_stmt|;
block|}
comment|/* Checking for multiplication overflow is done by dividing the 	 output of the multiplication by the first input of the 	 multiplication.  If the result of that division operation is 	 not equal to the second input of the multiplication, then the 	 multiplication overflowed.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|val1
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|int_const_binop
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|res
argument_list|,
name|val1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|check
init|=
name|compare_values
argument_list|(
name|tmp
argument_list|,
name|val2
argument_list|)
decl_stmt|;
if|if
condition|(
name|check
operator|!=
literal|0
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|overflow
condition|)
block|{
name|res
operator|=
name|copy_node
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|res
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_OVERFLOW
argument_list|(
name|res
argument_list|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|val1
argument_list|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|val2
argument_list|)
operator|)
operator|||
name|is_overflow_infinity
argument_list|(
name|val1
argument_list|)
operator|||
name|is_overflow_infinity
argument_list|(
name|val2
argument_list|)
condition|)
block|{
comment|/* If the operation overflowed but neither VAL1 nor VAL2 are 	 overflown, return -INF or +INF depending on the operation 	 and the combination of signs of the operands.  */
name|int
name|sgn1
init|=
name|tree_int_cst_sgn
argument_list|(
name|val1
argument_list|)
decl_stmt|;
name|int
name|sgn2
init|=
name|tree_int_cst_sgn
argument_list|(
name|val2
argument_list|)
decl_stmt|;
if|if
condition|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|)
operator|&&
operator|!
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* We have to punt on adding infinities of different signs, 	 since we can't tell what the sign of the result should be. 	 Likewise for subtracting infinities of the same sign.  */
if|if
condition|(
operator|(
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|sgn1
operator|!=
name|sgn2
operator|)
operator|||
operator|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|sgn1
operator|==
name|sgn2
operator|)
operator|)
operator|&&
name|is_overflow_infinity
argument_list|(
name|val1
argument_list|)
operator|&&
name|is_overflow_infinity
argument_list|(
name|val2
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't try to handle division or shifting of infinities.  */
if|if
condition|(
operator|(
name|code
operator|==
name|TRUNC_DIV_EXPR
operator|||
name|code
operator|==
name|FLOOR_DIV_EXPR
operator|||
name|code
operator|==
name|CEIL_DIV_EXPR
operator|||
name|code
operator|==
name|EXACT_DIV_EXPR
operator|||
name|code
operator|==
name|ROUND_DIV_EXPR
operator|||
name|code
operator|==
name|RSHIFT_EXPR
operator|)
operator|&&
operator|(
name|is_overflow_infinity
argument_list|(
name|val1
argument_list|)
operator|||
name|is_overflow_infinity
argument_list|(
name|val2
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Notice that we only need to handle the restricted set of 	 operations handled by extract_range_from_binary_expr. 	 Among them, only multiplication, addition and subtraction 	 can yield overflow without overflown operands because we 	 are working with integral types only... except in the 	 case VAL1 = -INF and VAL2 = -1 which overflows to +INF 	 for division too.  */
comment|/* For multiplication, the sign of the overflow is given 	 by the comparison of the signs of the operands.  */
if|if
condition|(
operator|(
name|code
operator|==
name|MULT_EXPR
operator|&&
name|sgn1
operator|==
name|sgn2
operator|)
comment|/* For addition, the operands must be of the same sign 	     to yield an overflow.  Its sign is therefore that 	     of one of the operands, for example the first.  For 	     infinite operands X + -INF is negative, not positive.  */
operator|||
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
operator|(
name|sgn1
operator|>=
literal|0
condition|?
operator|!
name|is_negative_overflow_infinity
argument_list|(
name|val2
argument_list|)
else|:
name|is_positive_overflow_infinity
argument_list|(
name|val2
argument_list|)
operator|)
operator|)
comment|/* For subtraction, non-infinite operands must be of 	     different signs to yield an overflow.  Its sign is 	     therefore that of the first operand or the opposite of 	     that of the second operand.  A first operand of 0 counts 	     as positive here, for the corner case 0 - (-INF), which 	     overflows, but must yield +INF.  For infinite operands 0 	     - INF is negative, not positive.  */
operator|||
operator|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
operator|(
name|sgn1
operator|>=
literal|0
condition|?
operator|!
name|is_positive_overflow_infinity
argument_list|(
name|val2
argument_list|)
else|:
name|is_negative_overflow_infinity
argument_list|(
name|val2
argument_list|)
operator|)
operator|)
comment|/* For division, the only case is -INF / -1 = +INF.  */
operator|||
name|code
operator|==
name|TRUNC_DIV_EXPR
operator|||
name|code
operator|==
name|FLOOR_DIV_EXPR
operator|||
name|code
operator|==
name|CEIL_DIV_EXPR
operator|||
name|code
operator|==
name|EXACT_DIV_EXPR
operator|||
name|code
operator|==
name|ROUND_DIV_EXPR
condition|)
return|return
operator|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|)
condition|?
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|)
else|:
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|)
condition|?
name|negative_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|)
else|:
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Extract range information from a binary expression EXPR based on    the ranges of each of its operands and the expression code.  */
end_comment

begin_function
specifier|static
name|void
name|extract_range_from_binary_expr
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|enum
name|value_range_type
name|type
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|value_range_t
name|vr0
init|=
block|{
name|VR_UNDEFINED
block|,
name|NULL_TREE
block|,
name|NULL_TREE
block|,
name|NULL
block|}
decl_stmt|;
name|value_range_t
name|vr1
init|=
block|{
name|VR_UNDEFINED
block|,
name|NULL_TREE
block|,
name|NULL_TREE
block|,
name|NULL
block|}
decl_stmt|;
comment|/* Not all binary expressions can be applied to ranges in a      meaningful way.  Handle only arithmetic operations.  */
if|if
condition|(
name|code
operator|!=
name|PLUS_EXPR
operator|&&
name|code
operator|!=
name|MINUS_EXPR
operator|&&
name|code
operator|!=
name|MULT_EXPR
operator|&&
name|code
operator|!=
name|TRUNC_DIV_EXPR
operator|&&
name|code
operator|!=
name|FLOOR_DIV_EXPR
operator|&&
name|code
operator|!=
name|CEIL_DIV_EXPR
operator|&&
name|code
operator|!=
name|EXACT_DIV_EXPR
operator|&&
name|code
operator|!=
name|ROUND_DIV_EXPR
operator|&&
name|code
operator|!=
name|MIN_EXPR
operator|&&
name|code
operator|!=
name|MAX_EXPR
operator|&&
name|code
operator|!=
name|BIT_AND_EXPR
operator|&&
name|code
operator|!=
name|TRUTH_ANDIF_EXPR
operator|&&
name|code
operator|!=
name|TRUTH_ORIF_EXPR
operator|&&
name|code
operator|!=
name|TRUTH_AND_EXPR
operator|&&
name|code
operator|!=
name|TRUTH_OR_EXPR
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get value ranges for each operand.  For constant operands, create      a new value range with the operand to simplify processing.  */
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|vr0
operator|=
operator|*
operator|(
name|get_value_range
argument_list|(
name|op0
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|op0
argument_list|)
condition|)
name|set_value_range_to_value
argument_list|(
operator|&
name|vr0
argument_list|,
name|op0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|set_value_range_to_varying
argument_list|(
operator|&
name|vr0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|vr1
operator|=
operator|*
operator|(
name|get_value_range
argument_list|(
name|op1
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|op1
argument_list|)
condition|)
name|set_value_range_to_value
argument_list|(
operator|&
name|vr1
argument_list|,
name|op1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|set_value_range_to_varying
argument_list|(
operator|&
name|vr1
argument_list|)
expr_stmt|;
comment|/* If either range is UNDEFINED, so is the result.  */
if|if
condition|(
name|vr0
operator|.
name|type
operator|==
name|VR_UNDEFINED
operator|||
name|vr1
operator|.
name|type
operator|==
name|VR_UNDEFINED
condition|)
block|{
name|set_value_range_to_undefined
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The type of the resulting value range defaults to VR0.TYPE.  */
name|type
operator|=
name|vr0
operator|.
name|type
expr_stmt|;
comment|/* Refuse to operate on VARYING ranges, ranges of different kinds      and symbolic ranges.  As an exception, we allow BIT_AND_EXPR      because we may be able to derive a useful range even if one of      the operands is VR_VARYING or symbolic range.  TODO, we may be      able to derive anti-ranges in some cases.  */
if|if
condition|(
name|code
operator|!=
name|BIT_AND_EXPR
operator|&&
name|code
operator|!=
name|TRUTH_AND_EXPR
operator|&&
name|code
operator|!=
name|TRUTH_OR_EXPR
operator|&&
operator|(
name|vr0
operator|.
name|type
operator|==
name|VR_VARYING
operator|||
name|vr1
operator|.
name|type
operator|==
name|VR_VARYING
operator|||
name|vr0
operator|.
name|type
operator|!=
name|vr1
operator|.
name|type
operator|||
name|symbolic_range_p
argument_list|(
operator|&
name|vr0
argument_list|)
operator|||
name|symbolic_range_p
argument_list|(
operator|&
name|vr1
argument_list|)
operator|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now evaluate the expression to determine the new range.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* For pointer types, we are really only interested in asserting 	 whether the expression evaluates to non-NULL.  FIXME, we used 	 to gcc_assert (code == PLUS_EXPR || code == MINUS_EXPR), but 	 ivopts is generating expressions with pointer multiplication 	 in them.  */
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
block|{
if|if
condition|(
name|range_is_nonnull
argument_list|(
operator|&
name|vr0
argument_list|)
operator|||
name|range_is_nonnull
argument_list|(
operator|&
name|vr1
argument_list|)
condition|)
name|set_value_range_to_nonnull
argument_list|(
name|vr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|range_is_null
argument_list|(
operator|&
name|vr0
argument_list|)
operator|&&
name|range_is_null
argument_list|(
operator|&
name|vr1
argument_list|)
condition|)
name|set_value_range_to_null
argument_list|(
name|vr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Subtracting from a pointer, may yield 0, so just drop the 	     resulting range to varying.  */
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* For integer ranges, apply the operation to each end of the      range and see what we end up with.  */
if|if
condition|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
condition|)
block|{
comment|/* If one of the operands is zero, we know that the whole 	 expression evaluates zero.  */
if|if
condition|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|&&
operator|(
operator|(
name|vr0
operator|.
name|type
operator|==
name|VR_RANGE
operator|&&
name|integer_zerop
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
operator|)
operator|||
operator|(
name|vr1
operator|.
name|type
operator|==
name|VR_RANGE
operator|&&
name|integer_zerop
argument_list|(
name|vr1
operator|.
name|min
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|vr1
operator|.
name|max
argument_list|)
operator|)
operator|)
condition|)
block|{
name|type
operator|=
name|VR_RANGE
expr_stmt|;
name|min
operator|=
name|max
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If one of the operands is one, we know that the whole 	 expression evaluates one.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|TRUTH_OR_EXPR
operator|&&
operator|(
operator|(
name|vr0
operator|.
name|type
operator|==
name|VR_RANGE
operator|&&
name|integer_onep
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
operator|)
operator|||
operator|(
name|vr1
operator|.
name|type
operator|==
name|VR_RANGE
operator|&&
name|integer_onep
argument_list|(
name|vr1
operator|.
name|min
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|vr1
operator|.
name|max
argument_list|)
operator|)
operator|)
condition|)
block|{
name|type
operator|=
name|VR_RANGE
expr_stmt|;
name|min
operator|=
name|max
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vr0
operator|.
name|type
operator|!=
name|VR_VARYING
operator|&&
name|vr1
operator|.
name|type
operator|!=
name|VR_VARYING
operator|&&
name|vr0
operator|.
name|type
operator|==
name|vr1
operator|.
name|type
operator|&&
operator|!
name|symbolic_range_p
argument_list|(
operator|&
name|vr0
argument_list|)
operator|&&
operator|!
name|overflow_infinity_range_p
argument_list|(
operator|&
name|vr0
argument_list|)
operator|&&
operator|!
name|symbolic_range_p
argument_list|(
operator|&
name|vr1
argument_list|)
operator|&&
operator|!
name|overflow_infinity_range_p
argument_list|(
operator|&
name|vr1
argument_list|)
condition|)
block|{
comment|/* Boolean expressions cannot be folded with int_const_binop.  */
name|min
operator|=
name|fold_binary
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|vr0
operator|.
name|min
argument_list|,
name|vr1
operator|.
name|min
argument_list|)
expr_stmt|;
name|max
operator|=
name|fold_binary
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|vr0
operator|.
name|max
argument_list|,
name|vr1
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MIN_EXPR
operator|||
name|code
operator|==
name|MAX_EXPR
condition|)
block|{
comment|/* If we have a PLUS_EXPR with two VR_ANTI_RANGEs, drop to 	 VR_VARYING.  It would take more effort to compute a precise 	 range for such a case.  For example, if we have op0 == 1 and 	 op1 == -1 with their ranges both being ~[0,0], we would have 	 op0 + op1 == 0, so we cannot claim that the sum is in ~[0,0]. 	 Note that we are guaranteed to have vr0.type == vr1.type at 	 this point.  */
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|vr0
operator|.
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* For operations that make the resulting range directly 	 proportional to the original ranges, apply the operation to 	 the same end of each range.  */
name|min
operator|=
name|vrp_int_const_binop
argument_list|(
name|code
argument_list|,
name|vr0
operator|.
name|min
argument_list|,
name|vr1
operator|.
name|min
argument_list|)
expr_stmt|;
name|max
operator|=
name|vrp_int_const_binop
argument_list|(
name|code
argument_list|,
name|vr0
operator|.
name|max
argument_list|,
name|vr1
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|||
name|code
operator|==
name|TRUNC_DIV_EXPR
operator|||
name|code
operator|==
name|FLOOR_DIV_EXPR
operator|||
name|code
operator|==
name|CEIL_DIV_EXPR
operator|||
name|code
operator|==
name|EXACT_DIV_EXPR
operator|||
name|code
operator|==
name|ROUND_DIV_EXPR
condition|)
block|{
name|tree
name|val
index|[
literal|4
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|bool
name|sop
decl_stmt|;
comment|/* If we have an unsigned MULT_EXPR with two VR_ANTI_RANGEs, 	 drop to VR_VARYING.  It would take more effort to compute a 	 precise range for such a case.  For example, if we have 	 op0 == 65536 and op1 == 65536 with their ranges both being 	 ~[0,0] on a 32-bit machine, we would have op0 * op1 == 0, so 	 we cannot claim that the product is in ~[0,0].  Note that we 	 are guaranteed to have vr0.type == vr1.type at this 	 point.  */
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|&&
name|vr0
operator|.
name|type
operator|==
name|VR_ANTI_RANGE
operator|&&
operator|!
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Multiplications and divisions are a bit tricky to handle, 	 depending on the mix of signs we have in the two ranges, we 	 need to operate on different values to get the minimum and 	 maximum values for the new range.  One approach is to figure 	 out all the variations of range combinations and do the 	 operations.  	 However, this involves several calls to compare_values and it 	 is pretty convoluted.  It's simpler to do the 4 operations 	 (MIN0 OP MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP 	 MAX1) and then figure the smallest and largest values to form 	 the new range.  */
comment|/* Divisions by zero result in a VARYING value.  */
if|if
condition|(
name|code
operator|!=
name|MULT_EXPR
operator|&&
operator|(
name|vr0
operator|.
name|type
operator|==
name|VR_ANTI_RANGE
operator|||
name|range_includes_zero_p
argument_list|(
operator|&
name|vr1
argument_list|)
operator|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Compute the 4 cross operations.  */
name|sop
operator|=
name|false
expr_stmt|;
name|val
index|[
literal|0
index|]
operator|=
name|vrp_int_const_binop
argument_list|(
name|code
argument_list|,
name|vr0
operator|.
name|min
argument_list|,
name|vr1
operator|.
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
index|[
literal|0
index|]
operator|==
name|NULL_TREE
condition|)
name|sop
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|vr1
operator|.
name|max
operator|==
name|vr1
operator|.
name|min
condition|)
name|val
index|[
literal|1
index|]
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|val
index|[
literal|1
index|]
operator|=
name|vrp_int_const_binop
argument_list|(
name|code
argument_list|,
name|vr0
operator|.
name|min
argument_list|,
name|vr1
operator|.
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
index|[
literal|1
index|]
operator|==
name|NULL_TREE
condition|)
name|sop
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|vr0
operator|.
name|max
operator|==
name|vr0
operator|.
name|min
condition|)
name|val
index|[
literal|2
index|]
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|val
index|[
literal|2
index|]
operator|=
name|vrp_int_const_binop
argument_list|(
name|code
argument_list|,
name|vr0
operator|.
name|max
argument_list|,
name|vr1
operator|.
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
index|[
literal|2
index|]
operator|==
name|NULL_TREE
condition|)
name|sop
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|vr0
operator|.
name|min
operator|==
name|vr0
operator|.
name|max
operator|||
name|vr1
operator|.
name|min
operator|==
name|vr1
operator|.
name|max
condition|)
name|val
index|[
literal|3
index|]
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|val
index|[
literal|3
index|]
operator|=
name|vrp_int_const_binop
argument_list|(
name|code
argument_list|,
name|vr0
operator|.
name|max
argument_list|,
name|vr1
operator|.
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
index|[
literal|3
index|]
operator|==
name|NULL_TREE
condition|)
name|sop
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|sop
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set MIN to the minimum of VAL[i] and MAX to the maximum 	 of VAL[i].  */
name|min
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|max
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|min
argument_list|)
operator|||
operator|(
name|TREE_OVERFLOW
argument_list|(
name|min
argument_list|)
operator|&&
operator|!
name|is_overflow_infinity
argument_list|(
name|min
argument_list|)
operator|)
operator|||
operator|!
name|is_gimple_min_invariant
argument_list|(
name|max
argument_list|)
operator|||
operator|(
name|TREE_OVERFLOW
argument_list|(
name|max
argument_list|)
operator|&&
operator|!
name|is_overflow_infinity
argument_list|(
name|max
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|val
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|val
index|[
name|i
index|]
argument_list|)
operator|||
operator|(
name|TREE_OVERFLOW
argument_list|(
name|val
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|is_overflow_infinity
argument_list|(
name|val
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* If we found an overflowed value, set MIN and MAX 		     to it so that we set the resulting range to 		     VARYING.  */
name|min
operator|=
name|max
operator|=
name|val
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|compare_values
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
name|min
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|min
operator|=
name|val
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|compare_values
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
name|max
argument_list|)
operator|==
literal|1
condition|)
name|max
operator|=
name|val
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
block|{
comment|/* If we have a MINUS_EXPR with two VR_ANTI_RANGEs, drop to 	 VR_VARYING.  It would take more effort to compute a precise 	 range for such a case.  For example, if we have op0 == 1 and 	 op1 == 1 with their ranges both being ~[0,0], we would have 	 op0 - op1 == 0, so we cannot claim that the difference is in 	 ~[0,0].  Note that we are guaranteed to have 	 vr0.type == vr1.type at this point.  */
if|if
condition|(
name|vr0
operator|.
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* For MINUS_EXPR, apply the operation to the opposite ends of 	 each range.  */
name|min
operator|=
name|vrp_int_const_binop
argument_list|(
name|code
argument_list|,
name|vr0
operator|.
name|min
argument_list|,
name|vr1
operator|.
name|max
argument_list|)
expr_stmt|;
name|max
operator|=
name|vrp_int_const_binop
argument_list|(
name|code
argument_list|,
name|vr0
operator|.
name|max
argument_list|,
name|vr1
operator|.
name|min
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|BIT_AND_EXPR
condition|)
block|{
if|if
condition|(
name|vr0
operator|.
name|type
operator|==
name|VR_RANGE
operator|&&
name|vr0
operator|.
name|min
operator|==
name|vr0
operator|.
name|max
operator|&&
name|TREE_CODE
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|min
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|max
operator|=
name|vr0
operator|.
name|max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vr1
operator|.
name|type
operator|==
name|VR_RANGE
operator|&&
name|vr1
operator|.
name|min
operator|==
name|vr1
operator|.
name|max
operator|&&
name|TREE_CODE
argument_list|(
name|vr1
operator|.
name|max
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|vr1
operator|.
name|max
argument_list|)
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|vr1
operator|.
name|max
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|type
operator|=
name|VR_RANGE
expr_stmt|;
name|min
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|max
operator|=
name|vr1
operator|.
name|max
expr_stmt|;
block|}
else|else
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* If either MIN or MAX overflowed, then set the resulting range to      VARYING.  But we do accept an overflow infinity      representation.  */
if|if
condition|(
name|min
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_gimple_min_invariant
argument_list|(
name|min
argument_list|)
operator|||
operator|(
name|TREE_OVERFLOW
argument_list|(
name|min
argument_list|)
operator|&&
operator|!
name|is_overflow_infinity
argument_list|(
name|min
argument_list|)
operator|)
operator|||
name|max
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_gimple_min_invariant
argument_list|(
name|max
argument_list|)
operator|||
operator|(
name|TREE_OVERFLOW
argument_list|(
name|max
argument_list|)
operator|&&
operator|!
name|is_overflow_infinity
argument_list|(
name|max
argument_list|)
operator|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We punt if:      1) [-INF, +INF]      2) [-INF, +-INF(OVF)]      3) [+-INF(OVF), +INF]      4) [+-INF(OVF), +-INF(OVF)]      We learn nothing when we have INF and INF(OVF) on both sides.      Note that we do accept [-INF, -INF] and [+INF, +INF] without      overflow.  */
if|if
condition|(
operator|(
name|vrp_val_is_min
argument_list|(
name|min
argument_list|)
operator|||
name|is_overflow_infinity
argument_list|(
name|min
argument_list|)
operator|)
operator|&&
operator|(
name|vrp_val_is_max
argument_list|(
name|max
argument_list|)
operator|||
name|is_overflow_infinity
argument_list|(
name|max
argument_list|)
operator|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
name|cmp
operator|=
name|compare_values
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
operator|-
literal|2
operator|||
name|cmp
operator|==
literal|1
condition|)
block|{
comment|/* If the new range has its limits swapped around (MIN> MAX), 	 then the operation caused one of them to wrap around, mark 	 the new range VARYING.  */
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
block|}
else|else
name|set_value_range
argument_list|(
name|vr
argument_list|,
name|type
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract range information from a unary expression EXPR based on    the range of its operand and the expression code.  */
end_comment

begin_function
specifier|static
name|void
name|extract_range_from_unary_expr
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|min
decl_stmt|,
name|max
decl_stmt|,
name|op0
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|value_range_t
name|vr0
init|=
block|{
name|VR_UNDEFINED
block|,
name|NULL_TREE
block|,
name|NULL_TREE
block|,
name|NULL
block|}
decl_stmt|;
comment|/* Refuse to operate on certain unary expressions for which we      cannot easily determine a resulting range.  */
if|if
condition|(
name|code
operator|==
name|FIX_TRUNC_EXPR
operator|||
name|code
operator|==
name|FIX_CEIL_EXPR
operator|||
name|code
operator|==
name|FIX_FLOOR_EXPR
operator|||
name|code
operator|==
name|FIX_ROUND_EXPR
operator|||
name|code
operator|==
name|FLOAT_EXPR
operator|||
name|code
operator|==
name|BIT_NOT_EXPR
operator|||
name|code
operator|==
name|NON_LVALUE_EXPR
operator|||
name|code
operator|==
name|CONJ_EXPR
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get value ranges for the operand.  For constant operands, create      a new value range with the operand to simplify processing.  */
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|vr0
operator|=
operator|*
operator|(
name|get_value_range
argument_list|(
name|op0
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|op0
argument_list|)
condition|)
name|set_value_range_to_value
argument_list|(
operator|&
name|vr0
argument_list|,
name|op0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|set_value_range_to_varying
argument_list|(
operator|&
name|vr0
argument_list|)
expr_stmt|;
comment|/* If VR0 is UNDEFINED, so is the result.  */
if|if
condition|(
name|vr0
operator|.
name|type
operator|==
name|VR_UNDEFINED
condition|)
block|{
name|set_value_range_to_undefined
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Refuse to operate on symbolic ranges, or if neither operand is      a pointer or integral type.  */
if|if
condition|(
operator|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|vr0
operator|.
name|type
operator|!=
name|VR_VARYING
operator|&&
name|symbolic_range_p
argument_list|(
operator|&
name|vr0
argument_list|)
operator|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the expression involves pointers, we are only interested in      determining if it evaluates to NULL [0, 0] or non-NULL (~[0, 0]).  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
name|bool
name|sop
decl_stmt|;
name|sop
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|range_is_nonnull
argument_list|(
operator|&
name|vr0
argument_list|)
operator|||
operator|(
name|tree_expr_nonzero_warnv_p
argument_list|(
name|expr
argument_list|,
operator|&
name|sop
argument_list|)
operator|&&
operator|!
name|sop
operator|)
condition|)
name|set_value_range_to_nonnull
argument_list|(
name|vr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|range_is_null
argument_list|(
operator|&
name|vr0
argument_list|)
condition|)
name|set_value_range_to_null
argument_list|(
name|vr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle unary expressions on integer ranges.  */
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|outer_type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* If VR0 represents a simple range, then try to convert 	 the min and max values for the range to the same type 	 as OUTER_TYPE.  If the results compare equal to VR0's 	 min and max values and the new min is still less than 	 or equal to the new max, then we can safely use the newly 	 computed range for EXPR.  This allows us to compute 	 accurate ranges through many casts.  */
if|if
condition|(
operator|(
name|vr0
operator|.
name|type
operator|==
name|VR_RANGE
operator|&&
operator|!
name|overflow_infinity_range_p
argument_list|(
operator|&
name|vr0
argument_list|)
operator|)
operator|||
operator|(
name|vr0
operator|.
name|type
operator|==
name|VR_VARYING
operator|&&
name|TYPE_PRECISION
argument_list|(
name|outer_type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|inner_type
argument_list|)
operator|)
condition|)
block|{
name|tree
name|new_min
decl_stmt|,
name|new_max
decl_stmt|,
name|orig_min
decl_stmt|,
name|orig_max
decl_stmt|;
comment|/* Convert the input operand min/max to OUTER_TYPE.   If 	     the input has no range information, then use the min/max 	     for the input's type.  */
if|if
condition|(
name|vr0
operator|.
name|type
operator|==
name|VR_RANGE
condition|)
block|{
name|orig_min
operator|=
name|vr0
operator|.
name|min
expr_stmt|;
name|orig_max
operator|=
name|vr0
operator|.
name|max
expr_stmt|;
block|}
else|else
block|{
name|orig_min
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|inner_type
argument_list|)
expr_stmt|;
name|orig_max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|inner_type
argument_list|)
expr_stmt|;
block|}
name|new_min
operator|=
name|fold_convert
argument_list|(
name|outer_type
argument_list|,
name|orig_min
argument_list|)
expr_stmt|;
name|new_max
operator|=
name|fold_convert
argument_list|(
name|outer_type
argument_list|,
name|orig_max
argument_list|)
expr_stmt|;
comment|/* Verify the new min/max values are gimple values and 	     that they compare equal to the original input's 	     min/max values.  */
if|if
condition|(
name|is_gimple_val
argument_list|(
name|new_min
argument_list|)
operator|&&
name|is_gimple_val
argument_list|(
name|new_max
argument_list|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|new_min
argument_list|,
name|orig_min
argument_list|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|new_max
argument_list|,
name|orig_max
argument_list|)
operator|&&
operator|(
operator|!
name|is_overflow_infinity
argument_list|(
name|new_min
argument_list|)
operator|||
operator|!
name|is_overflow_infinity
argument_list|(
name|new_max
argument_list|)
operator|)
operator|&&
name|compare_values
argument_list|(
name|new_min
argument_list|,
name|new_max
argument_list|)
operator|<=
literal|0
operator|&&
name|compare_values
argument_list|(
name|new_min
argument_list|,
name|new_max
argument_list|)
operator|>=
operator|-
literal|1
condition|)
block|{
name|set_value_range
argument_list|(
name|vr
argument_list|,
name|VR_RANGE
argument_list|,
name|new_min
argument_list|,
name|new_max
argument_list|,
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* When converting types of different sizes, set the result to 	 VARYING.  Things like sign extensions and precision loss may 	 change the range.  For instance, if x_3 is of type 'long long 	 int' and 'y_5 = (unsigned short) x_3', if x_3 is ~[0, 0], it 	 is impossible to know at compile time whether y_5 will be 	 ~[0, 0].  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|inner_type
argument_list|)
operator|!=
name|TYPE_SIZE
argument_list|(
name|outer_type
argument_list|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|inner_type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|outer_type
argument_list|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Conversion of a VR_VARYING value to a wider type can result      in a usable range.  So wait until after we've handled conversions      before dropping the result to VR_VARYING if we had a source      operand that is VR_VARYING.  */
if|if
condition|(
name|vr0
operator|.
name|type
operator|==
name|VR_VARYING
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Apply the operation to each end of the range and see what we end      up with.  */
if|if
condition|(
name|code
operator|==
name|NEGATE_EXPR
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
comment|/* NEGATE_EXPR flips the range around.  We need to treat 	 TYPE_MIN_VALUE specially.  */
if|if
condition|(
name|is_positive_overflow_infinity
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
condition|)
name|min
operator|=
name|negative_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_negative_overflow_infinity
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
condition|)
name|min
operator|=
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|vrp_val_is_min
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
condition|)
name|min
operator|=
name|fold_unary_to_constant
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|vr0
operator|.
name|max
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
operator|!
name|is_overflow_infinity
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
operator|&&
operator|!
name|vrp_val_is_min
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
condition|)
name|min
operator|=
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|min
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_positive_overflow_infinity
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
condition|)
name|max
operator|=
name|negative_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_negative_overflow_infinity
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
condition|)
name|max
operator|=
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|vrp_val_is_min
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
condition|)
name|max
operator|=
name|fold_unary_to_constant
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|vr0
operator|.
name|min
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|max
operator|=
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|max
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|NEGATE_EXPR
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|range_includes_zero_p
argument_list|(
operator|&
name|vr0
argument_list|)
condition|)
block|{
name|max
operator|=
name|fold_unary_to_constant
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|vr0
operator|.
name|min
argument_list|)
expr_stmt|;
name|min
operator|=
name|fold_unary_to_constant
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|vr0
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|range_is_null
argument_list|(
operator|&
name|vr0
argument_list|)
condition|)
name|set_value_range_to_null
argument_list|(
name|vr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ABS_EXPR
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
comment|/* -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get a          useful range.  */
if|if
condition|(
operator|!
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|vr0
operator|.
name|type
operator|==
name|VR_RANGE
operator|&&
name|vrp_val_is_min
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
operator|)
operator|||
operator|(
name|vr0
operator|.
name|type
operator|==
name|VR_ANTI_RANGE
operator|&&
operator|!
name|vrp_val_is_min
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
operator|&&
operator|!
name|range_includes_zero_p
argument_list|(
operator|&
name|vr0
argument_list|)
operator|)
operator|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ABS_EXPR may flip the range around, if the original range 	 included negative values.  */
if|if
condition|(
name|is_overflow_infinity
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
condition|)
name|min
operator|=
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|vrp_val_is_min
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
condition|)
name|min
operator|=
name|fold_unary_to_constant
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|vr0
operator|.
name|min
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|min
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|min
operator|=
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_overflow_infinity
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
condition|)
name|max
operator|=
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|vrp_val_is_min
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
condition|)
name|max
operator|=
name|fold_unary_to_constant
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|vr0
operator|.
name|max
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|max
operator|=
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
name|cmp
operator|=
name|compare_values
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
comment|/* If a VR_ANTI_RANGEs contains zero, then we have 	 ~[-INF, min(MIN, MAX)].  */
if|if
condition|(
name|vr0
operator|.
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
block|{
if|if
condition|(
name|range_includes_zero_p
argument_list|(
operator|&
name|vr0
argument_list|)
condition|)
block|{
comment|/* Take the lower of the two values.  */
if|if
condition|(
name|cmp
operator|!=
literal|1
condition|)
name|max
operator|=
name|min
expr_stmt|;
comment|/* Create ~[-INF, min (abs(MIN), abs(MAX))] 	         or ~[-INF + 1, min (abs(MIN), abs(MAX))] when 		 flag_wrapv is set and the original anti-range doesn't include 	         TYPE_MIN_VALUE, remember -TYPE_MIN_VALUE = TYPE_MIN_VALUE.  */
if|if
condition|(
name|TYPE_OVERFLOW_WRAPS
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type_min_value
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|min
operator|=
operator|(
name|vr0
operator|.
name|min
operator|!=
name|type_min_value
condition|?
name|int_const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type_min_value
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
else|:
name|type_min_value
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|overflow_infinity_range_p
argument_list|(
operator|&
name|vr0
argument_list|)
condition|)
name|min
operator|=
name|negative_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|min
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* All else has failed, so create the range [0, INF], even for 	         flag_wrapv since TYPE_MIN_VALUE is in the original 	         anti-range.  */
name|vr0
operator|.
name|type
operator|=
name|VR_RANGE
expr_stmt|;
name|min
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|max
operator|=
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the range contains zero then we know that the minimum value in the          range will be zero.  */
elseif|else
if|if
condition|(
name|range_includes_zero_p
argument_list|(
operator|&
name|vr0
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmp
operator|==
literal|1
condition|)
name|max
operator|=
name|min
expr_stmt|;
name|min
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the range was reversed, swap MIN and MAX.  */
if|if
condition|(
name|cmp
operator|==
literal|1
condition|)
block|{
name|tree
name|t
init|=
name|min
decl_stmt|;
name|min
operator|=
name|max
expr_stmt|;
name|max
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Otherwise, operate on each end of the range.  */
name|min
operator|=
name|fold_unary_to_constant
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|vr0
operator|.
name|min
argument_list|)
expr_stmt|;
name|max
operator|=
name|fold_unary_to_constant
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|vr0
operator|.
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|code
operator|!=
name|NEGATE_EXPR
operator|&&
name|code
operator|!=
name|ABS_EXPR
argument_list|)
expr_stmt|;
comment|/* If both sides have overflowed, we don't know 	     anything.  */
if|if
condition|(
operator|(
name|is_overflow_infinity
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
operator|||
name|TREE_OVERFLOW
argument_list|(
name|min
argument_list|)
operator|)
operator|&&
operator|(
name|is_overflow_infinity
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
operator|||
name|TREE_OVERFLOW
argument_list|(
name|max
argument_list|)
operator|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_overflow_infinity
argument_list|(
name|vr0
operator|.
name|min
argument_list|)
condition|)
name|min
operator|=
name|vr0
operator|.
name|min
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|min
argument_list|)
condition|)
block|{
if|if
condition|(
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|min
operator|=
operator|(
name|tree_int_cst_sgn
argument_list|(
name|min
argument_list|)
operator|>=
literal|0
condition|?
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|min
argument_list|)
argument_list|)
else|:
name|negative_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|min
argument_list|)
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|is_overflow_infinity
argument_list|(
name|vr0
operator|.
name|max
argument_list|)
condition|)
name|max
operator|=
name|vr0
operator|.
name|max
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|max
argument_list|)
condition|)
block|{
if|if
condition|(
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|max
operator|=
operator|(
name|tree_int_cst_sgn
argument_list|(
name|max
argument_list|)
operator|>=
literal|0
condition|?
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|max
argument_list|)
argument_list|)
else|:
name|negative_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|max
argument_list|)
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
name|cmp
operator|=
name|compare_values
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
operator|-
literal|2
operator|||
name|cmp
operator|==
literal|1
condition|)
block|{
comment|/* If the new range has its limits swapped around (MIN> MAX), 	 then the operation caused one of them to wrap around, mark 	 the new range VARYING.  */
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
block|}
else|else
name|set_value_range
argument_list|(
name|vr
argument_list|,
name|vr0
operator|.
name|type
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract range information from a comparison expression EXPR based    on the range of its operand and the expression code.  */
end_comment

begin_function
specifier|static
name|void
name|extract_range_from_comparison
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|bool
name|sop
init|=
name|false
decl_stmt|;
name|tree
name|val
init|=
name|vrp_evaluate_conditional_warnv
argument_list|(
name|expr
argument_list|,
name|false
argument_list|,
operator|&
name|sop
argument_list|)
decl_stmt|;
comment|/* A disadvantage of using a special infinity as an overflow      representation is that we lose the ability to record overflow      when we don't have an infinity.  So we have to ignore a result      which relies on overflow.  */
if|if
condition|(
name|val
operator|&&
operator|!
name|is_overflow_infinity
argument_list|(
name|val
argument_list|)
operator|&&
operator|!
name|sop
condition|)
block|{
comment|/* Since this expression was found on the RHS of an assignment, 	 its type may be different from _Bool.  Convert VAL to EXPR's 	 type.  */
name|val
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
condition|)
name|set_value_range_to_value
argument_list|(
name|vr
argument_list|,
name|val
argument_list|,
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
else|else
name|set_value_range
argument_list|(
name|vr
argument_list|,
name|VR_RANGE
argument_list|,
name|val
argument_list|,
name|val
argument_list|,
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
else|else
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to compute a useful range out of expression EXPR and store it    in *VR.  */
end_comment

begin_function
specifier|static
name|void
name|extract_range_from_expr
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|ASSERT_EXPR
condition|)
name|extract_range_from_assert
argument_list|(
name|vr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|SSA_NAME
condition|)
name|extract_range_from_ssa_name
argument_list|(
name|vr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_binary
operator|||
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code
operator|==
name|TRUTH_XOR_EXPR
condition|)
name|extract_range_from_binary_expr
argument_list|(
name|vr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
condition|)
name|extract_range_from_unary_expr
argument_list|(
name|vr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
condition|)
name|extract_range_from_comparison
argument_list|(
name|vr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
condition|)
name|set_value_range_to_value
argument_list|(
name|vr
argument_list|,
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|set_value_range_to_varying
argument_list|(
name|vr
argument_list|)
expr_stmt|;
comment|/* If we got a varying range from the tests above, try a final      time to derive a nonnegative or nonzero range.  This time      relying primarily on generic routines in fold in conjunction      with range data.  */
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_VARYING
condition|)
block|{
name|bool
name|sop
init|=
name|false
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|vrp_expr_computes_nonnegative
argument_list|(
name|expr
argument_list|,
operator|&
name|sop
argument_list|)
condition|)
name|set_value_range_to_nonnegative
argument_list|(
name|vr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|sop
operator|||
name|is_overflow_infinity
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vrp_expr_computes_nonzero
argument_list|(
name|expr
argument_list|,
operator|&
name|sop
argument_list|)
operator|&&
operator|!
name|sop
condition|)
name|set_value_range_to_nonnull
argument_list|(
name|vr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a range VR, a LOOP and a variable VAR, determine whether it    would be profitable to adjust VR using scalar evolution information    for VAR.  If so, update VR with the new limits.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_range_with_scev
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|tree
name|init
decl_stmt|,
name|step
decl_stmt|,
name|chrec
decl_stmt|,
name|tmin
decl_stmt|,
name|tmax
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|,
name|type
decl_stmt|;
name|enum
name|ev_direction
name|dir
decl_stmt|;
comment|/* TODO.  Don't adjust anti-ranges.  An anti-range may provide      better opportunities than a regular range, but I'm not sure.  */
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
return|return;
name|chrec
operator|=
name|instantiate_parameters
argument_list|(
name|loop
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|!=
name|POLYNOMIAL_CHREC
condition|)
return|return;
name|init
operator|=
name|initial_condition_in_loop_num
argument_list|(
name|chrec
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|step
operator|=
name|evolution_part_in_loop_num
argument_list|(
name|chrec
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
comment|/* If STEP is symbolic, we can't know whether INIT will be the      minimum or maximum value in the range.  Also, unless INIT is      a simple expression, compare_values and possibly other functions      in tree-vrp won't be able to handle it.  */
if|if
condition|(
name|step
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_gimple_min_invariant
argument_list|(
name|step
argument_list|)
operator|||
operator|!
name|valid_value_p
argument_list|(
name|init
argument_list|)
condition|)
return|return;
name|dir
operator|=
name|scev_direction
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* Do not adjust ranges if we do not know whether the iv increases 	 or decreases,  ... */
name|dir
operator|==
name|EV_DIR_UNKNOWN
comment|/* ... or if it may wrap.  */
operator|||
name|scev_probably_wraps_p
argument_list|(
name|init
argument_list|,
name|step
argument_list|,
name|stmt
argument_list|,
name|current_loops
operator|->
name|parray
index|[
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
index|]
argument_list|,
name|true
argument_list|)
condition|)
return|return;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* If we see a pointer type starting at a constant, then we have an      unusual ivopt.  It may legitimately wrap.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|init
argument_list|)
condition|)
return|return;
comment|/* We use TYPE_MIN_VALUE and TYPE_MAX_VALUE here instead of      negative_overflow_infinity and positive_overflow_infinity,      because we have concluded that the loop probably does not      wrap.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
condition|)
name|tmin
operator|=
name|lower_bound_in_type
argument_list|(
name|type
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|tmin
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
condition|)
name|tmax
operator|=
name|upper_bound_in_type
argument_list|(
name|type
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|tmax
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_VARYING
operator|||
name|vr
operator|->
name|type
operator|==
name|VR_UNDEFINED
condition|)
block|{
name|min
operator|=
name|tmin
expr_stmt|;
name|max
operator|=
name|tmax
expr_stmt|;
comment|/* For VARYING or UNDEFINED ranges, just about anything we get 	 from scalar evolutions should be better.  */
if|if
condition|(
name|dir
operator|==
name|EV_DIR_DECREASES
condition|)
name|max
operator|=
name|init
expr_stmt|;
else|else
name|min
operator|=
name|init
expr_stmt|;
comment|/* If we would create an invalid range, then just assume we 	 know absolutely nothing.  This may be over-conservative, 	 but it's clearly safe, and should happen only in unreachable          parts of code, or for invalid programs.  */
if|if
condition|(
name|compare_values
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
operator|==
literal|1
condition|)
return|return;
name|set_value_range
argument_list|(
name|vr
argument_list|,
name|VR_RANGE
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_RANGE
condition|)
block|{
name|min
operator|=
name|vr
operator|->
name|min
expr_stmt|;
name|max
operator|=
name|vr
operator|->
name|max
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|EV_DIR_DECREASES
condition|)
block|{
comment|/* INIT is the maximum value.  If INIT is lower than VR->MAX 	     but no smaller than VR->MIN, set VR->MAX to INIT.  */
if|if
condition|(
name|compare_values
argument_list|(
name|init
argument_list|,
name|max
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|max
operator|=
name|init
expr_stmt|;
comment|/* If we just created an invalid range with the minimum 		 greater than the maximum, we fail conservatively. 		 This should happen only in unreachable 		 parts of code, or for invalid programs.  */
if|if
condition|(
name|compare_values
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
operator|==
literal|1
condition|)
return|return;
block|}
comment|/* According to the loop information, the variable does not 	     overflow.  If we think it does, probably because of an 	     overflow due to arithmetic on a different INF value, 	     reset now.  */
if|if
condition|(
name|is_negative_overflow_infinity
argument_list|(
name|min
argument_list|)
condition|)
name|min
operator|=
name|tmin
expr_stmt|;
block|}
else|else
block|{
comment|/* If INIT is bigger than VR->MIN, set VR->MIN to INIT.  */
if|if
condition|(
name|compare_values
argument_list|(
name|init
argument_list|,
name|min
argument_list|)
operator|==
literal|1
condition|)
block|{
name|min
operator|=
name|init
expr_stmt|;
comment|/* Again, avoid creating invalid range by failing.  */
if|if
condition|(
name|compare_values
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
operator|==
literal|1
condition|)
return|return;
block|}
if|if
condition|(
name|is_positive_overflow_infinity
argument_list|(
name|max
argument_list|)
condition|)
name|max
operator|=
name|tmax
expr_stmt|;
block|}
name|set_value_range
argument_list|(
name|vr
argument_list|,
name|VR_RANGE
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|vr
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if VAR may overflow at STMT.  This checks any available    loop information to see if we can determine that VAR does not    overflow.  */
end_comment

begin_function
specifier|static
name|bool
name|vrp_var_may_overflow
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|l
decl_stmt|;
name|tree
name|chrec
decl_stmt|,
name|init
decl_stmt|,
name|step
decl_stmt|;
if|if
condition|(
name|current_loops
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|l
operator|=
name|loop_containing_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|chrec
operator|=
name|instantiate_parameters
argument_list|(
name|l
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|l
argument_list|,
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|!=
name|POLYNOMIAL_CHREC
condition|)
return|return
name|true
return|;
name|init
operator|=
name|initial_condition_in_loop_num
argument_list|(
name|chrec
argument_list|,
name|l
operator|->
name|num
argument_list|)
expr_stmt|;
name|step
operator|=
name|evolution_part_in_loop_num
argument_list|(
name|chrec
argument_list|,
name|l
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_gimple_min_invariant
argument_list|(
name|step
argument_list|)
operator|||
operator|!
name|valid_value_p
argument_list|(
name|init
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If we get here, we know something useful about VAR based on the      loop information.  If it wraps, it may overflow.  */
if|if
condition|(
name|scev_probably_wraps_p
argument_list|(
name|init
argument_list|,
name|step
argument_list|,
name|stmt
argument_list|,
name|current_loops
operator|->
name|parray
index|[
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
index|]
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
operator|!=
literal|0
condition|)
block|{
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|": loop information indicates does not overflow\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Given two numeric value ranges VR0, VR1 and a comparison code COMP:        - Return BOOLEAN_TRUE_NODE if VR0 COMP VR1 always returns true for      all the values in the ranges.     - Return BOOLEAN_FALSE_NODE if the comparison always returns false.     - Return NULL_TREE if it is not always possible to determine the      value of the comparison.     Also set *STRICT_OVERFLOW_P to indicate whether a range with an    overflow infinity was used in the test.  */
end_comment

begin_function
specifier|static
name|tree
name|compare_ranges
parameter_list|(
name|enum
name|tree_code
name|comp
parameter_list|,
name|value_range_t
modifier|*
name|vr0
parameter_list|,
name|value_range_t
modifier|*
name|vr1
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
comment|/* VARYING or UNDEFINED ranges cannot be compared.  */
if|if
condition|(
name|vr0
operator|->
name|type
operator|==
name|VR_VARYING
operator|||
name|vr0
operator|->
name|type
operator|==
name|VR_UNDEFINED
operator|||
name|vr1
operator|->
name|type
operator|==
name|VR_VARYING
operator|||
name|vr1
operator|->
name|type
operator|==
name|VR_UNDEFINED
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Anti-ranges need to be handled separately.  */
if|if
condition|(
name|vr0
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
operator|||
name|vr1
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
block|{
comment|/* If both are anti-ranges, then we cannot compute any 	 comparison.  */
if|if
condition|(
name|vr0
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
operator|&&
name|vr1
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* These comparisons are never statically computable.  */
if|if
condition|(
name|comp
operator|==
name|GT_EXPR
operator|||
name|comp
operator|==
name|GE_EXPR
operator|||
name|comp
operator|==
name|LT_EXPR
operator|||
name|comp
operator|==
name|LE_EXPR
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Equality can be computed only between a range and an 	 anti-range.  ~[VAL1, VAL2] == [VAL1, VAL2] is always false.  */
if|if
condition|(
name|vr0
operator|->
name|type
operator|==
name|VR_RANGE
condition|)
block|{
comment|/* To simplify processing, make VR0 the anti-range.  */
name|value_range_t
modifier|*
name|tmp
init|=
name|vr0
decl_stmt|;
name|vr0
operator|=
name|vr1
expr_stmt|;
name|vr1
operator|=
name|tmp
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|comp
operator|==
name|NE_EXPR
operator|||
name|comp
operator|==
name|EQ_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr1
operator|->
name|min
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|0
operator|&&
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|max
argument_list|,
name|vr1
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|comp
operator|==
name|NE_EXPR
operator|)
condition|?
name|boolean_true_node
else|:
name|boolean_false_node
return|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|usable_range_p
argument_list|(
name|vr0
argument_list|,
name|strict_overflow_p
argument_list|)
operator|||
operator|!
name|usable_range_p
argument_list|(
name|vr1
argument_list|,
name|strict_overflow_p
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Simplify processing.  If COMP is GT_EXPR or GE_EXPR, switch the      operands around and change the comparison code.  */
if|if
condition|(
name|comp
operator|==
name|GT_EXPR
operator|||
name|comp
operator|==
name|GE_EXPR
condition|)
block|{
name|value_range_t
modifier|*
name|tmp
decl_stmt|;
name|comp
operator|=
operator|(
name|comp
operator|==
name|GT_EXPR
operator|)
condition|?
name|LT_EXPR
else|:
name|LE_EXPR
expr_stmt|;
name|tmp
operator|=
name|vr0
expr_stmt|;
name|vr0
operator|=
name|vr1
expr_stmt|;
name|vr1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|==
name|EQ_EXPR
condition|)
block|{
comment|/* Equality may only be computed if both ranges represent 	 exactly one value.  */
if|if
condition|(
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr0
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|0
operator|&&
name|compare_values_warnv
argument_list|(
name|vr1
operator|->
name|min
argument_list|,
name|vr1
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|cmp_min
init|=
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr1
operator|->
name|min
argument_list|,
name|strict_overflow_p
argument_list|)
decl_stmt|;
name|int
name|cmp_max
init|=
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|max
argument_list|,
name|vr1
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp_min
operator|==
literal|0
operator|&&
name|cmp_max
operator|==
literal|0
condition|)
return|return
name|boolean_true_node
return|;
elseif|else
if|if
condition|(
name|cmp_min
operator|!=
operator|-
literal|2
operator|&&
name|cmp_max
operator|!=
operator|-
literal|2
condition|)
return|return
name|boolean_false_node
return|;
block|}
comment|/* If [V0_MIN, V1_MAX]< [V1_MIN, V1_MAX] then V0 != V1.  */
elseif|else
if|if
condition|(
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr1
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|1
operator|||
name|compare_values_warnv
argument_list|(
name|vr1
operator|->
name|min
argument_list|,
name|vr0
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|1
condition|)
return|return
name|boolean_false_node
return|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|==
name|NE_EXPR
condition|)
block|{
name|int
name|cmp1
decl_stmt|,
name|cmp2
decl_stmt|;
comment|/* If VR0 is completely to the left or completely to the right 	 of VR1, they are always different.  Notice that we need to 	 make sure that both comparisons yield similar results to 	 avoid comparing values that cannot be compared at 	 compile-time.  */
name|cmp1
operator|=
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|max
argument_list|,
name|vr1
operator|->
name|min
argument_list|,
name|strict_overflow_p
argument_list|)
expr_stmt|;
name|cmp2
operator|=
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr1
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmp1
operator|==
operator|-
literal|1
operator|&&
name|cmp2
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|cmp1
operator|==
literal|1
operator|&&
name|cmp2
operator|==
literal|1
operator|)
condition|)
return|return
name|boolean_true_node
return|;
comment|/* If VR0 and VR1 represent a single value and are identical, 	 return false.  */
elseif|else
if|if
condition|(
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr0
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|0
operator|&&
name|compare_values_warnv
argument_list|(
name|vr1
operator|->
name|min
argument_list|,
name|vr1
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|0
operator|&&
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr1
operator|->
name|min
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|0
operator|&&
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|max
argument_list|,
name|vr1
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|0
condition|)
return|return
name|boolean_false_node
return|;
comment|/* Otherwise, they may or may not be different.  */
else|else
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|==
name|LT_EXPR
operator|||
name|comp
operator|==
name|LE_EXPR
condition|)
block|{
name|int
name|tst
decl_stmt|;
comment|/* If VR0 is to the left of VR1, return true.  */
name|tst
operator|=
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|max
argument_list|,
name|vr1
operator|->
name|min
argument_list|,
name|strict_overflow_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp
operator|==
name|LT_EXPR
operator|&&
name|tst
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|comp
operator|==
name|LE_EXPR
operator|&&
operator|(
name|tst
operator|==
operator|-
literal|1
operator|||
name|tst
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|overflow_infinity_range_p
argument_list|(
name|vr0
argument_list|)
operator|||
name|overflow_infinity_range_p
argument_list|(
name|vr1
argument_list|)
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|boolean_true_node
return|;
block|}
comment|/* If VR0 is to the right of VR1, return false.  */
name|tst
operator|=
name|compare_values_warnv
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr1
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp
operator|==
name|LT_EXPR
operator|&&
operator|(
name|tst
operator|==
literal|0
operator|||
name|tst
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
name|comp
operator|==
name|LE_EXPR
operator|&&
name|tst
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|overflow_infinity_range_p
argument_list|(
name|vr0
argument_list|)
operator|||
name|overflow_infinity_range_p
argument_list|(
name|vr1
argument_list|)
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|boolean_false_node
return|;
block|}
comment|/* Otherwise, we don't know.  */
return|return
name|NULL_TREE
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a value range VR, a value VAL and a comparison code COMP, return    BOOLEAN_TRUE_NODE if VR COMP VAL always returns true for all the    values in VR.  Return BOOLEAN_FALSE_NODE if the comparison    always returns false.  Return NULL_TREE if it is not always    possible to determine the value of the comparison.  Also set    *STRICT_OVERFLOW_P to indicate whether a range with an overflow    infinity was used in the test.  */
end_comment

begin_function
specifier|static
name|tree
name|compare_range_with_value
parameter_list|(
name|enum
name|tree_code
name|comp
parameter_list|,
name|value_range_t
modifier|*
name|vr
parameter_list|,
name|tree
name|val
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_VARYING
operator|||
name|vr
operator|->
name|type
operator|==
name|VR_UNDEFINED
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Anti-ranges need to be handled separately.  */
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
block|{
comment|/* For anti-ranges, the only predicates that we can compute at 	 compile time are equality and inequality.  */
if|if
condition|(
name|comp
operator|==
name|GT_EXPR
operator|||
name|comp
operator|==
name|GE_EXPR
operator|||
name|comp
operator|==
name|LT_EXPR
operator|||
name|comp
operator|==
name|LE_EXPR
condition|)
return|return
name|NULL_TREE
return|;
comment|/* ~[VAL_1, VAL_2] OP VAL is known if VAL_1<= VAL<= VAL_2.  */
if|if
condition|(
name|value_inside_range
argument_list|(
name|val
argument_list|,
name|vr
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
name|comp
operator|==
name|NE_EXPR
operator|)
condition|?
name|boolean_true_node
else|:
name|boolean_false_node
return|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|usable_range_p
argument_list|(
name|vr
argument_list|,
name|strict_overflow_p
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|comp
operator|==
name|EQ_EXPR
condition|)
block|{
comment|/* EQ_EXPR may only be computed if VR represents exactly 	 one value.  */
if|if
condition|(
name|compare_values_warnv
argument_list|(
name|vr
operator|->
name|min
argument_list|,
name|vr
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|cmp
init|=
name|compare_values_warnv
argument_list|(
name|vr
operator|->
name|min
argument_list|,
name|val
argument_list|,
name|strict_overflow_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
return|return
name|boolean_true_node
return|;
elseif|else
if|if
condition|(
name|cmp
operator|==
operator|-
literal|1
operator|||
name|cmp
operator|==
literal|1
operator|||
name|cmp
operator|==
literal|2
condition|)
return|return
name|boolean_false_node
return|;
block|}
elseif|else
if|if
condition|(
name|compare_values_warnv
argument_list|(
name|val
argument_list|,
name|vr
operator|->
name|min
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|compare_values_warnv
argument_list|(
name|vr
operator|->
name|max
argument_list|,
name|val
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|boolean_false_node
return|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|==
name|NE_EXPR
condition|)
block|{
comment|/* If VAL is not inside VR, then they are always different.  */
if|if
condition|(
name|compare_values_warnv
argument_list|(
name|vr
operator|->
name|max
argument_list|,
name|val
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|compare_values_warnv
argument_list|(
name|vr
operator|->
name|min
argument_list|,
name|val
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|1
condition|)
return|return
name|boolean_true_node
return|;
comment|/* If VR represents exactly one value equal to VAL, then return 	 false.  */
if|if
condition|(
name|compare_values_warnv
argument_list|(
name|vr
operator|->
name|min
argument_list|,
name|vr
operator|->
name|max
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|0
operator|&&
name|compare_values_warnv
argument_list|(
name|vr
operator|->
name|min
argument_list|,
name|val
argument_list|,
name|strict_overflow_p
argument_list|)
operator|==
literal|0
condition|)
return|return
name|boolean_false_node
return|;
comment|/* Otherwise, they may or may not be different.  */
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|==
name|LT_EXPR
operator|||
name|comp
operator|==
name|LE_EXPR
condition|)
block|{
name|int
name|tst
decl_stmt|;
comment|/* If VR is to the left of VAL, return true.  */
name|tst
operator|=
name|compare_values_warnv
argument_list|(
name|vr
operator|->
name|max
argument_list|,
name|val
argument_list|,
name|strict_overflow_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp
operator|==
name|LT_EXPR
operator|&&
name|tst
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|comp
operator|==
name|LE_EXPR
operator|&&
operator|(
name|tst
operator|==
operator|-
literal|1
operator|||
name|tst
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|overflow_infinity_range_p
argument_list|(
name|vr
argument_list|)
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|boolean_true_node
return|;
block|}
comment|/* If VR is to the right of VAL, return false.  */
name|tst
operator|=
name|compare_values_warnv
argument_list|(
name|vr
operator|->
name|min
argument_list|,
name|val
argument_list|,
name|strict_overflow_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp
operator|==
name|LT_EXPR
operator|&&
operator|(
name|tst
operator|==
literal|0
operator|||
name|tst
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
name|comp
operator|==
name|LE_EXPR
operator|&&
name|tst
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|overflow_infinity_range_p
argument_list|(
name|vr
argument_list|)
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|boolean_false_node
return|;
block|}
comment|/* Otherwise, we don't know.  */
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|==
name|GT_EXPR
operator|||
name|comp
operator|==
name|GE_EXPR
condition|)
block|{
name|int
name|tst
decl_stmt|;
comment|/* If VR is to the right of VAL, return true.  */
name|tst
operator|=
name|compare_values_warnv
argument_list|(
name|vr
operator|->
name|min
argument_list|,
name|val
argument_list|,
name|strict_overflow_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp
operator|==
name|GT_EXPR
operator|&&
name|tst
operator|==
literal|1
operator|)
operator|||
operator|(
name|comp
operator|==
name|GE_EXPR
operator|&&
operator|(
name|tst
operator|==
literal|0
operator|||
name|tst
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|overflow_infinity_range_p
argument_list|(
name|vr
argument_list|)
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|boolean_true_node
return|;
block|}
comment|/* If VR is to the left of VAL, return false.  */
name|tst
operator|=
name|compare_values_warnv
argument_list|(
name|vr
operator|->
name|max
argument_list|,
name|val
argument_list|,
name|strict_overflow_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp
operator|==
name|GT_EXPR
operator|&&
operator|(
name|tst
operator|==
operator|-
literal|1
operator|||
name|tst
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|comp
operator|==
name|GE_EXPR
operator|&&
name|tst
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|overflow_infinity_range_p
argument_list|(
name|vr
argument_list|)
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|boolean_false_node
return|;
block|}
comment|/* Otherwise, we don't know.  */
return|return
name|NULL_TREE
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debugging dumps.  */
end_comment

begin_function_decl
name|void
name|dump_value_range
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|value_range_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_value_range
parameter_list|(
name|value_range_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_all_value_ranges
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_all_value_ranges
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_vr_equiv
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_vr_equiv
parameter_list|(
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Dump value range VR to FILE.  */
end_comment

begin_function
name|void
name|dump_value_range
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|value_range_t
modifier|*
name|vr
parameter_list|)
block|{
if|if
condition|(
name|vr
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_UNDEFINED
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"UNDEFINED"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_RANGE
operator|||
name|vr
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|vr
operator|->
name|min
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s["
argument_list|,
operator|(
name|vr
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
operator|)
condition|?
literal|"~"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_negative_overflow_infinity
argument_list|(
name|vr
operator|->
name|min
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-INF(OVF)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|vrp_val_is_min
argument_list|(
name|vr
operator|->
name|min
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-INF"
argument_list|)
expr_stmt|;
else|else
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|vr
operator|->
name|min
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_positive_overflow_infinity
argument_list|(
name|vr
operator|->
name|max
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+INF(OVF)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|vrp_val_is_max
argument_list|(
name|vr
operator|->
name|max
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+INF"
argument_list|)
expr_stmt|;
else|else
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|vr
operator|->
name|max
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vr
operator|->
name|equiv
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  EQUIVALENCES: { "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|vr->equiv
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"} (%u elements)"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_VARYING
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"VARYING"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"INVALID RANGE"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump value range VR to stderr.  */
end_comment

begin_function
name|void
name|debug_value_range
parameter_list|(
name|value_range_t
modifier|*
name|vr
parameter_list|)
block|{
name|dump_value_range
argument_list|(
name|stderr
argument_list|,
name|vr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump value ranges of all SSA_NAMEs to FILE.  */
end_comment

begin_function
name|void
name|dump_all_value_ranges
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vr_value
index|[
name|i
index|]
condition|)
block|{
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|dump_value_range
argument_list|(
name|file
argument_list|,
name|vr_value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump all value ranges to stderr.  */
end_comment

begin_function
name|void
name|debug_all_value_ranges
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_all_value_ranges
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,    create a new SSA name N and return the assertion assignment    'V = ASSERT_EXPR<V, V OP W>'.  */
end_comment

begin_function
specifier|static
name|tree
name|build_assert_expr_for
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|v
parameter_list|)
block|{
name|tree
name|n
decl_stmt|,
name|assertion
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|v
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|n
operator|=
name|duplicate_ssa_name
argument_list|(
name|v
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|tree
name|a
init|=
name|build2
argument_list|(
name|ASSERT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|,
name|v
argument_list|,
name|cond
argument_list|)
decl_stmt|;
name|assertion
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
block|{
comment|/* Given !V, build the assignment N = false.  */
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|op0
operator|==
name|v
argument_list|)
expr_stmt|;
name|assertion
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|,
name|n
argument_list|,
name|boolean_false_node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
comment|/* Given V, build the assignment N = true.  */
name|gcc_assert
argument_list|(
name|v
operator|==
name|cond
argument_list|)
expr_stmt|;
name|assertion
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|,
name|n
argument_list|,
name|boolean_true_node
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|n
argument_list|)
operator|=
name|assertion
expr_stmt|;
comment|/* The new ASSERT_EXPR, creates a new SSA name that replaces the      operand of the ASSERT_EXPR. Register the new name and the old one      in the replacement table so that we can fix the SSA web after      adding all the ASSERT_EXPRs.  */
name|register_new_name_mapping
argument_list|(
name|n
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|assertion
return|;
block|}
end_function

begin_comment
comment|/* Return false if EXPR is a predicate expression involving floating    point values.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|fp_predicate
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
return|return
operator|(
name|COMPARISON_CLASS_P
argument_list|(
name|expr
argument_list|)
operator|&&
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If the range of values taken by OP can be inferred after STMT executes,    return the comparison code (COMP_CODE_P) and value (VAL_P) that    describes the inferred range.  Return true if a range could be    inferred.  */
end_comment

begin_function
specifier|static
name|bool
name|infer_value_range
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|op
parameter_list|,
name|enum
name|tree_code
modifier|*
name|comp_code_p
parameter_list|,
name|tree
modifier|*
name|val_p
parameter_list|)
block|{
operator|*
name|val_p
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|comp_code_p
operator|=
name|ERROR_MARK
expr_stmt|;
comment|/* Do not attempt to infer anything in names that flow through      abnormal edges.  */
if|if
condition|(
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Similarly, don't infer anything from statements that may throw      exceptions.  */
if|if
condition|(
name|tree_could_throw_p
argument_list|(
name|stmt
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If STMT is the last statement of a basic block with no      successors, there is no point inferring anything about any of its      operands.  We would not be able to find a proper insertion point      for the assertion, anyway.  */
if|if
condition|(
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
operator|&&
name|EDGE_COUNT
argument_list|(
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|->
name|succs
argument_list|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* We can only assume that a pointer dereference will yield      non-NULL if -fdelete-null-pointer-checks is enabled.  */
if|if
condition|(
name|flag_delete_null_pointer_checks
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
block|{
name|bool
name|is_store
decl_stmt|;
name|unsigned
name|num_uses
decl_stmt|,
name|num_derefs
decl_stmt|;
name|count_uses_and_derefs
argument_list|(
name|op
argument_list|,
name|stmt
argument_list|,
operator|&
name|num_uses
argument_list|,
operator|&
name|num_derefs
argument_list|,
operator|&
name|is_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_derefs
operator|>
literal|0
condition|)
block|{
operator|*
name|val_p
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|comp_code_p
operator|=
name|NE_EXPR
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_function_decl
name|void
name|dump_asserts_for
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_asserts_for
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_all_asserts
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_all_asserts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Dump all the registered assertions for NAME to FILE.  */
end_comment

begin_function
name|void
name|dump_asserts_for
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|assert_locus_t
name|loc
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Assertions to be inserted for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|loc
operator|=
name|asserts_for
index|[
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|loc
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|bsi_stmt
argument_list|(
name|loc
operator|->
name|si
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\tBB #%d"
argument_list|,
name|loc
operator|->
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|->
name|e
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\tEDGE %d->%d"
argument_list|,
name|loc
operator|->
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|loc
operator|->
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|file
argument_list|,
name|loc
operator|->
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\tPREDICATE: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s "
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|loc
operator|->
name|comp_code
index|]
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|loc
operator|->
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|loc
operator|=
name|loc
operator|->
name|next
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump all the registered assertions for NAME to stderr.  */
end_comment

begin_function
name|void
name|debug_asserts_for
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|dump_asserts_for
argument_list|(
name|stderr
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump all the registered assertions for all the names to FILE.  */
end_comment

begin_function
name|void
name|dump_all_asserts
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nASSERT_EXPRs to be inserted\n\n"
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|need_assert_for
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|dump_asserts_for
argument_list|(
name|file
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump all the registered assertions for all the names to stderr.  */
end_comment

begin_function
name|void
name|debug_all_asserts
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_all_asserts
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If NAME doesn't have an ASSERT_EXPR registered for asserting    'NAME COMP_CODE VAL' at a location that dominates block BB or    E->DEST, then register this location as a possible insertion point    for ASSERT_EXPR<NAME, NAME COMP_CODE VAL>.     BB, E and SI provide the exact insertion point for the new    ASSERT_EXPR.  If BB is NULL, then the ASSERT_EXPR is to be inserted    on edge E.  Otherwise, if E is NULL, the ASSERT_EXPR is inserted on    BB.  If SI points to a COND_EXPR or a SWITCH_EXPR statement, then E    must not be NULL.  */
end_comment

begin_function
specifier|static
name|void
name|register_new_assert_for
parameter_list|(
name|tree
name|name
parameter_list|,
name|enum
name|tree_code
name|comp_code
parameter_list|,
name|tree
name|val
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|edge
name|e
parameter_list|,
name|block_stmt_iterator
name|si
parameter_list|)
block|{
name|assert_locus_t
name|n
decl_stmt|,
name|loc
decl_stmt|,
name|last_loc
decl_stmt|;
name|bool
name|found
decl_stmt|;
name|basic_block
name|dest_bb
decl_stmt|;
if|#
directive|if
name|defined
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|bb
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|!=
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|!=
name|SWITCH_EXPR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The new assertion A will be inserted at BB or E.  We need to      determine if the new location is dominated by a previously      registered location for A.  If we are doing an edge insertion,      assume that A will be inserted at E->DEST.  Note that this is not      necessarily true.            If E is a critical edge, it will be split.  But even if E is      split, the new block will dominate the same set of blocks that      E->DEST dominates.            The reverse, however, is not true, blocks dominated by E->DEST      will not be dominated by the new block created to split E.  So,      if the insertion location is on a critical edge, we will not use      the new location to move another assertion previously registered      at a block dominated by E->DEST.  */
name|dest_bb
operator|=
operator|(
name|bb
operator|)
condition|?
name|bb
else|:
name|e
operator|->
name|dest
expr_stmt|;
comment|/* If NAME already has an ASSERT_EXPR registered for COMP_CODE and      VAL at a block dominating DEST_BB, then we don't need to insert a new      one.  Similarly, if the same assertion already exists at a block      dominated by DEST_BB and the new location is not on a critical      edge, then update the existing location for the assertion (i.e.,      move the assertion up in the dominance tree).       Note, this is implemented as a simple linked list because there      should not be more than a handful of assertions registered per      name.  If this becomes a performance problem, a table hashed by      COMP_CODE and VAL could be implemented.  */
name|loc
operator|=
name|asserts_for
index|[
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
index|]
expr_stmt|;
name|last_loc
operator|=
name|loc
expr_stmt|;
name|found
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|loc
condition|)
block|{
if|if
condition|(
name|loc
operator|->
name|comp_code
operator|==
name|comp_code
operator|&&
operator|(
name|loc
operator|->
name|val
operator|==
name|val
operator|||
name|operand_equal_p
argument_list|(
name|loc
operator|->
name|val
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* If the assertion NAME COMP_CODE VAL has already been 	     registered at a basic block that dominates DEST_BB, then 	     we don't need to insert the same assertion again.  Note 	     that we don't check strict dominance here to avoid 	     replicating the same assertion inside the same basic 	     block more than once (e.g., when a pointer is 	     dereferenced several times inside a block).  	     An exception to this rule are edge insertions.  If the 	     new assertion is to be inserted on edge E, then it will 	     dominate all the other insertions that we may want to 	     insert in DEST_BB.  So, if we are doing an edge 	     insertion, don't do this dominance check.  */
if|if
condition|(
name|e
operator|==
name|NULL
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dest_bb
argument_list|,
name|loc
operator|->
name|bb
argument_list|)
condition|)
return|return;
comment|/* Otherwise, if E is not a critical edge and DEST_BB 	     dominates the existing location for the assertion, move 	     the assertion up in the dominance tree by updating its 	     location information.  */
if|if
condition|(
operator|(
name|e
operator|==
name|NULL
operator|||
operator|!
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
operator|)
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loc
operator|->
name|bb
argument_list|,
name|dest_bb
argument_list|)
condition|)
block|{
name|loc
operator|->
name|bb
operator|=
name|dest_bb
expr_stmt|;
name|loc
operator|->
name|e
operator|=
name|e
expr_stmt|;
name|loc
operator|->
name|si
operator|=
name|si
expr_stmt|;
return|return;
block|}
block|}
comment|/* Update the last node of the list and move to the next one.  */
name|last_loc
operator|=
name|loc
expr_stmt|;
name|loc
operator|=
name|loc
operator|->
name|next
expr_stmt|;
block|}
comment|/* If we didn't find an assertion already registered for      NAME COMP_CODE VAL, add a new one at the end of the list of      assertions associated with NAME.  */
name|n
operator|=
name|XNEW
argument_list|(
expr|struct
name|assert_locus_d
argument_list|)
expr_stmt|;
name|n
operator|->
name|bb
operator|=
name|dest_bb
expr_stmt|;
name|n
operator|->
name|e
operator|=
name|e
expr_stmt|;
name|n
operator|->
name|si
operator|=
name|si
expr_stmt|;
name|n
operator|->
name|comp_code
operator|=
name|comp_code
expr_stmt|;
name|n
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_loc
condition|)
name|last_loc
operator|->
name|next
operator|=
name|n
expr_stmt|;
else|else
name|asserts_for
index|[
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
index|]
operator|=
name|n
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|need_assert_for
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to register an edge assertion for SSA name NAME on edge E for    the conditional jump pointed to by SI.  Return true if an assertion    for NAME could be registered.  */
end_comment

begin_function
specifier|static
name|bool
name|register_edge_assert_for
parameter_list|(
name|tree
name|name
parameter_list|,
name|edge
name|e
parameter_list|,
name|block_stmt_iterator
name|si
parameter_list|)
block|{
name|tree
name|val
decl_stmt|,
name|stmt
decl_stmt|;
name|enum
name|tree_code
name|comp_code
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
comment|/* Do not attempt to infer anything in names that flow through      abnormal edges.  */
if|if
condition|(
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If NAME was not found in the sub-graph reachable from E, then      there's nothing to do.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|found_in_subgraph
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We found a use of NAME in the sub-graph rooted at E->DEST.      Register an assertion for NAME according to the value that NAME      takes on edge E.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* If BB ends in a COND_EXPR then NAME then we should insert 	 the original predicate on EDGE_TRUE_VALUE and the 	 opposite predicate on EDGE_FALSE_VALUE.  */
name|tree
name|cond
init|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|bool
name|is_else_edge
init|=
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALSE_VALUE
operator|)
operator|!=
literal|0
decl_stmt|;
comment|/* Predicates may be a single SSA name or NAME OP VAL.  */
if|if
condition|(
name|cond
operator|==
name|name
condition|)
block|{
comment|/* If the predicate is a name, it must be NAME, in which 	     case we create the predicate NAME == true or 	     NAME == false accordingly.  */
name|comp_code
operator|=
name|EQ_EXPR
expr_stmt|;
name|val
operator|=
operator|(
name|is_else_edge
operator|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we have a comparison of the form NAME COMP VAL 	     or VAL COMP NAME.  */
if|if
condition|(
name|name
operator|==
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If the predicate is of the form VAL COMP NAME, flip 		 COMP around because we need to register NAME as the 		 first operand in the predicate.  */
name|comp_code
operator|=
name|swap_tree_comparison
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The comparison is of the form NAME COMP VAL, so the 		 comparison code remains unchanged.  */
name|comp_code
operator|=
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we are inserting the assertion on the ELSE edge, we 	     need to invert the sign comparison.  */
if|if
condition|(
name|is_else_edge
condition|)
name|comp_code
operator|=
name|invert_tree_comparison
argument_list|(
name|comp_code
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do not register always-false predicates.  FIXME, this 	     works around a limitation in fold() when dealing with 	     enumerations.  Given 'enum { N1, N2 } x;', fold will not 	     fold 'if (x> N2)' to 'if (0)'.  */
if|if
condition|(
operator|(
name|comp_code
operator|==
name|GT_EXPR
operator|||
name|comp_code
operator|==
name|LT_EXPR
operator|)
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|||
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|min
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|max
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp_code
operator|==
name|GT_EXPR
operator|&&
name|compare_values
argument_list|(
name|val
argument_list|,
name|max
argument_list|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|comp_code
operator|==
name|LT_EXPR
operator|&&
name|compare_values
argument_list|(
name|val
argument_list|,
name|min
argument_list|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* FIXME.  Handle SWITCH_EXPR.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|register_new_assert_for
argument_list|(
name|name
argument_list|,
name|comp_code
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|si
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function_decl
specifier|static
name|bool
name|find_assert_locations
parameter_list|(
name|basic_block
name|bb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Determine whether the outgoing edges of BB should receive an    ASSERT_EXPR for each of the operands of BB's last statement.  The    last statement of BB must be a COND_EXPR or a SWITCH_EXPR.     If any of the sub-graphs rooted at BB have an interesting use of    the predicate operands, an assert location node is added to the    list of assertions for the corresponding operands.  */
end_comment

begin_function
specifier|static
name|bool
name|find_conditional_asserts
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|bool
name|need_assert
decl_stmt|;
name|block_stmt_iterator
name|last_si
decl_stmt|;
name|tree
name|op
decl_stmt|,
name|last
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|need_assert
operator|=
name|false
expr_stmt|;
name|last_si
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|last
operator|=
name|bsi_stmt
argument_list|(
name|last_si
argument_list|)
expr_stmt|;
comment|/* Look for uses of the operands in each of the sub-graphs      rooted at BB.  We need to check each of the outgoing edges      separately, so that we know what kind of ASSERT_EXPR to      insert.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|bb
condition|)
continue|continue;
comment|/* Remove the COND_EXPR operands from the FOUND_IN_SUBGRAPH bitmap. 	 Otherwise, when we finish traversing each of the sub-graphs, we 	 won't know whether the variables were found in the sub-graphs or 	 if they had been found in a block upstream from BB.   	 This is actually a bad idea is some cases, particularly jump 	 threading.  Consider a CFG like the following:                      0                    /|                   1 |                    \|                     2                    / \                   3   4  	 Assume that one or more operands in the conditional at the 	 end of block 0 are used in a conditional in block 2, but not 	 anywhere in block 1.  In this case we will not insert any 	 assert statements in block 1, which may cause us to miss 	 opportunities to optimize, particularly for jump threading.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|last
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
name|RESET_BIT
argument_list|(
name|found_in_subgraph
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Traverse the strictly dominated sub-graph rooted at E->DEST 	 to determine if any of the operands in the conditional 	 predicate are used.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|bb
condition|)
name|need_assert
operator||=
name|find_assert_locations
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
comment|/* Register the necessary assertions for each operand in the 	 conditional predicate.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|last
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
name|need_assert
operator||=
name|register_edge_assert_for
argument_list|(
name|op
argument_list|,
name|e
argument_list|,
name|last_si
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, indicate that we have found the operands in the      conditional.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|last
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
name|SET_BIT
argument_list|(
name|found_in_subgraph
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|need_assert
return|;
block|}
end_function

begin_comment
comment|/* Traverse all the statements in block BB looking for statements that    may generate useful assertions for the SSA names in their operand.    If a statement produces a useful assertion A for name N_i, then the    list of assertions already generated for N_i is scanned to    determine if A is actually needed.        If N_i already had the assertion A at a location dominating the    current location, then nothing needs to be done.  Otherwise, the    new location for A is recorded instead.     1- For every statement S in BB, all the variables used by S are       added to bitmap FOUND_IN_SUBGRAPH.     2- If statement S uses an operand N in a way that exposes a known       value range for N, then if N was not already generated by an       ASSERT_EXPR, create a new assert location for N.  For instance,       if N is a pointer and the statement dereferences it, we can       assume that N is not NULL.     3- COND_EXPRs are a special case of #2.  We can derive range       information from the predicate but need to insert different       ASSERT_EXPRs for each of the sub-graphs rooted at the       conditional block.  If the last statement of BB is a conditional       expression of the form 'X op Y', then        a) Remove X and Y from the set FOUND_IN_SUBGRAPH.        b) If the conditional is the only entry point to the sub-graph 	 corresponding to the THEN_CLAUSE, recurse into it.  On 	 return, if X and/or Y are marked in FOUND_IN_SUBGRAPH, then 	 an ASSERT_EXPR is added for the corresponding variable.        c) Repeat step (b) on the ELSE_CLAUSE.        d) Mark X and Y in FOUND_IN_SUBGRAPH.        For instance,  	    if (a == 9) 	      b = a; 	    else 	      b = c + 1;        In this case, an assertion on the THEN clause is useful to       determine that 'a' is always 9 on that edge.  However, an assertion       on the ELSE clause would be unnecessary.     4- If BB does not end in a conditional expression, then we recurse       into BB's dominator children.        At the end of the recursive traversal, every SSA name will have a    list of locations where ASSERT_EXPRs should be added.  When a new    location for name N is found, it is registered by calling    register_new_assert_for.  That function keeps track of all the    registered assertions to prevent adding unnecessary assertions.    For instance, if a pointer P_4 is dereferenced more than once in a    dominator tree, only the location dominating all the dereference of    P_4 will receive an ASSERT_EXPR.     If this function returns true, then it means that there are names    for which we need to generate ASSERT_EXPRs.  Those assertions are    inserted by process_assert_insertions.     TODO.  Handle SWITCH_EXPR.  */
end_comment

begin_function
specifier|static
name|bool
name|find_assert_locations
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|si
decl_stmt|;
name|tree
name|last
decl_stmt|,
name|phi
decl_stmt|;
name|bool
name|need_assert
decl_stmt|;
name|basic_block
name|son
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|blocks_visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
return|return
name|false
return|;
name|SET_BIT
argument_list|(
name|blocks_visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|need_assert
operator|=
name|false
expr_stmt|;
comment|/* Traverse all PHI nodes in BB marking used operands.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|use_operand_p
name|arg_p
decl_stmt|;
name|ssa_op_iter
name|i
decl_stmt|;
name|FOR_EACH_PHI_ARG
argument_list|(
argument|arg_p
argument_list|,
argument|phi
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|tree
name|arg
init|=
name|USE_FROM_PTR
argument_list|(
name|arg_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|gcc_assert
argument_list|(
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|found_in_subgraph
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Traverse all the statements in BB marking used names and looking      for statements that may infer assertions for their used operands.  */
name|last
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
name|stmt
decl_stmt|,
name|op
decl_stmt|;
name|ssa_op_iter
name|i
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
comment|/* See if we can derive an assertion for any of STMT's operands.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|tree
name|value
decl_stmt|;
name|enum
name|tree_code
name|comp_code
decl_stmt|;
comment|/* Mark OP in bitmap FOUND_IN_SUBGRAPH.  If STMT is inside 	     the sub-graph of a conditional block, when we return from 	     this recursive walk, our parent will use the 	     FOUND_IN_SUBGRAPH bitset to determine if one of the 	     operands it was looking for was present in the sub-graph.  */
name|SET_BIT
argument_list|(
name|found_in_subgraph
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If OP is used in such a way that we can infer a value 	     range for it, and we don't find a previous assertion for 	     it, create a new assertion location node for OP.  */
if|if
condition|(
name|infer_value_range
argument_list|(
name|stmt
argument_list|,
name|op
argument_list|,
operator|&
name|comp_code
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
comment|/* If we are able to infer a nonzero value range for OP, 		 then walk backwards through the use-def chain to see if OP 		 was set via a typecast.  		 If so, then we can also infer a nonzero value range 		 for the operand of the NOP_EXPR.  */
if|if
condition|(
name|comp_code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|op
decl_stmt|;
name|tree
name|def_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|def_stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Note we want to register the assert for the 			 operand of the NOP_EXPR after SI, not after the 			 conversion.  */
if|if
condition|(
operator|!
name|has_single_use
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|register_new_assert_for
argument_list|(
name|t
argument_list|,
name|comp_code
argument_list|,
name|value
argument_list|,
name|bb
argument_list|,
name|NULL
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|need_assert
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
comment|/* If OP is used only once, namely in this STMT, don't 		 bother creating an ASSERT_EXPR for it.  Such an 		 ASSERT_EXPR would do nothing but increase compile time.  */
if|if
condition|(
operator|!
name|has_single_use
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|register_new_assert_for
argument_list|(
name|op
argument_list|,
name|comp_code
argument_list|,
name|value
argument_list|,
name|bb
argument_list|,
name|NULL
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|need_assert
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
comment|/* Remember the last statement of the block.  */
name|last
operator|=
name|stmt
expr_stmt|;
block|}
comment|/* If BB's last statement is a conditional expression      involving integer operands, recurse into each of the sub-graphs      rooted at BB to determine if we need to add ASSERT_EXPRs.  */
if|if
condition|(
name|last
operator|&&
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|COND_EXPR
operator|&&
operator|!
name|fp_predicate
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|last
argument_list|)
argument_list|)
operator|&&
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|last
argument_list|,
name|SSA_OP_USE
argument_list|)
condition|)
name|need_assert
operator||=
name|find_conditional_asserts
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Recurse into the dominator children of BB.  */
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
name|need_assert
operator||=
name|find_assert_locations
argument_list|(
name|son
argument_list|)
expr_stmt|;
return|return
name|need_assert
return|;
block|}
end_function

begin_comment
comment|/* Create an ASSERT_EXPR for NAME and insert it in the location    indicated by LOC.  Return true if we made any edge insertions.  */
end_comment

begin_function
specifier|static
name|bool
name|process_assert_insertions_for
parameter_list|(
name|tree
name|name
parameter_list|,
name|assert_locus_t
name|loc
parameter_list|)
block|{
comment|/* Build the comparison expression NAME_i COMP_CODE VAL.  */
name|tree
name|stmt
decl_stmt|,
name|cond
decl_stmt|,
name|assert_expr
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|cond
operator|=
name|build2
argument_list|(
name|loc
operator|->
name|comp_code
argument_list|,
name|boolean_type_node
argument_list|,
name|name
argument_list|,
name|loc
operator|->
name|val
argument_list|)
expr_stmt|;
name|assert_expr
operator|=
name|build_assert_expr_for
argument_list|(
name|cond
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|->
name|e
condition|)
block|{
comment|/* We have been asked to insert the assertion on an edge.  This 	 is used only by COND_EXPR and SWITCH_EXPR assertions.  */
if|#
directive|if
name|defined
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|loc
operator|->
name|si
argument_list|)
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|loc
operator|->
name|si
argument_list|)
argument_list|)
operator|==
name|SWITCH_EXPR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsi_insert_on_edge
argument_list|(
name|loc
operator|->
name|e
argument_list|,
name|assert_expr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Otherwise, we can insert right after LOC->SI iff the      statement must not be the last statement in the block.  */
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|loc
operator|->
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|bsi_insert_after
argument_list|(
operator|&
name|loc
operator|->
name|si
argument_list|,
name|assert_expr
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If STMT must be the last statement in BB, we can only insert new      assertions on the non-abnormal edge out of BB.  Note that since      STMT is not control flow, there may only be one non-abnormal edge      out of BB.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|loc->bb->succs
argument_list|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
condition|)
block|{
name|bsi_insert_on_edge
argument_list|(
name|e
argument_list|,
name|assert_expr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process all the insertions registered for every name N_i registered    in NEED_ASSERT_FOR.  The list of assertions to be inserted are    found in ASSERTS_FOR[i].  */
end_comment

begin_function
specifier|static
name|void
name|process_assert_insertions
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|bool
name|update_edges_p
init|=
name|false
decl_stmt|;
name|int
name|num_asserts
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_all_asserts
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|need_assert_for
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|assert_locus_t
name|loc
init|=
name|asserts_for
index|[
name|i
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|loc
argument_list|)
expr_stmt|;
while|while
condition|(
name|loc
condition|)
block|{
name|assert_locus_t
name|next
init|=
name|loc
operator|->
name|next
decl_stmt|;
name|update_edges_p
operator||=
name|process_assert_insertions_for
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|=
name|next
expr_stmt|;
name|num_asserts
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|update_edges_p
condition|)
name|bsi_commit_edge_inserts
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nNumber of ASSERT_EXPR expressions inserted: %d\n\n"
argument_list|,
name|num_asserts
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Traverse the flowgraph looking for conditional jumps to insert range    expressions.  These range expressions are meant to provide information    to optimizations that need to reason in terms of value ranges.  They    will not be expanded into RTL.  For instance, given:     x = ...    y = ...    if (x< y)      y = x - 2;    else      x = y + 3;     this pass will transform the code into:     x = ...    y = ...    if (x< y)     {       x = ASSERT_EXPR<x, x< y>       y = x - 2     }    else     {       y = ASSERT_EXPR<y, x<= y>       x = y + 3     }     The idea is that once copy and constant propagation have run, other    optimizations will be able to determine what ranges of values can 'x'    take in different paths of the code, simply by checking the reaching    definition of 'x'.  */
end_comment

begin_function
specifier|static
name|void
name|insert_range_assertions
parameter_list|(
name|void
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bool
name|update_ssa_p
decl_stmt|;
name|found_in_subgraph
operator|=
name|sbitmap_alloc
argument_list|(
name|num_ssa_names
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|found_in_subgraph
argument_list|)
expr_stmt|;
name|blocks_visited
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks_visited
argument_list|)
expr_stmt|;
name|need_assert_for
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|asserts_for
operator|=
name|XNEWVEC
argument_list|(
name|assert_locus_t
argument_list|,
name|num_ssa_names
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|asserts_for
argument_list|,
literal|0
argument_list|,
name|num_ssa_names
operator|*
sizeof|sizeof
argument_list|(
name|assert_locus_t
argument_list|)
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|update_ssa_p
operator|=
name|false
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
if|if
condition|(
name|find_assert_locations
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
name|update_ssa_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|update_ssa_p
condition|)
block|{
name|process_assert_insertions
argument_list|()
expr_stmt|;
name|update_ssa
argument_list|(
name|TODO_update_ssa_no_phi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nSSA form after inserting ASSERT_EXPRs\n"
argument_list|)
expr_stmt|;
name|dump_function_to_file
argument_list|(
name|current_function_decl
argument_list|,
name|dump_file
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|found_in_subgraph
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|asserts_for
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|need_assert_for
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert range assertion expressions into the implied copies and    copy propagate away the copies.  Doing the trivial copy propagation    here avoids the need to run the full copy propagation pass after    VRP.         FIXME, this will eventually lead to copy propagation removing the    names that had useful range information attached to them.  For    instance, if we had the assertion N_i = ASSERT_EXPR<N_j, N_j> 3>,    then N_i will have the range [3, +INF].        However, by converting the assertion into the implied copy    operation N_i = N_j, we will then copy-propagate N_j into the uses    of N_i and lose the range information.  We may want to hold on to    ASSERT_EXPRs a little while longer as the ranges could be used in    things like jump threading.        The problem with keeping ASSERT_EXPRs around is that passes after    VRP need to handle them appropriately.      Another approach would be to make the range information a first    class property of the SSA_NAME so that it can be queried from    any pass.  This is made somewhat more complex by the need for    multiple ranges to be associated with one SSA_NAME.  */
end_comment

begin_function
specifier|static
name|void
name|remove_range_assertions
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
comment|/* Note that the BSI iterator bump happens at the bottom of the      loop and no bump is necessary if we're removing the statement      referenced by the current BSI.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|tree
name|use_stmt
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ASSERT_EXPR
condition|)
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|,
name|var
decl_stmt|;
name|tree
name|cond
init|=
name|fold
argument_list|(
name|ASSERT_EXPR_COND
argument_list|(
name|rhs
argument_list|)
argument_list|)
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|imm_use_iterator
name|iter
decl_stmt|;
name|gcc_assert
argument_list|(
name|cond
operator|!=
name|boolean_false_node
argument_list|)
expr_stmt|;
comment|/* Propagate the RHS into every use of the LHS.  */
name|var
operator|=
name|ASSERT_EXPR_VAR
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|FOR_EACH_IMM_USE_STMT
argument_list|(
argument|use_stmt
argument_list|,
argument|iter
argument_list|,
argument|TREE_OPERAND (stmt,
literal|0
argument|)
argument_list|)
name|FOR_EACH_IMM_USE_ON_STMT
argument_list|(
argument|use_p
argument_list|,
argument|iter
argument_list|)
block|{
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
block|}
comment|/* And finally, remove the copy, it is not needed.  */
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|blocks_visited
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if STMT is interesting for VRP.  */
end_comment

begin_function
specifier|static
name|bool
name|stmt_interesting_for_vrp
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
operator|&&
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|PHI_RESULT
argument_list|(
name|stmt
argument_list|)
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|PHI_RESULT
argument_list|(
name|stmt
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* In general, assignments with virtual operands are not useful 	 for deriving ranges, with the obvious exception of calls to 	 builtin functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|DECL_IS_BUILTIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_ALL_VIRTUALS
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Initialize local data structures for VRP.  */
end_comment

begin_function
specifier|static
name|void
name|vrp_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|vr_value
operator|=
name|XNEWVEC
argument_list|(
name|value_range_t
operator|*
argument_list|,
name|num_ssa_names
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|vr_value
argument_list|,
literal|0
argument_list|,
name|num_ssa_names
operator|*
sizeof|sizeof
argument_list|(
name|value_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|si
decl_stmt|;
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|stmt_interesting_for_vrp
argument_list|(
name|phi
argument_list|)
condition|)
block|{
name|tree
name|lhs
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|set_value_range_to_varying
argument_list|(
name|get_value_range
argument_list|(
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
name|DONT_SIMULATE_AGAIN
argument_list|(
name|phi
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
else|else
name|DONT_SIMULATE_AGAIN
argument_list|(
name|phi
argument_list|)
operator|=
name|false
expr_stmt|;
block|}
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stmt_interesting_for_vrp
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|ssa_op_iter
name|i
decl_stmt|;
name|tree
name|def
decl_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_DEF
argument_list|)
name|set_value_range_to_varying
argument_list|(
name|get_value_range
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
name|DONT_SIMULATE_AGAIN
argument_list|(
name|stmt
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|DONT_SIMULATE_AGAIN
argument_list|(
name|stmt
argument_list|)
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Visit assignment STMT.  If it produces an interesting range, record    the SSA name in *OUTPUT_P.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|vrp_visit_assignment
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|output_p
parameter_list|)
block|{
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|,
name|def
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We only keep track of ranges in integral and pointer types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|(
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
comment|/* It is valid to have NULL MIN/MAX values on a type.  See 	      build_range_type.  */
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|struct
name|loop
modifier|*
name|l
decl_stmt|;
name|value_range_t
name|new_vr
init|=
block|{
name|VR_UNDEFINED
block|,
name|NULL_TREE
block|,
name|NULL_TREE
block|,
name|NULL
block|}
decl_stmt|;
name|extract_range_from_expr
argument_list|(
operator|&
name|new_vr
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* If STMT is inside a loop, we may be able to know something 	 else about the range of LHS by examining scalar evolution 	 information.  */
if|if
condition|(
name|current_loops
operator|&&
operator|(
name|l
operator|=
name|loop_containing_stmt
argument_list|(
name|stmt
argument_list|)
operator|)
condition|)
name|adjust_range_with_scev
argument_list|(
operator|&
name|new_vr
argument_list|,
name|l
argument_list|,
name|stmt
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_value_range
argument_list|(
name|lhs
argument_list|,
operator|&
name|new_vr
argument_list|)
condition|)
block|{
operator|*
name|output_p
operator|=
name|lhs
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found new range for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|dump_value_range
argument_list|(
name|dump_file
argument_list|,
operator|&
name|new_vr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_vr
operator|.
name|type
operator|==
name|VR_VARYING
condition|)
return|return
name|SSA_PROP_VARYING
return|;
return|return
name|SSA_PROP_INTERESTING
return|;
block|}
return|return
name|SSA_PROP_NOT_INTERESTING
return|;
block|}
comment|/* Every other statement produces no useful ranges.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
name|set_value_range_to_varying
argument_list|(
name|get_value_range
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SSA_PROP_VARYING
return|;
block|}
end_function

begin_comment
comment|/* Compare all the value ranges for names equivalent to VAR with VAL    using comparison code COMP.  Return the same value returned by    compare_range_with_value, including the setting of    *STRICT_OVERFLOW_P.  */
end_comment

begin_function
specifier|static
name|tree
name|compare_name_with_value
parameter_list|(
name|enum
name|tree_code
name|comp
parameter_list|,
name|tree
name|var
parameter_list|,
name|tree
name|val
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bitmap
name|e
decl_stmt|;
name|tree
name|retval
decl_stmt|,
name|t
decl_stmt|;
name|int
name|used_strict_overflow
decl_stmt|;
name|t
operator|=
name|retval
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Get the set of equivalences for VAR.  */
name|e
operator|=
name|get_value_range
argument_list|(
name|var
argument_list|)
operator|->
name|equiv
expr_stmt|;
comment|/* Add VAR to its own set of equivalences so that VAR's value range      is processed by this loop (otherwise, we would have to replicate      the body of the loop just to check VAR's value range).  */
name|bitmap_set_bit
argument_list|(
name|e
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start at -1.  Set it to 0 if we do a comparison without relying      on overflow, or 1 if all comparisons rely on overflow.  */
name|used_strict_overflow
operator|=
operator|-
literal|1
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|e
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|bool
name|sop
decl_stmt|;
name|value_range_t
name|equiv_vr
init|=
operator|*
operator|(
name|vr_value
index|[
name|i
index|]
operator|)
decl_stmt|;
comment|/* If name N_i does not have a valid range, use N_i as its own 	 range.  This allows us to compare against names that may 	 have N_i in their ranges.  */
if|if
condition|(
name|equiv_vr
operator|.
name|type
operator|==
name|VR_VARYING
operator|||
name|equiv_vr
operator|.
name|type
operator|==
name|VR_UNDEFINED
condition|)
block|{
name|equiv_vr
operator|.
name|type
operator|=
name|VR_RANGE
expr_stmt|;
name|equiv_vr
operator|.
name|min
operator|=
name|ssa_name
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|equiv_vr
operator|.
name|max
operator|=
name|ssa_name
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|sop
operator|=
name|false
expr_stmt|;
name|t
operator|=
name|compare_range_with_value
argument_list|(
name|comp
argument_list|,
operator|&
name|equiv_vr
argument_list|,
name|val
argument_list|,
operator|&
name|sop
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
comment|/* If we get different answers from different members 	     of the equivalence set this check must be in a dead 	     code region.  Folding it to a trap representation 	     would be correct here.  For now just return don't-know.  */
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|&&
name|t
operator|!=
name|retval
condition|)
block|{
name|retval
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
name|retval
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|sop
condition|)
name|used_strict_overflow
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|used_strict_overflow
operator|<
literal|0
condition|)
name|used_strict_overflow
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Remove VAR from its own equivalence set.  */
name|bitmap_clear_bit
argument_list|(
name|e
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
if|if
condition|(
name|used_strict_overflow
operator|>
literal|0
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/* We couldn't find a non-NULL value for the predicate.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given a comparison code COMP and names N1 and N2, compare all the    ranges equivalent to N1 against all the ranges equivalent to N2    to determine the value of N1 COMP N2.  Return the same value    returned by compare_ranges.  Set *STRICT_OVERFLOW_P to indicate    whether we relied on an overflow infinity in the comparison.  */
end_comment

begin_function
specifier|static
name|tree
name|compare_names
parameter_list|(
name|enum
name|tree_code
name|comp
parameter_list|,
name|tree
name|n1
parameter_list|,
name|tree
name|n2
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|retval
decl_stmt|;
name|bitmap
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|bitmap_iterator
name|bi1
decl_stmt|,
name|bi2
decl_stmt|;
name|unsigned
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|int
name|used_strict_overflow
decl_stmt|;
comment|/* Compare the ranges of every name equivalent to N1 against the      ranges of every name equivalent to N2.  */
name|e1
operator|=
name|get_value_range
argument_list|(
name|n1
argument_list|)
operator|->
name|equiv
expr_stmt|;
name|e2
operator|=
name|get_value_range
argument_list|(
name|n2
argument_list|)
operator|->
name|equiv
expr_stmt|;
comment|/* Add N1 and N2 to their own set of equivalences to avoid      duplicating the body of the loop just to check N1 and N2      ranges.  */
name|bitmap_set_bit
argument_list|(
name|e1
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|e2
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|n2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the equivalence sets have a common intersection, then the two      names can be compared without checking their ranges.  */
if|if
condition|(
name|bitmap_intersect_p
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
name|e1
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|e2
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|n2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|comp
operator|==
name|EQ_EXPR
operator|||
name|comp
operator|==
name|GE_EXPR
operator|||
name|comp
operator|==
name|LE_EXPR
operator|)
condition|?
name|boolean_true_node
else|:
name|boolean_false_node
return|;
block|}
comment|/* Start at -1.  Set it to 0 if we do a comparison without relying      on overflow, or 1 if all comparisons rely on overflow.  */
name|used_strict_overflow
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Otherwise, compare all the equivalent ranges.  First, add N1 and      N2 to their own set of equivalences to avoid duplicating the body      of the loop just to check N1 and N2 ranges.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|e1
argument_list|,
literal|0
argument_list|,
argument|i1
argument_list|,
argument|bi1
argument_list|)
block|{
name|value_range_t
name|vr1
init|=
operator|*
operator|(
name|vr_value
index|[
name|i1
index|]
operator|)
decl_stmt|;
comment|/* If the range is VARYING or UNDEFINED, use the name itself.  */
if|if
condition|(
name|vr1
operator|.
name|type
operator|==
name|VR_VARYING
operator|||
name|vr1
operator|.
name|type
operator|==
name|VR_UNDEFINED
condition|)
block|{
name|vr1
operator|.
name|type
operator|=
name|VR_RANGE
expr_stmt|;
name|vr1
operator|.
name|min
operator|=
name|ssa_name
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|vr1
operator|.
name|max
operator|=
name|ssa_name
argument_list|(
name|i1
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|retval
operator|=
name|NULL_TREE
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|e2
argument_list|,
literal|0
argument_list|,
argument|i2
argument_list|,
argument|bi2
argument_list|)
block|{
name|bool
name|sop
init|=
name|false
decl_stmt|;
name|value_range_t
name|vr2
init|=
operator|*
operator|(
name|vr_value
index|[
name|i2
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|vr2
operator|.
name|type
operator|==
name|VR_VARYING
operator|||
name|vr2
operator|.
name|type
operator|==
name|VR_UNDEFINED
condition|)
block|{
name|vr2
operator|.
name|type
operator|=
name|VR_RANGE
expr_stmt|;
name|vr2
operator|.
name|min
operator|=
name|ssa_name
argument_list|(
name|i2
argument_list|)
expr_stmt|;
name|vr2
operator|.
name|max
operator|=
name|ssa_name
argument_list|(
name|i2
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|compare_ranges
argument_list|(
name|comp
argument_list|,
operator|&
name|vr1
argument_list|,
operator|&
name|vr2
argument_list|,
operator|&
name|sop
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
comment|/* If we get different answers from different members 		 of the equivalence set this check must be in a dead 		 code region.  Folding it to a trap representation 		 would be correct here.  For now just return don't-know.  */
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|&&
name|t
operator|!=
name|retval
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
name|e1
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|e2
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|n2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|retval
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|sop
condition|)
name|used_strict_overflow
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|used_strict_overflow
operator|<
literal|0
condition|)
name|used_strict_overflow
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|retval
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
name|e1
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|e2
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|n2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|used_strict_overflow
operator|>
literal|0
condition|)
operator|*
name|strict_overflow_p
operator|=
name|true
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
comment|/* None of the equivalent ranges are useful in computing this      comparison.  */
name|bitmap_clear_bit
argument_list|(
name|e1
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|n1
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|e2
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|n2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given a conditional predicate COND, try to determine if COND yields    true or false based on the value ranges of its operands.  Return    BOOLEAN_TRUE_NODE if the conditional always evaluates to true,    BOOLEAN_FALSE_NODE if the conditional always evaluates to false, and,    NULL if the conditional cannot be evaluated at compile time.     If USE_EQUIV_P is true, the ranges of all the names equivalent with    the operands in COND are used when trying to compute its value.    This is only used during final substitution.  During propagation,    we only check the range of each variable and not its equivalents.     Set *STRICT_OVERFLOW_P to indicate whether we relied on an overflow    infinity to produce the result.  */
end_comment

begin_function
specifier|static
name|tree
name|vrp_evaluate_conditional_warnv
parameter_list|(
name|tree
name|cond
parameter_list|,
name|bool
name|use_equiv_p
parameter_list|,
name|bool
modifier|*
name|strict_overflow_p
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|==
name|tcc_comparison
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|value_range_t
modifier|*
name|vr
decl_stmt|;
name|tree
name|retval
decl_stmt|;
if|if
condition|(
name|use_equiv_p
condition|)
name|retval
operator|=
name|compare_name_with_value
argument_list|(
name|NE_EXPR
argument_list|,
name|cond
argument_list|,
name|boolean_false_node
argument_list|,
name|strict_overflow_p
argument_list|)
expr_stmt|;
else|else
block|{
name|value_range_t
modifier|*
name|vr
init|=
name|get_value_range
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|retval
operator|=
name|compare_range_with_value
argument_list|(
name|NE_EXPR
argument_list|,
name|vr
argument_list|,
name|boolean_false_node
argument_list|,
name|strict_overflow_p
argument_list|)
expr_stmt|;
block|}
comment|/* If COND has a known boolean range, return it.  */
if|if
condition|(
name|retval
condition|)
return|return
name|retval
return|;
comment|/* Otherwise, if COND has a symbolic range of exactly one value, 	 return it.  */
name|vr
operator|=
name|get_value_range
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
name|vr
operator|->
name|min
operator|==
name|vr
operator|->
name|max
condition|)
return|return
name|vr
operator|->
name|min
return|;
block|}
else|else
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* We only deal with integral and pointer types.  */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|use_equiv_p
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|compare_names
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|compare_name_with_value
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
operator|(
name|compare_name_with_value
argument_list|(
name|swap_tree_comparison
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|value_range_t
modifier|*
name|vr0
decl_stmt|,
modifier|*
name|vr1
decl_stmt|;
name|vr0
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
operator|)
condition|?
name|get_value_range
argument_list|(
name|op0
argument_list|)
else|:
name|NULL
expr_stmt|;
name|vr1
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SSA_NAME
operator|)
condition|?
name|get_value_range
argument_list|(
name|op1
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|vr0
operator|&&
name|vr1
condition|)
return|return
name|compare_ranges
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|vr0
argument_list|,
name|vr1
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
elseif|else
if|if
condition|(
name|vr0
operator|&&
name|vr1
operator|==
name|NULL
condition|)
return|return
name|compare_range_with_value
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|vr0
argument_list|,
name|op1
argument_list|,
name|strict_overflow_p
argument_list|)
return|;
elseif|else
if|if
condition|(
name|vr0
operator|==
name|NULL
operator|&&
name|vr1
condition|)
return|return
operator|(
name|compare_range_with_value
argument_list|(
name|swap_tree_comparison
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|,
name|vr1
argument_list|,
name|op0
argument_list|,
name|strict_overflow_p
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* Anything else cannot be computed statically.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given COND within STMT, try to simplify it based on value range    information.  Return NULL if the conditional can not be evaluated.    The ranges of all the names equivalent with the operands in COND    will be used when trying to compute the value.  If the result is    based on undefined signed overflow, issue a warning if    appropriate.  */
end_comment

begin_function
name|tree
name|vrp_evaluate_conditional
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|bool
name|sop
decl_stmt|;
name|tree
name|ret
decl_stmt|;
name|sop
operator|=
name|false
expr_stmt|;
name|ret
operator|=
name|vrp_evaluate_conditional_warnv
argument_list|(
name|cond
argument_list|,
name|true
argument_list|,
operator|&
name|sop
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|sop
condition|)
block|{
name|enum
name|warn_strict_overflow_code
name|wc
decl_stmt|;
specifier|const
name|char
modifier|*
name|warnmsg
decl_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|wc
operator|=
name|WARN_STRICT_OVERFLOW_CONDITIONAL
expr_stmt|;
name|warnmsg
operator|=
name|G_
argument_list|(
literal|"assuming signed overflow does not occur when "
literal|"simplifying conditional to constant"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wc
operator|=
name|WARN_STRICT_OVERFLOW_COMPARISON
expr_stmt|;
name|warnmsg
operator|=
name|G_
argument_list|(
literal|"assuming signed overflow does not occur when "
literal|"simplifying conditional"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|issue_strict_overflow_warning
argument_list|(
name|wc
argument_list|)
condition|)
block|{
name|location_t
name|locus
decl_stmt|;
if|if
condition|(
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
condition|)
name|locus
operator|=
name|input_location
expr_stmt|;
else|else
name|locus
operator|=
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wstrict_overflow
argument_list|,
literal|"%H%s"
argument_list|,
operator|&
name|locus
argument_list|,
name|warnmsg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Visit conditional statement STMT.  If we can determine which edge    will be taken out of STMT's basic block, record it in    *TAKEN_EDGE_P and return SSA_PROP_INTERESTING.  Otherwise, return    SSA_PROP_VARYING.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|vrp_visit_cond_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|edge
modifier|*
name|taken_edge_p
parameter_list|)
block|{
name|tree
name|cond
decl_stmt|,
name|val
decl_stmt|;
name|bool
name|sop
decl_stmt|;
operator|*
name|taken_edge_p
operator|=
name|NULL
expr_stmt|;
comment|/* FIXME.  Handle SWITCH_EXPRs.  But first, the assert pass needs to      add ASSERT_EXPRs for them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
return|return
name|SSA_PROP_VARYING
return|;
name|cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|tree
name|use
decl_stmt|;
name|ssa_op_iter
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nVisiting conditional with predicate: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nWith known ranges\n"
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|use
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|dump_value_range
argument_list|(
name|dump_file
argument_list|,
name|vr_value
index|[
name|SSA_NAME_VERSION
argument_list|(
name|use
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the value of the predicate COND by checking the known      ranges of each of its operands.            Note that we cannot evaluate all the equivalent ranges here      because those ranges may not yet be final and with the current      propagation strategy, we cannot determine when the value ranges      of the names in the equivalence set have changed.       For instance, given the following code fragment          i_5 = PHI<8, i_13> 	...      	i_14 = ASSERT_EXPR<i_5, i_5 != 0> 	if (i_14 == 1) 	  ...       Assume that on the first visit to i_14, i_5 has the temporary      range [8, 8] because the second argument to the PHI function is      not yet executable.  We derive the range ~[0, 0] for i_14 and the      equivalence set { i_5 }.  So, when we visit 'if (i_14 == 1)' for      the first time, since i_14 is equivalent to the range [8, 8], we      determine that the predicate is always false.       On the next round of propagation, i_13 is determined to be      VARYING, which causes i_5 to drop down to VARYING.  So, another      visit to i_14 is scheduled.  In this second visit, we compute the      exact same range and equivalence set for i_14, namely ~[0, 0] and      { i_5 }.  But we did not have the previous range for i_5      registered, so vrp_visit_assignment thinks that the range for      i_14 has not changed.  Therefore, the predicate 'if (i_14 == 1)'      is not visited again, which stops propagation from visiting      statements in the THEN clause of that if().       To properly fix this we would need to keep the previous range      value for the names in the equivalence set.  This way we would've      discovered that from one visit to the other i_5 changed from      range [8, 8] to VR_VARYING.       However, fixing this apparent limitation may not be worth the      additional checking.  Testing on several code bases (GCC, DLV,      MICO, TRAMP3D and SPEC2000) showed that doing this results in      4 more predicates folded in SPEC.  */
name|sop
operator|=
name|false
expr_stmt|;
name|val
operator|=
name|vrp_evaluate_conditional_warnv
argument_list|(
name|cond
argument_list|,
name|false
argument_list|,
operator|&
name|sop
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
if|if
condition|(
operator|!
name|sop
condition|)
operator|*
name|taken_edge_p
operator|=
name|find_taken_edge
argument_list|(
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nIgnoring predicate evaluation because "
literal|"it assumes that signed overflow is undefined"
argument_list|)
expr_stmt|;
name|val
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nPredicate evaluates to: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"DON'T KNOW\n"
argument_list|)
expr_stmt|;
else|else
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|taken_edge_p
operator|)
condition|?
name|SSA_PROP_INTERESTING
else|:
name|SSA_PROP_VARYING
return|;
block|}
end_function

begin_comment
comment|/* Evaluate statement STMT.  If the statement produces a useful range,    return SSA_PROP_INTERESTING and record the SSA name with the    interesting range into *OUTPUT_P.     If STMT is a conditional branch and we can determine its truth    value, the taken edge is recorded in *TAKEN_EDGE_P.     If STMT produces a varying value, return SSA_PROP_VARYING.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|vrp_visit_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|edge
modifier|*
name|taken_edge_p
parameter_list|,
name|tree
modifier|*
name|output_p
parameter_list|)
block|{
name|tree
name|def
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nVisiting statement:\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* In general, assignments with virtual operands are not useful 	 for deriving ranges, with the obvious exception of calls to 	 builtin functions.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|DECL_IS_BUILTIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_ALL_VIRTUALS
argument_list|)
condition|)
return|return
name|vrp_visit_assignment
argument_list|(
name|stmt
argument_list|,
name|output_p
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
return|return
name|vrp_visit_cond_stmt
argument_list|(
name|stmt
argument_list|,
name|taken_edge_p
argument_list|)
return|;
comment|/* All other statements produce nothing of interest for VRP, so mark      their outputs varying and prevent further simulation.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
name|set_value_range_to_varying
argument_list|(
name|get_value_range
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SSA_PROP_VARYING
return|;
block|}
end_function

begin_comment
comment|/* Meet operation for value ranges.  Given two value ranges VR0 and    VR1, store in VR0 the result of meeting VR0 and VR1.        The meeting rules are as follows:     1- If VR0 and VR1 have an empty intersection, set VR0 to VR_VARYING.     2- If VR0 and VR1 have a non-empty intersection, set VR0 to the       union of VR0 and VR1.  */
end_comment

begin_function
specifier|static
name|void
name|vrp_meet
parameter_list|(
name|value_range_t
modifier|*
name|vr0
parameter_list|,
name|value_range_t
modifier|*
name|vr1
parameter_list|)
block|{
if|if
condition|(
name|vr0
operator|->
name|type
operator|==
name|VR_UNDEFINED
condition|)
block|{
name|copy_value_range
argument_list|(
name|vr0
argument_list|,
name|vr1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vr1
operator|->
name|type
operator|==
name|VR_UNDEFINED
condition|)
block|{
comment|/* Nothing to do.  VR0 already has the resulting range.  */
return|return;
block|}
if|if
condition|(
name|vr0
operator|->
name|type
operator|==
name|VR_VARYING
condition|)
block|{
comment|/* Nothing to do.  VR0 already has the resulting range.  */
return|return;
block|}
if|if
condition|(
name|vr1
operator|->
name|type
operator|==
name|VR_VARYING
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vr0
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
name|vr1
operator|->
name|type
operator|==
name|VR_RANGE
condition|)
block|{
comment|/* If VR0 and VR1 have a non-empty intersection, compute the 	 union of both ranges.  */
if|if
condition|(
name|value_ranges_intersect_p
argument_list|(
name|vr0
argument_list|,
name|vr1
argument_list|)
condition|)
block|{
name|int
name|cmp
decl_stmt|;
name|tree
name|min
decl_stmt|,
name|max
decl_stmt|;
comment|/* The lower limit of the new range is the minimum of the 	     two ranges.  If they cannot be compared, the result is 	     VARYING.  */
name|cmp
operator|=
name|compare_values
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr1
operator|->
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
operator|||
name|cmp
operator|==
literal|1
condition|)
name|min
operator|=
name|vr1
operator|->
name|min
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|==
operator|-
literal|1
condition|)
name|min
operator|=
name|vr0
operator|->
name|min
expr_stmt|;
else|else
block|{
name|set_value_range_to_varying
argument_list|(
name|vr0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Similarly, the upper limit of the new range is the 	     maximum of the two ranges.  If they cannot be compared, 	     the result is VARYING.  */
name|cmp
operator|=
name|compare_values
argument_list|(
name|vr0
operator|->
name|max
argument_list|,
name|vr1
operator|->
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
operator|||
name|cmp
operator|==
operator|-
literal|1
condition|)
name|max
operator|=
name|vr1
operator|->
name|max
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|1
condition|)
name|max
operator|=
name|vr0
operator|->
name|max
expr_stmt|;
else|else
block|{
name|set_value_range_to_varying
argument_list|(
name|vr0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for useless ranges.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|min
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|vrp_val_is_min
argument_list|(
name|min
argument_list|)
operator|||
name|is_overflow_infinity
argument_list|(
name|min
argument_list|)
operator|)
operator|&&
operator|(
name|vrp_val_is_max
argument_list|(
name|max
argument_list|)
operator|||
name|is_overflow_infinity
argument_list|(
name|max
argument_list|)
operator|)
operator|)
condition|)
block|{
name|set_value_range_to_varying
argument_list|(
name|vr0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The resulting set of equivalences is the intersection of 	     the two sets.  */
if|if
condition|(
name|vr0
operator|->
name|equiv
operator|&&
name|vr1
operator|->
name|equiv
operator|&&
name|vr0
operator|->
name|equiv
operator|!=
name|vr1
operator|->
name|equiv
condition|)
name|bitmap_and_into
argument_list|(
name|vr0
operator|->
name|equiv
argument_list|,
name|vr1
operator|->
name|equiv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vr0
operator|->
name|equiv
operator|&&
operator|!
name|vr1
operator|->
name|equiv
condition|)
name|bitmap_clear
argument_list|(
name|vr0
operator|->
name|equiv
argument_list|)
expr_stmt|;
name|set_value_range
argument_list|(
name|vr0
argument_list|,
name|vr0
operator|->
name|type
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|vr0
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|no_meet
goto|;
block|}
elseif|else
if|if
condition|(
name|vr0
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
operator|&&
name|vr1
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
block|{
comment|/* Two anti-ranges meet only if they are both identical.  */
if|if
condition|(
name|compare_values
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr1
operator|->
name|min
argument_list|)
operator|==
literal|0
operator|&&
name|compare_values
argument_list|(
name|vr0
operator|->
name|max
argument_list|,
name|vr1
operator|->
name|max
argument_list|)
operator|==
literal|0
operator|&&
name|compare_values
argument_list|(
name|vr0
operator|->
name|min
argument_list|,
name|vr0
operator|->
name|max
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The resulting set of equivalences is the intersection of 	     the two sets.  */
if|if
condition|(
name|vr0
operator|->
name|equiv
operator|&&
name|vr1
operator|->
name|equiv
operator|&&
name|vr0
operator|->
name|equiv
operator|!=
name|vr1
operator|->
name|equiv
condition|)
name|bitmap_and_into
argument_list|(
name|vr0
operator|->
name|equiv
argument_list|,
name|vr1
operator|->
name|equiv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vr0
operator|->
name|equiv
operator|&&
operator|!
name|vr1
operator|->
name|equiv
condition|)
name|bitmap_clear
argument_list|(
name|vr0
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|no_meet
goto|;
block|}
elseif|else
if|if
condition|(
name|vr0
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
operator|||
name|vr1
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
block|{
comment|/* A numeric range [VAL1, VAL2] and an anti-range ~[VAL3, VAL4] 	 meet only if the ranges have an empty intersection.  The 	 result of the meet operation is the anti-range.  */
if|if
condition|(
operator|!
name|symbolic_range_p
argument_list|(
name|vr0
argument_list|)
operator|&&
operator|!
name|symbolic_range_p
argument_list|(
name|vr1
argument_list|)
operator|&&
operator|!
name|value_ranges_intersect_p
argument_list|(
name|vr0
argument_list|,
name|vr1
argument_list|)
condition|)
block|{
comment|/* Copy most of VR1 into VR0.  Don't copy VR1's equivalence 	     set.  We need to compute the intersection of the two 	     equivalence sets.  */
if|if
condition|(
name|vr1
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
condition|)
name|set_value_range
argument_list|(
name|vr0
argument_list|,
name|vr1
operator|->
name|type
argument_list|,
name|vr1
operator|->
name|min
argument_list|,
name|vr1
operator|->
name|max
argument_list|,
name|vr0
operator|->
name|equiv
argument_list|)
expr_stmt|;
comment|/* The resulting set of equivalences is the intersection of 	     the two sets.  */
if|if
condition|(
name|vr0
operator|->
name|equiv
operator|&&
name|vr1
operator|->
name|equiv
operator|&&
name|vr0
operator|->
name|equiv
operator|!=
name|vr1
operator|->
name|equiv
condition|)
name|bitmap_and_into
argument_list|(
name|vr0
operator|->
name|equiv
argument_list|,
name|vr1
operator|->
name|equiv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vr0
operator|->
name|equiv
operator|&&
operator|!
name|vr1
operator|->
name|equiv
condition|)
name|bitmap_clear
argument_list|(
name|vr0
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|no_meet
goto|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
return|return;
name|no_meet
label|:
comment|/* The two range VR0 and VR1 do not meet.  Before giving up and      setting the result to VARYING, see if we can at least derive a      useful anti-range.  FIXME, all this nonsense about distinguishing      anti-ranges from ranges is necessary because of the odd      semantics of range_includes_zero_p and friends.  */
if|if
condition|(
operator|!
name|symbolic_range_p
argument_list|(
name|vr0
argument_list|)
operator|&&
operator|(
operator|(
name|vr0
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
operator|!
name|range_includes_zero_p
argument_list|(
name|vr0
argument_list|)
operator|)
operator|||
operator|(
name|vr0
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
operator|&&
name|range_includes_zero_p
argument_list|(
name|vr0
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|symbolic_range_p
argument_list|(
name|vr1
argument_list|)
operator|&&
operator|(
operator|(
name|vr1
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
operator|!
name|range_includes_zero_p
argument_list|(
name|vr1
argument_list|)
operator|)
operator|||
operator|(
name|vr1
operator|->
name|type
operator|==
name|VR_ANTI_RANGE
operator|&&
name|range_includes_zero_p
argument_list|(
name|vr1
argument_list|)
operator|)
operator|)
condition|)
block|{
name|set_value_range_to_nonnull
argument_list|(
name|vr0
argument_list|,
name|TREE_TYPE
argument_list|(
name|vr0
operator|->
name|min
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Since this meet operation did not result from the meeting of 	 two equivalent names, VR0 cannot have any equivalences.  */
if|if
condition|(
name|vr0
operator|->
name|equiv
condition|)
name|bitmap_clear
argument_list|(
name|vr0
operator|->
name|equiv
argument_list|)
expr_stmt|;
block|}
else|else
name|set_value_range_to_varying
argument_list|(
name|vr0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Visit all arguments for PHI node PHI that flow through executable    edges.  If a valid value range can be derived from all the incoming    value ranges, set a new range for the LHS of PHI.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|vrp_visit_phi_node
parameter_list|(
name|tree
name|phi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|lhs
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|value_range_t
modifier|*
name|lhs_vr
init|=
name|get_value_range
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|value_range_t
name|vr_result
init|=
block|{
name|VR_UNDEFINED
block|,
name|NULL_TREE
block|,
name|NULL_TREE
block|,
name|NULL
block|}
decl_stmt|;
name|copy_value_range
argument_list|(
operator|&
name|vr_result
argument_list|,
name|lhs_vr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nVisiting PHI node: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|phi
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
init|=
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n    Argument #%d (%d -> %d %sexecutable)\n"
argument_list|,
name|i
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EXECUTABLE
operator|)
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EXECUTABLE
condition|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|value_range_t
name|vr_arg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|vr_arg
operator|=
operator|*
operator|(
name|get_value_range
argument_list|(
name|arg
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|is_overflow_infinity
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|arg
operator|=
name|copy_node
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|arg
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|vr_arg
operator|.
name|type
operator|=
name|VR_RANGE
expr_stmt|;
name|vr_arg
operator|.
name|min
operator|=
name|arg
expr_stmt|;
name|vr_arg
operator|.
name|max
operator|=
name|arg
expr_stmt|;
name|vr_arg
operator|.
name|equiv
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|arg
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\tValue: "
argument_list|)
expr_stmt|;
name|dump_value_range
argument_list|(
name|dump_file
argument_list|,
operator|&
name|vr_arg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|vrp_meet
argument_list|(
operator|&
name|vr_result
argument_list|,
operator|&
name|vr_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|vr_result
operator|.
name|type
operator|==
name|VR_VARYING
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|vr_result
operator|.
name|type
operator|==
name|VR_VARYING
condition|)
goto|goto
name|varying
goto|;
comment|/* To prevent infinite iterations in the algorithm, derive ranges      when the new value is slightly bigger or smaller than the      previous one.  */
if|if
condition|(
name|lhs_vr
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
name|vr_result
operator|.
name|type
operator|==
name|VR_RANGE
condition|)
block|{
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|cmp_min
init|=
name|compare_values
argument_list|(
name|lhs_vr
operator|->
name|min
argument_list|,
name|vr_result
operator|.
name|min
argument_list|)
decl_stmt|;
name|int
name|cmp_max
init|=
name|compare_values
argument_list|(
name|lhs_vr
operator|->
name|max
argument_list|,
name|vr_result
operator|.
name|max
argument_list|)
decl_stmt|;
comment|/* If the new minimum is smaller or larger than the previous 	     one, go all the way to -INF.  In the first case, to avoid 	     iterating millions of times to reach -INF, and in the 	     other case to avoid infinite bouncing between different 	     minimums.  */
if|if
condition|(
name|cmp_min
operator|>
literal|0
operator|||
name|cmp_min
operator|<
literal|0
condition|)
block|{
comment|/* If we will end up with a (-INF, +INF) range, set it 		 to VARYING.  */
if|if
condition|(
name|vrp_val_is_max
argument_list|(
name|vr_result
operator|.
name|max
argument_list|)
condition|)
goto|goto
name|varying
goto|;
if|if
condition|(
operator|!
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|vr_result
operator|.
name|min
argument_list|)
argument_list|)
operator|||
operator|!
name|vrp_var_may_overflow
argument_list|(
name|lhs
argument_list|,
name|phi
argument_list|)
condition|)
name|vr_result
operator|.
name|min
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vr_result
operator|.
name|min
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|vr_result
operator|.
name|min
argument_list|)
argument_list|)
condition|)
name|vr_result
operator|.
name|min
operator|=
name|negative_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|vr_result
operator|.
name|min
argument_list|)
argument_list|)
expr_stmt|;
else|else
goto|goto
name|varying
goto|;
block|}
comment|/* Similarly, if the new maximum is smaller or larger than 	     the previous one, go all the way to +INF.  */
if|if
condition|(
name|cmp_max
operator|<
literal|0
operator|||
name|cmp_max
operator|>
literal|0
condition|)
block|{
comment|/* If we will end up with a (-INF, +INF) range, set it 		 to VARYING.  */
if|if
condition|(
name|vrp_val_is_min
argument_list|(
name|vr_result
operator|.
name|min
argument_list|)
condition|)
goto|goto
name|varying
goto|;
if|if
condition|(
operator|!
name|needs_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|vr_result
operator|.
name|max
argument_list|)
argument_list|)
operator|||
operator|!
name|vrp_var_may_overflow
argument_list|(
name|lhs
argument_list|,
name|phi
argument_list|)
condition|)
name|vr_result
operator|.
name|max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vr_result
operator|.
name|max
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|supports_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|vr_result
operator|.
name|max
argument_list|)
argument_list|)
condition|)
name|vr_result
operator|.
name|max
operator|=
name|positive_overflow_infinity
argument_list|(
name|TREE_TYPE
argument_list|(
name|vr_result
operator|.
name|max
argument_list|)
argument_list|)
expr_stmt|;
else|else
goto|goto
name|varying
goto|;
block|}
block|}
block|}
comment|/* If the new range is different than the previous value, keep      iterating.  */
if|if
condition|(
name|update_value_range
argument_list|(
name|lhs
argument_list|,
operator|&
name|vr_result
argument_list|)
condition|)
return|return
name|SSA_PROP_INTERESTING
return|;
comment|/* Nothing changed, don't add outgoing edges.  */
return|return
name|SSA_PROP_NOT_INTERESTING
return|;
comment|/* No match found.  Set the LHS to VARYING.  */
name|varying
label|:
name|set_value_range_to_varying
argument_list|(
name|lhs_vr
argument_list|)
expr_stmt|;
return|return
name|SSA_PROP_VARYING
return|;
block|}
end_function

begin_comment
comment|/* Simplify a division or modulo operator to a right shift or    bitwise and if the first operand is unsigned or is greater    than zero and the second operand is an exact power of two.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_div_or_mod_using_ranges
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|rhs
parameter_list|,
name|enum
name|tree_code
name|rhs_code
parameter_list|)
block|{
name|tree
name|val
init|=
name|NULL
decl_stmt|;
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|value_range_t
modifier|*
name|vr
init|=
name|get_value_range
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
block|{
name|val
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
block|{
name|bool
name|sop
init|=
name|false
decl_stmt|;
name|val
operator|=
name|compare_range_with_value
argument_list|(
name|GE_EXPR
argument_list|,
name|vr
argument_list|,
name|integer_zero_node
argument_list|,
operator|&
name|sop
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|sop
operator|&&
name|integer_onep
argument_list|(
name|val
argument_list|)
operator|&&
name|issue_strict_overflow_warning
argument_list|(
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
condition|)
block|{
name|location_t
name|locus
decl_stmt|;
if|if
condition|(
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
condition|)
name|locus
operator|=
name|input_location
expr_stmt|;
else|else
name|locus
operator|=
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wstrict_overflow
argument_list|,
operator|(
literal|"%Hassuming signed overflow does not occur when "
literal|"simplifying / or %% to>> or&"
operator|)
argument_list|,
operator|&
name|locus
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val
operator|&&
name|integer_onep
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rhs_code
operator|==
name|TRUNC_DIV_EXPR
condition|)
block|{
name|t
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|tree_log2
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|int_const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|op1
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|t
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If the operand to an ABS_EXPR is>= 0, then eliminate the    ABS_EXPR.  If the operand is<= 0, then simplify the    ABS_EXPR into a NEGATE_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_abs_using_ranges
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|tree
name|val
init|=
name|NULL
decl_stmt|;
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|value_range_t
modifier|*
name|vr
init|=
name|get_value_range
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vr
condition|)
block|{
name|bool
name|sop
init|=
name|false
decl_stmt|;
name|val
operator|=
name|compare_range_with_value
argument_list|(
name|LE_EXPR
argument_list|,
name|vr
argument_list|,
name|integer_zero_node
argument_list|,
operator|&
name|sop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|sop
operator|=
name|false
expr_stmt|;
name|val
operator|=
name|compare_range_with_value
argument_list|(
name|GE_EXPR
argument_list|,
name|vr
argument_list|,
name|integer_zero_node
argument_list|,
operator|&
name|sop
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_onep
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val
operator|&&
operator|(
name|integer_onep
argument_list|(
name|val
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|val
argument_list|)
operator|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|sop
operator|&&
name|issue_strict_overflow_warning
argument_list|(
name|WARN_STRICT_OVERFLOW_MISC
argument_list|)
condition|)
block|{
name|location_t
name|locus
decl_stmt|;
if|if
condition|(
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
condition|)
name|locus
operator|=
name|input_location
expr_stmt|;
else|else
name|locus
operator|=
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wstrict_overflow
argument_list|,
operator|(
literal|"%Hassuming signed overflow does not occur when "
literal|"simplifying abs (X) to X or -X"
operator|)
argument_list|,
operator|&
name|locus
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|integer_onep
argument_list|(
name|val
argument_list|)
condition|)
name|t
operator|=
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|op
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|t
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* We are comparing trees OP0 and OP1 using COND_CODE.  OP0 has    a known value range VR.     If there is one and only one value which will satisfy the    conditional, then return that value.  Else return NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|test_for_singularity
parameter_list|(
name|enum
name|tree_code
name|cond_code
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|,
name|value_range_t
modifier|*
name|vr
parameter_list|)
block|{
name|tree
name|min
init|=
name|NULL
decl_stmt|;
name|tree
name|max
init|=
name|NULL
decl_stmt|;
comment|/* Extract minimum/maximum values which satisfy the      the conditional as it was written.  */
if|if
condition|(
name|cond_code
operator|==
name|LE_EXPR
operator|||
name|cond_code
operator|==
name|LT_EXPR
condition|)
block|{
comment|/* This should not be negative infinity; there is no overflow 	 here.  */
name|min
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
name|op1
expr_stmt|;
if|if
condition|(
name|cond_code
operator|==
name|LT_EXPR
operator|&&
operator|!
name|is_overflow_infinity
argument_list|(
name|max
argument_list|)
condition|)
block|{
name|tree
name|one
init|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|max
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|max
argument_list|,
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|max
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|max
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cond_code
operator|==
name|GE_EXPR
operator|||
name|cond_code
operator|==
name|GT_EXPR
condition|)
block|{
comment|/* This should not be positive infinity; there is no overflow 	 here.  */
name|max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|min
operator|=
name|op1
expr_stmt|;
if|if
condition|(
name|cond_code
operator|==
name|GT_EXPR
operator|&&
operator|!
name|is_overflow_infinity
argument_list|(
name|min
argument_list|)
condition|)
block|{
name|tree
name|one
init|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|min
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|min
argument_list|,
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|min
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|min
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now refine the minimum and maximum values using any      value range information we have for op0.  */
if|if
condition|(
name|min
operator|&&
name|max
condition|)
block|{
if|if
condition|(
name|compare_values
argument_list|(
name|vr
operator|->
name|min
argument_list|,
name|min
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|min
operator|=
name|min
expr_stmt|;
else|else
name|min
operator|=
name|vr
operator|->
name|min
expr_stmt|;
if|if
condition|(
name|compare_values
argument_list|(
name|vr
operator|->
name|max
argument_list|,
name|max
argument_list|)
operator|==
literal|1
condition|)
name|max
operator|=
name|max
expr_stmt|;
else|else
name|max
operator|=
name|vr
operator|->
name|max
expr_stmt|;
comment|/* If the new min/max values have converged to a single value, 	 then there is only one value which can satisfy the condition, 	 return that value.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|min
argument_list|,
name|max
argument_list|,
literal|0
argument_list|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|min
argument_list|)
condition|)
return|return
name|min
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Simplify a conditional using a relational operator to an equality    test if the range information indicates only one value can satisfy    the original conditional.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_cond_using_ranges
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|cond
init|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|cond_code
init|=
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
decl_stmt|;
if|if
condition|(
name|cond_code
operator|!=
name|NE_EXPR
operator|&&
name|cond_code
operator|!=
name|EQ_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|value_range_t
modifier|*
name|vr
init|=
name|get_value_range
argument_list|(
name|op0
argument_list|)
decl_stmt|;
comment|/* If we have range information for OP0, then we might be 	 able to simplify this conditional. */
if|if
condition|(
name|vr
operator|->
name|type
operator|==
name|VR_RANGE
condition|)
block|{
name|tree
name|new
init|=
name|test_for_singularity
argument_list|(
name|cond_code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|vr
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Simplified relational "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" into "
argument_list|)
expr_stmt|;
block|}
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
operator|=
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|op0
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Try again after inverting the condition.  We only deal 	     with integral types here, so no need to worry about 	     issues with inverting FP comparisons.  */
name|cond_code
operator|=
name|invert_tree_comparison
argument_list|(
name|cond_code
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|new
operator|=
name|test_for_singularity
argument_list|(
name|cond_code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|vr
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Simplified relational "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" into "
argument_list|)
expr_stmt|;
block|}
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
operator|=
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|op0
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Simplify STMT using ranges if possible.  */
end_comment

begin_function
name|void
name|simplify_stmt_using_ranges
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|rhs_code
init|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
comment|/* Transform TRUNC_DIV_EXPR and TRUNC_MOD_EXPR into RSHIFT_EXPR 	 and BIT_AND_EXPR respectively if the first operand is greater 	 than zero and the second operand is an exact power of two.  */
if|if
condition|(
operator|(
name|rhs_code
operator|==
name|TRUNC_DIV_EXPR
operator|||
name|rhs_code
operator|==
name|TRUNC_MOD_EXPR
operator|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|simplify_div_or_mod_using_ranges
argument_list|(
name|stmt
argument_list|,
name|rhs
argument_list|,
name|rhs_code
argument_list|)
expr_stmt|;
comment|/* Transform ABS (X) into X or -X as appropriate.  */
if|if
condition|(
name|rhs_code
operator|==
name|ABS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|simplify_abs_using_ranges
argument_list|(
name|stmt
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
operator|&&
name|COMPARISON_CLASS_P
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
block|{
name|simplify_cond_using_ranges
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Stack of dest,src equivalency pairs that need to be restored after    each attempt to thread a block's incoming edge to an outgoing edge.      A NULL entry is used to mark the end of pairs which need to be    restored.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|stack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A trivial wrapper so that we can present the generic jump threading    code with a simple API for simplifying statements.  STMT is the    statement we want to simplify, WITHIN_STMT provides the location    for any overflow warnings.  */
end_comment

begin_function
specifier|static
name|tree
name|simplify_stmt_for_jump_threading
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|within_stmt
parameter_list|)
block|{
comment|/* We only use VRP information to simplify conditionals.  This is      overly conservative, but it's unclear if doing more would be      worth the compile time cost.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
name|NULL
return|;
return|return
name|vrp_evaluate_conditional
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|within_stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Blocks which have more than one predecessor and more than    one successor present jump threading opportunities.  ie,    when the block is reached from a specific predecessor, we    may be able to determine which of the outgoing edges will    be traversed.  When this optimization applies, we are able    to avoid conditionals at runtime and we may expose secondary    optimization opportunities.     This routine is effectively a driver for the generic jump    threading code.  It basically just presents the generic code    with edges that may be suitable for jump threading.     Unlike DOM, we do not iterate VRP if jump threading was successful.    While iterating may expose new opportunities for VRP, it is expected    those opportunities would be very limited and the compile time cost    to expose those opportunities would be significant.      As jump threading opportunities are discovered, they are registered    for later realization.  */
end_comment

begin_function
specifier|static
name|void
name|identify_jump_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|tree
name|dummy
decl_stmt|;
comment|/* Ugh.  When substituting values earlier in this pass we can      wipe the dominance information.  So rebuild the dominator      information as we need it within the jump threading code.  */
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* We do not allow VRP information to be used for jump threading      across a back edge in the CFG.  Otherwise it becomes too      difficult to avoid eliminating loop exit tests.  Of course      EDGE_DFS_BACK is not accurate at this time so we have to      recompute it.  */
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
comment|/* Allocate our unwinder stack to unwind any temporary equivalences      that might be recorded.  */
name|stack
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* To avoid lots of silly node creation, we create a single      conditional and just modify it in-place when attempting to      thread jumps.  */
name|dummy
operator|=
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dummy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Walk through all the blocks finding those which present a      potential jump threading opportunity.  We could set this up      as a dominator walker and record data during the walk, but      I doubt it's worth the effort for the classes of jump      threading opportunities we are trying to identify at this      point in compilation.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|last
decl_stmt|,
name|cond
decl_stmt|;
comment|/* If the generic jump threading code does not find this block 	 interesting, then there is nothing to do.  */
if|if
condition|(
operator|!
name|potentially_threadable_block
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
comment|/* We only care about blocks ending in a COND_EXPR.  While there 	 may be some value in handling SWITCH_EXPR here, I doubt it's 	 terribly important.  */
name|last
operator|=
name|bsi_stmt
argument_list|(
name|bsi_last
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|!=
name|COND_EXPR
condition|)
continue|continue;
comment|/* We're basically looking for any kind of conditional with 	 integral type arguments.  */
name|cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|is_gimple_min_invariant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* We've got a block with multiple predecessors and multiple 	     successors which also ends in a suitable conditional.  For 	     each predecessor, see if we can thread it to a specific 	     successor.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
comment|/* Do not thread across back edges or abnormal edges 		 in the CFG.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_DFS_BACK
operator||
name|EDGE_COMPLEX
operator|)
condition|)
continue|continue;
name|thread_across_edge
argument_list|(
name|dummy
argument_list|,
name|e
argument_list|,
name|true
argument_list|,
operator|&
name|stack
argument_list|,
name|simplify_stmt_for_jump_threading
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* We do not actually update the CFG or SSA graphs at this point as      ASSERT_EXPRs are still in the IL and cfg cleanup code does not yet      handle ASSERT_EXPRs gracefully.  */
block|}
end_function

begin_comment
comment|/* We identified all the jump threading opportunities earlier, but could    not transform the CFG at that time.  This routine transforms the    CFG and arranges for the dominator tree to be rebuilt if necessary.     Note the SSA graph update will occur during the normal TODO    processing by the pass manager.  */
end_comment

begin_function
specifier|static
name|void
name|finalize_jump_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|cfg_altered
init|=
name|false
decl_stmt|;
name|cfg_altered
operator|=
name|thread_through_all_blocks
argument_list|()
expr_stmt|;
comment|/* If we threaded jumps, then we need to recompute the dominance      information, to safely do that we must clean up the CFG first.  */
if|if
condition|(
name|cfg_altered
condition|)
block|{
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|cleanup_tree_cfg
argument_list|()
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Traverse all the blocks folding conditionals with known ranges.  */
end_comment

begin_function
specifier|static
name|void
name|vrp_finalize
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|prop_value_t
modifier|*
name|single_val_range
decl_stmt|;
name|bool
name|do_value_subst_p
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nValue ranges after VRP:\n\n"
argument_list|)
expr_stmt|;
name|dump_all_value_ranges
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* We may have ended with ranges that have exactly one value.  Those      values can be substituted as any other copy/const propagated      value using substitute_and_fold.  */
name|single_val_range
operator|=
name|XNEWVEC
argument_list|(
name|prop_value_t
argument_list|,
name|num_ssa_names
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|single_val_range
argument_list|,
literal|0
argument_list|,
name|num_ssa_names
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|single_val_range
argument_list|)
argument_list|)
expr_stmt|;
name|do_value_subst_p
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vr_value
index|[
name|i
index|]
operator|&&
name|vr_value
index|[
name|i
index|]
operator|->
name|type
operator|==
name|VR_RANGE
operator|&&
name|vr_value
index|[
name|i
index|]
operator|->
name|min
operator|==
name|vr_value
index|[
name|i
index|]
operator|->
name|max
condition|)
block|{
name|single_val_range
index|[
name|i
index|]
operator|.
name|value
operator|=
name|vr_value
index|[
name|i
index|]
operator|->
name|min
expr_stmt|;
name|do_value_subst_p
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_value_subst_p
condition|)
block|{
comment|/* We found no single-valued ranges, don't waste time trying to 	 do single value substitution in substitute_and_fold.  */
name|free
argument_list|(
name|single_val_range
argument_list|)
expr_stmt|;
name|single_val_range
operator|=
name|NULL
expr_stmt|;
block|}
name|substitute_and_fold
argument_list|(
name|single_val_range
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* We must identify jump threading opportunities before we release      the datastructures built by VRP.  */
name|identify_jump_threads
argument_list|()
expr_stmt|;
comment|/* Free allocated memory.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vr_value
index|[
name|i
index|]
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|vr_value
index|[
name|i
index|]
operator|->
name|equiv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vr_value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|single_val_range
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vr_value
argument_list|)
expr_stmt|;
comment|/* So that we can distinguish between VRP data being available      and not available.  */
name|vr_value
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main entry point to VRP (Value Range Propagation).  This pass is    loosely based on J. R. C. Patterson, ``Accurate Static Branch    Prediction by Value Range Propagation,'' in SIGPLAN Conference on    Programming Language Design and Implementation, pp. 67-78, 1995.    Also available at http://citeseer.ist.psu.edu/patterson95accurate.html     This is essentially an SSA-CCP pass modified to deal with ranges    instead of constants.     While propagating ranges, we may find that two or more SSA name    have equivalent, though distinct ranges.  For instance,       1	x_9 = p_3->a;      2	p_4 = ASSERT_EXPR<p_3, p_3 != 0>      3	if (p_4 == q_2)      4	  p_5 = ASSERT_EXPR<p_4, p_4 == q_2>;      5	endif      6	if (q_2) 	    In the code above, pointer p_5 has range [q_2, q_2], but from the    code we can also determine that p_5 cannot be NULL and, if q_2 had    a non-varying range, p_5's range should also be compatible with it.     These equivalences are created by two expressions: ASSERT_EXPR and    copy operations.  Since p_5 is an assertion on p_4, and p_4 was the    result of another assertion, then we can use the fact that p_5 and    p_4 are equivalent when evaluating p_5's range.     Together with value ranges, we also propagate these equivalences    between names so that we can take advantage of information from    multiple ranges when doing final replacement.  Note that this    equivalency relation is transitive but not symmetric.        In the example above, p_5 is equivalent to p_4, q_2 and p_3, but we    cannot assert that q_2 is equivalent to p_5 because q_2 may be used    in contexts where that assertion does not hold (e.g., in line 6).     TODO, the main difference between this pass and Patterson's is that    we do not propagate edge probabilities.  We only compute whether    edges can be taken or not.  That is, instead of having a spectrum    of jump probabilities between 0 and 1, we only deal with 0, 1 and    DON'T KNOW.  In the future, it may be worthwhile to propagate    probabilities to aid branch prediction.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_vrp
parameter_list|(
name|void
parameter_list|)
block|{
name|insert_range_assertions
argument_list|()
expr_stmt|;
name|current_loops
operator|=
name|loop_optimizer_init
argument_list|(
name|LOOPS_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_loops
condition|)
name|scev_initialize
argument_list|(
name|current_loops
argument_list|)
expr_stmt|;
name|vrp_initialize
argument_list|()
expr_stmt|;
name|ssa_propagate
argument_list|(
name|vrp_visit_stmt
argument_list|,
name|vrp_visit_phi_node
argument_list|)
expr_stmt|;
name|vrp_finalize
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_loops
condition|)
block|{
name|scev_finalize
argument_list|()
expr_stmt|;
name|loop_optimizer_finalize
argument_list|(
name|current_loops
argument_list|)
expr_stmt|;
name|current_loops
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* ASSERT_EXPRs must be removed before finalizing jump threads      as finalizing jump threads calls the CFG cleanup code which      does not properly handle ASSERT_EXPRs.  */
name|remove_range_assertions
argument_list|()
expr_stmt|;
comment|/* If we exposed any new variables, go ahead and put them into      SSA form now, before we handle jump threading.  This simplifies      interactions between rewriting of _DECL nodes into SSA form      and rewriting SSA_NAME nodes into SSA form after block      duplication and CFG manipulation.  */
name|update_ssa
argument_list|(
name|TODO_update_ssa
argument_list|)
expr_stmt|;
name|finalize_jump_threads
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_vrp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_vrp
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_vrp
init|=
block|{
literal|"vrp"
block|,
comment|/* name */
name|gate_vrp
block|,
comment|/* gate */
name|execute_vrp
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_VRP
block|,
comment|/* tv_id */
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
name|PROP_smt_usage
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_cleanup_cfg
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
operator||
name|TODO_dump_func
operator||
name|TODO_update_ssa
operator||
name|TODO_update_smt_usage
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

