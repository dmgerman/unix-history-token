begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert function calls to rtl insns, for GNU C compiler.    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"sbitmap.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_comment
comment|/* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */
end_comment

begin_define
define|#
directive|define
name|STACK_BYTES
value|(PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)
end_define

begin_comment
comment|/* Data structure and subroutines used within expand_call.  */
end_comment

begin_struct
struct|struct
name|arg_data
block|{
comment|/* Tree node for this argument.  */
name|tree
name|tree_value
decl_stmt|;
comment|/* Mode for value; TYPE_MODE unless promoted.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Current RTL value for argument, or 0 if it isn't precomputed.  */
name|rtx
name|value
decl_stmt|;
comment|/* Initially-compute RTL value for argument; only for const functions.  */
name|rtx
name|initial_value
decl_stmt|;
comment|/* Register to pass this argument in, 0 if passed on stack, or an      PARALLEL if the arg is to be copied into multiple non-contiguous      registers.  */
name|rtx
name|reg
decl_stmt|;
comment|/* Register to pass this argument in when generating tail call sequence.      This is not the same register as for normal calls on machines with      register windows.  */
name|rtx
name|tail_call_reg
decl_stmt|;
comment|/* If REG is a PARALLEL, this is a copy of VALUE pulled into the correct      form for emit_group_move.  */
name|rtx
name|parallel_value
decl_stmt|;
comment|/* If REG was promoted from the actual mode of the argument expression,      indicates whether the promotion is sign- or zero-extended.  */
name|int
name|unsignedp
decl_stmt|;
comment|/* Number of bytes to put in registers.  0 means put the whole arg      in registers.  Also 0 if not passed in registers.  */
name|int
name|partial
decl_stmt|;
comment|/* Nonzero if argument must be passed on stack.      Note that some arguments may be passed on the stack      even though pass_on_stack is zero, just because FUNCTION_ARG says so.      pass_on_stack identifies arguments that *cannot* go in registers.  */
name|int
name|pass_on_stack
decl_stmt|;
comment|/* Some fields packaged up for locate_and_pad_parm.  */
name|struct
name|locate_and_pad_arg_data
name|locate
decl_stmt|;
comment|/* Location on the stack at which parameter should be stored.  The store      has already been done if STACK == VALUE.  */
name|rtx
name|stack
decl_stmt|;
comment|/* Location on the stack of the start of this argument slot.  This can      differ from STACK if this arg pads downward.  This location is known      to be aligned to FUNCTION_ARG_BOUNDARY.  */
name|rtx
name|stack_slot
decl_stmt|;
comment|/* Place that this stack area has been saved, if needed.  */
name|rtx
name|save_area
decl_stmt|;
comment|/* If an argument's alignment does not permit direct copying into registers,      copy in smaller-sized pieces into pseudos.  These are stored in a      block pointed to by this field.  The next field says how many      word-sized pseudos we made.  */
name|rtx
modifier|*
name|aligned_regs
decl_stmt|;
name|int
name|n_aligned_regs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A vector of one char per byte of stack space.  A byte if nonzero if    the corresponding stack location has been used.    This vector is used to prevent a function call within an argument from    clobbering any stack already set up.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stack_usage_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of STACK_USAGE_MAP.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|highest_outgoing_arg_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A bitmap of virtual-incoming stack space.  Bit is set if the corresponding    stack location's tail call argument has been already stored into the stack.    This bitmap is used to prevent sibling call optimization if function tries    to use parent's incoming argument slots when they have been already    overwritten with tail call arguments.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|stored_args_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack_arg_under_construction is nonzero when an argument may be    initialized with a constructor call (including a C function that    returns a BLKmode struct) and expand_call must take special action    to make sure the object being constructed does not overlap the    argument list for the constructor call.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stack_arg_under_construction
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|emit_call_1
parameter_list|(
name|rtx
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|CUMULATIVE_ARGS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|precompute_register_parameters
parameter_list|(
name|int
parameter_list|,
name|struct
name|arg_data
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|store_one_arg
parameter_list|(
name|struct
name|arg_data
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_unaligned_arguments_into_pseudos
parameter_list|(
name|struct
name|arg_data
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|finalize_must_preallocate
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|arg_data
modifier|*
parameter_list|,
name|struct
name|args_size
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|precompute_arguments
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|arg_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compute_argument_block_size
parameter_list|(
name|int
parameter_list|,
name|struct
name|args_size
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_argument_information
parameter_list|(
name|int
parameter_list|,
name|struct
name|arg_data
modifier|*
parameter_list|,
name|struct
name|args_size
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_argument_addresses
parameter_list|(
name|struct
name|arg_data
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rtx_for_function_call
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_register_parameters
parameter_list|(
name|struct
name|arg_data
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|emit_library_call_value_1
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|libcall_type
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|special_function_p
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_sibcall_argument_overlap_1
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_sibcall_argument_overlap
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|arg_data
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|combine_pending_stack_adjustment_and_call
parameter_list|(
name|int
parameter_list|,
name|struct
name|args_size
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|split_complex_values
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|split_complex_types
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
end_ifdef

begin_function_decl
specifier|static
name|rtx
name|save_fixed_argument_area
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|restore_fixed_argument_area
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Force FUNEXP into a form suitable for the address of a CALL,    and return that as an rtx.  Also load the static chain register    if FNDECL is a nested function.     CALL_FUSAGE points to a variable holding the prospective    CALL_INSN_FUNCTION_USAGE information.  */
end_comment

begin_function
name|rtx
name|prepare_call_address
parameter_list|(
name|rtx
name|funexp
parameter_list|,
name|rtx
name|static_chain_value
parameter_list|,
name|rtx
modifier|*
name|call_fusage
parameter_list|,
name|int
name|reg_parm_seen
parameter_list|,
name|int
name|sibcallp
parameter_list|)
block|{
comment|/* Make a valid memory address and copy constants through pseudo-regs,      but not for a constant address if -fno-function-cse.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|funexp
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
comment|/* If we are using registers for parameters, force the        function address into a register now.  */
name|funexp
operator|=
operator|(
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|reg_parm_seen
operator|)
condition|?
name|force_not_mem
argument_list|(
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|)
else|:
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sibcallp
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_FUNCTION_CSE
if|if
condition|(
name|optimize
operator|&&
operator|!
name|flag_no_function_cse
condition|)
name|funexp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|static_chain_value
operator|!=
literal|0
condition|)
block|{
name|static_chain_value
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|static_chain_value
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|static_chain_rtx
argument_list|,
name|static_chain_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|static_chain_rtx
argument_list|)
condition|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|static_chain_rtx
argument_list|)
expr_stmt|;
block|}
return|return
name|funexp
return|;
block|}
end_function

begin_comment
comment|/* Generate instructions to call function FUNEXP,    and optionally pop the results.    The CALL_INSN is the first insn generated.     FNDECL is the declaration node of the function.  This is given to the    macro RETURN_POPS_ARGS to determine whether this function pops its own args.     FUNTYPE is the data type of the function.  This is given to the macro    RETURN_POPS_ARGS to determine whether this function pops its own args.    We used to allow an identifier for library functions, but that doesn't    work when the return type is an aggregate type and the calling convention    says that the pointer to this aggregate is to be popped by the callee.     STACK_SIZE is the number of bytes of arguments on the stack,    ROUNDED_STACK_SIZE is that number rounded up to    PREFERRED_STACK_BOUNDARY; zero if the size is variable.  This is    both to put into the call insn and to generate explicit popping    code if necessary.     STRUCT_VALUE_SIZE is the number of bytes wanted in a structure value.    It is zero if this call doesn't want a structure value.     NEXT_ARG_REG is the rtx that results from executing      FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1)    just after all the args have had their registers assigned.    This could be whatever you like, but normally it is the first    arg-register beyond those used for args in this call,    or 0 if all the arg-registers are used in this call.    It is passed on to `gen_call' so you can put this info in the call insn.     VALREG is a hard register in which a value is returned,    or 0 if the call does not return a value.     OLD_INHIBIT_DEFER_POP is the value that `inhibit_defer_pop' had before    the args to this call were processed.    We restore `inhibit_defer_pop' to that value.     CALL_FUSAGE is either empty or an EXPR_LIST of USE expressions that    denote registers used by the called function.  */
end_comment

begin_function
specifier|static
name|void
name|emit_call_1
parameter_list|(
name|rtx
name|funexp
parameter_list|,
name|tree
name|fntree
parameter_list|,
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|funtype
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|stack_size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|rounded_stack_size
parameter_list|,
name|HOST_WIDE_INT
name|struct_value_size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|next_arg_reg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|valreg
parameter_list|,
name|int
name|old_inhibit_defer_pop
parameter_list|,
name|rtx
name|call_fusage
parameter_list|,
name|int
name|ecf_flags
parameter_list|,
name|CUMULATIVE_ARGS
modifier|*
name|args_so_far
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|rounded_stack_size_rtx
init|=
name|GEN_INT
argument_list|(
name|rounded_stack_size
argument_list|)
decl_stmt|;
name|rtx
name|call_insn
decl_stmt|;
name|int
name|already_popped
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|n_popped
init|=
name|RETURN_POPS_ARGS
argument_list|(
name|fndecl
argument_list|,
name|funtype
argument_list|,
name|stack_size
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_call
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_call_value
argument_list|)
name|rtx
name|struct_value_size_rtx
decl_stmt|;
name|struct_value_size_rtx
operator|=
name|GEN_INT
argument_list|(
name|struct_value_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CALL_POPS_ARGS
name|n_popped
operator|+=
name|CALL_POPS_ARGS
argument_list|(
operator|*
name|args_so_far
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Ensure address is valid.  SYMBOL_REF is already valid, so no need,      and we don't want to load it into a register as an optimization,      because prepare_call_address already did it if it should be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|funexp
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|funexp
operator|=
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_sibcall_pop
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_sibcall_value_pop
argument_list|)
if|if
condition|(
operator|(
name|ecf_flags
operator|&
name|ECF_SIBCALL
operator|)
operator|&&
name|HAVE_sibcall_pop
operator|&&
name|HAVE_sibcall_value_pop
operator|&&
operator|(
name|n_popped
operator|>
literal|0
operator|||
name|stack_size
operator|==
literal|0
operator|)
condition|)
block|{
name|rtx
name|n_pop
init|=
name|GEN_INT
argument_list|(
name|n_popped
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
comment|/* If this subroutine pops its own args, record that in the call insn 	 if possible, for the sake of frame pointer elimination.  */
if|if
condition|(
name|valreg
condition|)
name|pat
operator|=
name|GEN_SIBCALL_VALUE_POP
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|n_pop
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|GEN_SIBCALL_POP
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|n_pop
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|already_popped
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_call_pop
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_call_value_pop
argument_list|)
comment|/* If the target has "call" or "call_value" insns, then prefer them      if no arguments are actually popped.  If the target does not have      "call" or "call_value" insns, then we must use the popping versions      even if the call has no arguments to pop.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_call
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_call_value
argument_list|)
if|if
condition|(
name|HAVE_call
operator|&&
name|HAVE_call_value
operator|&&
name|HAVE_call_pop
operator|&&
name|HAVE_call_value_pop
operator|&&
name|n_popped
operator|>
literal|0
operator|&&
operator|!
operator|(
name|ecf_flags
operator|&
name|ECF_SP_DEPRESSED
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|HAVE_call_pop
operator|&&
name|HAVE_call_value_pop
condition|)
endif|#
directive|endif
block|{
name|rtx
name|n_pop
init|=
name|GEN_INT
argument_list|(
name|n_popped
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
comment|/* If this subroutine pops its own args, record that in the call insn 	 if possible, for the sake of frame pointer elimination.  */
if|if
condition|(
name|valreg
condition|)
name|pat
operator|=
name|GEN_CALL_VALUE_POP
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|n_pop
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|GEN_CALL_POP
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|n_pop
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|already_popped
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_sibcall
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_sibcall_value
argument_list|)
if|if
condition|(
operator|(
name|ecf_flags
operator|&
name|ECF_SIBCALL
operator|)
operator|&&
name|HAVE_sibcall
operator|&&
name|HAVE_sibcall_value
condition|)
block|{
if|if
condition|(
name|valreg
condition|)
name|emit_call_insn
argument_list|(
name|GEN_SIBCALL_VALUE
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_call_insn
argument_list|(
name|GEN_SIBCALL
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|struct_value_size_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_call
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_call_value
argument_list|)
if|if
condition|(
name|HAVE_call
operator|&&
name|HAVE_call_value
condition|)
block|{
if|if
condition|(
name|valreg
condition|)
name|emit_call_insn
argument_list|(
name|GEN_CALL_VALUE
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_call_insn
argument_list|(
name|GEN_CALL
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|struct_value_size_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* Find the call we just emitted.  */
name|call_insn
operator|=
name|last_call_insn
argument_list|()
expr_stmt|;
comment|/* Mark memory as used for "pure" function call.  */
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_PURE
condition|)
name|call_fusage
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|call_fusage
argument_list|)
expr_stmt|;
comment|/* Put the register usage information there.  */
name|add_function_usage_to
argument_list|(
name|call_insn
argument_list|,
name|call_fusage
argument_list|)
expr_stmt|;
comment|/* If this is a const call, then set the insn's unchanging bit.  */
if|if
condition|(
name|ecf_flags
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
condition|)
name|CONST_OR_PURE_CALL_P
argument_list|(
name|call_insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this call can't throw, attach a REG_EH_REGION reg note to that      effect.  */
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_NOTHROW
condition|)
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|rn
init|=
name|lookup_stmt_eh_region
argument_list|(
name|fntree
argument_list|)
decl_stmt|;
comment|/* If rn< 0, then either (1) tree-ssa not used or (2) doesn't 	 throw, which we already took care of.  */
if|if
condition|(
name|rn
operator|>
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|GEN_INT
argument_list|(
name|rn
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
name|note_current_region_may_contain_throw
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_NORETURN
condition|)
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NORETURN
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_RETURNS_TWICE
condition|)
block|{
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_SETJMP
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_calls_setjmp
operator|=
literal|1
expr_stmt|;
block|}
name|SIBLING_CALL_P
argument_list|(
name|call_insn
argument_list|)
operator|=
operator|(
operator|(
name|ecf_flags
operator|&
name|ECF_SIBCALL
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Restore this now, so that we do defer pops for this call's args      if the context of the call as a whole permits.  */
name|inhibit_defer_pop
operator|=
name|old_inhibit_defer_pop
expr_stmt|;
if|if
condition|(
name|n_popped
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|already_popped
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
name|rounded_stack_size
operator|-=
name|n_popped
expr_stmt|;
name|rounded_stack_size_rtx
operator|=
name|GEN_INT
argument_list|(
name|rounded_stack_size
argument_list|)
expr_stmt|;
name|stack_pointer_delta
operator|-=
name|n_popped
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* If returning from the subroutine does not automatically pop the args, 	 we need an instruction to pop them sooner or later. 	 Perhaps do it now; perhaps just record how much space to pop later.  	 If returning from the subroutine does pop the args, indicate that the 	 stack pointer will be changed.  */
if|if
condition|(
name|rounded_stack_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ecf_flags
operator|&
operator|(
name|ECF_SP_DEPRESSED
operator||
name|ECF_NORETURN
operator|)
condition|)
comment|/* Just pretend we did the pop.  */
name|stack_pointer_delta
operator|-=
name|rounded_stack_size
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_defer_pop
operator|&&
name|inhibit_defer_pop
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ecf_flags
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
operator|)
condition|)
name|pending_stack_adjust
operator|+=
name|rounded_stack_size
expr_stmt|;
else|else
name|adjust_stack
argument_list|(
name|rounded_stack_size_rtx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* When we accumulate outgoing args, we must avoid any stack manipulations.      Restore the stack pointer to its original value now.  Usually      ACCUMULATE_OUTGOING_ARGS targets don't get here, but there are exceptions.      On  i386 ACCUMULATE_OUTGOING_ARGS can be enabled on demand, and      popping variants of functions exist as well.       ??? We may optimize similar to defer_pop above, but it is      probably not worthwhile.       ??? It will be worthwhile to enable combine_stack_adjustments even for      such machines.  */
elseif|else
if|if
condition|(
name|n_popped
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|n_popped
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if the function identified by NAME and FNDECL is one with    special properties we wish to know about.     For example, if the function might return more than one time (setjmp), then    set RETURNS_TWICE to a nonzero value.     Similarly set NORETURN if the function is in the longjmp family.     Set MAY_BE_ALLOCA for any memory allocation function that might allocate    space from the stack such as alloca.  */
end_comment

begin_function
specifier|static
name|int
name|special_function_p
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|fndecl
operator|&&
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|<=
literal|17
comment|/* Exclude functions not at the file scope, or not `extern', 	 since they are not the magic functions we would otherwise 	 think they are. 	 FIXME: this should be handled with attributes, not with this 	 hacky imitation of DECL_ASSEMBLER_NAME.  It's (also) wrong 	 because you can declare fork() inside a function if you 	 wish.  */
operator|&&
operator|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
name|TRANSLATION_UNIT_DECL
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
init|=
name|name
decl_stmt|;
comment|/* We assume that alloca will always be called by name.  It 	 makes no sense to pass it as a pointer-to-function to 	 anything that does not understand its behavior.  */
if|if
condition|(
operator|(
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|6
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'a'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"alloca"
argument_list|)
operator|)
operator|||
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|16
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_alloca"
argument_list|)
operator|)
operator|)
condition|)
name|flags
operator||=
name|ECF_MAY_BE_ALLOCA
expr_stmt|;
comment|/* Disregard prefix _, __ or __x.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'x'
condition|)
name|tname
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
name|tname
operator|+=
literal|2
expr_stmt|;
else|else
name|tname
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
operator|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"setjmp"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"setjmp_syscall"
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"sigsetjmp"
argument_list|)
operator|)
operator|||
operator|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"savectx"
argument_list|)
operator|)
condition|)
name|flags
operator||=
name|ECF_RETURNS_TWICE
expr_stmt|;
if|if
condition|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"siglongjmp"
argument_list|)
condition|)
name|flags
operator||=
name|ECF_NORETURN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'q'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"qsetjmp"
argument_list|)
operator|)
operator|||
operator|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'v'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"vfork"
argument_list|)
operator|)
operator|||
operator|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'g'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"getcontext"
argument_list|)
operator|)
condition|)
name|flags
operator||=
name|ECF_RETURNS_TWICE
expr_stmt|;
elseif|else
if|if
condition|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'l'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"longjmp"
argument_list|)
condition|)
name|flags
operator||=
name|ECF_NORETURN
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero when FNDECL represents a call to setjmp.  */
end_comment

begin_function
name|int
name|setjmp_call_p
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
return|return
name|special_function_p
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
operator|&
name|ECF_RETURNS_TWICE
return|;
block|}
end_function

begin_comment
comment|/* Return true when exp contains alloca call.  */
end_comment

begin_function
name|bool
name|alloca_call_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
operator|(
name|special_function_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&
name|ECF_MAY_BE_ALLOCA
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Detect flags (function attributes) from the function decl or type node.  */
end_comment

begin_function
name|int
name|flags_from_decl_or_type
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|tree
name|type
init|=
name|exp
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* The function exp may have the `malloc' attribute.  */
if|if
condition|(
name|DECL_IS_MALLOC
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_MALLOC
expr_stmt|;
comment|/* The function exp may have the `returns_twice' attribute.  */
if|if
condition|(
name|DECL_IS_RETURNS_TWICE
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_RETURNS_TWICE
expr_stmt|;
comment|/* The function exp may have the `pure' attribute.  */
if|if
condition|(
name|DECL_IS_PURE
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_PURE
expr_stmt|;
if|if
condition|(
name|DECL_IS_NOVOPS
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_NOVOPS
expr_stmt|;
if|if
condition|(
name|TREE_NOTHROW
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_NOTHROW
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_CONST
expr_stmt|;
name|flags
operator|=
name|special_function_p
argument_list|(
name|exp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|exp
argument_list|)
operator|&&
name|TYPE_READONLY
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_CONST
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_NORETURN
expr_stmt|;
comment|/* Mark if the function returns with the stack pointer depressed.   We      cannot consider it pure or constant in that case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TYPE_RETURNS_STACK_DEPRESSED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|flags
operator||=
name|ECF_SP_DEPRESSED
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|ECF_PURE
operator||
name|ECF_CONST
operator|)
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Detect flags from a CALL_EXPR.  */
end_comment

begin_function
name|int
name|call_expr_flags
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|tree
name|decl
init|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
condition|)
name|flags
operator|=
name|flags_from_decl_or_type
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|flags
operator|=
name|flags_from_decl_or_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Precompute all register parameters as described by ARGS, storing values    into fields within the ARGS array.     NUM_ACTUALS indicates the total number elements in the ARGS array.     Set REG_PARM_SEEN if we encounter a register parameter.  */
end_comment

begin_function
specifier|static
name|void
name|precompute_register_parameters
parameter_list|(
name|int
name|num_actuals
parameter_list|,
name|struct
name|arg_data
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|reg_parm_seen
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|reg_parm_seen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
block|{
operator|*
name|reg_parm_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|value
operator|==
literal|0
condition|)
block|{
name|push_temp_slots
argument_list|()
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|expand_normal
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
block|}
comment|/* If the value is a non-legitimate constant, force it into a 	   pseudo now.  TLS symbols sometimes need a call to resolve.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|force_reg
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
comment|/* If we are to promote the function arg to a wider mode, 	   do it now.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|convert_modes
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* If we're going to have to load the value by parts, pull the 	   parts into pseudos.  The part extraction process can involve 	   non-trivial computation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|parallel_value
operator|=
name|emit_group_load_into_temps
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|type
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the value is expensive, and we are inside an appropriately 	   short loop, put the value into a pseudo and then put the pseudo 	   into the hard reg.  	   For small register classes, also do this if this call uses 	   register parameters.  This is to avoid reload conflicts while 	   loading the parameters registers.  */
elseif|else
if|if
condition|(
operator|(
operator|!
operator|(
name|REG_P
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|!=
name|BLKmode
operator|&&
name|rtx_cost
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|SET
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|&&
operator|(
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
operator|*
name|reg_parm_seen
operator|)
operator|||
name|optimize
operator|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|copy_to_mode_reg
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
end_ifdef

begin_comment
comment|/* The argument list is the property of the called routine and it      may clobber it.  If the fixed area has been used for previous      parameters, we must save and restore it.  */
end_comment

begin_function
specifier|static
name|rtx
name|save_fixed_argument_area
parameter_list|(
name|int
name|reg_parm_stack_space
parameter_list|,
name|rtx
name|argblock
parameter_list|,
name|int
modifier|*
name|low_to_save
parameter_list|,
name|int
modifier|*
name|high_to_save
parameter_list|)
block|{
name|int
name|low
decl_stmt|;
name|int
name|high
decl_stmt|;
comment|/* Compute the boundary of the area that needs to be saved, if any.  */
name|high
operator|=
name|reg_parm_stack_space
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|high
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|high
operator|>
name|highest_outgoing_arg_in_use
condition|)
name|high
operator|=
name|highest_outgoing_arg_in_use
expr_stmt|;
for|for
control|(
name|low
operator|=
literal|0
init|;
name|low
operator|<
name|high
condition|;
name|low
operator|++
control|)
if|if
condition|(
name|stack_usage_map
index|[
name|low
index|]
operator|!=
literal|0
condition|)
block|{
name|int
name|num_to_save
decl_stmt|;
name|enum
name|machine_mode
name|save_mode
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|rtx
name|stack_area
decl_stmt|;
name|rtx
name|save_area
decl_stmt|;
while|while
condition|(
name|stack_usage_map
index|[
operator|--
name|high
index|]
operator|==
literal|0
condition|)
empty_stmt|;
operator|*
name|low_to_save
operator|=
name|low
expr_stmt|;
operator|*
name|high_to_save
operator|=
name|high
expr_stmt|;
name|num_to_save
operator|=
name|high
operator|-
name|low
operator|+
literal|1
expr_stmt|;
name|save_mode
operator|=
name|mode_for_size
argument_list|(
name|num_to_save
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we don't have the required alignment, must do this 	   in BLKmode.  */
if|if
condition|(
operator|(
name|low
operator|&
operator|(
name|MIN
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|save_mode
argument_list|)
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|UNITS_PER_WORD
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|save_mode
operator|=
name|BLKmode
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|delta
operator|=
operator|-
name|high
expr_stmt|;
else|#
directive|else
name|delta
operator|=
name|low
expr_stmt|;
endif|#
directive|endif
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|delta
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|stack_area
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_mode
operator|==
name|BLKmode
condition|)
block|{
name|save_area
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|num_to_save
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|stack_area
argument_list|,
name|GEN_INT
argument_list|(
name|num_to_save
argument_list|)
argument_list|,
name|BLOCK_OP_CALL_PARM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
return|return
name|save_area
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_fixed_argument_area
parameter_list|(
name|rtx
name|save_area
parameter_list|,
name|rtx
name|argblock
parameter_list|,
name|int
name|high_to_save
parameter_list|,
name|int
name|low_to_save
parameter_list|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|save_area
argument_list|)
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|rtx
name|stack_area
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|delta
operator|=
operator|-
name|high_to_save
expr_stmt|;
else|#
directive|else
name|delta
operator|=
name|low_to_save
expr_stmt|;
endif|#
directive|endif
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|delta
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|stack_area
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_mode
operator|!=
name|BLKmode
condition|)
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|save_area
argument_list|)
expr_stmt|;
else|else
name|emit_block_move
argument_list|(
name|stack_area
argument_list|,
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high_to_save
operator|-
name|low_to_save
operator|+
literal|1
argument_list|)
argument_list|,
name|BLOCK_OP_CALL_PARM
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REG_PARM_STACK_SPACE */
end_comment

begin_comment
comment|/* If any elements in ARGS refer to parameters that are to be passed in    registers, but not in memory, and whose alignment does not permit a    direct copy into registers.  Copy the values into a group of pseudos    which we will later copy into the appropriate hard registers.     Pseudos for each unaligned argument will be stored into the array    args[argnum].aligned_regs.  The caller is responsible for deallocating    the aligned_regs array if it is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|store_unaligned_arguments_into_pseudos
parameter_list|(
name|struct
name|arg_data
modifier|*
name|args
parameter_list|,
name|int
name|num_actuals
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|BLKmode
operator|&&
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|BITS_PER_WORD
argument_list|)
operator|)
condition|)
block|{
name|int
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|endian_correction
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
condition|)
block|{
name|gcc_assert
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|%
name|UNITS_PER_WORD
operator|==
literal|0
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
operator|=
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
operator|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
operator|=
name|XNEWVEC
argument_list|(
name|rtx
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
argument_list|)
expr_stmt|;
comment|/* Structures smaller than a word are normally aligned to the 	   least significant byte.  On a BYTES_BIG_ENDIAN machine, 	   this means we must skip the empty high order bytes when 	   calculating the bit offset.  */
if|if
condition|(
name|bytes
operator|<
name|UNITS_PER_WORD
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
operator|&&
operator|(
name|BLOCK_REG_PADDING
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|downward
operator|)
else|#
directive|else
operator|&&
name|BYTES_BIG_ENDIAN
endif|#
directive|endif
condition|)
name|endian_correction
operator|=
name|BITS_PER_WORD
operator|-
name|bytes
operator|*
name|BITS_PER_UNIT
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|rtx
name|word
init|=
name|operand_subword_force
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|j
argument_list|,
name|BLKmode
argument_list|)
decl_stmt|;
name|int
name|bitsize
init|=
name|MIN
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
index|[
name|j
index|]
operator|=
name|reg
expr_stmt|;
name|word
operator|=
name|extract_bit_field
argument_list|(
name|word
argument_list|,
name|bitsize
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|)
expr_stmt|;
comment|/* There is no need to restrict this code to loading items 	       in TYPE_ALIGN sized hunks.  The bitfield instructions can 	       load up entire word sized registers efficiently.  	       ??? This may not be needed anymore. 	       We use to emit a clobber here but that doesn't let later 	       passes optimize the instructions we emit.  By storing 0 into 	       the register later passes know the first AND to zero out the 	       bitfield being set in the register is unnecessary.  The store 	       of 0 will be deleted as will at least the first AND.  */
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|bitsize
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|store_bit_field
argument_list|(
name|reg
argument_list|,
name|bitsize
argument_list|,
name|endian_correction
argument_list|,
name|word_mode
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Fill in ARGS_SIZE and ARGS array based on the parameters found in    ACTPARMS.     NUM_ACTUALS is the total number of parameters.     N_NAMED_ARGS is the total number of named arguments.     FNDECL is the tree code for the target of this call (if known)     ARGS_SO_FAR holds state needed by the target to know where to place    the next argument.     REG_PARM_STACK_SPACE is the number of bytes of stack space reserved    for arguments which are passed in registers.     OLD_STACK_LEVEL is a pointer to an rtx which olds the old stack level    and may be modified by this routine.     OLD_PENDING_ADJ, MUST_PREALLOCATE and FLAGS are pointers to integer    flags which may may be modified by this routine.     MAY_TAILCALL is cleared if we encounter an invisible pass-by-reference    that requires allocation of stack space.     CALL_FROM_THUNK_P is true if this call is the jump from a thunk to    the thunked-to function.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_argument_information
parameter_list|(
name|int
name|num_actuals
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|arg_data
modifier|*
name|args
parameter_list|,
name|struct
name|args_size
modifier|*
name|args_size
parameter_list|,
name|int
name|n_named_args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|actparms
parameter_list|,
name|tree
name|fndecl
parameter_list|,
name|CUMULATIVE_ARGS
modifier|*
name|args_so_far
parameter_list|,
name|int
name|reg_parm_stack_space
parameter_list|,
name|rtx
modifier|*
name|old_stack_level
parameter_list|,
name|int
modifier|*
name|old_pending_adj
parameter_list|,
name|int
modifier|*
name|must_preallocate
parameter_list|,
name|int
modifier|*
name|ecf_flags
parameter_list|,
name|bool
modifier|*
name|may_tailcall
parameter_list|,
name|bool
name|call_from_thunk_p
parameter_list|)
block|{
comment|/* 1 if scanning parms front to back, -1 if scanning back to front.  */
name|int
name|inc
decl_stmt|;
comment|/* Count arg position in order args appear.  */
name|int
name|argpos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|p
decl_stmt|;
name|args_size
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
name|args_size
operator|->
name|var
operator|=
literal|0
expr_stmt|;
comment|/* In this loop, we consider args in the order they are written.      We fill up ARGS from the front or from the back if necessary      so that in any case the first arg to be pushed ends up at the front.  */
if|if
condition|(
name|PUSH_ARGS_REVERSED
condition|)
block|{
name|i
operator|=
name|num_actuals
operator|-
literal|1
operator|,
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* In this case, must reverse order of args 	 so that we compute and push the last arg first.  */
block|}
else|else
block|{
name|i
operator|=
literal|0
operator|,
name|inc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* I counts args in order (to be) pushed; ARGPOS counts in order written.  */
for|for
control|(
name|p
operator|=
name|actparms
operator|,
name|argpos
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|,
name|i
operator|+=
name|inc
operator|,
name|argpos
operator|++
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Replace erroneous argument with constant zero.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|integer_zero_node
operator|,
name|type
operator|=
name|integer_type_node
expr_stmt|;
comment|/* If TYPE is a transparent union, pass things the way we would 	 pass the first field of the union.  We have already verified that 	 the modes are the same.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decide where to pass this arg.  	 args[i].reg is nonzero if all or part is passed in registers.  	 args[i].partial is nonzero if part but not all is passed in registers, 	 and the exact value says how many bytes are passed in registers.  	 args[i].pass_on_stack is nonzero if the argument must at least be 	 computed on the stack.  It may then be loaded back into registers 	 if args[i].reg is nonzero.  	 These decisions are driven by the FUNCTION_... macros and must agree 	 with those made by function.c.  */
comment|/* See if this argument should be passed by invisible reference.  */
if|if
condition|(
name|pass_by_reference
argument_list|(
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
condition|)
block|{
name|bool
name|callee_copies
decl_stmt|;
name|tree
name|base
decl_stmt|;
name|callee_copies
operator|=
name|reference_callee_copied
argument_list|(
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
comment|/* If we're compiling a thunk, pass through invisible references 	     instead of making a copy.  */
if|if
condition|(
name|call_from_thunk_p
operator|||
operator|(
name|callee_copies
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|base
operator|=
name|get_base_address
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|DECL_P
argument_list|(
name|base
argument_list|)
operator|||
name|MEM_P
argument_list|(
name|DECL_RTL
argument_list|(
name|base
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* We can't use sibcalls if a callee-copied argument is 		 stored in the current function's frame.  */
if|if
condition|(
operator|!
name|call_from_thunk_p
operator|&&
name|DECL_P
argument_list|(
name|base
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|base
argument_list|)
condition|)
operator|*
name|may_tailcall
operator|=
name|false
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|build_fold_addr_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
expr_stmt|;
operator|*
name|ecf_flags
operator|&=
operator|~
operator|(
name|ECF_CONST
operator||
name|ECF_LIBCALL_BLOCK
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We make a copy of the object and pass the address to the 		 function being called.  */
name|rtx
name|copy
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
operator|&&
operator|(
literal|0
operator|<
name|compare_tree_int
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|STACK_CHECK_MAX_VAR_SIZE
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* This is a variable-sized object.  Make space on the stack 		     for it.  */
name|rtx
name|size_rtx
init|=
name|expr_size
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|old_stack_level
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
operator|*
name|old_pending_adj
operator|=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
name|copy
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|allocate_dynamic_stack_space
argument_list|(
name|size_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|copy
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|copy
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|callee_copies
condition|)
operator|*
name|ecf_flags
operator|&=
operator|~
operator|(
name|ECF_CONST
operator||
name|ECF_LIBCALL_BLOCK
operator|)
expr_stmt|;
else|else
operator|*
name|ecf_flags
operator|&=
operator|~
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator||
name|ECF_LIBCALL_BLOCK
operator|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|build_fold_addr_expr
argument_list|(
name|make_tree
argument_list|(
name|type
argument_list|,
name|copy
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
expr_stmt|;
operator|*
name|may_tailcall
operator|=
name|false
expr_stmt|;
block|}
block|}
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|promote_function_args
argument_list|(
name|fndecl
condition|?
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
else|:
literal|0
argument_list|)
condition|)
name|mode
operator|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|unsignedp
operator|=
name|unsignedp
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|FUNCTION_ARG
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
comment|/* If this is a sibling call and the machine has register windows, the 	 register window has to be unwinded before calling the routine, so 	 arguments have to go into the incoming registers.  */
name|args
index|[
name|i
index|]
operator|.
name|tail_call_reg
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
else|#
directive|else
name|args
index|[
name|i
index|]
operator|.
name|tail_call_reg
operator|=
name|args
index|[
name|i
index|]
operator|.
name|reg
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
condition|)
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|=
name|targetm
operator|.
name|calls
operator|.
name|arg_partial_bytes
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|=
name|targetm
operator|.
name|calls
operator|.
name|must_pass_in_stack
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If FUNCTION_ARG returned a (parallel [(expr_list (nil) ...) ...]), 	 it means that we are to pass this arg in the register(s) designated 	 by the PARALLEL, but also to pass it in the stack.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|=
literal|1
expr_stmt|;
comment|/* If this is an addressable type, we must preallocate the stack 	 since we must evaluate the object into its final location.  	 If this is to be passed in both registers and the stack, it is simpler 	 to preallocate.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|)
condition|)
operator|*
name|must_preallocate
operator|=
literal|1
expr_stmt|;
comment|/* If this is an addressable type, we cannot pre-evaluate it.  Thus, 	 we cannot consider this function call constant.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
operator|*
name|ecf_flags
operator|&=
operator|~
name|ECF_LIBCALL_BLOCK
expr_stmt|;
comment|/* Compute the stack-size of this argument.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|!=
literal|0
operator|||
name|reg_parm_stack_space
operator|>
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|locate_and_pad_parm
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
literal|1
argument_list|,
else|#
directive|else
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|?
literal|0
else|:
name|args
index|[
name|i
index|]
operator|.
name|partial
argument_list|,
name|fndecl
argument_list|,
name|args_size
argument_list|,
operator|&
name|args
index|[
name|i
index|]
operator|.
name|locate
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
else|else
comment|/* The argument is passed entirely in registers.  See at which 	   end it should be padded.  */
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|where_pad
operator|=
name|BLOCK_REG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<=
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Update ARGS_SIZE, the total stack space for args so far.  */
name|args_size
operator|->
name|constant
operator|+=
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|constant
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|var
condition|)
name|ADD_PARM_SIZE
argument_list|(
operator|*
name|args_size
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|var
argument_list|)
expr_stmt|;
comment|/* Increment ARGS_SO_FAR, which has info about which arg-registers 	 have been used, etc.  */
name|FUNCTION_ARG_ADVANCE
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update ARGS_SIZE to contain the total size for the argument block.    Return the original constant component of the argument block's size.     REG_PARM_STACK_SPACE holds the number of bytes of stack space reserved    for arguments passed in registers.  */
end_comment

begin_function
specifier|static
name|int
name|compute_argument_block_size
parameter_list|(
name|int
name|reg_parm_stack_space
parameter_list|,
name|struct
name|args_size
modifier|*
name|args_size
parameter_list|,
name|int
name|preferred_stack_boundary
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|unadjusted_args_size
init|=
name|args_size
operator|->
name|constant
decl_stmt|;
comment|/* For accumulate outgoing args mode we don't need to align, since the frame      will be already aligned.  Align to STACK_BOUNDARY in order to prevent      backends from generating misaligned frame sizes.  */
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|preferred_stack_boundary
operator|>
name|STACK_BOUNDARY
condition|)
name|preferred_stack_boundary
operator|=
name|STACK_BOUNDARY
expr_stmt|;
comment|/* Compute the actual size of the argument block required.  The variable      and constant sizes must be combined, the size may have to be rounded,      and there may be a minimum required size.  */
if|if
condition|(
name|args_size
operator|->
name|var
condition|)
block|{
name|args_size
operator|->
name|var
operator|=
name|ARGS_SIZE_TREE
argument_list|(
operator|*
name|args_size
argument_list|)
expr_stmt|;
name|args_size
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
name|preferred_stack_boundary
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|preferred_stack_boundary
operator|>
literal|1
condition|)
block|{
comment|/* We don't handle this case yet.  To handle it correctly we have 	     to add the delta, round and subtract the delta. 	     Currently no machine description requires this support.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|stack_pointer_delta
operator|&
operator|(
name|preferred_stack_boundary
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|args_size
operator|->
name|var
operator|=
name|round_up
argument_list|(
name|args_size
operator|->
name|var
argument_list|,
name|preferred_stack_boundary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_parm_stack_space
operator|>
literal|0
condition|)
block|{
name|args_size
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|args_size
operator|->
name|var
argument_list|,
name|ssize_int
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
comment|/* The area corresponding to register parameters is not to count in 	     the size of the block we need.  So make the adjustment.  */
name|args_size
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|args_size
operator|->
name|var
argument_list|,
name|ssize_int
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|preferred_stack_boundary
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|preferred_stack_boundary
operator|<
literal|1
condition|)
name|preferred_stack_boundary
operator|=
literal|1
expr_stmt|;
name|args_size
operator|->
name|constant
operator|=
operator|(
operator|(
operator|(
name|args_size
operator|->
name|constant
operator|+
name|stack_pointer_delta
operator|+
name|preferred_stack_boundary
operator|-
literal|1
operator|)
operator|/
name|preferred_stack_boundary
operator|*
name|preferred_stack_boundary
operator|)
operator|-
name|stack_pointer_delta
operator|)
expr_stmt|;
name|args_size
operator|->
name|constant
operator|=
name|MAX
argument_list|(
name|args_size
operator|->
name|constant
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
name|args_size
operator|->
name|constant
operator|-=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|unadjusted_args_size
return|;
block|}
end_function

begin_comment
comment|/* Precompute parameters as needed for a function call.     FLAGS is mask of ECF_* constants.     NUM_ACTUALS is the number of arguments.     ARGS is an array containing information for each argument; this    routine fills in the INITIAL_VALUE and VALUE fields for each    precomputed argument.  */
end_comment

begin_function
specifier|static
name|void
name|precompute_arguments
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|num_actuals
parameter_list|,
name|struct
name|arg_data
modifier|*
name|args
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* If this is a libcall, then precompute all arguments so that we do not      get extraneous instructions emitted as part of the libcall sequence.  */
comment|/* If we preallocated the stack space, and some arguments must be passed      on the stack, then we must precompute any parameter which contains a      function call which will store arguments on the stack.      Otherwise, evaluating the parameter may clobber previous parameters      which have already been stored into the stack.  (we have code to avoid      such case by saving the outgoing stack arguments, but it results in      worse code)  */
if|if
condition|(
operator|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
operator|)
operator|==
literal|0
operator|&&
operator|!
name|ACCUMULATE_OUTGOING_ARGS
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
operator|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|!=
name|CALL_EXPR
condition|)
continue|continue;
comment|/* If this is an addressable type, we cannot pre-evaluate it.  */
name|gcc_assert
argument_list|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|initial_value
operator|=
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|expand_normal
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|args
index|[
name|i
index|]
operator|.
name|mode
condition|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|convert_modes
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|mode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|unsignedp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PROMOTE_FUNCTION_MODE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PROMOTE_MODE
argument_list|)
comment|/* CSE will replace this only if it contains args[i].value 	     pseudo, so convert it down to the declared mode using 	     a SUBREG.  */
if|if
condition|(
name|REG_P
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|initial_value
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|initial_value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_SET
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|initial_value
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|unsignedp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given the current state of MUST_PREALLOCATE and information about    arguments to a function call in NUM_ACTUALS, ARGS and ARGS_SIZE,    compute and return the final value for MUST_PREALLOCATE.  */
end_comment

begin_function
specifier|static
name|int
name|finalize_must_preallocate
parameter_list|(
name|int
name|must_preallocate
parameter_list|,
name|int
name|num_actuals
parameter_list|,
name|struct
name|arg_data
modifier|*
name|args
parameter_list|,
name|struct
name|args_size
modifier|*
name|args_size
parameter_list|)
block|{
comment|/* See if we have or want to preallocate stack space.       If we would have to push a partially-in-regs parm      before other stack parms, preallocate stack space instead.       If the size of some parm is not a multiple of the required stack      alignment, we must preallocate.       If the total size of arguments that would otherwise create a copy in      a temporary (such as a CALL) is more than half the total argument list      size, preallocation is faster.       Another reason to preallocate is if we have a machine (like the m88k)      where stack alignment is required to be maintained between every      pair of insns, not just when the call is made.  However, we assume here      that such machines either do not have push insns (and hence preallocation      would occur anyway) or the problem is taken care of with      PUSH_ROUNDING.  */
if|if
condition|(
operator|!
name|must_preallocate
condition|)
block|{
name|int
name|partial_seen
init|=
literal|0
decl_stmt|;
name|int
name|copy_to_evaluate_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
operator|&&
operator|!
name|must_preallocate
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|>
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|partial_seen
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|partial_seen
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
condition|)
name|must_preallocate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|CALL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|TARGET_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|)
condition|)
name|copy_to_evaluate_size
operator|+=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copy_to_evaluate_size
operator|*
literal|2
operator|>=
name|args_size
operator|->
name|constant
operator|&&
name|args_size
operator|->
name|constant
operator|>
literal|0
condition|)
name|must_preallocate
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|must_preallocate
return|;
block|}
end_function

begin_comment
comment|/* If we preallocated stack space, compute the address of each argument    and store it into the ARGS array.     We need not ensure it is a valid memory address here; it will be    validized when it is used.     ARGBLOCK is an rtx for the address of the outgoing arguments.  */
end_comment

begin_function
specifier|static
name|void
name|compute_argument_addresses
parameter_list|(
name|struct
name|arg_data
modifier|*
name|args
parameter_list|,
name|rtx
name|argblock
parameter_list|,
name|int
name|num_actuals
parameter_list|)
block|{
if|if
condition|(
name|argblock
condition|)
block|{
name|rtx
name|arg_reg
init|=
name|argblock
decl_stmt|;
name|int
name|i
decl_stmt|,
name|arg_offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|argblock
argument_list|)
operator|==
name|PLUS
condition|)
name|arg_reg
operator|=
name|XEXP
argument_list|(
name|argblock
argument_list|,
literal|0
argument_list|)
operator|,
name|arg_offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|argblock
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|offset
init|=
name|ARGS_SIZE_RTX
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rtx
name|slot_offset
init|=
name|ARGS_SIZE_RTX
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|slot_offset
argument_list|)
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|,
name|boundary
decl_stmt|;
name|unsigned
name|int
name|units_on_stack
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|partial_mode
init|=
name|VOIDmode
decl_stmt|;
comment|/* Skip this parm if it will not be passed on the stack.  */
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|arg_reg
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|arg_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|arg_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|!=
literal|0
condition|)
block|{
comment|/* Only part of the parameter is being passed on the stack. 		 Generate a simple memory reference of the correct size.  */
name|units_on_stack
operator|=
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|constant
expr_stmt|;
name|partial_mode
operator|=
name|mode_for_size
argument_list|(
name|units_on_stack
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|stack
operator|=
name|gen_rtx_MEM
argument_list|(
name|partial_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack
argument_list|,
name|GEN_INT
argument_list|(
name|units_on_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
name|i
index|]
operator|.
name|stack
operator|=
name|gen_rtx_MEM
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack
argument_list|,
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|align
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|boundary
operator|=
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|boundary
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|where_pad
operator|!=
name|downward
condition|)
name|align
operator|=
name|boundary
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|align
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|*
name|BITS_PER_UNIT
operator||
name|boundary
expr_stmt|;
name|align
operator|=
name|align
operator|&
operator|-
name|align
expr_stmt|;
block|}
name|set_mem_align
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|slot_offset
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|arg_reg
argument_list|,
name|INTVAL
argument_list|(
name|slot_offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|arg_reg
argument_list|,
name|slot_offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|arg_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|!=
literal|0
condition|)
block|{
comment|/* Only part of the parameter is being passed on the stack. 		 Generate a simple memory reference of the correct size.  */
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
operator|=
name|gen_rtx_MEM
argument_list|(
name|partial_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
argument_list|,
name|GEN_INT
argument_list|(
name|units_on_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
operator|=
name|gen_rtx_MEM
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
argument_list|,
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|set_mem_align
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|boundary
argument_list|)
expr_stmt|;
comment|/* Function incoming arguments may overlap with sibling call 	     outgoing arguments and we cannot allow reordering of reads 	     from function arguments with stores to outgoing arguments 	     of sibling calls.  */
name|set_mem_alias_set
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a FNDECL and EXP, return an rtx suitable for use as a target address    in a call instruction.     FNDECL is the tree node for the target function.  For an indirect call    FNDECL will be NULL_TREE.     ADDR is the operand 0 of CALL_EXPR for this call.  */
end_comment

begin_function
specifier|static
name|rtx
name|rtx_for_function_call
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|addr
parameter_list|)
block|{
name|rtx
name|funexp
decl_stmt|;
comment|/* Get the function to call, in the form of RTL.  */
if|if
condition|(
name|fndecl
condition|)
block|{
comment|/* If this is the first use of the function, see if we need to 	 make an external definition for it.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Get a SYMBOL_REF rtx for the function address.  */
name|funexp
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Generate an rtx (probably a pseudo-register) for the address.  */
block|{
name|push_temp_slots
argument_list|()
expr_stmt|;
name|funexp
operator|=
name|expand_normal
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* FUNEXP can't be BLKmode.  */
block|}
return|return
name|funexp
return|;
block|}
end_function

begin_comment
comment|/* Return true if and only if SIZE storage units (usually bytes)    starting from address ADDR overlap with already clobbered argument    area.  This function is used to determine if we should give up a    sibcall.  */
end_comment

begin_function
specifier|static
name|bool
name|mem_overlaps_already_clobbered_arg_p
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|HOST_WIDE_INT
name|i
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|current_function_internal_arg_pointer
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|i
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return true for arg pointer based indexed addressing.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|||
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|i
operator|=
operator|-
name|i
operator|-
name|size
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|i
operator|+
name|k
operator|<
name|stored_args_map
operator|->
name|n_bits
operator|&&
name|TEST_BIT
argument_list|(
name|stored_args_map
argument_list|,
name|i
operator|+
name|k
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Do the register loads required for any wholly-register parms or any    parms which are passed both on the stack and in a register.  Their    expressions were already evaluated.     Mark all register-parms as living through the call, putting these USE    insns in the CALL_INSN_FUNCTION_USAGE field.     When IS_SIBCALL, perform the check_sibcall_argument_overlap    checking, setting *SIBCALL_FAILURE if appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|load_register_parameters
parameter_list|(
name|struct
name|arg_data
modifier|*
name|args
parameter_list|,
name|int
name|num_actuals
parameter_list|,
name|rtx
modifier|*
name|call_fusage
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|is_sibcall
parameter_list|,
name|int
modifier|*
name|sibcall_failure
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
operator|(
operator|(
name|flags
operator|&
name|ECF_SIBCALL
operator|)
condition|?
name|args
index|[
name|i
index|]
operator|.
name|tail_call_reg
else|:
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|)
decl_stmt|;
if|if
condition|(
name|reg
condition|)
block|{
name|int
name|partial
init|=
name|args
index|[
name|i
index|]
operator|.
name|partial
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|rtx
name|before_arg
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* Set non-negative if we must move a word at a time, even if 	     just one word (e.g, partial == 4&& mode == DFmode).  Set 	     to -1 if we just use a normal move insn.  This value can be 	     zero if the argument is a zero size structure.  */
name|nregs
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|partial
condition|)
block|{
name|gcc_assert
argument_list|(
name|partial
operator|%
name|UNITS_PER_WORD
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nregs
operator|=
name|partial
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
expr_stmt|;
name|nregs
operator|=
operator|(
name|size
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
comment|/* Handle calls that pass values in multiple non-contiguous 	     locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_move
argument_list|(
name|reg
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|parallel_value
argument_list|)
expr_stmt|;
comment|/* If simple case, just do move.  If normal partial, store_one_arg 	     has already loaded the register for us.  In all other cases, 	     load the register(s) from memory.  */
elseif|else
if|if
condition|(
name|nregs
operator|==
operator|-
literal|1
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
comment|/* Handle case where we have a value that needs shifting 		 up to the msb.  eg. a QImode value and we're padding 		 upward on a BYTES_BIG_ENDIAN machine.  */
if|if
condition|(
name|size
operator|<
name|UNITS_PER_WORD
operator|&&
operator|(
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|where_pad
operator|==
operator|(
name|BYTES_BIG_ENDIAN
condition|?
name|upward
else|:
name|downward
operator|)
operator|)
condition|)
block|{
name|rtx
name|x
decl_stmt|;
name|int
name|shift
init|=
operator|(
name|UNITS_PER_WORD
operator|-
name|size
operator|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
comment|/* Assigning REG here rather than a temp makes CALL_FUSAGE 		     report the whole reg as used.  Strictly speaking, the 		     call only uses SIZE bytes at the msb end, but it doesn't 		     seem worth generating rtl to say that.  */
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|shift
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|reg
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* If we have pre-computed the values to put in the registers in 	     the case of non-aligned structures, copy them in now.  */
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
operator|!=
literal|0
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
condition|;
name|j
operator|++
control|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|j
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|partial
operator|==
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
block|{
name|rtx
name|mem
init|=
name|validize_mem
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
decl_stmt|;
comment|/* Check for overlap with already clobbered argument area.  */
if|if
condition|(
name|is_sibcall
operator|&&
name|mem_overlaps_already_clobbered_arg_p
argument_list|(
name|XEXP
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
condition|)
operator|*
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
comment|/* Handle a BLKmode that needs shifting.  */
if|if
condition|(
name|nregs
operator|==
literal|1
operator|&&
name|size
operator|<
name|UNITS_PER_WORD
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|where_pad
operator|==
name|downward
else|#
directive|else
operator|&&
name|BYTES_BIG_ENDIAN
endif|#
directive|endif
condition|)
block|{
name|rtx
name|tem
init|=
name|operand_subword_force
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|ri
init|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|x
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|int
name|shift
init|=
operator|(
name|UNITS_PER_WORD
operator|-
name|size
operator|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|tree_code
name|dir
init|=
name|BYTES_BIG_ENDIAN
condition|?
name|RSHIFT_EXPR
else|:
name|LSHIFT_EXPR
decl_stmt|;
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|x
operator|=
name|expand_shift
argument_list|(
name|dir
argument_list|,
name|word_mode
argument_list|,
name|x
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|shift
argument_list|)
argument_list|,
name|ri
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|ri
condition|)
name|emit_move_insn
argument_list|(
name|ri
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|move_block_to_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|mem
argument_list|,
name|nregs
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* When a parameter is a block, and perhaps in other cases, it is 	     possible that it did a load from an argument slot that was 	     already clobbered.  */
if|if
condition|(
name|is_sibcall
operator|&&
name|check_sibcall_argument_overlap
argument_list|(
name|before_arg
argument_list|,
operator|&
name|args
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
condition|)
operator|*
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
comment|/* Handle calls that pass values in multiple non-contiguous 	     locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|use_group_regs
argument_list|(
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nregs
operator|==
operator|-
literal|1
condition|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nregs
operator|>
literal|0
condition|)
name|use_regs
argument_list|(
name|call_fusage
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* We need to pop PENDING_STACK_ADJUST bytes.  But, if the arguments    wouldn't fill up an even multiple of PREFERRED_UNIT_STACK_BOUNDARY    bytes, then we would need to push some additional bytes to pad the    arguments.  So, we compute an adjust to the stack pointer for an    amount that will leave the stack under-aligned by UNADJUSTED_ARGS_SIZE    bytes.  Then, when the arguments are pushed the stack will be perfectly    aligned.  ARGS_SIZE->CONSTANT is set to the number of bytes that should    be popped after the call.  Returns the adjustment.  */
end_comment

begin_function
specifier|static
name|int
name|combine_pending_stack_adjustment_and_call
parameter_list|(
name|int
name|unadjusted_args_size
parameter_list|,
name|struct
name|args_size
modifier|*
name|args_size
parameter_list|,
name|unsigned
name|int
name|preferred_unit_stack_boundary
parameter_list|)
block|{
comment|/* The number of bytes to pop so that the stack will be      under-aligned by UNADJUSTED_ARGS_SIZE bytes.  */
name|HOST_WIDE_INT
name|adjustment
decl_stmt|;
comment|/* The alignment of the stack after the arguments are pushed, if we      just pushed the arguments without adjust the stack here.  */
name|unsigned
name|HOST_WIDE_INT
name|unadjusted_alignment
decl_stmt|;
name|unadjusted_alignment
operator|=
operator|(
operator|(
name|stack_pointer_delta
operator|+
name|unadjusted_args_size
operator|)
operator|%
name|preferred_unit_stack_boundary
operator|)
expr_stmt|;
comment|/* We want to get rid of as many of the PENDING_STACK_ADJUST bytes      as possible -- leaving just enough left to cancel out the      UNADJUSTED_ALIGNMENT.  In other words, we want to ensure that the      PENDING_STACK_ADJUST is non-negative, and congruent to      -UNADJUSTED_ALIGNMENT modulo the PREFERRED_UNIT_STACK_BOUNDARY.  */
comment|/* Begin by trying to pop all the bytes.  */
name|unadjusted_alignment
operator|=
operator|(
name|unadjusted_alignment
operator|-
operator|(
name|pending_stack_adjust
operator|%
name|preferred_unit_stack_boundary
operator|)
operator|)
expr_stmt|;
name|adjustment
operator|=
name|pending_stack_adjust
expr_stmt|;
comment|/* Push enough additional bytes that the stack will be aligned      after the arguments are pushed.  */
if|if
condition|(
name|preferred_unit_stack_boundary
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|unadjusted_alignment
operator|>
literal|0
condition|)
name|adjustment
operator|-=
name|preferred_unit_stack_boundary
operator|-
name|unadjusted_alignment
expr_stmt|;
else|else
name|adjustment
operator|+=
name|unadjusted_alignment
expr_stmt|;
block|}
comment|/* Now, sets ARGS_SIZE->CONSTANT so that we pop the right number of      bytes after the call.  The right number is the entire      PENDING_STACK_ADJUST less our ADJUSTMENT plus the amount required      by the arguments in the first place.  */
name|args_size
operator|->
name|constant
operator|=
name|pending_stack_adjust
operator|-
name|adjustment
operator|+
name|unadjusted_args_size
expr_stmt|;
return|return
name|adjustment
return|;
block|}
end_function

begin_comment
comment|/* Scan X expression if it does not dereference any argument slots    we already clobbered by tail call arguments (as noted in stored_args_map    bitmap).    Return nonzero if X expression dereferences such argument slots,    zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|check_sibcall_argument_overlap_1
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|mem_overlaps_already_clobbered_arg_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Scan all subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|check_sibcall_argument_overlap_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|check_sibcall_argument_overlap_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Scan sequence after INSN if it does not dereference any argument slots    we already clobbered by tail call arguments (as noted in stored_args_map    bitmap).  If MARK_STORED_ARGS_MAP, add stack slots for ARG to    stored_args_map bitmap afterwards (when ARG is a register MARK_STORED_ARGS_MAP    should be 0).  Return nonzero if sequence after INSN dereferences such argument    slots, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|check_sibcall_argument_overlap
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|struct
name|arg_data
modifier|*
name|arg
parameter_list|,
name|int
name|mark_stored_args_map
parameter_list|)
block|{
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
condition|)
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|check_sibcall_argument_overlap_1
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|mark_stored_args_map
condition|)
block|{
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|low
operator|=
operator|-
name|arg
operator|->
name|locate
operator|.
name|slot_offset
operator|.
name|constant
operator|-
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|constant
expr_stmt|;
else|#
directive|else
name|low
operator|=
name|arg
operator|->
name|locate
operator|.
name|slot_offset
operator|.
name|constant
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|high
operator|=
name|low
operator|+
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|constant
init|;
name|low
operator|<
name|high
condition|;
name|low
operator|++
control|)
name|SET_BIT
argument_list|(
name|stored_args_map
argument_list|,
name|low
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
operator|!=
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Given that a function returns a value of mode MODE at the most    significant end of hard register VALUE, shift VALUE left or right    as specified by LEFT_P.  Return true if some action was needed.  */
end_comment

begin_function
name|bool
name|shift_return_value
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|bool
name|left_p
parameter_list|,
name|rtx
name|value
parameter_list|)
block|{
name|HOST_WIDE_INT
name|shift
decl_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|value
argument_list|)
operator|&&
name|HARD_REGISTER_P
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|shift
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* Use ashr rather than lshr for right shifts.  This is for the benefit      of the MIPS port, which requires SImode values to be sign-extended      when stored in 64-bit registers.  */
if|if
condition|(
operator|!
name|force_expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|left_p
condition|?
name|ashl_optab
else|:
name|ashr_optab
argument_list|,
name|value
argument_list|,
name|GEN_INT
argument_list|(
name|shift
argument_list|)
argument_list|,
name|value
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate all the code for a function call    and return an rtx for its value.    Store the value in TARGET (specified as an rtx) if convenient.    If the value is stored in TARGET then TARGET is returned.    If IGNORE is nonzero, then we ignore the value of the function call.  */
end_comment

begin_function
name|rtx
name|expand_call
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|ignore
parameter_list|)
block|{
comment|/* Nonzero if we are currently expanding a call.  */
specifier|static
name|int
name|currently_expanding_call
init|=
literal|0
decl_stmt|;
comment|/* List of actual parameters.  */
name|tree
name|actparms
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* RTX for the function to be called.  */
name|rtx
name|funexp
decl_stmt|;
comment|/* Sequence of insns to perform a normal "call".  */
name|rtx
name|normal_call_insns
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Sequence of insns to perform a tail "call".  */
name|rtx
name|tail_call_insns
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Data type of the function.  */
name|tree
name|funtype
decl_stmt|;
name|tree
name|type_arg_types
decl_stmt|;
comment|/* Declaration of the function being called,      or 0 if the function is computed (not known by name).  */
name|tree
name|fndecl
init|=
literal|0
decl_stmt|;
comment|/* The type of the function being called.  */
name|tree
name|fntype
decl_stmt|;
name|bool
name|try_tail_call
init|=
name|CALL_EXPR_TAILCALL
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|pass
decl_stmt|;
comment|/* Register in which non-BLKmode value will be returned,      or 0 if no value or if value is BLKmode.  */
name|rtx
name|valreg
decl_stmt|;
comment|/* Address where we should return a BLKmode value;      0 if value not BLKmode.  */
name|rtx
name|structure_value_addr
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if that address is being passed by treating it as      an extra, implicit first parameter.  Otherwise,      it is passed by being copied directly into struct_value_rtx.  */
name|int
name|structure_value_addr_parm
init|=
literal|0
decl_stmt|;
comment|/* Size of aggregate value wanted, or zero if none wanted      or if we are using the non-reentrant PCC calling convention      or expecting the value in registers.  */
name|HOST_WIDE_INT
name|struct_value_size
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if called function returns an aggregate in memory PCC style,      by returning the address of where to find it.  */
name|int
name|pcc_struct_value
init|=
literal|0
decl_stmt|;
name|rtx
name|struct_value
init|=
literal|0
decl_stmt|;
comment|/* Number of actual parameters in this call, including struct value addr.  */
name|int
name|num_actuals
decl_stmt|;
comment|/* Number of named args.  Args after this are anonymous ones      and they must all go on the stack.  */
name|int
name|n_named_args
decl_stmt|;
comment|/* Vector of information about each argument.      Arguments are numbered in the order they will be pushed,      not the order they are written.  */
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
comment|/* Total size in bytes of all the stack-parms scanned so far.  */
name|struct
name|args_size
name|args_size
decl_stmt|;
name|struct
name|args_size
name|adjusted_args_size
decl_stmt|;
comment|/* Size of arguments before any adjustments (such as rounding).  */
name|int
name|unadjusted_args_size
decl_stmt|;
comment|/* Data on reg parms scanned so far.  */
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
comment|/* Nonzero if a reg parm has been scanned.  */
name|int
name|reg_parm_seen
decl_stmt|;
comment|/* Nonzero if this is an indirect function call.  */
comment|/* Nonzero if we must avoid push-insns in the args for this call.      If stack space is allocated for register parameters, but not by the      caller, then it is preallocated in the fixed part of the stack frame.      So the entire argument block must then be preallocated (i.e., we      ignore PUSH_ROUNDING in that case).  */
name|int
name|must_preallocate
init|=
operator|!
name|PUSH_ARGS
decl_stmt|;
comment|/* Size of the stack reserved for parameter registers.  */
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
comment|/* Address of space preallocated for stack parms      (on machines that lack push insns), or 0 if space not preallocated.  */
name|rtx
name|argblock
init|=
literal|0
decl_stmt|;
comment|/* Mask of ECF_ flags.  */
name|int
name|flags
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
comment|/* Define the boundary of the register parm stack space that needs to be      saved, if any.  */
name|int
name|low_to_save
decl_stmt|,
name|high_to_save
decl_stmt|;
name|rtx
name|save_area
init|=
literal|0
decl_stmt|;
comment|/* Place that it is saved */
endif|#
directive|endif
name|int
name|initial_highest_arg_in_use
init|=
name|highest_outgoing_arg_in_use
decl_stmt|;
name|char
modifier|*
name|initial_stack_usage_map
init|=
name|stack_usage_map
decl_stmt|;
name|char
modifier|*
name|stack_usage_map_buf
init|=
name|NULL
decl_stmt|;
name|int
name|old_stack_allocated
decl_stmt|;
comment|/* State variables to track stack modifications.  */
name|rtx
name|old_stack_level
init|=
literal|0
decl_stmt|;
name|int
name|old_stack_arg_under_construction
init|=
literal|0
decl_stmt|;
name|int
name|old_pending_adj
init|=
literal|0
decl_stmt|;
name|int
name|old_inhibit_defer_pop
init|=
name|inhibit_defer_pop
decl_stmt|;
comment|/* Some stack pointer alterations we make are performed via      allocate_dynamic_stack_space. This modifies the stack_pointer_delta,      which we then also need to save/restore along the way.  */
name|int
name|old_stack_pointer_delta
init|=
literal|0
decl_stmt|;
name|rtx
name|call_fusage
decl_stmt|;
name|tree
name|p
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|addr
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The alignment of the stack, in bits.  */
name|unsigned
name|HOST_WIDE_INT
name|preferred_stack_boundary
decl_stmt|;
comment|/* The alignment of the stack, in bytes.  */
name|unsigned
name|HOST_WIDE_INT
name|preferred_unit_stack_boundary
decl_stmt|;
comment|/* The static chain value to use for this call.  */
name|rtx
name|static_chain_value
decl_stmt|;
comment|/* See if this is "nothrow" function call.  */
if|if
condition|(
name|TREE_NOTHROW
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_NOTHROW
expr_stmt|;
comment|/* See if we can find a DECL-node for the actual function, and get the      function attributes (flags) from the function decl or type node.  */
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|flags
operator||=
name|flags_from_decl_or_type
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
name|flags_from_decl_or_type
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
block|}
name|struct_value
operator|=
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|fntype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Warn if this value is an aggregate type,      regardless of which calling convention we are using for it.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Waggregate_return
argument_list|,
literal|"function call has aggregate value"
argument_list|)
expr_stmt|;
comment|/* If the result of a pure or const function call is ignored (or void),      and none of its arguments are volatile, we can avoid expanding the      call and just evaluate the arguments for side-effects.  */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
operator|)
operator|&&
operator|(
name|ignore
operator|||
name|target
operator|==
name|const0_rtx
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
block|{
name|bool
name|volatilep
init|=
name|false
decl_stmt|;
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|actparms
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|volatilep
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|volatilep
condition|)
block|{
for|for
control|(
name|arg
operator|=
name|actparms
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
if|if
condition|(
name|reg_parm_stack_space
operator|>
literal|0
operator|&&
name|PUSH_ARGS
condition|)
name|must_preallocate
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Set up a place to return a structure.  */
comment|/* Cater to broken compilers.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|exp
argument_list|,
name|fndecl
argument_list|)
condition|)
block|{
comment|/* This call returns a big structure.  */
name|flags
operator|&=
operator|~
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator||
name|ECF_LIBCALL_BLOCK
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
block|{
name|pcc_struct_value
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
comment|/* not PCC_STATIC_STRUCT_RETURN */
block|{
name|struct_value_size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|&&
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|&&
name|CALL_EXPR_RETURN_SLOT_OPT
argument_list|(
name|exp
argument_list|)
condition|)
name|structure_value_addr
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* For variable-sized objects, we must be called with a target 	       specified.  If we were to allocate space on the stack here, 	       we would have no way of knowing when to free it.  */
name|rtx
name|d
init|=
name|assign_temp
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|mark_temp_addr_taken
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|structure_value_addr
operator|=
name|XEXP
argument_list|(
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not PCC_STATIC_STRUCT_RETURN */
block|}
comment|/* Figure out the amount to which the stack should be aligned.  */
name|preferred_stack_boundary
operator|=
name|PREFERRED_STACK_BOUNDARY
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
name|struct
name|cgraph_rtl_info
modifier|*
name|i
init|=
name|cgraph_rtl_info
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|&&
name|i
operator|->
name|preferred_incoming_stack_boundary
condition|)
name|preferred_stack_boundary
operator|=
name|i
operator|->
name|preferred_incoming_stack_boundary
expr_stmt|;
block|}
comment|/* Operand 0 is a pointer-to-function; get the type of the function.  */
name|funtype
operator|=
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|POINTER_TYPE_P
argument_list|(
name|funtype
argument_list|)
argument_list|)
expr_stmt|;
name|funtype
operator|=
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
expr_stmt|;
comment|/* Munge the tree to split complex arguments into their imaginary      and real parts.  */
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
condition|)
block|{
name|type_arg_types
operator|=
name|split_complex_types
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
argument_list|)
expr_stmt|;
name|actparms
operator|=
name|split_complex_values
argument_list|(
name|actparms
argument_list|)
expr_stmt|;
block|}
else|else
name|type_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ECF_MAY_BE_ALLOCA
condition|)
name|current_function_calls_alloca
operator|=
literal|1
expr_stmt|;
comment|/* If struct_value_rtx is 0, it means pass the address      as if it were an extra parameter.  */
if|if
condition|(
name|structure_value_addr
operator|&&
name|struct_value
operator|==
literal|0
condition|)
block|{
comment|/* If structure_value_addr is a REG other than 	 virtual_outgoing_args_rtx, we can use always use it.  If it 	 is not a REG, we must always copy it into a register. 	 If it is virtual_outgoing_args_rtx, we must copy it to another 	 register in some cases.  */
name|rtx
name|temp
init|=
operator|(
operator|!
name|REG_P
argument_list|(
name|structure_value_addr
argument_list|)
operator|||
operator|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|stack_arg_under_construction
operator|&&
name|structure_value_addr
operator|==
name|virtual_outgoing_args_rtx
operator|)
condition|?
name|copy_addr_to_reg
argument_list|(
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|structure_value_addr
argument_list|)
argument_list|)
else|:
name|structure_value_addr
operator|)
decl_stmt|;
name|actparms
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|make_tree
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|)
argument_list|,
name|actparms
argument_list|)
expr_stmt|;
name|structure_value_addr_parm
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Count the arguments and set NUM_ACTUALS.  */
for|for
control|(
name|p
operator|=
name|actparms
operator|,
name|num_actuals
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|num_actuals
operator|++
expr_stmt|;
comment|/* Compute number of named args.      First, do a raw count of the args for INIT_CUMULATIVE_ARGS.  */
if|if
condition|(
name|type_arg_types
operator|!=
literal|0
condition|)
name|n_named_args
operator|=
operator|(
name|list_length
argument_list|(
name|type_arg_types
argument_list|)
comment|/* Count the struct value address, if it is passed as a parm.  */
operator|+
name|structure_value_addr_parm
operator|)
expr_stmt|;
else|else
comment|/* If we know nothing, treat all args as named.  */
name|n_named_args
operator|=
name|num_actuals
expr_stmt|;
comment|/* Start updating where the next arg would go.       On some machines (such as the PA) indirect calls have a different      calling convention than normal calls.  The fourth argument in      INIT_CUMULATIVE_ARGS tells the backend if this is an indirect call      or not.  */
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|funtype
argument_list|,
name|NULL_RTX
argument_list|,
name|fndecl
argument_list|,
name|n_named_args
argument_list|)
expr_stmt|;
comment|/* Now possibly adjust the number of named args.      Normally, don't include the last named arg if anonymous args follow.      We do include the last named arg if      targetm.calls.strict_argument_naming() returns nonzero.      (If no anonymous args follow, the result of list_length is actually      one too large.  This is harmless.)       If targetm.calls.pretend_outgoing_varargs_named() returns      nonzero, and targetm.calls.strict_argument_naming() returns zero,      this machine will be able to place unnamed args that were passed      in registers into the stack.  So treat all args as named.  This      allows the insns emitting for a specific argument list to be      independent of the function declaration.       If targetm.calls.pretend_outgoing_varargs_named() returns zero,      we do not have any reliable way to pass unnamed args in      registers, so we must force them into memory.  */
if|if
condition|(
name|type_arg_types
operator|!=
literal|0
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|strict_argument_naming
argument_list|(
operator|&
name|args_so_far
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|type_arg_types
operator|!=
literal|0
operator|&&
operator|!
name|targetm
operator|.
name|calls
operator|.
name|pretend_outgoing_varargs_named
argument_list|(
operator|&
name|args_so_far
argument_list|)
condition|)
comment|/* Don't include the last named arg.  */
operator|--
name|n_named_args
expr_stmt|;
else|else
comment|/* Treat all args as named.  */
name|n_named_args
operator|=
name|num_actuals
expr_stmt|;
comment|/* Make a vector to hold all the information about each arg.  */
name|args
operator|=
name|alloca
argument_list|(
name|num_actuals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg_data
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
name|num_actuals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build up entries in the ARGS array, compute the size of the      arguments into ARGS_SIZE, etc.  */
name|initialize_argument_information
argument_list|(
name|num_actuals
argument_list|,
name|args
argument_list|,
operator|&
name|args_size
argument_list|,
name|n_named_args
argument_list|,
name|actparms
argument_list|,
name|fndecl
argument_list|,
operator|&
name|args_so_far
argument_list|,
name|reg_parm_stack_space
argument_list|,
operator|&
name|old_stack_level
argument_list|,
operator|&
name|old_pending_adj
argument_list|,
operator|&
name|must_preallocate
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|try_tail_call
argument_list|,
name|CALL_FROM_THUNK_P
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args_size
operator|.
name|var
condition|)
block|{
comment|/* If this function requires a variable-sized argument list, don't 	 try to make a cse'able block for this call.  We may be able to 	 do this eventually, but it is too complicated to keep track of 	 what insns go in the cse'able block and which don't.  */
name|flags
operator|&=
operator|~
name|ECF_LIBCALL_BLOCK
expr_stmt|;
name|must_preallocate
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now make final decision about preallocating stack space.  */
name|must_preallocate
operator|=
name|finalize_must_preallocate
argument_list|(
name|must_preallocate
argument_list|,
name|num_actuals
argument_list|,
name|args
argument_list|,
operator|&
name|args_size
argument_list|)
expr_stmt|;
comment|/* If the structure value address will reference the stack pointer, we      must stabilize it.  We don't need to do this if we know that we are      not going to adjust the stack pointer in processing this call.  */
if|if
condition|(
name|structure_value_addr
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|structure_value_addr
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|structure_value_addr
argument_list|)
operator|)
operator|&&
operator|(
name|args_size
operator|.
name|var
operator|||
operator|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|args_size
operator|.
name|constant
operator|)
operator|)
condition|)
name|structure_value_addr
operator|=
name|copy_to_reg
argument_list|(
name|structure_value_addr
argument_list|)
expr_stmt|;
comment|/* Tail calls can make things harder to debug, and we've traditionally      pushed these optimizations into -O2.  Don't try if we're already      expanding a call, as that means we're an argument.  Don't try if      there's cleanups, as we know there's code to follow the call.  */
if|if
condition|(
name|currently_expanding_call
operator|++
operator|!=
literal|0
operator|||
operator|!
name|flag_optimize_sibling_calls
operator|||
name|args_size
operator|.
name|var
operator|||
name|lookup_stmt_eh_region
argument_list|(
name|exp
argument_list|)
operator|>=
literal|0
condition|)
name|try_tail_call
operator|=
literal|0
expr_stmt|;
comment|/*  Rest of purposes for tail call optimizations to fail.  */
if|if
condition|(
ifdef|#
directive|ifdef
name|HAVE_sibcall_epilogue
operator|!
name|HAVE_sibcall_epilogue
else|#
directive|else
literal|1
endif|#
directive|endif
operator|||
operator|!
name|try_tail_call
comment|/* Doing sibling call optimization needs some work, since 	 structure_value_addr can be allocated on the stack. 	 It does not seem worth the effort since few optimizable 	 sibling calls will return a structure.  */
operator|||
name|structure_value_addr
operator|!=
name|NULL_RTX
comment|/* Check whether the target is able to optimize the call 	 into a sibcall.  */
operator|||
operator|!
name|targetm
operator|.
name|function_ok_for_sibcall
argument_list|(
name|fndecl
argument_list|,
name|exp
argument_list|)
comment|/* Functions that do not return exactly once may not be sibcall 	 optimized.  */
operator|||
operator|(
name|flags
operator|&
operator|(
name|ECF_RETURNS_TWICE
operator||
name|ECF_NORETURN
operator|)
operator|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
comment|/* If the called function is nested in the current one, it might access 	 some of the caller's arguments, but could clobber them beforehand if 	 the argument areas are shared.  */
operator|||
operator|(
name|fndecl
operator|&&
name|decl_function_context
argument_list|(
name|fndecl
argument_list|)
operator|==
name|current_function_decl
operator|)
comment|/* If this function requires more stack slots than the current 	 function, we cannot change it into a sibling call. 	 current_function_pretend_args_size is not part of the 	 stack allocated by our caller.  */
operator|||
name|args_size
operator|.
name|constant
operator|>
operator|(
name|current_function_args_size
operator|-
name|current_function_pretend_args_size
operator|)
comment|/* If the callee pops its own arguments, then it must pop exactly 	 the same number of arguments as the current function.  */
operator|||
operator|(
name|RETURN_POPS_ARGS
argument_list|(
name|fndecl
argument_list|,
name|funtype
argument_list|,
name|args_size
operator|.
name|constant
argument_list|)
operator|!=
name|RETURN_POPS_ARGS
argument_list|(
name|current_function_decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|current_function_args_size
argument_list|)
operator|)
operator|||
operator|!
name|lang_hooks
operator|.
name|decls
operator|.
name|ok_for_sibcall
argument_list|(
name|fndecl
argument_list|)
condition|)
name|try_tail_call
operator|=
literal|0
expr_stmt|;
comment|/* Ensure current function's preferred stack boundary is at least      what we need.  We don't have to increase alignment for recursive      functions.  */
if|if
condition|(
name|cfun
operator|->
name|preferred_stack_boundary
operator|<
name|preferred_stack_boundary
operator|&&
name|fndecl
operator|!=
name|current_function_decl
condition|)
name|cfun
operator|->
name|preferred_stack_boundary
operator|=
name|preferred_stack_boundary
expr_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|current_function_decl
condition|)
name|cfun
operator|->
name|recursive_call_emit
operator|=
name|true
expr_stmt|;
name|preferred_unit_stack_boundary
operator|=
name|preferred_stack_boundary
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* We want to make two insn chains; one for a sibling call, the other      for a normal call.  We will select one of the two chains after      initial RTL generation is complete.  */
for|for
control|(
name|pass
operator|=
name|try_tail_call
condition|?
literal|0
else|:
literal|1
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|int
name|sibcall_failure
init|=
literal|0
decl_stmt|;
comment|/* We want to emit any pending stack adjustments before the tail 	 recursion "call".  That way we know any adjustment after the tail 	 recursion call can be ignored if we indeed use the tail 	 call expansion.  */
name|int
name|save_pending_stack_adjust
init|=
literal|0
decl_stmt|;
name|int
name|save_stack_pointer_delta
init|=
literal|0
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|rtx
name|before_call
decl_stmt|,
name|next_arg_reg
decl_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* State variables we need to save and restore between 	     iterations.  */
name|save_pending_stack_adjust
operator|=
name|pending_stack_adjust
expr_stmt|;
name|save_stack_pointer_delta
operator|=
name|stack_pointer_delta
expr_stmt|;
block|}
if|if
condition|(
name|pass
condition|)
name|flags
operator|&=
operator|~
name|ECF_SIBCALL
expr_stmt|;
else|else
name|flags
operator||=
name|ECF_SIBCALL
expr_stmt|;
comment|/* Other state variables that we must reinitialize each time 	 through the loop (that are not initialized by the loop itself).  */
name|argblock
operator|=
literal|0
expr_stmt|;
name|call_fusage
operator|=
literal|0
expr_stmt|;
comment|/* Start a new sequence for the normal call case.  	 From this point on, if the sibling call fails, we want to set 	 sibcall_failure instead of continuing the loop.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Don't let pending stack adjusts add up to too much. 	 Also, do all pending adjustments now if there is any chance 	 this might be a call to alloca or if we are expanding a sibling 	 call sequence or if we are calling a function that is to return 	 with stack pointer depressed. 	 Also do the adjustments before a throwing call, otherwise 	 exception handling can fail; PR 19225. */
if|if
condition|(
name|pending_stack_adjust
operator|>=
literal|32
operator|||
operator|(
name|pending_stack_adjust
operator|>
literal|0
operator|&&
operator|(
name|flags
operator|&
operator|(
name|ECF_MAY_BE_ALLOCA
operator||
name|ECF_SP_DEPRESSED
operator|)
operator|)
operator|)
operator|||
operator|(
name|pending_stack_adjust
operator|>
literal|0
operator|&&
name|flag_exceptions
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ECF_NOTHROW
operator|)
operator|)
operator|||
name|pass
operator|==
literal|0
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* When calling a const function, we must pop the stack args right away, 	 so that the pop is deleted or moved with the call.  */
if|if
condition|(
name|pass
operator|&&
operator|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
operator|)
condition|)
name|NO_DEFER_POP
expr_stmt|;
comment|/* Precompute any arguments as needed.  */
if|if
condition|(
name|pass
condition|)
name|precompute_arguments
argument_list|(
name|flags
argument_list|,
name|num_actuals
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Now we are about to start emitting insns that can be deleted 	 if a libcall is deleted.  */
if|if
condition|(
name|pass
operator|&&
operator|(
name|flags
operator|&
operator|(
name|ECF_LIBCALL_BLOCK
operator||
name|ECF_MALLOC
operator|)
operator|)
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
operator|&&
name|cfun
operator|->
name|stack_protect_guard
condition|)
name|stack_protect_epilogue
argument_list|()
expr_stmt|;
name|adjusted_args_size
operator|=
name|args_size
expr_stmt|;
comment|/* Compute the actual size of the argument block required.  The variable 	 and constant sizes must be combined, the size may have to be rounded, 	 and there may be a minimum required size.  When generating a sibcall 	 pattern, do not round up, since we'll be re-using whatever space our 	 caller provided.  */
name|unadjusted_args_size
operator|=
name|compute_argument_block_size
argument_list|(
name|reg_parm_stack_space
argument_list|,
operator|&
name|adjusted_args_size
argument_list|,
operator|(
name|pass
operator|==
literal|0
condition|?
literal|0
else|:
name|preferred_stack_boundary
operator|)
argument_list|)
expr_stmt|;
name|old_stack_allocated
operator|=
name|stack_pointer_delta
operator|-
name|pending_stack_adjust
expr_stmt|;
comment|/* The argument block when performing a sibling call is the 	 incoming argument block.  */
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|argblock
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
name|argblock
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
operator|=
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
else|#
directive|else
operator|=
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stored_args_map
operator|=
name|sbitmap_alloc
argument_list|(
name|args_size
operator|.
name|constant
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|stored_args_map
argument_list|)
expr_stmt|;
block|}
comment|/* If we have no actual push instructions, or shouldn't use them, 	 make space for all args right now.  */
elseif|else
if|if
condition|(
name|adjusted_args_size
operator|.
name|var
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|old_stack_level
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|old_stack_pointer_delta
operator|=
name|stack_pointer_delta
expr_stmt|;
name|old_pending_adj
operator|=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
comment|/* stack_arg_under_construction says whether a stack arg is 		 being constructed at the old stack level.  Pushing the stack 		 gets a clean outgoing argument block.  */
name|old_stack_arg_under_construction
operator|=
name|stack_arg_under_construction
expr_stmt|;
name|stack_arg_under_construction
operator|=
literal|0
expr_stmt|;
block|}
name|argblock
operator|=
name|push_block
argument_list|(
name|ARGS_SIZE_RTX
argument_list|(
name|adjusted_args_size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Note that we must go through the motions of allocating an argument 	     block even if the size is zero because we may be storing args 	     in the area reserved for register arguments, which may be part of 	     the stack frame.  */
name|int
name|needed
init|=
name|adjusted_args_size
operator|.
name|constant
decl_stmt|;
comment|/* Store the maximum argument space used.  It will be pushed by 	     the prologue (if ACCUMULATE_OUTGOING_ARGS, or stack overflow 	     checking).  */
if|if
condition|(
name|needed
operator|>
name|current_function_outgoing_args_size
condition|)
name|current_function_outgoing_args_size
operator|=
name|needed
expr_stmt|;
if|if
condition|(
name|must_preallocate
condition|)
block|{
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* Since the stack pointer will never be pushed, it is 		     possible for the evaluation of a parm to clobber 		     something we have already written to the stack. 		     Since most function calls on RISC machines do not use 		     the stack, this is uncommon, but must work correctly.  		     Therefore, we save any area of the stack that was already 		     written and that we are using.  Here we set up to do this 		     by making a new stack usage map from the old one.  The 		     actual save will be done by store_one_arg.  		     Another approach might be to try to reorder the argument 		     evaluations to avoid this conflicting stack usage.  */
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
comment|/* Since we will be writing into the entire argument area, 		     the map must be allocated for its entire size, not just 		     the part that is the responsibility of the caller.  */
name|needed
operator|+=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stack_usage_map_buf
condition|)
name|free
argument_list|(
name|stack_usage_map_buf
argument_list|)
expr_stmt|;
name|stack_usage_map_buf
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
name|stack_usage_map
operator|=
name|stack_usage_map_buf
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
condition|)
name|memcpy
argument_list|(
name|stack_usage_map
argument_list|,
name|initial_stack_usage_map
argument_list|,
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
operator|!=
name|highest_outgoing_arg_in_use
condition|)
name|memset
argument_list|(
operator|&
name|stack_usage_map
index|[
name|initial_highest_arg_in_use
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|highest_outgoing_arg_in_use
operator|-
name|initial_highest_arg_in_use
operator|)
argument_list|)
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
comment|/* The address of the outgoing argument list must not be 		     copied to a register here, because argblock would be left 		     pointing to the wrong place after the call to 		     allocate_dynamic_stack_space below.  */
name|argblock
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inhibit_defer_pop
operator|==
literal|0
condition|)
block|{
comment|/* Try to reuse some or all of the pending_stack_adjust 			 to get this space.  */
name|needed
operator|=
operator|(
name|combine_pending_stack_adjustment_and_call
argument_list|(
name|unadjusted_args_size
argument_list|,
operator|&
name|adjusted_args_size
argument_list|,
name|preferred_unit_stack_boundary
argument_list|)
operator|)
expr_stmt|;
comment|/* combine_pending_stack_adjustment_and_call computes 			 an adjustment before the arguments are allocated. 			 Account for them and see whether or not the stack 			 needs to go up or down.  */
name|needed
operator|=
name|unadjusted_args_size
operator|-
name|needed
expr_stmt|;
if|if
condition|(
name|needed
operator|<
literal|0
condition|)
block|{
comment|/* We're releasing stack space.  */
comment|/* ??? We can avoid any adjustment at all if we're 			     already aligned.  FIXME.  */
name|pending_stack_adjust
operator|=
operator|-
name|needed
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* We need to allocate space.  We'll do that in 			   push_block below.  */
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Special case this because overhead of `push_block' in 		     this case is non-trivial.  */
if|if
condition|(
name|needed
operator|==
literal|0
condition|)
name|argblock
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
else|else
block|{
name|argblock
operator|=
name|push_block
argument_list|(
name|GEN_INT
argument_list|(
name|needed
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|argblock
operator|=
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* We only really need to call `copy_to_reg' in the case 		     where push insns are going to be used to pass ARGBLOCK 		     to a function call in ARGS.  In that case, the stack 		     pointer changes value from the allocation point to the 		     call point, and hence the value of 		     VIRTUAL_OUTGOING_ARGS_RTX changes as well.  But might 		     as well always do it.  */
name|argblock
operator|=
name|copy_to_reg
argument_list|(
name|argblock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* The save/restore code in store_one_arg handles all 	     cases except one: a constructor call (including a C 	     function returning a BLKmode struct) to initialize 	     an argument.  */
if|if
condition|(
name|stack_arg_under_construction
condition|)
block|{
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
name|rtx
name|push_size
init|=
name|GEN_INT
argument_list|(
name|reg_parm_stack_space
operator|+
name|adjusted_args_size
operator|.
name|constant
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|push_size
init|=
name|GEN_INT
argument_list|(
name|adjusted_args_size
operator|.
name|constant
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|old_stack_level
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|old_stack_pointer_delta
operator|=
name|stack_pointer_delta
expr_stmt|;
name|old_pending_adj
operator|=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
comment|/* stack_arg_under_construction says whether a stack 		     arg is being constructed at the old stack level. 		     Pushing the stack gets a clean outgoing argument 		     block.  */
name|old_stack_arg_under_construction
operator|=
name|stack_arg_under_construction
expr_stmt|;
name|stack_arg_under_construction
operator|=
literal|0
expr_stmt|;
comment|/* Make a new map for the new argument list.  */
if|if
condition|(
name|stack_usage_map_buf
condition|)
name|free
argument_list|(
name|stack_usage_map_buf
argument_list|)
expr_stmt|;
name|stack_usage_map_buf
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
name|stack_usage_map
operator|=
name|stack_usage_map_buf
expr_stmt|;
name|memset
argument_list|(
name|stack_usage_map
argument_list|,
literal|0
argument_list|,
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
name|highest_outgoing_arg_in_use
operator|=
literal|0
expr_stmt|;
block|}
name|allocate_dynamic_stack_space
argument_list|(
name|push_size
argument_list|,
name|NULL_RTX
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
comment|/* If argument evaluation might modify the stack pointer, 	     copy the address of the argument list to a register.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
block|{
name|argblock
operator|=
name|copy_addr_to_reg
argument_list|(
name|argblock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|compute_argument_addresses
argument_list|(
name|args
argument_list|,
name|argblock
argument_list|,
name|num_actuals
argument_list|)
expr_stmt|;
comment|/* If we push args individually in reverse order, perform stack alignment 	 before the first push (the last arg).  */
if|if
condition|(
name|PUSH_ARGS_REVERSED
operator|&&
name|argblock
operator|==
literal|0
operator|&&
name|adjusted_args_size
operator|.
name|constant
operator|!=
name|unadjusted_args_size
condition|)
block|{
comment|/* When the stack adjustment is pending, we get better code 	     by combining the adjustments.  */
if|if
condition|(
name|pending_stack_adjust
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
operator|)
operator|&&
operator|!
name|inhibit_defer_pop
condition|)
block|{
name|pending_stack_adjust
operator|=
operator|(
name|combine_pending_stack_adjustment_and_call
argument_list|(
name|unadjusted_args_size
argument_list|,
operator|&
name|adjusted_args_size
argument_list|,
name|preferred_unit_stack_boundary
argument_list|)
operator|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argblock
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|adjusted_args_size
operator|.
name|constant
operator|-
name|unadjusted_args_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now that the stack is properly aligned, pops can't safely 	 be deferred during the evaluation of the arguments.  */
name|NO_DEFER_POP
expr_stmt|;
name|funexp
operator|=
name|rtx_for_function_call
argument_list|(
name|fndecl
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Figure out the register where the value, if any, will come back.  */
name|valreg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|structure_value_addr
condition|)
block|{
if|if
condition|(
name|pcc_struct_value
condition|)
name|valreg
operator|=
name|hard_function_value
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|fndecl
argument_list|,
name|NULL
argument_list|,
operator|(
name|pass
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
else|else
name|valreg
operator|=
name|hard_function_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fndecl
argument_list|,
name|fntype
argument_list|,
operator|(
name|pass
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Precompute all register parameters.  It isn't safe to compute anything 	 once we have started filling any specific hard regs.  */
name|precompute_register_parameters
argument_list|(
name|num_actuals
argument_list|,
name|args
argument_list|,
operator|&
name|reg_parm_seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
condition|)
name|static_chain_value
operator|=
name|expand_normal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|static_chain_value
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
comment|/* Save the fixed argument area if it's part of the caller's frame and 	 is clobbered by argument setup for this call.  */
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|pass
condition|)
name|save_area
operator|=
name|save_fixed_argument_area
argument_list|(
name|reg_parm_stack_space
argument_list|,
name|argblock
argument_list|,
operator|&
name|low_to_save
argument_list|,
operator|&
name|high_to_save
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now store (and compute if necessary) all non-register parms. 	 These come before register parms, since they can require block-moves, 	 which could clobber the registers used for register parms. 	 Parms which have partial registers are not stored here, 	 but we do preallocate space here if they want that.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
block|{
name|rtx
name|before_arg
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
if|if
condition|(
name|store_one_arg
argument_list|(
operator|&
name|args
index|[
name|i
index|]
argument_list|,
name|argblock
argument_list|,
name|flags
argument_list|,
name|adjusted_args_size
operator|.
name|var
operator|!=
literal|0
argument_list|,
name|reg_parm_stack_space
argument_list|)
operator|||
operator|(
name|pass
operator|==
literal|0
operator|&&
name|check_sibcall_argument_overlap
argument_list|(
name|before_arg
argument_list|,
operator|&
name|args
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ECF_CONST
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|stack
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|value
operator|==
name|args
index|[
name|i
index|]
operator|.
name|stack
condition|)
name|call_fusage
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|call_fusage
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a parm that is passed in registers but not in memory 	 and whose alignment does not permit a direct copy into registers, 	 make a group of pseudos that correspond to each register that we 	 will later fill.  */
if|if
condition|(
name|STRICT_ALIGNMENT
condition|)
name|store_unaligned_arguments_into_pseudos
argument_list|(
name|args
argument_list|,
name|num_actuals
argument_list|)
expr_stmt|;
comment|/* Now store any partially-in-registers parm. 	 This is the last place a block-move can happen.  */
if|if
condition|(
name|reg_parm_seen
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|!=
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
block|{
name|rtx
name|before_arg
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
if|if
condition|(
name|store_one_arg
argument_list|(
operator|&
name|args
index|[
name|i
index|]
argument_list|,
name|argblock
argument_list|,
name|flags
argument_list|,
name|adjusted_args_size
operator|.
name|var
operator|!=
literal|0
argument_list|,
name|reg_parm_stack_space
argument_list|)
operator|||
operator|(
name|pass
operator|==
literal|0
operator|&&
name|check_sibcall_argument_overlap
argument_list|(
name|before_arg
argument_list|,
operator|&
name|args
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we pushed args in forward order, perform stack alignment 	 after pushing the last arg.  */
if|if
condition|(
operator|!
name|PUSH_ARGS_REVERSED
operator|&&
name|argblock
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|adjusted_args_size
operator|.
name|constant
operator|-
name|unadjusted_args_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If register arguments require space on the stack and stack space 	 was not preallocated, allocate stack space here for arguments 	 passed in registers.  */
ifdef|#
directive|ifdef
name|OUTGOING_REG_PARM_STACK_SPACE
if|if
condition|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|must_preallocate
operator|==
literal|0
operator|&&
name|reg_parm_stack_space
operator|>
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Pass the function the address in which to return a 	 structure value.  */
if|if
condition|(
name|pass
operator|!=
literal|0
operator|&&
name|structure_value_addr
operator|&&
operator|!
name|structure_value_addr_parm
condition|)
block|{
name|structure_value_addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|structure_value_addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|struct_value
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|structure_value_addr
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|struct_value
argument_list|)
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|struct_value
argument_list|)
expr_stmt|;
block|}
name|funexp
operator|=
name|prepare_call_address
argument_list|(
name|funexp
argument_list|,
name|static_chain_value
argument_list|,
operator|&
name|call_fusage
argument_list|,
name|reg_parm_seen
argument_list|,
name|pass
operator|==
literal|0
argument_list|)
expr_stmt|;
name|load_register_parameters
argument_list|(
name|args
argument_list|,
name|num_actuals
argument_list|,
operator|&
name|call_fusage
argument_list|,
name|flags
argument_list|,
name|pass
operator|==
literal|0
argument_list|,
operator|&
name|sibcall_failure
argument_list|)
expr_stmt|;
comment|/* Save a pointer to the last insn before the call, so that we can 	 later safely search backwards to find the CALL_INSN.  */
name|before_call
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Set up next argument register.  For sibling calls on machines 	 with register windows this should be the incoming register.  */
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
name|next_arg_reg
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|next_arg_reg
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* All arguments and registers used for the call must be set up by 	 now!  */
comment|/* Stack must be properly aligned now.  */
name|gcc_assert
argument_list|(
operator|!
name|pass
operator|||
operator|!
operator|(
name|stack_pointer_delta
operator|%
name|preferred_unit_stack_boundary
operator|)
argument_list|)
expr_stmt|;
comment|/* Generate the actual call instruction.  */
name|emit_call_1
argument_list|(
name|funexp
argument_list|,
name|exp
argument_list|,
name|fndecl
argument_list|,
name|funtype
argument_list|,
name|unadjusted_args_size
argument_list|,
name|adjusted_args_size
operator|.
name|constant
argument_list|,
name|struct_value_size
argument_list|,
name|next_arg_reg
argument_list|,
name|valreg
argument_list|,
name|old_inhibit_defer_pop
argument_list|,
name|call_fusage
argument_list|,
name|flags
argument_list|,
operator|&
name|args_so_far
argument_list|)
expr_stmt|;
comment|/* If a non-BLKmode value is returned at the most significant end 	 of a register, shift the register right by the appropriate amount 	 and update VALREG accordingly.  BLKmode values are handled by the 	 group load/store machinery below.  */
if|if
condition|(
operator|!
name|structure_value_addr
operator|&&
operator|!
name|pcc_struct_value
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|return_in_msb
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|shift_return_value
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
name|valreg
argument_list|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
name|valreg
operator|=
name|gen_rtx_REG
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|valreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If call is cse'able, make appropriate pair of reg-notes around it. 	 Test valreg so we don't crash; may safely ignore `const' 	 if return type is void.  Disable for PARALLEL return values, because 	 we have no way to move such values into a pseudo register.  */
if|if
condition|(
name|pass
operator|&&
operator|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
operator|)
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|bool
name|failed
init|=
name|valreg
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|valreg
argument_list|)
operator|==
name|PARALLEL
decl_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Expansion of block moves possibly introduced a loop that may 	     not appear inside libcall block.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
name|failed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|failed
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|note
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Mark the return value as a pointer if needed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|mark_reg_pointer
argument_list|(
name|temp
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|fndecl
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
operator|&&
operator|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_SQRT
operator|||
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_SQRTF
operator|||
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_SQRTL
operator|)
condition|)
name|note
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|SQRT
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|initial_value
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Construct an "equal form" for the value which 		     mentions all the arguments in order as well as 		     the function name.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|initial_value
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|funexp
argument_list|,
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ECF_PURE
condition|)
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|temp
argument_list|,
name|valreg
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|valreg
operator|=
name|temp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pass
operator|&&
operator|(
name|flags
operator|&
name|ECF_MALLOC
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|last
decl_stmt|,
name|insns
decl_stmt|;
comment|/* The return value from a malloc-like function is a pointer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|mark_reg_pointer
argument_list|(
name|temp
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
comment|/* The return value from a malloc-like function can not alias 	     anything else.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOALIAS
argument_list|,
name|temp
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out the sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|valreg
operator|=
name|temp
expr_stmt|;
block|}
comment|/* For calls to `setjmp', etc., inform flow.c it should complain 	 if nonvolatile values are live.  For functions that cannot return, 	 inform flow that control does not fall through.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|ECF_NORETURN
operator|)
operator|||
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* The barrier must be emitted 	     immediately after the CALL_INSN.  Some ports emit more 	     than just a CALL_INSN above, so we must search for it here.  */
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|CALL_P
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* There was no CALL_INSN?  */
name|gcc_assert
argument_list|(
name|last
operator|!=
name|before_call
argument_list|)
expr_stmt|;
block|}
name|emit_barrier_after
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* Stack adjustments after a noreturn call are dead code. 	     However when NO_DEFER_POP is in effect, we must preserve 	     stack_pointer_delta.  */
if|if
condition|(
name|inhibit_defer_pop
operator|==
literal|0
condition|)
block|{
name|stack_pointer_delta
operator|=
name|old_stack_allocated
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If value type not void, return an rtx for the value.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|VOIDmode
operator|||
name|ignore
condition|)
name|target
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|structure_value_addr
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|MEM_P
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|target
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|memory_address
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|structure_value_addr
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pcc_struct_value
condition|)
block|{
comment|/* This is the special C++ case where we need to 	     know what the true target was.  We take care to 	     never use this value more than once in one expression.  */
name|target
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Handle calls that return values in multiple non-contiguous locations. 	 The Irix 6 ABI has examples of this.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|valreg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
comment|/* This will only be assigned once, so it can be readonly.  */
name|tree
name|nt
init|=
name|build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
decl_stmt|;
name|target
operator|=
name|assign_temp
argument_list|(
name|nt
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|)
condition|)
name|emit_group_store
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can not support sibling calls for this case.  */
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
condition|)
block|{
name|bool
name|may_overlap
init|=
name|false
decl_stmt|;
comment|/* We have to copy a return value in a CLASS_LIKELY_SPILLED hard 	     reg to a plain register.  */
if|if
condition|(
name|REG_P
argument_list|(
name|valreg
argument_list|)
operator|&&
name|HARD_REGISTER_P
argument_list|(
name|valreg
argument_list|)
operator|&&
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|valreg
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
operator|!
name|HARD_REGISTER_P
argument_list|(
name|target
argument_list|)
operator|)
condition|)
name|valreg
operator|=
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
expr_stmt|;
comment|/* If TARGET is a MEM in the argument area, and we have 	     saved part of the argument area, then we can't store 	     directly into TARGET as it may get overwritten when we 	     restore the argument save area below.  Don't work too 	     hard though and simply force TARGET to a register if it 	     is a MEM; the optimizer is quite likely to sort it out.  */
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|pass
operator|&&
name|MEM_P
argument_list|(
name|target
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|save_area
condition|)
block|{
name|may_overlap
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|may_overlap
condition|)
name|target
operator|=
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* TARGET and VALREG cannot be equal at this point 		 because the latter would not have 		 REG_FUNCTION_VALUE_P true, while the former would if 		 it were referring to the same register.  		 If they refer to the same register, this move will be 		 a no-op, except when function inlining is being 		 done.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
comment|/* If we are setting a MEM, this code must be executed. 		 Since it is emitted after the call insn, sibcall 		 optimization cannot be performed in that case.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|target
argument_list|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|target
operator|=
name|copy_blkmode_from_reg
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can not support sibling calls for this case.  */
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|target
operator|=
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|promote_function_return
argument_list|(
name|funtype
argument_list|)
condition|)
block|{
comment|/* If we promoted this return value, make the proper SUBREG. 	     TARGET might be const0_rtx here, so be careful.  */
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|pmode
decl_stmt|;
name|pmode
operator|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we don't promote as expected, something is wrong.  */
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|pmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|WORDS_BIG_ENDIAN
operator|||
name|BYTES_BIG_ENDIAN
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|offset
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|offset
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|%=
name|UNITS_PER_WORD
expr_stmt|;
block|}
name|target
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|target
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_SET
argument_list|(
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If size of args is variable or this was a constructor call for a stack 	 argument, restore saved stack-pointer value.  */
if|if
condition|(
name|old_stack_level
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ECF_SP_DEPRESSED
operator|)
condition|)
block|{
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|stack_pointer_delta
operator|=
name|old_stack_pointer_delta
expr_stmt|;
name|pending_stack_adjust
operator|=
name|old_pending_adj
expr_stmt|;
name|old_stack_allocated
operator|=
name|stack_pointer_delta
operator|-
name|pending_stack_adjust
expr_stmt|;
name|stack_arg_under_construction
operator|=
name|old_stack_arg_under_construction
expr_stmt|;
name|highest_outgoing_arg_in_use
operator|=
name|initial_highest_arg_in_use
expr_stmt|;
name|stack_usage_map
operator|=
name|initial_stack_usage_map
expr_stmt|;
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|pass
condition|)
block|{
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
if|if
condition|(
name|save_area
condition|)
name|restore_fixed_argument_area
argument_list|(
name|save_area
argument_list|,
name|argblock
argument_list|,
name|high_to_save
argument_list|,
name|low_to_save
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we saved any argument areas, restore them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|save_area
condition|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|save_area
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|XEXP
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|save_mode
operator|!=
name|BLKmode
condition|)
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|save_area
argument_list|)
expr_stmt|;
else|else
name|emit_block_move
argument_list|(
name|stack_area
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|save_area
argument_list|,
name|GEN_INT
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|constant
argument_list|)
argument_list|,
name|BLOCK_OP_CALL_PARM
argument_list|)
expr_stmt|;
block|}
name|highest_outgoing_arg_in_use
operator|=
name|initial_highest_arg_in_use
expr_stmt|;
name|stack_usage_map
operator|=
name|initial_stack_usage_map
expr_stmt|;
block|}
comment|/* If this was alloca, record the new stack level for nonlocal gotos. 	 Check for the handler slots since we might not have a save area 	 for non-local gotos.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|ECF_MAY_BE_ALLOCA
operator|)
operator|&&
name|cfun
operator|->
name|nonlocal_goto_save_area
operator|!=
literal|0
condition|)
name|update_nonlocal_goto_save_area
argument_list|()
expr_stmt|;
comment|/* Free up storage we no longer need.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|tail_call_insns
operator|=
name|insns
expr_stmt|;
comment|/* Restore the pending stack adjustment now that we have 	     finished generating the sibling call sequence.  */
name|pending_stack_adjust
operator|=
name|save_pending_stack_adjust
expr_stmt|;
name|stack_pointer_delta
operator|=
name|save_stack_pointer_delta
expr_stmt|;
comment|/* Prepare arg structure for next iteration.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|stack
operator|=
literal|0
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|stored_args_map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normal_call_insns
operator|=
name|insns
expr_stmt|;
comment|/* Verify that we've deallocated all the stack we used.  */
name|gcc_assert
argument_list|(
operator|(
name|flags
operator|&
name|ECF_NORETURN
operator|)
operator|||
operator|(
name|old_stack_allocated
operator|==
name|stack_pointer_delta
operator|-
name|pending_stack_adjust
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* If something prevents making this a sibling call, 	 zero out the sequence.  */
if|if
condition|(
name|sibcall_failure
condition|)
name|tail_call_insns
operator|=
name|NULL_RTX
expr_stmt|;
else|else
break|break;
block|}
comment|/* If tail call production succeeded, we need to remove REG_EQUIV notes on      arguments too, as argument area is now clobbered by the call.  */
if|if
condition|(
name|tail_call_insns
condition|)
block|{
name|emit_insn
argument_list|(
name|tail_call_insns
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|tail_call_emit
operator|=
name|true
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|normal_call_insns
argument_list|)
expr_stmt|;
name|currently_expanding_call
operator|--
expr_stmt|;
comment|/* If this function returns with the stack pointer depressed, ensure      this block saves and restores the stack pointer, show it was      changed, and adjust for any outgoing arg space.  */
if|if
condition|(
name|flags
operator|&
name|ECF_SP_DEPRESSED
condition|)
block|{
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stack_usage_map_buf
condition|)
name|free
argument_list|(
name|stack_usage_map_buf
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* A sibling call sequence invalidates any REG_EQUIV notes made for    this function's incoming arguments.     At the start of RTL generation we know the only REG_EQUIV notes    in the rtl chain are those for incoming arguments, so we can look    for REG_EQUIV notes between the start of the function and the    NOTE_INSN_FUNCTION_BEG.     This is (slight) overkill.  We could keep track of the highest    argument we clobber and be more selective in removing notes, but it    does not seem to be worth the effort.  */
end_comment

begin_function
name|void
name|fixup_tail_calls
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* There are never REG_EQUIV notes for the incoming arguments 	 after the NOTE_INSN_FUNCTION_BEG note, so stop if we see it.  */
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
break|break;
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
comment|/* Remove the note and keep looking at the notes for 		 this insn.  */
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Traverse an argument list in VALUES and expand all complex    arguments into their components.  */
end_comment

begin_function
specifier|static
name|tree
name|split_complex_values
parameter_list|(
name|tree
name|values
parameter_list|)
block|{
name|tree
name|p
decl_stmt|;
comment|/* Before allocating memory, check for the common case of no complex.  */
for|for
control|(
name|p
operator|=
name|values
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
argument_list|(
name|type
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
return|return
name|values
return|;
name|found
label|:
name|values
operator|=
name|copy_list
argument_list|(
name|values
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|values
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|complex_value
init|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|tree
name|complex_type
decl_stmt|;
name|complex_type
operator|=
name|TREE_TYPE
argument_list|(
name|complex_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|complex_type
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|complex_type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
argument_list|(
name|complex_type
argument_list|)
condition|)
block|{
name|tree
name|subtype
decl_stmt|;
name|tree
name|real
decl_stmt|,
name|imag
decl_stmt|,
name|next
decl_stmt|;
name|subtype
operator|=
name|TREE_TYPE
argument_list|(
name|complex_type
argument_list|)
expr_stmt|;
name|complex_value
operator|=
name|save_expr
argument_list|(
name|complex_value
argument_list|)
expr_stmt|;
name|real
operator|=
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|subtype
argument_list|,
name|complex_value
argument_list|)
expr_stmt|;
name|imag
operator|=
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|subtype
argument_list|,
name|complex_value
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|=
name|real
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|imag
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|imag
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|imag
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|imag
argument_list|)
operator|=
name|next
expr_stmt|;
comment|/* Skip the newly created node.  */
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|values
return|;
block|}
end_function

begin_comment
comment|/* Traverse a list of TYPES and expand all complex types into their    components.  */
end_comment

begin_function
specifier|static
name|tree
name|split_complex_types
parameter_list|(
name|tree
name|types
parameter_list|)
block|{
name|tree
name|p
decl_stmt|;
comment|/* Before allocating memory, check for the common case of no complex.  */
for|for
control|(
name|p
operator|=
name|types
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
argument_list|(
name|type
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
return|return
name|types
return|;
name|found
label|:
name|types
operator|=
name|copy_list
argument_list|(
name|types
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|types
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|complex_type
init|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|complex_type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
argument_list|(
name|complex_type
argument_list|)
condition|)
block|{
name|tree
name|next
decl_stmt|,
name|imag
decl_stmt|;
comment|/* Rewrite complex type with component type.  */
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|complex_type
argument_list|)
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Add another component type for the imaginary part.  */
name|imag
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|imag
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|imag
argument_list|)
operator|=
name|next
expr_stmt|;
comment|/* Skip the newly created node.  */
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|types
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a library call to function FUN (a SYMBOL_REF rtx).    The RETVAL parameter specifies whether return value needs to be saved, other    parameters are documented in the emit_library_call function below.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_library_call_value_1
parameter_list|(
name|int
name|retval
parameter_list|,
name|rtx
name|orgfun
parameter_list|,
name|rtx
name|value
parameter_list|,
name|enum
name|libcall_type
name|fn_type
parameter_list|,
name|enum
name|machine_mode
name|outmode
parameter_list|,
name|int
name|nargs
parameter_list|,
name|va_list
name|p
parameter_list|)
block|{
comment|/* Total size in bytes of all the stack-parms scanned so far.  */
name|struct
name|args_size
name|args_size
decl_stmt|;
comment|/* Size of arguments before any adjustments (such as rounding).  */
name|struct
name|args_size
name|original_args_size
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|rtx
name|fun
decl_stmt|;
name|int
name|inc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
name|argblock
init|=
literal|0
decl_stmt|;
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
struct|struct
name|arg
block|{
name|rtx
name|value
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|partial
decl_stmt|;
name|struct
name|locate_and_pad_arg_data
name|locate
decl_stmt|;
name|rtx
name|save_area
decl_stmt|;
block|}
struct|;
name|struct
name|arg
modifier|*
name|argvec
decl_stmt|;
name|int
name|old_inhibit_defer_pop
init|=
name|inhibit_defer_pop
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
name|rtx
name|mem_value
init|=
literal|0
decl_stmt|;
name|rtx
name|valreg
decl_stmt|;
name|int
name|pcc_struct_value
init|=
literal|0
decl_stmt|;
name|int
name|struct_value_size
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
name|int
name|needed
decl_stmt|;
name|rtx
name|before_call
decl_stmt|;
name|tree
name|tfom
decl_stmt|;
comment|/* type_for_mode (outmode, 0) */
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
comment|/* Define the boundary of the register parm stack space that needs to be      save, if any.  */
name|int
name|low_to_save
decl_stmt|,
name|high_to_save
decl_stmt|;
name|rtx
name|save_area
init|=
literal|0
decl_stmt|;
comment|/* Place that it is saved.  */
endif|#
directive|endif
comment|/* Size of the stack reserved for parameter registers.  */
name|int
name|initial_highest_arg_in_use
init|=
name|highest_outgoing_arg_in_use
decl_stmt|;
name|char
modifier|*
name|initial_stack_usage_map
init|=
name|stack_usage_map
decl_stmt|;
name|char
modifier|*
name|stack_usage_map_buf
init|=
name|NULL
decl_stmt|;
name|rtx
name|struct_value
init|=
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* By default, library functions can not throw.  */
name|flags
operator|=
name|ECF_NOTHROW
expr_stmt|;
switch|switch
condition|(
name|fn_type
condition|)
block|{
case|case
name|LCT_NORMAL
case|:
break|break;
case|case
name|LCT_CONST
case|:
name|flags
operator||=
name|ECF_CONST
expr_stmt|;
break|break;
case|case
name|LCT_PURE
case|:
name|flags
operator||=
name|ECF_PURE
expr_stmt|;
break|break;
case|case
name|LCT_CONST_MAKE_BLOCK
case|:
name|flags
operator||=
name|ECF_CONST
operator||
name|ECF_LIBCALL_BLOCK
expr_stmt|;
break|break;
case|case
name|LCT_PURE_MAKE_BLOCK
case|:
name|flags
operator||=
name|ECF_PURE
operator||
name|ECF_LIBCALL_BLOCK
expr_stmt|;
break|break;
case|case
name|LCT_NORETURN
case|:
name|flags
operator||=
name|ECF_NORETURN
expr_stmt|;
break|break;
case|case
name|LCT_THROW
case|:
name|flags
operator|=
name|ECF_NORETURN
expr_stmt|;
break|break;
case|case
name|LCT_RETURNS_TWICE
case|:
name|flags
operator|=
name|ECF_RETURNS_TWICE
expr_stmt|;
break|break;
block|}
name|fun
operator|=
name|orgfun
expr_stmt|;
comment|/* Ensure current function's preferred stack boundary is at least      what we need.  */
if|if
condition|(
name|cfun
operator|->
name|preferred_stack_boundary
operator|<
name|PREFERRED_STACK_BOUNDARY
condition|)
name|cfun
operator|->
name|preferred_stack_boundary
operator|=
name|PREFERRED_STACK_BOUNDARY
expr_stmt|;
comment|/* If this kind of value comes back in memory,      decide where in memory it should come back.  */
if|if
condition|(
name|outmode
operator|!=
name|VOIDmode
condition|)
block|{
name|tfom
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|outmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|tfom
argument_list|,
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
name|rtx
name|pointer_reg
init|=
name|hard_function_value
argument_list|(
name|build_pointer_type
argument_list|(
name|tfom
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|mem_value
operator|=
name|gen_rtx_MEM
argument_list|(
name|outmode
argument_list|,
name|pointer_reg
argument_list|)
expr_stmt|;
name|pcc_struct_value
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|gen_reg_rtx
argument_list|(
name|outmode
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not PCC_STATIC_STRUCT_RETURN */
name|struct_value_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|MEM_P
argument_list|(
name|value
argument_list|)
condition|)
name|mem_value
operator|=
name|value
expr_stmt|;
else|else
name|mem_value
operator|=
name|assign_temp
argument_list|(
name|tfom
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This call returns a big structure.  */
name|flags
operator|&=
operator|~
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator||
name|ECF_LIBCALL_BLOCK
operator|)
expr_stmt|;
block|}
block|}
else|else
name|tfom
operator|=
name|void_type_node
expr_stmt|;
comment|/* ??? Unfinished: must pass the memory address as an argument.  */
comment|/* Copy all the libcall-arguments out of the varargs data      and into a vector ARGVEC.       Compute how to pass each argument.  We only support a very small subset      of the full argument passing conventions to limit complexity here since      library functions shouldn't have many args.  */
name|argvec
operator|=
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|argvec
argument_list|,
literal|0
argument_list|,
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_CUMULATIVE_LIBCALL_ARGS
name|INIT_CUMULATIVE_LIBCALL_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|outmode
argument_list|,
name|fun
argument_list|)
expr_stmt|;
else|#
directive|else
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|NULL_TREE
argument_list|,
name|fun
argument_list|,
literal|0
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|args_size
operator|.
name|var
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Now we are about to start emitting insns that can be deleted      if a libcall is deleted.  */
if|if
condition|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
comment|/* If there's a structure value address to be passed,      either pass it in the special place, or pass it as an extra argument.  */
if|if
condition|(
name|mem_value
operator|&&
name|struct_value
operator|==
literal|0
operator|&&
operator|!
name|pcc_struct_value
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|mem_value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|nargs
operator|++
expr_stmt|;
comment|/* Make sure it is a reasonable operand for a move or push insn.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|addr
argument_list|)
operator|&&
operator|!
name|MEM_P
argument_list|(
name|addr
argument_list|)
operator|&&
operator|!
operator|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|)
condition|)
name|addr
operator|=
name|force_operand
argument_list|(
name|addr
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|value
operator|=
name|addr
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|mode
operator|=
name|Pmode
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
literal|0
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|Pmode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|targetm
operator|.
name|calls
operator|.
name|arg_partial_bytes
argument_list|(
operator|&
name|args_so_far
argument_list|,
name|Pmode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|locate_and_pad_parm
argument_list|(
name|Pmode
argument_list|,
name|NULL_TREE
argument_list|,
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
literal|1
argument_list|,
else|#
directive|else
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
literal|0
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|args_size
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|locate
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|!=
literal|0
operator|||
name|reg_parm_stack_space
operator|>
literal|0
condition|)
name|args_size
operator|.
name|constant
operator|+=
name|argvec
index|[
name|count
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|constant
expr_stmt|;
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|Pmode
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
block|{
name|rtx
name|val
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|)
decl_stmt|;
comment|/* We cannot convert the arg value to the mode the library wants here; 	 must do it earlier where we know the signedness of the arg.  */
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|==
name|VOIDmode
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure it is a reasonable operand for a move or push insn.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|val
argument_list|)
operator|&&
operator|!
name|MEM_P
argument_list|(
name|val
argument_list|)
operator|&&
operator|!
operator|(
name|CONSTANT_P
argument_list|(
name|val
argument_list|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|val
argument_list|)
operator|)
condition|)
name|val
operator|=
name|force_operand
argument_list|(
name|val
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass_by_reference
argument_list|(
operator|&
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|rtx
name|slot
decl_stmt|;
name|int
name|must_copy
init|=
operator|!
name|reference_callee_copied
argument_list|(
operator|&
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* loop.c won't look at CALL_INSN_FUNCTION_USAGE of const/pure 	     functions, so we have to pretend this isn't such a function.  */
if|if
condition|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
condition|)
block|{
name|rtx
name|insns
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
name|flags
operator|&=
operator|~
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator||
name|ECF_LIBCALL_BLOCK
operator|)
expr_stmt|;
comment|/* If this was a CONST function, it is now PURE since 	     it now reads memory.  */
if|if
condition|(
name|flags
operator|&
name|ECF_CONST
condition|)
block|{
name|flags
operator|&=
operator|~
name|ECF_CONST
expr_stmt|;
name|flags
operator||=
name|ECF_PURE
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|must_copy
condition|)
name|slot
operator|=
name|val
expr_stmt|;
else|else
block|{
name|slot
operator|=
name|assign_temp
argument_list|(
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|slot
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|call_fusage
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|slot
argument_list|)
argument_list|,
name|call_fusage
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_copy
condition|)
name|call_fusage
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|slot
argument_list|)
argument_list|,
name|call_fusage
argument_list|)
expr_stmt|;
name|mode
operator|=
name|Pmode
expr_stmt|;
name|val
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
name|argvec
index|[
name|count
index|]
operator|.
name|value
operator|=
name|val
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
name|targetm
operator|.
name|calls
operator|.
name|arg_partial_bytes
argument_list|(
operator|&
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|locate_and_pad_parm
argument_list|(
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
literal|1
argument_list|,
else|#
directive|else
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
name|argvec
index|[
name|count
index|]
operator|.
name|partial
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|args_size
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|locate
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|argvec
index|[
name|count
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|!=
literal|0
operator|||
name|reg_parm_stack_space
operator|>
literal|0
condition|)
name|args_size
operator|.
name|constant
operator|+=
name|argvec
index|[
name|count
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|constant
expr_stmt|;
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If this machine requires an external definition for library      functions, write one out.  */
name|assemble_external_libcall
argument_list|(
name|fun
argument_list|)
expr_stmt|;
name|original_args_size
operator|=
name|args_size
expr_stmt|;
name|args_size
operator|.
name|constant
operator|=
operator|(
operator|(
operator|(
name|args_size
operator|.
name|constant
operator|+
name|stack_pointer_delta
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|*
name|STACK_BYTES
operator|)
operator|-
name|stack_pointer_delta
operator|)
expr_stmt|;
name|args_size
operator|.
name|constant
operator|=
name|MAX
argument_list|(
name|args_size
operator|.
name|constant
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
name|args_size
operator|.
name|constant
operator|-=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args_size
operator|.
name|constant
operator|>
name|current_function_outgoing_args_size
condition|)
name|current_function_outgoing_args_size
operator|=
name|args_size
operator|.
name|constant
expr_stmt|;
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* Since the stack pointer will never be pushed, it is possible for 	 the evaluation of a parm to clobber something we have already 	 written to the stack.  Since most function calls on RISC machines 	 do not use the stack, this is uncommon, but must work correctly.  	 Therefore, we save any area of the stack that was already written 	 and that we are using.  Here we set up to do this by making a new 	 stack usage map from the old one.  	 Another approach might be to try to reorder the argument 	 evaluations to avoid this conflicting stack usage.  */
name|needed
operator|=
name|args_size
operator|.
name|constant
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
comment|/* Since we will be writing into the entire argument area, the 	 map must be allocated for its entire size, not just the part that 	 is the responsibility of the caller.  */
name|needed
operator|+=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stack_usage_map_buf
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
name|stack_usage_map
operator|=
name|stack_usage_map_buf
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
condition|)
name|memcpy
argument_list|(
name|stack_usage_map
argument_list|,
name|initial_stack_usage_map
argument_list|,
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
operator|!=
name|highest_outgoing_arg_in_use
condition|)
name|memset
argument_list|(
operator|&
name|stack_usage_map
index|[
name|initial_highest_arg_in_use
index|]
argument_list|,
literal|0
argument_list|,
name|highest_outgoing_arg_in_use
operator|-
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
comment|/* We must be careful to use virtual regs before they're instantiated, 	 and real regs afterwards.  Loop optimization, for example, can create 	 new libcalls after we've instantiated the virtual regs, and if we 	 use virtuals anyway, they won't match the rtl patterns.  */
if|if
condition|(
name|virtuals_instantiated
condition|)
name|argblock
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
argument_list|)
expr_stmt|;
else|else
name|argblock
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|PUSH_ARGS
condition|)
name|argblock
operator|=
name|push_block
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we push args individually in reverse order, perform stack alignment      before the first push (the last arg).  */
if|if
condition|(
name|argblock
operator|==
literal|0
operator|&&
name|PUSH_ARGS_REVERSED
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
operator|-
name|original_args_size
operator|.
name|constant
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PUSH_ARGS_REVERSED
condition|)
block|{
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
name|argnum
operator|=
name|nargs
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
name|argnum
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* The argument list is the property of the called routine and it 	 may clobber it.  If the fixed area has been used for previous 	 parameters, we must save and restore it.  */
name|save_area
operator|=
name|save_fixed_argument_area
argument_list|(
name|reg_parm_stack_space
argument_list|,
name|argblock
argument_list|,
operator|&
name|low_to_save
argument_list|,
operator|&
name|high_to_save
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Push the args that need to be pushed.  */
comment|/* ARGNUM indexes the ARGVEC array in the order in which the arguments      are to be pushed.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
operator|,
name|argnum
operator|+=
name|inc
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|val
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|value
decl_stmt|;
name|rtx
name|reg
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|reg
decl_stmt|;
name|int
name|partial
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|partial
decl_stmt|;
name|int
name|lower_bound
init|=
literal|0
decl_stmt|,
name|upper_bound
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|!=
literal|0
operator|&&
name|partial
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* If this is being stored into a pre-allocated, fixed-size, 		 stack area, save any previous data at that location.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
comment|/* stack_slot is negative, but we want to index stack_usage_map 		 with positive values.  */
name|upper_bound
operator|=
operator|-
name|argvec
index|[
name|argnum
index|]
operator|.
name|locate
operator|.
name|offset
operator|.
name|constant
operator|+
literal|1
expr_stmt|;
name|lower_bound
operator|=
name|upper_bound
operator|-
name|argvec
index|[
name|argnum
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|constant
expr_stmt|;
else|#
directive|else
name|lower_bound
operator|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|locate
operator|.
name|offset
operator|.
name|constant
expr_stmt|;
name|upper_bound
operator|=
name|lower_bound
operator|+
name|argvec
index|[
name|argnum
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|constant
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|lower_bound
expr_stmt|;
comment|/* Don't worry about things in the fixed argument area; 		 it has already been saved.  */
if|if
condition|(
name|i
operator|<
name|reg_parm_stack_space
condition|)
name|i
operator|=
name|reg_parm_stack_space
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|upper_bound
operator|&&
name|stack_usage_map
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|upper_bound
condition|)
block|{
comment|/* We need to make a save area.  */
name|unsigned
name|int
name|size
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|constant
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|size
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|adr
init|=
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|argvec
index|[
name|argnum
index|]
operator|.
name|locate
operator|.
name|offset
operator|.
name|constant
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|adr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|save_mode
operator|==
name|BLKmode
condition|)
block|{
name|argvec
index|[
name|argnum
index|]
operator|.
name|save_area
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|argvec
index|[
name|argnum
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|constant
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|validize_mem
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|save_area
argument_list|)
argument_list|,
name|stack_area
argument_list|,
name|GEN_INT
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|constant
argument_list|)
argument_list|,
name|BLOCK_OP_CALL_PARM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argvec
index|[
name|argnum
index|]
operator|.
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|emit_push_insn
argument_list|(
name|val
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_RTX
argument_list|,
name|PARM_BOUNDARY
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|argblock
argument_list|,
name|GEN_INT
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|locate
operator|.
name|offset
operator|.
name|constant
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|locate
operator|.
name|alignment_pad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now mark the segment we just used.  */
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
name|stack_usage_map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ECF_CONST
condition|)
block|{
name|rtx
name|use
decl_stmt|;
comment|/* Indicate argument access so that alias.c knows that these 		 values are live.  */
if|if
condition|(
name|argblock
condition|)
name|use
operator|=
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|argvec
index|[
name|argnum
index|]
operator|.
name|locate
operator|.
name|offset
operator|.
name|constant
argument_list|)
expr_stmt|;
else|else
comment|/* When arguments are pushed, trying to tell alias.c where 		   exactly this argument is won't work, because the 		   auto-increment causes confusion.  So we merely indicate 		   that we access something with a known mode somewhere on 		   the stack.  */
name|use
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|virtual_outgoing_args_rtx
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
name|use
operator|=
name|gen_rtx_MEM
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|mode
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|use
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|call_fusage
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|use
argument_list|,
name|call_fusage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If we pushed args in forward order, perform stack alignment      after pushing the last arg.  */
if|if
condition|(
name|argblock
operator|==
literal|0
operator|&&
operator|!
name|PUSH_ARGS_REVERSED
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
operator|-
name|original_args_size
operator|.
name|constant
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PUSH_ARGS_REVERSED
condition|)
name|argnum
operator|=
name|nargs
operator|-
literal|1
expr_stmt|;
else|else
name|argnum
operator|=
literal|0
expr_stmt|;
name|fun
operator|=
name|prepare_call_address
argument_list|(
name|fun
argument_list|,
name|NULL
argument_list|,
operator|&
name|call_fusage
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now load any reg parms into their regs.  */
comment|/* ARGNUM indexes the ARGVEC array in the order in which the arguments      are to be pushed.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
operator|,
name|argnum
operator|+=
name|inc
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|val
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|value
decl_stmt|;
name|rtx
name|reg
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|reg
decl_stmt|;
name|int
name|partial
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|partial
decl_stmt|;
comment|/* Handle calls that pass values in multiple non-contiguous 	 locations.  The PA64 has examples of this for library calls.  */
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|reg
argument_list|,
name|val
argument_list|,
name|NULL_TREE
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|partial
operator|==
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
block|}
comment|/* Any regs containing parms remain in use through the call.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|argvec
index|[
name|count
index|]
operator|.
name|reg
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|use_group_regs
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Pass the function the address in which to return a structure value.  */
if|if
condition|(
name|mem_value
operator|!=
literal|0
operator|&&
name|struct_value
operator|!=
literal|0
operator|&&
operator|!
name|pcc_struct_value
condition|)
block|{
name|emit_move_insn
argument_list|(
name|struct_value
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|mem_value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|struct_value
argument_list|)
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|struct_value
argument_list|)
expr_stmt|;
block|}
comment|/* Don't allow popping to be deferred, since then      cse'ing of library calls could delete a call and leave the pop.  */
name|NO_DEFER_POP
expr_stmt|;
name|valreg
operator|=
operator|(
name|mem_value
operator|==
literal|0
operator|&&
name|outmode
operator|!=
name|VOIDmode
condition|?
name|hard_libcall_value
argument_list|(
name|outmode
argument_list|)
else|:
name|NULL_RTX
operator|)
expr_stmt|;
comment|/* Stack must be properly aligned now.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|stack_pointer_delta
operator|&
operator|(
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|before_call
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which      will set inhibit_defer_pop to that value.  */
comment|/* The return type is needed to decide how many bytes the function pops.      Signedness plays no role in that, so for simplicity, we pretend it's      always signed.  We also assume that the list of arguments passed has      no impact, so we pretend it is unknown.  */
name|emit_call_1
argument_list|(
name|fun
argument_list|,
name|NULL
argument_list|,
name|get_identifier
argument_list|(
name|XSTR
argument_list|(
name|orgfun
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_function_type
argument_list|(
name|tfom
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|original_args_size
operator|.
name|constant
argument_list|,
name|args_size
operator|.
name|constant
argument_list|,
name|struct_value_size
argument_list|,
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|valreg
argument_list|,
name|old_inhibit_defer_pop
operator|+
literal|1
argument_list|,
name|call_fusage
argument_list|,
name|flags
argument_list|,
operator|&
name|args_so_far
argument_list|)
expr_stmt|;
comment|/* For calls to `setjmp', etc., inform flow.c it should complain      if nonvolatile values are live.  For functions that cannot return,      inform flow that control does not fall through.  */
if|if
condition|(
name|flags
operator|&
name|ECF_NORETURN
condition|)
block|{
comment|/* The barrier note must be emitted 	 immediately after the CALL_INSN.  Some ports emit more than 	 just a CALL_INSN above, so we must search for it here.  */
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|CALL_P
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* There was no CALL_INSN?  */
name|gcc_assert
argument_list|(
name|last
operator|!=
name|before_call
argument_list|)
expr_stmt|;
block|}
name|emit_barrier_after
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* Now restore inhibit_defer_pop to its actual original value.  */
name|OK_DEFER_POP
expr_stmt|;
comment|/* If call is cse'able, make appropriate pair of reg-notes around it.      Test valreg so we don't crash; may safely ignore `const'      if return type is void.  Disable for PARALLEL return values, because      we have no way to move such values into a pseudo register.  */
if|if
condition|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
if|if
condition|(
name|valreg
operator|==
literal|0
condition|)
block|{
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|note
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|valreg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|outmode
argument_list|)
expr_stmt|;
name|emit_group_store
argument_list|(
name|temp
argument_list|,
name|valreg
argument_list|,
name|NULL_TREE
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
argument_list|)
expr_stmt|;
name|valreg
operator|=
name|temp
expr_stmt|;
block|}
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Construct an "equal form" for the value which mentions all the 	     arguments in order as well as the function name.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|argvec
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|fun
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ECF_PURE
condition|)
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|temp
argument_list|,
name|valreg
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|valreg
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* Copy the value to the right place.  */
if|if
condition|(
name|outmode
operator|!=
name|VOIDmode
operator|&&
name|retval
condition|)
block|{
if|if
condition|(
name|mem_value
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|mem_value
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|mem_value
condition|)
name|emit_move_insn
argument_list|(
name|value
argument_list|,
name|mem_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|valreg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|gen_reg_rtx
argument_list|(
name|outmode
argument_list|)
expr_stmt|;
name|emit_group_store
argument_list|(
name|value
argument_list|,
name|valreg
argument_list|,
name|NULL_TREE
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|value
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|valreg
expr_stmt|;
block|}
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
if|if
condition|(
name|save_area
condition|)
name|restore_fixed_argument_area
argument_list|(
name|save_area
argument_list|,
name|argblock
argument_list|,
name|high_to_save
argument_list|,
name|low_to_save
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we saved any argument areas, restore them.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
condition|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
argument_list|)
decl_stmt|;
name|rtx
name|adr
init|=
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|locate
operator|.
name|offset
operator|.
name|constant
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|adr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|save_mode
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|stack_area
argument_list|,
name|validize_mem
argument_list|(
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|argvec
index|[
name|count
index|]
operator|.
name|locate
operator|.
name|size
operator|.
name|constant
argument_list|)
argument_list|,
name|BLOCK_OP_CALL_PARM
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
argument_list|)
expr_stmt|;
block|}
name|highest_outgoing_arg_in_use
operator|=
name|initial_highest_arg_in_use
expr_stmt|;
name|stack_usage_map
operator|=
name|initial_stack_usage_map
expr_stmt|;
block|}
if|if
condition|(
name|stack_usage_map_buf
condition|)
name|free
argument_list|(
name|stack_usage_map_buf
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a library call to function FUN (a SYMBOL_REF rtx)    (emitting the queue unless NO_QUEUE is nonzero),    for a value of mode OUTMODE,    with NARGS different arguments, passed as alternating rtx values    and machine_modes to convert them to.     FN_TYPE should be LCT_NORMAL for `normal' calls, LCT_CONST for `const'    calls, LCT_PURE for `pure' calls, LCT_CONST_MAKE_BLOCK for `const' calls    which should be enclosed in REG_LIBCALL/REG_RETVAL notes,    LCT_PURE_MAKE_BLOCK for `purep' calls which should be enclosed in    REG_LIBCALL/REG_RETVAL notes with extra (use (memory (scratch)),    or other LCT_ value for other types of library calls.  */
end_comment

begin_function
name|void
name|emit_library_call
parameter_list|(
name|rtx
name|orgfun
parameter_list|,
name|enum
name|libcall_type
name|fn_type
parameter_list|,
name|enum
name|machine_mode
name|outmode
parameter_list|,
name|int
name|nargs
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|p
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|emit_library_call_value_1
argument_list|(
literal|0
argument_list|,
name|orgfun
argument_list|,
name|NULL_RTX
argument_list|,
name|fn_type
argument_list|,
name|outmode
argument_list|,
name|nargs
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like emit_library_call except that an extra argument, VALUE,    comes second and says where to store the result.    (If VALUE is zero, this function chooses a convenient way    to return the value.     This function returns an rtx for where the value is to be found.    If VALUE is nonzero, VALUE is returned.  */
end_comment

begin_function
name|rtx
name|emit_library_call_value
parameter_list|(
name|rtx
name|orgfun
parameter_list|,
name|rtx
name|value
parameter_list|,
name|enum
name|libcall_type
name|fn_type
parameter_list|,
name|enum
name|machine_mode
name|outmode
parameter_list|,
name|int
name|nargs
parameter_list|,
modifier|...
parameter_list|)
block|{
name|rtx
name|result
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|result
operator|=
name|emit_library_call_value_1
argument_list|(
literal|1
argument_list|,
name|orgfun
argument_list|,
name|value
argument_list|,
name|fn_type
argument_list|,
name|outmode
argument_list|,
name|nargs
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store a single argument for a function call    into the register or memory area where it must be passed.    *ARG describes the argument value and where to pass it.     ARGBLOCK is the address of the stack-block for all the arguments,    or 0 on a machine where arguments are pushed individually.     MAY_BE_ALLOCA nonzero says this could be a call to `alloca'    so must be careful about how the stack is used.     VARIABLE_SIZE nonzero says that this was a variable-sized outgoing    argument stack.  This is used if ACCUMULATE_OUTGOING_ARGS to indicate    that we need not worry about saving and restoring the stack.     FNDECL is the declaration of the function we are calling.     Return nonzero if this arg should cause sibcall failure,    zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|store_one_arg
parameter_list|(
name|struct
name|arg_data
modifier|*
name|arg
parameter_list|,
name|rtx
name|argblock
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|variable_size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|reg_parm_stack_space
parameter_list|)
block|{
name|tree
name|pval
init|=
name|arg
operator|->
name|tree_value
decl_stmt|;
name|rtx
name|reg
init|=
literal|0
decl_stmt|;
name|int
name|partial
init|=
literal|0
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lower_bound
init|=
literal|0
decl_stmt|,
name|upper_bound
init|=
literal|0
decl_stmt|;
name|int
name|sibcall_failure
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pval
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
comment|/* Push a new temporary level for any temporaries we make for      this argument.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ECF_SIBCALL
operator|)
condition|)
block|{
comment|/* If this is being stored into a pre-allocated, fixed-size, stack area, 	 save any previous data at that location.  */
if|if
condition|(
name|argblock
operator|&&
operator|!
name|variable_size
operator|&&
name|arg
operator|->
name|stack
condition|)
block|{
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
comment|/* stack_slot is negative, but we want to index stack_usage_map 	     with positive values.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|upper_bound
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|upper_bound
operator|=
literal|0
expr_stmt|;
name|lower_bound
operator|=
name|upper_bound
operator|-
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|constant
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|lower_bound
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|lower_bound
operator|=
literal|0
expr_stmt|;
name|upper_bound
operator|=
name|lower_bound
operator|+
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|constant
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|lower_bound
expr_stmt|;
comment|/* Don't worry about things in the fixed argument area; 	     it has already been saved.  */
if|if
condition|(
name|i
operator|<
name|reg_parm_stack_space
condition|)
name|i
operator|=
name|reg_parm_stack_space
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|upper_bound
operator|&&
name|stack_usage_map
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|upper_bound
condition|)
block|{
comment|/* We need to make a save area.  */
name|unsigned
name|int
name|size
init|=
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|constant
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|size
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|adr
init|=
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|adr
argument_list|)
decl_stmt|;
if|if
condition|(
name|save_mode
operator|==
name|BLKmode
condition|)
block|{
name|tree
name|ot
init|=
name|TREE_TYPE
argument_list|(
name|arg
operator|->
name|tree_value
argument_list|)
decl_stmt|;
name|tree
name|nt
init|=
name|build_qualified_type
argument_list|(
name|ot
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|ot
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
decl_stmt|;
name|arg
operator|->
name|save_area
operator|=
name|assign_temp
argument_list|(
name|nt
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|arg
operator|->
name|save_area
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|validize_mem
argument_list|(
name|arg
operator|->
name|save_area
argument_list|)
argument_list|,
name|stack_area
argument_list|,
name|GEN_INT
argument_list|(
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|constant
argument_list|)
argument_list|,
name|BLOCK_OP_CALL_PARM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|->
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|arg
operator|->
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If this isn't going to be placed on both the stack and in registers,      set up the register and number of words.  */
if|if
condition|(
operator|!
name|arg
operator|->
name|pass_on_stack
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ECF_SIBCALL
condition|)
name|reg
operator|=
name|arg
operator|->
name|tail_call_reg
expr_stmt|;
else|else
name|reg
operator|=
name|arg
operator|->
name|reg
expr_stmt|;
name|partial
operator|=
name|arg
operator|->
name|partial
expr_stmt|;
block|}
comment|/* Being passed entirely in a register.  We shouldn't be called in      this case.  */
name|gcc_assert
argument_list|(
name|reg
operator|==
literal|0
operator|||
name|partial
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* If this arg needs special alignment, don't load the registers      here.  */
if|if
condition|(
name|arg
operator|->
name|n_aligned_regs
operator|!=
literal|0
condition|)
name|reg
operator|=
literal|0
expr_stmt|;
comment|/* If this is being passed partially in a register, we can't evaluate      it directly into its stack slot.  Otherwise, we can.  */
if|if
condition|(
name|arg
operator|->
name|value
operator|==
literal|0
condition|)
block|{
comment|/* stack_arg_under_construction is nonzero if a function argument is 	 being evaluated directly into the outgoing argument list and 	 expand_call must take special action to preserve the argument list 	 if it is called recursively.  	 For scalar function arguments stack_usage_map is sufficient to 	 determine which stack slots must be saved and restored.  Scalar 	 arguments in general have pass_on_stack == 0.  	 If this argument is initialized by a function which takes the 	 address of the argument (a C++ constructor or a C function 	 returning a BLKmode structure), then stack_usage_map is 	 insufficient and expand_call must push the stack around the 	 function call.  Such arguments have pass_on_stack == 1.  	 Note that it is always safe to set stack_arg_under_construction, 	 but this generates suboptimal code if set when not needed.  */
if|if
condition|(
name|arg
operator|->
name|pass_on_stack
condition|)
name|stack_arg_under_construction
operator|++
expr_stmt|;
name|arg
operator|->
name|value
operator|=
name|expand_expr
argument_list|(
name|pval
argument_list|,
operator|(
name|partial
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|!=
name|arg
operator|->
name|mode
operator|)
condition|?
name|NULL_RTX
else|:
name|arg
operator|->
name|stack
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_STACK_PARM
argument_list|)
expr_stmt|;
comment|/* If we are promoting object (or for any other reason) the mode 	 doesn't agree, convert the mode.  */
if|if
condition|(
name|arg
operator|->
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
condition|)
name|arg
operator|->
name|value
operator|=
name|convert_modes
argument_list|(
name|arg
operator|->
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|,
name|arg
operator|->
name|value
argument_list|,
name|arg
operator|->
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|pass_on_stack
condition|)
name|stack_arg_under_construction
operator|--
expr_stmt|;
block|}
comment|/* Check for overlap with already clobbered argument area.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|ECF_SIBCALL
operator|)
operator|&&
name|MEM_P
argument_list|(
name|arg
operator|->
name|value
argument_list|)
operator|&&
name|mem_overlaps_already_clobbered_arg_p
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|constant
argument_list|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
comment|/* Don't allow anything left on stack from computation      of argument to alloca.  */
if|if
condition|(
name|flags
operator|&
name|ECF_MAY_BE_ALLOCA
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|value
operator|==
name|arg
operator|->
name|stack
condition|)
comment|/* If the value is already in the stack slot, we are done.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|mode
operator|!=
name|BLKmode
condition|)
block|{
name|int
name|size
decl_stmt|;
comment|/* Argument is a scalar, not entirely passed in registers. 	 (If part is passed in registers, arg->partial says how much 	 and emit_push_insn will take care of putting it there.)  	 Push it, and if its size is less than the 	 amount of space allocated to it, 	 also bump stack pointer by the additional space. 	 Note that in C the default argument promotions 	 will prevent such mismatches.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|arg
operator|->
name|mode
argument_list|)
expr_stmt|;
comment|/* Compute how much space the push instruction will push. 	 On many machines, pushing a byte will advance the stack 	 pointer by a halfword.  */
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|used
operator|=
name|size
expr_stmt|;
comment|/* Compute how much space the argument should get: 	 round up to a multiple of the alignment for arguments.  */
if|if
condition|(
name|none
operator|!=
name|FUNCTION_ARG_PADDING
argument_list|(
name|arg
operator|->
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
condition|)
name|used
operator|=
operator|(
operator|(
operator|(
name|size
operator|+
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* This isn't already where we want it on the stack, so put it there. 	 This can either be done with push or copy insns.  */
name|emit_push_insn
argument_list|(
name|arg
operator|->
name|value
argument_list|,
name|arg
operator|->
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|PARM_BOUNDARY
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
name|used
operator|-
name|size
argument_list|,
name|argblock
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|locate
operator|.
name|offset
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|locate
operator|.
name|alignment_pad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unless this is a partially-in-register argument, the argument is now 	 in the stack.  */
if|if
condition|(
name|partial
operator|==
literal|0
condition|)
name|arg
operator|->
name|value
operator|=
name|arg
operator|->
name|stack
expr_stmt|;
block|}
else|else
block|{
comment|/* BLKmode, at least partly to be pushed.  */
name|unsigned
name|int
name|parm_align
decl_stmt|;
name|int
name|excess
decl_stmt|;
name|rtx
name|size_rtx
decl_stmt|;
comment|/* Pushing a nonscalar. 	 If part is passed in registers, PARTIAL says how much 	 and emit_push_insn will take care of putting it there.  */
comment|/* Round its size up to a multiple 	 of the allocation unit for arguments.  */
if|if
condition|(
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|var
operator|!=
literal|0
condition|)
block|{
name|excess
operator|=
literal|0
expr_stmt|;
name|size_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|locate
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* PUSH_ROUNDING has no effect on us, because emit_push_insn 	     for BLKmode is careful to avoid it.  */
name|excess
operator|=
operator|(
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|constant
operator|-
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|+
name|partial
operator|)
expr_stmt|;
name|size_rtx
operator|=
name|expand_expr
argument_list|(
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|parm_align
operator|=
name|arg
operator|->
name|locate
operator|.
name|boundary
expr_stmt|;
comment|/* When an argument is padded down, the block is aligned to 	 PARM_BOUNDARY, but the actual argument isn't.  */
if|if
condition|(
name|FUNCTION_ARG_PADDING
argument_list|(
name|arg
operator|->
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|==
name|downward
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|var
condition|)
name|parm_align
operator|=
name|BITS_PER_UNIT
expr_stmt|;
elseif|else
if|if
condition|(
name|excess
condition|)
block|{
name|unsigned
name|int
name|excess_align
init|=
operator|(
name|excess
operator|&
operator|-
name|excess
operator|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|parm_align
operator|=
name|MIN
argument_list|(
name|parm_align
argument_list|,
name|excess_align
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|ECF_SIBCALL
operator|)
operator|&&
name|MEM_P
argument_list|(
name|arg
operator|->
name|value
argument_list|)
condition|)
block|{
comment|/* emit_push_insn might not work properly if arg->value and 	     argblock + arg->locate.offset areas overlap.  */
name|rtx
name|x
init|=
name|arg
operator|->
name|value
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|current_function_internal_arg_pointer
condition|)
name|i
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* expand_call should ensure this.  */
name|gcc_assert
argument_list|(
operator|!
name|arg
operator|->
name|locate
operator|.
name|offset
operator|.
name|var
operator|&&
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|var
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|size_rtx
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|locate
operator|.
name|offset
operator|.
name|constant
operator|>
name|i
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|locate
operator|.
name|offset
operator|.
name|constant
operator|<
name|i
operator|+
name|INTVAL
argument_list|(
name|size_rtx
argument_list|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|locate
operator|.
name|offset
operator|.
name|constant
operator|<
name|i
condition|)
block|{
comment|/* Use arg->locate.size.constant instead of size_rtx 		     because we only care about the part of the argument 		     on the stack.  */
if|if
condition|(
name|i
operator|<
operator|(
name|arg
operator|->
name|locate
operator|.
name|offset
operator|.
name|constant
operator|+
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|constant
operator|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Even though they appear to be at the same location, 		     if part of the outgoing argument is in registers, 		     they aren't really at the same location.  Check for 		     this by making sure that the incoming size is the 		     same as the outgoing size.  */
if|if
condition|(
name|arg
operator|->
name|locate
operator|.
name|size
operator|.
name|constant
operator|!=
name|INTVAL
argument_list|(
name|size_rtx
argument_list|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|emit_push_insn
argument_list|(
name|arg
operator|->
name|value
argument_list|,
name|arg
operator|->
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|,
name|size_rtx
argument_list|,
name|parm_align
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
name|excess
argument_list|,
name|argblock
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|locate
operator|.
name|offset
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|locate
operator|.
name|alignment_pad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unless this is a partially-in-register argument, the argument is now 	 in the stack.  	 ??? Unlike the case above, in which we want the actual 	 address of the data, so that we can load it directly into a 	 register, here we want the address of the stack slot, so that 	 it's properly aligned for word-by-word copying or something 	 like that.  It's not clear that this is always correct.  */
if|if
condition|(
name|partial
operator|==
literal|0
condition|)
name|arg
operator|->
name|value
operator|=
name|arg
operator|->
name|stack_slot
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|->
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|arg
operator|->
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
operator|->
name|tree_value
argument_list|)
decl_stmt|;
name|arg
operator|->
name|parallel_value
operator|=
name|emit_group_load_into_temps
argument_list|(
name|arg
operator|->
name|reg
argument_list|,
name|arg
operator|->
name|value
argument_list|,
name|type
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Mark all slots this store used.  */
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ECF_SIBCALL
operator|)
operator|&&
name|argblock
operator|&&
operator|!
name|variable_size
operator|&&
name|arg
operator|->
name|stack
condition|)
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
name|stack_usage_map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Once we have pushed something, pops can't safely      be deferred during the rest of the arguments.  */
name|NO_DEFER_POP
expr_stmt|;
comment|/* Free any temporary slots made in processing this argument.  Show      that we might have taken the address of something and pushed that      as an operand.  */
name|preserve_temp_slots
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|sibcall_failure
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we do not know how to pass TYPE solely in registers.  */
end_comment

begin_function
name|bool
name|must_pass_in_stack_var_size
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|false
return|;
comment|/* If the type has variable size...  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|true
return|;
comment|/* If the type is marked as addressable (it is required      to be constructed into the stack)...  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Another version of the TARGET_MUST_PASS_IN_STACK hook.  This one    takes trailing padding of a structure into account.  */
end_comment

begin_comment
comment|/* ??? Should be able to merge these two by examining BLOCK_REG_PADDING.  */
end_comment

begin_function
name|bool
name|must_pass_in_stack_var_size_or_pad
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|false
return|;
comment|/* If the type has variable size...  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|true
return|;
comment|/* If the type is marked as addressable (it is required      to be constructed into the stack)...  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If the padding and mode of the type is such that a copy into      a register would put it into the wrong part of the register.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|%
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|&&
operator|(
name|FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|==
operator|(
name|BYTES_BIG_ENDIAN
condition|?
name|upward
else|:
name|downward
operator|)
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

end_unit

