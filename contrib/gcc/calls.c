begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert function calls to rtl insns, for GNU C compiler.    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000    Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
name|PREFERRED_STACK_BOUNDARY
operator|&&
name|defined
name|STACK_BOUNDARY
end_if

begin_define
define|#
directive|define
name|PREFERRED_STACK_BOUNDARY
value|STACK_BOUNDARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Decide whether a function's arguments should be processed    from first to last or from last to first.     They should if the stack and args grow in opposite directions, but    only if we have push insns.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STACK_GROWS_DOWNWARD
argument_list|)
operator|!=
name|defined
argument_list|(
name|ARGS_GROW_DOWNWARD
argument_list|)
end_if

begin_define
define|#
directive|define
name|PUSH_ARGS_REVERSED
end_define

begin_comment
comment|/* If it's last to first */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */
end_comment

begin_define
define|#
directive|define
name|STACK_BYTES
value|(PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)
end_define

begin_comment
comment|/* Data structure and subroutines used within expand_call.  */
end_comment

begin_struct
struct|struct
name|arg_data
block|{
comment|/* Tree node for this argument.  */
name|tree
name|tree_value
decl_stmt|;
comment|/* Mode for value; TYPE_MODE unless promoted.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Current RTL value for argument, or 0 if it isn't precomputed.  */
name|rtx
name|value
decl_stmt|;
comment|/* Initially-compute RTL value for argument; only for const functions.  */
name|rtx
name|initial_value
decl_stmt|;
comment|/* Register to pass this argument in, 0 if passed on stack, or an      PARALLEL if the arg is to be copied into multiple non-contiguous      registers.  */
name|rtx
name|reg
decl_stmt|;
comment|/* If REG was promoted from the actual mode of the argument expression,      indicates whether the promotion is sign- or zero-extended.  */
name|int
name|unsignedp
decl_stmt|;
comment|/* Number of registers to use.  0 means put the whole arg in registers.      Also 0 if not passed in registers.  */
name|int
name|partial
decl_stmt|;
comment|/* Non-zero if argument must be passed on stack.      Note that some arguments may be passed on the stack      even though pass_on_stack is zero, just because FUNCTION_ARG says so.      pass_on_stack identifies arguments that *cannot* go in registers.  */
name|int
name|pass_on_stack
decl_stmt|;
comment|/* Offset of this argument from beginning of stack-args.  */
name|struct
name|args_size
name|offset
decl_stmt|;
comment|/* Similar, but offset to the start of the stack slot.  Different from      OFFSET if this arg pads downward.  */
name|struct
name|args_size
name|slot_offset
decl_stmt|;
comment|/* Size of this argument on the stack, rounded up for any padding it gets,      parts of the argument passed in registers do not count.      If REG_PARM_STACK_SPACE is defined, then register parms      are counted here as well.  */
name|struct
name|args_size
name|size
decl_stmt|;
comment|/* Location on the stack at which parameter should be stored.  The store      has already been done if STACK == VALUE.  */
name|rtx
name|stack
decl_stmt|;
comment|/* Location on the stack of the start of this argument slot.  This can      differ from STACK if this arg pads downward.  This location is known      to be aligned to FUNCTION_ARG_BOUNDARY.  */
name|rtx
name|stack_slot
decl_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* Place that this stack area has been saved, if needed.  */
name|rtx
name|save_area
decl_stmt|;
endif|#
directive|endif
comment|/* If an argument's alignment does not permit direct copying into registers,      copy in smaller-sized pieces into pseudos.  These are stored in a      block pointed to by this field.  The next field says how many      word-sized pseudos we made.  */
name|rtx
modifier|*
name|aligned_regs
decl_stmt|;
name|int
name|n_aligned_regs
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
end_ifdef

begin_comment
comment|/* A vector of one char per byte of stack space.  A byte if non-zero if    the corresponding stack location has been used.    This vector is used to prevent a function call within an argument from    clobbering any stack already set up.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stack_usage_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of STACK_USAGE_MAP.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|highest_outgoing_arg_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack_arg_under_construction is nonzero when an argument may be    initialized with a constructor call (including a C function that    returns a BLKmode struct) and expand_call must take special action    to make sure the object being constructed does not overlap the    argument list for the constructor call.  */
end_comment

begin_decl_stmt
name|int
name|stack_arg_under_construction
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|calls_function
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|calls_function_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_call_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|tree
operator|,
name|tree
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|special_function_p
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tree
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|precompute_register_parameters
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|arg_data
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_one_arg
name|PROTO
argument_list|(
operator|(
expr|struct
name|arg_data
operator|*
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_unaligned_arguments_into_pseudos
name|PROTO
argument_list|(
operator|(
expr|struct
name|arg_data
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finalize_must_preallocate
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|arg_data
operator|*
operator|,
expr|struct
name|args_size
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|precompute_arguments
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|arg_data
operator|*
operator|,
expr|struct
name|args_size
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compute_argument_block_size
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|args_size
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_argument_information
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|arg_data
operator|*
operator|,
expr|struct
name|args_size
operator|*
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|CUMULATIVE_ARGS
operator|*
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_argument_addresses
name|PROTO
argument_list|(
operator|(
expr|struct
name|arg_data
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|rtx_for_function_call
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_register_parameters
name|PROTO
argument_list|(
operator|(
expr|struct
name|arg_data
operator|*
operator|,
name|int
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|rtx
name|save_fixed_argument_area
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_fixed_argument_area
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* If WHICH is 1, return 1 if EXP contains a call to the built-in function    `alloca'.     If WHICH is 0, return 1 if EXP contains a call to any function.    Actually, we only need return 1 if evaluating EXP would require pushing    arguments on the stack, but that is too difficult to compute, so we just    assume any function call might require the stack.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|calls_function_save_exprs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|calls_function
parameter_list|(
name|exp
parameter_list|,
name|which
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|calls_function_save_exprs
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|calls_function_1
argument_list|(
name|exp
argument_list|,
name|which
argument_list|)
expr_stmt|;
name|calls_function_save_exprs
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|calls_function_1
parameter_list|(
name|exp
parameter_list|,
name|which
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
decl_stmt|;
comment|/* If this code is language-specific, we don't know what it will do.  */
if|if
condition|(
operator|(
name|int
operator|)
name|code
operator|>=
name|NUM_TREE_CODES
condition|)
return|return
literal|1
return|;
comment|/* Only expressions and references can contain calls.  */
if|if
condition|(
name|type
operator|!=
literal|'e'
operator|&&
name|type
operator|!=
literal|'<'
operator|&&
name|type
operator|!=
literal|'1'
operator|&&
name|type
operator|!=
literal|'2'
operator|&&
name|type
operator|!=
literal|'r'
operator|&&
name|type
operator|!=
literal|'b'
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|which
operator|==
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|DECL_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_ALLOCA
operator|)
operator|||
operator|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|(
name|FUNCTION_FLAGS
argument_list|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&
name|FUNCTION_FLAGS_CALLS_ALLOCA
operator|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Third operand is RTL.  */
name|length
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|value_member
argument_list|(
name|exp
argument_list|,
name|calls_function_save_exprs
argument_list|)
condition|)
return|return
literal|0
return|;
name|calls_function_save_exprs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp
argument_list|,
name|calls_function_save_exprs
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|calls_function_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|which
argument_list|)
operator|)
return|;
case|case
name|BLOCK
case|:
block|{
specifier|register
name|tree
name|local
decl_stmt|;
for|for
control|(
name|local
operator|=
name|BLOCK_VARS
argument_list|(
name|exp
argument_list|)
init|;
name|local
condition|;
name|local
operator|=
name|TREE_CHAIN
argument_list|(
name|local
argument_list|)
control|)
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|local
argument_list|)
operator|!=
literal|0
operator|&&
name|calls_function_1
argument_list|(
name|DECL_INITIAL
argument_list|(
name|local
argument_list|)
argument_list|,
name|which
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|{
specifier|register
name|tree
name|subblock
decl_stmt|;
for|for
control|(
name|subblock
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|exp
argument_list|)
init|;
name|subblock
condition|;
name|subblock
operator|=
name|TREE_CHAIN
argument_list|(
name|subblock
argument_list|)
control|)
if|if
condition|(
name|calls_function_1
argument_list|(
name|subblock
argument_list|,
name|which
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|METHOD_CALL_EXPR
case|:
name|length
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|length
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RTL_EXPR
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
operator|&&
name|calls_function_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|,
name|which
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Force FUNEXP into a form suitable for the address of a CALL,    and return that as an rtx.  Also load the static chain register    if FNDECL is a nested function.     CALL_FUSAGE points to a variable holding the prospective    CALL_INSN_FUNCTION_USAGE information.  */
end_comment

begin_function
name|rtx
name|prepare_call_address
parameter_list|(
name|funexp
parameter_list|,
name|fndecl
parameter_list|,
name|call_fusage
parameter_list|,
name|reg_parm_seen
parameter_list|)
name|rtx
name|funexp
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|rtx
modifier|*
name|call_fusage
decl_stmt|;
name|int
name|reg_parm_seen
decl_stmt|;
block|{
name|rtx
name|static_chain_value
init|=
literal|0
decl_stmt|;
name|funexp
operator|=
name|protect_from_queue
argument_list|(
name|funexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
operator|!=
literal|0
condition|)
comment|/* Get possible static chain value for nested function in C.  */
name|static_chain_value
operator|=
name|lookup_static_chain
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Make a valid memory address and copy constants thru pseudo-regs,      but not for a constant address if -fno-function-cse.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|funexp
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
comment|/* If we are using registers for parameters, force the        function address into a register now.  */
name|funexp
operator|=
operator|(
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|reg_parm_seen
operator|)
condition|?
name|force_not_mem
argument_list|(
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|)
else|:
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
ifndef|#
directive|ifndef
name|NO_FUNCTION_CSE
if|if
condition|(
name|optimize
operator|&&
operator|!
name|flag_no_function_cse
condition|)
ifdef|#
directive|ifdef
name|NO_RECURSIVE_FUNCTION_CSE
if|if
condition|(
name|fndecl
operator|!=
name|current_function_decl
condition|)
endif|#
directive|endif
name|funexp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|static_chain_value
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|static_chain_rtx
argument_list|,
name|static_chain_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|static_chain_rtx
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|static_chain_rtx
argument_list|)
expr_stmt|;
block|}
return|return
name|funexp
return|;
block|}
end_function

begin_comment
comment|/* Generate instructions to call function FUNEXP,    and optionally pop the results.    The CALL_INSN is the first insn generated.     FNDECL is the declaration node of the function.  This is given to the    macro RETURN_POPS_ARGS to determine whether this function pops its own args.     FUNTYPE is the data type of the function.  This is given to the macro    RETURN_POPS_ARGS to determine whether this function pops its own args.    We used to allow an identifier for library functions, but that doesn't    work when the return type is an aggregate type and the calling convention    says that the pointer to this aggregate is to be popped by the callee.     STACK_SIZE is the number of bytes of arguments on the stack,    rounded up to PREFERRED_STACK_BOUNDARY; zero if the size is variable.    This is both to put into the call insn and    to generate explicit popping code if necessary.     STRUCT_VALUE_SIZE is the number of bytes wanted in a structure value.    It is zero if this call doesn't want a structure value.     NEXT_ARG_REG is the rtx that results from executing      FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1)    just after all the args have had their registers assigned.    This could be whatever you like, but normally it is the first    arg-register beyond those used for args in this call,    or 0 if all the arg-registers are used in this call.    It is passed on to `gen_call' so you can put this info in the call insn.     VALREG is a hard register in which a value is returned,    or 0 if the call does not return a value.     OLD_INHIBIT_DEFER_POP is the value that `inhibit_defer_pop' had before    the args to this call were processed.    We restore `inhibit_defer_pop' to that value.     CALL_FUSAGE is either empty or an EXPR_LIST of USE expressions that    denote registers used by the called function.     IS_CONST is true if this is a `const' call.  */
end_comment

begin_function
specifier|static
name|void
name|emit_call_1
parameter_list|(
name|funexp
parameter_list|,
name|fndecl
parameter_list|,
name|funtype
parameter_list|,
name|stack_size
parameter_list|,
name|rounded_stack_size
parameter_list|,
name|struct_value_size
parameter_list|,
name|next_arg_reg
parameter_list|,
name|valreg
parameter_list|,
name|old_inhibit_defer_pop
parameter_list|,
name|call_fusage
parameter_list|,
name|is_const
parameter_list|)
name|rtx
name|funexp
decl_stmt|;
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|funtype
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|stack_size
decl_stmt|;
name|HOST_WIDE_INT
name|rounded_stack_size
decl_stmt|;
name|HOST_WIDE_INT
name|struct_value_size
decl_stmt|;
name|rtx
name|next_arg_reg
decl_stmt|;
name|rtx
name|valreg
decl_stmt|;
name|int
name|old_inhibit_defer_pop
decl_stmt|;
name|rtx
name|call_fusage
decl_stmt|;
name|int
name|is_const
decl_stmt|;
block|{
name|rtx
name|rounded_stack_size_rtx
init|=
name|GEN_INT
argument_list|(
name|rounded_stack_size
argument_list|)
decl_stmt|;
name|rtx
name|struct_value_size_rtx
init|=
name|GEN_INT
argument_list|(
name|struct_value_size
argument_list|)
decl_stmt|;
name|rtx
name|call_insn
decl_stmt|;
ifndef|#
directive|ifndef
name|ACCUMULATE_OUTGOING_ARGS
name|int
name|already_popped
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|n_popped
init|=
name|RETURN_POPS_ARGS
argument_list|(
name|fndecl
argument_list|,
name|funtype
argument_list|,
name|stack_size
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Ensure address is valid.  SYMBOL_REF is already valid, so no need,      and we don't want to load it into a register as an optimization,      because prepare_call_address already did it if it should be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|funexp
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|funexp
operator|=
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ACCUMULATE_OUTGOING_ARGS
if|#
directive|if
name|defined
argument_list|(
name|HAVE_call_pop
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_call_value_pop
argument_list|)
comment|/* If the target has "call" or "call_value" insns, then prefer them    if no arguments are actually popped.  If the target does not have    "call" or "call_value" insns, then we must use the popping versions    even if the call has no arguments to pop.  */
if|if
condition|(
name|HAVE_call_pop
operator|&&
name|HAVE_call_value_pop
if|#
directive|if
name|defined
argument_list|(
name|HAVE_call
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_call_value
argument_list|)
operator|&&
operator|(
name|n_popped
operator|>
literal|0
operator|||
operator|!
name|HAVE_call
operator|||
operator|!
name|HAVE_call_value
operator|)
endif|#
directive|endif
condition|)
block|{
name|rtx
name|n_pop
init|=
name|GEN_INT
argument_list|(
name|n_popped
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
comment|/* If this subroutine pops its own args, record that in the call insn 	 if possible, for the sake of frame pointer elimination.  */
if|if
condition|(
name|valreg
condition|)
name|pat
operator|=
name|gen_call_value_pop
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|n_pop
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|gen_call_pop
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|n_pop
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|already_popped
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_call
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_call_value
argument_list|)
if|if
condition|(
name|HAVE_call
operator|&&
name|HAVE_call_value
condition|)
block|{
if|if
condition|(
name|valreg
condition|)
name|emit_call_insn
argument_list|(
name|gen_call_value
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_call_insn
argument_list|(
name|gen_call
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|struct_value_size_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the CALL insn we just emitted.  */
for|for
control|(
name|call_insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|call_insn
operator|&&
name|GET_CODE
argument_list|(
name|call_insn
argument_list|)
operator|!=
name|CALL_INSN
condition|;
name|call_insn
operator|=
name|PREV_INSN
argument_list|(
name|call_insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|call_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Put the register usage information on the CALL.  If there is already      some usage information, put ours at the end.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
init|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
empty_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
block|}
else|else
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
comment|/* If this is a const call, then set the insn's unchanging bit.  */
if|if
condition|(
name|is_const
condition|)
name|CONST_CALL_P
argument_list|(
name|call_insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Restore this now, so that we do defer pops for this call's args      if the context of the call as a whole permits.  */
name|inhibit_defer_pop
operator|=
name|old_inhibit_defer_pop
expr_stmt|;
ifndef|#
directive|ifndef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* If returning from the subroutine does not automatically pop the args,      we need an instruction to pop them sooner or later.      Perhaps do it now; perhaps just record how much space to pop later.       If returning from the subroutine does pop the args, indicate that the      stack pointer will be changed.  */
if|if
condition|(
name|n_popped
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|already_popped
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
name|rounded_stack_size
operator|-=
name|n_popped
expr_stmt|;
name|rounded_stack_size_rtx
operator|=
name|GEN_INT
argument_list|(
name|rounded_stack_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rounded_stack_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|flag_defer_pop
operator|&&
name|inhibit_defer_pop
operator|==
literal|0
operator|&&
operator|!
name|is_const
condition|)
name|pending_stack_adjust
operator|+=
name|rounded_stack_size
expr_stmt|;
else|else
name|adjust_stack
argument_list|(
name|rounded_stack_size_rtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Determine if the function identified by NAME and FNDECL is one with    special properties we wish to know about.     For example, if the function might return more than one time (setjmp), then    set RETURNS_TWICE to a nonzero value.     Similarly set IS_LONGJMP for if the function is in the longjmp family.     Set IS_MALLOC for any of the standard memory allocation functions which    allocate from the heap.     Set MAY_BE_ALLOCA for any memory allocation function that might allocate    space from the stack such as alloca.  */
end_comment

begin_function
specifier|static
name|void
name|special_function_p
parameter_list|(
name|name
parameter_list|,
name|fndecl
parameter_list|,
name|returns_twice
parameter_list|,
name|is_longjmp
parameter_list|,
name|is_malloc
parameter_list|,
name|may_be_alloca
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
modifier|*
name|returns_twice
decl_stmt|;
name|int
modifier|*
name|is_longjmp
decl_stmt|;
name|int
modifier|*
name|is_malloc
decl_stmt|;
name|int
modifier|*
name|may_be_alloca
decl_stmt|;
block|{
operator|*
name|returns_twice
operator|=
literal|0
expr_stmt|;
operator|*
name|is_longjmp
operator|=
literal|0
expr_stmt|;
operator|*
name|is_malloc
operator|=
literal|0
expr_stmt|;
operator|*
name|may_be_alloca
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|!=
literal|0
operator|&&
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|<=
literal|17
comment|/* Exclude functions not at the file scope, or not `extern', 	 since they are not the magic functions we would otherwise 	 think they are.  */
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_PUBLIC
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tname
init|=
name|name
decl_stmt|;
comment|/* We assume that alloca will always be called by name.  It 	 makes no sense to pass it as a pointer-to-function to 	 anything that does not understand its behavior.  */
operator|*
name|may_be_alloca
operator|=
operator|(
operator|(
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|6
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'a'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"alloca"
argument_list|)
operator|)
operator|||
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|16
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_alloca"
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Disregard prefix _, __ or __x.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'x'
condition|)
name|tname
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
name|tname
operator|+=
literal|2
expr_stmt|;
else|else
name|tname
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
operator|*
name|returns_twice
operator|=
operator|(
operator|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"setjmp"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"setjmp_syscall"
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"sigsetjmp"
argument_list|)
operator|)
operator|||
operator|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"savectx"
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"siglongjmp"
argument_list|)
condition|)
operator|*
name|is_longjmp
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'q'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"qsetjmp"
argument_list|)
operator|)
operator|||
operator|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'v'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"vfork"
argument_list|)
operator|)
condition|)
operator|*
name|returns_twice
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'l'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"longjmp"
argument_list|)
condition|)
operator|*
name|is_longjmp
operator|=
literal|1
expr_stmt|;
comment|/* XXX should have "malloc" attribute on functions instead 	 of recognizing them by name.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"malloc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"calloc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"realloc"
argument_list|)
comment|/* Note use of NAME rather than TNAME here.  These functions 		  are only reserved when preceded with __.  */
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__vn"
argument_list|)
comment|/* mangled __builtin_vec_new */
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__nw"
argument_list|)
comment|/* mangled __builtin_new */
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_new"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_vec_new"
argument_list|)
condition|)
operator|*
name|is_malloc
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Precompute all register parameters as described by ARGS, storing values    into fields within the ARGS array.     NUM_ACTUALS indicates the total number elements in the ARGS array.     Set REG_PARM_SEEN if we encounter a register parameter.  */
end_comment

begin_function
specifier|static
name|void
name|precompute_register_parameters
parameter_list|(
name|num_actuals
parameter_list|,
name|args
parameter_list|,
name|reg_parm_seen
parameter_list|)
name|int
name|num_actuals
decl_stmt|;
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|int
modifier|*
name|reg_parm_seen
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
operator|*
name|reg_parm_seen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
block|{
operator|*
name|reg_parm_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|value
operator|==
literal|0
condition|)
block|{
name|push_temp_slots
argument_list|()
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|expand_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* ANSI doesn't require a sequence point here, 	       but PCC has one, so this will avoid some problems.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
comment|/* If we are to promote the function arg to a wider mode, 	   do it now.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|convert_modes
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* If the value is expensive, and we are inside an appropriately  	   short loop, put the value into a pseudo and then put the pseudo 	   into the hard reg.  	   For small register classes, also do this if this call uses 	   register parameters.  This is to avoid reload conflicts while 	   loading the parameters registers.  */
if|if
condition|(
operator|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|)
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|!=
name|BLKmode
operator|&&
name|rtx_cost
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|SET
argument_list|)
operator|>
literal|2
operator|&&
operator|(
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
operator|*
name|reg_parm_seen
operator|)
operator|||
name|preserve_subexpressions_p
argument_list|()
operator|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|copy_to_mode_reg
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
end_if

begin_comment
comment|/* The argument list is the property of the called routine and it      may clobber it.  If the fixed area has been used for previous      parameters, we must save and restore it.  */
end_comment

begin_function
specifier|static
name|rtx
name|save_fixed_argument_area
parameter_list|(
name|reg_parm_stack_space
parameter_list|,
name|argblock
parameter_list|,
name|low_to_save
parameter_list|,
name|high_to_save
parameter_list|)
name|int
name|reg_parm_stack_space
decl_stmt|;
name|rtx
name|argblock
decl_stmt|;
name|int
modifier|*
name|low_to_save
decl_stmt|;
name|int
modifier|*
name|high_to_save
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|save_area
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Compute the boundary of the that needs to be saved, if any.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg_parm_stack_space
operator|+
literal|1
condition|;
name|i
operator|++
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg_parm_stack_space
condition|;
name|i
operator|++
control|)
endif|#
directive|endif
block|{
if|if
condition|(
name|i
operator|>=
name|highest_outgoing_arg_in_use
operator|||
name|stack_usage_map
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|*
name|low_to_save
operator|==
operator|-
literal|1
condition|)
operator|*
name|low_to_save
operator|=
name|i
expr_stmt|;
operator|*
name|high_to_save
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|low_to_save
operator|>=
literal|0
condition|)
block|{
name|int
name|num_to_save
init|=
operator|*
name|high_to_save
operator|-
operator|*
name|low_to_save
operator|+
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|num_to_save
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
decl_stmt|;
comment|/* If we don't have the required alignment, must do this in BLKmode.  */
if|if
condition|(
operator|(
operator|*
name|low_to_save
operator|&
operator|(
name|MIN
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|save_mode
argument_list|)
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|UNITS_PER_WORD
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|save_mode
operator|=
name|BLKmode
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
operator|*
name|high_to_save
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|*
name|low_to_save
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|save_mode
operator|==
name|BLKmode
condition|)
block|{
name|save_area
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|num_to_save
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|stack_area
argument_list|,
name|GEN_INT
argument_list|(
name|num_to_save
argument_list|)
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|save_area
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_fixed_argument_area
parameter_list|(
name|save_area
parameter_list|,
name|argblock
parameter_list|,
name|high_to_save
parameter_list|,
name|low_to_save
parameter_list|)
name|rtx
name|save_area
decl_stmt|;
name|rtx
name|argblock
decl_stmt|;
name|int
name|high_to_save
decl_stmt|;
name|int
name|low_to_save
decl_stmt|;
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|save_area
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
name|high_to_save
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|low_to_save
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|save_mode
operator|!=
name|BLKmode
condition|)
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|save_area
argument_list|)
expr_stmt|;
else|else
name|emit_block_move
argument_list|(
name|stack_area
argument_list|,
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high_to_save
operator|-
name|low_to_save
operator|+
literal|1
argument_list|)
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If any elements in ARGS refer to parameters that are to be passed in    registers, but not in memory, and whose alignment does not permit a    direct copy into registers.  Copy the values into a group of pseudos    which we will later copy into the appropriate hard registers.      Pseudos for each unaligned argument will be stored into the array    args[argnum].aligned_regs.  The caller is responsible for deallocating    the aligned_regs array if it is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|store_unaligned_arguments_into_pseudos
parameter_list|(
name|args
parameter_list|,
name|num_actuals
parameter_list|)
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|int
name|num_actuals
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|BLKmode
operator|&&
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|BITS_PER_WORD
argument_list|)
operator|)
condition|)
block|{
name|int
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|big_endian_correction
init|=
literal|0
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
operator|=
name|args
index|[
name|i
index|]
operator|.
name|partial
condition|?
name|args
index|[
name|i
index|]
operator|.
name|partial
else|:
operator|(
name|bytes
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
argument_list|)
expr_stmt|;
comment|/* Structures smaller than a word are aligned to the least 	   significant byte (to the right).  On a BYTES_BIG_ENDIAN machine, 	   this means we must skip the empty high order bytes when 	   calculating the bit offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|bytes
operator|<
name|UNITS_PER_WORD
condition|)
name|big_endian_correction
operator|=
operator|(
name|BITS_PER_WORD
operator|-
operator|(
name|bytes
operator|*
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|rtx
name|word
init|=
name|operand_subword_force
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|j
argument_list|,
name|BLKmode
argument_list|)
decl_stmt|;
name|int
name|bitsize
init|=
name|MIN
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
name|int
name|bitalign
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
index|[
name|j
index|]
operator|=
name|reg
expr_stmt|;
comment|/* There is no need to restrict this code to loading items 	       in TYPE_ALIGN sized hunks.  The bitfield instructions can 	       load up entire word sized registers efficiently.  	       ??? This may not be needed anymore. 	       We use to emit a clobber here but that doesn't let later 	       passes optimize the instructions we emit.  By storing 0 into 	       the register later passes know the first AND to zero out the 	       bitfield being set in the register is unnecessary.  The store 	       of 0 will be deleted as will at least the first AND.  */
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|bitsize
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|store_bit_field
argument_list|(
name|reg
argument_list|,
name|bitsize
argument_list|,
name|big_endian_correction
argument_list|,
name|word_mode
argument_list|,
name|extract_bit_field
argument_list|(
name|word
argument_list|,
name|bitsize
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|,
name|bitalign
operator|/
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|bitalign
operator|/
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Fill in ARGS_SIZE and ARGS array based on the parameters found in    ACTPARMS.      NUM_ACTUALS is the total number of parameters.     N_NAMED_ARGS is the total number of named arguments.     FNDECL is the tree code for the target of this call (if known)     ARGS_SO_FAR holds state needed by the target to know where to place    the next argument.     REG_PARM_STACK_SPACE is the number of bytes of stack space reserved    for arguments which are passed in registers.     OLD_STACK_LEVEL is a pointer to an rtx which olds the old stack level    and may be modified by this routine.     OLD_PENDING_ADJ, MUST_PREALLOCATE and IS_CONST are pointers to integer    flags which may may be modified by this routine.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_argument_information
parameter_list|(
name|num_actuals
parameter_list|,
name|args
parameter_list|,
name|args_size
parameter_list|,
name|n_named_args
parameter_list|,
name|actparms
parameter_list|,
name|fndecl
parameter_list|,
name|args_so_far
parameter_list|,
name|reg_parm_stack_space
parameter_list|,
name|old_stack_level
parameter_list|,
name|old_pending_adj
parameter_list|,
name|must_preallocate
parameter_list|,
name|is_const
parameter_list|)
name|int
name|num_actuals
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|struct
name|args_size
modifier|*
name|args_size
decl_stmt|;
name|int
name|n_named_args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|actparms
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|CUMULATIVE_ARGS
modifier|*
name|args_so_far
decl_stmt|;
name|int
name|reg_parm_stack_space
decl_stmt|;
name|rtx
modifier|*
name|old_stack_level
decl_stmt|;
name|int
modifier|*
name|old_pending_adj
decl_stmt|;
name|int
modifier|*
name|must_preallocate
decl_stmt|;
name|int
modifier|*
name|is_const
decl_stmt|;
block|{
comment|/* 1 if scanning parms front to back, -1 if scanning back to front.  */
name|int
name|inc
decl_stmt|;
comment|/* Count arg position in order args appear.  */
name|int
name|argpos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|p
decl_stmt|;
name|args_size
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
name|args_size
operator|->
name|var
operator|=
literal|0
expr_stmt|;
comment|/* In this loop, we consider args in the order they are written.      We fill up ARGS from the front or from the back if necessary      so that in any case the first arg to be pushed ends up at the front.  */
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
name|i
operator|=
name|num_actuals
operator|-
literal|1
operator|,
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* In this case, must reverse order of args      so that we compute and push the last arg first.  */
else|#
directive|else
name|i
operator|=
literal|0
operator|,
name|inc
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* I counts args in order (to be) pushed; ARGPOS counts in order written.  */
for|for
control|(
name|p
operator|=
name|actparms
operator|,
name|argpos
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|,
name|i
operator|+=
name|inc
operator|,
name|argpos
operator|++
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Replace erroneous argument with constant zero.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|integer_zero_node
operator|,
name|type
operator|=
name|integer_type_node
expr_stmt|;
comment|/* If TYPE is a transparent union, pass things the way we would 	 pass the first field of the union.  We have already verified that 	 the modes are the same.  */
if|if
condition|(
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decide where to pass this arg.  	 args[i].reg is nonzero if all or part is passed in registers.  	 args[i].partial is nonzero if part but not all is passed in registers, 	 and the exact value says how many words are passed in registers.  	 args[i].pass_on_stack is nonzero if the argument must at least be 	 computed on the stack.  It may then be loaded back into registers 	 if args[i].reg is nonzero.  	 These decisions are driven by the FUNCTION_... macros and must agree 	 with those made by function.c.  */
comment|/* See if this argument should be passed by invisible reference.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|contains_placeholder_p
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PASS_BY_REFERENCE
operator|||
name|FUNCTION_ARG_PASS_BY_REFERENCE
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
endif|#
directive|endif
condition|)
block|{
comment|/* If we're compiling a thunk, pass through invisible              references instead of making a copy.  */
if|if
condition|(
name|current_function_is_thunk
ifdef|#
directive|ifdef
name|FUNCTION_ARG_CALLEE_COPIES
operator|||
operator|(
name|FUNCTION_ARG_CALLEE_COPIES
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
comment|/* If it's in a register, we must make a copy of it too.  */
comment|/* ??? Is this a sufficient test?  Is there a better one? */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* C++ uses a TARGET_EXPR to indicate that we want to make a 	         new object from the argument.  If we are passing by 	         invisible reference, the callee will do that for us, so we 	         can strip off the TARGET_EXPR.  This is not always safe, 	         but it is safe in the only case where this is a useful 	         optimization; namely, when the argument is a plain object. 	         In that case, the frontend is just asking the backend to 	         make a bitwise copy of the argument. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|TARGET_EXPR
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|)
operator|&&
operator|!
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|TREE_OPERAND
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We make a copy of the object and pass the address to the 		 function being called.  */
name|rtx
name|copy
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
name|STACK_CHECK_MAX_VAR_SIZE
operator|*
name|BITS_PER_UNIT
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* This is a variable-sized object.  Make space on the stack 		     for it.  */
name|rtx
name|size_rtx
init|=
name|expr_size
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|old_stack_level
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
operator|*
name|old_pending_adj
operator|=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
name|copy
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|allocate_dynamic_stack_space
argument_list|(
name|size_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|copy
operator|=
name|assign_stack_temp
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|copy
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|is_const
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|copy
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_ARGS
name|mode
operator|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
index|[
name|i
index|]
operator|.
name|unsignedp
operator|=
name|unsignedp
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|FUNCTION_ARG
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
condition|)
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|=
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|=
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If FUNCTION_ARG returned a (parallel [(expr_list (nil) ...) ...]), 	 it means that we are to pass this arg in the register(s) designated 	 by the PARALLEL, but also to pass it in the stack.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|=
literal|1
expr_stmt|;
comment|/* If this is an addressable type, we must preallocate the stack 	 since we must evaluate the object into its final location.  	 If this is to be passed in both registers and the stack, it is simpler 	 to preallocate.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|)
condition|)
operator|*
name|must_preallocate
operator|=
literal|1
expr_stmt|;
comment|/* If this is an addressable type, we cannot pre-evaluate it.  Thus, 	 we cannot consider this function call constant.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
operator|*
name|is_const
operator|=
literal|0
expr_stmt|;
comment|/* Compute the stack-size of this argument.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|!=
literal|0
operator|||
name|reg_parm_stack_space
operator|>
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|locate_and_pad_parm
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
literal|1
argument_list|,
else|#
directive|else
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
name|fndecl
argument_list|,
name|args_size
argument_list|,
operator|&
name|args
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
operator|&
name|args
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ARGS_GROW_DOWNWARD
name|args
index|[
name|i
index|]
operator|.
name|slot_offset
operator|=
operator|*
name|args_size
expr_stmt|;
endif|#
directive|endif
comment|/* If a part of the arg was put into registers, 	 don't include that part in the amount pushed.  */
if|if
condition|(
name|reg_parm_stack_space
operator|==
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|constant
operator|-=
operator|(
operator|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|*
name|UNITS_PER_WORD
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* Update ARGS_SIZE, the total stack space for args so far.  */
name|args_size
operator|->
name|constant
operator|+=
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|var
condition|)
block|{
name|ADD_PARM_SIZE
argument_list|(
operator|*
name|args_size
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|var
argument_list|)
expr_stmt|;
block|}
comment|/* Since the slot offset points to the bottom of the slot, 	 we must record it after incrementing if the args grow down.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|args
index|[
name|i
index|]
operator|.
name|slot_offset
operator|=
operator|*
name|args_size
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|slot_offset
operator|.
name|constant
operator|=
operator|-
name|args_size
operator|->
name|constant
expr_stmt|;
if|if
condition|(
name|args_size
operator|->
name|var
condition|)
block|{
name|SUB_PARM_SIZE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|slot_offset
argument_list|,
name|args_size
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Increment ARGS_SO_FAR, which has info about which arg-registers 	 have been used, etc.  */
name|FUNCTION_ARG_ADVANCE
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update ARGS_SIZE to contain the total size for the argument block.    Return the original constant component of the argument block's size.     REG_PARM_STACK_SPACE holds the number of bytes of stack space reserved    for arguments passed in registers.  */
end_comment

begin_function
specifier|static
name|int
name|compute_argument_block_size
parameter_list|(
name|reg_parm_stack_space
parameter_list|,
name|args_size
parameter_list|)
name|int
name|reg_parm_stack_space
decl_stmt|;
name|struct
name|args_size
modifier|*
name|args_size
decl_stmt|;
block|{
name|int
name|unadjusted_args_size
init|=
name|args_size
operator|->
name|constant
decl_stmt|;
comment|/* Compute the actual size of the argument block required.  The variable      and constant sizes must be combined, the size may have to be rounded,      and there may be a minimum required size.  */
if|if
condition|(
name|args_size
operator|->
name|var
condition|)
block|{
name|args_size
operator|->
name|var
operator|=
name|ARGS_SIZE_TREE
argument_list|(
operator|*
name|args_size
argument_list|)
expr_stmt|;
name|args_size
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PREFERRED_STACK_BOUNDARY
if|if
condition|(
name|PREFERRED_STACK_BOUNDARY
operator|!=
name|BITS_PER_UNIT
condition|)
name|args_size
operator|->
name|var
operator|=
name|round_up
argument_list|(
name|args_size
operator|->
name|var
argument_list|,
name|STACK_BYTES
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|reg_parm_stack_space
operator|>
literal|0
condition|)
block|{
name|args_size
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|args_size
operator|->
name|var
argument_list|,
name|size_int
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
comment|/* The area corresponding to register parameters is not to count in 	     the size of the block we need.  So make the adjustment.  */
name|args_size
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|args_size
operator|->
name|var
argument_list|,
name|size_int
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PREFERRED_STACK_BOUNDARY
name|args_size
operator|->
name|constant
operator|=
operator|(
operator|(
operator|(
name|args_size
operator|->
name|constant
operator|+
name|pending_stack_adjust
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|*
name|STACK_BYTES
operator|)
operator|-
name|pending_stack_adjust
operator|)
expr_stmt|;
endif|#
directive|endif
name|args_size
operator|->
name|constant
operator|=
name|MAX
argument_list|(
name|args_size
operator|->
name|constant
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
if|if
condition|(
name|reg_parm_stack_space
operator|==
literal|0
condition|)
name|args_size
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
name|args_size
operator|->
name|constant
operator|-=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|unadjusted_args_size
return|;
block|}
end_function

begin_comment
comment|/* Precompute parameters has needed for a function call.     IS_CONST indicates the target function is a pure function.     MUST_PREALLOCATE indicates that we must preallocate stack space for    any stack arguments.     NUM_ACTUALS is the number of arguments.     ARGS is an array containing information for each argument; this routine    fills in the INITIAL_VALUE and VALUE fields for each precomputed argument.     ARGS_SIZE contains information about the size of the arg list.  */
end_comment

begin_function
specifier|static
name|void
name|precompute_arguments
parameter_list|(
name|is_const
parameter_list|,
name|must_preallocate
parameter_list|,
name|num_actuals
parameter_list|,
name|args
parameter_list|,
name|args_size
parameter_list|)
name|int
name|is_const
decl_stmt|;
name|int
name|must_preallocate
decl_stmt|;
name|int
name|num_actuals
decl_stmt|;
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|struct
name|args_size
modifier|*
name|args_size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* If this function call is cse'able, precompute all the parameters.      Note that if the parameter is constructed into a temporary, this will      cause an additional copy because the parameter will be constructed      into a temporary location and then copied into the outgoing arguments.      If a parameter contains a call to alloca and this function uses the      stack, precompute the parameter.  */
comment|/* If we preallocated the stack space, and some arguments must be passed      on the stack, then we must precompute any parameter which contains a      function call which will store arguments on the stack.      Otherwise, evaluating the parameter may clobber previous parameters      which have already been stored into the stack.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_const
operator|||
operator|(
operator|(
name|args_size
operator|->
name|var
operator|!=
literal|0
operator|||
name|args_size
operator|->
name|constant
operator|!=
literal|0
operator|)
operator|&&
name|calls_function
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|must_preallocate
operator|&&
operator|(
name|args_size
operator|->
name|var
operator|!=
literal|0
operator|||
name|args_size
operator|->
name|constant
operator|!=
literal|0
operator|)
operator|&&
name|calls_function
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* If this is an addressable type, we cannot pre-evaluate it.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|initial_value
operator|=
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|expand_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* ANSI doesn't require a sequence point here, 	   but PCC has one, so this will avoid some problems.  */
name|emit_queue
argument_list|()
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|initial_value
operator|=
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|protect_from_queue
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|initial_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|!=
name|args
index|[
name|i
index|]
operator|.
name|mode
condition|)
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|convert_modes
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|unsignedp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given the current state of MUST_PREALLOCATE and information about    arguments to a function call in NUM_ACTUALS, ARGS and ARGS_SIZE,    compute and return the final value for MUST_PREALLOCATE.  */
end_comment

begin_function
specifier|static
name|int
name|finalize_must_preallocate
parameter_list|(
name|must_preallocate
parameter_list|,
name|num_actuals
parameter_list|,
name|args
parameter_list|,
name|args_size
parameter_list|)
name|int
name|must_preallocate
decl_stmt|;
name|int
name|num_actuals
decl_stmt|;
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|struct
name|args_size
modifier|*
name|args_size
decl_stmt|;
block|{
comment|/* See if we have or want to preallocate stack space.       If we would have to push a partially-in-regs parm      before other stack parms, preallocate stack space instead.       If the size of some parm is not a multiple of the required stack      alignment, we must preallocate.       If the total size of arguments that would otherwise create a copy in      a temporary (such as a CALL) is more than half the total argument list      size, preallocation is faster.       Another reason to preallocate is if we have a machine (like the m88k)      where stack alignment is required to be maintained between every      pair of insns, not just when the call is made.  However, we assume here      that such machines either do not have push insns (and hence preallocation      would occur anyway) or the problem is taken care of with      PUSH_ROUNDING.  */
if|if
condition|(
operator|!
name|must_preallocate
condition|)
block|{
name|int
name|partial_seen
init|=
literal|0
decl_stmt|;
name|int
name|copy_to_evaluate_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
operator|&&
operator|!
name|must_preallocate
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|>
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|partial_seen
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|partial_seen
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
condition|)
name|must_preallocate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|CALL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|TARGET_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|)
condition|)
name|copy_to_evaluate_size
operator|+=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copy_to_evaluate_size
operator|*
literal|2
operator|>=
name|args_size
operator|->
name|constant
operator|&&
name|args_size
operator|->
name|constant
operator|>
literal|0
condition|)
name|must_preallocate
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|must_preallocate
return|;
block|}
end_function

begin_comment
comment|/* If we preallocated stack space, compute the address of each argument    and store it into the ARGS array.     We need not ensure it is a valid memory address here; it will be     validized when it is used.     ARGBLOCK is an rtx for the address of the outgoing arguments.  */
end_comment

begin_function
specifier|static
name|void
name|compute_argument_addresses
parameter_list|(
name|args
parameter_list|,
name|argblock
parameter_list|,
name|num_actuals
parameter_list|)
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|rtx
name|argblock
decl_stmt|;
name|int
name|num_actuals
decl_stmt|;
block|{
if|if
condition|(
name|argblock
condition|)
block|{
name|rtx
name|arg_reg
init|=
name|argblock
decl_stmt|;
name|int
name|i
decl_stmt|,
name|arg_offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|argblock
argument_list|)
operator|==
name|PLUS
condition|)
name|arg_reg
operator|=
name|XEXP
argument_list|(
name|argblock
argument_list|,
literal|0
argument_list|)
operator|,
name|arg_offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|argblock
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|offset
init|=
name|ARGS_SIZE_RTX
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rtx
name|slot_offset
init|=
name|ARGS_SIZE_RTX
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|slot_offset
argument_list|)
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* Skip this parm if it will not be passed on the stack.  */
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|arg_reg
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|arg_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|arg_offset
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|stack
operator|=
name|gen_rtx_MEM
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|slot_offset
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|arg_reg
argument_list|,
name|INTVAL
argument_list|(
name|slot_offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|arg_reg
argument_list|,
name|slot_offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|arg_offset
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
operator|=
name|gen_rtx_MEM
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a FNDECL and EXP, return an rtx suitable for use as a target address    in a call instruction.     FNDECL is the tree node for the target function.  For an indirect call    FNDECL will be NULL_TREE.     EXP is the CALL_EXPR for this call.  */
end_comment

begin_function
specifier|static
name|rtx
name|rtx_for_function_call
parameter_list|(
name|fndecl
parameter_list|,
name|exp
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|tree
name|exp
decl_stmt|;
block|{
name|rtx
name|funexp
decl_stmt|;
comment|/* Get the function to call, in the form of RTL.  */
if|if
condition|(
name|fndecl
condition|)
block|{
comment|/* If this is the first use of the function, see if we need to 	 make an external definition for it.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Get a SYMBOL_REF rtx for the function address.  */
name|funexp
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Generate an rtx (probably a pseudo-register) for the address.  */
block|{
name|rtx
name|funaddr
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|funaddr
operator|=
name|funexp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* FUNEXP can't be BLKmode */
comment|/* Check the function is executable.  */
if|if
condition|(
name|current_function_check_memory_usage
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
comment|/* It might be OK to convert funexp in place, but there's 	     a lot going on between here and when it happens naturally 	     that this seems safer. */
name|funaddr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|chkr_check_exec_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|funaddr
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
block|}
return|return
name|funexp
return|;
block|}
end_function

begin_comment
comment|/* Do the register loads required for any wholly-register parms or any    parms which are passed both on the stack and in a register.  Their    expressions were already evaluated.      Mark all register-parms as living through the call, putting these USE    insns in the CALL_INSN_FUNCTION_USAGE field.  */
end_comment

begin_function
specifier|static
name|void
name|load_register_parameters
parameter_list|(
name|args
parameter_list|,
name|num_actuals
parameter_list|,
name|call_fusage
parameter_list|)
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|int
name|num_actuals
decl_stmt|;
name|rtx
modifier|*
name|call_fusage
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|LOAD_ARGS_REVERSED
for|for
control|(
name|i
operator|=
name|num_actuals
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
endif|#
directive|endif
block|{
name|rtx
name|reg
init|=
name|args
index|[
name|i
index|]
operator|.
name|reg
decl_stmt|;
name|int
name|partial
init|=
name|args
index|[
name|i
index|]
operator|.
name|partial
decl_stmt|;
name|int
name|nregs
decl_stmt|;
if|if
condition|(
name|reg
condition|)
block|{
comment|/* Set to non-negative if must move a word at a time, even if just 	     one word (e.g, partial == 1&& mode == DFmode).  Set to -1 if 	     we just use a normal move insn.  This value can be zero if the 	     argument is a zero size structure with no fields.  */
name|nregs
operator|=
operator|(
name|partial
condition|?
name|partial
else|:
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|?
operator|(
operator|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
else|:
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Handle calls that pass values in multiple non-contiguous 	     locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|emit_group_load
argument_list|(
name|reg
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* If simple case, just do move.  If normal partial, store_one_arg 	     has already loaded the register for us.  In all other cases, 	     load the register(s) from memory.  */
elseif|else
if|if
condition|(
name|nregs
operator|==
operator|-
literal|1
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
comment|/* If we have pre-computed the values to put in the registers in 	     the case of non-aligned structures, copy them in now.  */
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
operator|!=
literal|0
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
condition|;
name|j
operator|++
control|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|j
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|partial
operator|==
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|move_block_to_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|nregs
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
comment|/* Handle calls that pass values in multiple non-contiguous 	     locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|use_group_regs
argument_list|(
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nregs
operator|==
operator|-
literal|1
condition|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
else|else
name|use_regs
argument_list|(
name|call_fusage
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|nregs
operator|==
literal|0
condition|?
literal|1
else|:
name|nregs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate all the code for a function call    and return an rtx for its value.    Store the value in TARGET (specified as an rtx) if convenient.    If the value is stored in TARGET then TARGET is returned.    If IGNORE is nonzero, then we ignore the value of the function call.  */
end_comment

begin_function
name|rtx
name|expand_call
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|ignore
decl_stmt|;
block|{
comment|/* List of actual parameters.  */
name|tree
name|actparms
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* RTX for the function to be called.  */
name|rtx
name|funexp
decl_stmt|;
comment|/* Data type of the function.  */
name|tree
name|funtype
decl_stmt|;
comment|/* Declaration of the function being called,      or 0 if the function is computed (not known by name).  */
name|tree
name|fndecl
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
comment|/* Register in which non-BLKmode value will be returned,      or 0 if no value or if value is BLKmode.  */
name|rtx
name|valreg
decl_stmt|;
comment|/* Address where we should return a BLKmode value;      0 if value not BLKmode.  */
name|rtx
name|structure_value_addr
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if that address is being passed by treating it as      an extra, implicit first parameter.  Otherwise,      it is passed by being copied directly into struct_value_rtx.  */
name|int
name|structure_value_addr_parm
init|=
literal|0
decl_stmt|;
comment|/* Size of aggregate value wanted, or zero if none wanted      or if we are using the non-reentrant PCC calling convention      or expecting the value in registers.  */
name|HOST_WIDE_INT
name|struct_value_size
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if called function returns an aggregate in memory PCC style,      by returning the address of where to find it.  */
name|int
name|pcc_struct_value
init|=
literal|0
decl_stmt|;
comment|/* Number of actual parameters in this call, including struct value addr.  */
name|int
name|num_actuals
decl_stmt|;
comment|/* Number of named args.  Args after this are anonymous ones      and they must all go on the stack.  */
name|int
name|n_named_args
decl_stmt|;
comment|/* Vector of information about each argument.      Arguments are numbered in the order they will be pushed,      not the order they are written.  */
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
comment|/* Total size in bytes of all the stack-parms scanned so far.  */
name|struct
name|args_size
name|args_size
decl_stmt|;
comment|/* Size of arguments before any adjustments (such as rounding).  */
name|int
name|unadjusted_args_size
decl_stmt|;
comment|/* Data on reg parms scanned so far.  */
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
comment|/* Nonzero if a reg parm has been scanned.  */
name|int
name|reg_parm_seen
decl_stmt|;
comment|/* Nonzero if this is an indirect function call.  */
comment|/* Nonzero if we must avoid push-insns in the args for this call.       If stack space is allocated for register parameters, but not by the      caller, then it is preallocated in the fixed part of the stack frame.      So the entire argument block must then be preallocated (i.e., we      ignore PUSH_ROUNDING in that case).  */
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|int
name|must_preallocate
init|=
literal|0
decl_stmt|;
else|#
directive|else
name|int
name|must_preallocate
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
comment|/* Size of the stack reserved for parameter registers.  */
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
comment|/* Address of space preallocated for stack parms      (on machines that lack push insns), or 0 if space not preallocated.  */
name|rtx
name|argblock
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if it is plausible that this is a call to alloca.  */
name|int
name|may_be_alloca
decl_stmt|;
comment|/* Nonzero if this is a call to malloc or a related function. */
name|int
name|is_malloc
decl_stmt|;
comment|/* Nonzero if this is a call to setjmp or a related function.  */
name|int
name|returns_twice
decl_stmt|;
comment|/* Nonzero if this is a call to `longjmp'.  */
name|int
name|is_longjmp
decl_stmt|;
comment|/* Nonzero if this is a call to an inline function.  */
name|int
name|is_integrable
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a call to a `const' function.      Note that only explicitly named functions are handled as `const' here.  */
name|int
name|is_const
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a call to a `volatile' function.  */
name|int
name|is_volatile
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
comment|/* Define the boundary of the register parm stack space that needs to be      save, if any.  */
name|int
name|low_to_save
init|=
operator|-
literal|1
decl_stmt|,
name|high_to_save
decl_stmt|;
name|rtx
name|save_area
init|=
literal|0
decl_stmt|;
comment|/* Place that it is saved */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
name|int
name|initial_highest_arg_in_use
init|=
name|highest_outgoing_arg_in_use
decl_stmt|;
name|char
modifier|*
name|initial_stack_usage_map
init|=
name|stack_usage_map
decl_stmt|;
name|int
name|old_stack_arg_under_construction
decl_stmt|;
endif|#
directive|endif
name|rtx
name|old_stack_level
init|=
literal|0
decl_stmt|;
name|int
name|old_pending_adj
init|=
literal|0
decl_stmt|;
name|int
name|old_inhibit_defer_pop
init|=
name|inhibit_defer_pop
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* The value of the function call can be put in a hard register.  But      if -fcheck-memory-usage, code which invokes functions (and thus      damages some hard registers) can be inserted before using the value.      So, target is always a pseudo-register in that case.  */
if|if
condition|(
name|current_function_check_memory_usage
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* See if we can find a DECL-node for the actual function.      As a result, decide whether this is a call to an integrable function.  */
name|p
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|fndecl
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|flag_no_inline
operator|&&
name|fndecl
operator|!=
name|current_function_decl
operator|&&
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|RTX_INTEGRATED_P
argument_list|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|is_integrable
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* In case this function later becomes inlinable, 		 record that there was already a non-inline call to it.  		 Use abstraction instead of setting TREE_ADDRESSABLE 		 directly.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|warn_inline
operator|&&
operator|!
name|flag_no_inline
operator|&&
name|optimize
operator|>
literal|0
condition|)
block|{
name|warning_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"can't inline call to `%s'"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"called from here"
argument_list|)
expr_stmt|;
block|}
name|mark_addressable
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|is_const
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|fndecl
argument_list|)
condition|)
name|is_volatile
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If we don't have specific function to call, see if we have a       constant or `noreturn' function from the type.  */
if|if
condition|(
name|fndecl
operator|==
literal|0
condition|)
block|{
name|is_const
operator|=
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|is_volatile
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|MAYBE_REG_PARM_STACK_SPACE
expr_stmt|;
else|#
directive|else
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PUSH_ROUNDING
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OUTGOING_REG_PARM_STACK_SPACE
argument_list|)
if|if
condition|(
name|reg_parm_stack_space
operator|>
literal|0
condition|)
name|must_preallocate
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Warn if this value is an aggregate type,      regardless of which calling convention we are using for it.  */
if|if
condition|(
name|warn_aggregate_return
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function call has aggregate value"
argument_list|)
expr_stmt|;
comment|/* Set up a place to return a structure.  */
comment|/* Cater to broken compilers.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|exp
argument_list|)
condition|)
block|{
comment|/* This call returns a big structure.  */
name|is_const
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
block|{
name|pcc_struct_value
operator|=
literal|1
expr_stmt|;
comment|/* Easier than making that case work right.  */
if|if
condition|(
name|is_integrable
condition|)
block|{
comment|/* In case this is a static function, note that it has been 	       used.  */
if|if
condition|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|fndecl
argument_list|)
condition|)
name|mark_addressable
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|is_integrable
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* not PCC_STATIC_STRUCT_RETURN */
block|{
name|struct_value_size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|structure_value_addr
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Assign a temporary to hold the value.  */
name|tree
name|d
decl_stmt|;
comment|/* For variable-sized objects, we must be called with a target 	       specified.  If we were to allocate space on the stack here, 	       we would have no way of knowing when to free it.  */
if|if
condition|(
name|struct_value_size
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This DECL is just something to feed to mark_addressable; 	       it doesn't get pushed.  */
name|d
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|d
argument_list|)
operator|=
name|assign_temp
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_addressable
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|structure_value_addr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|d
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|target
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not PCC_STATIC_STRUCT_RETURN */
block|}
comment|/* If called function is inline, try to integrate it.  */
if|if
condition|(
name|is_integrable
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
name|rtx
name|before_call
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|temp
operator|=
name|expand_inline_function
argument_list|(
name|fndecl
argument_list|,
name|actparms
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|structure_value_addr
argument_list|)
expr_stmt|;
comment|/* If inlining succeeded, return.  */
if|if
condition|(
name|temp
operator|!=
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* If the outgoing argument list must be preserved, push 	     the stack before executing the inlined function if it 	     makes any calls.  */
for|for
control|(
name|i
operator|=
name|reg_parm_stack_space
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|i
operator|<
name|highest_outgoing_arg_in_use
operator|&&
name|stack_usage_map
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|stack_arg_under_construction
operator|||
name|i
operator|>=
literal|0
condition|)
block|{
name|rtx
name|first_insn
init|=
name|before_call
condition|?
name|NEXT_INSN
argument_list|(
name|before_call
argument_list|)
else|:
name|get_insns
argument_list|()
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|seq
decl_stmt|;
comment|/* Look for a call in the inline function code. 		 If OUTGOING_ARGS_SIZE (DECL_SAVED_INSNS (fndecl)) is 		 nonzero then there is a call and it is not necessary 		 to scan the insns.  */
if|if
condition|(
name|OUTGOING_ARGS_SIZE
argument_list|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
for|for
control|(
name|insn
operator|=
name|first_insn
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
if|if
condition|(
name|insn
condition|)
block|{
comment|/* Reserve enough stack space so that the largest 		     argument list of any function call in the inline 		     function does not overlap the argument list being 		     evaluated.  This is usually an overestimate because 		     allocate_dynamic_stack_space reserves space for an 		     outgoing argument list in addition to the requested 		     space, but there is no way to ask for stack space such 		     that an argument list of a certain length can be 		     safely constructed.   		     Add the stack space reserved for register arguments, if 		     any, in the inline function.  What is really needed is the 		     largest value of reg_parm_stack_space in the inline 		     function, but that is not available.  Using the current 		     value of reg_parm_stack_space is wrong, but gives 		     correct results on all supported machines.  */
name|int
name|adjust
init|=
operator|(
name|OUTGOING_ARGS_SIZE
argument_list|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|+
name|reg_parm_stack_space
operator|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|allocate_dynamic_stack_space
argument_list|(
name|GEN_INT
argument_list|(
name|adjust
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|first_insn
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* If the result is equivalent to TARGET, return TARGET to simplify 	     checks in store_expr.  They can be equivalent but not equal in the 	     case of a function that returns BLKmode.  */
if|if
condition|(
name|temp
operator|!=
name|target
operator|&&
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
condition|)
return|return
name|target
return|;
return|return
name|temp
return|;
block|}
comment|/* If inlining failed, mark FNDECL as needing to be compiled 	 separately after all.  If function was declared inline, 	 give a warning.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|warn_inline
operator|&&
operator|!
name|flag_no_inline
operator|&&
name|optimize
operator|>
literal|0
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"inlining failed in call to `%s'"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"called from here"
argument_list|)
expr_stmt|;
block|}
name|mark_addressable
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
name|function_call_count
operator|++
expr_stmt|;
if|if
condition|(
name|fndecl
operator|&&
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if this is a call to a function that can return more than once      or a call to longjmp or malloc.  */
name|special_function_p
argument_list|(
name|name
argument_list|,
name|fndecl
argument_list|,
operator|&
name|returns_twice
argument_list|,
operator|&
name|is_longjmp
argument_list|,
operator|&
name|is_malloc
argument_list|,
operator|&
name|may_be_alloca
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_be_alloca
condition|)
name|current_function_calls_alloca
operator|=
literal|1
expr_stmt|;
comment|/* Operand 0 is a pointer-to-function; get the type of the function.  */
name|funtype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|funtype
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|funtype
operator|=
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
expr_stmt|;
comment|/* When calling a const function, we must pop the stack args right away,      so that the pop is deleted or moved with the call.  */
if|if
condition|(
name|is_const
condition|)
name|NO_DEFER_POP
expr_stmt|;
comment|/* Don't let pending stack adjusts add up to too much.      Also, do all pending adjustments now      if there is any chance this might be a call to alloca.  */
if|if
condition|(
name|pending_stack_adjust
operator|>=
literal|32
operator|||
operator|(
name|pending_stack_adjust
operator|>
literal|0
operator|&&
name|may_be_alloca
operator|)
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Push the temporary stack slot level so that we can free any temporaries      we make.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
comment|/* Start updating where the next arg would go.       On some machines (such as the PA) indirect calls have a different      calling convention than normal calls.  The last argument in      INIT_CUMULATIVE_ARGS tells the backend if this is an indirect call      or not.  */
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|funtype
argument_list|,
name|NULL_RTX
argument_list|,
operator|(
name|fndecl
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* If struct_value_rtx is 0, it means pass the address      as if it were an extra parameter.  */
if|if
condition|(
name|structure_value_addr
operator|&&
name|struct_value_rtx
operator|==
literal|0
condition|)
block|{
comment|/* If structure_value_addr is a REG other than 	 virtual_outgoing_args_rtx, we can use always use it.  If it 	 is not a REG, we must always copy it into a register. 	 If it is virtual_outgoing_args_rtx, we must copy it to another 	 register in some cases.  */
name|rtx
name|temp
init|=
operator|(
name|GET_CODE
argument_list|(
name|structure_value_addr
argument_list|)
operator|!=
name|REG
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
operator|||
operator|(
name|stack_arg_under_construction
operator|&&
name|structure_value_addr
operator|==
name|virtual_outgoing_args_rtx
operator|)
endif|#
directive|endif
condition|?
name|copy_addr_to_reg
argument_list|(
name|structure_value_addr
argument_list|)
else|:
name|structure_value_addr
operator|)
decl_stmt|;
name|actparms
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|make_tree
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|)
argument_list|,
name|actparms
argument_list|)
expr_stmt|;
name|structure_value_addr_parm
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Count the arguments and set NUM_ACTUALS.  */
for|for
control|(
name|p
operator|=
name|actparms
operator|,
name|i
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|i
operator|++
expr_stmt|;
name|num_actuals
operator|=
name|i
expr_stmt|;
comment|/* Compute number of named args.      Normally, don't include the last named arg if anonymous args follow.      We do include the last named arg if STRICT_ARGUMENT_NAMING is nonzero.      (If no anonymous args follow, the result of list_length is actually      one too large.  This is harmless.)       If PRETEND_OUTGOING_VARARGS_NAMED is set and STRICT_ARGUMENT_NAMING is      zero, this machine will be able to place unnamed args that were passed in      registers into the stack.  So treat all args as named.  This allows the      insns emitting for a specific argument list to be independent of the      function declaration.       If PRETEND_OUTGOING_VARARGS_NAMED is not set, we do not have any reliable      way to pass unnamed args in registers, so we must force them into      memory.  */
if|if
condition|(
operator|(
name|STRICT_ARGUMENT_NAMING
operator|||
operator|!
name|PRETEND_OUTGOING_VARARGS_NAMED
operator|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
operator|!=
literal|0
condition|)
name|n_named_args
operator|=
operator|(
name|list_length
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
argument_list|)
comment|/* Don't include the last named arg.  */
operator|-
operator|(
name|STRICT_ARGUMENT_NAMING
condition|?
literal|0
else|:
literal|1
operator|)
comment|/* Count the struct value address, if it is passed as a parm.  */
operator|+
name|structure_value_addr_parm
operator|)
expr_stmt|;
else|else
comment|/* If we know nothing, treat all args as named.  */
name|n_named_args
operator|=
name|num_actuals
expr_stmt|;
comment|/* Make a vector to hold all the information about each arg.  */
name|args
operator|=
operator|(
expr|struct
name|arg_data
operator|*
operator|)
name|alloca
argument_list|(
name|num_actuals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg_data
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|args
argument_list|,
name|num_actuals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build up entries inthe ARGS array, compute the size of the arguments      into ARGS_SIZE, etc.  */
name|initialize_argument_information
argument_list|(
name|num_actuals
argument_list|,
name|args
argument_list|,
operator|&
name|args_size
argument_list|,
name|n_named_args
argument_list|,
name|actparms
argument_list|,
name|fndecl
argument_list|,
operator|&
name|args_so_far
argument_list|,
name|reg_parm_stack_space
argument_list|,
operator|&
name|old_stack_level
argument_list|,
operator|&
name|old_pending_adj
argument_list|,
operator|&
name|must_preallocate
argument_list|,
operator|&
name|is_const
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FINAL_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|FINAL_REG_PARM_STACK_SPACE
argument_list|(
name|args_size
operator|.
name|constant
argument_list|,
name|args_size
operator|.
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args_size
operator|.
name|var
condition|)
block|{
comment|/* If this function requires a variable-sized argument list, don't try to 	 make a cse'able block for this call.  We may be able to do this 	 eventually, but it is too complicated to keep track of what insns go 	 in the cse'able block and which don't.  */
name|is_const
operator|=
literal|0
expr_stmt|;
name|must_preallocate
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Compute the actual size of the argument block required.  The variable      and constant sizes must be combined, the size may have to be rounded,      and there may be a minimum required size.  */
name|unadjusted_args_size
operator|=
name|compute_argument_block_size
argument_list|(
name|reg_parm_stack_space
argument_list|,
operator|&
name|args_size
argument_list|)
expr_stmt|;
comment|/* Now make final decision about preallocating stack space.  */
name|must_preallocate
operator|=
name|finalize_must_preallocate
argument_list|(
name|must_preallocate
argument_list|,
name|num_actuals
argument_list|,
name|args
argument_list|,
operator|&
name|args_size
argument_list|)
expr_stmt|;
comment|/* If the structure value address will reference the stack pointer, we must      stabilize it.  We don't need to do this if we know that we are not going      to adjust the stack pointer in processing this call.  */
if|if
condition|(
name|structure_value_addr
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|structure_value_addr
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|structure_value_addr
argument_list|)
operator|)
operator|&&
operator|(
name|args_size
operator|.
name|var
ifndef|#
directive|ifndef
name|ACCUMULATE_OUTGOING_ARGS
operator|||
name|args_size
operator|.
name|constant
endif|#
directive|endif
operator|)
condition|)
name|structure_value_addr
operator|=
name|copy_to_reg
argument_list|(
name|structure_value_addr
argument_list|)
expr_stmt|;
comment|/* Precompute any arguments as needed.  */
name|precompute_arguments
argument_list|(
name|is_const
argument_list|,
name|must_preallocate
argument_list|,
name|num_actuals
argument_list|,
name|args
argument_list|,
operator|&
name|args_size
argument_list|)
expr_stmt|;
comment|/* Now we are about to start emitting insns that can be deleted      if a libcall is deleted.  */
if|if
condition|(
name|is_const
operator|||
name|is_malloc
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* If we have no actual push instructions, or shouldn't use them,      make space for all args right now.  */
if|if
condition|(
name|args_size
operator|.
name|var
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|old_stack_level
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|old_pending_adj
operator|=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* stack_arg_under_construction says whether a stack arg is 	     being constructed at the old stack level.  Pushing the stack 	     gets a clean outgoing argument block.  */
name|old_stack_arg_under_construction
operator|=
name|stack_arg_under_construction
expr_stmt|;
name|stack_arg_under_construction
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|argblock
operator|=
name|push_block
argument_list|(
name|ARGS_SIZE_RTX
argument_list|(
name|args_size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Note that we must go through the motions of allocating an argument 	 block even if the size is zero because we may be storing args 	 in the area reserved for register arguments, which may be part of 	 the stack frame.  */
name|int
name|needed
init|=
name|args_size
operator|.
name|constant
decl_stmt|;
comment|/* Store the maximum argument space used.  It will be pushed by 	 the prologue (if ACCUMULATE_OUTGOING_ARGS, or stack overflow 	 checking).  */
if|if
condition|(
name|needed
operator|>
name|current_function_outgoing_args_size
condition|)
name|current_function_outgoing_args_size
operator|=
name|needed
expr_stmt|;
if|if
condition|(
name|must_preallocate
condition|)
block|{
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* Since the stack pointer will never be pushed, it is possible for 	     the evaluation of a parm to clobber something we have already 	     written to the stack.  Since most function calls on RISC machines 	     do not use the stack, this is uncommon, but must work correctly.  	     Therefore, we save any area of the stack that was already written 	     and that we are using.  Here we set up to do this by making a new 	     stack usage map from the old one.  The actual save will be done 	     by store_one_arg.   	     Another approach might be to try to reorder the argument 	     evaluations to avoid this conflicting stack usage.  */
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
comment|/* Since we will be writing into the entire argument area, the 	     map must be allocated for its entire size, not just the part that 	     is the responsibility of the caller.  */
name|needed
operator|+=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stack_usage_map
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
condition|)
name|bcopy
argument_list|(
name|initial_stack_usage_map
argument_list|,
name|stack_usage_map
argument_list|,
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
operator|!=
name|highest_outgoing_arg_in_use
condition|)
name|bzero
argument_list|(
operator|&
name|stack_usage_map
index|[
name|initial_highest_arg_in_use
index|]
argument_list|,
name|highest_outgoing_arg_in_use
operator|-
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
comment|/* The address of the outgoing argument list must not be copied to a 	     register here, because argblock would be left pointing to the 	     wrong place after the call to allocate_dynamic_stack_space below. 	     */
name|argblock
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
else|#
directive|else
comment|/* not ACCUMULATE_OUTGOING_ARGS */
if|if
condition|(
name|inhibit_defer_pop
operator|==
literal|0
condition|)
block|{
comment|/* Try to reuse some or all of the pending_stack_adjust 		 to get this space.  Maybe we can avoid any pushing.  */
if|if
condition|(
name|needed
operator|>
name|pending_stack_adjust
condition|)
block|{
name|needed
operator|-=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pending_stack_adjust
operator|-=
name|needed
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Special case this because overhead of `push_block' in this 	     case is non-trivial.  */
if|if
condition|(
name|needed
operator|==
literal|0
condition|)
name|argblock
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
else|else
name|argblock
operator|=
name|push_block
argument_list|(
name|GEN_INT
argument_list|(
name|needed
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We only really need to call `copy_to_reg' in the case where push 	     insns are going to be used to pass ARGBLOCK to a function 	     call in ARGS.  In that case, the stack pointer changes value 	     from the allocation point to the call point, and hence 	     the value of VIRTUAL_OUTGOING_ARGS_RTX changes as well. 	     But might as well always do it.  */
name|argblock
operator|=
name|copy_to_reg
argument_list|(
name|argblock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not ACCUMULATE_OUTGOING_ARGS */
block|}
block|}
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* The save/restore code in store_one_arg handles all cases except one:      a constructor call (including a C function returning a BLKmode struct)      to initialize an argument.  */
if|if
condition|(
name|stack_arg_under_construction
condition|)
block|{
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
name|rtx
name|push_size
init|=
name|GEN_INT
argument_list|(
name|reg_parm_stack_space
operator|+
name|args_size
operator|.
name|constant
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|push_size
init|=
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|old_stack_level
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|old_pending_adj
operator|=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
comment|/* stack_arg_under_construction says whether a stack arg is 	     being constructed at the old stack level.  Pushing the stack 	     gets a clean outgoing argument block.  */
name|old_stack_arg_under_construction
operator|=
name|stack_arg_under_construction
expr_stmt|;
name|stack_arg_under_construction
operator|=
literal|0
expr_stmt|;
comment|/* Make a new map for the new argument list.  */
name|stack_usage_map
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|stack_usage_map
argument_list|,
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
name|highest_outgoing_arg_in_use
operator|=
literal|0
expr_stmt|;
block|}
name|allocate_dynamic_stack_space
argument_list|(
name|push_size
argument_list|,
name|NULL_RTX
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
comment|/* If argument evaluation might modify the stack pointer, copy the      address of the argument list to a register.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
block|{
name|argblock
operator|=
name|copy_addr_to_reg
argument_list|(
name|argblock
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|compute_argument_addresses
argument_list|(
name|args
argument_list|,
name|argblock
argument_list|,
name|num_actuals
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
ifdef|#
directive|ifdef
name|PREFERRED_STACK_BOUNDARY
comment|/* If we push args individually in reverse order, perform stack alignment      before the first push (the last arg).  */
if|if
condition|(
name|argblock
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
operator|-
name|unadjusted_args_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Don't try to defer pops if preallocating, not even from the first arg,      since ARGBLOCK probably refers to the SP.  */
if|if
condition|(
name|argblock
condition|)
name|NO_DEFER_POP
expr_stmt|;
name|funexp
operator|=
name|rtx_for_function_call
argument_list|(
name|fndecl
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* Figure out the register where the value, if any, will come back.  */
name|valreg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|structure_value_addr
condition|)
block|{
if|if
condition|(
name|pcc_struct_value
condition|)
name|valreg
operator|=
name|hard_function_value
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|valreg
operator|=
name|hard_function_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
comment|/* Precompute all register parameters.  It isn't safe to compute anything      once we have started filling any specific hard regs.  */
name|precompute_register_parameters
argument_list|(
name|num_actuals
argument_list|,
name|args
argument_list|,
operator|&
name|reg_parm_seen
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
comment|/* Save the fixed argument area if it's part of the caller's frame and      is clobbered by argument setup for this call.  */
name|save_area
operator|=
name|save_fixed_argument_area
argument_list|(
name|reg_parm_stack_space
argument_list|,
name|argblock
argument_list|,
operator|&
name|low_to_save
argument_list|,
operator|&
name|high_to_save
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now store (and compute if necessary) all non-register parms.      These come before register parms, since they can require block-moves,      which could clobber the registers used for register parms.      Parms which have partial registers are not stored here,      but we do preallocate space here if they want that.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|store_one_arg
argument_list|(
operator|&
name|args
index|[
name|i
index|]
argument_list|,
name|argblock
argument_list|,
name|may_be_alloca
argument_list|,
name|args_size
operator|.
name|var
operator|!=
literal|0
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
comment|/* If we have a parm that is passed in registers but not in memory      and whose alignment does not permit a direct copy into registers,      make a group of pseudos that correspond to each register that we      will later fill.  */
if|if
condition|(
name|STRICT_ALIGNMENT
condition|)
name|store_unaligned_arguments_into_pseudos
argument_list|(
name|args
argument_list|,
name|num_actuals
argument_list|)
expr_stmt|;
comment|/* Now store any partially-in-registers parm.      This is the last place a block-move can happen.  */
if|if
condition|(
name|reg_parm_seen
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|!=
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|store_one_arg
argument_list|(
operator|&
name|args
index|[
name|i
index|]
argument_list|,
name|argblock
argument_list|,
name|may_be_alloca
argument_list|,
name|args_size
operator|.
name|var
operator|!=
literal|0
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
ifdef|#
directive|ifdef
name|PREFERRED_STACK_BOUNDARY
comment|/* If we pushed args in forward order, perform stack alignment      after pushing the last arg.  */
if|if
condition|(
name|argblock
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
operator|-
name|unadjusted_args_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* If register arguments require space on the stack and stack space      was not preallocated, allocate stack space here for arguments      passed in registers.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|OUTGOING_REG_PARM_STACK_SPACE
argument_list|)
if|if
condition|(
name|must_preallocate
operator|==
literal|0
operator|&&
name|reg_parm_stack_space
operator|>
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Pass the function the address in which to return a structure value.  */
if|if
condition|(
name|structure_value_addr
operator|&&
operator|!
name|structure_value_addr_parm
condition|)
block|{
name|emit_move_insn
argument_list|(
name|struct_value_rtx
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|structure_value_addr
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the memory for the aggregate as write-only.  */
if|if
condition|(
name|current_function_check_memory_usage
condition|)
name|emit_library_call
argument_list|(
name|chkr_set_right_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|structure_value_addr
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|struct_value_size
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_WO
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|struct_value_rtx
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|struct_value_rtx
argument_list|)
expr_stmt|;
block|}
name|funexp
operator|=
name|prepare_call_address
argument_list|(
name|funexp
argument_list|,
name|fndecl
argument_list|,
operator|&
name|call_fusage
argument_list|,
name|reg_parm_seen
argument_list|)
expr_stmt|;
name|load_register_parameters
argument_list|(
name|args
argument_list|,
name|num_actuals
argument_list|,
operator|&
name|call_fusage
argument_list|)
expr_stmt|;
comment|/* Perform postincrements before actually calling the function.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* All arguments and registers used for the call must be set up by now!  */
comment|/* Generate the actual call instruction.  */
name|emit_call_1
argument_list|(
name|funexp
argument_list|,
name|fndecl
argument_list|,
name|funtype
argument_list|,
name|unadjusted_args_size
argument_list|,
name|args_size
operator|.
name|constant
argument_list|,
name|struct_value_size
argument_list|,
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|valreg
argument_list|,
name|old_inhibit_defer_pop
argument_list|,
name|call_fusage
argument_list|,
name|is_const
argument_list|)
expr_stmt|;
comment|/* If call is cse'able, make appropriate pair of reg-notes around it.      Test valreg so we don't crash; may safely ignore `const'      if return type is void.  Disable for PARALLEL return values, because      we have no way to move such values into a pseudo register.  */
if|if
condition|(
name|is_const
operator|&&
name|valreg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|valreg
argument_list|)
operator|!=
name|PARALLEL
condition|)
block|{
name|rtx
name|note
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
comment|/* Mark the return value as a pointer if needed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|pointed_to
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|mark_reg_pointer
argument_list|(
name|temp
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|pointed_to
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
comment|/* Construct an "equal form" for the value which mentions all the 	 arguments in order as well as the function name.  */
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|initial_value
argument_list|,
name|note
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
name|num_actuals
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|initial_value
argument_list|,
name|note
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|funexp
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|temp
argument_list|,
name|valreg
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|valreg
operator|=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_const
condition|)
block|{
comment|/* Otherwise, just write out the sequence without a note.  */
name|rtx
name|insns
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_malloc
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|last
decl_stmt|,
name|insns
decl_stmt|;
comment|/* The return value from a malloc-like function is a pointer. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|mark_reg_pointer
argument_list|(
name|temp
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
comment|/* The return value from a malloc-like function can not alias 	 anything else.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOALIAS
argument_list|,
name|temp
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out the sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|valreg
operator|=
name|temp
expr_stmt|;
block|}
comment|/* For calls to `setjmp', etc., inform flow.c it should complain      if nonvolatile values are live.  */
if|if
condition|(
name|returns_twice
condition|)
block|{
name|emit_note
argument_list|(
name|name
argument_list|,
name|NOTE_INSN_SETJMP
argument_list|)
expr_stmt|;
name|current_function_calls_setjmp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|is_longjmp
condition|)
name|current_function_calls_longjmp
operator|=
literal|1
expr_stmt|;
comment|/* Notice functions that cannot return.      If optimizing, insns emitted below will be dead.      If not optimizing, they will exist, which is useful      if the user uses the `return' command in the debugger.  */
if|if
condition|(
name|is_volatile
operator|||
name|is_longjmp
condition|)
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* If value type not void, return an rtx for the value.  */
comment|/* If there are cleanups to be called, don't use a hard reg as target.      We need to double check this and see if it matters anymore.  */
if|if
condition|(
name|any_pending_cleanups
argument_list|(
literal|1
argument_list|)
operator|&&
name|target
operator|&&
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|VOIDmode
operator|||
name|ignore
condition|)
block|{
name|target
operator|=
name|const0_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|structure_value_addr
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
condition|)
block|{
name|target
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|memory_address
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|structure_value_addr
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|target
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pcc_struct_value
condition|)
block|{
comment|/* This is the special C++ case where we need to 	 know what the true target was.  We take care to 	 never use this value more than once in one expression.  */
name|target
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|target
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Handle calls that return values in multiple non-contiguous locations.      The Irix 6 ABI has examples of this.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|valreg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
name|target
operator|=
name|assign_stack_temp
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|target
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
name|emit_group_store
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|,
name|bytes
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
condition|)
comment|/* TARGET and VALREG cannot be equal at this point because the latter        would not have REG_FUNCTION_VALUE_P true, while the former would if        it were referring to the same register.         If they refer to the same register, this move will be a no-op, except        when function inlining is being done.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
name|target
operator|=
name|copy_blkmode_from_reg
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_RETURN
comment|/* If we promoted this return value, make the proper SUBREG.  TARGET      might be const0_rtx here, so be careful.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* If we don't promote as expected, something is wrong.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|target
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If size of args is variable or this was a constructor call for a stack      argument, restore saved stack-pointer value.  */
if|if
condition|(
name|old_stack_level
condition|)
block|{
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|pending_stack_adjust
operator|=
name|old_pending_adj
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
name|stack_arg_under_construction
operator|=
name|old_stack_arg_under_construction
expr_stmt|;
name|highest_outgoing_arg_in_use
operator|=
name|initial_highest_arg_in_use
expr_stmt|;
name|stack_usage_map
operator|=
name|initial_stack_usage_map
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
else|else
block|{
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
if|if
condition|(
name|save_area
condition|)
name|restore_fixed_argument_area
argument_list|(
name|save_area
argument_list|,
name|argblock
argument_list|,
name|high_to_save
argument_list|,
name|low_to_save
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we saved any argument areas, restore them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|save_area
condition|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|save_area
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|XEXP
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|save_mode
operator|!=
name|BLKmode
condition|)
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|save_area
argument_list|)
expr_stmt|;
else|else
name|emit_block_move
argument_list|(
name|stack_area
argument_list|,
name|validize_mem
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|save_area
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|constant
argument_list|)
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
name|highest_outgoing_arg_in_use
operator|=
name|initial_highest_arg_in_use
expr_stmt|;
name|stack_usage_map
operator|=
name|initial_stack_usage_map
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If this was alloca, record the new stack level for nonlocal gotos.        Check for the handler slots since we might not have a save area      for non-local gotos.  */
if|if
condition|(
name|may_be_alloca
operator|&&
name|nonlocal_goto_handler_slots
operator|!=
literal|0
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|nonlocal_goto_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* Free up storage we no longer need.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a library call to function FUN (a SYMBOL_REF rtx)    (emitting the queue unless NO_QUEUE is nonzero),    for a value of mode OUTMODE,    with NARGS different arguments, passed as alternating rtx values    and machine_modes to convert them to.    The rtx values should have been passed through protect_from_queue already.     NO_QUEUE will be true if and only if the library call is a `const' call    which will be enclosed in REG_LIBCALL/REG_RETVAL notes; it is equivalent    to the variable is_const in expand_call.     NO_QUEUE must be true for const calls, because if it isn't, then    any pending increment will be emitted between REG_LIBCALL/REG_RETVAL notes,    and will be lost if the libcall sequence is optimized away.     NO_QUEUE must be false for non-const calls, because if it isn't, the    call insn will have its CONST_CALL_P bit set, and it will be incorrectly    optimized.  For instance, the instruction scheduler may incorrectly    move memory references across the non-const call.  */
end_comment

begin_decl_stmt
name|void
name|emit_library_call
name|VPROTO
argument_list|(
operator|(
name|rtx
name|orgfun
operator|,
name|int
name|no_queue
operator|,
expr|enum
name|machine_mode
name|outmode
operator|,
name|int
name|nargs
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|rtx
name|orgfun
decl_stmt|;
name|int
name|no_queue
decl_stmt|;
name|enum
name|machine_mode
name|outmode
decl_stmt|;
name|int
name|nargs
decl_stmt|;
endif|#
directive|endif
name|va_list
name|p
decl_stmt|;
comment|/* Total size in bytes of all the stack-parms scanned so far.  */
name|struct
name|args_size
name|args_size
decl_stmt|;
comment|/* Size of arguments before any adjustments (such as rounding).  */
name|struct
name|args_size
name|original_args_size
decl_stmt|;
specifier|register
name|int
name|argnum
decl_stmt|;
name|rtx
name|fun
decl_stmt|;
name|int
name|inc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
name|argblock
init|=
literal|0
decl_stmt|;
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
struct|struct
name|arg
block|{
name|rtx
name|value
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|partial
decl_stmt|;
name|struct
name|args_size
name|offset
decl_stmt|;
name|struct
name|args_size
name|size
decl_stmt|;
name|rtx
name|save_area
decl_stmt|;
block|}
struct|;
name|struct
name|arg
modifier|*
name|argvec
decl_stmt|;
name|int
name|old_inhibit_defer_pop
init|=
name|inhibit_defer_pop
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
comment|/* Define the boundary of the register parm stack space that needs to be      save, if any.  */
name|int
name|low_to_save
init|=
operator|-
literal|1
decl_stmt|,
name|high_to_save
decl_stmt|;
name|rtx
name|save_area
init|=
literal|0
decl_stmt|;
comment|/* Place that it is saved */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
name|int
name|initial_highest_arg_in_use
init|=
name|highest_outgoing_arg_in_use
decl_stmt|;
name|char
modifier|*
name|initial_stack_usage_map
init|=
name|stack_usage_map
decl_stmt|;
name|int
name|needed
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
comment|/* Size of the stack reserved for parameter registers.  */
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|MAYBE_REG_PARM_STACK_SPACE
expr_stmt|;
else|#
directive|else
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|VA_START
argument_list|(
name|p
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|orgfun
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
name|no_queue
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|outmode
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fun
operator|=
name|orgfun
expr_stmt|;
comment|/* Copy all the libcall-arguments out of the varargs data      and into a vector ARGVEC.       Compute how to pass each argument.  We only support a very small subset      of the full argument passing conventions to limit complexity here since      library functions shouldn't have many args.  */
name|argvec
operator|=
operator|(
expr|struct
name|arg
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argvec
argument_list|,
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|NULL_TREE
argument_list|,
name|fun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|args_size
operator|.
name|var
operator|=
literal|0
expr_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
block|{
name|rtx
name|val
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|)
decl_stmt|;
comment|/* We cannot convert the arg value to the mode the library wants here; 	 must do it earlier where we know the signedness of the arg.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
operator|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* On some machines, there's no way to pass a float to a library fcn. 	 Pass it as a double instead.  */
ifdef|#
directive|ifdef
name|LIBGCC_NEEDS_DOUBLE
if|if
condition|(
name|LIBGCC_NEEDS_DOUBLE
operator|&&
name|mode
operator|==
name|SFmode
condition|)
name|val
operator|=
name|convert_modes
argument_list|(
name|DFmode
argument_list|,
name|SFmode
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
operator|,
name|mode
operator|=
name|DFmode
expr_stmt|;
endif|#
directive|endif
comment|/* There's no need to call protect_from_queue, because 	 either emit_move_insn or emit_push_insn will do that.  */
comment|/* Make sure it is a reasonable operand for a move or push insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|MEM
operator|&&
operator|!
operator|(
name|CONSTANT_P
argument_list|(
name|val
argument_list|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|val
argument_list|)
operator|)
condition|)
name|val
operator|=
name|force_operand
argument_list|(
name|val
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PASS_BY_REFERENCE
if|if
condition|(
name|FUNCTION_ARG_PASS_BY_REFERENCE
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* We do not support FUNCTION_ARG_CALLEE_COPIES here since it can 	     be viewed as just an efficiency improvement.  */
name|rtx
name|slot
init|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|slot
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|mode
operator|=
name|Pmode
expr_stmt|;
block|}
endif|#
directive|endif
name|argvec
index|[
name|count
index|]
operator|.
name|value
operator|=
name|val
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|locate_and_pad_parm
argument_list|(
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|&&
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|==
literal|0
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|args_size
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|offset
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|size
operator|.
name|var
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg_parm_stack_space
operator|==
literal|0
operator|&&
name|argvec
index|[
name|count
index|]
operator|.
name|partial
condition|)
name|argvec
index|[
name|count
index|]
operator|.
name|size
operator|.
name|constant
operator|-=
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|!=
literal|0
operator|||
name|reg_parm_stack_space
operator|>
literal|0
condition|)
name|args_size
operator|.
name|constant
operator|+=
name|argvec
index|[
name|count
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FINAL_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|FINAL_REG_PARM_STACK_SPACE
argument_list|(
name|args_size
operator|.
name|constant
argument_list|,
name|args_size
operator|.
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this machine requires an external definition for library      functions, write one out.  */
name|assemble_external_libcall
argument_list|(
name|fun
argument_list|)
expr_stmt|;
name|original_args_size
operator|=
name|args_size
expr_stmt|;
ifdef|#
directive|ifdef
name|PREFERRED_STACK_BOUNDARY
name|args_size
operator|.
name|constant
operator|=
operator|(
operator|(
operator|(
name|args_size
operator|.
name|constant
operator|+
operator|(
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|)
operator|/
name|STACK_BYTES
operator|)
operator|*
name|STACK_BYTES
operator|)
expr_stmt|;
endif|#
directive|endif
name|args_size
operator|.
name|constant
operator|=
name|MAX
argument_list|(
name|args_size
operator|.
name|constant
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
name|args_size
operator|.
name|constant
operator|-=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args_size
operator|.
name|constant
operator|>
name|current_function_outgoing_args_size
condition|)
name|current_function_outgoing_args_size
operator|=
name|args_size
operator|.
name|constant
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* Since the stack pointer will never be pushed, it is possible for      the evaluation of a parm to clobber something we have already      written to the stack.  Since most function calls on RISC machines      do not use the stack, this is uncommon, but must work correctly.       Therefore, we save any area of the stack that was already written      and that we are using.  Here we set up to do this by making a new      stack usage map from the old one.       Another approach might be to try to reorder the argument      evaluations to avoid this conflicting stack usage.  */
name|needed
operator|=
name|args_size
operator|.
name|constant
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
comment|/* Since we will be writing into the entire argument area, the      map must be allocated for its entire size, not just the part that      is the responsibility of the caller.  */
name|needed
operator|+=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stack_usage_map
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
condition|)
name|bcopy
argument_list|(
name|initial_stack_usage_map
argument_list|,
name|stack_usage_map
argument_list|,
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
operator|!=
name|highest_outgoing_arg_in_use
condition|)
name|bzero
argument_list|(
operator|&
name|stack_usage_map
index|[
name|initial_highest_arg_in_use
index|]
argument_list|,
name|highest_outgoing_arg_in_use
operator|-
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
comment|/* The address of the outgoing argument list must not be copied to a      register here, because argblock would be left pointing to the      wrong place after the call to allocate_dynamic_stack_space below.      */
name|argblock
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
else|#
directive|else
comment|/* not ACCUMULATE_OUTGOING_ARGS */
ifndef|#
directive|ifndef
name|PUSH_ROUNDING
name|argblock
operator|=
name|push_block
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
ifdef|#
directive|ifdef
name|PREFERRED_STACK_BOUNDARY
comment|/* If we push args individually in reverse order, perform stack alignment      before the first push (the last arg).  */
if|if
condition|(
name|argblock
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
operator|-
name|original_args_size
operator|.
name|constant
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
name|argnum
operator|=
name|nargs
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|inc
operator|=
literal|1
expr_stmt|;
name|argnum
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
comment|/* The argument list is the property of the called routine and it      may clobber it.  If the fixed area has been used for previous      parameters, we must save and restore it.       Here we compute the boundary of the that needs to be saved, if any.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|reg_parm_stack_space
operator|+
literal|1
condition|;
name|count
operator|++
control|)
else|#
directive|else
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|reg_parm_stack_space
condition|;
name|count
operator|++
control|)
endif|#
directive|endif
block|{
if|if
condition|(
name|count
operator|>=
name|highest_outgoing_arg_in_use
operator|||
name|stack_usage_map
index|[
name|count
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|low_to_save
operator|==
operator|-
literal|1
condition|)
name|low_to_save
operator|=
name|count
expr_stmt|;
name|high_to_save
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|low_to_save
operator|>=
literal|0
condition|)
block|{
name|int
name|num_to_save
init|=
name|high_to_save
operator|-
name|low_to_save
operator|+
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|num_to_save
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
decl_stmt|;
comment|/* If we don't have the required alignment, must do this in BLKmode.  */
if|if
condition|(
operator|(
name|low_to_save
operator|&
operator|(
name|MIN
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|save_mode
argument_list|)
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|UNITS_PER_WORD
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|save_mode
operator|=
name|BLKmode
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
name|high_to_save
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|low_to_save
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|save_mode
operator|==
name|BLKmode
condition|)
block|{
name|save_area
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|num_to_save
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|stack_area
argument_list|,
name|GEN_INT
argument_list|(
name|num_to_save
argument_list|)
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Push the args that need to be pushed.  */
comment|/* ARGNUM indexes the ARGVEC array in the order in which the arguments      are to be pushed.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
operator|,
name|argnum
operator|+=
name|inc
control|)
block|{
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|mode
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|value
decl_stmt|;
name|rtx
name|reg
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|reg
decl_stmt|;
name|int
name|partial
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|partial
decl_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
name|int
name|lower_bound
decl_stmt|,
name|upper_bound
decl_stmt|,
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|reg
operator|!=
literal|0
operator|&&
name|partial
operator|==
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* If this is being stored into a pre-allocated, fixed-size, stack 	     area, save any previous data at that location.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
comment|/* stack_slot is negative, but we want to index stack_usage_map 	     with positive values.  */
name|upper_bound
operator|=
operator|-
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
operator|+
literal|1
expr_stmt|;
name|lower_bound
operator|=
name|upper_bound
operator|-
name|argvec
index|[
name|argnum
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
else|#
directive|else
name|lower_bound
operator|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
expr_stmt|;
name|upper_bound
operator|=
name|lower_bound
operator|+
name|argvec
index|[
name|argnum
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stack_usage_map
index|[
name|i
index|]
comment|/* Don't store things in the fixed argument area at this point; 		   it has already been saved.  */
operator|&&
name|i
operator|>
name|reg_parm_stack_space
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|upper_bound
condition|)
block|{
comment|/* We need to make a save area.  See what mode we can make it. */
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|size
operator|.
name|constant
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|argvec
index|[
name|argnum
index|]
operator|.
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|emit_push_insn
argument_list|(
name|val
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|argblock
argument_list|,
name|GEN_INT
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* Now mark the segment we just used.  */
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
name|stack_usage_map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|NO_DEFER_POP
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
ifdef|#
directive|ifdef
name|PREFERRED_STACK_BOUNDARY
comment|/* If we pushed args in forward order, perform stack alignment      after pushing the last arg.  */
if|if
condition|(
name|argblock
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
operator|-
name|original_args_size
operator|.
name|constant
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
name|argnum
operator|=
name|nargs
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|argnum
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|fun
operator|=
name|prepare_call_address
argument_list|(
name|fun
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|call_fusage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now load any reg parms into their regs.  */
comment|/* ARGNUM indexes the ARGVEC array in the order in which the arguments      are to be pushed.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
operator|,
name|argnum
operator|+=
name|inc
control|)
block|{
specifier|register
name|rtx
name|val
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|value
decl_stmt|;
name|rtx
name|reg
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|reg
decl_stmt|;
name|int
name|partial
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|partial
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|partial
operator|==
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
block|}
comment|/* For version 1.37, try deleting this entirely.  */
if|if
condition|(
operator|!
name|no_queue
condition|)
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Any regs containing parms remain in use through the call.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|!=
literal|0
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
comment|/* Don't allow popping to be deferred, since then      cse'ing of library calls could delete a call and leave the pop.  */
name|NO_DEFER_POP
expr_stmt|;
comment|/* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which      will set inhibit_defer_pop to that value.  */
comment|/* The return type is needed to decide how many bytes the function pops.      Signedness plays no role in that, so for simplicity, we pretend it's      always signed.  We also assume that the list of arguments passed has      no impact, so we pretend it is unknown.  */
name|emit_call_1
argument_list|(
name|fun
argument_list|,
name|get_identifier
argument_list|(
name|XSTR
argument_list|(
name|orgfun
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_function_type
argument_list|(
name|outmode
operator|==
name|VOIDmode
condition|?
name|void_type_node
else|:
name|type_for_mode
argument_list|(
name|outmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|original_args_size
operator|.
name|constant
argument_list|,
name|args_size
operator|.
name|constant
argument_list|,
literal|0
argument_list|,
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outmode
operator|!=
name|VOIDmode
condition|?
name|hard_libcall_value
argument_list|(
name|outmode
argument_list|)
else|:
name|NULL_RTX
argument_list|,
name|old_inhibit_defer_pop
operator|+
literal|1
argument_list|,
name|call_fusage
argument_list|,
name|no_queue
argument_list|)
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* Now restore inhibit_defer_pop to its actual original value.  */
name|OK_DEFER_POP
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
if|if
condition|(
name|save_area
condition|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|save_area
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
name|high_to_save
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|low_to_save
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|save_mode
operator|!=
name|BLKmode
condition|)
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|save_area
argument_list|)
expr_stmt|;
else|else
name|emit_block_move
argument_list|(
name|stack_area
argument_list|,
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high_to_save
operator|-
name|low_to_save
operator|+
literal|1
argument_list|)
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we saved any argument areas, restore them.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
condition|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|offset
operator|.
name|constant
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
argument_list|)
expr_stmt|;
block|}
name|highest_outgoing_arg_in_use
operator|=
name|initial_highest_arg_in_use
expr_stmt|;
name|stack_usage_map
operator|=
name|initial_stack_usage_map
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Like emit_library_call except that an extra argument, VALUE,    comes second and says where to store the result.    (If VALUE is zero, this function chooses a convenient way    to return the value.     This function returns an rtx for where the value is to be found.    If VALUE is nonzero, VALUE is returned.  */
end_comment

begin_decl_stmt
name|rtx
name|emit_library_call_value
name|VPROTO
argument_list|(
operator|(
name|rtx
name|orgfun
operator|,
name|rtx
name|value
operator|,
name|int
name|no_queue
operator|,
expr|enum
name|machine_mode
name|outmode
operator|,
name|int
name|nargs
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|rtx
name|orgfun
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|no_queue
decl_stmt|;
name|enum
name|machine_mode
name|outmode
decl_stmt|;
name|int
name|nargs
decl_stmt|;
endif|#
directive|endif
name|va_list
name|p
decl_stmt|;
comment|/* Total size in bytes of all the stack-parms scanned so far.  */
name|struct
name|args_size
name|args_size
decl_stmt|;
comment|/* Size of arguments before any adjustments (such as rounding).  */
name|struct
name|args_size
name|original_args_size
decl_stmt|;
specifier|register
name|int
name|argnum
decl_stmt|;
name|rtx
name|fun
decl_stmt|;
name|int
name|inc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
name|argblock
init|=
literal|0
decl_stmt|;
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
struct|struct
name|arg
block|{
name|rtx
name|value
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|partial
decl_stmt|;
name|struct
name|args_size
name|offset
decl_stmt|;
name|struct
name|args_size
name|size
decl_stmt|;
name|rtx
name|save_area
decl_stmt|;
block|}
struct|;
name|struct
name|arg
modifier|*
name|argvec
decl_stmt|;
name|int
name|old_inhibit_defer_pop
init|=
name|inhibit_defer_pop
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
name|rtx
name|mem_value
init|=
literal|0
decl_stmt|;
name|int
name|pcc_struct_value
init|=
literal|0
decl_stmt|;
name|int
name|struct_value_size
init|=
literal|0
decl_stmt|;
name|int
name|is_const
decl_stmt|;
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
name|int
name|needed
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
comment|/* Define the boundary of the register parm stack space that needs to be      save, if any.  */
name|int
name|low_to_save
init|=
operator|-
literal|1
decl_stmt|,
name|high_to_save
decl_stmt|;
name|rtx
name|save_area
init|=
literal|0
decl_stmt|;
comment|/* Place that it is saved */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* Size of the stack reserved for parameter registers.  */
name|int
name|initial_highest_arg_in_use
init|=
name|highest_outgoing_arg_in_use
decl_stmt|;
name|char
modifier|*
name|initial_stack_usage_map
init|=
name|stack_usage_map
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|MAYBE_REG_PARM_STACK_SPACE
expr_stmt|;
else|#
directive|else
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|VA_START
argument_list|(
name|p
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|orgfun
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
name|value
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
name|no_queue
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|outmode
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is_const
operator|=
name|no_queue
expr_stmt|;
name|fun
operator|=
name|orgfun
expr_stmt|;
comment|/* If this kind of value comes back in memory,      decide where in memory it should come back.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|type_for_mode
argument_list|(
name|outmode
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
name|rtx
name|pointer_reg
init|=
name|hard_function_value
argument_list|(
name|build_pointer_type
argument_list|(
name|type_for_mode
argument_list|(
name|outmode
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|mem_value
operator|=
name|gen_rtx_MEM
argument_list|(
name|outmode
argument_list|,
name|pointer_reg
argument_list|)
expr_stmt|;
name|pcc_struct_value
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|gen_reg_rtx
argument_list|(
name|outmode
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not PCC_STATIC_STRUCT_RETURN */
name|struct_value_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
condition|)
name|mem_value
operator|=
name|value
expr_stmt|;
else|else
name|mem_value
operator|=
name|assign_stack_temp
argument_list|(
name|outmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This call returns a big structure.  */
name|is_const
operator|=
literal|0
expr_stmt|;
block|}
comment|/* ??? Unfinished: must pass the memory address as an argument.  */
comment|/* Copy all the libcall-arguments out of the varargs data      and into a vector ARGVEC.       Compute how to pass each argument.  We only support a very small subset      of the full argument passing conventions to limit complexity here since      library functions shouldn't have many args.  */
name|argvec
operator|=
operator|(
expr|struct
name|arg
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argvec
argument_list|,
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|NULL_TREE
argument_list|,
name|fun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|args_size
operator|.
name|var
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
comment|/* If there's a structure value address to be passed,      either pass it in the special place, or pass it as an extra argument.  */
if|if
condition|(
name|mem_value
operator|&&
name|struct_value_rtx
operator|==
literal|0
operator|&&
operator|!
name|pcc_struct_value
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|mem_value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|nargs
operator|++
expr_stmt|;
comment|/* Make sure it is a reasonable operand for a move or push insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|MEM
operator|&&
operator|!
operator|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|)
condition|)
name|addr
operator|=
name|force_operand
argument_list|(
name|addr
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|value
operator|=
name|addr
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|mode
operator|=
name|Pmode
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
literal|0
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|Pmode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
if|if
condition|(
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
name|args_so_far
argument_list|,
name|Pmode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|locate_and_pad_parm
argument_list|(
name|Pmode
argument_list|,
name|NULL_TREE
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|&&
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|==
literal|0
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|args_size
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|offset
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|!=
literal|0
operator|||
name|reg_parm_stack_space
operator|>
literal|0
condition|)
name|args_size
operator|.
name|constant
operator|+=
name|argvec
index|[
name|count
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|Pmode
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
block|{
name|rtx
name|val
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|)
decl_stmt|;
comment|/* We cannot convert the arg value to the mode the library wants here; 	 must do it earlier where we know the signedness of the arg.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
operator|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* On some machines, there's no way to pass a float to a library fcn. 	 Pass it as a double instead.  */
ifdef|#
directive|ifdef
name|LIBGCC_NEEDS_DOUBLE
if|if
condition|(
name|LIBGCC_NEEDS_DOUBLE
operator|&&
name|mode
operator|==
name|SFmode
condition|)
name|val
operator|=
name|convert_modes
argument_list|(
name|DFmode
argument_list|,
name|SFmode
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
operator|,
name|mode
operator|=
name|DFmode
expr_stmt|;
endif|#
directive|endif
comment|/* There's no need to call protect_from_queue, because 	 either emit_move_insn or emit_push_insn will do that.  */
comment|/* Make sure it is a reasonable operand for a move or push insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|MEM
operator|&&
operator|!
operator|(
name|CONSTANT_P
argument_list|(
name|val
argument_list|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|val
argument_list|)
operator|)
condition|)
name|val
operator|=
name|force_operand
argument_list|(
name|val
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PASS_BY_REFERENCE
if|if
condition|(
name|FUNCTION_ARG_PASS_BY_REFERENCE
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* We do not support FUNCTION_ARG_CALLEE_COPIES here since it can 	     be viewed as just an efficiency improvement.  */
name|rtx
name|slot
init|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|slot
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|Pmode
expr_stmt|;
block|}
endif|#
directive|endif
name|argvec
index|[
name|count
index|]
operator|.
name|value
operator|=
name|val
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|locate_and_pad_parm
argument_list|(
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|&&
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|==
literal|0
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|args_size
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|offset
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|size
operator|.
name|var
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg_parm_stack_space
operator|==
literal|0
operator|&&
name|argvec
index|[
name|count
index|]
operator|.
name|partial
condition|)
name|argvec
index|[
name|count
index|]
operator|.
name|size
operator|.
name|constant
operator|-=
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|!=
literal|0
operator|||
name|reg_parm_stack_space
operator|>
literal|0
condition|)
name|args_size
operator|.
name|constant
operator|+=
name|argvec
index|[
name|count
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FINAL_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|FINAL_REG_PARM_STACK_SPACE
argument_list|(
name|args_size
operator|.
name|constant
argument_list|,
name|args_size
operator|.
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this machine requires an external definition for library      functions, write one out.  */
name|assemble_external_libcall
argument_list|(
name|fun
argument_list|)
expr_stmt|;
name|original_args_size
operator|=
name|args_size
expr_stmt|;
ifdef|#
directive|ifdef
name|PREFERRED_STACK_BOUNDARY
name|args_size
operator|.
name|constant
operator|=
operator|(
operator|(
operator|(
name|args_size
operator|.
name|constant
operator|+
operator|(
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|)
operator|/
name|STACK_BYTES
operator|)
operator|*
name|STACK_BYTES
operator|)
expr_stmt|;
endif|#
directive|endif
name|args_size
operator|.
name|constant
operator|=
name|MAX
argument_list|(
name|args_size
operator|.
name|constant
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
name|args_size
operator|.
name|constant
operator|-=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args_size
operator|.
name|constant
operator|>
name|current_function_outgoing_args_size
condition|)
name|current_function_outgoing_args_size
operator|=
name|args_size
operator|.
name|constant
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* Since the stack pointer will never be pushed, it is possible for      the evaluation of a parm to clobber something we have already      written to the stack.  Since most function calls on RISC machines      do not use the stack, this is uncommon, but must work correctly.       Therefore, we save any area of the stack that was already written      and that we are using.  Here we set up to do this by making a new      stack usage map from the old one.       Another approach might be to try to reorder the argument      evaluations to avoid this conflicting stack usage.  */
name|needed
operator|=
name|args_size
operator|.
name|constant
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
comment|/* Since we will be writing into the entire argument area, the      map must be allocated for its entire size, not just the part that      is the responsibility of the caller.  */
name|needed
operator|+=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stack_usage_map
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
condition|)
name|bcopy
argument_list|(
name|initial_stack_usage_map
argument_list|,
name|stack_usage_map
argument_list|,
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
operator|!=
name|highest_outgoing_arg_in_use
condition|)
name|bzero
argument_list|(
operator|&
name|stack_usage_map
index|[
name|initial_highest_arg_in_use
index|]
argument_list|,
name|highest_outgoing_arg_in_use
operator|-
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
comment|/* The address of the outgoing argument list must not be copied to a      register here, because argblock would be left pointing to the      wrong place after the call to allocate_dynamic_stack_space below.      */
name|argblock
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
else|#
directive|else
comment|/* not ACCUMULATE_OUTGOING_ARGS */
ifndef|#
directive|ifndef
name|PUSH_ROUNDING
name|argblock
operator|=
name|push_block
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
ifdef|#
directive|ifdef
name|PREFERRED_STACK_BOUNDARY
comment|/* If we push args individually in reverse order, perform stack alignment      before the first push (the last arg).  */
if|if
condition|(
name|argblock
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
operator|-
name|original_args_size
operator|.
name|constant
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
name|argnum
operator|=
name|nargs
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|inc
operator|=
literal|1
expr_stmt|;
name|argnum
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
comment|/* The argument list is the property of the called routine and it      may clobber it.  If the fixed area has been used for previous      parameters, we must save and restore it.       Here we compute the boundary of the that needs to be saved, if any.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|reg_parm_stack_space
operator|+
literal|1
condition|;
name|count
operator|++
control|)
else|#
directive|else
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|reg_parm_stack_space
condition|;
name|count
operator|++
control|)
endif|#
directive|endif
block|{
if|if
condition|(
name|count
operator|>=
name|highest_outgoing_arg_in_use
operator|||
name|stack_usage_map
index|[
name|count
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|low_to_save
operator|==
operator|-
literal|1
condition|)
name|low_to_save
operator|=
name|count
expr_stmt|;
name|high_to_save
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|low_to_save
operator|>=
literal|0
condition|)
block|{
name|int
name|num_to_save
init|=
name|high_to_save
operator|-
name|low_to_save
operator|+
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|num_to_save
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
decl_stmt|;
comment|/* If we don't have the required alignment, must do this in BLKmode.  */
if|if
condition|(
operator|(
name|low_to_save
operator|&
operator|(
name|MIN
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|save_mode
argument_list|)
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|UNITS_PER_WORD
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|save_mode
operator|=
name|BLKmode
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
name|high_to_save
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|low_to_save
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|save_mode
operator|==
name|BLKmode
condition|)
block|{
name|save_area
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|num_to_save
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|stack_area
argument_list|,
name|GEN_INT
argument_list|(
name|num_to_save
argument_list|)
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Push the args that need to be pushed.  */
comment|/* ARGNUM indexes the ARGVEC array in the order in which the arguments      are to be pushed.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
operator|,
name|argnum
operator|+=
name|inc
control|)
block|{
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|mode
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|value
decl_stmt|;
name|rtx
name|reg
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|reg
decl_stmt|;
name|int
name|partial
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|partial
decl_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
name|int
name|lower_bound
decl_stmt|,
name|upper_bound
decl_stmt|,
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|reg
operator|!=
literal|0
operator|&&
name|partial
operator|==
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* If this is being stored into a pre-allocated, fixed-size, stack 	     area, save any previous data at that location.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
comment|/* stack_slot is negative, but we want to index stack_usage_map 	     with positive values.  */
name|upper_bound
operator|=
operator|-
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
operator|+
literal|1
expr_stmt|;
name|lower_bound
operator|=
name|upper_bound
operator|-
name|argvec
index|[
name|argnum
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
else|#
directive|else
name|lower_bound
operator|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
expr_stmt|;
name|upper_bound
operator|=
name|lower_bound
operator|+
name|argvec
index|[
name|argnum
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stack_usage_map
index|[
name|i
index|]
comment|/* Don't store things in the fixed argument area at this point; 		   it has already been saved.  */
operator|&&
name|i
operator|>
name|reg_parm_stack_space
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|upper_bound
condition|)
block|{
comment|/* We need to make a save area.  See what mode we can make it. */
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|size
operator|.
name|constant
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|argvec
index|[
name|argnum
index|]
operator|.
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|emit_push_insn
argument_list|(
name|val
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|argblock
argument_list|,
name|GEN_INT
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* Now mark the segment we just used.  */
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
name|stack_usage_map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|NO_DEFER_POP
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
ifdef|#
directive|ifdef
name|PREFERRED_STACK_BOUNDARY
comment|/* If we pushed args in forward order, perform stack alignment      after pushing the last arg.  */
if|if
condition|(
name|argblock
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
operator|-
name|original_args_size
operator|.
name|constant
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PUSH_ARGS_REVERSED
name|argnum
operator|=
name|nargs
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|argnum
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|fun
operator|=
name|prepare_call_address
argument_list|(
name|fun
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|call_fusage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now load any reg parms into their regs.  */
comment|/* ARGNUM indexes the ARGVEC array in the order in which the arguments      are to be pushed.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
operator|,
name|argnum
operator|+=
name|inc
control|)
block|{
specifier|register
name|rtx
name|val
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|value
decl_stmt|;
name|rtx
name|reg
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|reg
decl_stmt|;
name|int
name|partial
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|partial
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|partial
operator|==
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* For version 1.37, try deleting this entirely.  */
block|if (! no_queue)     emit_queue ();
endif|#
directive|endif
comment|/* Any regs containing parms remain in use through the call.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|!=
literal|0
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
comment|/* Pass the function the address in which to return a structure value.  */
if|if
condition|(
name|mem_value
operator|!=
literal|0
operator|&&
name|struct_value_rtx
operator|!=
literal|0
operator|&&
operator|!
name|pcc_struct_value
condition|)
block|{
name|emit_move_insn
argument_list|(
name|struct_value_rtx
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|mem_value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|struct_value_rtx
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|struct_value_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* Don't allow popping to be deferred, since then      cse'ing of library calls could delete a call and leave the pop.  */
name|NO_DEFER_POP
expr_stmt|;
comment|/* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which      will set inhibit_defer_pop to that value.  */
comment|/* See the comment in emit_library_call about the function type we build      and pass here.  */
name|emit_call_1
argument_list|(
name|fun
argument_list|,
name|get_identifier
argument_list|(
name|XSTR
argument_list|(
name|orgfun
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_function_type
argument_list|(
name|type_for_mode
argument_list|(
name|outmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|original_args_size
operator|.
name|constant
argument_list|,
name|args_size
operator|.
name|constant
argument_list|,
name|struct_value_size
argument_list|,
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mem_value
operator|==
literal|0
condition|?
name|hard_libcall_value
argument_list|(
name|outmode
argument_list|)
else|:
name|NULL_RTX
argument_list|,
name|old_inhibit_defer_pop
operator|+
literal|1
argument_list|,
name|call_fusage
argument_list|,
name|is_const
argument_list|)
expr_stmt|;
comment|/* Now restore inhibit_defer_pop to its actual original value.  */
name|OK_DEFER_POP
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* Copy the value to the right place.  */
if|if
condition|(
name|outmode
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|mem_value
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|mem_value
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|mem_value
condition|)
name|emit_move_insn
argument_list|(
name|value
argument_list|,
name|mem_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|value
argument_list|,
name|hard_libcall_value
argument_list|(
name|outmode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|hard_libcall_value
argument_list|(
name|outmode
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
if|if
condition|(
name|save_area
condition|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|save_area
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
name|high_to_save
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|low_to_save
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|save_mode
operator|!=
name|BLKmode
condition|)
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|save_area
argument_list|)
expr_stmt|;
else|else
name|emit_block_move
argument_list|(
name|stack_area
argument_list|,
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high_to_save
operator|-
name|low_to_save
operator|+
literal|1
argument_list|)
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we saved any argument areas, restore them.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
condition|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|offset
operator|.
name|constant
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
argument_list|)
expr_stmt|;
block|}
name|highest_outgoing_arg_in_use
operator|=
name|initial_highest_arg_in_use
expr_stmt|;
name|stack_usage_map
operator|=
name|initial_stack_usage_map
expr_stmt|;
endif|#
directive|endif
return|return
name|value
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Return an rtx which represents a suitable home on the stack    given TYPE, the type of the argument looking for a home.    This is called only for BLKmode arguments.     SIZE is the size needed for this target.    ARGS_ADDR is the address of the bottom of the argument block for this call.    OFFSET describes this parameter's offset into ARGS_ADDR.  It is meaningless    if this machine uses push insns.  */
end_comment

begin_comment
unit|static rtx target_for_arg (type, size, args_addr, offset)      tree type;      rtx size;      rtx args_addr;      struct args_size offset; {   rtx target;   rtx offset_rtx = ARGS_SIZE_RTX (offset);
comment|/* We do not call memory_address if possible,      because we want to address as close to the stack      as possible.  For non-variable sized arguments,      this will be stack-pointer relative addressing.  */
end_comment

begin_comment
unit|if (GET_CODE (offset_rtx) == CONST_INT)     target = plus_constant (args_addr, INTVAL (offset_rtx));   else     {
comment|/* I have no idea how to guarantee that this 	 will work in the presence of register parameters.  */
end_comment

begin_endif
unit|target = gen_rtx_PLUS (Pmode, args_addr, offset_rtx);       target = memory_address (QImode, target);     }    return gen_rtx_MEM (BLKmode, target); }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Store a single argument for a function call    into the register or memory area where it must be passed.    *ARG describes the argument value and where to pass it.     ARGBLOCK is the address of the stack-block for all the arguments,    or 0 on a machine where arguments are pushed individually.     MAY_BE_ALLOCA nonzero says this could be a call to `alloca'    so must be careful about how the stack is used.      VARIABLE_SIZE nonzero says that this was a variable-sized outgoing    argument stack.  This is used if ACCUMULATE_OUTGOING_ARGS to indicate    that we need not worry about saving and restoring the stack.     FNDECL is the declaration of the function we are calling.  */
end_comment

begin_function
specifier|static
name|void
name|store_one_arg
parameter_list|(
name|arg
parameter_list|,
name|argblock
parameter_list|,
name|may_be_alloca
parameter_list|,
name|variable_size
parameter_list|,
name|reg_parm_stack_space
parameter_list|)
name|struct
name|arg_data
modifier|*
name|arg
decl_stmt|;
name|rtx
name|argblock
decl_stmt|;
name|int
name|may_be_alloca
decl_stmt|;
name|int
name|variable_size
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|reg_parm_stack_space
decl_stmt|;
block|{
specifier|register
name|tree
name|pval
init|=
name|arg
operator|->
name|tree_value
decl_stmt|;
name|rtx
name|reg
init|=
literal|0
decl_stmt|;
name|int
name|partial
init|=
literal|0
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
name|int
name|i
decl_stmt|,
name|lower_bound
decl_stmt|,
name|upper_bound
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pval
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* Push a new temporary level for any temporaries we make for      this argument.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* If this is being stored into a pre-allocated, fixed-size, stack area,      save any previous data at that location.  */
if|if
condition|(
name|argblock
operator|&&
operator|!
name|variable_size
operator|&&
name|arg
operator|->
name|stack
condition|)
block|{
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
comment|/* stack_slot is negative, but we want to index stack_usage_map          with positive values.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|upper_bound
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|upper_bound
operator|=
literal|0
expr_stmt|;
name|lower_bound
operator|=
name|upper_bound
operator|-
name|arg
operator|->
name|size
operator|.
name|constant
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|lower_bound
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|lower_bound
operator|=
literal|0
expr_stmt|;
name|upper_bound
operator|=
name|lower_bound
operator|+
name|arg
operator|->
name|size
operator|.
name|constant
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stack_usage_map
index|[
name|i
index|]
comment|/* Don't store things in the fixed argument area at this point; 	       it has already been saved.  */
operator|&&
name|i
operator|>
name|reg_parm_stack_space
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|upper_bound
condition|)
block|{
comment|/* We need to make a save area.  See what mode we can make it.  */
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|arg
operator|->
name|size
operator|.
name|constant
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|save_mode
operator|==
name|BLKmode
condition|)
block|{
name|arg
operator|->
name|save_area
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|arg
operator|->
name|size
operator|.
name|constant
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|arg
operator|->
name|save_area
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
operator|->
name|tree_value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|arg
operator|->
name|save_area
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|validize_mem
argument_list|(
name|arg
operator|->
name|save_area
argument_list|)
argument_list|,
name|stack_area
argument_list|,
name|GEN_INT
argument_list|(
name|arg
operator|->
name|size
operator|.
name|constant
argument_list|)
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|->
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|arg
operator|->
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now that we have saved any slots that will be overwritten by this      store, mark all slots this store will use.  We must do this before      we actually expand the argument since the expansion itself may      trigger library calls which might need to use the same stack slot.  */
if|if
condition|(
name|argblock
operator|&&
operator|!
name|variable_size
operator|&&
name|arg
operator|->
name|stack
condition|)
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
name|stack_usage_map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* If this isn't going to be placed on both the stack and in registers,      set up the register and number of words.  */
if|if
condition|(
operator|!
name|arg
operator|->
name|pass_on_stack
condition|)
name|reg
operator|=
name|arg
operator|->
name|reg
operator|,
name|partial
operator|=
name|arg
operator|->
name|partial
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|partial
operator|==
literal|0
condition|)
comment|/* Being passed entirely in a register.  We shouldn't be called in        this case.   */
name|abort
argument_list|()
expr_stmt|;
comment|/* If this arg needs special alignment, don't load the registers      here.  */
if|if
condition|(
name|arg
operator|->
name|n_aligned_regs
operator|!=
literal|0
condition|)
name|reg
operator|=
literal|0
expr_stmt|;
comment|/* If this is being passed partially in a register, we can't evaluate      it directly into its stack slot.  Otherwise, we can.  */
if|if
condition|(
name|arg
operator|->
name|value
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* stack_arg_under_construction is nonzero if a function argument is 	 being evaluated directly into the outgoing argument list and 	 expand_call must take special action to preserve the argument list 	 if it is called recursively.  	 For scalar function arguments stack_usage_map is sufficient to 	 determine which stack slots must be saved and restored.  Scalar 	 arguments in general have pass_on_stack == 0.  	 If this argument is initialized by a function which takes the 	 address of the argument (a C++ constructor or a C function 	 returning a BLKmode structure), then stack_usage_map is 	 insufficient and expand_call must push the stack around the 	 function call.  Such arguments have pass_on_stack == 1.  	 Note that it is always safe to set stack_arg_under_construction, 	 but this generates suboptimal code if set when not needed.  */
if|if
condition|(
name|arg
operator|->
name|pass_on_stack
condition|)
name|stack_arg_under_construction
operator|++
expr_stmt|;
endif|#
directive|endif
name|arg
operator|->
name|value
operator|=
name|expand_expr
argument_list|(
name|pval
argument_list|,
operator|(
name|partial
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|!=
name|arg
operator|->
name|mode
operator|)
condition|?
name|NULL_RTX
else|:
name|arg
operator|->
name|stack
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we are promoting object (or for any other reason) the mode 	 doesn't agree, convert the mode.  */
if|if
condition|(
name|arg
operator|->
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
condition|)
name|arg
operator|->
name|value
operator|=
name|convert_modes
argument_list|(
name|arg
operator|->
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|,
name|arg
operator|->
name|value
argument_list|,
name|arg
operator|->
name|unsignedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
if|if
condition|(
name|arg
operator|->
name|pass_on_stack
condition|)
name|stack_arg_under_construction
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Don't allow anything left on stack from computation      of argument to alloca.  */
if|if
condition|(
name|may_be_alloca
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|value
operator|==
name|arg
operator|->
name|stack
condition|)
block|{
comment|/* If the value is already in the stack slot, we are done moving 	 data.  */
if|if
condition|(
name|current_function_check_memory_usage
operator|&&
name|GET_CODE
argument_list|(
name|arg
operator|->
name|stack
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|emit_library_call
argument_list|(
name|chkr_set_right_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|arg
operator|->
name|stack
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|size
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_RW
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|mode
operator|!=
name|BLKmode
condition|)
block|{
specifier|register
name|int
name|size
decl_stmt|;
comment|/* Argument is a scalar, not entirely passed in registers. 	 (If part is passed in registers, arg->partial says how much 	 and emit_push_insn will take care of putting it there.) 	  	 Push it, and if its size is less than the 	 amount of space allocated to it, 	 also bump stack pointer by the additional space. 	 Note that in C the default argument promotions 	 will prevent such mismatches.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|arg
operator|->
name|mode
argument_list|)
expr_stmt|;
comment|/* Compute how much space the push instruction will push. 	 On many machines, pushing a byte will advance the stack 	 pointer by a halfword.  */
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|used
operator|=
name|size
expr_stmt|;
comment|/* Compute how much space the argument should get: 	 round up to a multiple of the alignment for arguments.  */
if|if
condition|(
name|none
operator|!=
name|FUNCTION_ARG_PADDING
argument_list|(
name|arg
operator|->
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
condition|)
name|used
operator|=
operator|(
operator|(
operator|(
name|size
operator|+
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* This isn't already where we want it on the stack, so put it there. 	 This can either be done with push or copy insns.  */
name|emit_push_insn
argument_list|(
name|arg
operator|->
name|value
argument_list|,
name|arg
operator|->
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
name|used
operator|-
name|size
argument_list|,
name|argblock
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|offset
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* BLKmode, at least partly to be pushed.  */
specifier|register
name|int
name|excess
decl_stmt|;
name|rtx
name|size_rtx
decl_stmt|;
comment|/* Pushing a nonscalar. 	 If part is passed in registers, PARTIAL says how much 	 and emit_push_insn will take care of putting it there.  */
comment|/* Round its size up to a multiple 	 of the allocation unit for arguments.  */
if|if
condition|(
name|arg
operator|->
name|size
operator|.
name|var
operator|!=
literal|0
condition|)
block|{
name|excess
operator|=
literal|0
expr_stmt|;
name|size_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* PUSH_ROUNDING has no effect on us, because 	     emit_push_insn for BLKmode is careful to avoid it.  */
name|excess
operator|=
operator|(
name|arg
operator|->
name|size
operator|.
name|constant
operator|-
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|+
name|partial
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|size_rtx
operator|=
name|expr_size
argument_list|(
name|pval
argument_list|)
expr_stmt|;
block|}
name|emit_push_insn
argument_list|(
name|arg
operator|->
name|value
argument_list|,
name|arg
operator|->
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|,
name|size_rtx
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
name|excess
argument_list|,
name|argblock
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|offset
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
block|}
comment|/* Unless this is a partially-in-register argument, the argument is now      in the stack.        ??? Note that this can change arg->value from arg->stack to      arg->stack_slot and it matters when they are not the same.      It isn't totally clear that this is correct in all cases.  */
if|if
condition|(
name|partial
operator|==
literal|0
condition|)
name|arg
operator|->
name|value
operator|=
name|arg
operator|->
name|stack_slot
expr_stmt|;
comment|/* Once we have pushed something, pops can't safely      be deferred during the rest of the arguments.  */
name|NO_DEFER_POP
expr_stmt|;
comment|/* ANSI doesn't require a sequence point here,      but PCC has one, so this will avoid some problems.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Free any temporary slots made in processing this argument.  Show      that we might have taken the address of something and pushed that      as an operand.  */
name|preserve_temp_slots
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

