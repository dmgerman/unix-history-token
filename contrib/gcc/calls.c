begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert function calls to rtl insns, for GNU C compiler.    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998    1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"sbitmap.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
name|FUNCTION_OK_FOR_SIBCALL
end_if

begin_define
define|#
directive|define
name|FUNCTION_OK_FOR_SIBCALL
parameter_list|(
name|DECL
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Decide whether a function's arguments should be processed    from first to last or from last to first.     They should if the stack and args grow in opposite directions, but    only if we have push insns.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STACK_GROWS_DOWNWARD
argument_list|)
operator|!=
name|defined
argument_list|(
name|ARGS_GROW_DOWNWARD
argument_list|)
end_if

begin_define
define|#
directive|define
name|PUSH_ARGS_REVERSED
value|PUSH_ARGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
end_ifndef

begin_define
define|#
directive|define
name|PUSH_ARGS_REVERSED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_POINTER_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|STACK_POINTER_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */
end_comment

begin_define
define|#
directive|define
name|STACK_BYTES
value|(PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)
end_define

begin_comment
comment|/* Data structure and subroutines used within expand_call.  */
end_comment

begin_struct
struct|struct
name|arg_data
block|{
comment|/* Tree node for this argument.  */
name|tree
name|tree_value
decl_stmt|;
comment|/* Mode for value; TYPE_MODE unless promoted.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Current RTL value for argument, or 0 if it isn't precomputed.  */
name|rtx
name|value
decl_stmt|;
comment|/* Initially-compute RTL value for argument; only for const functions.  */
name|rtx
name|initial_value
decl_stmt|;
comment|/* Register to pass this argument in, 0 if passed on stack, or an      PARALLEL if the arg is to be copied into multiple non-contiguous      registers.  */
name|rtx
name|reg
decl_stmt|;
comment|/* Register to pass this argument in when generating tail call sequence.      This is not the same register as for normal calls on machines with      register windows.  */
name|rtx
name|tail_call_reg
decl_stmt|;
comment|/* If REG was promoted from the actual mode of the argument expression,      indicates whether the promotion is sign- or zero-extended.  */
name|int
name|unsignedp
decl_stmt|;
comment|/* Number of registers to use.  0 means put the whole arg in registers.      Also 0 if not passed in registers.  */
name|int
name|partial
decl_stmt|;
comment|/* Non-zero if argument must be passed on stack.      Note that some arguments may be passed on the stack      even though pass_on_stack is zero, just because FUNCTION_ARG says so.      pass_on_stack identifies arguments that *cannot* go in registers.  */
name|int
name|pass_on_stack
decl_stmt|;
comment|/* Offset of this argument from beginning of stack-args.  */
name|struct
name|args_size
name|offset
decl_stmt|;
comment|/* Similar, but offset to the start of the stack slot.  Different from      OFFSET if this arg pads downward.  */
name|struct
name|args_size
name|slot_offset
decl_stmt|;
comment|/* Size of this argument on the stack, rounded up for any padding it gets,      parts of the argument passed in registers do not count.      If REG_PARM_STACK_SPACE is defined, then register parms      are counted here as well.  */
name|struct
name|args_size
name|size
decl_stmt|;
comment|/* Location on the stack at which parameter should be stored.  The store      has already been done if STACK == VALUE.  */
name|rtx
name|stack
decl_stmt|;
comment|/* Location on the stack of the start of this argument slot.  This can      differ from STACK if this arg pads downward.  This location is known      to be aligned to FUNCTION_ARG_BOUNDARY.  */
name|rtx
name|stack_slot
decl_stmt|;
comment|/* Place that this stack area has been saved, if needed.  */
name|rtx
name|save_area
decl_stmt|;
comment|/* If an argument's alignment does not permit direct copying into registers,      copy in smaller-sized pieces into pseudos.  These are stored in a      block pointed to by this field.  The next field says how many      word-sized pseudos we made.  */
name|rtx
modifier|*
name|aligned_regs
decl_stmt|;
name|int
name|n_aligned_regs
decl_stmt|;
comment|/* The amount that the stack pointer needs to be adjusted to      force alignment for the next argument.  */
name|struct
name|args_size
name|alignment_pad
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A vector of one char per byte of stack space.  A byte if non-zero if    the corresponding stack location has been used.    This vector is used to prevent a function call within an argument from    clobbering any stack already set up.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stack_usage_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of STACK_USAGE_MAP.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|highest_outgoing_arg_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A bitmap of virtual-incoming stack space.  Bit is set if the corresponding    stack location's tail call argument has been already stored into the stack.    This bitmap is used to prevent sibling call optimization if function tries    to use parent's incoming argument slots when they have been already    overwritten with tail call arguments.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|stored_args_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack_arg_under_construction is nonzero when an argument may be    initialized with a constructor call (including a C function that    returns a BLKmode struct) and expand_call must take special action    to make sure the object being constructed does not overlap the    argument list for the constructor call.  */
end_comment

begin_decl_stmt
name|int
name|stack_arg_under_construction
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|calls_function
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|calls_function_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this is a call to a `const' function.  */
end_comment

begin_define
define|#
directive|define
name|ECF_CONST
value|1
end_define

begin_comment
comment|/* Nonzero if this is a call to a `volatile' function.  */
end_comment

begin_define
define|#
directive|define
name|ECF_NORETURN
value|2
end_define

begin_comment
comment|/* Nonzero if this is a call to malloc or a related function.  */
end_comment

begin_define
define|#
directive|define
name|ECF_MALLOC
value|4
end_define

begin_comment
comment|/* Nonzero if it is plausible that this is a call to alloca.  */
end_comment

begin_define
define|#
directive|define
name|ECF_MAY_BE_ALLOCA
value|8
end_define

begin_comment
comment|/* Nonzero if this is a call to a function that won't throw an exception.  */
end_comment

begin_define
define|#
directive|define
name|ECF_NOTHROW
value|16
end_define

begin_comment
comment|/* Nonzero if this is a call to setjmp or a related function.  */
end_comment

begin_define
define|#
directive|define
name|ECF_RETURNS_TWICE
value|32
end_define

begin_comment
comment|/* Nonzero if this is a call to `longjmp'.  */
end_comment

begin_define
define|#
directive|define
name|ECF_LONGJMP
value|64
end_define

begin_comment
comment|/* Nonzero if this is a syscall that makes a new process in the image of    the current one.  */
end_comment

begin_define
define|#
directive|define
name|ECF_FORK_OR_EXEC
value|128
end_define

begin_define
define|#
directive|define
name|ECF_SIBCALL
value|256
end_define

begin_comment
comment|/* Nonzero if this is a call to "pure" function (like const function,    but may read memory.  */
end_comment

begin_define
define|#
directive|define
name|ECF_PURE
value|512
end_define

begin_comment
comment|/* Nonzero if this is a call to a function that returns with the stack    pointer depressed.  */
end_comment

begin_define
define|#
directive|define
name|ECF_SP_DEPRESSED
value|1024
end_define

begin_comment
comment|/* Nonzero if this call is known to always return.  */
end_comment

begin_define
define|#
directive|define
name|ECF_ALWAYS_RETURN
value|2048
end_define

begin_comment
comment|/* Create libcall block around the call.  */
end_comment

begin_define
define|#
directive|define
name|ECF_LIBCALL_BLOCK
value|4096
end_define

begin_decl_stmt
specifier|static
name|void
name|emit_call_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|tree
operator|,
name|tree
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|CUMULATIVE_ARGS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|precompute_register_parameters
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|arg_data
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|store_one_arg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arg_data
operator|*
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_unaligned_arguments_into_pseudos
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arg_data
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finalize_must_preallocate
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|arg_data
operator|*
operator|,
expr|struct
name|args_size
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|precompute_arguments
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|arg_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compute_argument_block_size
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|args_size
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_argument_information
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|arg_data
operator|*
operator|,
expr|struct
name|args_size
operator|*
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|CUMULATIVE_ARGS
operator|*
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_argument_addresses
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arg_data
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|rtx_for_function_call
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_register_parameters
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arg_data
operator|*
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|emit_library_call_value_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|libcall_type
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|special_function_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flags_from_decl_or_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|try_to_integrate
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|rtx
operator|,
name|int
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_sibcall_argument_overlap_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_sibcall_argument_overlap
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|arg_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|combine_pending_stack_adjustment_and_call
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|args_size
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
end_ifdef

begin_decl_stmt
specifier|static
name|rtx
name|save_fixed_argument_area
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_fixed_argument_area
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* If WHICH is 1, return 1 if EXP contains a call to the built-in function    `alloca'.     If WHICH is 0, return 1 if EXP contains a call to any function.    Actually, we only need return 1 if evaluating EXP would require pushing    arguments on the stack, but that is too difficult to compute, so we just    assume any function call might require the stack.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|calls_function_save_exprs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|calls_function
parameter_list|(
name|exp
parameter_list|,
name|which
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|calls_function_save_exprs
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|calls_function_1
argument_list|(
name|exp
argument_list|,
name|which
argument_list|)
expr_stmt|;
name|calls_function_save_exprs
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Recursive function to do the work of above function.  */
end_comment

begin_function
specifier|static
name|int
name|calls_function_1
parameter_list|(
name|exp
parameter_list|,
name|which
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|class
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|first_rtl_op
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* If this code is language-specific, we don't know what it will do.  */
if|if
condition|(
operator|(
name|int
operator|)
name|code
operator|>=
name|NUM_TREE_CODES
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|which
operator|==
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|&&
operator|(
name|TYPE_RETURNS_STACK_DEPRESSED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
operator|(
name|special_function_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&
name|ECF_MAY_BE_ALLOCA
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|CONSTRUCTOR
case|:
block|{
name|tree
name|tem
decl_stmt|;
for|for
control|(
name|tem
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|tem
operator|!=
literal|0
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|calls_function_1
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|which
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|value_member
argument_list|(
name|exp
argument_list|,
name|calls_function_save_exprs
argument_list|)
condition|)
return|return
literal|0
return|;
name|calls_function_save_exprs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp
argument_list|,
name|calls_function_save_exprs
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|calls_function_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|which
argument_list|)
operator|)
return|;
case|case
name|BLOCK
case|:
block|{
name|tree
name|local
decl_stmt|;
name|tree
name|subblock
decl_stmt|;
for|for
control|(
name|local
operator|=
name|BLOCK_VARS
argument_list|(
name|exp
argument_list|)
init|;
name|local
condition|;
name|local
operator|=
name|TREE_CHAIN
argument_list|(
name|local
argument_list|)
control|)
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|local
argument_list|)
operator|!=
literal|0
operator|&&
name|calls_function_1
argument_list|(
name|DECL_INITIAL
argument_list|(
name|local
argument_list|)
argument_list|,
name|which
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|subblock
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|exp
argument_list|)
init|;
name|subblock
condition|;
name|subblock
operator|=
name|TREE_CHAIN
argument_list|(
name|subblock
argument_list|)
control|)
if|if
condition|(
name|calls_function_1
argument_list|(
name|subblock
argument_list|,
name|which
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|TREE_LIST
case|:
for|for
control|(
init|;
name|exp
operator|!=
literal|0
condition|;
name|exp
operator|=
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
control|)
if|if
condition|(
name|calls_function_1
argument_list|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|which
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|/* Only expressions, references, and blocks can contain calls.  */
if|if
condition|(
operator|!
name|IS_EXPR_CODE_CLASS
argument_list|(
name|class
argument_list|)
operator|&&
name|class
operator|!=
literal|'r'
operator|&&
name|class
operator|!=
literal|'b'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
operator|&&
name|calls_function_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|,
name|which
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Force FUNEXP into a form suitable for the address of a CALL,    and return that as an rtx.  Also load the static chain register    if FNDECL is a nested function.     CALL_FUSAGE points to a variable holding the prospective    CALL_INSN_FUNCTION_USAGE information.  */
end_comment

begin_function
name|rtx
name|prepare_call_address
parameter_list|(
name|funexp
parameter_list|,
name|fndecl
parameter_list|,
name|call_fusage
parameter_list|,
name|reg_parm_seen
parameter_list|,
name|sibcallp
parameter_list|)
name|rtx
name|funexp
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|rtx
modifier|*
name|call_fusage
decl_stmt|;
name|int
name|reg_parm_seen
decl_stmt|;
name|int
name|sibcallp
decl_stmt|;
block|{
name|rtx
name|static_chain_value
init|=
literal|0
decl_stmt|;
name|funexp
operator|=
name|protect_from_queue
argument_list|(
name|funexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
operator|!=
literal|0
condition|)
comment|/* Get possible static chain value for nested function in C.  */
name|static_chain_value
operator|=
name|lookup_static_chain
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Make a valid memory address and copy constants thru pseudo-regs,      but not for a constant address if -fno-function-cse.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|funexp
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
comment|/* If we are using registers for parameters, force the        function address into a register now.  */
name|funexp
operator|=
operator|(
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|reg_parm_seen
operator|)
condition|?
name|force_not_mem
argument_list|(
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|)
else|:
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sibcallp
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_FUNCTION_CSE
if|if
condition|(
name|optimize
operator|&&
operator|!
name|flag_no_function_cse
condition|)
ifdef|#
directive|ifdef
name|NO_RECURSIVE_FUNCTION_CSE
if|if
condition|(
name|fndecl
operator|!=
name|current_function_decl
condition|)
endif|#
directive|endif
name|funexp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|static_chain_value
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|static_chain_rtx
argument_list|,
name|static_chain_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|static_chain_rtx
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|static_chain_rtx
argument_list|)
expr_stmt|;
block|}
return|return
name|funexp
return|;
block|}
end_function

begin_comment
comment|/* Generate instructions to call function FUNEXP,    and optionally pop the results.    The CALL_INSN is the first insn generated.     FNDECL is the declaration node of the function.  This is given to the    macro RETURN_POPS_ARGS to determine whether this function pops its own args.     FUNTYPE is the data type of the function.  This is given to the macro    RETURN_POPS_ARGS to determine whether this function pops its own args.    We used to allow an identifier for library functions, but that doesn't    work when the return type is an aggregate type and the calling convention    says that the pointer to this aggregate is to be popped by the callee.     STACK_SIZE is the number of bytes of arguments on the stack,    ROUNDED_STACK_SIZE is that number rounded up to    PREFERRED_STACK_BOUNDARY; zero if the size is variable.  This is    both to put into the call insn and to generate explicit popping    code if necessary.     STRUCT_VALUE_SIZE is the number of bytes wanted in a structure value.    It is zero if this call doesn't want a structure value.     NEXT_ARG_REG is the rtx that results from executing      FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1)    just after all the args have had their registers assigned.    This could be whatever you like, but normally it is the first    arg-register beyond those used for args in this call,    or 0 if all the arg-registers are used in this call.    It is passed on to `gen_call' so you can put this info in the call insn.     VALREG is a hard register in which a value is returned,    or 0 if the call does not return a value.     OLD_INHIBIT_DEFER_POP is the value that `inhibit_defer_pop' had before    the args to this call were processed.    We restore `inhibit_defer_pop' to that value.     CALL_FUSAGE is either empty or an EXPR_LIST of USE expressions that    denote registers used by the called function.  */
end_comment

begin_function
specifier|static
name|void
name|emit_call_1
parameter_list|(
name|funexp
parameter_list|,
name|fndecl
parameter_list|,
name|funtype
parameter_list|,
name|stack_size
parameter_list|,
name|rounded_stack_size
parameter_list|,
name|struct_value_size
parameter_list|,
name|next_arg_reg
parameter_list|,
name|valreg
parameter_list|,
name|old_inhibit_defer_pop
parameter_list|,
name|call_fusage
parameter_list|,
name|ecf_flags
parameter_list|,
name|args_so_far
parameter_list|)
name|rtx
name|funexp
decl_stmt|;
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|funtype
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|stack_size
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|rounded_stack_size
decl_stmt|;
name|HOST_WIDE_INT
name|struct_value_size
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|next_arg_reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|valreg
decl_stmt|;
name|int
name|old_inhibit_defer_pop
decl_stmt|;
name|rtx
name|call_fusage
decl_stmt|;
name|int
name|ecf_flags
decl_stmt|;
name|CUMULATIVE_ARGS
modifier|*
name|args_so_far
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|rounded_stack_size_rtx
init|=
name|GEN_INT
argument_list|(
name|rounded_stack_size
argument_list|)
decl_stmt|;
name|rtx
name|call_insn
decl_stmt|;
name|int
name|already_popped
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|n_popped
init|=
name|RETURN_POPS_ARGS
argument_list|(
name|fndecl
argument_list|,
name|funtype
argument_list|,
name|stack_size
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_call
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_call_value
argument_list|)
name|rtx
name|struct_value_size_rtx
decl_stmt|;
name|struct_value_size_rtx
operator|=
name|GEN_INT
argument_list|(
name|struct_value_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CALL_POPS_ARGS
name|n_popped
operator|+=
name|CALL_POPS_ARGS
argument_list|(
operator|*
name|args_so_far
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Ensure address is valid.  SYMBOL_REF is already valid, so no need,      and we don't want to load it into a register as an optimization,      because prepare_call_address already did it if it should be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|funexp
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|funexp
operator|=
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_sibcall_pop
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_sibcall_value_pop
argument_list|)
if|if
condition|(
operator|(
name|ecf_flags
operator|&
name|ECF_SIBCALL
operator|)
operator|&&
name|HAVE_sibcall_pop
operator|&&
name|HAVE_sibcall_value_pop
operator|&&
operator|(
name|n_popped
operator|>
literal|0
operator|||
name|stack_size
operator|==
literal|0
operator|)
condition|)
block|{
name|rtx
name|n_pop
init|=
name|GEN_INT
argument_list|(
name|n_popped
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
comment|/* If this subroutine pops its own args, record that in the call insn 	 if possible, for the sake of frame pointer elimination.  */
if|if
condition|(
name|valreg
condition|)
name|pat
operator|=
name|GEN_SIBCALL_VALUE_POP
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|n_pop
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|GEN_SIBCALL_POP
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|n_pop
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|already_popped
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_call_pop
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_call_value_pop
argument_list|)
comment|/* If the target has "call" or "call_value" insns, then prefer them      if no arguments are actually popped.  If the target does not have      "call" or "call_value" insns, then we must use the popping versions      even if the call has no arguments to pop.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_call
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_call_value
argument_list|)
if|if
condition|(
name|HAVE_call
operator|&&
name|HAVE_call_value
operator|&&
name|HAVE_call_pop
operator|&&
name|HAVE_call_value_pop
operator|&&
name|n_popped
operator|>
literal|0
operator|&&
operator|!
operator|(
name|ecf_flags
operator|&
name|ECF_SP_DEPRESSED
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|HAVE_call_pop
operator|&&
name|HAVE_call_value_pop
condition|)
endif|#
directive|endif
block|{
name|rtx
name|n_pop
init|=
name|GEN_INT
argument_list|(
name|n_popped
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
comment|/* If this subroutine pops its own args, record that in the call insn 	 if possible, for the sake of frame pointer elimination.  */
if|if
condition|(
name|valreg
condition|)
name|pat
operator|=
name|GEN_CALL_VALUE_POP
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|n_pop
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|GEN_CALL_POP
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|n_pop
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|already_popped
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_sibcall
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_sibcall_value
argument_list|)
if|if
condition|(
operator|(
name|ecf_flags
operator|&
name|ECF_SIBCALL
operator|)
operator|&&
name|HAVE_sibcall
operator|&&
name|HAVE_sibcall_value
condition|)
block|{
if|if
condition|(
name|valreg
condition|)
name|emit_call_insn
argument_list|(
name|GEN_SIBCALL_VALUE
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_call_insn
argument_list|(
name|GEN_SIBCALL
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|struct_value_size_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_call
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_call_value
argument_list|)
if|if
condition|(
name|HAVE_call
operator|&&
name|HAVE_call_value
condition|)
block|{
if|if
condition|(
name|valreg
condition|)
name|emit_call_insn
argument_list|(
name|GEN_CALL_VALUE
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_call_insn
argument_list|(
name|GEN_CALL
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
argument_list|,
name|rounded_stack_size_rtx
argument_list|,
name|next_arg_reg
argument_list|,
name|struct_value_size_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the CALL insn we just emitted.  */
for|for
control|(
name|call_insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|call_insn
operator|&&
name|GET_CODE
argument_list|(
name|call_insn
argument_list|)
operator|!=
name|CALL_INSN
condition|;
name|call_insn
operator|=
name|PREV_INSN
argument_list|(
name|call_insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|call_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Mark memory as used for "pure" function call.  */
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_PURE
condition|)
name|call_fusage
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|call_fusage
argument_list|)
expr_stmt|;
comment|/* Put the register usage information on the CALL.  If there is already      some usage information, put ours at the end.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
init|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
empty_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
block|}
else|else
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
comment|/* If this is a const call, then set the insn's unchanging bit.  */
if|if
condition|(
name|ecf_flags
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
condition|)
name|CONST_OR_PURE_CALL_P
argument_list|(
name|call_insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this call can't throw, attach a REG_EH_REGION reg note to that      effect.  */
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_NOTHROW
condition|)
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_NORETURN
condition|)
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NORETURN
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_ALWAYS_RETURN
condition|)
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_ALWAYS_RETURN
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_RETURNS_TWICE
condition|)
block|{
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_SETJMP
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_calls_setjmp
operator|=
literal|1
expr_stmt|;
block|}
name|SIBLING_CALL_P
argument_list|(
name|call_insn
argument_list|)
operator|=
operator|(
operator|(
name|ecf_flags
operator|&
name|ECF_SIBCALL
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Restore this now, so that we do defer pops for this call's args      if the context of the call as a whole permits.  */
name|inhibit_defer_pop
operator|=
name|old_inhibit_defer_pop
expr_stmt|;
if|if
condition|(
name|n_popped
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|already_popped
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
argument_list|)
expr_stmt|;
name|rounded_stack_size
operator|-=
name|n_popped
expr_stmt|;
name|rounded_stack_size_rtx
operator|=
name|GEN_INT
argument_list|(
name|rounded_stack_size
argument_list|)
expr_stmt|;
name|stack_pointer_delta
operator|-=
name|n_popped
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* If returning from the subroutine does not automatically pop the args, 	 we need an instruction to pop them sooner or later. 	 Perhaps do it now; perhaps just record how much space to pop later.  	 If returning from the subroutine does pop the args, indicate that the 	 stack pointer will be changed.  */
if|if
condition|(
name|rounded_stack_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ecf_flags
operator|&
name|ECF_SP_DEPRESSED
condition|)
comment|/* Just pretend we did the pop.  */
name|stack_pointer_delta
operator|-=
name|rounded_stack_size
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_defer_pop
operator|&&
name|inhibit_defer_pop
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ecf_flags
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
operator|)
condition|)
name|pending_stack_adjust
operator|+=
name|rounded_stack_size
expr_stmt|;
else|else
name|adjust_stack
argument_list|(
name|rounded_stack_size_rtx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* When we accumulate outgoing args, we must avoid any stack manipulations.      Restore the stack pointer to its original value now.  Usually      ACCUMULATE_OUTGOING_ARGS targets don't get here, but there are exceptions.      On  i386 ACCUMULATE_OUTGOING_ARGS can be enabled on demand, and      popping variants of functions exist as well.       ??? We may optimize similar to defer_pop above, but it is      probably not worthwhile.       ??? It will be worthwhile to enable combine_stack_adjustments even for      such machines.  */
elseif|else
if|if
condition|(
name|n_popped
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|n_popped
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if the function identified by NAME and FNDECL is one with    special properties we wish to know about.     For example, if the function might return more than one time (setjmp), then    set RETURNS_TWICE to a nonzero value.     Similarly set LONGJMP for if the function is in the longjmp family.     Set MALLOC for any of the standard memory allocation functions which    allocate from the heap.     Set MAY_BE_ALLOCA for any memory allocation function that might allocate    space from the stack such as alloca.  */
end_comment

begin_function
specifier|static
name|int
name|special_function_p
parameter_list|(
name|fndecl
parameter_list|,
name|flags
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ECF_MALLOC
operator|)
operator|&&
name|fndecl
operator|&&
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|<=
literal|17
comment|/* Exclude functions not at the file scope, or not `extern', 	 since they are not the magic functions we would otherwise 	 think they are.  */
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_PUBLIC
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
init|=
name|name
decl_stmt|;
comment|/* We assume that alloca will always be called by name.  It 	 makes no sense to pass it as a pointer-to-function to 	 anything that does not understand its behavior.  */
if|if
condition|(
operator|(
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|6
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'a'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"alloca"
argument_list|)
operator|)
operator|||
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|16
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_alloca"
argument_list|)
operator|)
operator|)
condition|)
name|flags
operator||=
name|ECF_MAY_BE_ALLOCA
expr_stmt|;
comment|/* Disregard prefix _, __ or __x.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'x'
condition|)
name|tname
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
name|tname
operator|+=
literal|2
expr_stmt|;
else|else
name|tname
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
operator|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"setjmp"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"setjmp_syscall"
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"sigsetjmp"
argument_list|)
operator|)
operator|||
operator|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"savectx"
argument_list|)
operator|)
condition|)
name|flags
operator||=
name|ECF_RETURNS_TWICE
expr_stmt|;
if|if
condition|(
name|tname
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"siglongjmp"
argument_list|)
condition|)
name|flags
operator||=
name|ECF_LONGJMP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'q'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"qsetjmp"
argument_list|)
operator|)
operator|||
operator|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'v'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"vfork"
argument_list|)
operator|)
condition|)
name|flags
operator||=
name|ECF_RETURNS_TWICE
expr_stmt|;
elseif|else
if|if
condition|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'l'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"longjmp"
argument_list|)
condition|)
name|flags
operator||=
name|ECF_LONGJMP
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"fork"
argument_list|)
operator|)
comment|/* Linux specific: __clone.  check NAME to insist on the 		  leading underscores, to avoid polluting the ISO / POSIX 		  namespace.  */
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"clone"
argument_list|)
operator|)
operator|||
operator|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|tname
index|[
literal|1
index|]
operator|==
literal|'x'
operator|&&
name|tname
index|[
literal|2
index|]
operator|==
literal|'e'
operator|&&
name|tname
index|[
literal|3
index|]
operator|==
literal|'c'
operator|&&
operator|(
name|tname
index|[
literal|4
index|]
operator|==
literal|'l'
operator|||
name|tname
index|[
literal|4
index|]
operator|==
literal|'v'
operator|)
operator|&&
operator|(
name|tname
index|[
literal|5
index|]
operator|==
literal|'\0'
operator|||
operator|(
operator|(
name|tname
index|[
literal|5
index|]
operator|==
literal|'p'
operator|||
name|tname
index|[
literal|5
index|]
operator|==
literal|'e'
operator|)
operator|&&
name|tname
index|[
literal|6
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
name|flags
operator||=
name|ECF_FORK_OR_EXEC
expr_stmt|;
comment|/* Do not add any more malloc-like functions to this list,          instead mark them as malloc functions using the malloc attribute.          Note, realloc is not suitable for attribute malloc since          it may return the same address across multiple calls.          C++ operator new is not suitable because it is not required          to return a unique pointer; indeed, the standard placement new 	 just returns its argument.  */
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|Pmode
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"malloc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"calloc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"strdup"
argument_list|)
operator|)
condition|)
name|flags
operator||=
name|ECF_MALLOC
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero when tree represent call to longjmp.  */
end_comment

begin_function
name|int
name|setjmp_call_p
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
return|return
name|special_function_p
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
operator|&
name|ECF_RETURNS_TWICE
return|;
block|}
end_function

begin_comment
comment|/* Detect flags (function attributes) from the function decl or type node.  */
end_comment

begin_function
specifier|static
name|int
name|flags_from_decl_or_type
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|tree
name|type
init|=
name|exp
decl_stmt|;
comment|/* ??? We can't set IS_MALLOC for function types?  */
if|if
condition|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* The function exp may have the `malloc' attribute.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
operator|&&
name|DECL_IS_MALLOC
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_MALLOC
expr_stmt|;
comment|/* The function exp may have the `pure' attribute.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
operator|&&
name|DECL_IS_PURE
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_PURE
operator||
name|ECF_LIBCALL_BLOCK
expr_stmt|;
if|if
condition|(
name|TREE_NOTHROW
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_NOTHROW
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_CONST
operator||
name|ECF_LIBCALL_BLOCK
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_NORETURN
expr_stmt|;
comment|/* Mark if the function returns with the stack pointer depressed.   We      cannot consider it pure or constant in that case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TYPE_RETURNS_STACK_DEPRESSED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|flags
operator||=
name|ECF_SP_DEPRESSED
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|ECF_PURE
operator||
name|ECF_CONST
operator||
name|ECF_LIBCALL_BLOCK
operator|)
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Precompute all register parameters as described by ARGS, storing values    into fields within the ARGS array.     NUM_ACTUALS indicates the total number elements in the ARGS array.     Set REG_PARM_SEEN if we encounter a register parameter.  */
end_comment

begin_function
specifier|static
name|void
name|precompute_register_parameters
parameter_list|(
name|num_actuals
parameter_list|,
name|args
parameter_list|,
name|reg_parm_seen
parameter_list|)
name|int
name|num_actuals
decl_stmt|;
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|int
modifier|*
name|reg_parm_seen
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
operator|*
name|reg_parm_seen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
block|{
operator|*
name|reg_parm_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|value
operator|==
literal|0
condition|)
block|{
name|push_temp_slots
argument_list|()
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|expand_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* ANSI doesn't require a sequence point here, 	       but PCC has one, so this will avoid some problems.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
comment|/* If we are to promote the function arg to a wider mode, 	   do it now.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|convert_modes
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* If the value is expensive, and we are inside an appropriately 	   short loop, put the value into a pseudo and then put the pseudo 	   into the hard reg.  	   For small register classes, also do this if this call uses 	   register parameters.  This is to avoid reload conflicts while 	   loading the parameters registers.  */
if|if
condition|(
operator|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|)
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|!=
name|BLKmode
operator|&&
name|rtx_cost
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|SET
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|&&
operator|(
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
operator|*
name|reg_parm_seen
operator|)
operator|||
name|preserve_subexpressions_p
argument_list|()
operator|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|copy_to_mode_reg
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
end_ifdef

begin_comment
comment|/* The argument list is the property of the called routine and it      may clobber it.  If the fixed area has been used for previous      parameters, we must save and restore it.  */
end_comment

begin_function
specifier|static
name|rtx
name|save_fixed_argument_area
parameter_list|(
name|reg_parm_stack_space
parameter_list|,
name|argblock
parameter_list|,
name|low_to_save
parameter_list|,
name|high_to_save
parameter_list|)
name|int
name|reg_parm_stack_space
decl_stmt|;
name|rtx
name|argblock
decl_stmt|;
name|int
modifier|*
name|low_to_save
decl_stmt|;
name|int
modifier|*
name|high_to_save
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|save_area
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Compute the boundary of the that needs to be saved, if any.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg_parm_stack_space
operator|+
literal|1
condition|;
name|i
operator|++
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg_parm_stack_space
condition|;
name|i
operator|++
control|)
endif|#
directive|endif
block|{
if|if
condition|(
name|i
operator|>=
name|highest_outgoing_arg_in_use
operator|||
name|stack_usage_map
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|*
name|low_to_save
operator|==
operator|-
literal|1
condition|)
operator|*
name|low_to_save
operator|=
name|i
expr_stmt|;
operator|*
name|high_to_save
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|low_to_save
operator|>=
literal|0
condition|)
block|{
name|int
name|num_to_save
init|=
operator|*
name|high_to_save
operator|-
operator|*
name|low_to_save
operator|+
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|num_to_save
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
decl_stmt|;
comment|/* If we don't have the required alignment, must do this in BLKmode.  */
if|if
condition|(
operator|(
operator|*
name|low_to_save
operator|&
operator|(
name|MIN
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|save_mode
argument_list|)
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|UNITS_PER_WORD
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|save_mode
operator|=
name|BLKmode
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
operator|*
name|high_to_save
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|*
name|low_to_save
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_mem_align
argument_list|(
name|stack_area
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_mode
operator|==
name|BLKmode
condition|)
block|{
name|save_area
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|num_to_save
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Cannot use emit_block_move here because it can be done by a 	     library call which in turn gets into this place again and deadly 	     infinite recursion happens.  */
name|move_by_pieces
argument_list|(
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|stack_area
argument_list|,
name|num_to_save
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|save_area
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_fixed_argument_area
parameter_list|(
name|save_area
parameter_list|,
name|argblock
parameter_list|,
name|high_to_save
parameter_list|,
name|low_to_save
parameter_list|)
name|rtx
name|save_area
decl_stmt|;
name|rtx
name|argblock
decl_stmt|;
name|int
name|high_to_save
decl_stmt|;
name|int
name|low_to_save
decl_stmt|;
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|save_area
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
name|high_to_save
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|low_to_save
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|save_mode
operator|!=
name|BLKmode
condition|)
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|save_area
argument_list|)
expr_stmt|;
else|else
comment|/* Cannot use emit_block_move here because it can be done by a library        call which in turn gets into this place again and deadly infinite        recursion happens.  */
name|move_by_pieces
argument_list|(
name|stack_area
argument_list|,
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|high_to_save
operator|-
name|low_to_save
operator|+
literal|1
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REG_PARM_STACK_SPACE */
end_comment

begin_comment
comment|/* If any elements in ARGS refer to parameters that are to be passed in    registers, but not in memory, and whose alignment does not permit a    direct copy into registers.  Copy the values into a group of pseudos    which we will later copy into the appropriate hard registers.     Pseudos for each unaligned argument will be stored into the array    args[argnum].aligned_regs.  The caller is responsible for deallocating    the aligned_regs array if it is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|store_unaligned_arguments_into_pseudos
parameter_list|(
name|args
parameter_list|,
name|num_actuals
parameter_list|)
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|int
name|num_actuals
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|BLKmode
operator|&&
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|BITS_PER_WORD
argument_list|)
operator|)
condition|)
block|{
name|int
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|big_endian_correction
init|=
literal|0
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
operator|=
name|args
index|[
name|i
index|]
operator|.
name|partial
condition|?
name|args
index|[
name|i
index|]
operator|.
name|partial
else|:
operator|(
name|bytes
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
argument_list|)
expr_stmt|;
comment|/* Structures smaller than a word are aligned to the least 	   significant byte (to the right).  On a BYTES_BIG_ENDIAN machine, 	   this means we must skip the empty high order bytes when 	   calculating the bit offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
operator|!
name|FUNCTION_ARG_REG_LITTLE_ENDIAN
operator|&&
name|bytes
operator|<
name|UNITS_PER_WORD
condition|)
name|big_endian_correction
operator|=
operator|(
name|BITS_PER_WORD
operator|-
operator|(
name|bytes
operator|*
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|rtx
name|word
init|=
name|operand_subword_force
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|j
argument_list|,
name|BLKmode
argument_list|)
decl_stmt|;
name|int
name|bitsize
init|=
name|MIN
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
index|[
name|j
index|]
operator|=
name|reg
expr_stmt|;
comment|/* There is no need to restrict this code to loading items 	       in TYPE_ALIGN sized hunks.  The bitfield instructions can 	       load up entire word sized registers efficiently.  	       ??? This may not be needed anymore. 	       We use to emit a clobber here but that doesn't let later 	       passes optimize the instructions we emit.  By storing 0 into 	       the register later passes know the first AND to zero out the 	       bitfield being set in the register is unnecessary.  The store 	       of 0 will be deleted as will at least the first AND.  */
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|bitsize
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|store_bit_field
argument_list|(
name|reg
argument_list|,
name|bitsize
argument_list|,
name|big_endian_correction
argument_list|,
name|word_mode
argument_list|,
name|extract_bit_field
argument_list|(
name|word
argument_list|,
name|bitsize
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|,
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Fill in ARGS_SIZE and ARGS array based on the parameters found in    ACTPARMS.     NUM_ACTUALS is the total number of parameters.     N_NAMED_ARGS is the total number of named arguments.     FNDECL is the tree code for the target of this call (if known)     ARGS_SO_FAR holds state needed by the target to know where to place    the next argument.     REG_PARM_STACK_SPACE is the number of bytes of stack space reserved    for arguments which are passed in registers.     OLD_STACK_LEVEL is a pointer to an rtx which olds the old stack level    and may be modified by this routine.     OLD_PENDING_ADJ, MUST_PREALLOCATE and FLAGS are pointers to integer    flags which may may be modified by this routine.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_argument_information
parameter_list|(
name|num_actuals
parameter_list|,
name|args
parameter_list|,
name|args_size
parameter_list|,
name|n_named_args
parameter_list|,
name|actparms
parameter_list|,
name|fndecl
parameter_list|,
name|args_so_far
parameter_list|,
name|reg_parm_stack_space
parameter_list|,
name|old_stack_level
parameter_list|,
name|old_pending_adj
parameter_list|,
name|must_preallocate
parameter_list|,
name|ecf_flags
parameter_list|)
name|int
name|num_actuals
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|struct
name|args_size
modifier|*
name|args_size
decl_stmt|;
name|int
name|n_named_args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|actparms
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|CUMULATIVE_ARGS
modifier|*
name|args_so_far
decl_stmt|;
name|int
name|reg_parm_stack_space
decl_stmt|;
name|rtx
modifier|*
name|old_stack_level
decl_stmt|;
name|int
modifier|*
name|old_pending_adj
decl_stmt|;
name|int
modifier|*
name|must_preallocate
decl_stmt|;
name|int
modifier|*
name|ecf_flags
decl_stmt|;
block|{
comment|/* 1 if scanning parms front to back, -1 if scanning back to front.  */
name|int
name|inc
decl_stmt|;
comment|/* Count arg position in order args appear.  */
name|int
name|argpos
decl_stmt|;
name|struct
name|args_size
name|alignment_pad
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|p
decl_stmt|;
name|args_size
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
name|args_size
operator|->
name|var
operator|=
literal|0
expr_stmt|;
comment|/* In this loop, we consider args in the order they are written.      We fill up ARGS from the front or from the back if necessary      so that in any case the first arg to be pushed ends up at the front.  */
if|if
condition|(
name|PUSH_ARGS_REVERSED
condition|)
block|{
name|i
operator|=
name|num_actuals
operator|-
literal|1
operator|,
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* In this case, must reverse order of args 	 so that we compute and push the last arg first.  */
block|}
else|else
block|{
name|i
operator|=
literal|0
operator|,
name|inc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* I counts args in order (to be) pushed; ARGPOS counts in order written.  */
for|for
control|(
name|p
operator|=
name|actparms
operator|,
name|argpos
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|,
name|i
operator|+=
name|inc
operator|,
name|argpos
operator|++
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Replace erroneous argument with constant zero.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|integer_zero_node
operator|,
name|type
operator|=
name|integer_type_node
expr_stmt|;
comment|/* If TYPE is a transparent union, pass things the way we would 	 pass the first field of the union.  We have already verified that 	 the modes are the same.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decide where to pass this arg.  	 args[i].reg is nonzero if all or part is passed in registers.  	 args[i].partial is nonzero if part but not all is passed in registers, 	 and the exact value says how many words are passed in registers.  	 args[i].pass_on_stack is nonzero if the argument must at least be 	 computed on the stack.  It may then be loaded back into registers 	 if args[i].reg is nonzero.  	 These decisions are driven by the FUNCTION_... macros and must agree 	 with those made by function.c.  */
comment|/* See if this argument should be passed by invisible reference.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|contains_placeholder_p
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PASS_BY_REFERENCE
operator|||
name|FUNCTION_ARG_PASS_BY_REFERENCE
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
endif|#
directive|endif
condition|)
block|{
comment|/* If we're compiling a thunk, pass through invisible              references instead of making a copy.  */
if|if
condition|(
name|current_function_is_thunk
ifdef|#
directive|ifdef
name|FUNCTION_ARG_CALLEE_COPIES
operator|||
operator|(
name|FUNCTION_ARG_CALLEE_COPIES
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
comment|/* If it's in a register, we must make a copy of it too.  */
comment|/* ??? Is this a sufficient test?  Is there a better one? */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* C++ uses a TARGET_EXPR to indicate that we want to make a 	         new object from the argument.  If we are passing by 	         invisible reference, the callee will do that for us, so we 	         can strip off the TARGET_EXPR.  This is not always safe, 	         but it is safe in the only case where this is a useful 	         optimization; namely, when the argument is a plain object. 	         In that case, the frontend is just asking the backend to 	         make a bitwise copy of the argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|TARGET_EXPR
operator|&&
operator|(
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|TREE_OPERAND
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
comment|/* In the V3 C++ ABI, parameters are destroyed in the caller. 		 We implement this by passing the address of the temporary 	         rather than expanding it into another allocated slot.  */
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We make a copy of the object and pass the address to the 		 function being called.  */
name|rtx
name|copy
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
operator|&&
operator|(
literal|0
operator|<
name|compare_tree_int
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|STACK_CHECK_MAX_VAR_SIZE
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* This is a variable-sized object.  Make space on the stack 		     for it.  */
name|rtx
name|size_rtx
init|=
name|expr_size
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|old_stack_level
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
operator|*
name|old_pending_adj
operator|=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
name|copy
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|allocate_dynamic_stack_space
argument_list|(
name|size_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|copy
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|copy
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ecf_flags
operator|&=
operator|~
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator||
name|ECF_LIBCALL_BLOCK
operator|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|copy
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_ARGS
name|mode
operator|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
index|[
name|i
index|]
operator|.
name|unsignedp
operator|=
name|unsignedp
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|FUNCTION_ARG
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
comment|/* If this is a sibling call and the machine has register windows, the 	 register window has to be unwinded before calling the routine, so 	 arguments have to go into the incoming registers.  */
name|args
index|[
name|i
index|]
operator|.
name|tail_call_reg
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
else|#
directive|else
name|args
index|[
name|i
index|]
operator|.
name|tail_call_reg
operator|=
name|args
index|[
name|i
index|]
operator|.
name|reg
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
condition|)
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|=
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|=
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* If FUNCTION_ARG returned a (parallel [(expr_list (nil) ...) ...]), 	 it means that we are to pass this arg in the register(s) designated 	 by the PARALLEL, but also to pass it in the stack.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|=
literal|1
expr_stmt|;
comment|/* If this is an addressable type, we must preallocate the stack 	 since we must evaluate the object into its final location.  	 If this is to be passed in both registers and the stack, it is simpler 	 to preallocate.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
operator|)
condition|)
operator|*
name|must_preallocate
operator|=
literal|1
expr_stmt|;
comment|/* If this is an addressable type, we cannot pre-evaluate it.  Thus, 	 we cannot consider this function call constant.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
operator|*
name|ecf_flags
operator|&=
operator|~
name|ECF_LIBCALL_BLOCK
expr_stmt|;
comment|/* Compute the stack-size of this argument.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|!=
literal|0
operator|||
name|reg_parm_stack_space
operator|>
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|locate_and_pad_parm
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
literal|1
argument_list|,
else|#
directive|else
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
name|fndecl
argument_list|,
name|args_size
argument_list|,
operator|&
name|args
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
operator|&
name|args
index|[
name|i
index|]
operator|.
name|size
argument_list|,
operator|&
name|alignment_pad
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ARGS_GROW_DOWNWARD
name|args
index|[
name|i
index|]
operator|.
name|slot_offset
operator|=
operator|*
name|args_size
expr_stmt|;
endif|#
directive|endif
name|args
index|[
name|i
index|]
operator|.
name|alignment_pad
operator|=
name|alignment_pad
expr_stmt|;
comment|/* If a part of the arg was put into registers, 	 don't include that part in the amount pushed.  */
if|if
condition|(
name|reg_parm_stack_space
operator|==
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|constant
operator|-=
operator|(
operator|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|*
name|UNITS_PER_WORD
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* Update ARGS_SIZE, the total stack space for args so far.  */
name|args_size
operator|->
name|constant
operator|+=
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|var
condition|)
block|{
name|ADD_PARM_SIZE
argument_list|(
operator|*
name|args_size
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|var
argument_list|)
expr_stmt|;
block|}
comment|/* Since the slot offset points to the bottom of the slot, 	 we must record it after incrementing if the args grow down.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|args
index|[
name|i
index|]
operator|.
name|slot_offset
operator|=
operator|*
name|args_size
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|slot_offset
operator|.
name|constant
operator|=
operator|-
name|args_size
operator|->
name|constant
expr_stmt|;
if|if
condition|(
name|args_size
operator|->
name|var
condition|)
name|SUB_PARM_SIZE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|slot_offset
argument_list|,
name|args_size
operator|->
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Increment ARGS_SO_FAR, which has info about which arg-registers 	 have been used, etc.  */
name|FUNCTION_ARG_ADVANCE
argument_list|(
operator|*
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|argpos
operator|<
name|n_named_args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update ARGS_SIZE to contain the total size for the argument block.    Return the original constant component of the argument block's size.     REG_PARM_STACK_SPACE holds the number of bytes of stack space reserved    for arguments passed in registers.  */
end_comment

begin_function
specifier|static
name|int
name|compute_argument_block_size
parameter_list|(
name|reg_parm_stack_space
parameter_list|,
name|args_size
parameter_list|,
name|preferred_stack_boundary
parameter_list|)
name|int
name|reg_parm_stack_space
decl_stmt|;
name|struct
name|args_size
modifier|*
name|args_size
decl_stmt|;
name|int
name|preferred_stack_boundary
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|unadjusted_args_size
init|=
name|args_size
operator|->
name|constant
decl_stmt|;
comment|/* For accumulate outgoing args mode we don't need to align, since the frame      will be already aligned.  Align to STACK_BOUNDARY in order to prevent      backends from generating misaligned frame sizes.  */
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|preferred_stack_boundary
operator|>
name|STACK_BOUNDARY
condition|)
name|preferred_stack_boundary
operator|=
name|STACK_BOUNDARY
expr_stmt|;
comment|/* Compute the actual size of the argument block required.  The variable      and constant sizes must be combined, the size may have to be rounded,      and there may be a minimum required size.  */
if|if
condition|(
name|args_size
operator|->
name|var
condition|)
block|{
name|args_size
operator|->
name|var
operator|=
name|ARGS_SIZE_TREE
argument_list|(
operator|*
name|args_size
argument_list|)
expr_stmt|;
name|args_size
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
name|preferred_stack_boundary
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|preferred_stack_boundary
operator|>
literal|1
condition|)
block|{
comment|/* We don't handle this case yet.  To handle it correctly we have 	     to add the delta, round and subtract the delta. 	     Currently no machine description requires this support.  */
if|if
condition|(
name|stack_pointer_delta
operator|&
operator|(
name|preferred_stack_boundary
operator|-
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|args_size
operator|->
name|var
operator|=
name|round_up
argument_list|(
name|args_size
operator|->
name|var
argument_list|,
name|preferred_stack_boundary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_parm_stack_space
operator|>
literal|0
condition|)
block|{
name|args_size
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|args_size
operator|->
name|var
argument_list|,
name|ssize_int
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
comment|/* The area corresponding to register parameters is not to count in 	     the size of the block we need.  So make the adjustment.  */
name|args_size
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|args_size
operator|->
name|var
argument_list|,
name|ssize_int
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|preferred_stack_boundary
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|preferred_stack_boundary
operator|<
literal|1
condition|)
name|preferred_stack_boundary
operator|=
literal|1
expr_stmt|;
name|args_size
operator|->
name|constant
operator|=
operator|(
operator|(
operator|(
name|args_size
operator|->
name|constant
operator|+
name|stack_pointer_delta
operator|+
name|preferred_stack_boundary
operator|-
literal|1
operator|)
operator|/
name|preferred_stack_boundary
operator|*
name|preferred_stack_boundary
operator|)
operator|-
name|stack_pointer_delta
operator|)
expr_stmt|;
name|args_size
operator|->
name|constant
operator|=
name|MAX
argument_list|(
name|args_size
operator|->
name|constant
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
if|if
condition|(
name|reg_parm_stack_space
operator|==
literal|0
condition|)
name|args_size
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
name|args_size
operator|->
name|constant
operator|-=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|unadjusted_args_size
return|;
block|}
end_function

begin_comment
comment|/* Precompute parameters as needed for a function call.     FLAGS is mask of ECF_* constants.     NUM_ACTUALS is the number of arguments.     ARGS is an array containing information for each argument; this    routine fills in the INITIAL_VALUE and VALUE fields for each    precomputed argument.  */
end_comment

begin_function
specifier|static
name|void
name|precompute_arguments
parameter_list|(
name|flags
parameter_list|,
name|num_actuals
parameter_list|,
name|args
parameter_list|)
name|int
name|flags
decl_stmt|;
name|int
name|num_actuals
decl_stmt|;
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* If this function call is cse'able, precompute all the parameters.      Note that if the parameter is constructed into a temporary, this will      cause an additional copy because the parameter will be constructed      into a temporary location and then copied into the outgoing arguments.      If a parameter contains a call to alloca and this function uses the      stack, precompute the parameter.  */
comment|/* If we preallocated the stack space, and some arguments must be passed      on the stack, then we must precompute any parameter which contains a      function call which will store arguments on the stack.      Otherwise, evaluating the parameter may clobber previous parameters      which have already been stored into the stack.  (we have code to avoid      such case by saving the outgoing stack arguments, but it results in      worse code)  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
operator|)
operator|||
name|calls_function
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
operator|!
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* If this is an addressable type, we cannot pre-evaluate it.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|expand_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ANSI doesn't require a sequence point here, 	   but PCC has one, so this will avoid some problems.  */
name|emit_queue
argument_list|()
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|initial_value
operator|=
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|protect_from_queue
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|args
index|[
name|i
index|]
operator|.
name|mode
condition|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
name|convert_modes
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|mode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|unsignedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FOR_CALL_ONLY
comment|/* CSE will replace this only if it contains args[i].value 	       pseudo, so convert it down to the declared mode using 	       a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|initial_value
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|initial_value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|initial_value
argument_list|)
operator|=
name|args
index|[
name|i
index|]
operator|.
name|unsignedp
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given the current state of MUST_PREALLOCATE and information about    arguments to a function call in NUM_ACTUALS, ARGS and ARGS_SIZE,    compute and return the final value for MUST_PREALLOCATE.  */
end_comment

begin_function
specifier|static
name|int
name|finalize_must_preallocate
parameter_list|(
name|must_preallocate
parameter_list|,
name|num_actuals
parameter_list|,
name|args
parameter_list|,
name|args_size
parameter_list|)
name|int
name|must_preallocate
decl_stmt|;
name|int
name|num_actuals
decl_stmt|;
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|struct
name|args_size
modifier|*
name|args_size
decl_stmt|;
block|{
comment|/* See if we have or want to preallocate stack space.       If we would have to push a partially-in-regs parm      before other stack parms, preallocate stack space instead.       If the size of some parm is not a multiple of the required stack      alignment, we must preallocate.       If the total size of arguments that would otherwise create a copy in      a temporary (such as a CALL) is more than half the total argument list      size, preallocation is faster.       Another reason to preallocate is if we have a machine (like the m88k)      where stack alignment is required to be maintained between every      pair of insns, not just when the call is made.  However, we assume here      that such machines either do not have push insns (and hence preallocation      would occur anyway) or the problem is taken care of with      PUSH_ROUNDING.  */
if|if
condition|(
operator|!
name|must_preallocate
condition|)
block|{
name|int
name|partial_seen
init|=
literal|0
decl_stmt|;
name|int
name|copy_to_evaluate_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
operator|&&
operator|!
name|must_preallocate
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|>
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|partial_seen
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|partial_seen
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
condition|)
name|must_preallocate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|CALL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|TARGET_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|)
condition|)
name|copy_to_evaluate_size
operator|+=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copy_to_evaluate_size
operator|*
literal|2
operator|>=
name|args_size
operator|->
name|constant
operator|&&
name|args_size
operator|->
name|constant
operator|>
literal|0
condition|)
name|must_preallocate
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|must_preallocate
return|;
block|}
end_function

begin_comment
comment|/* If we preallocated stack space, compute the address of each argument    and store it into the ARGS array.     We need not ensure it is a valid memory address here; it will be    validized when it is used.     ARGBLOCK is an rtx for the address of the outgoing arguments.  */
end_comment

begin_function
specifier|static
name|void
name|compute_argument_addresses
parameter_list|(
name|args
parameter_list|,
name|argblock
parameter_list|,
name|num_actuals
parameter_list|)
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|rtx
name|argblock
decl_stmt|;
name|int
name|num_actuals
decl_stmt|;
block|{
if|if
condition|(
name|argblock
condition|)
block|{
name|rtx
name|arg_reg
init|=
name|argblock
decl_stmt|;
name|int
name|i
decl_stmt|,
name|arg_offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|argblock
argument_list|)
operator|==
name|PLUS
condition|)
name|arg_reg
operator|=
name|XEXP
argument_list|(
name|argblock
argument_list|,
literal|0
argument_list|)
operator|,
name|arg_offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|argblock
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|offset
init|=
name|ARGS_SIZE_RTX
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
decl_stmt|;
name|rtx
name|slot_offset
init|=
name|ARGS_SIZE_RTX
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|slot_offset
argument_list|)
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* Skip this parm if it will not be passed on the stack.  */
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
operator|&&
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|arg_reg
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|arg_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|arg_offset
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|stack
operator|=
name|gen_rtx_MEM
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack
argument_list|,
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|slot_offset
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|arg_reg
argument_list|,
name|INTVAL
argument_list|(
name|slot_offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|arg_reg
argument_list|,
name|slot_offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|arg_offset
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
operator|=
name|gen_rtx_MEM
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
argument_list|,
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Function incoming arguments may overlap with sibling call 	     outgoing arguments and we cannot allow reordering of reads 	     from function arguments with stores to outgoing arguments 	     of sibling calls.  */
name|set_mem_alias_set
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a FNDECL and EXP, return an rtx suitable for use as a target address    in a call instruction.     FNDECL is the tree node for the target function.  For an indirect call    FNDECL will be NULL_TREE.     EXP is the CALL_EXPR for this call.  */
end_comment

begin_function
specifier|static
name|rtx
name|rtx_for_function_call
parameter_list|(
name|fndecl
parameter_list|,
name|exp
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|tree
name|exp
decl_stmt|;
block|{
name|rtx
name|funexp
decl_stmt|;
comment|/* Get the function to call, in the form of RTL.  */
if|if
condition|(
name|fndecl
condition|)
block|{
comment|/* If this is the first use of the function, see if we need to 	 make an external definition for it.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Get a SYMBOL_REF rtx for the function address.  */
name|funexp
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Generate an rtx (probably a pseudo-register) for the address.  */
block|{
name|rtx
name|funaddr
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|funaddr
operator|=
name|funexp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* FUNEXP can't be BLKmode.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
return|return
name|funexp
return|;
block|}
end_function

begin_comment
comment|/* Do the register loads required for any wholly-register parms or any    parms which are passed both on the stack and in a register.  Their    expressions were already evaluated.     Mark all register-parms as living through the call, putting these USE    insns in the CALL_INSN_FUNCTION_USAGE field.  */
end_comment

begin_function
specifier|static
name|void
name|load_register_parameters
parameter_list|(
name|args
parameter_list|,
name|num_actuals
parameter_list|,
name|call_fusage
parameter_list|,
name|flags
parameter_list|)
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
name|int
name|num_actuals
decl_stmt|;
name|rtx
modifier|*
name|call_fusage
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|LOAD_ARGS_REVERSED
for|for
control|(
name|i
operator|=
name|num_actuals
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
endif|#
directive|endif
block|{
name|rtx
name|reg
init|=
operator|(
operator|(
name|flags
operator|&
name|ECF_SIBCALL
operator|)
condition|?
name|args
index|[
name|i
index|]
operator|.
name|tail_call_reg
else|:
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|)
decl_stmt|;
name|int
name|partial
init|=
name|args
index|[
name|i
index|]
operator|.
name|partial
decl_stmt|;
name|int
name|nregs
decl_stmt|;
if|if
condition|(
name|reg
condition|)
block|{
comment|/* Set to non-negative if must move a word at a time, even if just 	     one word (e.g, partial == 1&& mode == DFmode).  Set to -1 if 	     we just use a normal move insn.  This value can be zero if the 	     argument is a zero size structure with no fields.  */
name|nregs
operator|=
operator|(
name|partial
condition|?
name|partial
else|:
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|?
operator|(
operator|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
else|:
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Handle calls that pass values in multiple non-contiguous 	     locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|reg
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If simple case, just do move.  If normal partial, store_one_arg 	     has already loaded the register for us.  In all other cases, 	     load the register(s) from memory.  */
elseif|else
if|if
condition|(
name|nregs
operator|==
operator|-
literal|1
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
comment|/* If we have pre-computed the values to put in the registers in 	     the case of non-aligned structures, copy them in now.  */
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
operator|!=
literal|0
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|args
index|[
name|i
index|]
operator|.
name|n_aligned_regs
condition|;
name|j
operator|++
control|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|j
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|partial
operator|==
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
name|move_block_to_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|value
argument_list|)
argument_list|,
name|nregs
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
comment|/* Handle calls that pass values in multiple non-contiguous 	     locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|use_group_regs
argument_list|(
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nregs
operator|==
operator|-
literal|1
condition|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
else|else
name|use_regs
argument_list|(
name|call_fusage
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|nregs
operator|==
literal|0
condition|?
literal|1
else|:
name|nregs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Try to integrate function.  See expand_inline_function for documentation    about the parameters.  */
end_comment

begin_function
specifier|static
name|rtx
name|try_to_integrate
parameter_list|(
name|fndecl
parameter_list|,
name|actparms
parameter_list|,
name|target
parameter_list|,
name|ignore
parameter_list|,
name|type
parameter_list|,
name|structure_value_addr
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|tree
name|actparms
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|rtx
name|structure_value_addr
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
name|rtx
name|before_call
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|old_stack_level
init|=
literal|0
decl_stmt|;
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|MAYBE_REG_PARM_STACK_SPACE
expr_stmt|;
else|#
directive|else
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|before_call
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_inline_function
argument_list|(
name|fndecl
argument_list|,
name|actparms
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|,
name|type
argument_list|,
name|structure_value_addr
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
comment|/* If inlining succeeded, return.  */
if|if
condition|(
name|temp
operator|!=
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* If the outgoing argument list must be preserved, push 	     the stack before executing the inlined function if it 	     makes any calls.  */
for|for
control|(
name|i
operator|=
name|reg_parm_stack_space
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|i
operator|<
name|highest_outgoing_arg_in_use
operator|&&
name|stack_usage_map
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|stack_arg_under_construction
operator|||
name|i
operator|>=
literal|0
condition|)
block|{
name|rtx
name|first_insn
init|=
name|before_call
condition|?
name|NEXT_INSN
argument_list|(
name|before_call
argument_list|)
else|:
name|get_insns
argument_list|()
decl_stmt|;
name|rtx
name|insn
init|=
name|NULL_RTX
decl_stmt|,
name|seq
decl_stmt|;
comment|/* Look for a call in the inline function code. 	         If DECL_SAVED_INSNS (fndecl)->outgoing_args_size is 	         nonzero then there is a call and it is not necessary 	         to scan the insns.  */
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|->
name|outgoing_args_size
operator|==
literal|0
condition|)
for|for
control|(
name|insn
operator|=
name|first_insn
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
if|if
condition|(
name|insn
condition|)
block|{
comment|/* Reserve enough stack space so that the largest 		     argument list of any function call in the inline 		     function does not overlap the argument list being 		     evaluated.  This is usually an overestimate because 		     allocate_dynamic_stack_space reserves space for an 		     outgoing argument list in addition to the requested 		     space, but there is no way to ask for stack space such 		     that an argument list of a certain length can be 		     safely constructed.  		     Add the stack space reserved for register arguments, if 		     any, in the inline function.  What is really needed is the 		     largest value of reg_parm_stack_space in the inline 		     function, but that is not available.  Using the current 		     value of reg_parm_stack_space is wrong, but gives 		     correct results on all supported machines.  */
name|int
name|adjust
init|=
operator|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|->
name|outgoing_args_size
operator|+
name|reg_parm_stack_space
operator|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|allocate_dynamic_stack_space
argument_list|(
name|GEN_INT
argument_list|(
name|adjust
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|first_insn
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If the result is equivalent to TARGET, return TARGET to simplify          checks in store_expr.  They can be equivalent but not equal in the          case of a function that returns BLKmode.  */
if|if
condition|(
name|temp
operator|!=
name|target
operator|&&
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
condition|)
return|return
name|target
return|;
return|return
name|temp
return|;
block|}
comment|/* If inlining failed, mark FNDECL as needing to be compiled      separately after all.  If function was declared inline,      give a warning.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|warn_inline
operator|&&
operator|!
name|flag_no_inline
operator|&&
name|optimize
operator|>
literal|0
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"inlining failed in call to `%s'"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"called from here"
argument_list|)
expr_stmt|;
block|}
name|mark_addressable
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
return|return
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* We need to pop PENDING_STACK_ADJUST bytes.  But, if the arguments    wouldn't fill up an even multiple of PREFERRED_UNIT_STACK_BOUNDARY    bytes, then we would need to push some additional bytes to pad the    arguments.  So, we compute an adjust to the stack pointer for an    amount that will leave the stack under-aligned by UNADJUSTED_ARGS_SIZE    bytes.  Then, when the arguments are pushed the stack will be perfectly    aligned.  ARGS_SIZE->CONSTANT is set to the number of bytes that should    be popped after the call.  Returns the adjustment.  */
end_comment

begin_function
specifier|static
name|int
name|combine_pending_stack_adjustment_and_call
parameter_list|(
name|unadjusted_args_size
parameter_list|,
name|args_size
parameter_list|,
name|preferred_unit_stack_boundary
parameter_list|)
name|int
name|unadjusted_args_size
decl_stmt|;
name|struct
name|args_size
modifier|*
name|args_size
decl_stmt|;
name|int
name|preferred_unit_stack_boundary
decl_stmt|;
block|{
comment|/* The number of bytes to pop so that the stack will be      under-aligned by UNADJUSTED_ARGS_SIZE bytes.  */
name|HOST_WIDE_INT
name|adjustment
decl_stmt|;
comment|/* The alignment of the stack after the arguments are pushed, if we      just pushed the arguments without adjust the stack here.  */
name|HOST_WIDE_INT
name|unadjusted_alignment
decl_stmt|;
name|unadjusted_alignment
operator|=
operator|(
operator|(
name|stack_pointer_delta
operator|+
name|unadjusted_args_size
operator|)
operator|%
name|preferred_unit_stack_boundary
operator|)
expr_stmt|;
comment|/* We want to get rid of as many of the PENDING_STACK_ADJUST bytes      as possible -- leaving just enough left to cancel out the      UNADJUSTED_ALIGNMENT.  In other words, we want to ensure that the      PENDING_STACK_ADJUST is non-negative, and congruent to      -UNADJUSTED_ALIGNMENT modulo the PREFERRED_UNIT_STACK_BOUNDARY.  */
comment|/* Begin by trying to pop all the bytes.  */
name|unadjusted_alignment
operator|=
operator|(
name|unadjusted_alignment
operator|-
operator|(
name|pending_stack_adjust
operator|%
name|preferred_unit_stack_boundary
operator|)
operator|)
expr_stmt|;
name|adjustment
operator|=
name|pending_stack_adjust
expr_stmt|;
comment|/* Push enough additional bytes that the stack will be aligned      after the arguments are pushed.  */
if|if
condition|(
name|preferred_unit_stack_boundary
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|unadjusted_alignment
operator|>
literal|0
condition|)
name|adjustment
operator|-=
name|preferred_unit_stack_boundary
operator|-
name|unadjusted_alignment
expr_stmt|;
else|else
name|adjustment
operator|+=
name|unadjusted_alignment
expr_stmt|;
block|}
comment|/* Now, sets ARGS_SIZE->CONSTANT so that we pop the right number of      bytes after the call.  The right number is the entire      PENDING_STACK_ADJUST less our ADJUSTMENT plus the amount required      by the arguments in the first place.  */
name|args_size
operator|->
name|constant
operator|=
name|pending_stack_adjust
operator|-
name|adjustment
operator|+
name|unadjusted_args_size
expr_stmt|;
return|return
name|adjustment
return|;
block|}
end_function

begin_comment
comment|/* Scan X expression if it does not dereference any argument slots    we already clobbered by tail call arguments (as noted in stored_args_map    bitmap).    Return non-zero if X expression dereferences such argument slots,    zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|check_sibcall_argument_overlap_1
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|k
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|i
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|i
operator|=
operator|-
name|i
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|i
operator|+
name|k
operator|<
name|stored_args_map
operator|->
name|n_bits
operator|&&
name|TEST_BIT
argument_list|(
name|stored_args_map
argument_list|,
name|i
operator|+
name|k
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/* Scan all subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|check_sibcall_argument_overlap_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|check_sibcall_argument_overlap_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Scan sequence after INSN if it does not dereference any argument slots    we already clobbered by tail call arguments (as noted in stored_args_map    bitmap).  Add stack slots for ARG to stored_args_map bitmap afterwards.    Return non-zero if sequence after INSN dereferences such argument slots,    zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|check_sibcall_argument_overlap
parameter_list|(
name|insn
parameter_list|,
name|arg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|arg_data
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
condition|)
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|check_sibcall_argument_overlap_1
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
break|break;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|low
operator|=
operator|-
name|arg
operator|->
name|slot_offset
operator|.
name|constant
operator|-
name|arg
operator|->
name|size
operator|.
name|constant
expr_stmt|;
else|#
directive|else
name|low
operator|=
name|arg
operator|->
name|slot_offset
operator|.
name|constant
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|high
operator|=
name|low
operator|+
name|arg
operator|->
name|size
operator|.
name|constant
init|;
name|low
operator|<
name|high
condition|;
name|low
operator|++
control|)
name|SET_BIT
argument_list|(
name|stored_args_map
argument_list|,
name|low
argument_list|)
expr_stmt|;
return|return
name|insn
operator|!=
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Generate all the code for a function call    and return an rtx for its value.    Store the value in TARGET (specified as an rtx) if convenient.    If the value is stored in TARGET then TARGET is returned.    If IGNORE is nonzero, then we ignore the value of the function call.  */
end_comment

begin_function
name|rtx
name|expand_call
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|ignore
decl_stmt|;
block|{
comment|/* Nonzero if we are currently expanding a call.  */
specifier|static
name|int
name|currently_expanding_call
init|=
literal|0
decl_stmt|;
comment|/* List of actual parameters.  */
name|tree
name|actparms
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* RTX for the function to be called.  */
name|rtx
name|funexp
decl_stmt|;
comment|/* Sequence of insns to perform a tail recursive "call".  */
name|rtx
name|tail_recursion_insns
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Sequence of insns to perform a normal "call".  */
name|rtx
name|normal_call_insns
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Sequence of insns to perform a tail recursive "call".  */
name|rtx
name|tail_call_insns
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Data type of the function.  */
name|tree
name|funtype
decl_stmt|;
comment|/* Declaration of the function being called,      or 0 if the function is computed (not known by name).  */
name|tree
name|fndecl
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|try_tail_call
init|=
literal|1
decl_stmt|;
name|int
name|try_tail_recursion
init|=
literal|1
decl_stmt|;
name|int
name|pass
decl_stmt|;
comment|/* Register in which non-BLKmode value will be returned,      or 0 if no value or if value is BLKmode.  */
name|rtx
name|valreg
decl_stmt|;
comment|/* Address where we should return a BLKmode value;      0 if value not BLKmode.  */
name|rtx
name|structure_value_addr
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if that address is being passed by treating it as      an extra, implicit first parameter.  Otherwise,      it is passed by being copied directly into struct_value_rtx.  */
name|int
name|structure_value_addr_parm
init|=
literal|0
decl_stmt|;
comment|/* Size of aggregate value wanted, or zero if none wanted      or if we are using the non-reentrant PCC calling convention      or expecting the value in registers.  */
name|HOST_WIDE_INT
name|struct_value_size
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if called function returns an aggregate in memory PCC style,      by returning the address of where to find it.  */
name|int
name|pcc_struct_value
init|=
literal|0
decl_stmt|;
comment|/* Number of actual parameters in this call, including struct value addr.  */
name|int
name|num_actuals
decl_stmt|;
comment|/* Number of named args.  Args after this are anonymous ones      and they must all go on the stack.  */
name|int
name|n_named_args
decl_stmt|;
comment|/* Vector of information about each argument.      Arguments are numbered in the order they will be pushed,      not the order they are written.  */
name|struct
name|arg_data
modifier|*
name|args
decl_stmt|;
comment|/* Total size in bytes of all the stack-parms scanned so far.  */
name|struct
name|args_size
name|args_size
decl_stmt|;
name|struct
name|args_size
name|adjusted_args_size
decl_stmt|;
comment|/* Size of arguments before any adjustments (such as rounding).  */
name|int
name|unadjusted_args_size
decl_stmt|;
comment|/* Data on reg parms scanned so far.  */
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
comment|/* Nonzero if a reg parm has been scanned.  */
name|int
name|reg_parm_seen
decl_stmt|;
comment|/* Nonzero if this is an indirect function call.  */
comment|/* Nonzero if we must avoid push-insns in the args for this call.      If stack space is allocated for register parameters, but not by the      caller, then it is preallocated in the fixed part of the stack frame.      So the entire argument block must then be preallocated (i.e., we      ignore PUSH_ROUNDING in that case).  */
name|int
name|must_preallocate
init|=
operator|!
name|PUSH_ARGS
decl_stmt|;
comment|/* Size of the stack reserved for parameter registers.  */
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
comment|/* Address of space preallocated for stack parms      (on machines that lack push insns), or 0 if space not preallocated.  */
name|rtx
name|argblock
init|=
literal|0
decl_stmt|;
comment|/* Mask of ECF_ flags.  */
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a call to an inline function.  */
name|int
name|is_integrable
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
comment|/* Define the boundary of the register parm stack space that needs to be      save, if any.  */
name|int
name|low_to_save
init|=
operator|-
literal|1
decl_stmt|,
name|high_to_save
decl_stmt|;
name|rtx
name|save_area
init|=
literal|0
decl_stmt|;
comment|/* Place that it is saved */
endif|#
directive|endif
name|int
name|initial_highest_arg_in_use
init|=
name|highest_outgoing_arg_in_use
decl_stmt|;
name|char
modifier|*
name|initial_stack_usage_map
init|=
name|stack_usage_map
decl_stmt|;
name|int
name|old_stack_arg_under_construction
init|=
literal|0
decl_stmt|;
name|rtx
name|old_stack_level
init|=
literal|0
decl_stmt|;
name|int
name|old_pending_adj
init|=
literal|0
decl_stmt|;
name|int
name|old_inhibit_defer_pop
init|=
name|inhibit_defer_pop
decl_stmt|;
name|int
name|old_stack_allocated
decl_stmt|;
name|rtx
name|call_fusage
decl_stmt|;
name|tree
name|p
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The alignment of the stack, in bits.  */
name|HOST_WIDE_INT
name|preferred_stack_boundary
decl_stmt|;
comment|/* The alignment of the stack, in bytes.  */
name|HOST_WIDE_INT
name|preferred_unit_stack_boundary
decl_stmt|;
comment|/* See if this is "nothrow" function call.  */
if|if
condition|(
name|TREE_NOTHROW
argument_list|(
name|exp
argument_list|)
condition|)
name|flags
operator||=
name|ECF_NOTHROW
expr_stmt|;
comment|/* See if we can find a DECL-node for the actual function.      As a result, decide whether this is a call to an integrable function.  */
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
if|if
condition|(
operator|!
name|flag_no_inline
operator|&&
name|fndecl
operator|!=
name|current_function_decl
operator|&&
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|->
name|inlinable
condition|)
name|is_integrable
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* In case this function later becomes inlinable, 	     record that there was already a non-inline call to it.  	     Use abstraction instead of setting TREE_ADDRESSABLE 	     directly.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|warn_inline
operator|&&
operator|!
name|flag_no_inline
operator|&&
name|optimize
operator|>
literal|0
condition|)
block|{
name|warning_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"can't inline call to `%s'"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"called from here"
argument_list|)
expr_stmt|;
block|}
name|mark_addressable
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
name|flags
operator||=
name|flags_from_decl_or_type
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't have specific function to call, see if we have a      attributes set in the type.  */
else|else
name|flags
operator||=
name|flags_from_decl_or_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|MAYBE_REG_PARM_STACK_SPACE
expr_stmt|;
else|#
directive|else
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
if|if
condition|(
name|reg_parm_stack_space
operator|>
literal|0
operator|&&
name|PUSH_ARGS
condition|)
name|must_preallocate
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Warn if this value is an aggregate type,      regardless of which calling convention we are using for it.  */
if|if
condition|(
name|warn_aggregate_return
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function call has aggregate value"
argument_list|)
expr_stmt|;
comment|/* Set up a place to return a structure.  */
comment|/* Cater to broken compilers.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|exp
argument_list|)
condition|)
block|{
comment|/* This call returns a big structure.  */
name|flags
operator|&=
operator|~
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator||
name|ECF_LIBCALL_BLOCK
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
block|{
name|pcc_struct_value
operator|=
literal|1
expr_stmt|;
comment|/* Easier than making that case work right.  */
if|if
condition|(
name|is_integrable
condition|)
block|{
comment|/* In case this is a static function, note that it has been 	       used.  */
if|if
condition|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|fndecl
argument_list|)
condition|)
name|mark_addressable
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|is_integrable
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* not PCC_STATIC_STRUCT_RETURN */
block|{
name|struct_value_size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|structure_value_addr
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* For variable-sized objects, we must be called with a target 	       specified.  If we were to allocate space on the stack here, 	       we would have no way of knowing when to free it.  */
name|rtx
name|d
init|=
name|assign_temp
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|mark_temp_addr_taken
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|structure_value_addr
operator|=
name|XEXP
argument_list|(
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not PCC_STATIC_STRUCT_RETURN */
block|}
comment|/* If called function is inline, try to integrate it.  */
if|if
condition|(
name|is_integrable
condition|)
block|{
name|rtx
name|temp
init|=
name|try_to_integrate
argument_list|(
name|fndecl
argument_list|,
name|actparms
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|structure_value_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|!=
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
operator|-
literal|1
condition|)
return|return
name|temp
return|;
block|}
comment|/* Figure out the amount to which the stack should be aligned.  */
name|preferred_stack_boundary
operator|=
name|PREFERRED_STACK_BOUNDARY
expr_stmt|;
comment|/* Operand 0 is a pointer-to-function; get the type of the function.  */
name|funtype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|funtype
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|funtype
operator|=
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
expr_stmt|;
comment|/* See if this is a call to a function that can return more than once      or a call to longjmp or malloc.  */
name|flags
operator||=
name|special_function_p
argument_list|(
name|fndecl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ECF_MAY_BE_ALLOCA
condition|)
name|current_function_calls_alloca
operator|=
literal|1
expr_stmt|;
comment|/* If struct_value_rtx is 0, it means pass the address      as if it were an extra parameter.  */
if|if
condition|(
name|structure_value_addr
operator|&&
name|struct_value_rtx
operator|==
literal|0
condition|)
block|{
comment|/* If structure_value_addr is a REG other than 	 virtual_outgoing_args_rtx, we can use always use it.  If it 	 is not a REG, we must always copy it into a register. 	 If it is virtual_outgoing_args_rtx, we must copy it to another 	 register in some cases.  */
name|rtx
name|temp
init|=
operator|(
name|GET_CODE
argument_list|(
name|structure_value_addr
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|stack_arg_under_construction
operator|&&
name|structure_value_addr
operator|==
name|virtual_outgoing_args_rtx
operator|)
condition|?
name|copy_addr_to_reg
argument_list|(
name|structure_value_addr
argument_list|)
else|:
name|structure_value_addr
operator|)
decl_stmt|;
name|actparms
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|make_tree
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|)
argument_list|,
name|actparms
argument_list|)
expr_stmt|;
name|structure_value_addr_parm
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Count the arguments and set NUM_ACTUALS.  */
for|for
control|(
name|p
operator|=
name|actparms
operator|,
name|num_actuals
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|num_actuals
operator|++
expr_stmt|;
comment|/* Compute number of named args.      Normally, don't include the last named arg if anonymous args follow.      We do include the last named arg if STRICT_ARGUMENT_NAMING is nonzero.      (If no anonymous args follow, the result of list_length is actually      one too large.  This is harmless.)       If PRETEND_OUTGOING_VARARGS_NAMED is set and STRICT_ARGUMENT_NAMING is      zero, this machine will be able to place unnamed args that were      passed in registers into the stack.  So treat all args as named.      This allows the insns emitting for a specific argument list to be      independent of the function declaration.       If PRETEND_OUTGOING_VARARGS_NAMED is not set, we do not have any      reliable way to pass unnamed args in registers, so we must force      them into memory.  */
if|if
condition|(
operator|(
name|STRICT_ARGUMENT_NAMING
operator|||
operator|!
name|PRETEND_OUTGOING_VARARGS_NAMED
operator|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
operator|!=
literal|0
condition|)
name|n_named_args
operator|=
operator|(
name|list_length
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
argument_list|)
comment|/* Don't include the last named arg.  */
operator|-
operator|(
name|STRICT_ARGUMENT_NAMING
condition|?
literal|0
else|:
literal|1
operator|)
comment|/* Count the struct value address, if it is passed as a parm.  */
operator|+
name|structure_value_addr_parm
operator|)
expr_stmt|;
else|else
comment|/* If we know nothing, treat all args as named.  */
name|n_named_args
operator|=
name|num_actuals
expr_stmt|;
comment|/* Start updating where the next arg would go.       On some machines (such as the PA) indirect calls have a different      calling convention than normal calls.  The last argument in      INIT_CUMULATIVE_ARGS tells the backend if this is an indirect call      or not.  */
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|funtype
argument_list|,
name|NULL_RTX
argument_list|,
operator|(
name|fndecl
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Make a vector to hold all the information about each arg.  */
name|args
operator|=
operator|(
expr|struct
name|arg_data
operator|*
operator|)
name|alloca
argument_list|(
name|num_actuals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg_data
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|args
argument_list|,
literal|0
argument_list|,
name|num_actuals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build up entries in the ARGS array, compute the size of the      arguments into ARGS_SIZE, etc.  */
name|initialize_argument_information
argument_list|(
name|num_actuals
argument_list|,
name|args
argument_list|,
operator|&
name|args_size
argument_list|,
name|n_named_args
argument_list|,
name|actparms
argument_list|,
name|fndecl
argument_list|,
operator|&
name|args_so_far
argument_list|,
name|reg_parm_stack_space
argument_list|,
operator|&
name|old_stack_level
argument_list|,
operator|&
name|old_pending_adj
argument_list|,
operator|&
name|must_preallocate
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|args_size
operator|.
name|var
condition|)
block|{
comment|/* If this function requires a variable-sized argument list, don't 	 try to make a cse'able block for this call.  We may be able to 	 do this eventually, but it is too complicated to keep track of 	 what insns go in the cse'able block and which don't.  */
name|flags
operator|&=
operator|~
name|ECF_LIBCALL_BLOCK
expr_stmt|;
name|must_preallocate
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now make final decision about preallocating stack space.  */
name|must_preallocate
operator|=
name|finalize_must_preallocate
argument_list|(
name|must_preallocate
argument_list|,
name|num_actuals
argument_list|,
name|args
argument_list|,
operator|&
name|args_size
argument_list|)
expr_stmt|;
comment|/* If the structure value address will reference the stack pointer, we      must stabilize it.  We don't need to do this if we know that we are      not going to adjust the stack pointer in processing this call.  */
if|if
condition|(
name|structure_value_addr
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|structure_value_addr
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|structure_value_addr
argument_list|)
operator|)
operator|&&
operator|(
name|args_size
operator|.
name|var
operator|||
operator|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|args_size
operator|.
name|constant
operator|)
operator|)
condition|)
name|structure_value_addr
operator|=
name|copy_to_reg
argument_list|(
name|structure_value_addr
argument_list|)
expr_stmt|;
comment|/* Tail calls can make things harder to debug, and we're traditionally      pushed these optimizations into -O2.  Don't try if we're already      expanding a call, as that means we're an argument.  Don't try if      there's cleanups, as we know there's code to follow the call.       If rtx_equal_function_value_matters is false, that means we've      finished with regular parsing.  Which means that some of the      machinery we use to generate tail-calls is no longer in place.      This is most often true of sjlj-exceptions, which we couldn't      tail-call to anyway.  */
if|if
condition|(
name|currently_expanding_call
operator|++
operator|!=
literal|0
operator|||
operator|!
name|flag_optimize_sibling_calls
operator|||
operator|!
name|rtx_equal_function_value_matters
operator|||
name|any_pending_cleanups
argument_list|(
literal|1
argument_list|)
operator|||
name|args_size
operator|.
name|var
condition|)
name|try_tail_call
operator|=
name|try_tail_recursion
operator|=
literal|0
expr_stmt|;
comment|/* Tail recursion fails, when we are not dealing with recursive calls.  */
if|if
condition|(
operator|!
name|try_tail_recursion
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ADDR_EXPR
operator|||
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|current_function_decl
condition|)
name|try_tail_recursion
operator|=
literal|0
expr_stmt|;
comment|/*  Rest of purposes for tail call optimizations to fail.  */
if|if
condition|(
ifdef|#
directive|ifdef
name|HAVE_sibcall_epilogue
operator|!
name|HAVE_sibcall_epilogue
else|#
directive|else
literal|1
endif|#
directive|endif
operator|||
operator|!
name|try_tail_call
comment|/* Doing sibling call optimization needs some work, since 	 structure_value_addr can be allocated on the stack. 	 It does not seem worth the effort since few optimizable 	 sibling calls will return a structure.  */
operator|||
name|structure_value_addr
operator|!=
name|NULL_RTX
comment|/* If the register holding the address is a callee saved 	 register, then we lose.  We have no way to prevent that, 	 so we only allow calls to named functions.  */
comment|/* ??? This could be done by having the insn constraints 	 use a register class that is all call-clobbered.  Any 	 reload insns generated to fix things up would appear 	 before the sibcall_epilogue.  */
operator|||
name|fndecl
operator|==
name|NULL_TREE
operator|||
operator|(
name|flags
operator|&
operator|(
name|ECF_RETURNS_TWICE
operator||
name|ECF_LONGJMP
operator|)
operator|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|fndecl
argument_list|)
operator|||
operator|!
name|FUNCTION_OK_FOR_SIBCALL
argument_list|(
name|fndecl
argument_list|)
comment|/* If this function requires more stack slots than the current 	 function, we cannot change it into a sibling call.  */
operator|||
name|args_size
operator|.
name|constant
operator|>
name|current_function_args_size
comment|/* If the callee pops its own arguments, then it must pop exactly 	 the same number of arguments as the current function.  */
operator|||
name|RETURN_POPS_ARGS
argument_list|(
name|fndecl
argument_list|,
name|funtype
argument_list|,
name|args_size
operator|.
name|constant
argument_list|)
operator|!=
name|RETURN_POPS_ARGS
argument_list|(
name|current_function_decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|current_function_args_size
argument_list|)
condition|)
name|try_tail_call
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|try_tail_call
operator|||
name|try_tail_recursion
condition|)
block|{
name|int
name|end
decl_stmt|,
name|inc
decl_stmt|;
name|actparms
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Ok, we're going to give the tail call the old college try. 	 This means we're going to evaluate the function arguments 	 up to three times.  There are two degrees of badness we can 	 encounter, those that can be unsaved and those that can't. 	 (See unsafe_for_reeval commentary for details.)  	 Generate a new argument list.  Pass safe arguments through 	 unchanged.  For the easy badness wrap them in UNSAVE_EXPRs. 	 For hard badness, evaluate them now and put their resulting 	 rtx in a temporary VAR_DECL.  	 initialize_argument_information has ordered the array for the 	 order to be pushed, and we must remember this when reconstructing 	 the original argument order.  */
if|if
condition|(
name|PUSH_ARGS_REVERSED
condition|)
block|{
name|inc
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|num_actuals
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
name|num_actuals
operator|-
literal|1
expr_stmt|;
name|end
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|!=
name|end
condition|;
name|i
operator|+=
name|inc
control|)
block|{
switch|switch
condition|(
name|unsafe_for_reeval
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Safe.  */
break|break;
case|case
literal|1
case|:
comment|/* Mildly unsafe.  */
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|unsave_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Wildly unsafe.  */
block|{
name|tree
name|var
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|)
argument_list|)
decl_stmt|;
name|SET_DECL_RTL
argument_list|(
name|var
argument_list|,
name|expand_expr
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|tree_value
operator|=
name|var
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* We need to build actparms for optimize_tail_recursion.  We can 	     safely trash away TREE_PURPOSE, since it is unused by this 	     function.  */
if|if
condition|(
name|try_tail_recursion
condition|)
name|actparms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|tree_value
argument_list|,
name|actparms
argument_list|)
expr_stmt|;
block|}
comment|/* Expanding one of those dangerous arguments could have added 	 cleanups, but otherwise give it a whirl.  */
if|if
condition|(
name|any_pending_cleanups
argument_list|(
literal|1
argument_list|)
condition|)
name|try_tail_call
operator|=
name|try_tail_recursion
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Generate a tail recursion sequence when calling ourselves.  */
if|if
condition|(
name|try_tail_recursion
condition|)
block|{
comment|/* We want to emit any pending stack adjustments before the tail 	 recursion "call".  That way we know any adjustment after the tail 	 recursion call can be ignored if we indeed use the tail recursion 	 call expansion.  */
name|int
name|save_pending_stack_adjust
init|=
name|pending_stack_adjust
decl_stmt|;
name|int
name|save_stack_pointer_delta
init|=
name|stack_pointer_delta
decl_stmt|;
comment|/* Emit any queued insns now; otherwise they would end up in 	 only one of the alternates.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Use a new sequence to hold any RTL we generate.  We do not even 	 know if we will use this RTL yet.  The final decision can not be 	 made until after RTL generation for the entire function is 	 complete.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* If expanding any of the arguments creates cleanups, we can't 	 do a tailcall.  So, we'll need to pop the pending cleanups 	 list.  If, however, all goes well, and there are no cleanups 	 then the call to expand_start_target_temps will have no 	 effect.  */
name|expand_start_target_temps
argument_list|()
expr_stmt|;
if|if
condition|(
name|optimize_tail_recursion
argument_list|(
name|actparms
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|any_pending_cleanups
argument_list|(
literal|1
argument_list|)
condition|)
name|try_tail_call
operator|=
name|try_tail_recursion
operator|=
literal|0
expr_stmt|;
else|else
name|tail_recursion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
block|}
name|expand_end_target_temps
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Restore the original pending stack adjustment for the sibling and 	 normal call cases below.  */
name|pending_stack_adjust
operator|=
name|save_pending_stack_adjust
expr_stmt|;
name|stack_pointer_delta
operator|=
name|save_stack_pointer_delta
expr_stmt|;
block|}
if|if
condition|(
name|profile_arc_flag
operator|&&
operator|(
name|flags
operator|&
name|ECF_FORK_OR_EXEC
operator|)
condition|)
block|{
comment|/* A fork duplicates the profile information, and an exec discards 	 it.  We can't rely on fork/exec to be paired.  So write out the 	 profile information we have gathered so far, and clear it.  */
comment|/* ??? When Linux's __clone is called with CLONE_VM set, profiling 	 is subject to race conditions, just as with multithreaded 	 programs.  */
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__bb_fork_func"
argument_list|)
argument_list|,
name|LCT_ALWAYS_RETURN
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure current function's preferred stack boundary is at least      what we need.  We don't have to increase alignment for recursive      functions.  */
if|if
condition|(
name|cfun
operator|->
name|preferred_stack_boundary
operator|<
name|preferred_stack_boundary
operator|&&
name|fndecl
operator|!=
name|current_function_decl
condition|)
name|cfun
operator|->
name|preferred_stack_boundary
operator|=
name|preferred_stack_boundary
expr_stmt|;
name|preferred_unit_stack_boundary
operator|=
name|preferred_stack_boundary
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|function_call_count
operator|++
expr_stmt|;
comment|/* We want to make two insn chains; one for a sibling call, the other      for a normal call.  We will select one of the two chains after      initial RTL generation is complete.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|int
name|sibcall_failure
init|=
literal|0
decl_stmt|;
comment|/* We want to emit any pending stack adjustments before the tail 	 recursion "call".  That way we know any adjustment after the tail 	 recursion call can be ignored if we indeed use the tail recursion 	 call expansion.  */
name|int
name|save_pending_stack_adjust
init|=
literal|0
decl_stmt|;
name|int
name|save_stack_pointer_delta
init|=
literal|0
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|rtx
name|before_call
decl_stmt|,
name|next_arg_reg
decl_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|try_tail_call
condition|)
continue|continue;
comment|/* Emit any queued insns now; otherwise they would end up in              only one of the alternates.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* State variables we need to save and restore between 	     iterations.  */
name|save_pending_stack_adjust
operator|=
name|pending_stack_adjust
expr_stmt|;
name|save_stack_pointer_delta
operator|=
name|stack_pointer_delta
expr_stmt|;
block|}
if|if
condition|(
name|pass
condition|)
name|flags
operator|&=
operator|~
name|ECF_SIBCALL
expr_stmt|;
else|else
name|flags
operator||=
name|ECF_SIBCALL
expr_stmt|;
comment|/* Other state variables that we must reinitialize each time 	 through the loop (that are not initialized by the loop itself).  */
name|argblock
operator|=
literal|0
expr_stmt|;
name|call_fusage
operator|=
literal|0
expr_stmt|;
comment|/* Start a new sequence for the normal call case.  	 From this point on, if the sibling call fails, we want to set 	 sibcall_failure instead of continuing the loop.  */
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* We know at this point that there are not currently any 	     pending cleanups.  If, however, in the process of evaluating 	     the arguments we were to create some, we'll need to be 	     able to get rid of them.  */
name|expand_start_target_temps
argument_list|()
expr_stmt|;
block|}
comment|/* Don't let pending stack adjusts add up to too much. 	 Also, do all pending adjustments now if there is any chance 	 this might be a call to alloca or if we are expanding a sibling 	 call sequence or if we are calling a function that is to return 	 with stack pointer depressed.  */
if|if
condition|(
name|pending_stack_adjust
operator|>=
literal|32
operator|||
operator|(
name|pending_stack_adjust
operator|>
literal|0
operator|&&
operator|(
name|flags
operator|&
operator|(
name|ECF_MAY_BE_ALLOCA
operator||
name|ECF_SP_DEPRESSED
operator|)
operator|)
operator|)
operator|||
name|pass
operator|==
literal|0
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* When calling a const function, we must pop the stack args right away, 	 so that the pop is deleted or moved with the call.  */
if|if
condition|(
name|pass
operator|&&
operator|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
operator|)
condition|)
name|NO_DEFER_POP
expr_stmt|;
ifdef|#
directive|ifdef
name|FINAL_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|FINAL_REG_PARM_STACK_SPACE
argument_list|(
name|args_size
operator|.
name|constant
argument_list|,
name|args_size
operator|.
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Precompute any arguments as needed.  */
if|if
condition|(
name|pass
condition|)
name|precompute_arguments
argument_list|(
name|flags
argument_list|,
name|num_actuals
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Now we are about to start emitting insns that can be deleted 	 if a libcall is deleted.  */
if|if
condition|(
name|pass
operator|&&
operator|(
name|flags
operator|&
operator|(
name|ECF_LIBCALL_BLOCK
operator||
name|ECF_MALLOC
operator|)
operator|)
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
name|adjusted_args_size
operator|=
name|args_size
expr_stmt|;
comment|/* Compute the actual size of the argument block required.  The variable 	 and constant sizes must be combined, the size may have to be rounded, 	 and there may be a minimum required size.  When generating a sibcall 	 pattern, do not round up, since we'll be re-using whatever space our 	 caller provided.  */
name|unadjusted_args_size
operator|=
name|compute_argument_block_size
argument_list|(
name|reg_parm_stack_space
argument_list|,
operator|&
name|adjusted_args_size
argument_list|,
operator|(
name|pass
operator|==
literal|0
condition|?
literal|0
else|:
name|preferred_stack_boundary
operator|)
argument_list|)
expr_stmt|;
name|old_stack_allocated
operator|=
name|stack_pointer_delta
operator|-
name|pending_stack_adjust
expr_stmt|;
comment|/* The argument block when performing a sibling call is the          incoming argument block.  */
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|argblock
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
name|argblock
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
operator|=
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
else|#
directive|else
operator|=
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stored_args_map
operator|=
name|sbitmap_alloc
argument_list|(
name|args_size
operator|.
name|constant
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|stored_args_map
argument_list|)
expr_stmt|;
block|}
comment|/* If we have no actual push instructions, or shouldn't use them, 	 make space for all args right now.  */
elseif|else
if|if
condition|(
name|adjusted_args_size
operator|.
name|var
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|old_stack_level
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|old_pending_adj
operator|=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
comment|/* stack_arg_under_construction says whether a stack arg is 		 being constructed at the old stack level.  Pushing the stack 		 gets a clean outgoing argument block.  */
name|old_stack_arg_under_construction
operator|=
name|stack_arg_under_construction
expr_stmt|;
name|stack_arg_under_construction
operator|=
literal|0
expr_stmt|;
block|}
name|argblock
operator|=
name|push_block
argument_list|(
name|ARGS_SIZE_RTX
argument_list|(
name|adjusted_args_size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Note that we must go through the motions of allocating an argument 	     block even if the size is zero because we may be storing args 	     in the area reserved for register arguments, which may be part of 	     the stack frame.  */
name|int
name|needed
init|=
name|adjusted_args_size
operator|.
name|constant
decl_stmt|;
comment|/* Store the maximum argument space used.  It will be pushed by 	     the prologue (if ACCUMULATE_OUTGOING_ARGS, or stack overflow 	     checking).  */
if|if
condition|(
name|needed
operator|>
name|current_function_outgoing_args_size
condition|)
name|current_function_outgoing_args_size
operator|=
name|needed
expr_stmt|;
if|if
condition|(
name|must_preallocate
condition|)
block|{
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* Since the stack pointer will never be pushed, it is 		     possible for the evaluation of a parm to clobber 		     something we have already written to the stack. 		     Since most function calls on RISC machines do not use 		     the stack, this is uncommon, but must work correctly.  		     Therefore, we save any area of the stack that was already 		     written and that we are using.  Here we set up to do this 		     by making a new stack usage map from the old one.  The 		     actual save will be done by store_one_arg.  		     Another approach might be to try to reorder the argument 		     evaluations to avoid this conflicting stack usage.  */
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
comment|/* Since we will be writing into the entire argument area, 		     the map must be allocated for its entire size, not just 		     the part that is the responsibility of the caller.  */
name|needed
operator|+=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stack_usage_map
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
condition|)
name|memcpy
argument_list|(
name|stack_usage_map
argument_list|,
name|initial_stack_usage_map
argument_list|,
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
operator|!=
name|highest_outgoing_arg_in_use
condition|)
name|memset
argument_list|(
operator|&
name|stack_usage_map
index|[
name|initial_highest_arg_in_use
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|highest_outgoing_arg_in_use
operator|-
name|initial_highest_arg_in_use
operator|)
argument_list|)
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
comment|/* The address of the outgoing argument list must not be 		     copied to a register here, because argblock would be left 		     pointing to the wrong place after the call to 		     allocate_dynamic_stack_space below.  */
name|argblock
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inhibit_defer_pop
operator|==
literal|0
condition|)
block|{
comment|/* Try to reuse some or all of the pending_stack_adjust 			 to get this space.  */
name|needed
operator|=
operator|(
name|combine_pending_stack_adjustment_and_call
argument_list|(
name|unadjusted_args_size
argument_list|,
operator|&
name|adjusted_args_size
argument_list|,
name|preferred_unit_stack_boundary
argument_list|)
operator|)
expr_stmt|;
comment|/* combine_pending_stack_adjustment_and_call computes 			 an adjustment before the arguments are allocated. 			 Account for them and see whether or not the stack 			 needs to go up or down.  */
name|needed
operator|=
name|unadjusted_args_size
operator|-
name|needed
expr_stmt|;
if|if
condition|(
name|needed
operator|<
literal|0
condition|)
block|{
comment|/* We're releasing stack space.  */
comment|/* ??? We can avoid any adjustment at all if we're 			     already aligned.  FIXME.  */
name|pending_stack_adjust
operator|=
operator|-
name|needed
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* We need to allocate space.  We'll do that in 			   push_block below.  */
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Special case this because overhead of `push_block' in 		     this case is non-trivial.  */
if|if
condition|(
name|needed
operator|==
literal|0
condition|)
name|argblock
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
else|else
name|argblock
operator|=
name|push_block
argument_list|(
name|GEN_INT
argument_list|(
name|needed
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We only really need to call `copy_to_reg' in the case 		     where push insns are going to be used to pass ARGBLOCK 		     to a function call in ARGS.  In that case, the stack 		     pointer changes value from the allocation point to the 		     call point, and hence the value of 		     VIRTUAL_OUTGOING_ARGS_RTX changes as well.  But might 		     as well always do it.  */
name|argblock
operator|=
name|copy_to_reg
argument_list|(
name|argblock
argument_list|)
expr_stmt|;
comment|/* The save/restore code in store_one_arg handles all 		     cases except one: a constructor call (including a C 		     function returning a BLKmode struct) to initialize 		     an argument.  */
if|if
condition|(
name|stack_arg_under_construction
condition|)
block|{
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
name|rtx
name|push_size
init|=
name|GEN_INT
argument_list|(
name|reg_parm_stack_space
operator|+
name|adjusted_args_size
operator|.
name|constant
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|push_size
init|=
name|GEN_INT
argument_list|(
name|adjusted_args_size
operator|.
name|constant
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|old_stack_level
operator|==
literal|0
condition|)
block|{
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|old_pending_adj
operator|=
name|pending_stack_adjust
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
comment|/* stack_arg_under_construction says whether a stack 			     arg is being constructed at the old stack level. 			     Pushing the stack gets a clean outgoing argument 			     block.  */
name|old_stack_arg_under_construction
operator|=
name|stack_arg_under_construction
expr_stmt|;
name|stack_arg_under_construction
operator|=
literal|0
expr_stmt|;
comment|/* Make a new map for the new argument list.  */
name|stack_usage_map
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stack_usage_map
argument_list|,
literal|0
argument_list|,
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
name|highest_outgoing_arg_in_use
operator|=
literal|0
expr_stmt|;
block|}
name|allocate_dynamic_stack_space
argument_list|(
name|push_size
argument_list|,
name|NULL_RTX
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
comment|/* If argument evaluation might modify the stack pointer, 		     copy the address of the argument list to a register.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
block|{
name|argblock
operator|=
name|copy_addr_to_reg
argument_list|(
name|argblock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|compute_argument_addresses
argument_list|(
name|args
argument_list|,
name|argblock
argument_list|,
name|num_actuals
argument_list|)
expr_stmt|;
comment|/* If we push args individually in reverse order, perform stack alignment 	 before the first push (the last arg).  */
if|if
condition|(
name|PUSH_ARGS_REVERSED
operator|&&
name|argblock
operator|==
literal|0
operator|&&
name|adjusted_args_size
operator|.
name|constant
operator|!=
name|unadjusted_args_size
condition|)
block|{
comment|/* When the stack adjustment is pending, we get better code 	     by combining the adjustments.  */
if|if
condition|(
name|pending_stack_adjust
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
operator|)
operator|&&
operator|!
name|inhibit_defer_pop
condition|)
block|{
name|pending_stack_adjust
operator|=
operator|(
name|combine_pending_stack_adjustment_and_call
argument_list|(
name|unadjusted_args_size
argument_list|,
operator|&
name|adjusted_args_size
argument_list|,
name|preferred_unit_stack_boundary
argument_list|)
operator|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argblock
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|adjusted_args_size
operator|.
name|constant
operator|-
name|unadjusted_args_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now that the stack is properly aligned, pops can't safely 	 be deferred during the evaluation of the arguments.  */
name|NO_DEFER_POP
expr_stmt|;
name|funexp
operator|=
name|rtx_for_function_call
argument_list|(
name|fndecl
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* Figure out the register where the value, if any, will come back.  */
name|valreg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|structure_value_addr
condition|)
block|{
if|if
condition|(
name|pcc_struct_value
condition|)
name|valreg
operator|=
name|hard_function_value
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|fndecl
argument_list|,
operator|(
name|pass
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
else|else
name|valreg
operator|=
name|hard_function_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fndecl
argument_list|,
operator|(
name|pass
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Precompute all register parameters.  It isn't safe to compute anything 	 once we have started filling any specific hard regs.  */
name|precompute_register_parameters
argument_list|(
name|num_actuals
argument_list|,
name|args
argument_list|,
operator|&
name|reg_parm_seen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
comment|/* Save the fixed argument area if it's part of the caller's frame and 	 is clobbered by argument setup for this call.  */
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|pass
condition|)
name|save_area
operator|=
name|save_fixed_argument_area
argument_list|(
name|reg_parm_stack_space
argument_list|,
name|argblock
argument_list|,
operator|&
name|low_to_save
argument_list|,
operator|&
name|high_to_save
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now store (and compute if necessary) all non-register parms. 	 These come before register parms, since they can require block-moves, 	 which could clobber the registers used for register parms. 	 Parms which have partial registers are not stored here, 	 but we do preallocate space here if they want that.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
block|{
name|rtx
name|before_arg
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
if|if
condition|(
name|store_one_arg
argument_list|(
operator|&
name|args
index|[
name|i
index|]
argument_list|,
name|argblock
argument_list|,
name|flags
argument_list|,
name|adjusted_args_size
operator|.
name|var
operator|!=
literal|0
argument_list|,
name|reg_parm_stack_space
argument_list|)
operator|||
operator|(
name|pass
operator|==
literal|0
operator|&&
name|check_sibcall_argument_overlap
argument_list|(
name|before_arg
argument_list|,
operator|&
name|args
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we have a parm that is passed in registers but not in memory 	 and whose alignment does not permit a direct copy into registers, 	 make a group of pseudos that correspond to each register that we 	 will later fill.  */
if|if
condition|(
name|STRICT_ALIGNMENT
condition|)
name|store_unaligned_arguments_into_pseudos
argument_list|(
name|args
argument_list|,
name|num_actuals
argument_list|)
expr_stmt|;
comment|/* Now store any partially-in-registers parm. 	 This is the last place a block-move can happen.  */
if|if
condition|(
name|reg_parm_seen
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|partial
operator|!=
literal|0
operator|&&
operator|!
name|args
index|[
name|i
index|]
operator|.
name|pass_on_stack
condition|)
block|{
name|rtx
name|before_arg
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
if|if
condition|(
name|store_one_arg
argument_list|(
operator|&
name|args
index|[
name|i
index|]
argument_list|,
name|argblock
argument_list|,
name|flags
argument_list|,
name|adjusted_args_size
operator|.
name|var
operator|!=
literal|0
argument_list|,
name|reg_parm_stack_space
argument_list|)
operator|||
operator|(
name|pass
operator|==
literal|0
operator|&&
name|check_sibcall_argument_overlap
argument_list|(
name|before_arg
argument_list|,
operator|&
name|args
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we pushed args in forward order, perform stack alignment 	 after pushing the last arg.  */
if|if
condition|(
operator|!
name|PUSH_ARGS_REVERSED
operator|&&
name|argblock
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|adjusted_args_size
operator|.
name|constant
operator|-
name|unadjusted_args_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If register arguments require space on the stack and stack space 	 was not preallocated, allocate stack space here for arguments 	 passed in registers.  */
ifdef|#
directive|ifdef
name|OUTGOING_REG_PARM_STACK_SPACE
if|if
condition|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|must_preallocate
operator|==
literal|0
operator|&&
name|reg_parm_stack_space
operator|>
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Pass the function the address in which to return a 	 structure value.  */
if|if
condition|(
name|pass
operator|!=
literal|0
operator|&&
name|structure_value_addr
operator|&&
operator|!
name|structure_value_addr_parm
condition|)
block|{
name|emit_move_insn
argument_list|(
name|struct_value_rtx
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|structure_value_addr
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|struct_value_rtx
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|struct_value_rtx
argument_list|)
expr_stmt|;
block|}
name|funexp
operator|=
name|prepare_call_address
argument_list|(
name|funexp
argument_list|,
name|fndecl
argument_list|,
operator|&
name|call_fusage
argument_list|,
name|reg_parm_seen
argument_list|,
name|pass
operator|==
literal|0
argument_list|)
expr_stmt|;
name|load_register_parameters
argument_list|(
name|args
argument_list|,
name|num_actuals
argument_list|,
operator|&
name|call_fusage
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Perform postincrements before actually calling the function.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Save a pointer to the last insn before the call, so that we can 	 later safely search backwards to find the CALL_INSN.  */
name|before_call
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Set up next argument register.  For sibling calls on machines 	 with register windows this should be the incoming register.  */
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
name|next_arg_reg
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|next_arg_reg
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* All arguments and registers used for the call must be set up by 	 now!  */
comment|/* Stack must be properly aligned now.  */
if|if
condition|(
name|pass
operator|&&
name|stack_pointer_delta
operator|%
name|preferred_unit_stack_boundary
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Generate the actual call instruction.  */
name|emit_call_1
argument_list|(
name|funexp
argument_list|,
name|fndecl
argument_list|,
name|funtype
argument_list|,
name|unadjusted_args_size
argument_list|,
name|adjusted_args_size
operator|.
name|constant
argument_list|,
name|struct_value_size
argument_list|,
name|next_arg_reg
argument_list|,
name|valreg
argument_list|,
name|old_inhibit_defer_pop
argument_list|,
name|call_fusage
argument_list|,
name|flags
argument_list|,
operator|&
name|args_so_far
argument_list|)
expr_stmt|;
comment|/* Verify that we've deallocated all the stack we used.  */
if|if
condition|(
name|pass
operator|&&
name|old_stack_allocated
operator|!=
name|stack_pointer_delta
operator|-
name|pending_stack_adjust
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If call is cse'able, make appropriate pair of reg-notes around it. 	 Test valreg so we don't crash; may safely ignore `const' 	 if return type is void.  Disable for PARALLEL return values, because 	 we have no way to move such values into a pseudo register.  */
if|if
condition|(
name|pass
operator|&&
operator|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
operator|)
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
if|if
condition|(
name|valreg
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|valreg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|note
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Mark the return value as a pointer if needed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|mark_reg_pointer
argument_list|(
name|temp
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Construct an "equal form" for the value which mentions all the 		 arguments in order as well as the function name.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|initial_value
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|funexp
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ECF_PURE
condition|)
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|temp
argument_list|,
name|valreg
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|valreg
operator|=
name|temp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pass
operator|&&
operator|(
name|flags
operator|&
name|ECF_MALLOC
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|last
decl_stmt|,
name|insns
decl_stmt|;
comment|/* The return value from a malloc-like function is a pointer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|mark_reg_pointer
argument_list|(
name|temp
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
comment|/* The return value from a malloc-like function can not alias 	     anything else.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOALIAS
argument_list|,
name|temp
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out the sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|valreg
operator|=
name|temp
expr_stmt|;
block|}
comment|/* For calls to `setjmp', etc., inform flow.c it should complain 	 if nonvolatile values are live.  For functions that cannot return, 	 inform flow that control does not fall through.  */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|ECF_NORETURN
operator||
name|ECF_LONGJMP
operator|)
operator|)
operator|||
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* The barrier must be emitted 	     immediately after the CALL_INSN.  Some ports emit more 	     than just a CALL_INSN above, so we must search for it here.  */
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|!=
name|CALL_INSN
condition|)
block|{
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* There was no CALL_INSN?  */
if|if
condition|(
name|last
operator|==
name|before_call
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_barrier_after
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|ECF_LONGJMP
condition|)
name|current_function_calls_longjmp
operator|=
literal|1
expr_stmt|;
comment|/* If this function is returning into a memory location marked as 	 readonly, it means it is initializing that location.  But we normally 	 treat functions as not clobbering such locations, so we need to 	 specify that this one does.  */
if|if
condition|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|structure_value_addr
operator|!=
literal|0
operator|&&
name|RTX_UNCHANGING_P
argument_list|(
name|target
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If value type not void, return an rtx for the value.  */
comment|/* If there are cleanups to be called, don't use a hard reg as target. 	 We need to double check this and see if it matters anymore.  */
if|if
condition|(
name|any_pending_cleanups
argument_list|(
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|target
operator|&&
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|target
operator|=
literal|0
expr_stmt|;
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|VOIDmode
operator|||
name|ignore
condition|)
name|target
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|structure_value_addr
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
condition|)
block|{
name|target
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|memory_address
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|structure_value_addr
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pcc_struct_value
condition|)
block|{
comment|/* This is the special C++ case where we need to 	     know what the true target was.  We take care to 	     never use this value more than once in one expression.  */
name|target
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Handle calls that return values in multiple non-contiguous locations. 	 The Irix 6 ABI has examples of this.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|valreg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
comment|/* This will only be assigned once, so it can be readonly.  */
name|tree
name|nt
init|=
name|build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
decl_stmt|;
name|target
operator|=
name|assign_temp
argument_list|(
name|nt
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|)
condition|)
name|emit_group_store
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can not support sibling calls for this case.  */
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
condition|)
block|{
comment|/* TARGET and VALREG cannot be equal at this point because the 	     latter would not have REG_FUNCTION_VALUE_P true, while the 	     former would if it were referring to the same register.  	     If they refer to the same register, this move will be a no-op, 	     except when function inlining is being done.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|target
operator|=
name|copy_blkmode_from_reg
argument_list|(
name|target
argument_list|,
name|valreg
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can not support sibling calls for this case.  */
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|target
operator|=
name|copy_to_reg
argument_list|(
name|valreg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_RETURN
comment|/* If we promoted this return value, make the proper SUBREG.  TARGET 	 might be const0_rtx here, so be careful.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* If we don't promote as expected, something is wrong.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|WORDS_BIG_ENDIAN
operator|||
name|BYTES_BIG_ENDIAN
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|=
operator|(
name|offset
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|%=
name|UNITS_PER_WORD
expr_stmt|;
block|}
name|target
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|target
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If size of args is variable or this was a constructor call for a stack 	 argument, restore saved stack-pointer value.  */
if|if
condition|(
name|old_stack_level
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ECF_SP_DEPRESSED
operator|)
condition|)
block|{
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|pending_stack_adjust
operator|=
name|old_pending_adj
expr_stmt|;
name|stack_arg_under_construction
operator|=
name|old_stack_arg_under_construction
expr_stmt|;
name|highest_outgoing_arg_in_use
operator|=
name|initial_highest_arg_in_use
expr_stmt|;
name|stack_usage_map
operator|=
name|initial_stack_usage_map
expr_stmt|;
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|pass
condition|)
block|{
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
if|if
condition|(
name|save_area
condition|)
block|{
name|restore_fixed_argument_area
argument_list|(
name|save_area
argument_list|,
name|argblock
argument_list|,
name|high_to_save
argument_list|,
name|low_to_save
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we saved any argument areas, restore them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|save_area
condition|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|save_area
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|XEXP
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|save_mode
operator|!=
name|BLKmode
condition|)
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|save_area
argument_list|)
expr_stmt|;
else|else
name|emit_block_move
argument_list|(
name|stack_area
argument_list|,
name|validize_mem
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|save_area
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|size
operator|.
name|constant
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|highest_outgoing_arg_in_use
operator|=
name|initial_highest_arg_in_use
expr_stmt|;
name|stack_usage_map
operator|=
name|initial_stack_usage_map
expr_stmt|;
block|}
comment|/* If this was alloca, record the new stack level for nonlocal gotos. 	 Check for the handler slots since we might not have a save area 	 for non-local gotos.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|ECF_MAY_BE_ALLOCA
operator|)
operator|&&
name|nonlocal_goto_handler_slots
operator|!=
literal|0
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|nonlocal_goto_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Free up storage we no longer need.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* Undo the fake expand_start_target_temps we did earlier.  If 	     there had been any cleanups created, we've already set 	     sibcall_failure.  */
name|expand_end_target_temps
argument_list|()
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|tail_call_insns
operator|=
name|insns
expr_stmt|;
comment|/* Restore the pending stack adjustment now that we have 	     finished generating the sibling call sequence.  */
name|pending_stack_adjust
operator|=
name|save_pending_stack_adjust
expr_stmt|;
name|stack_pointer_delta
operator|=
name|save_stack_pointer_delta
expr_stmt|;
comment|/* Prepare arg structure for next iteration.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_actuals
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|aligned_regs
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|stack
operator|=
literal|0
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|stored_args_map
argument_list|)
expr_stmt|;
block|}
else|else
name|normal_call_insns
operator|=
name|insns
expr_stmt|;
comment|/* If something prevents making this a sibling call, 	 zero out the sequence.  */
if|if
condition|(
name|sibcall_failure
condition|)
name|tail_call_insns
operator|=
name|NULL_RTX
expr_stmt|;
block|}
comment|/* The function optimize_sibling_and_tail_recursive_calls doesn't      handle CALL_PLACEHOLDERs inside other CALL_PLACEHOLDERs.  This      can happen if the arguments to this function call an inline      function who's expansion contains another CALL_PLACEHOLDER.       If there are any C_Ps in any of these sequences, replace them      with their normal call.  */
for|for
control|(
name|insn
operator|=
name|normal_call_insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
name|replace_call_placeholder
argument_list|(
name|insn
argument_list|,
name|sibcall_use_normal
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|tail_call_insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
name|replace_call_placeholder
argument_list|(
name|insn
argument_list|,
name|sibcall_use_normal
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|tail_recursion_insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
name|replace_call_placeholder
argument_list|(
name|insn
argument_list|,
name|sibcall_use_normal
argument_list|)
expr_stmt|;
comment|/* If this was a potential tail recursion site, then emit a      CALL_PLACEHOLDER with the normal and the tail recursion streams.      One of them will be selected later.  */
if|if
condition|(
name|tail_recursion_insns
operator|||
name|tail_call_insns
condition|)
block|{
comment|/* The tail recursion label must be kept around.  We could expose 	 its use in the CALL_PLACEHOLDER, but that creates unwanted edges 	 and makes determining true tail recursion sites difficult.  	 So we set LABEL_PRESERVE_P here, then clear it when we select 	 one of the call sequences after rtl generation is complete.  */
if|if
condition|(
name|tail_recursion_insns
condition|)
name|LABEL_PRESERVE_P
argument_list|(
name|tail_recursion_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_call_insn
argument_list|(
name|gen_rtx_CALL_PLACEHOLDER
argument_list|(
name|VOIDmode
argument_list|,
name|normal_call_insns
argument_list|,
name|tail_call_insns
argument_list|,
name|tail_recursion_insns
argument_list|,
name|tail_recursion_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insns
argument_list|(
name|normal_call_insns
argument_list|)
expr_stmt|;
name|currently_expanding_call
operator|--
expr_stmt|;
comment|/* If this function returns with the stack pointer depressed, ensure      this block saves and restores the stack pointer, show it was      changed, and adjust for any outgoing arg space.  */
if|if
condition|(
name|flags
operator|&
name|ECF_SP_DEPRESSED
condition|)
block|{
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|save_stack_pointer
argument_list|()
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a library call to function FUN (a SYMBOL_REF rtx).    The RETVAL parameter specifies whether return value needs to be saved, other    parameters are documented in the emit_library_call function below.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_library_call_value_1
parameter_list|(
name|retval
parameter_list|,
name|orgfun
parameter_list|,
name|value
parameter_list|,
name|fn_type
parameter_list|,
name|outmode
parameter_list|,
name|nargs
parameter_list|,
name|p
parameter_list|)
name|int
name|retval
decl_stmt|;
name|rtx
name|orgfun
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|enum
name|libcall_type
name|fn_type
decl_stmt|;
name|enum
name|machine_mode
name|outmode
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|va_list
name|p
decl_stmt|;
block|{
comment|/* Total size in bytes of all the stack-parms scanned so far.  */
name|struct
name|args_size
name|args_size
decl_stmt|;
comment|/* Size of arguments before any adjustments (such as rounding).  */
name|struct
name|args_size
name|original_args_size
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|rtx
name|fun
decl_stmt|;
name|int
name|inc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|args_size
name|alignment_pad
decl_stmt|;
name|rtx
name|argblock
init|=
literal|0
decl_stmt|;
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
struct|struct
name|arg
block|{
name|rtx
name|value
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|partial
decl_stmt|;
name|struct
name|args_size
name|offset
decl_stmt|;
name|struct
name|args_size
name|size
decl_stmt|;
name|rtx
name|save_area
decl_stmt|;
block|}
struct|;
name|struct
name|arg
modifier|*
name|argvec
decl_stmt|;
name|int
name|old_inhibit_defer_pop
init|=
name|inhibit_defer_pop
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
name|rtx
name|mem_value
init|=
literal|0
decl_stmt|;
name|rtx
name|valreg
decl_stmt|;
name|int
name|pcc_struct_value
init|=
literal|0
decl_stmt|;
name|int
name|struct_value_size
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
name|int
name|needed
decl_stmt|;
name|rtx
name|before_call
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
comment|/* Define the boundary of the register parm stack space that needs to be      save, if any.  */
name|int
name|low_to_save
init|=
operator|-
literal|1
decl_stmt|,
name|high_to_save
init|=
literal|0
decl_stmt|;
name|rtx
name|save_area
init|=
literal|0
decl_stmt|;
comment|/* Place that it is saved.  */
endif|#
directive|endif
comment|/* Size of the stack reserved for parameter registers.  */
name|int
name|initial_highest_arg_in_use
init|=
name|highest_outgoing_arg_in_use
decl_stmt|;
name|char
modifier|*
name|initial_stack_usage_map
init|=
name|stack_usage_map
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|MAYBE_REG_PARM_STACK_SPACE
expr_stmt|;
else|#
directive|else
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* By default, library functions can not throw.  */
name|flags
operator|=
name|ECF_NOTHROW
expr_stmt|;
switch|switch
condition|(
name|fn_type
condition|)
block|{
case|case
name|LCT_NORMAL
case|:
break|break;
case|case
name|LCT_CONST
case|:
name|flags
operator||=
name|ECF_CONST
expr_stmt|;
break|break;
case|case
name|LCT_PURE
case|:
name|flags
operator||=
name|ECF_PURE
expr_stmt|;
break|break;
case|case
name|LCT_CONST_MAKE_BLOCK
case|:
name|flags
operator||=
name|ECF_CONST
operator||
name|ECF_LIBCALL_BLOCK
expr_stmt|;
break|break;
case|case
name|LCT_PURE_MAKE_BLOCK
case|:
name|flags
operator||=
name|ECF_PURE
operator||
name|ECF_LIBCALL_BLOCK
expr_stmt|;
break|break;
case|case
name|LCT_NORETURN
case|:
name|flags
operator||=
name|ECF_NORETURN
expr_stmt|;
break|break;
case|case
name|LCT_THROW
case|:
name|flags
operator|=
name|ECF_NORETURN
expr_stmt|;
break|break;
case|case
name|LCT_ALWAYS_RETURN
case|:
name|flags
operator|=
name|ECF_ALWAYS_RETURN
expr_stmt|;
break|break;
case|case
name|LCT_RETURNS_TWICE
case|:
name|flags
operator|=
name|ECF_RETURNS_TWICE
expr_stmt|;
break|break;
block|}
name|fun
operator|=
name|orgfun
expr_stmt|;
comment|/* Ensure current function's preferred stack boundary is at least      what we need.  */
if|if
condition|(
name|cfun
operator|->
name|preferred_stack_boundary
operator|<
name|PREFERRED_STACK_BOUNDARY
condition|)
name|cfun
operator|->
name|preferred_stack_boundary
operator|=
name|PREFERRED_STACK_BOUNDARY
expr_stmt|;
comment|/* If this kind of value comes back in memory,      decide where in memory it should come back.  */
if|if
condition|(
name|outmode
operator|!=
name|VOIDmode
operator|&&
name|aggregate_value_p
argument_list|(
name|type_for_mode
argument_list|(
name|outmode
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
name|rtx
name|pointer_reg
init|=
name|hard_function_value
argument_list|(
name|build_pointer_type
argument_list|(
name|type_for_mode
argument_list|(
name|outmode
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|mem_value
operator|=
name|gen_rtx_MEM
argument_list|(
name|outmode
argument_list|,
name|pointer_reg
argument_list|)
expr_stmt|;
name|pcc_struct_value
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|gen_reg_rtx
argument_list|(
name|outmode
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not PCC_STATIC_STRUCT_RETURN */
name|struct_value_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
condition|)
name|mem_value
operator|=
name|value
expr_stmt|;
else|else
name|mem_value
operator|=
name|assign_temp
argument_list|(
name|type_for_mode
argument_list|(
name|outmode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This call returns a big structure.  */
name|flags
operator|&=
operator|~
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator||
name|ECF_LIBCALL_BLOCK
operator|)
expr_stmt|;
block|}
comment|/* ??? Unfinished: must pass the memory address as an argument.  */
comment|/* Copy all the libcall-arguments out of the varargs data      and into a vector ARGVEC.       Compute how to pass each argument.  We only support a very small subset      of the full argument passing conventions to limit complexity here since      library functions shouldn't have many args.  */
name|argvec
operator|=
operator|(
expr|struct
name|arg
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argvec
argument_list|,
literal|0
argument_list|,
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|arg
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_CUMULATIVE_LIBCALL_ARGS
name|INIT_CUMULATIVE_LIBCALL_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|outmode
argument_list|,
name|fun
argument_list|)
expr_stmt|;
else|#
directive|else
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|NULL_TREE
argument_list|,
name|fun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|args_size
operator|.
name|var
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Now we are about to start emitting insns that can be deleted      if a libcall is deleted.  */
if|if
condition|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
comment|/* If there's a structure value address to be passed,      either pass it in the special place, or pass it as an extra argument.  */
if|if
condition|(
name|mem_value
operator|&&
name|struct_value_rtx
operator|==
literal|0
operator|&&
operator|!
name|pcc_struct_value
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|mem_value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|nargs
operator|++
expr_stmt|;
comment|/* Make sure it is a reasonable operand for a move or push insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|MEM
operator|&&
operator|!
operator|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|)
condition|)
name|addr
operator|=
name|force_operand
argument_list|(
name|addr
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|value
operator|=
name|addr
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|mode
operator|=
name|Pmode
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
literal|0
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|Pmode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
if|if
condition|(
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
name|args_so_far
argument_list|,
name|Pmode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|locate_and_pad_parm
argument_list|(
name|Pmode
argument_list|,
name|NULL_TREE
argument_list|,
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
literal|1
argument_list|,
else|#
directive|else
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
name|NULL_TREE
argument_list|,
operator|&
name|args_size
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|offset
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|size
argument_list|,
operator|&
name|alignment_pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|!=
literal|0
operator|||
name|reg_parm_stack_space
operator|>
literal|0
condition|)
name|args_size
operator|.
name|constant
operator|+=
name|argvec
index|[
name|count
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|Pmode
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
block|{
name|rtx
name|val
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|)
decl_stmt|;
comment|/* We cannot convert the arg value to the mode the library wants here; 	 must do it earlier where we know the signedness of the arg.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
operator|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* On some machines, there's no way to pass a float to a library fcn. 	 Pass it as a double instead.  */
ifdef|#
directive|ifdef
name|LIBGCC_NEEDS_DOUBLE
if|if
condition|(
name|LIBGCC_NEEDS_DOUBLE
operator|&&
name|mode
operator|==
name|SFmode
condition|)
name|val
operator|=
name|convert_modes
argument_list|(
name|DFmode
argument_list|,
name|SFmode
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
operator|,
name|mode
operator|=
name|DFmode
expr_stmt|;
endif|#
directive|endif
comment|/* There's no need to call protect_from_queue, because 	 either emit_move_insn or emit_push_insn will do that.  */
comment|/* Make sure it is a reasonable operand for a move or push insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|MEM
operator|&&
operator|!
operator|(
name|CONSTANT_P
argument_list|(
name|val
argument_list|)
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|val
argument_list|)
operator|)
condition|)
name|val
operator|=
name|force_operand
argument_list|(
name|val
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PASS_BY_REFERENCE
if|if
condition|(
name|FUNCTION_ARG_PASS_BY_REFERENCE
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|rtx
name|slot
decl_stmt|;
name|int
name|must_copy
init|=
literal|1
ifdef|#
directive|ifdef
name|FUNCTION_ARG_CALLEE_COPIES
operator|&&
operator|!
name|FUNCTION_ARG_CALLEE_COPIES
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
endif|#
directive|endif
decl_stmt|;
comment|/* If this was a CONST function, it is now PURE since 	     it now reads memory.  */
if|if
condition|(
name|flags
operator|&
name|ECF_CONST
condition|)
block|{
name|flags
operator|&=
operator|~
name|ECF_CONST
expr_stmt|;
name|flags
operator||=
name|ECF_PURE
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|must_copy
condition|)
name|slot
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|must_copy
condition|)
block|{
name|slot
operator|=
name|assign_temp
argument_list|(
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|slot
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
init|=
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|slot
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|expand_expr
argument_list|(
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|val
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|call_fusage
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|slot
argument_list|)
argument_list|,
name|call_fusage
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_copy
condition|)
name|call_fusage
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|slot
argument_list|)
argument_list|,
name|call_fusage
argument_list|)
expr_stmt|;
name|mode
operator|=
name|Pmode
expr_stmt|;
name|val
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|argvec
index|[
name|count
index|]
operator|.
name|value
operator|=
name|val
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|locate_and_pad_parm
argument_list|(
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
literal|1
argument_list|,
else|#
directive|else
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
name|NULL_TREE
argument_list|,
operator|&
name|args_size
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|offset
argument_list|,
operator|&
name|argvec
index|[
name|count
index|]
operator|.
name|size
argument_list|,
operator|&
name|alignment_pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|size
operator|.
name|var
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg_parm_stack_space
operator|==
literal|0
operator|&&
name|argvec
index|[
name|count
index|]
operator|.
name|partial
condition|)
name|argvec
index|[
name|count
index|]
operator|.
name|size
operator|.
name|constant
operator|-=
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|reg
operator|==
literal|0
operator|||
name|argvec
index|[
name|count
index|]
operator|.
name|partial
operator|!=
literal|0
operator|||
name|reg_parm_stack_space
operator|>
literal|0
condition|)
name|args_size
operator|.
name|constant
operator|+=
name|argvec
index|[
name|count
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FINAL_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|FINAL_REG_PARM_STACK_SPACE
argument_list|(
name|args_size
operator|.
name|constant
argument_list|,
name|args_size
operator|.
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this machine requires an external definition for library      functions, write one out.  */
name|assemble_external_libcall
argument_list|(
name|fun
argument_list|)
expr_stmt|;
name|original_args_size
operator|=
name|args_size
expr_stmt|;
name|args_size
operator|.
name|constant
operator|=
operator|(
operator|(
operator|(
name|args_size
operator|.
name|constant
operator|+
name|stack_pointer_delta
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|*
name|STACK_BYTES
operator|)
operator|-
name|stack_pointer_delta
operator|)
expr_stmt|;
name|args_size
operator|.
name|constant
operator|=
name|MAX
argument_list|(
name|args_size
operator|.
name|constant
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
name|args_size
operator|.
name|constant
operator|-=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args_size
operator|.
name|constant
operator|>
name|current_function_outgoing_args_size
condition|)
name|current_function_outgoing_args_size
operator|=
name|args_size
operator|.
name|constant
expr_stmt|;
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* Since the stack pointer will never be pushed, it is possible for 	 the evaluation of a parm to clobber something we have already 	 written to the stack.  Since most function calls on RISC machines 	 do not use the stack, this is uncommon, but must work correctly.  	 Therefore, we save any area of the stack that was already written 	 and that we are using.  Here we set up to do this by making a new 	 stack usage map from the old one.  	 Another approach might be to try to reorder the argument 	 evaluations to avoid this conflicting stack usage.  */
name|needed
operator|=
name|args_size
operator|.
name|constant
expr_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REG_PARM_STACK_SPACE
comment|/* Since we will be writing into the entire argument area, the 	 map must be allocated for its entire size, not just the part that 	 is the responsibility of the caller.  */
name|needed
operator|+=
name|reg_parm_stack_space
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|highest_outgoing_arg_in_use
operator|=
name|MAX
argument_list|(
name|initial_highest_arg_in_use
argument_list|,
name|needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stack_usage_map
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|highest_outgoing_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
condition|)
name|memcpy
argument_list|(
name|stack_usage_map
argument_list|,
name|initial_stack_usage_map
argument_list|,
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_highest_arg_in_use
operator|!=
name|highest_outgoing_arg_in_use
condition|)
name|memset
argument_list|(
operator|&
name|stack_usage_map
index|[
name|initial_highest_arg_in_use
index|]
argument_list|,
literal|0
argument_list|,
name|highest_outgoing_arg_in_use
operator|-
name|initial_highest_arg_in_use
argument_list|)
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
comment|/* We must be careful to use virtual regs before they're instantiated,          and real regs afterwards.  Loop optimization, for example, can create 	 new libcalls after we've instantiated the virtual regs, and if we 	 use virtuals anyway, they won't match the rtl patterns.  */
if|if
condition|(
name|virtuals_instantiated
condition|)
name|argblock
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
argument_list|)
expr_stmt|;
else|else
name|argblock
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|PUSH_ARGS
condition|)
name|argblock
operator|=
name|push_block
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we push args individually in reverse order, perform stack alignment      before the first push (the last arg).  */
if|if
condition|(
name|argblock
operator|==
literal|0
operator|&&
name|PUSH_ARGS_REVERSED
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
operator|-
name|original_args_size
operator|.
name|constant
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PUSH_ARGS_REVERSED
condition|)
block|{
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
name|argnum
operator|=
name|nargs
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inc
operator|=
literal|1
expr_stmt|;
name|argnum
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* The argument list is the property of the called routine and it 	 may clobber it.  If the fixed area has been used for previous 	 parameters, we must save and restore it.  	 Here we compute the boundary of the that needs to be saved, if any.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|reg_parm_stack_space
operator|+
literal|1
condition|;
name|count
operator|++
control|)
else|#
directive|else
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|reg_parm_stack_space
condition|;
name|count
operator|++
control|)
endif|#
directive|endif
block|{
if|if
condition|(
name|count
operator|>=
name|highest_outgoing_arg_in_use
operator|||
name|stack_usage_map
index|[
name|count
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|low_to_save
operator|==
operator|-
literal|1
condition|)
name|low_to_save
operator|=
name|count
expr_stmt|;
name|high_to_save
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|low_to_save
operator|>=
literal|0
condition|)
block|{
name|int
name|num_to_save
init|=
name|high_to_save
operator|-
name|low_to_save
operator|+
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|num_to_save
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
decl_stmt|;
comment|/* If we don't have the required alignment, must do this in BLKmode.  */
if|if
condition|(
operator|(
name|low_to_save
operator|&
operator|(
name|MIN
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|save_mode
argument_list|)
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|UNITS_PER_WORD
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|save_mode
operator|=
name|BLKmode
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
name|high_to_save
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|stack_area
operator|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|low_to_save
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|save_mode
operator|==
name|BLKmode
condition|)
block|{
name|save_area
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|num_to_save
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|save_area
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|stack_area
argument_list|,
name|GEN_INT
argument_list|(
name|num_to_save
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Push the args that need to be pushed.  */
comment|/* ARGNUM indexes the ARGVEC array in the order in which the arguments      are to be pushed.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
operator|,
name|argnum
operator|+=
name|inc
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|val
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|value
decl_stmt|;
name|rtx
name|reg
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|reg
decl_stmt|;
name|int
name|partial
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|partial
decl_stmt|;
name|int
name|lower_bound
init|=
literal|0
decl_stmt|,
name|upper_bound
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|!=
literal|0
operator|&&
name|partial
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* If this is being stored into a pre-allocated, fixed-size, 		 stack area, save any previous data at that location.  */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
comment|/* stack_slot is negative, but we want to index stack_usage_map 		 with positive values.  */
name|upper_bound
operator|=
operator|-
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
operator|+
literal|1
expr_stmt|;
name|lower_bound
operator|=
name|upper_bound
operator|-
name|argvec
index|[
name|argnum
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
else|#
directive|else
name|lower_bound
operator|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
expr_stmt|;
name|upper_bound
operator|=
name|lower_bound
operator|+
name|argvec
index|[
name|argnum
index|]
operator|.
name|size
operator|.
name|constant
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stack_usage_map
index|[
name|i
index|]
comment|/* Don't store things in the fixed argument area at this 		       point; it has already been saved.  */
operator|&&
name|i
operator|>
name|reg_parm_stack_space
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|upper_bound
condition|)
block|{
comment|/* We need to make a save area.  See what mode we can make 		     it.  */
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|size
operator|.
name|constant
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|argvec
index|[
name|argnum
index|]
operator|.
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_push_insn
argument_list|(
name|val
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|argblock
argument_list|,
name|GEN_INT
argument_list|(
name|argvec
index|[
name|argnum
index|]
operator|.
name|offset
operator|.
name|constant
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|alignment_pad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now mark the segment we just used.  */
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
name|stack_usage_map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
block|}
block|}
comment|/* If we pushed args in forward order, perform stack alignment      after pushing the last arg.  */
if|if
condition|(
name|argblock
operator|==
literal|0
operator|&&
operator|!
name|PUSH_ARGS_REVERSED
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|args_size
operator|.
name|constant
operator|-
name|original_args_size
operator|.
name|constant
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PUSH_ARGS_REVERSED
condition|)
name|argnum
operator|=
name|nargs
operator|-
literal|1
expr_stmt|;
else|else
name|argnum
operator|=
literal|0
expr_stmt|;
name|fun
operator|=
name|prepare_call_address
argument_list|(
name|fun
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|call_fusage
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now load any reg parms into their regs.  */
comment|/* ARGNUM indexes the ARGVEC array in the order in which the arguments      are to be pushed.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
operator|,
name|argnum
operator|+=
name|inc
control|)
block|{
name|rtx
name|val
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|value
decl_stmt|;
name|rtx
name|reg
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|reg
decl_stmt|;
name|int
name|partial
init|=
name|argvec
index|[
name|argnum
index|]
operator|.
name|partial
decl_stmt|;
comment|/* Handle calls that pass values in multiple non-contiguous 	 locations.  The PA64 has examples of this for library calls.  */
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|reg
argument_list|,
name|val
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|partial
operator|==
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
block|}
comment|/* Any regs containing parms remain in use through the call.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|argvec
index|[
name|count
index|]
operator|.
name|reg
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|use_group_regs
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Pass the function the address in which to return a structure value.  */
if|if
condition|(
name|mem_value
operator|!=
literal|0
operator|&&
name|struct_value_rtx
operator|!=
literal|0
operator|&&
operator|!
name|pcc_struct_value
condition|)
block|{
name|emit_move_insn
argument_list|(
name|struct_value_rtx
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|mem_value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|struct_value_rtx
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|struct_value_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* Don't allow popping to be deferred, since then      cse'ing of library calls could delete a call and leave the pop.  */
name|NO_DEFER_POP
expr_stmt|;
name|valreg
operator|=
operator|(
name|mem_value
operator|==
literal|0
operator|&&
name|outmode
operator|!=
name|VOIDmode
condition|?
name|hard_libcall_value
argument_list|(
name|outmode
argument_list|)
else|:
name|NULL_RTX
operator|)
expr_stmt|;
comment|/* Stack must be properly aligned now.  */
if|if
condition|(
name|stack_pointer_delta
operator|&
operator|(
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|before_call
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which      will set inhibit_defer_pop to that value.  */
comment|/* The return type is needed to decide how many bytes the function pops.      Signedness plays no role in that, so for simplicity, we pretend it's      always signed.  We also assume that the list of arguments passed has      no impact, so we pretend it is unknown.  */
name|emit_call_1
argument_list|(
name|fun
argument_list|,
name|get_identifier
argument_list|(
name|XSTR
argument_list|(
name|orgfun
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_function_type
argument_list|(
name|outmode
operator|==
name|VOIDmode
condition|?
name|void_type_node
else|:
name|type_for_mode
argument_list|(
name|outmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|original_args_size
operator|.
name|constant
argument_list|,
name|args_size
operator|.
name|constant
argument_list|,
name|struct_value_size
argument_list|,
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|VOIDmode
argument_list|,
name|void_type_node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|valreg
argument_list|,
name|old_inhibit_defer_pop
operator|+
literal|1
argument_list|,
name|call_fusage
argument_list|,
name|flags
argument_list|,
operator|&
name|args_so_far
argument_list|)
expr_stmt|;
comment|/* For calls to `setjmp', etc., inform flow.c it should complain      if nonvolatile values are live.  For functions that cannot return,      inform flow that control does not fall through.  */
if|if
condition|(
name|flags
operator|&
operator|(
name|ECF_NORETURN
operator||
name|ECF_LONGJMP
operator|)
condition|)
block|{
comment|/* The barrier note must be emitted 	 immediately after the CALL_INSN.  Some ports emit more than 	 just a CALL_INSN above, so we must search for it here.  */
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|!=
name|CALL_INSN
condition|)
block|{
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* There was no CALL_INSN?  */
if|if
condition|(
name|last
operator|==
name|before_call
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_barrier_after
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* Now restore inhibit_defer_pop to its actual original value.  */
name|OK_DEFER_POP
expr_stmt|;
comment|/* If call is cse'able, make appropriate pair of reg-notes around it.      Test valreg so we don't crash; may safely ignore `const'      if return type is void.  Disable for PARALLEL return values, because      we have no way to move such values into a pseudo register.  */
if|if
condition|(
name|flags
operator|&
name|ECF_LIBCALL_BLOCK
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
if|if
condition|(
name|valreg
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|valreg
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|note
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Construct an "equal form" for the value which mentions all the 	     arguments in order as well as the function name.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|argvec
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|fun
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ECF_PURE
condition|)
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|temp
argument_list|,
name|valreg
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|valreg
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* Copy the value to the right place.  */
if|if
condition|(
name|outmode
operator|!=
name|VOIDmode
operator|&&
name|retval
condition|)
block|{
if|if
condition|(
name|mem_value
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|mem_value
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|mem_value
condition|)
name|emit_move_insn
argument_list|(
name|value
argument_list|,
name|mem_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|value
argument_list|,
name|hard_libcall_value
argument_list|(
name|outmode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|hard_libcall_value
argument_list|(
name|outmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
if|if
condition|(
name|save_area
condition|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|save_area
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
operator|-
name|high_to_save
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|low_to_save
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|set_mem_align
argument_list|(
name|stack_area
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_mode
operator|!=
name|BLKmode
condition|)
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|save_area
argument_list|)
expr_stmt|;
else|else
name|emit_block_move
argument_list|(
name|stack_area
argument_list|,
name|validize_mem
argument_list|(
name|save_area
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high_to_save
operator|-
name|low_to_save
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we saved any argument areas, restore them.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nargs
condition|;
name|count
operator|++
control|)
if|if
condition|(
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
condition|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|GET_MODE
argument_list|(
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|plus_constant
argument_list|(
name|argblock
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|offset
operator|.
name|constant
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|stack_area
argument_list|,
name|argvec
index|[
name|count
index|]
operator|.
name|save_area
argument_list|)
expr_stmt|;
block|}
name|highest_outgoing_arg_in_use
operator|=
name|initial_highest_arg_in_use
expr_stmt|;
name|stack_usage_map
operator|=
name|initial_stack_usage_map
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a library call to function FUN (a SYMBOL_REF rtx)    (emitting the queue unless NO_QUEUE is nonzero),    for a value of mode OUTMODE,    with NARGS different arguments, passed as alternating rtx values    and machine_modes to convert them to.    The rtx values should have been passed through protect_from_queue already.     FN_TYPE should be LCT_NORMAL for `normal' calls, LCT_CONST for `const'    calls, LCT_PURE for `pure' calls, LCT_CONST_MAKE_BLOCK for `const' calls    which should be enclosed in REG_LIBCALL/REG_RETVAL notes,    LCT_PURE_MAKE_BLOCK for `purep' calls which should be enclosed in    REG_LIBCALL/REG_RETVAL notes with extra (use (memory (scratch)),    or other LCT_ value for other types of library calls.  */
end_comment

begin_decl_stmt
name|void
name|emit_library_call
name|VPARAMS
argument_list|(
operator|(
name|rtx
name|orgfun
operator|,
expr|enum
name|libcall_type
name|fn_type
operator|,
expr|enum
name|machine_mode
name|outmode
operator|,
name|int
name|nargs
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|p
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|,
name|orgfun
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
name|int
argument_list|,
name|fn_type
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|,
name|outmode
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
name|int
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|emit_library_call_value_1
argument_list|(
literal|0
argument_list|,
name|orgfun
argument_list|,
name|NULL_RTX
argument_list|,
name|fn_type
argument_list|,
name|outmode
argument_list|,
name|nargs
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Like emit_library_call except that an extra argument, VALUE,    comes second and says where to store the result.    (If VALUE is zero, this function chooses a convenient way    to return the value.     This function returns an rtx for where the value is to be found.    If VALUE is nonzero, VALUE is returned.  */
end_comment

begin_decl_stmt
name|rtx
name|emit_library_call_value
name|VPARAMS
argument_list|(
operator|(
name|rtx
name|orgfun
operator|,
name|rtx
name|value
operator|,
expr|enum
name|libcall_type
name|fn_type
operator|,
expr|enum
name|machine_mode
name|outmode
operator|,
name|int
name|nargs
operator|,
operator|...
operator|)
argument_list|)
block|{
name|rtx
name|result
decl_stmt|;
name|VA_OPEN
argument_list|(
name|p
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|,
name|orgfun
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
name|int
argument_list|,
name|fn_type
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|,
name|outmode
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|p
argument_list|,
name|int
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|result
operator|=
name|emit_library_call_value_1
argument_list|(
literal|1
argument_list|,
name|orgfun
argument_list|,
name|value
argument_list|,
name|fn_type
argument_list|,
name|outmode
argument_list|,
name|nargs
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Store a single argument for a function call    into the register or memory area where it must be passed.    *ARG describes the argument value and where to pass it.     ARGBLOCK is the address of the stack-block for all the arguments,    or 0 on a machine where arguments are pushed individually.     MAY_BE_ALLOCA nonzero says this could be a call to `alloca'    so must be careful about how the stack is used.     VARIABLE_SIZE nonzero says that this was a variable-sized outgoing    argument stack.  This is used if ACCUMULATE_OUTGOING_ARGS to indicate    that we need not worry about saving and restoring the stack.     FNDECL is the declaration of the function we are calling.     Return non-zero if this arg should cause sibcall failure,    zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|store_one_arg
parameter_list|(
name|arg
parameter_list|,
name|argblock
parameter_list|,
name|flags
parameter_list|,
name|variable_size
parameter_list|,
name|reg_parm_stack_space
parameter_list|)
name|struct
name|arg_data
modifier|*
name|arg
decl_stmt|;
name|rtx
name|argblock
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|variable_size
decl_stmt|;
name|int
name|reg_parm_stack_space
decl_stmt|;
block|{
name|tree
name|pval
init|=
name|arg
operator|->
name|tree_value
decl_stmt|;
name|rtx
name|reg
init|=
literal|0
decl_stmt|;
name|int
name|partial
init|=
literal|0
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lower_bound
init|=
literal|0
decl_stmt|,
name|upper_bound
init|=
literal|0
decl_stmt|;
name|int
name|sibcall_failure
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pval
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
comment|/* Push a new temporary level for any temporaries we make for      this argument.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ECF_SIBCALL
operator|)
condition|)
block|{
comment|/* If this is being stored into a pre-allocated, fixed-size, stack area, 	 save any previous data at that location.  */
if|if
condition|(
name|argblock
operator|&&
operator|!
name|variable_size
operator|&&
name|arg
operator|->
name|stack
condition|)
block|{
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
comment|/* stack_slot is negative, but we want to index stack_usage_map 	     with positive values.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|upper_bound
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|upper_bound
operator|=
literal|0
expr_stmt|;
name|lower_bound
operator|=
name|upper_bound
operator|-
name|arg
operator|->
name|size
operator|.
name|constant
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|lower_bound
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|lower_bound
operator|=
literal|0
expr_stmt|;
name|upper_bound
operator|=
name|lower_bound
operator|+
name|arg
operator|->
name|size
operator|.
name|constant
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stack_usage_map
index|[
name|i
index|]
comment|/* Don't store things in the fixed argument area at this point; 		   it has already been saved.  */
operator|&&
name|i
operator|>
name|reg_parm_stack_space
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|upper_bound
condition|)
block|{
comment|/* We need to make a save area.  See what mode we can make it.  */
name|enum
name|machine_mode
name|save_mode
init|=
name|mode_for_size
argument_list|(
name|arg
operator|->
name|size
operator|.
name|constant
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|stack_area
init|=
name|gen_rtx_MEM
argument_list|(
name|save_mode
argument_list|,
name|memory_address
argument_list|(
name|save_mode
argument_list|,
name|XEXP
argument_list|(
name|arg
operator|->
name|stack_slot
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|save_mode
operator|==
name|BLKmode
condition|)
block|{
name|tree
name|ot
init|=
name|TREE_TYPE
argument_list|(
name|arg
operator|->
name|tree_value
argument_list|)
decl_stmt|;
name|tree
name|nt
init|=
name|build_qualified_type
argument_list|(
name|ot
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|ot
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
decl_stmt|;
name|arg
operator|->
name|save_area
operator|=
name|assign_temp
argument_list|(
name|nt
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|arg
operator|->
name|save_area
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|validize_mem
argument_list|(
name|arg
operator|->
name|save_area
argument_list|)
argument_list|,
name|stack_area
argument_list|,
name|expr_size
argument_list|(
name|arg
operator|->
name|tree_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|->
name|save_area
operator|=
name|gen_reg_rtx
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|arg
operator|->
name|save_area
argument_list|,
name|stack_area
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now that we have saved any slots that will be overwritten 	     by this store, mark all slots this store will use.  We 	     must do this before we actually expand the argument since 	     the expansion itself may trigger library calls which might 	     need to use the same stack slot. We only do it if we can't 	     pass all arguments to a library call in registers.  */
if|if
condition|(
name|arg
operator|->
name|partial
condition|)
block|{
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
name|stack_usage_map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Set it so that we don't do it again.  */
name|variable_size
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If this isn't going to be placed on both the stack and in registers,      set up the register and number of words.  */
if|if
condition|(
operator|!
name|arg
operator|->
name|pass_on_stack
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ECF_SIBCALL
condition|)
name|reg
operator|=
name|arg
operator|->
name|tail_call_reg
expr_stmt|;
else|else
name|reg
operator|=
name|arg
operator|->
name|reg
expr_stmt|;
name|partial
operator|=
name|arg
operator|->
name|partial
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|partial
operator|==
literal|0
condition|)
comment|/* Being passed entirely in a register.  We shouldn't be called in        this case.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* If this arg needs special alignment, don't load the registers      here.  */
if|if
condition|(
name|arg
operator|->
name|n_aligned_regs
operator|!=
literal|0
condition|)
name|reg
operator|=
literal|0
expr_stmt|;
comment|/* If this is being passed partially in a register, we can't evaluate      it directly into its stack slot.  Otherwise, we can.  */
if|if
condition|(
name|arg
operator|->
name|value
operator|==
literal|0
condition|)
block|{
comment|/* stack_arg_under_construction is nonzero if a function argument is 	 being evaluated directly into the outgoing argument list and 	 expand_call must take special action to preserve the argument list 	 if it is called recursively.  	 For scalar function arguments stack_usage_map is sufficient to 	 determine which stack slots must be saved and restored.  Scalar 	 arguments in general have pass_on_stack == 0.  	 If this argument is initialized by a function which takes the 	 address of the argument (a C++ constructor or a C function 	 returning a BLKmode structure), then stack_usage_map is 	 insufficient and expand_call must push the stack around the 	 function call.  Such arguments have pass_on_stack == 1.  	 Note that it is always safe to set stack_arg_under_construction, 	 but this generates suboptimal code if set when not needed.  */
if|if
condition|(
name|arg
operator|->
name|pass_on_stack
condition|)
name|stack_arg_under_construction
operator|++
expr_stmt|;
name|arg
operator|->
name|value
operator|=
name|expand_expr
argument_list|(
name|pval
argument_list|,
operator|(
name|partial
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|!=
name|arg
operator|->
name|mode
operator|)
condition|?
name|NULL_RTX
else|:
name|arg
operator|->
name|stack
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we are promoting object (or for any other reason) the mode 	 doesn't agree, convert the mode.  */
if|if
condition|(
name|arg
operator|->
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
condition|)
name|arg
operator|->
name|value
operator|=
name|convert_modes
argument_list|(
name|arg
operator|->
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|,
name|arg
operator|->
name|value
argument_list|,
name|arg
operator|->
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|pass_on_stack
condition|)
name|stack_arg_under_construction
operator|--
expr_stmt|;
block|}
comment|/* Don't allow anything left on stack from computation      of argument to alloca.  */
if|if
condition|(
name|flags
operator|&
name|ECF_MAY_BE_ALLOCA
condition|)
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|value
operator|==
name|arg
operator|->
name|stack
condition|)
comment|/* If the value is already in the stack slot, we are done.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|mode
operator|!=
name|BLKmode
condition|)
block|{
name|int
name|size
decl_stmt|;
comment|/* Argument is a scalar, not entirely passed in registers. 	 (If part is passed in registers, arg->partial says how much 	 and emit_push_insn will take care of putting it there.)  	 Push it, and if its size is less than the 	 amount of space allocated to it, 	 also bump stack pointer by the additional space. 	 Note that in C the default argument promotions 	 will prevent such mismatches.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|arg
operator|->
name|mode
argument_list|)
expr_stmt|;
comment|/* Compute how much space the push instruction will push. 	 On many machines, pushing a byte will advance the stack 	 pointer by a halfword.  */
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|used
operator|=
name|size
expr_stmt|;
comment|/* Compute how much space the argument should get: 	 round up to a multiple of the alignment for arguments.  */
if|if
condition|(
name|none
operator|!=
name|FUNCTION_ARG_PADDING
argument_list|(
name|arg
operator|->
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
condition|)
name|used
operator|=
operator|(
operator|(
operator|(
name|size
operator|+
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* This isn't already where we want it on the stack, so put it there. 	 This can either be done with push or copy insns.  */
name|emit_push_insn
argument_list|(
name|arg
operator|->
name|value
argument_list|,
name|arg
operator|->
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
name|used
operator|-
name|size
argument_list|,
name|argblock
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|offset
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|alignment_pad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unless this is a partially-in-register argument, the argument is now 	 in the stack.  */
if|if
condition|(
name|partial
operator|==
literal|0
condition|)
name|arg
operator|->
name|value
operator|=
name|arg
operator|->
name|stack
expr_stmt|;
block|}
else|else
block|{
comment|/* BLKmode, at least partly to be pushed.  */
name|int
name|excess
decl_stmt|;
name|rtx
name|size_rtx
decl_stmt|;
comment|/* Pushing a nonscalar. 	 If part is passed in registers, PARTIAL says how much 	 and emit_push_insn will take care of putting it there.  */
comment|/* Round its size up to a multiple 	 of the allocation unit for arguments.  */
if|if
condition|(
name|arg
operator|->
name|size
operator|.
name|var
operator|!=
literal|0
condition|)
block|{
name|excess
operator|=
literal|0
expr_stmt|;
name|size_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* PUSH_ROUNDING has no effect on us, because 	     emit_push_insn for BLKmode is careful to avoid it.  */
name|excess
operator|=
operator|(
name|arg
operator|->
name|size
operator|.
name|constant
operator|-
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|+
name|partial
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|size_rtx
operator|=
name|expand_expr
argument_list|(
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|ECF_SIBCALL
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|arg
operator|->
name|value
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* emit_push_insn might not work properly if arg->value and 	     argblock + arg->offset areas overlap.  */
name|rtx
name|x
init|=
name|arg
operator|->
name|value
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|current_function_internal_arg_pointer
condition|)
name|i
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* expand_call should ensure this */
if|if
condition|(
name|arg
operator|->
name|offset
operator|.
name|var
operator|||
name|GET_CODE
argument_list|(
name|size_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|offset
operator|.
name|constant
operator|>
name|i
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|offset
operator|.
name|constant
operator|<
name|i
operator|+
name|INTVAL
argument_list|(
name|size_rtx
argument_list|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|offset
operator|.
name|constant
operator|<
name|i
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|arg
operator|->
name|offset
operator|.
name|constant
operator|+
name|INTVAL
argument_list|(
name|size_rtx
argument_list|)
condition|)
name|sibcall_failure
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Special handling is required if part of the parameter lies in the 	 register parameter area.  The argument may be copied into the stack 	 slot using memcpy(), but the original contents of the register 	 parameter area will be restored after the memcpy() call.  	 To ensure that the part that lies in the register parameter area 	 is copied correctly, we emit a separate push for that part.  This 	 push should be small enough to avoid a call to memcpy().  */
ifndef|#
directive|ifndef
name|STACK_PARMS_IN_REG_PARM_AREA
if|if
condition|(
name|arg
operator|->
name|reg
operator|&&
name|arg
operator|->
name|pass_on_stack
condition|)
else|#
directive|else
if|if
condition|(
literal|1
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|arg
operator|->
name|offset
operator|.
name|constant
operator|<
name|reg_parm_stack_space
operator|&&
name|arg
operator|->
name|offset
operator|.
name|var
condition|)
name|error
argument_list|(
literal|"variable offset is passed partially in stack and in reg"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|offset
operator|.
name|constant
operator|<
name|reg_parm_stack_space
operator|&&
name|arg
operator|->
name|size
operator|.
name|var
condition|)
name|error
argument_list|(
literal|"variable size is passed partially in stack and in reg"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|offset
operator|.
name|constant
operator|<
name|reg_parm_stack_space
operator|&&
operator|(
operator|(
name|arg
operator|->
name|offset
operator|.
name|constant
operator|+
name|arg
operator|->
name|size
operator|.
name|constant
operator|)
operator|>
name|reg_parm_stack_space
operator|)
condition|)
block|{
name|rtx
name|size_rtx1
init|=
name|GEN_INT
argument_list|(
name|reg_parm_stack_space
operator|-
name|arg
operator|->
name|offset
operator|.
name|constant
argument_list|)
decl_stmt|;
name|emit_push_insn
argument_list|(
name|arg
operator|->
name|value
argument_list|,
name|arg
operator|->
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|,
name|size_rtx1
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
name|excess
argument_list|,
name|argblock
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|offset
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|alignment_pad
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_push_insn
argument_list|(
name|arg
operator|->
name|value
argument_list|,
name|arg
operator|->
name|mode
argument_list|,
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|,
name|size_rtx
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|,
name|partial
argument_list|,
name|reg
argument_list|,
name|excess
argument_list|,
name|argblock
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|offset
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|,
name|ARGS_SIZE_RTX
argument_list|(
name|arg
operator|->
name|alignment_pad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unless this is a partially-in-register argument, the argument is now 	 in the stack.  	 ??? Unlike the case above, in which we want the actual 	 address of the data, so that we can load it directly into a 	 register, here we want the address of the stack slot, so that 	 it's properly aligned for word-by-word copying or something 	 like that.  It's not clear that this is always correct.  */
if|if
condition|(
name|partial
operator|==
literal|0
condition|)
name|arg
operator|->
name|value
operator|=
name|arg
operator|->
name|stack_slot
expr_stmt|;
block|}
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ECF_SIBCALL
operator|)
operator|&&
name|argblock
operator|&&
operator|!
name|variable_size
operator|&&
name|arg
operator|->
name|stack
condition|)
for|for
control|(
name|i
operator|=
name|lower_bound
init|;
name|i
operator|<
name|upper_bound
condition|;
name|i
operator|++
control|)
name|stack_usage_map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Once we have pushed something, pops can't safely      be deferred during the rest of the arguments.  */
name|NO_DEFER_POP
expr_stmt|;
comment|/* ANSI doesn't require a sequence point here,      but PCC has one, so this will avoid some problems.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Free any temporary slots made in processing this argument.  Show      that we might have taken the address of something and pushed that      as an operand.  */
name|preserve_temp_slots
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|sibcall_failure
return|;
block|}
end_function

end_unit

