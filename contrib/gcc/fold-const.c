begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fold a constant sub-tree into a single node for C-compiler    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*@@ This file should be rewritten to use an arbitrary precision   @@ representation for "struct tree_int_cst" and "struct tree_real_cst".   @@ Perhaps the routines could also be used for bc/dc, and made a lib.   @@ The routines that translate from the ap rep should   @@ warn if precision et. al. is lost.   @@ This would also make life easier when this technology is used   @@ for cross-compilers.  */
end_comment

begin_comment
comment|/* The entry points in this file are fold, size_int_wide, size_binop    and force_fit_type.     fold takes a tree as argument and returns a simplified tree.     size_binop takes a tree code for an arithmetic operation    and two operands that are trees, and produces a tree for the    result, assuming the type comes from `sizetype'.     size_int takes an integer value, and creates a tree constant    with type from `sizetype'.     force_fit_type takes a constant and prior overflow indicator, and    forces the value to fit the type.  It returns an overflow indicator.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|encode
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|*
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decode
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|*
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|,
name|HOST_WIDE_INT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|exact_real_inverse_1
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|tree
name|negate_expr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|split_tree
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|tree_code
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|associate_trees
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|enum
name|tree_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|int_const_binop
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|const_binop_1
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|const_binop
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|size_htab_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|size_htab_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fold_convert_1
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|fold_convert
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|tree_code
name|invert_tree_comparison
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|tree_code
name|swap_tree_comparison
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|truth_value_p
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|operand_equal_for_comparison_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|twoval_comparison_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|eval_subst
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|omit_one_operand
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|pedantic_omit_one_operand
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|distribute_bit_expr
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|make_bit_field_ref
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|optimize_bit_field_compare
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|decode_field_reference
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|HOST_WIDE_INT
operator|*
operator|,
name|HOST_WIDE_INT
operator|*
operator|,
expr|enum
name|machine_mode
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|all_ones_mask_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|simple_operand_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|range_binop
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|make_range
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|*
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_range_check
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|merge_ranges
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|fold_range_test
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|unextend
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|fold_truthop
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|optimize_minmax_comparison
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|extract_muldiv
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|enum
name|tree_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|strip_compound_expr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|multiple_of_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|constant_boolean_node
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_cond
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|fold_binary_op_with_conditional_arg
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BRANCH_COST
end_ifndef

begin_define
define|#
directive|define
name|BRANCH_COST
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HOST_EBCDIC
argument_list|)
end_if

begin_comment
comment|/* bit 8 is significant in EBCDIC */
end_comment

begin_define
define|#
directive|define
name|CHARMASK
value|0xff
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHARMASK
value|0x7f
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring    overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,    and SUM1.  Then this yields nonzero if overflow occurred during the    addition.     Overflow occurs if A and B have the same sign, but A and SUM differ in    sign.  Use `^' to test whether signs differ, and `< 0' to isolate the    sign.  */
end_comment

begin_define
define|#
directive|define
name|OVERFLOW_SUM_SIGN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|sum
parameter_list|)
value|((~((a) ^ (b))& ((a) ^ (sum)))< 0)
end_define

begin_escape
end_escape

begin_comment
comment|/* To do constant folding on INTEGER_CST nodes requires two-word arithmetic.    We do that by representing the two-word integer in 4 words, with only    HOST_BITS_PER_WIDE_INT / 2 bits stored in each word, as a positive    number.  The value of the word is LOWPART + HIGHPART * BASE.  */
end_comment

begin_define
define|#
directive|define
name|LOWPART
parameter_list|(
name|x
parameter_list|)
define|\
value|((x)& (((unsigned HOST_WIDE_INT) 1<< (HOST_BITS_PER_WIDE_INT / 2)) - 1))
end_define

begin_define
define|#
directive|define
name|HIGHPART
parameter_list|(
name|x
parameter_list|)
define|\
value|((unsigned HOST_WIDE_INT) (x)>> HOST_BITS_PER_WIDE_INT / 2)
end_define

begin_define
define|#
directive|define
name|BASE
value|((unsigned HOST_WIDE_INT) 1<< HOST_BITS_PER_WIDE_INT / 2)
end_define

begin_comment
comment|/* Unpack a two-word integer into 4 words.    LOW and HI are the integer, as two `HOST_WIDE_INT' pieces.    WORDS points to the array of HOST_WIDE_INTs.  */
end_comment

begin_function
specifier|static
name|void
name|encode
parameter_list|(
name|words
parameter_list|,
name|low
parameter_list|,
name|hi
parameter_list|)
name|HOST_WIDE_INT
modifier|*
name|words
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|;
block|{
name|words
index|[
literal|0
index|]
operator|=
name|LOWPART
argument_list|(
name|low
argument_list|)
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
name|HIGHPART
argument_list|(
name|low
argument_list|)
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
name|LOWPART
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
name|HIGHPART
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pack an array of 4 words into a two-word integer.    WORDS points to the array of words.    The integer is stored into *LOW and *HI as two `HOST_WIDE_INT' pieces.  */
end_comment

begin_function
specifier|static
name|void
name|decode
parameter_list|(
name|words
parameter_list|,
name|low
parameter_list|,
name|hi
parameter_list|)
name|HOST_WIDE_INT
modifier|*
name|words
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|low
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|hi
decl_stmt|;
block|{
operator|*
name|low
operator|=
name|words
index|[
literal|0
index|]
operator|+
name|words
index|[
literal|1
index|]
operator|*
name|BASE
expr_stmt|;
operator|*
name|hi
operator|=
name|words
index|[
literal|2
index|]
operator|+
name|words
index|[
literal|3
index|]
operator|*
name|BASE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make the integer constant T valid for its type by setting to 0 or 1 all    the bits in the constant that don't belong in the type.     Return 1 if a signed overflow occurs, 0 otherwise.  If OVERFLOW is    nonzero, a signed overflow has already occurred in calculating T, so    propagate it.     Make the real constant T valid for its type by calling CHECK_FLOAT_VALUE,    if it exists.  */
end_comment

begin_function
name|int
name|force_fit_type
parameter_list|(
name|t
parameter_list|,
name|overflow
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|overflow
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|unsigned
name|int
name|prec
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
ifdef|#
directive|ifdef
name|CHECK_FLOAT_VALUE
name|CHECK_FLOAT_VALUE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|overflow
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|overflow
return|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|prec
operator|=
name|POINTER_SIZE
expr_stmt|;
else|else
name|prec
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First clear all bits that are beyond the type's precision.  */
if|if
condition|(
name|prec
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|&=
operator|~
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
comment|/* Unsigned types do not suffer sign extension or overflow unless they      are a sizetype.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|overflow
return|;
comment|/* If the value's sign bit is set, extend the sign.  */
if|if
condition|(
name|prec
operator|!=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|?
literal|0
operator|!=
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|)
else|:
literal|0
operator|!=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Value is negative: 	 set to 1 all the bits that are outside this type's precision.  */
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator||=
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
block|}
comment|/* Return nonzero if signed overflow occurred.  */
return|return
operator|(
operator|(
name|overflow
operator||
operator|(
name|low
operator|^
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|)
operator||
operator|(
name|high
operator|^
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add two doubleword integers with doubleword result.    Each argument is given as two `HOST_WIDE_INT' pieces.    One argument is L1 and H1; the other, L2 and H2.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|int
name|add_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|l2
parameter_list|,
name|h2
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|h2
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|hv
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|HOST_WIDE_INT
name|h
decl_stmt|;
name|l
operator|=
name|l1
operator|+
name|l2
expr_stmt|;
name|h
operator|=
name|h1
operator|+
name|h2
operator|+
operator|(
name|l
operator|<
name|l1
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|l
expr_stmt|;
operator|*
name|hv
operator|=
name|h
expr_stmt|;
return|return
name|OVERFLOW_SUM_SIGN
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
name|h
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Negate a doubleword integer with doubleword result.    Return nonzero if the operation overflows, assuming it's signed.    The argument is given as two `HOST_WIDE_INT' pieces in L1 and H1.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|int
name|neg_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|hv
decl_stmt|;
block|{
if|if
condition|(
name|l1
operator|==
literal|0
condition|)
block|{
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
operator|*
name|hv
operator|=
operator|-
name|h1
expr_stmt|;
return|return
operator|(
operator|*
name|hv
operator|&
name|h1
operator|)
operator|<
literal|0
return|;
block|}
else|else
block|{
operator|*
name|lv
operator|=
operator|-
name|l1
expr_stmt|;
operator|*
name|hv
operator|=
operator|~
name|h1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Multiply two doubleword integers with doubleword result.    Return nonzero if the operation overflows, assuming it's signed.    Each argument is given as two `HOST_WIDE_INT' pieces.    One argument is L1 and H1; the other, L2 and H2.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|int
name|mul_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|l2
parameter_list|,
name|h2
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|h2
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|hv
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|arg1
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|arg2
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|prod
index|[
literal|4
operator|*
literal|2
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|carry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|toplow
decl_stmt|,
name|neglow
decl_stmt|;
name|HOST_WIDE_INT
name|tophigh
decl_stmt|,
name|neghigh
decl_stmt|;
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|arg2
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|prod
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|prod
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|i
operator|+
name|j
expr_stmt|;
comment|/* This product is<= 0xFFFE0001, the sum<= 0xFFFF0000.  */
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
operator|*
name|arg2
index|[
name|j
index|]
expr_stmt|;
comment|/* Since prod[p]< 0xFFFF, this sum<= 0xFFFFFFFF.  */
name|carry
operator|+=
name|prod
index|[
name|k
index|]
expr_stmt|;
name|prod
index|[
name|k
index|]
operator|=
name|LOWPART
argument_list|(
name|carry
argument_list|)
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|carry
argument_list|)
expr_stmt|;
block|}
name|prod
index|[
name|i
operator|+
literal|4
index|]
operator|=
name|carry
expr_stmt|;
block|}
name|decode
argument_list|(
name|prod
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
comment|/* This ignores prod[4] through prod[4*2-1] */
comment|/* Check for overflow by calculating the top half of the answer in full;      it should agree with the low half's sign bit.  */
name|decode
argument_list|(
name|prod
operator|+
literal|4
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
if|if
condition|(
name|h1
operator|<
literal|0
condition|)
block|{
name|neg_double
argument_list|(
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|neglow
argument_list|,
operator|&
name|neghigh
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|neglow
argument_list|,
name|neghigh
argument_list|,
name|toplow
argument_list|,
name|tophigh
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h2
operator|<
literal|0
condition|)
block|{
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|neglow
argument_list|,
operator|&
name|neghigh
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|neglow
argument_list|,
name|neghigh
argument_list|,
name|toplow
argument_list|,
name|tophigh
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|hv
operator|<
literal|0
condition|?
operator|~
operator|(
name|toplow
operator|&
name|tophigh
operator|)
else|:
name|toplow
operator||
name|tophigh
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Shift the doubleword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.    Shift right if COUNT is negative.    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|lshift_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|,
name|arith
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|int
name|prec
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|hv
decl_stmt|;
name|int
name|arith
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|signmask
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|-
name|count
argument_list|,
name|prec
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|arith
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|count
operator|%=
name|prec
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Shifting by the host word size is undefined according to the 	 ANSI standard, so we must handle this as a special case.  */
operator|*
name|hv
operator|=
literal|0
expr_stmt|;
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|=
name|l1
operator|<<
operator|(
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|<<
name|count
operator|)
operator||
operator|(
name|l1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|count
operator|-
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|l1
operator|<<
name|count
expr_stmt|;
block|}
comment|/* Sign extend all bits that are beyond the precision.  */
name|signmask
operator|=
operator|-
operator|(
operator|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|?
operator|(
operator|*
name|hv
operator|>>
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
else|:
operator|(
operator|*
name|lv
operator|>>
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|prec
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
operator|*
name|hv
operator||=
name|signmask
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
name|signmask
expr_stmt|;
operator|*
name|lv
operator|&=
operator|~
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
operator|*
name|lv
operator||=
name|signmask
operator|<<
name|prec
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift the doubleword integer in L1, H1 right by COUNT places    keeping only PREC bits of result.  COUNT must be positive.    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|rshift_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|,
name|arith
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|int
name|prec
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|hv
decl_stmt|;
name|int
name|arith
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|signmask
decl_stmt|;
name|signmask
operator|=
operator|(
name|arith
condition|?
operator|-
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
else|:
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|count
operator|%=
name|prec
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Shifting by the host word size is undefined according to the 	 ANSI standard, so we must handle this as a special case.  */
operator|*
name|hv
operator|=
literal|0
expr_stmt|;
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|=
literal|0
expr_stmt|;
operator|*
name|lv
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>>
operator|(
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>>
name|count
expr_stmt|;
operator|*
name|lv
operator|=
operator|(
operator|(
name|l1
operator|>>
name|count
operator|)
operator||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|count
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Zero / sign extend all bits that are beyond the precision.  */
if|if
condition|(
name|count
operator|>=
operator|(
name|HOST_WIDE_INT
operator|)
name|prec
condition|)
block|{
operator|*
name|hv
operator|=
name|signmask
expr_stmt|;
operator|*
name|lv
operator|=
name|signmask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|prec
operator|-
name|count
operator|)
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|prec
operator|-
name|count
operator|)
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
operator|*
name|hv
operator||=
name|signmask
operator|<<
operator|(
name|prec
operator|-
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
name|signmask
expr_stmt|;
operator|*
name|lv
operator|&=
operator|~
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|count
operator|)
operator|)
expr_stmt|;
operator|*
name|lv
operator||=
name|signmask
operator|<<
operator|(
name|prec
operator|-
name|count
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Rotate the doubleword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.    Rotate right if COUNT is negative.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|lrotate_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|int
name|prec
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|hv
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|s1l
decl_stmt|,
name|s2l
decl_stmt|;
name|HOST_WIDE_INT
name|s1h
decl_stmt|,
name|s2h
decl_stmt|;
name|count
operator|%=
name|prec
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|+=
name|prec
expr_stmt|;
name|lshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s1l
argument_list|,
operator|&
name|s1h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|prec
operator|-
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s2l
argument_list|,
operator|&
name|s2h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|lv
operator|=
name|s1l
operator||
name|s2l
expr_stmt|;
operator|*
name|hv
operator|=
name|s1h
operator||
name|s2h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rotate the doubleword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.  COUNT must be positive.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|rrotate_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|l1
decl_stmt|;
name|HOST_WIDE_INT
name|h1
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|int
name|prec
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|hv
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|s1l
decl_stmt|,
name|s2l
decl_stmt|;
name|HOST_WIDE_INT
name|s1h
decl_stmt|,
name|s2h
decl_stmt|;
name|count
operator|%=
name|prec
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|+=
name|prec
expr_stmt|;
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s1l
argument_list|,
operator|&
name|s1h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|prec
operator|-
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s2l
argument_list|,
operator|&
name|s2h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|lv
operator|=
name|s1l
operator||
name|s2l
expr_stmt|;
operator|*
name|hv
operator|=
name|s1h
operator||
name|s2h
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Divide doubleword integer LNUM, HNUM by doubleword integer LDEN, HDEN    for a quotient (stored in *LQUO, *HQUO) and remainder (in *LREM, *HREM).    CODE is a tree code for a kind of division, one of    TRUNC_DIV_EXPR, FLOOR_DIV_EXPR, CEIL_DIV_EXPR, ROUND_DIV_EXPR    or EXACT_DIV_EXPR    It controls how the quotient is rounded to an integer.    Return nonzero if the operation overflows.    UNS nonzero says do unsigned division.  */
end_comment

begin_function
name|int
name|div_and_round_double
parameter_list|(
name|code
parameter_list|,
name|uns
parameter_list|,
name|lnum_orig
parameter_list|,
name|hnum_orig
parameter_list|,
name|lden_orig
parameter_list|,
name|hden_orig
parameter_list|,
name|lquo
parameter_list|,
name|hquo
parameter_list|,
name|lrem
parameter_list|,
name|hrem
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|uns
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lnum_orig
decl_stmt|;
comment|/* num == numerator == dividend */
name|HOST_WIDE_INT
name|hnum_orig
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lden_orig
decl_stmt|;
comment|/* den == denominator == divisor */
name|HOST_WIDE_INT
name|hden_orig
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lquo
decl_stmt|,
decl|*
name|lrem
decl_stmt|;
end_function

begin_decl_stmt
name|HOST_WIDE_INT
modifier|*
name|hquo
decl_stmt|,
modifier|*
name|hrem
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|quo_neg
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|num
index|[
literal|4
operator|+
literal|1
index|]
decl_stmt|;
comment|/* extra element for scaling.  */
name|HOST_WIDE_INT
name|den
index|[
literal|4
index|]
decl_stmt|,
name|quo
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|work
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|carry
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lnum
init|=
name|lnum_orig
decl_stmt|;
name|HOST_WIDE_INT
name|hnum
init|=
name|hnum_orig
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lden
init|=
name|lden_orig
decl_stmt|;
name|HOST_WIDE_INT
name|hden
init|=
name|hden_orig
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hden
operator|==
literal|0
operator|&&
name|lden
operator|==
literal|0
condition|)
name|overflow
operator|=
literal|1
operator|,
name|lden
operator|=
literal|1
expr_stmt|;
comment|/* calculate quotient sign and convert operands to unsigned.  */
if|if
condition|(
operator|!
name|uns
condition|)
block|{
if|if
condition|(
name|hnum
operator|<
literal|0
condition|)
block|{
name|quo_neg
operator|=
operator|~
name|quo_neg
expr_stmt|;
comment|/* (minimum integer) / (-1) is the only overflow case.  */
if|if
condition|(
name|neg_double
argument_list|(
name|lnum
argument_list|,
name|hnum
argument_list|,
operator|&
name|lnum
argument_list|,
operator|&
name|hnum
argument_list|)
operator|&&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|lden
operator|&
name|hden
operator|)
operator|==
operator|-
literal|1
condition|)
name|overflow
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hden
operator|<
literal|0
condition|)
block|{
name|quo_neg
operator|=
operator|~
name|quo_neg
expr_stmt|;
name|neg_double
argument_list|(
name|lden
argument_list|,
name|hden
argument_list|,
operator|&
name|lden
argument_list|,
operator|&
name|hden
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hnum
operator|==
literal|0
operator|&&
name|hden
operator|==
literal|0
condition|)
block|{
comment|/* single precision */
operator|*
name|hquo
operator|=
operator|*
name|hrem
operator|=
literal|0
expr_stmt|;
comment|/* This unsigned division rounds toward zero.  */
operator|*
name|lquo
operator|=
name|lnum
operator|/
name|lden
expr_stmt|;
goto|goto
name|finish_up
goto|;
block|}
if|if
condition|(
name|hnum
operator|==
literal|0
condition|)
block|{
comment|/* trivial case: dividend< divisor */
comment|/* hden != 0 already checked.  */
operator|*
name|hquo
operator|=
operator|*
name|lquo
operator|=
literal|0
expr_stmt|;
operator|*
name|hrem
operator|=
name|hnum
expr_stmt|;
operator|*
name|lrem
operator|=
name|lnum
expr_stmt|;
goto|goto
name|finish_up
goto|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|quo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|quo
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|num
argument_list|)
expr_stmt|;
comment|/* to zero 9th element */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|den
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|den
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|num
argument_list|,
name|lnum
argument_list|,
name|hnum
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|den
argument_list|,
name|lden
argument_list|,
name|hden
argument_list|)
expr_stmt|;
comment|/* Special code for when the divisor< BASE.  */
if|if
condition|(
name|hden
operator|==
literal|0
operator|&&
name|lden
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|BASE
condition|)
block|{
comment|/* hnum != 0 already checked.  */
for|for
control|(
name|i
operator|=
literal|4
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|work
operator|=
name|num
index|[
name|i
index|]
operator|+
name|carry
operator|*
name|BASE
expr_stmt|;
name|quo
index|[
name|i
index|]
operator|=
name|work
operator|/
name|lden
expr_stmt|;
name|carry
operator|=
name|work
operator|%
name|lden
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Full double precision division, 	 with thanks to Don Knuth's "Seminumerical Algorithms".  */
name|int
name|num_hi_sig
decl_stmt|,
name|den_hi_sig
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|quo_est
decl_stmt|,
name|scale
decl_stmt|;
comment|/* Find the highest non-zero divisor digit.  */
for|for
control|(
name|i
operator|=
literal|4
operator|-
literal|1
init|;
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|den
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|den_hi_sig
operator|=
name|i
expr_stmt|;
break|break;
block|}
comment|/* Insure that the first digit of the divisor is at least BASE/2. 	 This is required by the quotient digit estimation algorithm.  */
name|scale
operator|=
name|BASE
operator|/
operator|(
name|den
index|[
name|den_hi_sig
index|]
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|scale
operator|>
literal|1
condition|)
block|{
comment|/* scale divisor and dividend */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|4
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|num
index|[
name|i
index|]
operator|*
name|scale
operator|)
operator|+
name|carry
expr_stmt|;
name|num
index|[
name|i
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
name|num
index|[
literal|4
index|]
operator|=
name|carry
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|4
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|den
index|[
name|i
index|]
operator|*
name|scale
operator|)
operator|+
name|carry
expr_stmt|;
name|den
index|[
name|i
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|den
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|den_hi_sig
operator|=
name|i
expr_stmt|;
block|}
block|}
name|num_hi_sig
operator|=
literal|4
expr_stmt|;
comment|/* Main loop */
for|for
control|(
name|i
operator|=
name|num_hi_sig
operator|-
name|den_hi_sig
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Guess the next quotient digit, quo_est, by dividing the first 	     two remaining dividend digits by the high order quotient digit. 	     quo_est is never low and is at most 2 high.  */
name|unsigned
name|HOST_WIDE_INT
name|tmp
decl_stmt|;
name|num_hi_sig
operator|=
name|i
operator|+
name|den_hi_sig
operator|+
literal|1
expr_stmt|;
name|work
operator|=
name|num
index|[
name|num_hi_sig
index|]
operator|*
name|BASE
operator|+
name|num
index|[
name|num_hi_sig
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|num
index|[
name|num_hi_sig
index|]
operator|!=
name|den
index|[
name|den_hi_sig
index|]
condition|)
name|quo_est
operator|=
name|work
operator|/
name|den
index|[
name|den_hi_sig
index|]
expr_stmt|;
else|else
name|quo_est
operator|=
name|BASE
operator|-
literal|1
expr_stmt|;
comment|/* Refine quo_est so it's usually correct, and at most one high.  */
name|tmp
operator|=
name|work
operator|-
name|quo_est
operator|*
name|den
index|[
name|den_hi_sig
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|BASE
operator|&&
operator|(
name|den
index|[
name|den_hi_sig
operator|-
literal|1
index|]
operator|*
name|quo_est
operator|>
operator|(
name|tmp
operator|*
name|BASE
operator|+
name|num
index|[
name|num_hi_sig
operator|-
literal|2
index|]
operator|)
operator|)
condition|)
name|quo_est
operator|--
expr_stmt|;
comment|/* Try QUO_EST as the quotient digit, by multiplying the 	     divisor by QUO_EST and subtracting from the remaining dividend. 	     Keep in mind that QUO_EST is the I - 1st digit.  */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|den_hi_sig
condition|;
name|j
operator|++
control|)
block|{
name|work
operator|=
name|quo_est
operator|*
name|den
index|[
name|j
index|]
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|work
operator|=
name|num
index|[
name|i
operator|+
name|j
index|]
operator|-
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|num
index|[
name|i
operator|+
name|j
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|carry
operator|+=
name|HIGHPART
argument_list|(
name|work
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
comment|/* If quo_est was high by one, then num[i] went negative and 	     we need to correct things.  */
if|if
condition|(
name|num
index|[
name|num_hi_sig
index|]
operator|<
name|carry
condition|)
block|{
name|quo_est
operator|--
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
comment|/* add divisor back in */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|den_hi_sig
condition|;
name|j
operator|++
control|)
block|{
name|work
operator|=
name|num
index|[
name|i
operator|+
name|j
index|]
operator|+
name|den
index|[
name|j
index|]
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|num
index|[
name|i
operator|+
name|j
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
name|num
index|[
name|num_hi_sig
index|]
operator|+=
name|carry
expr_stmt|;
block|}
comment|/* Store the quotient digit.  */
name|quo
index|[
name|i
index|]
operator|=
name|quo_est
expr_stmt|;
block|}
block|}
name|decode
argument_list|(
name|quo
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
name|finish_up
label|:
comment|/* if result is negative, make it so.  */
if|if
condition|(
name|quo_neg
condition|)
name|neg_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
comment|/* compute trial remainder:  rem = num - (quo * den)  */
name|mul_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lden_orig
argument_list|,
name|hden_orig
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lnum_orig
argument_list|,
name|hnum_orig
argument_list|,
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
comment|/* round toward zero */
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* for this one, it shouldn't matter */
return|return
name|overflow
return|;
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
comment|/* round toward negative infinity */
if|if
condition|(
name|quo_neg
operator|&&
operator|(
operator|*
name|lrem
operator|!=
literal|0
operator|||
operator|*
name|hrem
operator|!=
literal|0
operator|)
condition|)
comment|/* ratio< 0&& rem != 0 */
block|{
comment|/* quo = quo - 1;  */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
break|break;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
comment|/* round toward positive infinity */
if|if
condition|(
operator|!
name|quo_neg
operator|&&
operator|(
operator|*
name|lrem
operator|!=
literal|0
operator|||
operator|*
name|hrem
operator|!=
literal|0
operator|)
condition|)
comment|/* ratio> 0&& rem != 0 */
block|{
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
break|break;
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
comment|/* round to closest integer */
block|{
name|unsigned
name|HOST_WIDE_INT
name|labs_rem
init|=
operator|*
name|lrem
decl_stmt|;
name|HOST_WIDE_INT
name|habs_rem
init|=
operator|*
name|hrem
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|labs_den
init|=
name|lden
decl_stmt|,
name|ltwice
decl_stmt|;
name|HOST_WIDE_INT
name|habs_den
init|=
name|hden
decl_stmt|,
name|htwice
decl_stmt|;
comment|/* Get absolute values */
if|if
condition|(
operator|*
name|hrem
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
operator|&
name|labs_rem
argument_list|,
operator|&
name|habs_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|hden
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|lden
argument_list|,
name|hden
argument_list|,
operator|&
name|labs_den
argument_list|,
operator|&
name|habs_den
argument_list|)
expr_stmt|;
comment|/* If (2 * abs (lrem)>= abs (lden)) */
name|mul_double
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|labs_rem
argument_list|,
name|habs_rem
argument_list|,
operator|&
name|ltwice
argument_list|,
operator|&
name|htwice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|habs_den
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|htwice
operator|)
operator|||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|habs_den
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|htwice
operator|)
operator|&&
operator|(
name|labs_den
operator|<
name|ltwice
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|hquo
operator|<
literal|0
condition|)
comment|/* quo = quo - 1;  */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
else|else
comment|/* quo = quo + 1; */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* compute true remainder:  rem = num - (quo * den)  */
name|mul_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lden_orig
argument_list|,
name|hden_orig
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lnum_orig
argument_list|,
name|hnum_orig
argument_list|,
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
return|return
name|overflow
return|;
block|}
end_block

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
end_ifndef

begin_comment
comment|/* Effectively truncate a real value to represent the nearest possible value    in a narrower mode.  The result is actually represented in the same data    type as the argument, but its value is usually different.     A trap may occur during the FP operations and it is the responsibility    of the calling function to have a handler established.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|real_value_truncate
parameter_list|(
name|mode
parameter_list|,
name|arg
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
name|arg
decl_stmt|;
block|{
return|return
name|REAL_VALUE_TRUNCATE
argument_list|(
name|mode
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
end_if

begin_comment
comment|/* Check for infinity in an IEEE double precision number.  */
end_comment

begin_function
name|int
name|target_isinf
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
comment|/* The IEEE 64-bit double format.  */
union|union
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
struct|struct
block|{
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|mantissa2
range|:
literal|32
decl_stmt|;
block|}
name|little_endian
struct|;
struct|struct
block|{
name|unsigned
name|mantissa2
range|:
literal|32
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
block|}
name|big_endian
struct|;
block|}
name|u
union|;
name|u
operator|.
name|d
operator|=
name|dconstm1
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|big_endian
operator|.
name|sign
operator|==
literal|1
condition|)
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|u
operator|.
name|big_endian
operator|.
name|exponent
operator|==
literal|2047
operator|&&
name|u
operator|.
name|big_endian
operator|.
name|mantissa1
operator|==
literal|0
operator|&&
name|u
operator|.
name|big_endian
operator|.
name|mantissa2
operator|==
literal|0
operator|)
return|;
block|}
else|else
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|u
operator|.
name|little_endian
operator|.
name|exponent
operator|==
literal|2047
operator|&&
name|u
operator|.
name|little_endian
operator|.
name|mantissa1
operator|==
literal|0
operator|&&
name|u
operator|.
name|little_endian
operator|.
name|mantissa2
operator|==
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Check whether an IEEE double precision number is a NaN.  */
end_comment

begin_function
name|int
name|target_isnan
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
comment|/* The IEEE 64-bit double format.  */
union|union
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
struct|struct
block|{
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|mantissa2
range|:
literal|32
decl_stmt|;
block|}
name|little_endian
struct|;
struct|struct
block|{
name|unsigned
name|mantissa2
range|:
literal|32
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
block|}
name|big_endian
struct|;
block|}
name|u
union|;
name|u
operator|.
name|d
operator|=
name|dconstm1
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|big_endian
operator|.
name|sign
operator|==
literal|1
condition|)
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|u
operator|.
name|big_endian
operator|.
name|exponent
operator|==
literal|2047
operator|&&
operator|(
name|u
operator|.
name|big_endian
operator|.
name|mantissa1
operator|!=
literal|0
operator|||
name|u
operator|.
name|big_endian
operator|.
name|mantissa2
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
else|else
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|u
operator|.
name|little_endian
operator|.
name|exponent
operator|==
literal|2047
operator|&&
operator|(
name|u
operator|.
name|little_endian
operator|.
name|mantissa1
operator|!=
literal|0
operator|||
name|u
operator|.
name|little_endian
operator|.
name|mantissa2
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Check for a negative IEEE double precision number.  */
end_comment

begin_function
name|int
name|target_negative
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
comment|/* The IEEE 64-bit double format.  */
union|union
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
struct|struct
block|{
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|mantissa2
range|:
literal|32
decl_stmt|;
block|}
name|little_endian
struct|;
struct|struct
block|{
name|unsigned
name|mantissa2
range|:
literal|32
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
block|}
name|big_endian
struct|;
block|}
name|u
union|;
name|u
operator|.
name|d
operator|=
name|dconstm1
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|big_endian
operator|.
name|sign
operator|==
literal|1
condition|)
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
name|u
operator|.
name|big_endian
operator|.
name|sign
return|;
block|}
else|else
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
name|u
operator|.
name|little_endian
operator|.
name|sign
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Target not IEEE */
end_comment

begin_comment
comment|/* Let's assume other float formats don't have infinity.    (This can be overridden by redefining REAL_VALUE_ISINF.)  */
end_comment

begin_function
name|int
name|target_isinf
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Let's assume other float formats don't have NaNs.    (This can be overridden by redefining REAL_VALUE_ISNAN.)  */
end_comment

begin_function
name|int
name|target_isnan
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Let's assume other float formats don't have minus zero.    (This can be overridden by redefining REAL_VALUE_NEGATIVE.)  */
end_comment

begin_function
name|int
name|target_negative
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
return|return
name|x
operator|<
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Target not IEEE */
end_comment

begin_comment
comment|/* Try to change R into its exact multiplicative inverse in machine mode    MODE.  Return nonzero function value if successful.  */
end_comment

begin_struct
struct|struct
name|exact_real_inverse_args
block|{
name|REAL_VALUE_TYPE
modifier|*
name|r
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|success
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|exact_real_inverse_1
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|exact_real_inverse_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|exact_real_inverse_args
operator|*
operator|)
name|p
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|args
operator|->
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|r
init|=
name|args
operator|->
name|r
decl_stmt|;
union|union
block|{
name|double
name|d
decl_stmt|;
name|unsigned
name|short
name|i
index|[
literal|4
index|]
decl_stmt|;
block|}
name|x
union|,
name|t
union|,
name|y
union|;
ifdef|#
directive|ifdef
name|CHECK_FLOAT_VALUE
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* Set array index to the less significant bits in the unions, depending      on the endian-ness of the host doubles.  */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|VAX_FLOAT_FORMAT
expr|\
operator|||
name|HOST_FLOAT_FORMAT
operator|==
name|IBM_FLOAT_FORMAT
define|#
directive|define
name|K
value|2
else|#
directive|else
define|#
directive|define
name|K
value|(2 * HOST_FLOAT_WORDS_BIG_ENDIAN)
endif|#
directive|endif
comment|/* Domain check the argument.  */
name|x
operator|.
name|d
operator|=
operator|*
name|r
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|d
operator|==
literal|0.0
condition|)
goto|goto
name|fail
goto|;
ifdef|#
directive|ifdef
name|REAL_INFINITY
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|x
operator|.
name|d
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|x
operator|.
name|d
argument_list|)
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
comment|/* Compute the reciprocal and check for numerical exactness.      It is unnecessary to check all the significand bits to determine      whether X is a power of 2.  If X is not, then it is impossible for      the bottom half significand of both X and 1/X to be all zero bits.      Hence we ignore the data structure of the top half and examine only      the low order bits of the two significands.  */
name|t
operator|.
name|d
operator|=
literal|1.0
operator|/
name|x
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|i
index|[
name|K
index|]
operator|!=
literal|0
operator|||
name|x
operator|.
name|i
index|[
name|K
operator|+
literal|1
index|]
operator|!=
literal|0
operator|||
name|t
operator|.
name|i
index|[
name|K
index|]
operator|!=
literal|0
operator|||
name|t
operator|.
name|i
index|[
name|K
operator|+
literal|1
index|]
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Truncate to the required mode and range-check the result.  */
name|y
operator|.
name|d
operator|=
name|REAL_VALUE_TRUNCATE
argument_list|(
name|mode
argument_list|,
name|t
operator|.
name|d
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CHECK_FLOAT_VALUE
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CHECK_FLOAT_VALUE
argument_list|(
name|mode
argument_list|,
name|y
operator|.
name|d
argument_list|,
name|i
argument_list|)
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
comment|/* Fail if truncation changed the value.  */
if|if
condition|(
name|y
operator|.
name|d
operator|!=
name|t
operator|.
name|d
operator|||
name|y
operator|.
name|d
operator|==
literal|0.0
condition|)
goto|goto
name|fail
goto|;
ifdef|#
directive|ifdef
name|REAL_INFINITY
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|y
operator|.
name|d
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|y
operator|.
name|d
argument_list|)
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
comment|/* Output the reciprocal and return success flag.  */
operator|*
name|r
operator|=
name|y
operator|.
name|d
expr_stmt|;
name|args
operator|->
name|success
operator|=
literal|1
expr_stmt|;
return|return;
name|fail
label|:
name|args
operator|->
name|success
operator|=
literal|0
expr_stmt|;
return|return;
undef|#
directive|undef
name|K
block|}
end_function

begin_function
name|int
name|exact_real_inverse
parameter_list|(
name|mode
parameter_list|,
name|r
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|r
decl_stmt|;
block|{
name|struct
name|exact_real_inverse_args
name|args
decl_stmt|;
comment|/* Disable if insufficient information on the data structure.  */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|UNKNOWN_FLOAT_FORMAT
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Usually disable if bounds checks are not reliable.  */
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|)
operator|&&
operator|!
name|flag_pretend_float
condition|)
return|return
literal|0
return|;
name|args
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|args
operator|.
name|r
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|do_float_handler
argument_list|(
name|exact_real_inverse_1
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
return|return
name|args
operator|.
name|success
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert C99 hexadecimal floating point string constant S.  Return    real value type in mode MODE.  This function uses the host computer's    floating point arithmetic when there is no REAL_ARITHMETIC.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|real_hex_to_f
parameter_list|(
name|s
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|ip
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|shcount
decl_stmt|,
name|nrmcount
decl_stmt|,
name|k
decl_stmt|;
name|int
name|sign
decl_stmt|,
name|expsign
decl_stmt|,
name|isfloat
decl_stmt|;
name|int
name|lost
init|=
literal|0
decl_stmt|;
comment|/* Nonzero low order bits shifted out and discarded.  */
name|int
name|frexpon
init|=
literal|0
decl_stmt|;
comment|/* Bits after the decimal point.  */
name|int
name|expon
init|=
literal|0
decl_stmt|;
comment|/* Value of exponent.  */
name|int
name|decpt
init|=
literal|0
decl_stmt|;
comment|/* How many decimal points.  */
name|int
name|gotp
init|=
literal|0
decl_stmt|;
comment|/* How many P's.  */
name|char
name|c
decl_stmt|;
name|isfloat
operator|=
literal|0
expr_stmt|;
name|expsign
operator|=
literal|1
expr_stmt|;
name|ip
operator|=
literal|0.0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Sign, if any, comes first.  */
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
comment|/* The string is supposed to start with 0x or 0X .  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'x'
operator|||
operator|*
name|p
operator|==
literal|'X'
condition|)
operator|++
name|p
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
operator|++
name|p
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|shcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|k
operator|=
name|hex_value
argument_list|(
name|c
operator|&
name|CHARMASK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|high
operator|&
literal|0xf0000000
operator|)
operator|==
literal|0
condition|)
block|{
name|high
operator|=
operator|(
name|high
operator|<<
literal|4
operator|)
operator|+
operator|(
operator|(
name|low
operator|>>
literal|28
operator|)
operator|&
literal|15
operator|)
expr_stmt|;
name|low
operator|=
operator|(
name|low
operator|<<
literal|4
operator|)
operator|+
name|k
expr_stmt|;
name|shcount
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|decpt
condition|)
name|frexpon
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* Record nonzero lost bits.  */
name|lost
operator||=
name|k
expr_stmt|;
if|if
condition|(
operator|!
name|decpt
condition|)
name|frexpon
operator|-=
literal|4
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
operator|++
name|decpt
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'P'
condition|)
block|{
operator|++
name|gotp
expr_stmt|;
operator|++
name|p
expr_stmt|;
comment|/* Sign of exponent.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|expsign
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
comment|/* Value of exponent. 	     The exponent field is a decimal integer.  */
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|k
operator|=
operator|(
operator|*
name|p
operator|++
operator|&
name|CHARMASK
operator|)
operator|-
literal|'0'
expr_stmt|;
name|expon
operator|=
literal|10
operator|*
name|expon
operator|+
name|k
expr_stmt|;
block|}
name|expon
operator|*=
name|expsign
expr_stmt|;
comment|/* F suffix is ambiguous in the significand part 	     so it must appear after the decimal exponent field.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'f'
operator|||
operator|*
name|p
operator|==
literal|'F'
condition|)
block|{
name|isfloat
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
block|{
operator|++
name|p
expr_stmt|;
break|break;
block|}
else|else
break|break;
block|}
comment|/* Abort if last character read was not legitimate.  */
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
operator|)
operator|||
operator|(
name|decpt
operator|>
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* There must be either one decimal point or one p.  */
if|if
condition|(
name|decpt
operator|==
literal|0
operator|&&
name|gotp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|shcount
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|high
operator|==
literal|0
operator|&&
name|low
operator|==
literal|0
condition|)
return|return
name|dconst0
return|;
comment|/* Normalize.  */
name|nrmcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|high
operator|==
literal|0
condition|)
block|{
name|high
operator|=
name|low
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|nrmcount
operator|+=
literal|32
expr_stmt|;
block|}
comment|/* Leave a high guard bit for carry-out.  */
if|if
condition|(
operator|(
name|high
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
block|{
name|lost
operator||=
name|low
operator|&
literal|1
expr_stmt|;
name|low
operator|=
operator|(
name|low
operator|>>
literal|1
operator|)
operator||
operator|(
name|high
operator|<<
literal|31
operator|)
expr_stmt|;
name|high
operator|=
name|high
operator|>>
literal|1
expr_stmt|;
name|nrmcount
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|high
operator|&
literal|0xffff8000
operator|)
operator|==
literal|0
condition|)
block|{
name|high
operator|=
operator|(
name|high
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|low
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|low
operator|=
name|low
operator|<<
literal|16
expr_stmt|;
name|nrmcount
operator|+=
literal|16
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|high
operator|&
literal|0xc0000000
operator|)
operator|==
literal|0
condition|)
block|{
name|high
operator|=
operator|(
name|high
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|low
operator|>>
literal|31
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|low
operator|=
name|low
operator|<<
literal|1
expr_stmt|;
name|nrmcount
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isfloat
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_WORD
condition|)
block|{
comment|/* Keep 24 bits precision, bits 0x7fffff80. 	 Rounding bit is 0x40.  */
name|lost
operator|=
name|lost
operator||
name|low
operator||
operator|(
name|high
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|high
operator|&
literal|0x40
condition|)
block|{
if|if
condition|(
operator|(
name|high
operator|&
literal|0x80
operator|)
operator|||
name|lost
condition|)
name|high
operator|+=
literal|0x40
expr_stmt|;
block|}
name|high
operator|&=
literal|0xffffff80
expr_stmt|;
block|}
else|else
block|{
comment|/* We need real.c to do long double formats, so here default 	 to double precision.  */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
comment|/* IEEE double. 	 Keep 53 bits precision, bits 0x7fffffff fffffc00. 	 Rounding bit is low word 0x200.  */
name|lost
operator|=
name|lost
operator||
operator|(
name|low
operator|&
literal|0x1ff
operator|)
expr_stmt|;
if|if
condition|(
name|low
operator|&
literal|0x200
condition|)
block|{
if|if
condition|(
operator|(
name|low
operator|&
literal|0x400
operator|)
operator|||
name|lost
condition|)
block|{
name|low
operator|=
operator|(
name|low
operator|+
literal|0x200
operator|)
operator|&
literal|0xfffffc00
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
name|high
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|low
operator|&=
literal|0xfffffc00
expr_stmt|;
else|#
directive|else
comment|/* Assume it's a VAX with 56-bit significand, 	 bits 0x7fffffff ffffff80.  */
name|lost
operator|=
name|lost
operator||
operator|(
name|low
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
name|low
operator|&
literal|0x40
condition|)
block|{
if|if
condition|(
operator|(
name|low
operator|&
literal|0x80
operator|)
operator|||
name|lost
condition|)
block|{
name|low
operator|=
operator|(
name|low
operator|+
literal|0x40
operator|)
operator|&
literal|0xffffff80
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
name|high
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|low
operator|&=
literal|0xffffff80
expr_stmt|;
endif|#
directive|endif
block|}
name|ip
operator|=
operator|(
name|double
operator|)
name|high
expr_stmt|;
name|ip
operator|=
name|REAL_VALUE_LDEXP
argument_list|(
name|ip
argument_list|,
literal|32
argument_list|)
operator|+
operator|(
name|double
operator|)
name|low
expr_stmt|;
comment|/* Apply shifts and exponent value as power of 2.  */
name|ip
operator|=
name|REAL_VALUE_LDEXP
argument_list|(
name|ip
argument_list|,
name|expon
operator|-
operator|(
name|nrmcount
operator|+
name|frexpon
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
name|ip
operator|=
operator|-
name|ip
expr_stmt|;
return|return
name|ip
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no REAL_ARITHMETIC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Given T, an expression, return the negation of T.  Allow for T to be    null, in which case return null.  */
end_comment

begin_function
specifier|static
name|tree
name|negate_expr
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|tem
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|NEGATE_EXPR
case|:
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
comment|/* - (A - B) -> B - A  */
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split a tree IN into a constant, literal and variable parts that could be    combined with CODE to make IN.  "constant" means an expression with    TREE_CONSTANT but that isn't an actual constant.  CODE must be a    commutative arithmetic operation.  Store the constant part into *CONP,    the literal in&LITP and return the variable part.  If a part isn't    present, set it to null.  If the tree does not decompose in this way,    return the entire tree as the variable part and the other parts as null.     If CODE is PLUS_EXPR we also split trees that use MINUS_EXPR.  In that    case, we negate an operand that was subtracted.  If NEGATE_P is true, we    are negating all of IN.     If IN is itself a literal or constant, return it as appropriate.     Note that we do not guarantee that any of the three values will be the    same type as IN, but they will have the same signedness and mode.  */
end_comment

begin_function
specifier|static
name|tree
name|split_tree
parameter_list|(
name|in
parameter_list|,
name|code
parameter_list|,
name|conp
parameter_list|,
name|litp
parameter_list|,
name|negate_p
parameter_list|)
name|tree
name|in
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
modifier|*
name|conp
decl_stmt|,
decl|*
name|litp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|negate_p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|var
init|=
literal|0
decl_stmt|;
operator|*
name|conp
operator|=
literal|0
expr_stmt|;
operator|*
name|litp
operator|=
literal|0
expr_stmt|;
comment|/* Strip any conversions that don't change the machine mode or signedness.  */
name|STRIP_SIGN_NOPS
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REAL_CST
condition|)
operator|*
name|litp
operator|=
name|in
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|code
operator|||
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|in
argument_list|)
argument_list|)
comment|/* We can associate addition and subtraction together (even 		  though the C standard doesn't say so) for integers because 		  the value is not affected.  For reals, the value might be 		  affected, so we can't.  */
operator|&&
operator|(
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|||
operator|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|PLUS_EXPR
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|neg1_p
init|=
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
decl_stmt|;
name|int
name|neg_litp_p
init|=
literal|0
decl_stmt|,
name|neg_conp_p
init|=
literal|0
decl_stmt|,
name|neg_var_p
init|=
literal|0
decl_stmt|;
comment|/* First see if either of the operands is a literal, then a constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REAL_CST
condition|)
operator|*
name|litp
operator|=
name|op0
operator|,
name|op0
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REAL_CST
condition|)
operator|*
name|litp
operator|=
name|op1
operator|,
name|neg_litp_p
operator|=
name|neg1_p
operator|,
name|op1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
literal|0
operator|&&
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
condition|)
operator|*
name|conp
operator|=
name|op0
operator|,
name|op0
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|op1
operator|!=
literal|0
operator|&&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
condition|)
operator|*
name|conp
operator|=
name|op1
operator|,
name|neg_conp_p
operator|=
name|neg1_p
operator|,
name|op1
operator|=
literal|0
expr_stmt|;
comment|/* If we haven't dealt with either operand, this is not a case we can 	 decompose.  Otherwise, VAR is either of the ones remaining, if any.  */
if|if
condition|(
name|op0
operator|!=
literal|0
operator|&&
name|op1
operator|!=
literal|0
condition|)
name|var
operator|=
name|in
expr_stmt|;
elseif|else
if|if
condition|(
name|op0
operator|!=
literal|0
condition|)
name|var
operator|=
name|op0
expr_stmt|;
else|else
name|var
operator|=
name|op1
operator|,
name|neg_var_p
operator|=
name|neg1_p
expr_stmt|;
comment|/* Now do any needed negations.  */
if|if
condition|(
name|neg_litp_p
condition|)
operator|*
name|litp
operator|=
name|negate_expr
argument_list|(
operator|*
name|litp
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg_conp_p
condition|)
operator|*
name|conp
operator|=
name|negate_expr
argument_list|(
operator|*
name|conp
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg_var_p
condition|)
name|var
operator|=
name|negate_expr
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|in
argument_list|)
condition|)
operator|*
name|conp
operator|=
name|in
expr_stmt|;
else|else
name|var
operator|=
name|in
expr_stmt|;
if|if
condition|(
name|negate_p
condition|)
block|{
name|var
operator|=
name|negate_expr
argument_list|(
name|var
argument_list|)
expr_stmt|;
operator|*
name|conp
operator|=
name|negate_expr
argument_list|(
operator|*
name|conp
argument_list|)
expr_stmt|;
operator|*
name|litp
operator|=
name|negate_expr
argument_list|(
operator|*
name|litp
argument_list|)
expr_stmt|;
block|}
return|return
name|var
return|;
block|}
end_block

begin_comment
comment|/* Re-associate trees split by the above function.  T1 and T2 are either    expressions to associate or null.  Return the new expression, if any.  If    we build an operation, do it in TYPE and with CODE, except if CODE is a    MINUS_EXPR, in which case we use PLUS_EXPR since split_tree will already    have taken care of the negations.  */
end_comment

begin_function
specifier|static
name|tree
name|associate_trees
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|,
name|code
parameter_list|,
name|type
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|t1
operator|==
literal|0
condition|)
return|return
name|t2
return|;
elseif|else
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
comment|/* If either input is CODE, a PLUS_EXPR, or a MINUS_EXPR, don't      try to fold this since we will have infinite recursion.  But do      deal with any NEGATE_EXPRs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|code
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|code
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|MINUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|)
return|;
block|}
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Combine two integer constants ARG1 and ARG2 under operation CODE    to produce a new constant.     If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */
end_comment

begin_function
specifier|static
name|tree
name|int_const_binop
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|notrunc
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|int
name|notrunc
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|int1l
decl_stmt|,
name|int2l
decl_stmt|;
name|HOST_WIDE_INT
name|int1h
decl_stmt|,
name|int2h
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|garbagel
decl_stmt|;
name|HOST_WIDE_INT
name|garbageh
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|is_sizetype
init|=
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|no_overflow
init|=
literal|0
decl_stmt|;
name|int1l
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|int1h
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|int2l
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|int2h
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BIT_IOR_EXPR
case|:
name|low
operator|=
name|int1l
operator||
name|int2l
operator|,
name|hi
operator|=
name|int1h
operator||
name|int2h
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|low
operator|=
name|int1l
operator|^
name|int2l
operator|,
name|hi
operator|=
name|int1h
operator|^
name|int2h
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|low
operator|=
name|int1l
operator|&
name|int2l
operator|,
name|hi
operator|=
name|int1h
operator|&
name|int2h
expr_stmt|;
break|break;
case|case
name|BIT_ANDTC_EXPR
case|:
name|low
operator|=
name|int1l
operator|&
operator|~
name|int2l
operator|,
name|hi
operator|=
name|int1h
operator|&
operator|~
name|int2h
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|int2l
operator|=
operator|-
name|int2l
expr_stmt|;
case|case
name|LSHIFT_EXPR
case|:
comment|/* It's unclear from the C standard whether shifts can overflow. 	 The following code ignores overflow; perhaps a C standard 	 interpretation ruling is needed.  */
name|lshift_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|,
operator|!
name|uns
argument_list|)
expr_stmt|;
name|no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RROTATE_EXPR
case|:
name|int2l
operator|=
operator|-
name|int2l
expr_stmt|;
case|case
name|LROTATE_EXPR
case|:
name|lrotate_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
name|overflow
operator|=
name|add_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|neg_double
argument_list|(
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|low
argument_list|,
name|hi
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|OVERFLOW_SUM_SIGN
argument_list|(
name|hi
argument_list|,
name|int2h
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|overflow
operator|=
name|mul_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* This is a shortcut for a common special case.  */
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int2l
operator|>
literal|0
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|&&
name|int1h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int1l
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CEIL_DIV_EXPR
condition|)
name|int1l
operator|+=
name|int2l
operator|-
literal|1
expr_stmt|;
name|low
operator|=
name|int1l
operator|/
name|int2l
operator|,
name|hi
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* ... fall through ...  */
case|case
name|ROUND_DIV_EXPR
case|:
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
name|int2l
operator|==
literal|1
condition|)
block|{
name|low
operator|=
name|int1l
operator|,
name|hi
operator|=
name|int1h
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int1l
operator|==
name|int2l
operator|&&
name|int1h
operator|==
name|int2h
operator|&&
operator|!
operator|(
name|int1l
operator|==
literal|0
operator|&&
name|int1h
operator|==
literal|0
operator|)
condition|)
block|{
name|low
operator|=
literal|1
operator|,
name|hi
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|overflow
operator|=
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|garbagel
argument_list|,
operator|&
name|garbageh
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
comment|/* This is a shortcut for a common special case.  */
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int2l
operator|>
literal|0
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|&&
name|int1h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int1l
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CEIL_MOD_EXPR
condition|)
name|int1l
operator|+=
name|int2l
operator|-
literal|1
expr_stmt|;
name|low
operator|=
name|int1l
operator|%
name|int2l
operator|,
name|hi
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* ... fall through ...  */
case|case
name|ROUND_MOD_EXPR
case|:
name|overflow
operator|=
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|garbagel
argument_list|,
operator|&
name|garbageh
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
if|if
condition|(
name|uns
condition|)
name|low
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int1h
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int2h
operator|)
operator|||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int1h
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int2h
operator|)
operator|&&
name|int1l
operator|<
name|int2l
operator|)
operator|)
expr_stmt|;
else|else
name|low
operator|=
operator|(
name|int1h
operator|<
name|int2h
operator|||
operator|(
name|int1h
operator|==
name|int2h
operator|&&
name|int1l
operator|<
name|int2l
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|low
operator|==
operator|(
name|code
operator|==
name|MIN_EXPR
operator|)
condition|)
name|low
operator|=
name|int1l
operator|,
name|hi
operator|=
name|int1h
expr_stmt|;
else|else
name|low
operator|=
name|int2l
operator|,
name|hi
operator|=
name|int2h
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this is for a sizetype, can be represented as one (signed)      HOST_WIDE_INT word, and doesn't overflow, use size_int since it caches      constants.  */
if|if
condition|(
name|is_sizetype
operator|&&
operator|(
operator|(
name|hi
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|low
operator|>=
literal|0
operator|)
operator|||
operator|(
name|hi
operator|==
operator|-
literal|1
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|low
operator|<
literal|0
operator|)
operator|)
operator|&&
name|overflow
operator|==
literal|0
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|arg2
argument_list|)
condition|)
return|return
name|size_int_type_wide
argument_list|(
name|low
argument_list|,
name|type
argument_list|)
return|;
else|else
block|{
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
operator|(
operator|(
name|notrunc
condition|?
operator|(
operator|!
name|uns
operator|||
name|is_sizetype
operator|)
operator|&&
name|overflow
else|:
operator|(
name|force_fit_type
argument_list|(
name|t
argument_list|,
operator|(
operator|!
name|uns
operator|||
name|is_sizetype
operator|)
operator|&&
name|overflow
argument_list|)
operator|&&
operator|!
name|no_overflow
operator|)
operator|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|)
expr_stmt|;
comment|/* If we're doing a size calculation, unsigned arithmetic does overflow.      So check if force_fit_type truncated the value.  */
if|if
condition|(
name|is_sizetype
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|!=
name|hi
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|!=
name|low
operator|)
condition|)
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Define input and output argument for const_binop_1.  */
end_comment

begin_struct
struct|struct
name|cb_args
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
comment|/* Input: tree code for operation.  */
name|tree
name|type
decl_stmt|;
comment|/* Input: tree type for operation.  */
name|REAL_VALUE_TYPE
name|d1
decl_stmt|,
name|d2
decl_stmt|;
comment|/* Input: floating point operands.  */
name|tree
name|t
decl_stmt|;
comment|/* Output: constant for result.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Do the real arithmetic for const_binop while protected by a    float overflow handler.  */
end_comment

begin_function
specifier|static
name|void
name|const_binop_1
parameter_list|(
name|data
parameter_list|)
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|cb_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|cb_args
operator|*
operator|)
name|data
decl_stmt|;
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_ARITHMETIC
argument_list|(
name|value
argument_list|,
name|args
operator|->
name|code
argument_list|,
name|args
operator|->
name|d1
argument_list|,
name|args
operator|->
name|d2
argument_list|)
expr_stmt|;
else|#
directive|else
switch|switch
condition|(
name|args
operator|->
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|value
operator|=
name|args
operator|->
name|d1
operator|+
name|args
operator|->
name|d2
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|value
operator|=
name|args
operator|->
name|d1
operator|-
name|args
operator|->
name|d2
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|value
operator|=
name|args
operator|->
name|d1
operator|*
name|args
operator|->
name|d2
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
ifndef|#
directive|ifndef
name|REAL_INFINITY
if|if
condition|(
name|args
operator|->
name|d2
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
name|args
operator|->
name|d1
operator|/
name|args
operator|->
name|d2
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|value
operator|=
name|MIN
argument_list|(
name|args
operator|->
name|d1
argument_list|,
name|args
operator|->
name|d2
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|value
operator|=
name|MAX
argument_list|(
name|args
operator|->
name|d1
argument_list|,
name|args
operator|->
name|d2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* no REAL_ARITHMETIC */
name|args
operator|->
name|t
operator|=
name|build_real
argument_list|(
name|args
operator|->
name|type
argument_list|,
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Combine two constants ARG1 and ARG2 under operation CODE to produce a new    constant.  We assume ARG1 and ARG2 have the same data type, or at least    are the same kind of constant and the same machine mode.     If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */
end_comment

begin_function
specifier|static
name|tree
name|const_binop
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|notrunc
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|int
name|notrunc
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|int_const_binop
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|notrunc
argument_list|)
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|REAL_VALUE_TYPE
name|d1
decl_stmt|;
name|REAL_VALUE_TYPE
name|d2
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|struct
name|cb_args
name|args
decl_stmt|;
name|d1
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* If either operand is a NaN, just return it.  Otherwise, set up 	 for floating-point trap; we return an overflow.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d1
argument_list|)
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d2
argument_list|)
condition|)
return|return
name|arg2
return|;
comment|/* Setup input for const_binop_1() */
name|args
operator|.
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|args
operator|.
name|d1
operator|=
name|d1
expr_stmt|;
name|args
operator|.
name|d2
operator|=
name|d2
expr_stmt|;
name|args
operator|.
name|code
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|do_float_handler
argument_list|(
name|const_binop_1
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
comment|/* Receive output from const_binop_1.  */
name|t
operator|=
name|args
operator|.
name|t
expr_stmt|;
else|else
block|{
comment|/* We got an exception from const_binop_1.  */
name|t
operator|=
name|copy_node
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|overflow
operator|=
literal|1
expr_stmt|;
block|}
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|force_fit_type
argument_list|(
name|t
argument_list|,
name|overflow
argument_list|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|r1
init|=
name|TREE_REALPART
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|i1
init|=
name|TREE_IMAGPART
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|r2
init|=
name|TREE_REALPART
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|tree
name|i2
init|=
name|TREE_IMAGPART
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
block|{
name|tree
name|magsquared
init|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r2
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i2
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_complex
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|r1
argument_list|)
argument_list|)
condition|?
name|TRUNC_DIV_EXPR
else|:
name|RDIV_EXPR
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|magsquared
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|r1
argument_list|)
argument_list|)
condition|?
name|TRUNC_DIV_EXPR
else|:
name|RDIV_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|magsquared
argument_list|,
name|notrunc
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* These are the hash table functions for the hash table of INTEGER_CST    nodes of a sizetype.  */
end_comment

begin_comment
comment|/* Return the hash code code X, an INTEGER_CST.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|size_htab_hash
parameter_list|(
name|x
parameter_list|)
specifier|const
name|void
modifier|*
name|x
decl_stmt|;
block|{
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|x
decl_stmt|;
return|return
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|^
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|^
call|(
name|hashval_t
call|)
argument_list|(
operator|(
name|long
operator|)
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|>>
literal|3
argument_list|)
operator|^
operator|(
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|<<
literal|20
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the value represented by *X (an INTEGER_CST tree node)    is the same as that given by *Y, which is the same.  */
end_comment

begin_function
specifier|static
name|int
name|size_htab_eq
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|void
modifier|*
name|x
decl_stmt|;
specifier|const
name|void
modifier|*
name|y
decl_stmt|;
block|{
name|tree
name|xt
init|=
operator|(
name|tree
operator|)
name|x
decl_stmt|;
name|tree
name|yt
init|=
operator|(
name|tree
operator|)
name|y
decl_stmt|;
return|return
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|xt
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|yt
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|xt
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|yt
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|xt
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|yt
argument_list|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|xt
argument_list|)
operator|==
name|TREE_OVERFLOW
argument_list|(
name|yt
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an INTEGER_CST with value whose low-order HOST_BITS_PER_WIDE_INT    bits are given by NUMBER and of the sizetype represented by KIND.  */
end_comment

begin_function
name|tree
name|size_int_wide
parameter_list|(
name|number
parameter_list|,
name|kind
parameter_list|)
name|HOST_WIDE_INT
name|number
decl_stmt|;
name|enum
name|size_type_kind
name|kind
decl_stmt|;
block|{
return|return
name|size_int_type_wide
argument_list|(
name|number
argument_list|,
name|sizetype_tab
index|[
operator|(
name|int
operator|)
name|kind
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but the desired type is specified explicitly.  */
end_comment

begin_function
name|tree
name|size_int_type_wide
parameter_list|(
name|number
parameter_list|,
name|type
parameter_list|)
name|HOST_WIDE_INT
name|number
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|static
name|htab_t
name|size_htab
init|=
literal|0
decl_stmt|;
specifier|static
name|tree
name|new_const
init|=
literal|0
decl_stmt|;
name|PTR
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|size_htab
operator|==
literal|0
condition|)
block|{
name|size_htab
operator|=
name|htab_create
argument_list|(
literal|1024
argument_list|,
name|size_htab_hash
argument_list|,
name|size_htab_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ggc_add_deletable_htab
argument_list|(
name|size_htab
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new_const
operator|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|new_const
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust NEW_CONST to be the constant we want.  If it's already in the      hash table, we return the value from the hash table.  Otherwise, we      place that in the hash table and make a new node for the next time.  */
name|TREE_INT_CST_LOW
argument_list|(
name|new_const
argument_list|)
operator|=
name|number
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|new_const
argument_list|)
operator|=
name|number
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_const
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|new_const
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|new_const
argument_list|)
operator|=
name|force_fit_type
argument_list|(
name|new_const
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|size_htab
argument_list|,
name|new_const
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
literal|0
condition|)
block|{
name|tree
name|t
init|=
name|new_const
decl_stmt|;
operator|*
name|slot
operator|=
operator|(
name|PTR
operator|)
name|new_const
expr_stmt|;
name|new_const
operator|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
else|else
return|return
operator|(
name|tree
operator|)
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Combine operands OP1 and OP2 with arithmetic operation CODE.  CODE    is a tree code.  The type of the result is taken from the operands.    Both must be the same type integer type and it must be a size type.    If the operands are constant, so is the result.  */
end_comment

begin_function
name|tree
name|size_binop
parameter_list|(
name|code
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
operator|!
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
operator|||
name|type
operator|!=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Handle the special case of two integer constants faster.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* And some specific cases even faster than that.  */
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|MINUS_EXPR
operator|||
name|code
operator|==
name|PLUS_EXPR
operator|)
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|arg0
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg1
return|;
comment|/* Handle general case of two integer constants.  */
return|return
name|int_const_binop
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given two values, either both of sizetype or both of bitsizetype,    compute the difference between the two values.  Return the value    in signed type corresponding to the type of the operands.  */
end_comment

begin_function
name|tree
name|size_diffop
parameter_list|(
name|arg0
parameter_list|,
name|arg1
parameter_list|)
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|ctype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
operator|!
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
operator|||
name|type
operator|!=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the type is already signed, just do the simple thing.  */
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
name|ctype
operator|=
operator|(
name|type
operator|==
name|bitsizetype
operator|||
name|type
operator|==
name|ubitsizetype
condition|?
name|sbitsizetype
else|:
name|ssizetype
operator|)
expr_stmt|;
comment|/* If either operand is not a constant, do the conversions to the signed      type and subtract.  The hardware will do the right thing with any      overflow in the subtraction.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* If ARG0 is larger than ARG1, subtract and return the result in CTYPE.      Otherwise, subtract the other way, convert to CTYPE (we know that can't      overflow) and negate (which can't either).  Special-case a result      of zero while we're here.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|ctype
argument_list|,
name|integer_zero_node
argument_list|)
return|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|arg1
argument_list|,
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|ctype
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This structure is used to communicate arguments to fold_convert_1.  */
end_comment

begin_struct
struct|struct
name|fc_args
block|{
name|tree
name|arg1
decl_stmt|;
comment|/* Input: value to convert.  */
name|tree
name|type
decl_stmt|;
comment|/* Input: type to convert value to.  */
name|tree
name|t
decl_stmt|;
comment|/* Output: result of conversion.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Function to convert floating-point constants, protected by floating    point exception handler.  */
end_comment

begin_function
specifier|static
name|void
name|fold_convert_1
parameter_list|(
name|data
parameter_list|)
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|fc_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|fc_args
operator|*
operator|)
name|data
decl_stmt|;
name|args
operator|->
name|t
operator|=
name|build_real
argument_list|(
name|args
operator|->
name|type
argument_list|,
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|args
operator|->
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given T, a tree representing type conversion of ARG1, a constant,    return a constant tree representing the result of conversion.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_convert
parameter_list|(
name|t
parameter_list|,
name|arg1
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|arg1
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* If we would build a constant wider than GCC supports, 	     leave the conversion unfolded.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|t
return|;
comment|/* If we are trying to make a sizetype for a small integer, use 	     size_int to pick up cached types to reduce duplicate nodes.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|compare_tree_int
argument_list|(
name|arg1
argument_list|,
literal|10000
argument_list|)
operator|<
literal|0
condition|)
return|return
name|size_int_type_wide
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
comment|/* Given an integer constant, make new constant with new type, 	     appropriately sign-extended or truncated.  */
name|t
operator|=
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Indicate an overflow if (1) ARG1 already overflowed, 	     or (2) force_fit_type indicates an overflow. 	     Tell force_fit_type that an overflow has already occurred 	     if ARG1 is a too-large unsigned value and T is signed. 	     But don't indicate an overflow if converting a pointer.  */
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
operator|(
operator|(
name|force_fit_type
argument_list|(
name|t
argument_list|,
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|<
literal|0
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|<
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|)
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
comment|/* Don't initialize these, use assignments. 	     Initialized local aggregates don't work on old compilers.  */
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|REAL_VALUE_TYPE
name|l
decl_stmt|;
name|REAL_VALUE_TYPE
name|u
decl_stmt|;
name|tree
name|type1
init|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|int
name|no_upper_bound
decl_stmt|;
name|x
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|l
operator|=
name|real_value_from_int_cst
argument_list|(
name|type1
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|no_upper_bound
operator|=
operator|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_upper_bound
condition|)
name|u
operator|=
name|real_value_from_int_cst
argument_list|(
name|type1
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if X will be in range after truncation towards 0. 	     To compensate for truncation, move the bounds away from 0, 	     but reject if X exactly equals the adjusted bounds.  */
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_ARITHMETIC
argument_list|(
name|l
argument_list|,
name|MINUS_EXPR
argument_list|,
name|l
argument_list|,
name|dconst1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_upper_bound
condition|)
name|REAL_ARITHMETIC
argument_list|(
name|u
argument_list|,
name|PLUS_EXPR
argument_list|,
name|u
argument_list|,
name|dconst1
argument_list|)
expr_stmt|;
else|#
directive|else
name|l
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|no_upper_bound
condition|)
name|u
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* If X is a NaN, use zero instead and show we have an overflow. 	     Otherwise, range check.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
condition|)
name|overflow
operator|=
literal|1
operator|,
name|x
operator|=
name|dconst0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|REAL_VALUES_LESS
argument_list|(
name|l
argument_list|,
name|x
argument_list|)
operator|&&
operator|!
name|no_upper_bound
operator|&&
name|REAL_VALUES_LESS
argument_list|(
name|x
argument_list|,
name|u
argument_list|)
operator|)
condition|)
name|overflow
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|HOST_WIDE_INT
name|half_word
init|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
operator|-
name|x
expr_stmt|;
name|high
operator|=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
name|x
operator|/
name|half_word
operator|/
name|half_word
argument_list|)
expr_stmt|;
name|x
operator|-=
operator|(
name|REAL_VALUE_TYPE
operator|)
name|high
operator|*
name|half_word
operator|*
name|half_word
expr_stmt|;
if|if
condition|(
name|x
operator|>=
operator|(
name|REAL_VALUE_TYPE
operator|)
name|half_word
operator|*
name|half_word
operator|/
literal|2
condition|)
block|{
name|low
operator|=
name|x
operator|-
operator|(
name|REAL_VALUE_TYPE
operator|)
name|half_word
operator|*
name|half_word
operator|/
literal|2
expr_stmt|;
name|low
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
name|low
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|x
expr_stmt|;
if|if
condition|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|REAL_VALUE_TO_INT
argument_list|(
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|force_fit_type
argument_list|(
name|t
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|build_real_from_int_cst
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|struct
name|fc_args
name|args
decl_stmt|;
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|t
operator|=
name|arg1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* Setup input for fold_convert_1() */
name|args
operator|.
name|arg1
operator|=
name|arg1
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|do_float_handler
argument_list|(
name|fold_convert_1
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
block|{
comment|/* Receive output from fold_convert_1() */
name|t
operator|=
name|args
operator|.
name|t
expr_stmt|;
block|}
else|else
block|{
comment|/* We got an exception from fold_convert_1() */
name|overflow
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|force_fit_type
argument_list|(
name|t
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an expr equal to X but certainly not valid as an lvalue.  */
end_comment

begin_function
name|tree
name|non_lvalue
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
comment|/* These things are certainly not lvalues.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|x
return|;
name|result
operator|=
name|build1
argument_list|(
name|NON_LVALUE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Nonzero means lvalues are limited to those valid in pedantic ANSI C.    Zero means allow extended lvalues.  */
end_comment

begin_decl_stmt
name|int
name|pedantic_lvalues
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When pedantic, return an expr equal to X but certainly not valid as a    pedantic lvalue.  Otherwise, return X.  */
end_comment

begin_function
name|tree
name|pedantic_non_lvalue
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
if|if
condition|(
name|pedantic_lvalues
condition|)
return|return
name|non_lvalue
argument_list|(
name|x
argument_list|)
return|;
else|else
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a tree comparison code, return the code that is the logical inverse    of the given code.  It is not safe to do this for floating-point    comparisons, except for NE_EXPR and EQ_EXPR.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|invert_tree_comparison
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
return|return
name|NE_EXPR
return|;
case|case
name|NE_EXPR
case|:
return|return
name|EQ_EXPR
return|;
case|case
name|GT_EXPR
case|:
return|return
name|LE_EXPR
return|;
case|case
name|GE_EXPR
case|:
return|return
name|LT_EXPR
return|;
case|case
name|LT_EXPR
case|:
return|return
name|GE_EXPR
return|;
case|case
name|LE_EXPR
case|:
return|return
name|GT_EXPR
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar, but return the comparison that results if the operands are    swapped.  This is safe for floating-point.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|swap_tree_comparison
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
return|return
name|code
return|;
case|case
name|GT_EXPR
case|:
return|return
name|LT_EXPR
return|;
case|case
name|GE_EXPR
case|:
return|return
name|LE_EXPR
return|;
case|case
name|LT_EXPR
case|:
return|return
name|GT_EXPR
return|;
case|case
name|LE_EXPR
case|:
return|return
name|GE_EXPR
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if CODE is a tree code that represents a truth value.  */
end_comment

begin_function
specifier|static
name|int
name|truth_value_p
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_XOR_EXPR
operator|||
name|code
operator|==
name|TRUTH_NOT_EXPR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if two operands are necessarily equal.    If ONLY_CONST is non-zero, only return non-zero for constants.    This function tests whether the operands are indistinguishable;    it does not test whether they are equal using C's == operation.    The distinction is important for IEEE floating point, because    (1) -0.0 and 0.0 are distinguishable, but -0.0==0.0, and    (2) two NaNs may be indistinguishable, but NaN!=NaN.  */
end_comment

begin_function
name|int
name|operand_equal_p
parameter_list|(
name|arg0
parameter_list|,
name|arg1
parameter_list|,
name|only_const
parameter_list|)
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|int
name|only_const
decl_stmt|;
block|{
comment|/* If both types don't have the same signedness, then we can't consider      them equal.  We must check this before the STRIP_NOPS calls      because they may change the signedness of the arguments.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
comment|/* This is needed for conversions and for COMPONENT_REF. 	 Might as well play it safe and always test this.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If ARG0 and ARG1 are the same SAVE_EXPR, they are necessarily equal.      We don't care about side effects in that case because the SAVE_EXPR      takes care of that for us. In all other cases, two expressions are      equal if they have no side effects.  If we have two identical      expressions with side effects that should be treated the same due      to the only side effects being identical SAVE_EXPR's, that will      be detected in the recursive calls below.  */
if|if
condition|(
name|arg0
operator|==
name|arg1
operator|&&
operator|!
name|only_const
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|SAVE_EXPR
operator|||
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Next handle constant cases, those for which we can return 1 even      if ONLY_CONST is set.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
operator|(
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
return|;
case|case
name|REAL_CST
case|:
return|return
operator|(
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|REAL_VALUES_IDENTICAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
operator|(
name|operand_equal_p
argument_list|(
name|TREE_REALPART
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REALPART
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|only_const
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_IMAGPART
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|only_const
argument_list|)
operator|)
return|;
case|case
name|STRING_CST
case|:
return|return
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|only_const
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* Two conversions are equal only if signedness and modes match.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|'<'
case|:
case|case
literal|'2'
case|:
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* For commutative ops, allow the other order.  */
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MIN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MAX_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|EQ_EXPR
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
literal|'r'
case|:
comment|/* If either of the pointer (or reference) expressions we are dereferencing 	 contain a side effect, these cannot be equal.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
return|return
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
return|return
operator|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|BIT_FIELD_REF
case|:
return|return
operator|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
case|case
literal|'e'
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RTL_EXPR
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|RTL_EXPR_RTL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similar to operand_equal_p, but see if ARG0 might have been made by    shorten_compare from ARG1 when ARG1 was being compared with OTHER.     When in doubt, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|operand_equal_for_comparison_p
parameter_list|(
name|arg0
parameter_list|,
name|arg1
parameter_list|,
name|other
parameter_list|)
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|tree
name|other
decl_stmt|;
block|{
name|int
name|unsignedp1
decl_stmt|,
name|unsignedpo
decl_stmt|;
name|tree
name|primarg0
decl_stmt|,
name|primarg1
decl_stmt|,
name|primother
decl_stmt|;
name|unsigned
name|int
name|correct_width
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Discard any conversions that don't change the modes of ARG0 and ARG1      and see if the inner values are the same.  This removes any      signedness comparison, which doesn't matter here.  */
name|primarg0
operator|=
name|arg0
operator|,
name|primarg1
operator|=
name|arg1
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|primarg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|primarg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|primarg0
argument_list|,
name|primarg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Duplicate what shorten_compare does to ARG1 and see if that gives the      actual comparison operand, ARG0.       First throw away any conversions to wider types      already present in the operands.  */
name|primarg1
operator|=
name|get_narrower
argument_list|(
name|arg1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
name|primother
operator|=
name|get_narrower
argument_list|(
name|other
argument_list|,
operator|&
name|unsignedpo
argument_list|)
expr_stmt|;
name|correct_width
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp1
operator|==
name|unsignedpo
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primarg1
argument_list|)
argument_list|)
operator|<
name|correct_width
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primother
argument_list|)
argument_list|)
operator|<
name|correct_width
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primarg1
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primarg1
argument_list|)
argument_list|)
argument_list|,
name|primarg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|primarg1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if ARG is an expression that is either a comparison or is performing    arithmetic on comparisons.  The comparisons must only be comparing    two different values, which will be stored in *CVAL1 and *CVAL2; if    they are non-zero it means that some operands have already been found.    No variables may be used anywhere else in the expression except in the    comparisons.  If SAVE_P is true it means we removed a SAVE_EXPR around    the expression and save_expr needs to be called with CVAL1 and CVAL2.     If this is true, return 1.  Otherwise, return zero.  */
end_comment

begin_function
specifier|static
name|int
name|twoval_comparison_p
parameter_list|(
name|arg
parameter_list|,
name|cval1
parameter_list|,
name|cval2
parameter_list|,
name|save_p
parameter_list|)
name|tree
name|arg
decl_stmt|;
name|tree
modifier|*
name|cval1
decl_stmt|,
decl|*
name|cval2
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|save_p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|char
name|class
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* We can handle some of the 'e' cases here.  */
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
name|code
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|class
operator|=
literal|'1'
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|COMPOUND_EXPR
operator|)
condition|)
name|class
operator|=
literal|'2'
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
name|code
operator|==
name|SAVE_EXPR
operator|&&
name|SAVE_EXPR_RTL
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If we've already found a CVAL1 or CVAL2, this expression is 	 two complex to handle.  */
if|if
condition|(
operator|*
name|cval1
operator|||
operator|*
name|cval2
condition|)
return|return
literal|0
return|;
name|class
operator|=
literal|'1'
expr_stmt|;
operator|*
name|save_p
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|'1'
case|:
return|return
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
return|;
case|case
literal|'2'
case|:
return|return
operator|(
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|)
return|;
case|case
literal|'c'
case|:
return|return
literal|1
return|;
case|case
literal|'e'
case|:
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
return|return
operator|(
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
case|case
literal|'<'
case|:
comment|/* First see if we can handle the first operand, then the second.  For 	 the second operand, we know *CVAL1 can't be zero.  It must be that 	 one side of the comparison is each of the values; test for the 	 case where this isn't true by failing if the two operands 	 are the same.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|cval1
operator|==
literal|0
condition|)
operator|*
name|cval1
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cval2
operator|==
literal|0
condition|)
operator|*
name|cval2
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cval2
operator|==
literal|0
condition|)
operator|*
name|cval2
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ARG is a tree that is known to contain just arithmetic operations and    comparisons.  Evaluate the operations in the tree substituting NEW0 for    any occurrence of OLD0 as an operand of a comparison and likewise for    NEW1 and OLD1.  */
end_comment

begin_function
specifier|static
name|tree
name|eval_subst
parameter_list|(
name|arg
parameter_list|,
name|old0
parameter_list|,
name|new0
parameter_list|,
name|old1
parameter_list|,
name|new1
parameter_list|)
name|tree
name|arg
decl_stmt|;
name|tree
name|old0
decl_stmt|,
name|new0
decl_stmt|,
name|old1
decl_stmt|,
name|new1
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|char
name|class
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* We can handle some of the 'e' cases here.  */
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
name|code
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|class
operator|=
literal|'1'
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
condition|)
name|class
operator|=
literal|'2'
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|'1'
case|:
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
literal|'2'
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
literal|'e'
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SAVE_EXPR
case|:
return|return
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* fall through - ??? */
case|case
literal|'<'
case|:
block|{
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* We need to check both for exact equality and tree equality.  The 	   former will be true if the operand has a side-effect.  In that 	   case, we know the operand occurred exactly once.  */
if|if
condition|(
name|arg0
operator|==
name|old0
operator|||
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|old0
argument_list|,
literal|0
argument_list|)
condition|)
name|arg0
operator|=
name|new0
expr_stmt|;
elseif|else
if|if
condition|(
name|arg0
operator|==
name|old1
operator|||
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|old1
argument_list|,
literal|0
argument_list|)
condition|)
name|arg0
operator|=
name|new1
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|old0
operator|||
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|old0
argument_list|,
literal|0
argument_list|)
condition|)
name|arg1
operator|=
name|new0
expr_stmt|;
elseif|else
if|if
condition|(
name|arg1
operator|==
name|old1
operator|||
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|old1
argument_list|,
literal|0
argument_list|)
condition|)
name|arg1
operator|=
name|new1
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
default|default:
return|return
name|arg
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the case when the result of an expression is RESULT    converted to TYPE and OMITTED was previously an operand of the expression    but is now not needed (e.g., we folded OMITTED * 0).     If OMITTED has side effects, we must evaluate it.  Otherwise, just do    the conversion of RESULT to TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|omit_one_operand
parameter_list|(
name|type
parameter_list|,
name|result
parameter_list|,
name|omitted
parameter_list|)
name|tree
name|type
decl_stmt|,
name|result
decl_stmt|,
name|omitted
decl_stmt|;
block|{
name|tree
name|t
init|=
name|convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|omitted
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|omitted
argument_list|,
name|t
argument_list|)
return|;
return|return
name|non_lvalue
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but call pedantic_non_lvalue instead of non_lvalue.  */
end_comment

begin_function
specifier|static
name|tree
name|pedantic_omit_one_operand
parameter_list|(
name|type
parameter_list|,
name|result
parameter_list|,
name|omitted
parameter_list|)
name|tree
name|type
decl_stmt|,
name|result
decl_stmt|,
name|omitted
decl_stmt|;
block|{
name|tree
name|t
init|=
name|convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|omitted
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|omitted
argument_list|,
name|t
argument_list|)
return|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a simplified tree node for the truth-negation of ARG.  This    never alters ARG itself.  We assume that ARG is an operation that    returns a truth value (0 or 1).  */
end_comment

begin_function
name|tree
name|invert_truthvalue
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|arg
return|;
comment|/* If this is a comparison, we can simply invert it, except for      floating-point non-equality comparisons, in which case we just      enclose a TRUTH_NOT_EXPR around what we have.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|flag_unsafe_math_optimizations
operator|&&
name|code
operator|!=
name|NE_EXPR
operator|&&
name|code
operator|!=
name|EQ_EXPR
condition|)
return|return
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
else|else
return|return
name|build
argument_list|(
name|invert_tree_comparison
argument_list|(
name|code
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|build_int_2
argument_list|(
name|integer_zerop
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_AND_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_OR_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_OR_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_XOR_EXPR
case|:
comment|/* Here we can invert either operand.  We invert the first operand 	 unless the second operand is a TRUTH_NOT_EXPR in which case our 	 result is the XOR of the first operand with the inside of the 	 negation of the second operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
return|return
name|build
argument_list|(
name|TRUTH_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|build
argument_list|(
name|TRUTH_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|WITH_RECORD_EXPR
case|:
return|return
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
operator|!
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
break|break;
return|return
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
return|return
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|CLEANUP_POINT_EXPR
case|:
return|return
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a bit-wise operation CODE applied to ARG0 and ARG1, see if both    operands are another bit-wise operation with a common input.  If so,    distribute the bit operations to save an operation and possibly two if    constants are involved.  For example, convert    	(A | B)& (A | C) into A | (B& C)    Further simplification will occur if B and C are constants.     If this optimization cannot be done, 0 will be returned.  */
end_comment

begin_function
specifier|static
name|tree
name|distribute_bit_expr
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
block|{
name|tree
name|common
decl_stmt|;
name|tree
name|left
decl_stmt|,
name|right
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|code
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|BIT_IOR_EXPR
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|common
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a BIT_FIELD_REF of type TYPE to refer to BITSIZE bits of INNER    starting at BITPOS.  The field is unsigned if UNSIGNEDP is non-zero.  */
end_comment

begin_function
specifier|static
name|tree
name|make_bit_field_ref
parameter_list|(
name|inner
parameter_list|,
name|type
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|unsignedp
parameter_list|)
name|tree
name|inner
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|tree
name|result
init|=
name|build
argument_list|(
name|BIT_FIELD_REF
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|size_int
argument_list|(
name|bitsize
argument_list|)
argument_list|,
name|bitsize_int
argument_list|(
name|bitpos
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|result
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Optimize a bit-field compare.     There are two cases:  First is a compare against a constant and the    second is a comparison of two items where the fields are at the same    bit position relative to the start of a chunk (byte, halfword, word)    large enough to contain it.  In these cases we can avoid the shift    implicit in bitfield extractions.     For constants, we emit a compare of the shifted constant with the    BIT_AND_EXPR of a mask and a byte, halfword, or word of the operand being    compared.  For two fields at the same position, we do the ANDs with the    similar mask and compare the result of the ANDs.     CODE is the comparison code, known to be either NE_EXPR or EQ_EXPR.    COMPARE_TYPE is the type of the comparison, and LHS and RHS    are the left and right operands of the comparison, respectively.     If the optimization described above can be done, we return the resulting    tree.  Otherwise we return zero.  */
end_comment

begin_function
specifier|static
name|tree
name|optimize_bit_field_compare
parameter_list|(
name|code
parameter_list|,
name|compare_type
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|compare_type
decl_stmt|;
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|lbitpos
decl_stmt|,
name|lbitsize
decl_stmt|,
name|rbitpos
decl_stmt|,
name|rbitsize
decl_stmt|,
name|nbitpos
decl_stmt|,
name|nbitsize
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|signed_type
decl_stmt|,
name|unsigned_type
decl_stmt|;
name|int
name|const_p
init|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
decl_stmt|;
name|enum
name|machine_mode
name|lmode
decl_stmt|,
name|rmode
decl_stmt|,
name|nmode
decl_stmt|;
name|int
name|lunsignedp
decl_stmt|,
name|runsignedp
decl_stmt|;
name|int
name|lvolatilep
init|=
literal|0
decl_stmt|,
name|rvolatilep
init|=
literal|0
decl_stmt|;
name|tree
name|linner
decl_stmt|,
name|rinner
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|mask
decl_stmt|;
name|tree
name|offset
decl_stmt|;
comment|/* Get all the information about the extractions being done.  If the bit size      if the same as the size of the underlying object, we aren't doing an      extraction at all and so can do nothing.  We also don't want to      do anything if the inner expression is a PLACEHOLDER_EXPR since we      then will no longer be able to replace it.  */
name|linner
operator|=
name|get_inner_reference
argument_list|(
name|lhs
argument_list|,
operator|&
name|lbitsize
argument_list|,
operator|&
name|lbitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|lmode
argument_list|,
operator|&
name|lunsignedp
argument_list|,
operator|&
name|lvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|linner
operator|==
name|lhs
operator|||
name|lbitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|lmode
argument_list|)
operator|||
name|lbitsize
operator|<
literal|0
operator|||
name|offset
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|linner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|const_p
condition|)
block|{
comment|/* If this is not a constant, we can only do something if bit positions, 	sizes, and signedness are the same.  */
name|rinner
operator|=
name|get_inner_reference
argument_list|(
name|rhs
argument_list|,
operator|&
name|rbitsize
argument_list|,
operator|&
name|rbitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|rmode
argument_list|,
operator|&
name|runsignedp
argument_list|,
operator|&
name|rvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|rinner
operator|==
name|rhs
operator|||
name|lbitpos
operator|!=
name|rbitpos
operator|||
name|lbitsize
operator|!=
name|rbitsize
operator|||
name|lunsignedp
operator|!=
name|runsignedp
operator|||
name|offset
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|rinner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
literal|0
return|;
block|}
comment|/* See if we can find a mode to refer to this field.  We should be able to,      but fail if we can't.  */
name|nmode
operator|=
name|get_best_mode
argument_list|(
name|lbitsize
argument_list|,
name|lbitpos
argument_list|,
name|const_p
condition|?
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|linner
argument_list|)
argument_list|)
else|:
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|linner
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|rinner
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|lvolatilep
operator|||
name|rvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
comment|/* Set signed and unsigned types of the precision of this mode for the      shifts below.  */
name|signed_type
operator|=
name|type_for_mode
argument_list|(
name|nmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unsigned_type
operator|=
name|type_for_mode
argument_list|(
name|nmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the bit position and size for the new reference and our offset      within it. If the new reference is the same size as the original, we      won't optimize anything, so return zero.  */
name|nbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|nmode
argument_list|)
expr_stmt|;
name|nbitpos
operator|=
name|lbitpos
operator|&
operator|~
operator|(
name|nbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|lbitpos
operator|-=
name|nbitpos
expr_stmt|;
if|if
condition|(
name|nbitsize
operator|==
name|lbitsize
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|lbitpos
operator|=
name|nbitsize
operator|-
name|lbitsize
operator|-
name|lbitpos
expr_stmt|;
comment|/* Make the mask to be used against the extracted field.  */
name|mask
operator|=
name|build_int_2
argument_list|(
operator|~
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|mask
argument_list|)
operator|=
name|unsigned_type
expr_stmt|;
name|force_fit_type
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|convert
argument_list|(
name|unsigned_type
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|nbitsize
operator|-
name|lbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|nbitsize
operator|-
name|lbitsize
operator|-
name|lbitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|const_p
condition|)
comment|/* If not comparing with constant, just rework the comparison        and return.  */
return|return
name|build
argument_list|(
name|code
argument_list|,
name|compare_type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|make_bit_field_ref
argument_list|(
name|linner
argument_list|,
name|unsigned_type
argument_list|,
name|nbitsize
argument_list|,
name|nbitpos
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|make_bit_field_ref
argument_list|(
name|rinner
argument_list|,
name|unsigned_type
argument_list|,
name|nbitsize
argument_list|,
name|nbitpos
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
return|;
comment|/* Otherwise, we are handling the constant case. See if the constant is too      big for the field.  Warn and return a tree of for 0 (false) if so.  We do      this not only for its own sake, but to avoid having to test for this      error case below.  If we didn't, we might generate wrong code.       For unsigned fields, the constant shifted right by the field length should      be all zero.  For signed fields, the high-order bits should agree with      the sign bit.  */
if|if
condition|(
name|lunsignedp
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|unsigned_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison is always %d due to width of bit-field"
argument_list|,
name|code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|compare_type
argument_list|,
operator|(
name|code
operator|==
name|NE_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
operator|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|tree
name|tem
init|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|signed_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitsize
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison is always %d due to width of bit-field"
argument_list|,
name|code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|compare_type
argument_list|,
operator|(
name|code
operator|==
name|NE_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
operator|)
argument_list|)
return|;
block|}
block|}
comment|/* Single-bit compares should always be against zero.  */
if|if
condition|(
name|lbitsize
operator|==
literal|1
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|code
operator|=
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
expr_stmt|;
name|rhs
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
comment|/* Make a new bitfield reference, shift the constant over the      appropriate number of bits and mask it with the computed mask      (in case this was a signed field).  If we changed it, make a new one.  */
name|lhs
operator|=
name|make_bit_field_ref
argument_list|(
name|linner
argument_list|,
name|unsigned_type
argument_list|,
name|nbitsize
argument_list|,
name|nbitpos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvolatilep
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|lhs
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|rhs
operator|=
name|fold
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|unsigned_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|code
argument_list|,
name|compare_type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|lhs
argument_list|,
name|mask
argument_list|)
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine for fold_truthop: decode a field reference.     If EXP is a comparison reference, we return the innermost reference.     *PBITSIZE is set to the number of bits in the reference, *PBITPOS is    set to the starting bit number.     If the innermost field can be completely contained in a mode-sized    unit, *PMODE is set to that mode.  Otherwise, it is set to VOIDmode.     *PVOLATILEP is set to 1 if the any expression encountered is volatile;    otherwise it is not changed.     *PUNSIGNEDP is set to the signedness of the field.     *PMASK is set to the mask used.  This is either contained in a    BIT_AND_EXPR or derived from the width of the field.     *PAND_MASK is set to the mask found in a BIT_AND_EXPR, if any.     Return 0 if this is not a component reference or is one that we can't    do anything with.  */
end_comment

begin_function
specifier|static
name|tree
name|decode_field_reference
parameter_list|(
name|exp
parameter_list|,
name|pbitsize
parameter_list|,
name|pbitpos
parameter_list|,
name|pmode
parameter_list|,
name|punsignedp
parameter_list|,
name|pvolatilep
parameter_list|,
name|pmask
parameter_list|,
name|pand_mask
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|pbitsize
decl_stmt|,
decl|*
name|pbitpos
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|machine_mode
modifier|*
name|pmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|punsignedp
decl_stmt|,
modifier|*
name|pvolatilep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
modifier|*
name|pmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
modifier|*
name|pand_mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|and_mask
init|=
literal|0
decl_stmt|;
name|tree
name|mask
decl_stmt|,
name|inner
decl_stmt|,
name|offset
decl_stmt|;
name|tree
name|unsigned_type
decl_stmt|;
name|unsigned
name|int
name|precision
decl_stmt|;
comment|/* All the optimizations using this function assume integer fields.      There are problems with FP fields since the type_for_size call      below can fail for, e.g., XFmode.  */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|)
block|{
name|and_mask
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|and_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|and_mask
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
block|}
name|inner
operator|=
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
name|pbitsize
argument_list|,
name|pbitpos
argument_list|,
operator|&
name|offset
argument_list|,
name|pmode
argument_list|,
name|punsignedp
argument_list|,
name|pvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inner
operator|==
name|exp
operator|&&
name|and_mask
operator|==
literal|0
operator|)
operator|||
operator|*
name|pbitsize
operator|<
literal|0
operator|||
name|offset
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
literal|0
return|;
comment|/* Compute the mask to access the bitfield.  */
name|unsigned_type
operator|=
name|type_for_size
argument_list|(
operator|*
name|pbitsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type
argument_list|)
expr_stmt|;
name|mask
operator|=
name|build_int_2
argument_list|(
operator|~
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|mask
argument_list|)
operator|=
name|unsigned_type
expr_stmt|;
name|force_fit_type
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
operator|*
name|pbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
operator|*
name|pbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Merge it with the mask we found in the BIT_AND_EXPR, if any.  */
if|if
condition|(
name|and_mask
operator|!=
literal|0
condition|)
name|mask
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|convert
argument_list|(
name|unsigned_type
argument_list|,
name|and_mask
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pmask
operator|=
name|mask
expr_stmt|;
operator|*
name|pand_mask
operator|=
name|and_mask
expr_stmt|;
return|return
name|inner
return|;
block|}
end_block

begin_comment
comment|/* Return non-zero if MASK represents a mask of SIZE ones in the low-order    bit positions.  */
end_comment

begin_function
specifier|static
name|int
name|all_ones_mask_p
parameter_list|(
name|mask
parameter_list|,
name|size
parameter_list|)
name|tree
name|mask
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|mask
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|tmask
decl_stmt|;
name|tmask
operator|=
name|build_int_2
argument_list|(
operator|~
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmask
argument_list|)
operator|=
name|signed_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|force_fit_type
argument_list|(
name|tmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|tree_int_cst_equal
argument_list|(
name|mask
argument_list|,
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tmask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
name|size
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
name|size
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine for fold_truthop: determine if an operand is simple enough    to be evaluated unconditionally.  */
end_comment

begin_function
specifier|static
name|int
name|simple_operand_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
comment|/* Strip any conversions that don't change the machine mode.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
operator|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|DECL_NONLOCAL
argument_list|(
name|exp
argument_list|)
comment|/* Don't regard global variables as simple.  They may be 		 allocated in ways unknown to the compiler (shared memory, 		 #pragma weak, etc).  */
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|exp
argument_list|)
comment|/* Loading a static variable is unduly expensive, but global 		 registers aren't expensive.  */
operator|&&
operator|(
operator|!
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|||
name|DECL_REGISTER
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following functions are subroutines to fold_range_test and allow it to    try to change a logical combination of comparisons into a range test.     For example, both    	X == 2 || X == 3 || X == 4 || X == 5    and    	X>= 2&& X<= 5    are converted to 	(unsigned) (X - 2)<= 3     We describe each set of comparisons as being either inside or outside    a range, using a variable named like IN_P, and then describe the    range with a lower and upper bound.  If one of the bounds is omitted,    it represents either the highest or lowest value of the type.     In the comments below, we represent a range by two numbers in brackets    preceded by a "+" to designate being inside that range, or a "-" to    designate being outside that range, so the condition can be inverted by    flipping the prefix.  An omitted bound is represented by a "-".  For    example, "- [-, 10]" means being outside the range starting at the lowest    possible value and ending at 10, in other words, being greater than 10.    The range "+ [-, -]" is always true and hence the range "- [-, -]" is    always false.     We set up things so that the missing bounds are handled in a consistent    manner so neither a missing bound nor "true" and "false" need to be    handled using a special case.  */
end_comment

begin_comment
comment|/* Return the result of applying CODE to ARG0 and ARG1, but handle the case    of ARG0 and/or ARG1 being omitted, meaning an unlimited range. UPPER0_P    and UPPER1_P are nonzero if the respective argument is an upper bound    and zero for a lower.  TYPE, if nonzero, is the type of the result; it    must be specified for a comparison.  ARG1 will be converted to ARG0's    type if both are specified.  */
end_comment

begin_function
specifier|static
name|tree
name|range_binop
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|arg0
parameter_list|,
name|upper0_p
parameter_list|,
name|arg1
parameter_list|,
name|upper1_p
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|int
name|upper0_p
decl_stmt|,
name|upper1_p
decl_stmt|;
block|{
name|tree
name|tem
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|sgn0
decl_stmt|,
name|sgn1
decl_stmt|;
comment|/* If neither arg represents infinity, do the normal operation.      Else, if not a comparison, return infinity.  Else handle the special      comparison rules. Note that most of the cases below won't occur, but      are handled for consistency.  */
if|if
condition|(
name|arg0
operator|!=
literal|0
operator|&&
name|arg1
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
operator|!=
literal|0
condition|?
name|type
else|:
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INTEGER_CST
condition|?
name|tem
else|:
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
comment|/* Set SGN[01] to -1 if ARG[01] is a lower bound, 1 for upper, and 0      for neither.  In real maths, we cannot assume open ended ranges are      the same. But, this is computer arithmetic, where numbers are finite.      We can therefore make the transformation of any unbounded range with      the value Z, Z being greater than any representable number. This permits      us to treat unbounded ranges as equal.  */
name|sgn0
operator|=
name|arg0
operator|!=
literal|0
condition|?
literal|0
else|:
operator|(
name|upper0_p
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
expr_stmt|;
name|sgn1
operator|=
name|arg1
operator|!=
literal|0
condition|?
literal|0
else|:
operator|(
name|upper1_p
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
name|result
operator|=
name|sgn0
operator|==
name|sgn1
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|result
operator|=
name|sgn0
operator|!=
name|sgn1
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|result
operator|=
name|sgn0
operator|<
name|sgn1
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|result
operator|=
name|sgn0
operator|<=
name|sgn1
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|result
operator|=
name|sgn0
operator|>
name|sgn1
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|result
operator|=
name|sgn0
operator|>=
name|sgn1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|result
condition|?
name|integer_one_node
else|:
name|integer_zero_node
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given EXP, a logical expression, set the range it is testing into    variables denoted by PIN_P, PLOW, and PHIGH.  Return the expression    actually being tested.  *PLOW and *PHIGH will be made of the same type    as the returned expression.  If EXP is not a comparison, we will most    likely not be returning a useful value and range.  */
end_comment

begin_function
specifier|static
name|tree
name|make_range
parameter_list|(
name|exp
parameter_list|,
name|pin_p
parameter_list|,
name|plow
parameter_list|,
name|phigh
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
modifier|*
name|pin_p
decl_stmt|;
name|tree
modifier|*
name|plow
decl_stmt|,
decl|*
name|phigh
decl_stmt|;
end_function

begin_block
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg0
init|=
name|NULL_TREE
decl_stmt|,
name|arg1
init|=
name|NULL_TREE
decl_stmt|,
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|orig_type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|in_p
decl_stmt|,
name|n_in_p
decl_stmt|;
name|tree
name|low
decl_stmt|,
name|high
decl_stmt|,
name|n_low
decl_stmt|,
name|n_high
decl_stmt|;
comment|/* Start with simply saying "EXP != 0" and then look at the code of EXP      and see if we can refine the range.  Some of the cases below may not      happen, but it doesn't seem worth worrying about this.  We "continue"      the outer loop when we've changed something; otherwise we "break"      the switch, which will "break" the while.  */
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|high
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|code
operator|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
argument_list|)
condition|)
block|{
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'e'
operator|&&
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|>
literal|1
operator|)
condition|)
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Set ORIG_TYPE as soon as TYPE is non-null so that we do not 	 lose a cast by accident.  */
if|if
condition|(
name|type
operator|!=
name|NULL_TREE
operator|&&
name|orig_type
operator|==
name|NULL_TREE
condition|)
name|orig_type
operator|=
name|type
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUTH_NOT_EXPR
case|:
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|exp
operator|=
name|arg0
expr_stmt|;
continue|continue;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
comment|/* We can only do something if the range is testing for zero 	     and if the second operand is an integer constant.  Note that 	     saying something is "in" the range we make is done by 	     complementing IN_P since it will set in the initial case of 	     being not equal to zero; "out" is leaving it alone.  */
if|if
condition|(
name|low
operator|==
literal|0
operator|||
name|high
operator|==
literal|0
operator|||
operator|!
name|integer_zerop
argument_list|(
name|low
argument_list|)
operator|||
operator|!
name|integer_zerop
argument_list|(
name|high
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE_EXPR
case|:
comment|/* - [c, c]  */
name|low
operator|=
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
comment|/* + [c, c]  */
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|low
operator|=
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
comment|/* - [-, c] */
name|low
operator|=
literal|0
operator|,
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
comment|/* + [c, -] */
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|low
operator|=
name|arg1
operator|,
name|high
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
comment|/* - [c, -] */
name|low
operator|=
name|arg1
operator|,
name|high
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
comment|/* + [-, c] */
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|low
operator|=
literal|0
operator|,
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|exp
operator|=
name|arg0
expr_stmt|;
comment|/* If this is an unsigned comparison, we also know that EXP is 	     greater than or equal to zero.  We base the range tests we make 	     on that fact, so we record it here so we can parse existing 	     range tests.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|low
operator|==
literal|0
operator|||
name|high
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|merge_ranges
argument_list|(
operator|&
name|n_in_p
argument_list|,
operator|&
name|n_low
argument_list|,
operator|&
name|n_high
argument_list|,
name|in_p
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
literal|1
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
break|break;
name|in_p
operator|=
name|n_in_p
operator|,
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
comment|/* If the high bound is missing, but we 		 have a low bound, reverse the range so 		 it goes from zero to the low bound minus 1.  */
if|if
condition|(
name|high
operator|==
literal|0
operator|&&
name|low
condition|)
block|{
name|in_p
operator|=
operator|!
name|in_p
expr_stmt|;
name|high
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|low
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|low
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
case|case
name|NEGATE_EXPR
case|:
comment|/* (-x) IN [a,b] -> x in [-b, -a]  */
name|n_low
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|high
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n_high
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|low
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
name|exp
operator|=
name|arg0
expr_stmt|;
continue|continue;
case|case
name|BIT_NOT_EXPR
case|:
comment|/* ~ X -> -X - 1  */
name|exp
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
comment|/* If EXP is signed, any overflow in the computation is undefined, 	     so we don't worry about it so long as our computations on 	     the bounds don't overflow.  For unsigned, overflow is defined 	     and this is exactly the right thing.  */
name|n_low
operator|=
name|range_binop
argument_list|(
name|code
operator|==
name|MINUS_EXPR
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|low
argument_list|,
literal|0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n_high
operator|=
name|range_binop
argument_list|(
name|code
operator|==
name|MINUS_EXPR
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|high
argument_list|,
literal|1
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n_low
operator|!=
literal|0
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|n_low
argument_list|)
operator|)
operator|||
operator|(
name|n_high
operator|!=
literal|0
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|n_high
argument_list|)
operator|)
condition|)
break|break;
comment|/* Check for an unsigned range which has wrapped around the maximum 	     value thus making n_high< n_low, and normalize it.  */
if|if
condition|(
name|n_low
operator|&&
name|n_high
operator|&&
name|tree_int_cst_lt
argument_list|(
name|n_high
argument_list|,
name|n_low
argument_list|)
condition|)
block|{
name|low
operator|=
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|n_high
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|high
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|n_low
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the range is of the form +/- [ x+1, x ], we won't 		 be able to normalize it.  But then, it represents the 		 whole range or the empty set, so make it 		 +/- [ -, - ].  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|n_low
argument_list|,
name|low
argument_list|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|n_high
argument_list|,
name|high
argument_list|)
condition|)
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
else|else
name|in_p
operator|=
operator|!
name|in_p
expr_stmt|;
block|}
else|else
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
name|exp
operator|=
name|arg0
expr_stmt|;
continue|continue;
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|orig_type
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|low
operator|!=
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|low
argument_list|,
name|type
argument_list|)
operator|)
operator|||
operator|(
name|high
operator|!=
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|high
argument_list|,
name|type
argument_list|)
operator|)
condition|)
break|break;
name|n_low
operator|=
name|low
operator|,
name|n_high
operator|=
name|high
expr_stmt|;
if|if
condition|(
name|n_low
operator|!=
literal|0
condition|)
name|n_low
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|n_low
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_high
operator|!=
literal|0
condition|)
name|n_high
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|n_high
argument_list|)
expr_stmt|;
comment|/* If we're converting from an unsigned to a signed type, 	     we will be doing the comparison as unsigned.  The tests above 	     have already verified that LOW and HIGH are both positive.  	     So we have to make sure that the original unsigned value will 	     be interpreted as positive.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|equiv_type
init|=
name|type_for_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|high_positive
decl_stmt|;
comment|/* A range without an upper bound is, naturally, unbounded. 		 Since convert would have cropped a very large value, use 		 the max value for the destination type.  */
name|high_positive
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|equiv_type
argument_list|)
condition|?
name|TYPE_MAX_VALUE
argument_list|(
name|equiv_type
argument_list|)
else|:
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|high_positive
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|high_positive
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the low bound is specified, "and" the range with the 		 range for which the original unsigned value will be 		 positive.  */
if|if
condition|(
name|low
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|merge_ranges
argument_list|(
operator|&
name|n_in_p
argument_list|,
operator|&
name|n_low
argument_list|,
operator|&
name|n_high
argument_list|,
literal|1
argument_list|,
name|n_low
argument_list|,
name|n_high
argument_list|,
literal|1
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|high_positive
argument_list|)
condition|)
break|break;
name|in_p
operator|=
operator|(
name|n_in_p
operator|==
name|in_p
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, "or" the range with the range of the input 		     that will be interpreted as negative.  */
if|if
condition|(
operator|!
name|merge_ranges
argument_list|(
operator|&
name|n_in_p
argument_list|,
operator|&
name|n_low
argument_list|,
operator|&
name|n_high
argument_list|,
literal|0
argument_list|,
name|n_low
argument_list|,
name|n_high
argument_list|,
literal|1
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|high_positive
argument_list|)
condition|)
break|break;
name|in_p
operator|=
operator|(
name|in_p
operator|!=
name|n_in_p
operator|)
expr_stmt|;
block|}
block|}
name|exp
operator|=
name|arg0
expr_stmt|;
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* If EXP is a constant, we can evaluate whether this is true or false.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|in_p
operator|=
name|in_p
operator|==
operator|(
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|low
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|,
name|high
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|pin_p
operator|=
name|in_p
operator|,
operator|*
name|plow
operator|=
name|low
operator|,
operator|*
name|phigh
operator|=
name|high
expr_stmt|;
return|return
name|exp
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Given a range, LOW, HIGH, and IN_P, an expression, EXP, and a result    type, TYPE, return an expression to test if EXP is in (or out of, depending    on IN_P) the range.  */
end_comment

begin_function
specifier|static
name|tree
name|build_range_check
parameter_list|(
name|type
parameter_list|,
name|exp
parameter_list|,
name|in_p
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|int
name|in_p
decl_stmt|;
name|tree
name|low
decl_stmt|,
name|high
decl_stmt|;
block|{
name|tree
name|etype
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|utype
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|in_p
operator|&&
operator|(
literal|0
operator|!=
operator|(
name|value
operator|=
name|build_range_check
argument_list|(
name|type
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
operator|)
operator|)
condition|)
return|return
name|invert_truthvalue
argument_list|(
name|value
argument_list|)
return|;
elseif|else
if|if
condition|(
name|low
operator|==
literal|0
operator|&&
name|high
operator|==
literal|0
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
return|;
elseif|else
if|if
condition|(
name|low
operator|==
literal|0
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|high
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|high
operator|==
literal|0
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|low
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|low
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|etype
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|low
argument_list|)
condition|)
return|return
name|build_range_check
argument_list|(
name|type
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|high
argument_list|)
return|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|utype
operator|=
name|unsigned_type
argument_list|(
name|etype
argument_list|)
expr_stmt|;
return|return
name|build_range_check
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|utype
argument_list|,
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|convert
argument_list|(
name|utype
argument_list|,
name|high
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|!=
operator|(
name|value
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|high
argument_list|,
name|low
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|build_range_check
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|etype
argument_list|,
name|exp
argument_list|,
name|low
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|convert
argument_list|(
name|etype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given two ranges, see if we can merge them into one.  Return 1 if we    can, 0 if we can't.  Set the output range into the specified parameters.  */
end_comment

begin_function
specifier|static
name|int
name|merge_ranges
parameter_list|(
name|pin_p
parameter_list|,
name|plow
parameter_list|,
name|phigh
parameter_list|,
name|in0_p
parameter_list|,
name|low0
parameter_list|,
name|high0
parameter_list|,
name|in1_p
parameter_list|,
name|low1
parameter_list|,
name|high1
parameter_list|)
name|int
modifier|*
name|pin_p
decl_stmt|;
name|tree
modifier|*
name|plow
decl_stmt|,
decl|*
name|phigh
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|in0_p
decl_stmt|,
name|in1_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|low0
decl_stmt|,
name|high0
decl_stmt|,
name|low1
decl_stmt|,
name|high1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|no_overlap
decl_stmt|;
name|int
name|subset
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|int
name|in_p
decl_stmt|;
name|tree
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|lowequal
init|=
operator|(
operator|(
name|low0
operator|==
literal|0
operator|&&
name|low1
operator|==
literal|0
operator|)
operator|||
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|low0
argument_list|,
literal|0
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|highequal
init|=
operator|(
operator|(
name|high0
operator|==
literal|0
operator|&&
name|high1
operator|==
literal|0
operator|)
operator|||
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|,
name|high1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Make range 0 be the range that starts first, or ends last if they      start at the same value.  Swap them if it isn't.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|low0
argument_list|,
literal|0
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|lowequal
operator|&&
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high1
argument_list|,
literal|1
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|in0_p
operator|,
name|in0_p
operator|=
name|in1_p
operator|,
name|in1_p
operator|=
name|temp
expr_stmt|;
name|tem
operator|=
name|low0
operator|,
name|low0
operator|=
name|low1
operator|,
name|low1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|high0
operator|,
name|high0
operator|=
name|high1
operator|,
name|high1
operator|=
name|tem
expr_stmt|;
block|}
comment|/* Now flag two cases, whether the ranges are disjoint or whether the      second range is totally subsumed in the first.  Note that the tests      below are simplified by the ones above.  */
name|no_overlap
operator|=
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|subset
operator|=
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high1
argument_list|,
literal|1
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We now have four cases, depending on whether we are including or      excluding the two ranges.  */
if|if
condition|(
name|in0_p
operator|&&
name|in1_p
condition|)
block|{
comment|/* If they don't overlap, the result is false.  If the second range 	 is a subset it is the result.  Otherwise, the range is from the start 	 of the second to the end of the first.  */
if|if
condition|(
name|no_overlap
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|subset
condition|)
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low1
operator|,
name|high
operator|=
name|high1
expr_stmt|;
else|else
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low1
operator|,
name|high
operator|=
name|high0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in0_p
operator|&&
operator|!
name|in1_p
condition|)
block|{
comment|/* If they don't overlap, the result is the first range.  If they are 	 equal, the result is false.  If the second range is a subset of the 	 first, and the ranges begin at the same place, we go from just after 	 the end of the first range to the end of the second.  If the second 	 range is not a subset of the first, or if it is a subset and both 	 ranges end at the same place, the range starts at the start of the 	 first range and ends just before the second range. 	 Otherwise, we can't describe this as a single range.  */
if|if
condition|(
name|no_overlap
condition|)
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high0
expr_stmt|;
elseif|else
if|if
condition|(
name|lowequal
operator|&&
name|highequal
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|subset
operator|&&
name|lowequal
condition|)
block|{
name|in_p
operator|=
literal|1
operator|,
name|high
operator|=
name|high0
expr_stmt|;
name|low
operator|=
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|high1
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|subset
operator|||
name|highequal
condition|)
block|{
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low0
expr_stmt|;
name|high
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|in0_p
operator|&&
name|in1_p
condition|)
block|{
comment|/* If they don't overlap, the result is the second range.  If the second 	 is a subset of the first, the result is false.  Otherwise, 	 the range starts just after the first range and ends at the 	 end of the second.  */
if|if
condition|(
name|no_overlap
condition|)
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low1
operator|,
name|high
operator|=
name|high1
expr_stmt|;
elseif|else
if|if
condition|(
name|subset
operator|||
name|highequal
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|in_p
operator|=
literal|1
operator|,
name|high
operator|=
name|high1
expr_stmt|;
name|low
operator|=
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The case where we are excluding both ranges.  Here the complex case 	 is if they don't overlap.  In that case, the only time we have a 	 range is if they are adjacent.  If the second is a subset of the 	 first, the result is the first.  Otherwise, the range to exclude 	 starts at the beginning of the first range and ends at the end of the 	 second.  */
if|if
condition|(
name|no_overlap
condition|)
block|{
if|if
condition|(
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high1
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|subset
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high0
expr_stmt|;
else|else
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high1
expr_stmt|;
block|}
operator|*
name|pin_p
operator|=
name|in_p
operator|,
operator|*
name|plow
operator|=
name|low
operator|,
operator|*
name|phigh
operator|=
name|high
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* EXP is some logical combination of boolean tests.  See if we can    merge it into some range test.  Return the new tree if so.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_range_test
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|or_op
init|=
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_OR_EXPR
operator|)
decl_stmt|;
name|int
name|in0_p
decl_stmt|,
name|in1_p
decl_stmt|,
name|in_p
decl_stmt|;
name|tree
name|low0
decl_stmt|,
name|low1
decl_stmt|,
name|low
decl_stmt|,
name|high0
decl_stmt|,
name|high1
decl_stmt|,
name|high
decl_stmt|;
name|tree
name|lhs
init|=
name|make_range
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|in0_p
argument_list|,
operator|&
name|low0
argument_list|,
operator|&
name|high0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|make_range
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|in1_p
argument_list|,
operator|&
name|low1
argument_list|,
operator|&
name|high1
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* If this is an OR operation, invert both sides; we will invert      again at the end.  */
if|if
condition|(
name|or_op
condition|)
name|in0_p
operator|=
operator|!
name|in0_p
operator|,
name|in1_p
operator|=
operator|!
name|in1_p
expr_stmt|;
comment|/* If both expressions are the same, if we can merge the ranges, and we      can build the range test, return it or it inverted.  If one of the      ranges is always true or always false, consider it to be the same      expression as the other.  */
if|if
condition|(
operator|(
name|lhs
operator|==
literal|0
operator|||
name|rhs
operator|==
literal|0
operator|||
name|operand_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|merge_ranges
argument_list|(
operator|&
name|in_p
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|,
name|in0_p
argument_list|,
name|low0
argument_list|,
name|high0
argument_list|,
name|in1_p
argument_list|,
name|low1
argument_list|,
name|high1
argument_list|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
operator|(
name|build_range_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|lhs
operator|!=
literal|0
condition|?
name|lhs
else|:
name|rhs
operator|!=
literal|0
condition|?
name|rhs
else|:
name|integer_zero_node
argument_list|,
name|in_p
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
operator|)
operator|)
condition|)
return|return
name|or_op
condition|?
name|invert_truthvalue
argument_list|(
name|tem
argument_list|)
else|:
name|tem
return|;
comment|/* On machines where the branch cost is expensive, if this is a      short-circuited branch and the underlying object on both sides      is the same, make a non-short-circuit operation.  */
elseif|else
if|if
condition|(
name|BRANCH_COST
operator|>=
literal|2
operator|&&
name|lhs
operator|!=
literal|0
operator|&&
name|rhs
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If simple enough, just rewrite.  Otherwise, make a SAVE_EXPR 	 unless we are at top level or LHS contains a PLACEHOLDER_EXPR, in 	 which cases we can't do this.  */
if|if
condition|(
name|simple_operand_p
argument_list|(
name|lhs
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
condition|?
name|TRUTH_AND_EXPR
else|:
name|TRUTH_OR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|global_bindings_p
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|contains_placeholder_p
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|tree
name|common
init|=
name|save_expr
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|lhs
operator|=
name|build_range_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|common
argument_list|,
name|or_op
condition|?
operator|!
name|in0_p
else|:
name|in0_p
argument_list|,
name|low0
argument_list|,
name|high0
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
operator|(
name|rhs
operator|=
name|build_range_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|common
argument_list|,
name|or_op
condition|?
operator|!
name|in1_p
else|:
name|in1_p
argument_list|,
name|low1
argument_list|,
name|high1
argument_list|)
operator|)
operator|)
condition|)
return|return
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
condition|?
name|TRUTH_AND_EXPR
else|:
name|TRUTH_OR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine for fold_truthop: C is an INTEGER_CST interpreted as a P    bit value.  Arrange things so the extra bits will be set to zero if and    only if C is signed-extended to its full width.  If MASK is nonzero,    it is an INTEGER_CST that should be AND'ed with the extra bits.  */
end_comment

begin_function
specifier|static
name|tree
name|unextend
parameter_list|(
name|c
parameter_list|,
name|p
parameter_list|,
name|unsignedp
parameter_list|,
name|mask
parameter_list|)
name|tree
name|c
decl_stmt|;
name|int
name|p
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|tree
name|mask
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|int
name|modesize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|temp
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|modesize
operator|||
name|unsignedp
condition|)
return|return
name|c
return|;
comment|/* We work by getting just the sign bit into the low-order bit, then      into the high-order bit, then sign-extend.  We then XOR that value      with C.  */
name|temp
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|c
argument_list|,
name|size_int
argument_list|(
name|p
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We must use a signed type in order to get an arithmetic right shift.      However, we must also avoid introducing accidental overflows, so that      a subsequent call to integer_zerop will work.  Hence we must      do the type conversion here.  At this point, the constant is either      zero or one, and the conversion to a signed type can never overflow.      We could get an overflow if this conversion is done anywhere else.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|temp
operator|=
name|convert
argument_list|(
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
name|modesize
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
name|modesize
operator|-
name|p
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
name|temp
operator|=
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|temp
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If necessary, convert the type back to match the type of C.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|temp
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|c
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find ways of folding logical expressions of LHS and RHS:    Try to merge two comparisons to the same innermost item.    Look for range tests like "ch>= '0'&& ch<= '9'".    Look for combinations of simple terms on machines with expensive branches    and evaluate the RHS unconditionally.     For example, if we have p->a == 2&& p->b == 4 and we can make an    object large enough to span both A and B, we can do this with a comparison    against the object ANDed with the a mask.     If we have p->a == q->a&& p->b == q->b, we may be able to use bit masking    operations to do this with one comparison.     We check for both normal comparisons and the BIT_AND_EXPRs made this by    function and the one above.     CODE is the logical operation being done.  It can be TRUTH_ANDIF_EXPR,    TRUTH_AND_EXPR, TRUTH_ORIF_EXPR, or TRUTH_OR_EXPR.     TRUTH_TYPE is the type of the logical operand and LHS and RHS are its    two operands.     We return the simplified tree or 0 if no optimization is possible.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_truthop
parameter_list|(
name|code
parameter_list|,
name|truth_type
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|truth_type
decl_stmt|,
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
block|{
comment|/* If this is the "or" of two comparisons, we can do something if      the comparisons are NE_EXPR.  If this is the "and", we can do something      if the comparisons are EQ_EXPR.  I.e.,      	(a->b == 2&& a->c == 4) can become (a->new == NEW).       WANTED_CODE is this operation code.  For single bit fields, we can      convert EQ_EXPR to NE_EXPR so we need not reject the "wrong"      comparison for one-bit fields.  */
name|enum
name|tree_code
name|wanted_code
decl_stmt|;
name|enum
name|tree_code
name|lcode
decl_stmt|,
name|rcode
decl_stmt|;
name|tree
name|ll_arg
decl_stmt|,
name|lr_arg
decl_stmt|,
name|rl_arg
decl_stmt|,
name|rr_arg
decl_stmt|;
name|tree
name|ll_inner
decl_stmt|,
name|lr_inner
decl_stmt|,
name|rl_inner
decl_stmt|,
name|rr_inner
decl_stmt|;
name|HOST_WIDE_INT
name|ll_bitsize
decl_stmt|,
name|ll_bitpos
decl_stmt|,
name|lr_bitsize
decl_stmt|,
name|lr_bitpos
decl_stmt|;
name|HOST_WIDE_INT
name|rl_bitsize
decl_stmt|,
name|rl_bitpos
decl_stmt|,
name|rr_bitsize
decl_stmt|,
name|rr_bitpos
decl_stmt|;
name|HOST_WIDE_INT
name|xll_bitpos
decl_stmt|,
name|xlr_bitpos
decl_stmt|,
name|xrl_bitpos
decl_stmt|,
name|xrr_bitpos
decl_stmt|;
name|HOST_WIDE_INT
name|lnbitsize
decl_stmt|,
name|lnbitpos
decl_stmt|,
name|rnbitsize
decl_stmt|,
name|rnbitpos
decl_stmt|;
name|int
name|ll_unsignedp
decl_stmt|,
name|lr_unsignedp
decl_stmt|,
name|rl_unsignedp
decl_stmt|,
name|rr_unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|ll_mode
decl_stmt|,
name|lr_mode
decl_stmt|,
name|rl_mode
decl_stmt|,
name|rr_mode
decl_stmt|;
name|enum
name|machine_mode
name|lnmode
decl_stmt|,
name|rnmode
decl_stmt|;
name|tree
name|ll_mask
decl_stmt|,
name|lr_mask
decl_stmt|,
name|rl_mask
decl_stmt|,
name|rr_mask
decl_stmt|;
name|tree
name|ll_and_mask
decl_stmt|,
name|lr_and_mask
decl_stmt|,
name|rl_and_mask
decl_stmt|,
name|rr_and_mask
decl_stmt|;
name|tree
name|l_const
decl_stmt|,
name|r_const
decl_stmt|;
name|tree
name|lntype
decl_stmt|,
name|rntype
decl_stmt|,
name|result
decl_stmt|;
name|int
name|first_bit
decl_stmt|,
name|end_bit
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
comment|/* Start by getting the comparison codes.  Fail if anything is volatile.      If one operand is a BIT_AND_EXPR with the constant one, treat it as if      it were surrounded with a NE_EXPR.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
literal|0
return|;
name|lcode
operator|=
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcode
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|lcode
operator|=
name|NE_EXPR
operator|,
name|lhs
operator|=
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|rcode
operator|=
name|NE_EXPR
operator|,
name|rhs
operator|=
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|truth_type
argument_list|,
name|rhs
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|lcode
argument_list|)
operator|!=
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|rcode
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|code
operator|=
operator|(
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|)
condition|?
name|TRUTH_AND_EXPR
else|:
name|TRUTH_OR_EXPR
operator|)
expr_stmt|;
name|ll_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lr_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rl_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rr_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the RHS can be evaluated unconditionally and its operands are      simple, it wins to evaluate the RHS unconditionally on machines      with expensive branches.  In this case, this isn't a comparison      that can be merged.  Avoid doing this if the RHS is a floating-point      comparison since those can trap.  */
if|if
condition|(
name|BRANCH_COST
operator|>=
literal|2
operator|&&
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rl_arg
argument_list|)
argument_list|)
operator|&&
name|simple_operand_p
argument_list|(
name|rl_arg
argument_list|)
operator|&&
name|simple_operand_p
argument_list|(
name|rr_arg
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
comment|/* See if the comparisons can be merged.  Then get all the parameters for      each side.  */
if|if
condition|(
operator|(
name|lcode
operator|!=
name|EQ_EXPR
operator|&&
name|lcode
operator|!=
name|NE_EXPR
operator|)
operator|||
operator|(
name|rcode
operator|!=
name|EQ_EXPR
operator|&&
name|rcode
operator|!=
name|NE_EXPR
operator|)
condition|)
return|return
literal|0
return|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|ll_inner
operator|=
name|decode_field_reference
argument_list|(
name|ll_arg
argument_list|,
operator|&
name|ll_bitsize
argument_list|,
operator|&
name|ll_bitpos
argument_list|,
operator|&
name|ll_mode
argument_list|,
operator|&
name|ll_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|ll_mask
argument_list|,
operator|&
name|ll_and_mask
argument_list|)
expr_stmt|;
name|lr_inner
operator|=
name|decode_field_reference
argument_list|(
name|lr_arg
argument_list|,
operator|&
name|lr_bitsize
argument_list|,
operator|&
name|lr_bitpos
argument_list|,
operator|&
name|lr_mode
argument_list|,
operator|&
name|lr_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|lr_mask
argument_list|,
operator|&
name|lr_and_mask
argument_list|)
expr_stmt|;
name|rl_inner
operator|=
name|decode_field_reference
argument_list|(
name|rl_arg
argument_list|,
operator|&
name|rl_bitsize
argument_list|,
operator|&
name|rl_bitpos
argument_list|,
operator|&
name|rl_mode
argument_list|,
operator|&
name|rl_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|rl_mask
argument_list|,
operator|&
name|rl_and_mask
argument_list|)
expr_stmt|;
name|rr_inner
operator|=
name|decode_field_reference
argument_list|(
name|rr_arg
argument_list|,
operator|&
name|rr_bitsize
argument_list|,
operator|&
name|rr_bitpos
argument_list|,
operator|&
name|rr_mode
argument_list|,
operator|&
name|rr_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|rr_mask
argument_list|,
operator|&
name|rr_and_mask
argument_list|)
expr_stmt|;
comment|/* It must be true that the inner operation on the lhs of each      comparison must be the same if we are to be able to do anything.      Then see if we have constants.  If not, the same must be true for      the rhs's.  */
if|if
condition|(
name|volatilep
operator|||
name|ll_inner
operator|==
literal|0
operator|||
name|rl_inner
operator|==
literal|0
operator|||
operator|!
name|operand_equal_p
argument_list|(
name|ll_inner
argument_list|,
name|rl_inner
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lr_arg
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|rr_arg
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|l_const
operator|=
name|lr_arg
operator|,
name|r_const
operator|=
name|rr_arg
expr_stmt|;
elseif|else
if|if
condition|(
name|lr_inner
operator|==
literal|0
operator|||
name|rr_inner
operator|==
literal|0
operator|||
operator|!
name|operand_equal_p
argument_list|(
name|lr_inner
argument_list|,
name|rr_inner
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
name|l_const
operator|=
name|r_const
operator|=
literal|0
expr_stmt|;
comment|/* If either comparison code is not correct for our logical operation,      fail.  However, we can convert a one-bit comparison against zero into      the opposite comparison against that bit being set in the field.  */
name|wanted_code
operator|=
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
operator|)
expr_stmt|;
if|if
condition|(
name|lcode
operator|!=
name|wanted_code
condition|)
block|{
if|if
condition|(
name|l_const
operator|&&
name|integer_zerop
argument_list|(
name|l_const
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|ll_mask
argument_list|)
condition|)
block|{
comment|/* Make the left operand unsigned, since we are only interested 	     in the value of one bit.  Otherwise we are doing the wrong 	     thing below.  */
name|ll_unsignedp
operator|=
literal|1
expr_stmt|;
name|l_const
operator|=
name|ll_mask
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* This is analogous to the code for l_const above.  */
if|if
condition|(
name|rcode
operator|!=
name|wanted_code
condition|)
block|{
if|if
condition|(
name|r_const
operator|&&
name|integer_zerop
argument_list|(
name|r_const
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|rl_mask
argument_list|)
condition|)
block|{
name|rl_unsignedp
operator|=
literal|1
expr_stmt|;
name|r_const
operator|=
name|rl_mask
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* See if we can find a mode that contains both fields being compared on      the left.  If we can't, fail.  Otherwise, update all constants and masks      to be relative to a field of that size.  */
name|first_bit
operator|=
name|MIN
argument_list|(
name|ll_bitpos
argument_list|,
name|rl_bitpos
argument_list|)
expr_stmt|;
name|end_bit
operator|=
name|MAX
argument_list|(
name|ll_bitpos
operator|+
name|ll_bitsize
argument_list|,
name|rl_bitpos
operator|+
name|rl_bitsize
argument_list|)
expr_stmt|;
name|lnmode
operator|=
name|get_best_mode
argument_list|(
name|end_bit
operator|-
name|first_bit
argument_list|,
name|first_bit
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|ll_inner
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
name|lnbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|lnmode
argument_list|)
expr_stmt|;
name|lnbitpos
operator|=
name|first_bit
operator|&
operator|~
operator|(
name|lnbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|lntype
operator|=
name|type_for_size
argument_list|(
name|lnbitsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xll_bitpos
operator|=
name|ll_bitpos
operator|-
name|lnbitpos
operator|,
name|xrl_bitpos
operator|=
name|rl_bitpos
operator|-
name|lnbitpos
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|xll_bitpos
operator|=
name|lnbitsize
operator|-
name|xll_bitpos
operator|-
name|ll_bitsize
expr_stmt|;
name|xrl_bitpos
operator|=
name|lnbitsize
operator|-
name|xrl_bitpos
operator|-
name|rl_bitsize
expr_stmt|;
block|}
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|lntype
argument_list|,
name|ll_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xll_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|lntype
argument_list|,
name|rl_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xrl_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_const
condition|)
block|{
name|l_const
operator|=
name|convert
argument_list|(
name|lntype
argument_list|,
name|l_const
argument_list|)
expr_stmt|;
name|l_const
operator|=
name|unextend
argument_list|(
name|l_const
argument_list|,
name|ll_bitsize
argument_list|,
name|ll_unsignedp
argument_list|,
name|ll_and_mask
argument_list|)
expr_stmt|;
name|l_const
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|l_const
argument_list|,
name|size_int
argument_list|(
name|xll_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|l_const
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|lntype
argument_list|,
name|ll_mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison is always %d"
argument_list|,
name|wanted_code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|truth_type
argument_list|,
name|wanted_code
operator|==
name|NE_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|r_const
condition|)
block|{
name|r_const
operator|=
name|convert
argument_list|(
name|lntype
argument_list|,
name|r_const
argument_list|)
expr_stmt|;
name|r_const
operator|=
name|unextend
argument_list|(
name|r_const
argument_list|,
name|rl_bitsize
argument_list|,
name|rl_unsignedp
argument_list|,
name|rl_and_mask
argument_list|)
expr_stmt|;
name|r_const
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|r_const
argument_list|,
name|size_int
argument_list|(
name|xrl_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|r_const
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|lntype
argument_list|,
name|rl_mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison is always %d"
argument_list|,
name|wanted_code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|truth_type
argument_list|,
name|wanted_code
operator|==
name|NE_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
comment|/* If the right sides are not constant, do the same for it.  Also,      disallow this optimization if a size or signedness mismatch occurs      between the left and right sides.  */
if|if
condition|(
name|l_const
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ll_bitsize
operator|!=
name|lr_bitsize
operator|||
name|rl_bitsize
operator|!=
name|rr_bitsize
operator|||
name|ll_unsignedp
operator|!=
name|lr_unsignedp
operator|||
name|rl_unsignedp
operator|!=
name|rr_unsignedp
comment|/* Make sure the two fields on the right 	     correspond to the left without being swapped.  */
operator|||
name|ll_bitpos
operator|-
name|rl_bitpos
operator|!=
name|lr_bitpos
operator|-
name|rr_bitpos
condition|)
return|return
literal|0
return|;
name|first_bit
operator|=
name|MIN
argument_list|(
name|lr_bitpos
argument_list|,
name|rr_bitpos
argument_list|)
expr_stmt|;
name|end_bit
operator|=
name|MAX
argument_list|(
name|lr_bitpos
operator|+
name|lr_bitsize
argument_list|,
name|rr_bitpos
operator|+
name|rr_bitsize
argument_list|)
expr_stmt|;
name|rnmode
operator|=
name|get_best_mode
argument_list|(
name|end_bit
operator|-
name|first_bit
argument_list|,
name|first_bit
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|lr_inner
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
name|rnbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|rnmode
argument_list|)
expr_stmt|;
name|rnbitpos
operator|=
name|first_bit
operator|&
operator|~
operator|(
name|rnbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|rntype
operator|=
name|type_for_size
argument_list|(
name|rnbitsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xlr_bitpos
operator|=
name|lr_bitpos
operator|-
name|rnbitpos
operator|,
name|xrr_bitpos
operator|=
name|rr_bitpos
operator|-
name|rnbitpos
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|xlr_bitpos
operator|=
name|rnbitsize
operator|-
name|xlr_bitpos
operator|-
name|lr_bitsize
expr_stmt|;
name|xrr_bitpos
operator|=
name|rnbitsize
operator|-
name|xrr_bitpos
operator|-
name|rr_bitsize
expr_stmt|;
block|}
name|lr_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|rntype
argument_list|,
name|lr_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xlr_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rr_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|rntype
argument_list|,
name|rr_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xrr_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a mask that corresponds to both fields being compared. 	 Do this for both items being compared.  If the operands are the 	 same size and the bits being compared are in the same position 	 then we can do this by masking both and comparing the masked 	 results.  */
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lr_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|lr_mask
argument_list|,
name|rr_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnbitsize
operator|==
name|rnbitsize
operator|&&
name|xll_bitpos
operator|==
name|xlr_bitpos
condition|)
block|{
name|lhs
operator|=
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|lntype
argument_list|,
name|lnbitsize
argument_list|,
name|lnbitpos
argument_list|,
name|ll_unsignedp
operator|||
name|rl_unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|ll_mask
argument_list|,
name|lnbitsize
argument_list|)
condition|)
name|lhs
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|lntype
argument_list|,
name|lhs
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|make_bit_field_ref
argument_list|(
name|lr_inner
argument_list|,
name|rntype
argument_list|,
name|rnbitsize
argument_list|,
name|rnbitpos
argument_list|,
name|lr_unsignedp
operator|||
name|rr_unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|lr_mask
argument_list|,
name|rnbitsize
argument_list|)
condition|)
name|rhs
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|rntype
argument_list|,
name|rhs
argument_list|,
name|lr_mask
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* There is still another way we can do something:  If both pairs of 	 fields being compared are adjacent, we may be able to make a wider 	 field containing them both.  	 Note that we still must mask the lhs/rhs expressions.  Furthermore, 	 the mask must be shifted to account for the shift done by 	 make_bit_field_ref.  */
if|if
condition|(
operator|(
name|ll_bitsize
operator|+
name|ll_bitpos
operator|==
name|rl_bitpos
operator|&&
name|lr_bitsize
operator|+
name|lr_bitpos
operator|==
name|rr_bitpos
operator|)
operator|||
operator|(
name|ll_bitpos
operator|==
name|rl_bitpos
operator|+
name|rl_bitsize
operator|&&
name|lr_bitpos
operator|==
name|rr_bitpos
operator|+
name|rr_bitsize
operator|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|lhs
operator|=
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|lntype
argument_list|,
name|ll_bitsize
operator|+
name|rl_bitsize
argument_list|,
name|MIN
argument_list|(
name|ll_bitpos
argument_list|,
name|rl_bitpos
argument_list|)
argument_list|,
name|ll_unsignedp
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|make_bit_field_ref
argument_list|(
name|lr_inner
argument_list|,
name|rntype
argument_list|,
name|lr_bitsize
operator|+
name|rr_bitsize
argument_list|,
name|MIN
argument_list|(
name|lr_bitpos
argument_list|,
name|rr_bitpos
argument_list|)
argument_list|,
name|lr_unsignedp
argument_list|)
expr_stmt|;
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|size_int
argument_list|(
name|MIN
argument_list|(
name|xll_bitpos
argument_list|,
name|xrl_bitpos
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lr_mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|lr_mask
argument_list|,
name|size_int
argument_list|(
name|MIN
argument_list|(
name|xlr_bitpos
argument_list|,
name|xrr_bitpos
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert to the smaller type before masking out unwanted bits.  */
name|type
operator|=
name|lntype
expr_stmt|;
if|if
condition|(
name|lntype
operator|!=
name|rntype
condition|)
block|{
if|if
condition|(
name|lnbitsize
operator|>
name|rnbitsize
condition|)
block|{
name|lhs
operator|=
name|convert
argument_list|(
name|rntype
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|ll_mask
operator|=
name|convert
argument_list|(
name|rntype
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
name|type
operator|=
name|rntype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lnbitsize
operator|<
name|rnbitsize
condition|)
block|{
name|rhs
operator|=
name|convert
argument_list|(
name|lntype
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|lr_mask
operator|=
name|convert
argument_list|(
name|lntype
argument_list|,
name|lr_mask
argument_list|)
expr_stmt|;
name|type
operator|=
name|lntype
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|ll_mask
argument_list|,
name|ll_bitsize
operator|+
name|rl_bitsize
argument_list|)
condition|)
name|lhs
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|lhs
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|lr_mask
argument_list|,
name|lr_bitsize
operator|+
name|rr_bitsize
argument_list|)
condition|)
name|rhs
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|,
name|lr_mask
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Handle the case of comparisons with constants.  If there is something in      common between the masks, those bits of the constants must be the same.      If not, the condition is always false.  Test for this to avoid generating      incorrect code below.  */
name|result
operator|=
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|result
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|result
argument_list|,
name|l_const
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|result
argument_list|,
name|r_const
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|wanted_code
operator|==
name|NE_EXPR
condition|)
block|{
name|warning
argument_list|(
literal|"`or' of unmatched not-equal tests is always 1"
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|truth_type
argument_list|,
name|integer_one_node
argument_list|)
return|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`and' of mutually exclusive equal-tests is always 0"
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|truth_type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
comment|/* Construct the expression we will return.  First get the component      reference we will make.  Unless the mask is all ones the width of      that field, perform the mask operation.  Then compare with the      merged constant.  */
name|result
operator|=
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|lntype
argument_list|,
name|lnbitsize
argument_list|,
name|lnbitpos
argument_list|,
name|ll_unsignedp
operator|||
name|rl_unsignedp
argument_list|)
expr_stmt|;
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|ll_mask
argument_list|,
name|lnbitsize
argument_list|)
condition|)
name|result
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|lntype
argument_list|,
name|result
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|result
argument_list|,
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|l_const
argument_list|,
name|r_const
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimize T, which is a comparison of a MIN_EXPR or MAX_EXPR with a    constant.  */
end_comment

begin_function
specifier|static
name|tree
name|optimize_minmax_comparison
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|op_code
decl_stmt|;
name|tree
name|comp_const
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|minmax_const
decl_stmt|;
name|int
name|consts_equal
decl_stmt|,
name|consts_lt
decl_stmt|;
name|tree
name|inner
decl_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op_code
operator|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|minmax_const
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|consts_equal
operator|=
name|tree_int_cst_equal
argument_list|(
name|minmax_const
argument_list|,
name|comp_const
argument_list|)
expr_stmt|;
name|consts_lt
operator|=
name|tree_int_cst_lt
argument_list|(
name|minmax_const
argument_list|,
name|comp_const
argument_list|)
expr_stmt|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If something does not permit us to optimize, return the original tree.  */
if|if
condition|(
operator|(
name|op_code
operator|!=
name|MIN_EXPR
operator|&&
name|op_code
operator|!=
name|MAX_EXPR
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|comp_const
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|comp_const
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|minmax_const
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|minmax_const
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Now handle all the various comparison codes.  We only handle EQ_EXPR      and GT_EXPR, doing the rest with recursive calls using logical      simplifications.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
return|return
name|invert_truthvalue
argument_list|(
name|optimize_minmax_comparison
argument_list|(
name|invert_truthvalue
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|optimize_minmax_comparison
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|comp_const
argument_list|)
argument_list|)
argument_list|,
name|optimize_minmax_comparison
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|comp_const
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|EQ_EXPR
case|:
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
operator|&&
name|consts_equal
condition|)
comment|/* MAX (X, 0) == 0  ->  X<= 0  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
operator|&&
name|consts_lt
condition|)
comment|/* MAX (X, 0) == 5  ->  X == 5   */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
condition|)
comment|/* MAX (X, 0) == -1  ->  false  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|inner
argument_list|)
return|;
elseif|else
if|if
condition|(
name|consts_equal
condition|)
comment|/* MIN (X, 0) == 0  ->  X>= 0  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|consts_lt
condition|)
comment|/* MIN (X, 0) == 5  ->  false  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|inner
argument_list|)
return|;
else|else
comment|/* MIN (X, 0) == -1  ->  X == -1  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
operator|&&
operator|(
name|consts_equal
operator|||
name|consts_lt
operator|)
condition|)
comment|/* MAX (X, 0)> 0  ->  X> 0 	   MAX (X, 0)> 5  ->  X> 5  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
condition|)
comment|/* MAX (X, 0)> -1  ->  true  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|inner
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MIN_EXPR
operator|&&
operator|(
name|consts_equal
operator|||
name|consts_lt
operator|)
condition|)
comment|/* MIN (X, 0)> 0  ->  false 	   MIN (X, 0)> 5  ->  false  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|inner
argument_list|)
return|;
else|else
comment|/* MIN (X, 0)> -1  ->  X> -1  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|t
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* T is an integer expression that is being multiplied, divided, or taken a    modulus (CODE says which and what kind of divide or modulus) by a    constant C.  See if we can eliminate that operation by folding it with    other operations already in T.  WIDE_TYPE, if non-null, is a type that    should be used for the computation if wider than our type.     For example, if we are dividing (X * 8) + (Y + 16) by 4, we can return    (X * 2) + (Y + 4).  We must, however, be assured that either the original    expression would not overflow or that overflow is undefined for the type    in the language in question.     We also canonicalize (X + 7) * 4 into X * 4 + 28 in the hope that either    the machine has a multiply-accumulate insn or that this is part of an    addressing calculation.     If we return a non-null expression, it is an equivalent form of the    original computation, but need not be in the original type.  */
end_comment

begin_function
specifier|static
name|tree
name|extract_muldiv
parameter_list|(
name|t
parameter_list|,
name|c
parameter_list|,
name|code
parameter_list|,
name|wide_type
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|c
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|wide_type
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|tcode
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|ctype
init|=
operator|(
name|wide_type
operator|!=
literal|0
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|wide_type
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|?
name|wide_type
else|:
name|type
operator|)
decl_stmt|;
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|same_p
init|=
name|tcode
operator|==
name|code
decl_stmt|;
name|tree
name|op0
init|=
name|NULL_TREE
decl_stmt|,
name|op1
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Don't deal with constants of zero here; they confuse the code below.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|tcode
argument_list|)
operator|==
literal|'1'
condition|)
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|tcode
argument_list|)
operator|==
literal|'2'
condition|)
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Note that we need not handle conditional operations here since fold      already handles those cases.  So just do arithmetic here.  */
switch|switch
condition|(
name|tcode
condition|)
block|{
case|case
name|INTEGER_CST
case|:
comment|/* For a constant, we can always simplify if we are a multiply 	 or (for divide and modulus) if it is a multiple of our constant.  */
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|||
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|t
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|const_binop
argument_list|(
name|code
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|t
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* If op0 is an expression, and is unsigned, and the type is 	 smaller than ctype, then we cannot widen the expression.  */
if|if
condition|(
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'e'
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
comment|/* Pass the constant down and see if we can make a simplification.  If 	 we can, replace this expression with the inner simplification for 	 possible later conversion to our or some other type.  */
if|if
condition|(
literal|0
operator|!=
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|code
argument_list|,
name|code
operator|==
name|MULT_EXPR
condition|?
name|ctype
else|:
name|NULL_TREE
argument_list|)
operator|)
condition|)
return|return
name|t1
return|;
break|break;
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
if|if
condition|(
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
comment|/* If widening the type changes the signedness, then we can't perform 	 this optimization as that changes the result.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
break|break;
comment|/* MIN (a, b) / 5 -> MIN (a / 5, b / 5)  */
if|if
condition|(
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|t2
operator|=
name|extract_muldiv
argument_list|(
name|op1
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
name|tcode
operator|=
operator|(
name|tcode
operator|==
name|MIN_EXPR
condition|?
name|MAX_EXPR
else|:
name|MIN_EXPR
operator|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|WITH_RECORD_EXPR
case|:
if|if
condition|(
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|t1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SAVE_EXPR
case|:
comment|/* If this has not been evaluated and the operand has no side effects, 	 we can see if we can do something inside it and make a new one. 	 Note that this test is overly conservative since we can do this 	 if the only reason it had side effects is that it was another 	 similar SAVE_EXPR, but that isn't worth bothering with.  */
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
literal|0
operator|!=
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
condition|)
block|{
name|t1
operator|=
name|save_expr
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|SAVE_EXPR_PERSISTENT_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|SAVE_EXPR_PERSISTENT_P
argument_list|(
name|t1
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_pending_size
argument_list|(
name|t
argument_list|)
condition|)
name|put_pending_size
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
comment|/* If the second operand is constant, this is a multiplication 	 or floor division, by a power of two, so we can treat it that 	 way unless the multiplier or divisor overflows.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
comment|/* const_binop may not detect overflow correctly, 	     so check for it explicitly here.  */
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|size_one_node
argument_list|)
argument_list|)
operator|>
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
literal|0
operator|!=
operator|(
name|t1
operator|=
name|convert
argument_list|(
name|ctype
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|size_one_node
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|extract_muldiv
argument_list|(
name|build
argument_list|(
name|tcode
operator|==
name|LSHIFT_EXPR
condition|?
name|MULT_EXPR
else|:
name|FLOOR_DIV_EXPR
argument_list|,
name|ctype
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|t1
argument_list|)
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
return|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
comment|/* See if we can eliminate the operation on both sides.  If we can, we 	 can return a new PLUS or MINUS.  If we can't, the only remaining 	 cases where we can do anything are if the second operand is a 	 constant.  */
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
expr_stmt|;
name|t2
operator|=
name|extract_muldiv
argument_list|(
name|op1
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
literal|0
operator|&&
name|t2
operator|!=
literal|0
operator|&&
operator|(
name|code
operator|==
name|MULT_EXPR
comment|/* If not multiplication, we can only do this if either operand 		 is divisible by c.  */
operator|||
name|multiple_of_p
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|,
name|c
argument_list|)
operator|||
name|multiple_of_p
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|,
name|c
argument_list|)
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If this was a subtraction, negate OP1 and set it to be an addition. 	 This simplifies the logic below.  */
if|if
condition|(
name|tcode
operator|==
name|MINUS_EXPR
condition|)
name|tcode
operator|=
name|PLUS_EXPR
operator|,
name|op1
operator|=
name|negate_expr
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
comment|/* If either OP1 or C are negative, this optimization is not safe for 	 some of the division and remainder types while for others we need 	 to change the code.  */
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
operator|||
name|tree_int_cst_sgn
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CEIL_DIV_EXPR
condition|)
name|code
operator|=
name|FLOOR_DIV_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|FLOOR_DIV_EXPR
condition|)
name|code
operator|=
name|CEIL_DIV_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|!=
name|MULT_EXPR
operator|&&
name|code
operator|!=
name|CEIL_MOD_EXPR
operator|&&
name|code
operator|!=
name|FLOOR_MOD_EXPR
condition|)
break|break;
block|}
comment|/* If it's a multiply or a division/modulus operation of a multiple          of our constant, do the operation and verify it doesn't overflow.  */
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|||
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|op1
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
literal|0
operator|||
name|TREE_OVERFLOW
argument_list|(
name|op1
argument_list|)
condition|)
break|break;
block|}
else|else
break|break;
comment|/* If we have an unsigned type is not a sizetype, we cannot widen 	 the operation since it will change the result if the original 	 computation overflowed.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|ctype
argument_list|)
operator|)
operator|&&
name|ctype
operator|!=
name|type
condition|)
break|break;
comment|/* If we were able to eliminate our operation from the first side, 	 apply our operation to the second side and reform the PLUS.  */
if|if
condition|(
name|t1
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|code
operator|||
name|code
operator|==
name|MULT_EXPR
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
comment|/* The last case is if we are a multiply.  In that case, we can 	 apply the distributive law to commute the multiply and addition 	 if the multiplication of the constants doesn't overflow.  */
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|ctype
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MULT_EXPR
case|:
comment|/* We have a special case here if we are doing something like 	 (C * 8) % 4 since we know that's zero.  */
if|if
condition|(
operator|(
name|code
operator|==
name|TRUNC_MOD_EXPR
operator|||
name|code
operator|==
name|CEIL_MOD_EXPR
operator|||
name|code
operator|==
name|FLOOR_MOD_EXPR
operator|||
name|code
operator|==
name|ROUND_MOD_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|op0
argument_list|)
return|;
comment|/* ... fall through ...  */
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* If we can extract our operation from the LHS, do so and return a 	 new operation.  Likewise for the RHS from a MULT_EXPR.  Otherwise, 	 do something only if the second operand is a constant.  */
if|if
condition|(
name|same_p
operator|&&
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|tcode
operator|==
name|MULT_EXPR
operator|&&
name|code
operator|==
name|MULT_EXPR
operator|&&
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op1
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
comment|/* If these are the same operation types, we can associate them 	 assuming no overflow.  */
if|if
condition|(
name|tcode
operator|==
name|code
operator|&&
literal|0
operator|!=
operator|(
name|t1
operator|=
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|t1
argument_list|)
argument_list|)
return|;
comment|/* If these operations "cancel" each other, we have the main 	 optimizations of this pass, which occur when either constant is a 	 multiple of the other, in which case we replace this with either an 	 operation or CODE or TCODE.  	 If we have an unsigned type that is not a sizetype, we cannot do 	 this since it will change the result if the original computation 	 overflowed.  */
if|if
condition|(
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|ctype
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|code
operator|==
name|MULT_EXPR
operator|&&
name|tcode
operator|==
name|EXACT_DIV_EXPR
operator|)
operator|||
operator|(
name|tcode
operator|==
name|MULT_EXPR
operator|&&
name|code
operator|!=
name|TRUNC_MOD_EXPR
operator|&&
name|code
operator|!=
name|CEIL_MOD_EXPR
operator|&&
name|code
operator|!=
name|FLOOR_MOD_EXPR
operator|&&
name|code
operator|!=
name|ROUND_MOD_EXPR
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|const_binop
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|c
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|ctype
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|ctype
argument_list|,
name|const_binop
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|c
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If T contains a COMPOUND_EXPR which was inserted merely to evaluate    S, a SAVE_EXPR, return the expression actually being evaluated.   Note    that we may sometimes modify the tree.  */
end_comment

begin_function
specifier|static
name|tree
name|strip_compound_expr
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|s
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* See if this is the COMPOUND_EXPR we want to eliminate.  */
if|if
condition|(
name|code
operator|==
name|COMPOUND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|s
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
return|;
comment|/* See if this is a COND_EXPR or a simple arithmetic operator.   We      don't bother handling any other types.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a node which has the indicated constant VALUE (either 0 or    1), and is of the indicated TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|constant_boolean_node
parameter_list|(
name|value
parameter_list|,
name|type
parameter_list|)
name|int
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
return|return
name|value
condition|?
name|integer_one_node
else|:
name|integer_zero_node
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|truthvalue_conversion
argument_list|(
name|value
condition|?
name|integer_one_node
else|:
name|integer_zero_node
argument_list|)
return|;
else|else
block|{
name|tree
name|t
init|=
name|build_int_2
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* Utility function for the following routine, to see how complex a nesting of    COND_EXPRs can be.  EXPR is the expression and LIMIT is a count beyond which    we don't care (to avoid spending too much time on complex expressions.).  */
end_comment

begin_function
specifier|static
name|int
name|count_cond
parameter_list|(
name|expr
parameter_list|,
name|lim
parameter_list|)
name|tree
name|expr
decl_stmt|;
name|int
name|lim
decl_stmt|;
block|{
name|int
name|ctrue
decl_stmt|,
name|cfalse
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|lim
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|ctrue
operator|=
name|count_cond
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|lim
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cfalse
operator|=
name|count_cond
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
name|lim
operator|-
literal|1
operator|-
name|ctrue
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|lim
argument_list|,
literal|1
operator|+
name|ctrue
operator|+
name|cfalse
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Transform `a + (b ? x : y)' into `x ? (a + b) : (a + y)'.    Transform, `a + (x< y)' into `(x< y) ? (a + 1) : (a + 0)'.  Here    CODE corresponds to the `+', COND to the `(b ? x : y)' or `(x< y)'    expression, and ARG to `a'.  If COND_FIRST_P is non-zero, then the    COND is the first argument to CODE; otherwise (as in the example    given here), it is the second argument.  TYPE is the type of the    original expression.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_binary_op_with_conditional_arg
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|cond
parameter_list|,
name|arg
parameter_list|,
name|cond_first_p
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|int
name|cond_first_p
decl_stmt|;
block|{
name|tree
name|test
decl_stmt|,
name|true_value
decl_stmt|,
name|false_value
decl_stmt|;
name|tree
name|lhs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|rhs
init|=
name|NULL_TREE
decl_stmt|;
comment|/* In the end, we'll produce a COND_EXPR.  Both arms of the      conditional expression will be binary operations.  The left-hand      side of the expression to be executed if the condition is true      will be pointed to by TRUE_LHS.  Similarly, the right-hand side      of the expression to be executed if the condition is true will be      pointed to by TRUE_RHS.  FALSE_LHS and FALSE_RHS are analogous --      but apply to the expression to be executed if the conditional is      false.  */
name|tree
modifier|*
name|true_lhs
decl_stmt|;
name|tree
modifier|*
name|true_rhs
decl_stmt|;
name|tree
modifier|*
name|false_lhs
decl_stmt|;
name|tree
modifier|*
name|false_rhs
decl_stmt|;
comment|/* These are the codes to use for the left-hand side and right-hand      side of the COND_EXPR.  Normally, they are the same as CODE.  */
name|enum
name|tree_code
name|lhs_code
init|=
name|code
decl_stmt|;
name|enum
name|tree_code
name|rhs_code
init|=
name|code
decl_stmt|;
comment|/* And these are the types of the expressions.  */
name|tree
name|lhs_type
init|=
name|type
decl_stmt|;
name|tree
name|rhs_type
init|=
name|type
decl_stmt|;
if|if
condition|(
name|cond_first_p
condition|)
block|{
name|true_rhs
operator|=
name|false_rhs
operator|=
operator|&
name|arg
expr_stmt|;
name|true_lhs
operator|=
operator|&
name|true_value
expr_stmt|;
name|false_lhs
operator|=
operator|&
name|false_value
expr_stmt|;
block|}
else|else
block|{
name|true_lhs
operator|=
name|false_lhs
operator|=
operator|&
name|arg
expr_stmt|;
name|true_rhs
operator|=
operator|&
name|true_value
expr_stmt|;
name|false_rhs
operator|=
operator|&
name|false_value
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|test
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|true_value
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|false_value
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If this operand throws an expression, then it does not make 	 sense to try to perform a logical or arithmetic operation 	 involving it.  Instead of building `a + throw 3' for example, 	 we simply build `a, throw 3'.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|true_value
argument_list|)
argument_list|)
condition|)
block|{
name|lhs_code
operator|=
name|COMPOUND_EXPR
expr_stmt|;
if|if
condition|(
operator|!
name|cond_first_p
condition|)
name|lhs_type
operator|=
name|void_type_node
expr_stmt|;
block|}
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|false_value
argument_list|)
argument_list|)
condition|)
block|{
name|rhs_code
operator|=
name|COMPOUND_EXPR
expr_stmt|;
if|if
condition|(
operator|!
name|cond_first_p
condition|)
name|rhs_type
operator|=
name|void_type_node
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|testtype
init|=
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|test
operator|=
name|cond
expr_stmt|;
name|true_value
operator|=
name|convert
argument_list|(
name|testtype
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|false_value
operator|=
name|convert
argument_list|(
name|testtype
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
comment|/* If ARG is complex we want to make sure we only evaluate      it once.  Though this is only required if it is volatile, it      might be more efficient even if it is not.  However, if we      succeed in folding one part to a constant, we do not need      to make this SAVE_EXPR.  Since we do this optimization      primarily to see if we do end up with constant and this      SAVE_EXPR interferes with later optimizations, suppressing      it when we can is important.            If we are not in a function, we can't make a SAVE_EXPR, so don't      try to do so.  Don't try to see if the result is a constant      if an arm is a COND_EXPR since we get exponential behavior      in that case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|SAVE_EXPR
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
operator|&&
name|global_bindings_p
argument_list|()
operator|==
literal|0
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|PARM_DECL
operator|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|true_value
argument_list|)
operator|!=
name|COND_EXPR
condition|)
name|lhs
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|lhs_code
argument_list|,
name|lhs_type
argument_list|,
operator|*
name|true_lhs
argument_list|,
operator|*
name|true_rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|false_value
argument_list|)
operator|!=
name|COND_EXPR
condition|)
name|rhs
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|rhs_code
argument_list|,
name|rhs_type
argument_list|,
operator|*
name|false_lhs
argument_list|,
operator|*
name|false_rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lhs
operator|==
literal|0
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|lhs
argument_list|)
operator|)
operator|&&
operator|(
name|rhs
operator|==
literal|0
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
operator|,
name|lhs
operator|=
name|rhs
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lhs
operator|==
literal|0
condition|)
name|lhs
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|lhs_code
argument_list|,
name|lhs_type
argument_list|,
operator|*
name|true_lhs
argument_list|,
operator|*
name|true_rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
literal|0
condition|)
name|rhs
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|rhs_code
argument_list|,
name|rhs_type
argument_list|,
operator|*
name|false_lhs
argument_list|,
operator|*
name|false_rhs
argument_list|)
argument_list|)
expr_stmt|;
name|test
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|test
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|arg
argument_list|)
argument_list|,
name|strip_compound_expr
argument_list|(
name|test
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
else|else
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|test
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform constant folding and related simplification of EXPR.    The related simplifications include x*1 => x, x*0 => 0, etc.,    and application of the associative law.    NOP_EXPR conversions may be removed freely (as long as we    are careful not to change the C type of the overall expression)    We cannot simplify through a CONVERT_EXPR, FIX_EXPR or FLOAT_EXPR,    but we can constant-fold them if they have constant operands.  */
end_comment

begin_function
name|tree
name|fold
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|t
init|=
name|expr
decl_stmt|;
name|tree
name|t1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|NULL_TREE
decl_stmt|,
name|arg1
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|kind
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|invert
decl_stmt|;
comment|/* WINS will be nonzero when the switch is done      if all operands are constant.  */
name|int
name|wins
init|=
literal|1
decl_stmt|;
comment|/* Don't try to process an RTL_EXPR since its operands aren't trees.      Likewise for a SAVE_EXPR that's already been evaluated.  */
if|if
condition|(
name|code
operator|==
name|RTL_EXPR
operator|||
operator|(
name|code
operator|==
name|SAVE_EXPR
operator|&&
name|SAVE_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|t
return|;
comment|/* Return right away if a constant.  */
if|if
condition|(
name|kind
operator|==
literal|'c'
condition|)
return|return
name|t
return|;
ifdef|#
directive|ifdef
name|MAX_INTEGER_COMPUTATION_MODE
name|check_max_integer_computation_mode
argument_list|(
name|expr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|FLOAT_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|tree
name|subop
decl_stmt|;
comment|/* Special case for conversion ops that can have fixed point args.  */
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't use STRIP_NOPS, because signedness of argument type matters.  */
if|if
condition|(
name|arg0
operator|!=
literal|0
condition|)
name|STRIP_SIGN_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
name|subop
operator|=
name|TREE_REALPART
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
else|else
name|subop
operator|=
name|arg0
expr_stmt|;
if|if
condition|(
name|subop
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|subop
argument_list|)
operator|!=
name|INTEGER_CST
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|subop
argument_list|)
operator|!=
name|REAL_CST
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
condition|)
comment|/* Note that TREE_CONSTANT isn't enough: 	   static var addresses are constant but we can't 	   do arithmetic on them.  */
name|wins
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|kind
argument_list|)
operator|||
name|kind
operator|==
literal|'r'
condition|)
block|{
name|int
name|len
init|=
name|first_rtl_op
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|subop
decl_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
continue|continue;
comment|/* Valid for CALL_EXPR, at least.  */
if|if
condition|(
name|kind
operator|==
literal|'<'
operator|||
name|code
operator|==
name|RSHIFT_EXPR
condition|)
block|{
comment|/* Signedness matters here.  Perhaps we can refine this 		 later.  */
name|STRIP_SIGN_NOPS
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Strip any conversions that don't change the mode.  */
name|STRIP_NOPS
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
name|subop
operator|=
name|TREE_REALPART
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|subop
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|subop
argument_list|)
operator|!=
name|INTEGER_CST
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|subop
argument_list|)
operator|!=
name|REAL_CST
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
condition|)
comment|/* Note that TREE_CONSTANT isn't enough: 	       static var addresses are constant but we can't 	       do arithmetic on them.  */
name|wins
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|arg0
operator|=
name|op
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|arg1
operator|=
name|op
expr_stmt|;
block|}
block|}
comment|/* If this is a commutative operation, and ARG0 is a constant, move it      to ARG1 to reduce the number of tests below.  */
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MULT_EXPR
operator|||
name|code
operator|==
name|MIN_EXPR
operator|||
name|code
operator|==
name|MAX_EXPR
operator|||
name|code
operator|==
name|BIT_IOR_EXPR
operator|||
name|code
operator|==
name|BIT_XOR_EXPR
operator|||
name|code
operator|==
name|BIT_AND_EXPR
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|)
condition|)
block|{
name|tem
operator|=
name|arg0
expr_stmt|;
name|arg0
operator|=
name|arg1
expr_stmt|;
name|arg1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|tem
expr_stmt|;
block|}
comment|/* Now WINS is set as described above,      ARG0 is the first operand of EXPR,      and ARG1 is the second operand (if it has more than one operand).       First check for cases where an arithmetic operation is applied to a      compound, conditional, or comparison operation.  Push the arithmetic      operation inside the compound or conditional to see if any folding      can then be done.  Convert comparison to conditional for this purpose.      The also optimizes non-constant cases that used to be done in      expand_expr.       Before we do that, see if this is a BIT_AND_EXPR or a BIT_IOR_EXPR,      one of the operands is a comparison and the other is a comparison, a      BIT_AND_EXPR with the constant 1, or a truth value.  In that case, the      code below would make the expression more complex.  Change it to a      TRUTH_{AND,OR}_EXPR.  Likewise, convert a similar NE_EXPR to      TRUTH_XOR_EXPR and an EQ_EXPR to the inversion of a TRUTH_XOR_EXPR.  */
if|if
condition|(
operator|(
name|code
operator|==
name|BIT_AND_EXPR
operator|||
name|code
operator|==
name|BIT_IOR_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
operator|(
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|&&
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
operator|==
name|BIT_AND_EXPR
condition|?
name|TRUTH_AND_EXPR
else|:
name|code
operator|==
name|BIT_IOR_EXPR
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|t
operator|=
name|invert_truthvalue
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this was a conversion, and all we did was to move into 	     inside the COND_EXPR, bring it back out.  But leave it if 	     it is a conversion from integer to integer and the 	     result precision is no wider than a word since such a 	     conversion is cheap and may be optimized away by combine, 	     while it couldn't if it were outside the COND_EXPR.  Then return 	     so we don't get into an infinite recursion loop taking the 	     conversion out and then back in.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_WORD
operator|)
condition|)
name|t
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COND_EXPR
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
operator|)
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|COND_EXPR
operator|||
name|count_cond
argument_list|(
name|arg0
argument_list|,
literal|25
argument_list|)
operator|+
name|count_cond
argument_list|(
name|arg1
argument_list|,
literal|25
argument_list|)
operator|<=
literal|25
operator|)
operator|&&
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|||
operator|(
name|global_bindings_p
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|contains_placeholder_p
argument_list|(
name|arg0
argument_list|)
operator|)
operator|)
condition|)
return|return
name|fold_binary_op_with_conditional_arg
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|,
comment|/*cond_first_p=*/
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COND_EXPR
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
operator|)
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|COND_EXPR
operator|||
name|count_cond
argument_list|(
name|arg0
argument_list|,
literal|25
argument_list|)
operator|+
name|count_cond
argument_list|(
name|arg1
argument_list|,
literal|25
argument_list|)
operator|<=
literal|25
operator|)
operator|&&
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
operator|||
operator|(
name|global_bindings_p
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|contains_placeholder_p
argument_list|(
name|arg1
argument_list|)
operator|)
operator|)
condition|)
return|return
name|fold_binary_op_with_conditional_arg
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
comment|/*cond_first_p=*/
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|CONSTRUCTOR
case|:
return|return
name|t
return|;
case|case
name|CONST_DECL
case|:
return|return
name|fold
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
comment|/* Other kinds of FIX are not handled properly by fold_convert.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Handle cases of two conversions in a row.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|tree
name|inside_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|inter_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|final_type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|inside_int
init|=
name|INTEGRAL_TYPE_P
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inside_ptr
init|=
name|POINTER_TYPE_P
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inside_float
init|=
name|FLOAT_TYPE_P
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|inside_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inside_unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inter_int
init|=
name|INTEGRAL_TYPE_P
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|inter_ptr
init|=
name|POINTER_TYPE_P
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|inter_float
init|=
name|FLOAT_TYPE_P
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|inter_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|inter_unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|final_int
init|=
name|INTEGRAL_TYPE_P
argument_list|(
name|final_type
argument_list|)
decl_stmt|;
name|int
name|final_ptr
init|=
name|POINTER_TYPE_P
argument_list|(
name|final_type
argument_list|)
decl_stmt|;
name|int
name|final_float
init|=
name|FLOAT_TYPE_P
argument_list|(
name|final_type
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|final_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|final_type
argument_list|)
decl_stmt|;
name|int
name|final_unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
decl_stmt|;
comment|/* In addition to the cases of two conversions in a row 	     handled below, if we are converting something to its own 	     type via an object of identical or wider precision, neither 	     conversion is needed.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|inside_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|final_type
argument_list|)
operator|&&
operator|(
operator|(
name|inter_int
operator|&&
name|final_int
operator|)
operator|||
operator|(
name|inter_float
operator|&&
name|final_float
operator|)
operator|)
operator|&&
name|inter_prec
operator|>=
name|final_prec
condition|)
return|return
name|convert
argument_list|(
name|final_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Likewise, if the intermediate and final types are either both 	     float or both integer, we don't need the middle conversion if 	     it is wider than the final type and doesn't change the signedness 	     (for integers).  Avoid this if the final type is a pointer 	     since then we sometimes need the inner conversion.  Likewise if 	     the outer has a precision not equal to the size of its mode.  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inter_int
operator|||
name|inter_ptr
operator|)
operator|&&
operator|(
name|inside_int
operator|||
name|inside_ptr
operator|)
operator|)
operator|||
operator|(
name|inter_float
operator|&&
name|inside_float
operator|)
operator|)
operator|&&
name|inter_prec
operator|>=
name|inside_prec
operator|&&
operator|(
name|inter_float
operator|||
name|inter_unsignedp
operator|==
name|inside_unsignedp
operator|)
operator|&&
operator|!
operator|(
name|final_prec
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|final_type
argument_list|)
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|final_type
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|inter_type
argument_list|)
operator|)
operator|&&
operator|!
name|final_ptr
condition|)
return|return
name|convert
argument_list|(
name|final_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* If we have a sign-extension of a zero-extended value, we can 	     replace that by a single zero-extension.  */
if|if
condition|(
name|inside_int
operator|&&
name|inter_int
operator|&&
name|final_int
operator|&&
name|inside_prec
operator|<
name|inter_prec
operator|&&
name|inter_prec
operator|<
name|final_prec
operator|&&
name|inside_unsignedp
operator|&&
operator|!
name|inter_unsignedp
condition|)
return|return
name|convert
argument_list|(
name|final_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Two conversions in a row are not needed unless: 	     - some conversion is floating-point (overstrict for now), or 	     - the intermediate type is narrower than both initial and 	       final, or 	     - the intermediate type and innermost type differ in signedness, 	       and the outermost type is wider than the intermediate, or 	     - the initial type is a pointer type and the precisions of the 	       intermediate and final types differ, or 	     - the final type is a pointer type and the precisions of the 	       initial and intermediate types differ.  */
if|if
condition|(
operator|!
name|inside_float
operator|&&
operator|!
name|inter_float
operator|&&
operator|!
name|final_float
operator|&&
operator|(
name|inter_prec
operator|>
name|inside_prec
operator|||
name|inter_prec
operator|>
name|final_prec
operator|)
operator|&&
operator|!
operator|(
name|inside_int
operator|&&
name|inter_int
operator|&&
name|inter_unsignedp
operator|!=
name|inside_unsignedp
operator|&&
name|inter_prec
operator|<
name|final_prec
operator|)
operator|&&
operator|(
operator|(
name|inter_unsignedp
operator|&&
name|inter_prec
operator|>
name|inside_prec
operator|)
operator|==
operator|(
name|final_unsignedp
operator|&&
name|final_prec
operator|>
name|inter_prec
operator|)
operator|)
operator|&&
operator|!
operator|(
name|inside_ptr
operator|&&
name|inter_prec
operator|!=
name|final_prec
operator|)
operator|&&
operator|!
operator|(
name|final_ptr
operator|&&
name|inside_prec
operator|!=
name|inter_prec
operator|)
operator|&&
operator|!
operator|(
name|final_prec
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|final_type
argument_list|)
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|final_type
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|inter_type
argument_list|)
operator|)
operator|&&
operator|!
name|final_ptr
condition|)
return|return
name|convert
argument_list|(
name|final_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
comment|/* Detect assigning a bitfield.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Don't leave an assignment inside a conversion 	     unless assigning a bitfield.  */
name|tree
name|prev
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* First do the assignment, then return converted constant.  */
name|t
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|prev
argument_list|,
name|fold
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
operator|!
name|wins
condition|)
block|{
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
name|fold_convert
argument_list|(
name|t
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|VIEW_CONVERT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
condition|)
return|return
name|build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
if|#
directive|if
literal|0
comment|/* This loses on&"foo"[0].  */
block|case ARRAY_REF: 	{ 	  int i;
comment|/* Fold an expression like: "foo"[2] */
block|if (TREE_CODE (arg0) == STRING_CST&& TREE_CODE (arg1) == INTEGER_CST&& compare_tree_int (arg1, TREE_STRING_LENGTH (arg0))< 0) 	    { 	      t = build_int_2 (TREE_STRING_POINTER (arg0)[TREE_INT_CST_LOW (arg))], 0); 	      TREE_TYPE (t) = TREE_TYPE (TREE_TYPE (arg0)); 	      force_fit_type (t, 0); 	    } 	}       return t;
endif|#
directive|endif
comment|/* 0 */
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|tree
name|m
init|=
name|purpose_member
argument_list|(
name|arg1
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|RANGE_EXPR
case|:
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|wins
expr_stmt|;
return|return
name|t
return|;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
name|wins
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|int
name|overflow
init|=
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|TREE_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator||
name|force_fit_type
argument_list|(
name|t
argument_list|,
name|overflow
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
condition|)
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Convert - (a - b) to (b - a) for non-floating-point.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
condition|)
return|return
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
name|wins
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* If the value is unsigned, then the absolute value is 		 the same as the ordinary value.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|arg0
return|;
comment|/* Similarly, if the value is non-negative.  */
elseif|else
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|integer_minus_one_node
argument_list|,
name|arg0
argument_list|)
condition|)
return|return
name|arg0
return|;
comment|/* If the value is negative, then the absolute value is 		 its negation.  */
else|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|int
name|overflow
init|=
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|TREE_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator||
name|force_fit_type
argument_list|(
name|t
argument_list|,
name|overflow
argument_list|)
operator|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|REAL_VALUE_NEGATIVE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ABS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|CONJ_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|build_complex
argument_list|(
name|type
argument_list|,
name|TREE_REALPART
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|CONJ_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|CONJ_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONJ_EXPR
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|wins
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|PLUS_EXPR
case|:
comment|/* A + (-B) -> A - B */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* (-A) + B -> B - A */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If we are adding two BIT_AND_EXPR's, both of which are and'ing 	     with a constant, and the two constants have no bits in common, 	     we should treat this as a BIT_IOR_EXPR since this may produce more 	     simplifications.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
goto|goto
name|bit_ior
goto|;
block|}
comment|/* Reassociate (plus (plus (mult) (foo)) (mult)) as 	     (plus (plus (mult) (mult)) (foo)) so that we can 	     take advantage of the factoring cases below.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|)
condition|)
block|{
name|tree
name|parg0
decl_stmt|,
name|parg1
decl_stmt|,
name|parg
decl_stmt|,
name|marg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
name|parg
operator|=
name|arg0
operator|,
name|marg
operator|=
name|arg1
expr_stmt|;
else|else
name|parg
operator|=
name|arg1
operator|,
name|marg
operator|=
name|arg0
expr_stmt|;
name|parg0
operator|=
name|TREE_OPERAND
argument_list|(
name|parg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parg1
operator|=
name|TREE_OPERAND
argument_list|(
name|parg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|parg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|parg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parg0
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|parg1
argument_list|)
operator|!=
name|MULT_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|parg0
argument_list|,
name|marg
argument_list|)
argument_list|)
argument_list|,
name|parg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parg0
argument_list|)
operator|!=
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|parg1
argument_list|)
operator|==
name|MULT_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|parg1
argument_list|,
name|marg
argument_list|)
argument_list|)
argument_list|,
name|parg0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
condition|)
block|{
name|tree
name|arg00
decl_stmt|,
name|arg01
decl_stmt|,
name|arg10
decl_stmt|,
name|arg11
decl_stmt|;
name|tree
name|alt0
init|=
name|NULL_TREE
decl_stmt|,
name|alt1
init|=
name|NULL_TREE
decl_stmt|,
name|same
decl_stmt|;
comment|/* (A * C) + (B * C) -> (A+B) * C. 		 We are most concerned about the case where C is a constant, 		 but other combinations show up during loop reduction.  Since 		 it is not difficult, try all four possibilities.  */
name|arg00
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg01
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg10
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg11
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|same
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|arg11
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg01
operator|,
name|alt0
operator|=
name|arg00
operator|,
name|alt1
operator|=
name|arg10
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg00
operator|,
name|alt0
operator|=
name|arg01
operator|,
name|alt1
operator|=
name|arg11
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg11
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg00
operator|,
name|alt0
operator|=
name|arg01
operator|,
name|alt1
operator|=
name|arg10
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg01
operator|,
name|alt0
operator|=
name|arg00
operator|,
name|alt1
operator|=
name|arg11
expr_stmt|;
comment|/* No identical multiplicands; see if we can find a common 		 power-of-two factor in non-power-of-two multiplies.  This 		 can help in multi-dimensional array access.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg11
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg01
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg11
argument_list|)
operator|==
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|int01
decl_stmt|,
name|int11
decl_stmt|,
name|tmp
decl_stmt|;
name|int01
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg01
argument_list|)
expr_stmt|;
name|int11
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg11
argument_list|)
expr_stmt|;
comment|/* Move min of absolute values to int11.  */
if|if
condition|(
operator|(
name|int01
operator|>=
literal|0
condition|?
name|int01
else|:
operator|-
name|int01
operator|)
operator|<
operator|(
name|int11
operator|>=
literal|0
condition|?
name|int11
else|:
operator|-
name|int11
operator|)
condition|)
block|{
name|tmp
operator|=
name|int01
operator|,
name|int01
operator|=
name|int11
operator|,
name|int11
operator|=
name|tmp
expr_stmt|;
name|alt0
operator|=
name|arg00
operator|,
name|arg00
operator|=
name|arg10
operator|,
name|arg10
operator|=
name|alt0
expr_stmt|;
name|alt0
operator|=
name|arg01
operator|,
name|arg01
operator|=
name|arg11
operator|,
name|arg11
operator|=
name|alt0
expr_stmt|;
block|}
if|if
condition|(
name|exact_log2
argument_list|(
name|int11
argument_list|)
operator|>
literal|0
operator|&&
name|int01
operator|%
name|int11
operator|==
literal|0
condition|)
block|{
name|alt0
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|build_int_2
argument_list|(
name|int01
operator|/
name|int11
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|alt1
operator|=
name|arg10
expr_stmt|;
name|same
operator|=
name|arg11
expr_stmt|;
block|}
block|}
if|if
condition|(
name|same
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|alt0
argument_list|,
name|alt1
argument_list|)
argument_list|)
argument_list|,
name|same
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* In IEEE floating point, x+0 may not equal x.  */
elseif|else
if|if
condition|(
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* x+(-0) equals x, even for IEEE.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
name|bit_rotate
label|:
comment|/* (A<< C1) + (A>> C2) if A is unsigned and C1+C2 is the size of A 	 is a rotate of A by C1 bits.  */
comment|/* (A<< B) + (A>> (Z - B)) if A is unsigned and Z is the size of A 	 is a rotate of A by B bits.  */
block|{
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|code0
operator|==
name|RSHIFT_EXPR
operator|&&
name|code1
operator|==
name|LSHIFT_EXPR
operator|)
operator|||
operator|(
name|code1
operator|==
name|RSHIFT_EXPR
operator|&&
name|code0
operator|==
name|LSHIFT_EXPR
operator|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tree01
decl_stmt|,
name|tree11
decl_stmt|;
name|enum
name|tree_code
name|code01
decl_stmt|,
name|code11
decl_stmt|;
name|tree01
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tree11
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree01
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree11
argument_list|)
expr_stmt|;
name|code01
operator|=
name|TREE_CODE
argument_list|(
name|tree01
argument_list|)
expr_stmt|;
name|code11
operator|=
name|TREE_CODE
argument_list|(
name|tree11
argument_list|)
expr_stmt|;
if|if
condition|(
name|code01
operator|==
name|INTEGER_CST
operator|&&
name|code11
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|tree01
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|tree11
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|tree01
argument_list|)
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|tree11
argument_list|)
operator|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|build
argument_list|(
name|LROTATE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code0
operator|==
name|LSHIFT_EXPR
condition|?
name|tree01
else|:
name|tree11
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code11
operator|==
name|MINUS_EXPR
condition|)
block|{
name|tree
name|tree110
decl_stmt|,
name|tree111
decl_stmt|;
name|tree110
operator|=
name|TREE_OPERAND
argument_list|(
name|tree11
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tree111
operator|=
name|TREE_OPERAND
argument_list|(
name|tree11
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree110
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree111
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tree110
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|==
name|compare_tree_int
argument_list|(
name|tree110
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|tree01
argument_list|,
name|tree111
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build
argument_list|(
operator|(
name|code0
operator|==
name|LSHIFT_EXPR
condition|?
name|LROTATE_EXPR
else|:
name|RROTATE_EXPR
operator|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree01
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code01
operator|==
name|MINUS_EXPR
condition|)
block|{
name|tree
name|tree010
decl_stmt|,
name|tree011
decl_stmt|;
name|tree010
operator|=
name|TREE_OPERAND
argument_list|(
name|tree01
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tree011
operator|=
name|TREE_OPERAND
argument_list|(
name|tree01
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree010
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree011
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tree010
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|==
name|compare_tree_int
argument_list|(
name|tree010
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|tree11
argument_list|,
name|tree011
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build
argument_list|(
operator|(
name|code0
operator|!=
name|LSHIFT_EXPR
condition|?
name|LROTATE_EXPR
else|:
name|RROTATE_EXPR
operator|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree11
argument_list|)
return|;
block|}
block|}
block|}
name|associate
label|:
comment|/* In most languages, can't associate operations on floats through 	 parentheses.  Rather than remember where the parentheses were, we 	 don't associate floats at all.  It shouldn't matter much.  However, 	 associating multiplications is only very slightly inaccurate, so do 	 that if -funsafe-math-optimizations is specified.  */
if|if
condition|(
operator|!
name|wins
operator|&&
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|flag_unsafe_math_optimizations
operator|&&
name|code
operator|==
name|MULT_EXPR
operator|)
operator|)
condition|)
block|{
name|tree
name|var0
decl_stmt|,
name|con0
decl_stmt|,
name|lit0
decl_stmt|,
name|var1
decl_stmt|,
name|con1
decl_stmt|,
name|lit1
decl_stmt|;
comment|/* Split both trees into variables, constants, and literals.  Then 	     associate each group together, the constants with literals, 	     then the result with variables.  This increases the chances of 	     literals being recombined later and of generating relocatable 	     expressions for the sum of a constant and literal.  */
name|var0
operator|=
name|split_tree
argument_list|(
name|arg0
argument_list|,
name|code
argument_list|,
operator|&
name|con0
argument_list|,
operator|&
name|lit0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|var1
operator|=
name|split_tree
argument_list|(
name|arg1
argument_list|,
name|code
argument_list|,
operator|&
name|con1
argument_list|,
operator|&
name|lit1
argument_list|,
name|code
operator|==
name|MINUS_EXPR
argument_list|)
expr_stmt|;
comment|/* Only do something if we found more than two objects.  Otherwise, 	     nothing has changed and we risk infinite recursion.  */
if|if
condition|(
literal|2
operator|<
operator|(
operator|(
name|var0
operator|!=
literal|0
operator|)
operator|+
operator|(
name|var1
operator|!=
literal|0
operator|)
operator|+
operator|(
name|con0
operator|!=
literal|0
operator|)
operator|+
operator|(
name|con1
operator|!=
literal|0
operator|)
operator|+
operator|(
name|lit0
operator|!=
literal|0
operator|)
operator|+
operator|(
name|lit1
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|var0
operator|=
name|associate_trees
argument_list|(
name|var0
argument_list|,
name|var1
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|con0
operator|=
name|associate_trees
argument_list|(
name|con0
argument_list|,
name|con1
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|lit0
operator|=
name|associate_trees
argument_list|(
name|lit0
argument_list|,
name|lit1
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|con0
operator|=
name|associate_trees
argument_list|(
name|con0
argument_list|,
name|lit0
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|associate_trees
argument_list|(
name|var0
argument_list|,
name|con0
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
block|}
name|binary
label|:
if|#
directive|if
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
name|t
return|;
endif|#
directive|endif
comment|/* REAL_IS_NOT_DOUBLE, and no REAL_ARITHMETIC */
if|if
condition|(
name|wins
condition|)
name|t1
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* The return value should always have 	     the same type as the original expression.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
name|t1
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t1
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
return|return
name|t
return|;
case|case
name|MINUS_EXPR
case|:
comment|/* A - (-B) -> A + B */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* (-A) - CST -> (-CST) - A   for floating point (what about ints ?)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|wins
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|negate_expr
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* (A * C) - (B * C) -> (A-B) * C.  Since we are most concerned 	     about the case where C is a constant, just try one of the 	     four possibilities.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
name|flag_unsafe_math_optimizations
condition|)
block|{
comment|/* Except with IEEE floating point, 0-x equals -x.  */
if|if
condition|(
operator|!
name|wins
operator|&&
name|real_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|negate_expr
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* Except with IEEE floating point, x-0 equals x.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fold&x -&x.  This can happen from&x.foo -&x. 	 This is unsafe for certain floats even in non-IEEE formats. 	 In IEEE, it is unsafe because it does wrong for NaNs. 	 Also note that operand_equal_p is always false if an operand 	 is volatile.  */
if|if
condition|(
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|MULT_EXPR
case|:
comment|/* (-A) * (-B) -> A * B  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* (a * (1<< b)) is (a<< b)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|extract_muldiv
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|code
argument_list|,
name|NULL_TREE
argument_list|)
operator|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
else|else
block|{
comment|/* x*0 is 0, except for IEEE floating point.  */
if|if
condition|(
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* In IEEE floating point, x*1 is not equivalent to x for snans. 	     However, ANSI says we can drop signals, 	     so we can do this anyway.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* x*2 is x+x */
if|if
condition|(
operator|!
name|wins
operator|&&
name|real_twop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|global_bindings_p
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|contains_placeholder_p
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|tree
name|arg
init|=
name|save_expr
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
return|;
block|}
block|}
goto|goto
name|associate
goto|;
case|case
name|BIT_IOR_EXPR
case|:
name|bit_ior
label|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
name|t1
operator|=
name|distribute_bit_expr
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
return|return
name|t1
return|;
comment|/* Convert (or (not arg0) (not arg1)) to (not (and (arg0) (arg1))).  	 This results in more efficient code for machines without a NAND 	 instruction.  Combine will canonicalize to the first form 	 which will allow use of NAND instructions provided by the 	 backend if they exist.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* See if this can be simplified into a rotate first.  If that 	 is unsuccessful continue in the association code.  */
goto|goto
name|bit_rotate
goto|;
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If we are XORing two BIT_AND_EXPR's, both of which are and'ing          with a constant, and the two constants have no bits in common, 	 we should treat this as a BIT_IOR_EXPR since this may produce more 	 simplifications.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
goto|goto
name|bit_ior
goto|;
block|}
comment|/* See if this can be simplified into a rotate first.  If that 	 is unsuccessful continue in the association code.  */
goto|goto
name|bit_rotate
goto|;
case|case
name|BIT_AND_EXPR
case|:
name|bit_and
label|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
name|t1
operator|=
name|distribute_bit_expr
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
return|return
name|t1
return|;
comment|/* Simplify ((int)c& 0x377) into (int)c, if c is unsigned char.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prec
operator|<
name|BITS_PER_WORD
operator|&&
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prec
operator|<
name|BITS_PER_WORD
operator|&&
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Convert (and (not arg0) (not arg1)) to (not (or (arg0) (arg1))).  	 This results in more efficient code for machines without a NOR 	 instruction.  Combine will canonicalize to the first form 	 which will allow use of NOR instructions provided by the 	 backend if they exist.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
goto|goto
name|associate
goto|;
case|case
name|BIT_ANDTC_EXPR
case|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|arg1
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
goto|goto
name|bit_and
goto|;
block|}
goto|goto
name|binary
goto|;
case|case
name|RDIV_EXPR
case|:
comment|/* In most cases, do nothing with a divide by zero.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
ifndef|#
directive|ifndef
name|REAL_INFINITY
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
comment|/* (-A) / (-B) -> A / B  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* In IEEE floating point, x/1 is not equivalent to x for snans. 	 However, ANSI says we can drop signals, so we can do this anyway.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If ARG1 is a constant, we can convert this to a multiply by the 	 reciprocal.  This does not have the same rounding properties, 	 so only do this if -funsafe-math-optimizations.  We can actually 	 always safely do it if ARG1 is a power of two, but it's hard to 	 tell if it is or not in a portable manner.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
comment|/* Find the reciprocal if optimizing and the result is exact.  */
elseif|else
if|if
condition|(
name|optimize
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|r
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exact_real_inverse
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
name|tem
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Convert A/B/C to A/(B*C).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RDIV_EXPR
condition|)
block|{
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Convert A/(B/C) to (A/B)*C.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|RDIV_EXPR
condition|)
block|{
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
goto|goto
name|binary
goto|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* If arg0 is a multiple of arg1, then rewrite to the fastest div 	 operation, EXACT_DIV_EXPR.  	 Note that only CEIL_DIV_EXPR and FLOOR_DIV_EXPR are rewritten now. 	 At one time others generated faster code, it's not clear if they do 	 after the last round to changes to the DIV code in expmed.c.  */
if|if
condition|(
operator|(
name|code
operator|==
name|CEIL_DIV_EXPR
operator|||
name|code
operator|==
name|FLOOR_DIV_EXPR
operator|)
operator|&&
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|extract_muldiv
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|code
argument_list|,
name|NULL_TREE
argument_list|)
operator|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
goto|goto
name|binary
goto|;
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|extract_muldiv
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|code
argument_list|,
name|NULL_TREE
argument_list|)
operator|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
goto|goto
name|binary
goto|;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Since negative shift count is not well-defined, 	 don't try to compute it in the compiler.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|arg1
argument_list|)
operator|<
literal|0
condition|)
return|return
name|t
return|;
comment|/* Rewrite an LROTATE_EXPR by a constant into an 	 RROTATE_EXPR by a new constant.  */
if|if
condition|(
name|code
operator|==
name|LROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|RROTATE_EXPR
argument_list|)
expr_stmt|;
name|code
operator|=
name|RROTATE_EXPR
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|arg1
argument_list|)
operator|<
literal|0
condition|)
return|return
name|t
return|;
block|}
comment|/* If we have a rotate of a bit operation with the rotate count and 	 the second operand of the bit operation both constant, 	 permute the two operations.  */
if|if
condition|(
name|code
operator|==
name|RROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_ANDTC_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Two consecutive rotates adding up to the width of the mode can 	 be ignored.  */
if|if
condition|(
name|code
operator|==
name|RROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
goto|goto
name|binary
goto|;
case|case
name|MIN_EXPR
case|:
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|MAX_EXPR
case|:
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|TRUTH_NOT_EXPR
case|:
comment|/* Note that the operand of this must be an int 	 and its values must be 0 or 1. 	 ("true" is a fixed value perhaps depending on the language, 	 but we don't handle values other than 1 correctly yet.)  */
name|tem
operator|=
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
comment|/* Avoid infinite recursion.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
return|return
name|t
return|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
comment|/* Note that the operands of this must be ints 	 and their values must be 0 or 1. 	 ("true" is a fixed value perhaps depending on the language.)  */
comment|/* If first arg is constant zero, return it.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|TRUTH_AND_EXPR
case|:
comment|/* If either arg is constant true, drop it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
comment|/* Preserve sequence points.  */
operator|&&
operator|(
name|code
operator|!=
name|TRUTH_ANDIF_EXPR
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If second arg is constant zero, result is zero, but first arg 	 must be evaluated.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Likewise for first arg, but note that only the TRUTH_AND_EXPR 	 case will be handled here.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
name|truth_andor
label|:
comment|/* We only do these simplifications if we are optimizing.  */
if|if
condition|(
operator|!
name|optimize
condition|)
return|return
name|t
return|;
comment|/* Check for things like (A || B)&& (A || C).  We can convert this 	 to A || (B&& C).  Note that either operator can be any of the four 	 truth and/or operations and the transformation will still be 	 valid.   Also note that we only care about order for the 	 ANDIF and ORIF operators.  If B contains side effects, this 	 might change the truth-value of A.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_AND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_OR_EXPR
operator|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|a00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|a01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|a10
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|a11
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|commutative
init|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_OR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_AND_EXPR
operator|)
operator|&&
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|a00
argument_list|,
name|a10
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a01
argument_list|,
name|a11
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|commutative
operator|&&
name|operand_equal_p
argument_list|(
name|a00
argument_list|,
name|a11
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a01
argument_list|,
name|a10
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|commutative
operator|&&
name|operand_equal_p
argument_list|(
name|a01
argument_list|,
name|a10
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|a01
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|a11
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* This case if tricky because we must either have commutative 	     operators or else A10 must not have side-effects.  */
elseif|else
if|if
condition|(
operator|(
name|commutative
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|a10
argument_list|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|a01
argument_list|,
name|a11
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|a10
argument_list|)
argument_list|)
argument_list|,
name|a01
argument_list|)
argument_list|)
return|;
block|}
comment|/* See if we can build a range comparison.  */
if|if
condition|(
literal|0
operator|!=
operator|(
name|tem
operator|=
name|fold_range_test
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
comment|/* Check for the possibility of merging component references.  If our 	 lhs is another similar operation, try to merge its rhs with our 	 rhs.  Then try to merge our lhs and rhs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|code
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|fold_truthop
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|tem
operator|=
name|fold_truthop
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
return|return
name|t
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
comment|/* Note that the operands of this must be ints 	 and their values must be 0 or true. 	 ("true" is a fixed value perhaps depending on the language.)  */
comment|/* If first arg is constant true, return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|TRUTH_OR_EXPR
case|:
comment|/* If either arg is constant zero, drop it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
comment|/* Preserve sequence points.  */
operator|&&
operator|(
name|code
operator|!=
name|TRUTH_ORIF_EXPR
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If second arg is constant true, result is true, but we must 	 evaluate first arg.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Likewise for first arg, but note this only occurs here for 	 TRUTH_OR_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
goto|goto
name|truth_andor
goto|;
case|case
name|TRUTH_XOR_EXPR
case|:
comment|/* If either arg is constant zero, drop it.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If either arg is constant true, this is a logical inversion.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* (-a) CMP (-b) -> b CMP a  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* (-a) CMP CST -> a swap(CMP) (-CST)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* IEEE doesn't distinguish +0 and -0 in comparisons.  */
comment|/* a CMP (-0) -> a CMP 0  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* If one arg is a constant integer, put it last.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|arg1
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Convert foo++ == CONST into ++foo == CONST + INCR. 	 First, see if one arg is constant; find the constant arg 	 and the other one.  */
block|{
name|tree
name|constop
init|=
literal|0
decl_stmt|,
name|varop
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|constopnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
condition|)
name|constopnum
operator|=
literal|1
operator|,
name|constop
operator|=
name|arg1
operator|,
name|varop
operator|=
name|arg0
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
condition|)
name|constopnum
operator|=
literal|0
operator|,
name|constop
operator|=
name|arg0
operator|,
name|varop
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|constop
operator|&&
name|TREE_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|POSTINCREMENT_EXPR
condition|)
block|{
comment|/* This optimization is invalid for ordered comparisons 	       if CONST+INCR overflows or if foo+incr might overflow. 	       This optimization is invalid for floating point due to rounding. 	       For pointer types we assume overflow doesn't happen.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|||
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|)
condition|)
block|{
name|tree
name|newconst
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|constop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Do not overwrite the current varop to be a preincrement, 		   create a new node so that we won't confuse our caller who 		   might create trees and throw them away, reusing the 		   arguments that they passed to build.  This shows up in 		   the THEN or ELSE parts of ?: being postincrements.  */
name|varop
operator|=
name|build
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If VAROP is a reference to a bitfield, we must mask 		   the constant by the width of the field.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|mask
decl_stmt|,
name|unsigned_type
decl_stmt|;
name|unsigned
name|int
name|precision
decl_stmt|;
name|tree
name|folded_compare
decl_stmt|;
comment|/* First check whether the comparison would come out 		       always the same.  If we don't do that we would 		       change the meaning with the masking.  */
if|if
condition|(
name|constopnum
operator|==
literal|0
condition|)
name|folded_compare
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|constop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|folded_compare
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|folded_compare
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|folded_compare
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|folded_compare
argument_list|,
name|varop
argument_list|)
return|;
name|unsigned_type
operator|=
name|type_for_size
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type
argument_list|)
expr_stmt|;
name|mask
operator|=
name|build_int_2
argument_list|(
operator|~
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|mask
argument_list|)
operator|=
name|unsigned_type
expr_stmt|;
name|force_fit_type
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
name|size
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newconst
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|newconst
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
operator|(
name|constopnum
operator|==
literal|0
operator|)
condition|?
name|newconst
else|:
name|varop
argument_list|,
operator|(
name|constopnum
operator|==
literal|1
operator|)
condition|?
name|newconst
else|:
name|varop
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|constop
operator|&&
name|TREE_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
condition|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|||
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|)
condition|)
block|{
name|tree
name|newconst
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|constop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Do not overwrite the current varop to be a predecrement, 		   create a new node so that we won't confuse our caller who 		   might create trees and throw them away, reusing the 		   arguments that they passed to build.  This shows up in 		   the THEN or ELSE parts of ?: being postdecrements.  */
name|varop
operator|=
name|build
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|mask
decl_stmt|,
name|unsigned_type
decl_stmt|;
name|unsigned
name|int
name|precision
decl_stmt|;
name|tree
name|folded_compare
decl_stmt|;
if|if
condition|(
name|constopnum
operator|==
literal|0
condition|)
name|folded_compare
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|constop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|folded_compare
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|folded_compare
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|folded_compare
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|folded_compare
argument_list|,
name|varop
argument_list|)
return|;
name|unsigned_type
operator|=
name|type_for_size
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type
argument_list|)
expr_stmt|;
name|mask
operator|=
name|build_int_2
argument_list|(
operator|~
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|mask
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
expr_stmt|;
name|force_fit_type
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
name|size
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newconst
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|newconst
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
operator|(
name|constopnum
operator|==
literal|0
operator|)
condition|?
name|newconst
else|:
name|varop
argument_list|,
operator|(
name|constopnum
operator|==
literal|1
operator|)
condition|?
name|newconst
else|:
name|varop
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
block|}
comment|/* Change X>= CST to X> (CST - 1) if CST is positive.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|arg1
argument_list|)
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If this is an EQ or NE comparison of a constant with a PLUS_EXPR or 	 a MINUS_EXPR of a constant, we can convert it into a comparison with 	 a revised constant as long as no overflow occurs.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|const_binop
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
comment|/* Similarly for a NEGATE_EXPR.  */
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|negate_expr
argument_list|(
name|arg1
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
comment|/* If we have X - Y == 0, we can convert that to X == Y and similarly 	 for !=.  Don't do this for ordered comparisons due to overflow.  */
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|)
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If we are widening one operand of an integer comparison, 	 see if the other operand is similarly being widened.  Perhaps we 	 can do the comparison in the narrower type.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|tem
operator|=
name|get_unwidened
argument_list|(
name|arg0
argument_list|,
name|NULL_TREE
argument_list|)
operator|)
operator|!=
name|arg0
operator|&&
operator|(
name|t1
operator|=
name|get_unwidened
argument_list|(
name|arg1
argument_list|,
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|t1
argument_list|,
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|t1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a 	 constant, we can simplify it.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MIN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MAX_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|optimize_minmax_comparison
argument_list|(
name|t
argument_list|)
return|;
comment|/* If we are comparing an ABS_EXPR with a constant, we can 	 convert all the cases into explicit comparisons, but they may 	 well not be faster than doing the ABS and one comparison. 	 But ABS (X)<= C is a range comparison, which becomes a subtraction 	 and a comparison, and is probably faster.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|LE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ABS_EXPR
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|(
literal|0
operator|!=
operator|(
name|tem
operator|=
name|negate_expr
argument_list|(
name|arg1
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|,
name|build
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If this is an EQ or NE comparison with zero and ARG0 is 	 (1<< foo)& bar, convert it to (bar>> foo)& 1.  Both require 	 two operations, but the latter can be done in one less insn 	 on machines that have only two-operand insns or on which a 	 constant cannot be the first operand.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
comment|/* If this is an NE or EQ comparison of zero against the result of a 	 signed MOD operation whose second operand is a power of 2, make 	 the MOD operation unsigned since it is simpler and equivalent.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|)
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUNC_MOD_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CEIL_MOD_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|FLOOR_MOD_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ROUND_MOD_EXPR
operator|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|newtype
init|=
name|unsigned_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newmod
init|=
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|newtype
argument_list|,
name|convert
argument_list|(
name|newtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|newtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|newmod
argument_list|,
name|convert
argument_list|(
name|newtype
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
comment|/* If this is an NE comparison of zero with an AND of one, remove the 	 comparison since the AND will give the correct value.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* If we have (A& C) == C where C is a power of 2, convert this into 	 (A& C) != 0.  Similarly for NE_EXPR.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|integer_zero_node
argument_list|)
return|;
comment|/* If X is unsigned, convert X< (1<< Y) into X>> Y == 0 	 and similarly for>= into !=.  */
if|if
condition|(
operator|(
name|code
operator|==
name|LT_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|code
operator|==
name|LT_EXPR
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|LT_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|code
operator|==
name|LT_EXPR
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
comment|/* Simplify comparison of something with itself.  (For IEEE 	 floating-point, we can only do some of these simplifications.)  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LE_EXPR
case|:
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
return|return
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
comment|/* For NE, we can only do this simplification if integer.  */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* ... fall through ...  */
case|case
name|GT_EXPR
case|:
case|case
name|LT_EXPR
case|:
return|return
name|constant_boolean_node
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* An unsigned comparison against 0 can be simplified.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|NE_EXPR
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|NE_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|EQ_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
comment|/* Comparisons with the highest or lowest possible integer of 	 the specified size will have known values and an unsigned<= 0x7fffffff can be simplified.  */
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|GT_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|EQ_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|NE_EXPR
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|LT_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|EQ_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|GT_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|NE_EXPR
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
comment|/* signed_type does not work on pointer types.  */
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|LE_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|GT_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LT_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|GT_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|EQ_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|NE_EXPR
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
comment|/* If we are comparing an expression that just has comparisons 	 of two integer values, arithmetic expressions of those comparisons, 	 and constants, we can simplify it.  There are only three cases 	 to check: the two values can either be equal, the first can be 	 greater, or the second can be greater.  Fold the expression for 	 those three values.  Since each value must be 0 or 1, we have 	 eight possibilities, each of which corresponds to the constant 0 	 or 1 or one of the six possible comparisons.  	 This handles common cases like (a> b) == 0 but also handles 	 expressions like  ((x> y) - (y> x))> 0, which supposedly 	 occur in macroized code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|tree
name|cval1
init|=
literal|0
decl_stmt|,
name|cval2
init|=
literal|0
decl_stmt|;
name|int
name|save_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|twoval_comparison_p
argument_list|(
name|arg0
argument_list|,
operator|&
name|cval1
argument_list|,
operator|&
name|cval2
argument_list|,
operator|&
name|save_p
argument_list|)
comment|/* Don't handle degenerate cases here; they should already 		 have been handled anyway.  */
operator|&&
name|cval1
operator|!=
literal|0
operator|&&
name|cval2
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CONSTANT
argument_list|(
name|cval1
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|cval2
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|cval2
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval2
argument_list|)
argument_list|)
operator|&&
operator|!
name|operand_equal_p
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval2
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|maxval
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|minval
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We can't just pass T to eval_subst in case cval1 or cval2 		 was the same as ARG1.  */
name|tree
name|high_result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|maxval
argument_list|,
name|cval2
argument_list|,
name|minval
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|equal_result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|maxval
argument_list|,
name|cval2
argument_list|,
name|maxval
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|low_result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|minval
argument_list|,
name|cval2
argument_list|,
name|maxval
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* All three of these results should be 0 or 1.  Confirm they 		 are.  Then use those values to select the proper code 		 to use.  */
if|if
condition|(
operator|(
name|integer_zerop
argument_list|(
name|high_result
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|high_result
argument_list|)
operator|)
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|equal_result
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|equal_result
argument_list|)
operator|)
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|low_result
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|low_result
argument_list|)
operator|)
condition|)
block|{
comment|/* Make a 3-bit mask with the high-order bit being the 		     value for `>', the next for '=', and the low for '<'.  */
switch|switch
condition|(
operator|(
name|integer_onep
argument_list|(
name|high_result
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|integer_onep
argument_list|(
name|equal_result
argument_list|)
operator|*
literal|2
operator|)
operator|+
name|integer_onep
argument_list|(
name|low_result
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Always false.  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
case|case
literal|1
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|code
operator|=
name|NE_EXPR
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* Always true.  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
block|}
name|t
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_p
condition|)
return|return
name|save_expr
argument_list|(
name|t
argument_list|)
return|;
else|else
return|return
name|fold
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
block|}
comment|/* If this is a comparison of a field, we may be able to simplify it.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|)
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
comment|/* Handle the constant case even without -O 	     to make sure the warnings are given.  */
operator|&&
operator|(
name|optimize
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
block|{
name|t1
operator|=
name|optimize_bit_field_compare
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|t1
condition|?
name|t1
else|:
name|t
return|;
block|}
comment|/* If this is a comparison of complex values and either or both sides 	 are a COMPLEX_EXPR or COMPLEX_CST, it is best to split up the 	 comparisons and join them with a TRUTH_ANDIF_EXPR or TRUTH_ORIF_EXPR. 	 This may prevent needless evaluations.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_CST
operator|)
condition|)
block|{
name|tree
name|subtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|real0
decl_stmt|,
name|imag0
decl_stmt|,
name|real1
decl_stmt|,
name|imag1
decl_stmt|;
name|arg0
operator|=
name|save_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|save_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|real0
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|subtype
argument_list|,
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|imag0
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|subtype
argument_list|,
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|real1
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|subtype
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|imag1
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|subtype
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
operator|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|TRUTH_ANDIF_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|imag0
argument_list|,
name|imag1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Optimize comparisons of strlen vs zero to a compare of the 	 first character of the string vs zero.  To wit,  	 	strlen(ptr) == 0   =>  *ptr == 0 		strlen(ptr) != 0   =>  *ptr != 0 	 Other cases should reduce to one of these two (or a constant) 	 due to the return value of strlen being unsigned.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|BUILT_IN_MD
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_STRLEN
operator|&&
operator|(
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|!
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|char_type_node
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
block|}
comment|/* From here on, the only cases we handle are when the result is 	 known to be a constant.  	 To compute GT, swap the arguments and do LT. 	 To compute GE, do LT and invert the result. 	 To compute LE, swap the arguments, do LT and invert the result. 	 To compute NE, do EQ and invert the result.  	 Therefore, the code below must handle only EQ and LT.  */
if|if
condition|(
name|code
operator|==
name|LE_EXPR
operator|||
name|code
operator|==
name|GT_EXPR
condition|)
block|{
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Note that it is safe to invert for real values here because we 	 will check below in the one case that it matters.  */
name|t1
operator|=
name|NULL_TREE
expr_stmt|;
name|invert
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
condition|)
block|{
name|invert
operator|=
literal|1
expr_stmt|;
name|code
operator|=
name|invert_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Compute a result for LT or EQ if args permit; 	 otherwise return T.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|t1
operator|=
name|build_int_2
argument_list|(
name|tree_int_cst_equal
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|t1
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|?
name|INT_CST_LT_UNSIGNED
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
else|:
name|INT_CST_LT
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This is no longer useful, but breaks some real code.  */
comment|/* Assume a nonexplicit constant cannot equal an explicit one, 	 since such code would be undefined anyway. 	 Exception: on sysvr4, using #pragma weak, 	 a label can come out as 0.  */
if|else if (TREE_CODE (arg1) == INTEGER_CST&& !integer_zerop (arg1)&& TREE_CONSTANT (arg0)&& TREE_CODE (arg0) == ADDR_EXPR&& code == EQ_EXPR) 	t1 = build_int_2 (0, 0);
endif|#
directive|endif
comment|/* Two real constants can be compared explicitly.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
comment|/* If either operand is a NaN, the result is false with two 	     exceptions: First, an NE_EXPR is true on NaNs, but that case 	     is already handled correctly since we will be inverting the 	     result for NE_EXPR.  Second, if we had inverted a LE_EXPR 	     or a GE_EXPR into a LT_EXPR, we must return true so that it 	     will be inverted into false.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|t1
operator|=
name|build_int_2
argument_list|(
name|invert
operator|&&
name|code
operator|==
name|LT_EXPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|t1
operator|=
name|build_int_2
argument_list|(
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|t1
operator|=
name|build_int_2
argument_list|(
name|REAL_VALUES_LESS
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
return|return
name|t
return|;
if|if
condition|(
name|invert
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|^=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|truthvalue_conversion
argument_list|(
name|t1
argument_list|)
return|;
return|return
name|t1
return|;
case|case
name|COND_EXPR
case|:
comment|/* Pedantic ANSI C says that a conditional expression is never an lvalue, 	 so all simple results must be passed through pedantic_non_lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
operator|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|pedantic_omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* If the second operand is zero, invert the comparison and swap 	 the second and third operands.  Likewise if the second operand 	 is constant and the third is not or if the third operand is 	 equivalent to the first operand of the comparison.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|||
operator|(
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|operand_equal_for_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* See if this can be inverted.  If it can't, possibly because 	     it was a floating-point inequality comparison, don't do 	     anything.  */
name|tem
operator|=
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|TRUTH_NOT_EXPR
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|tem
expr_stmt|;
comment|/* arg1 should be the first argument of the new T.  */
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have A op B ? A : C, we may be able to convert this to a 	 simpler expression, depending on the operation and the values 	 of B and C.  IEEE floating point prevents this though, 	 because A or B might be -0.0 or a NaN.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|operand_equal_for_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|arg2
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|comp_code
init|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* If we have A op 0 ? A : -A, this is A, -A, abs (A), or abs (-A), 	     depending on the comparison operation.  */
if|if
condition|(
operator|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|?
name|real_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
return|return
name|pedantic_non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
return|return
name|pedantic_non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|arg1
operator|=
name|convert
argument_list|(
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|arg1
operator|=
name|convert
argument_list|(
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|negate_expr
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this is A != 0 ? A : 0, this is simply A.  For ==, it is 	     always zero.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|arg2
argument_list|)
condition|)
block|{
if|if
condition|(
name|comp_code
operator|==
name|NE_EXPR
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|comp_code
operator|==
name|EQ_EXPR
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
block|}
comment|/* If this is A op B ? A : B, this is either A, B, min (A, B), 	     or max (A, B), depending on the operation.  */
if|if
condition|(
name|operand_equal_for_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|comp_op0
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|comp_op1
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|comp_type
init|=
name|TREE_TYPE
argument_list|(
name|comp_op0
argument_list|)
decl_stmt|;
comment|/* Avoid adding NOP_EXPRs in case this is an lvalue.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|comp_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
name|comp_type
operator|=
name|type
expr_stmt|;
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
return|return
name|pedantic_non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
return|return
name|pedantic_non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
case|case
name|LT_EXPR
case|:
comment|/* In C++ a ?: expression can be an lvalue, so put the 		     operand which will be used if they are equal first 		     so that we can convert this back to the 		     corresponding COND_EXPR.  */
return|return
name|pedantic_non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MIN_EXPR
argument_list|,
name|comp_type
argument_list|,
operator|(
name|comp_code
operator|==
name|LE_EXPR
condition|?
name|comp_op0
else|:
name|comp_op1
operator|)
argument_list|,
operator|(
name|comp_code
operator|==
name|LE_EXPR
condition|?
name|comp_op1
else|:
name|comp_op0
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
return|return
name|pedantic_non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MAX_EXPR
argument_list|,
name|comp_type
argument_list|,
operator|(
name|comp_code
operator|==
name|GE_EXPR
condition|?
name|comp_op0
else|:
name|comp_op1
operator|)
argument_list|,
operator|(
name|comp_code
operator|==
name|GE_EXPR
condition|?
name|comp_op1
else|:
name|comp_op0
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If this is A op C1 ? A : C2 with C1 and C2 constant integers, 	     we might still be able to simplify this.  For example, 	     if C1 is one less or one more than C2, this might have started 	     out as a MIN or MAX and been transformed by this function. 	     Only good for INTEGER_TYPEs, because we need TYPE_MAX_VALUE.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|INTEGER_CST
condition|)
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
comment|/* We can replace A with C1 in this case.  */
name|arg1
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
comment|/* If C1 is C2 + 1, this is min(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|LE_EXPR
case|:
comment|/* If C1 is C2 - 1, this is min(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|GT_EXPR
case|:
comment|/* If C1 is C2 - 1, this is max(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MAX_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|GE_EXPR
case|:
comment|/* If C1 is C2 + 1, this is max(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MAX_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|NE_EXPR
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If the second operand is simpler than the third, swap them 	 since that produces better jump optimization results.  */
if|if
condition|(
operator|(
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
operator|||
name|DECL_P
argument_list|(
name|arg1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|SAVE_EXPR
operator|)
operator|&&
operator|!
operator|(
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|||
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|SAVE_EXPR
operator|)
condition|)
block|{
comment|/* See if this can be inverted.  If it can't, possibly because 	     it was a floating-point inequality comparison, don't do 	     anything.  */
name|tem
operator|=
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|TRUTH_NOT_EXPR
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|tem
expr_stmt|;
comment|/* arg1 should be the first argument of the new T.  */
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Convert A ? 1 : 0 to simply A.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
comment|/* If we try to convert TREE_OPERAND (t, 0) to our type, the 	     call to fold will try to move the conversion inside 	     a COND, which will recurse.  In that case, the COND_EXPR 	     is probably the best choice, so leave it alone.  */
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|arg0
argument_list|)
return|;
comment|/* Look for expressions of the form A& 2 ? 2 : 0.  The result of this 	 operation is simply A& 2.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|COMPOUND_EXPR
case|:
comment|/* When pedantic, a compound expression can be neither an lvalue 	 nor an integer constant expression.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|||
name|pedantic
condition|)
return|return
name|t
return|;
comment|/* Don't let (0, 0) be null pointer constant.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
return|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|COMPLEX_EXPR
case|:
if|if
condition|(
name|wins
condition|)
return|return
name|build_complex
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|REALPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return
name|t
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_REALPART
argument_list|(
name|arg0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|IMAGPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_IMAGPART
argument_list|(
name|arg0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
comment|/* Pull arithmetic ops out of the CLEANUP_POINT_EXPR where          appropriate.  */
case|case
name|CLEANUP_POINT_EXPR
case|:
if|if
condition|(
operator|!
name|has_cleanups
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
return|;
block|{
name|enum
name|tree_code
name|code0
init|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|int
name|kind0
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code0
argument_list|)
decl_stmt|;
name|tree
name|arg00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg01
decl_stmt|;
if|if
condition|(
name|kind0
operator|==
literal|'1'
operator|||
name|code0
operator|==
name|TRUTH_NOT_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code0
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|,
name|arg00
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|kind0
operator|==
literal|'<'
operator|||
name|kind0
operator|==
literal|'2'
operator|||
name|code0
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code0
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code0
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code0
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code0
operator|==
name|TRUTH_XOR_EXPR
condition|)
block|{
name|arg01
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg00
argument_list|)
operator|||
operator|(
operator|(
name|code0
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code0
operator|==
name|TRUTH_ORIF_EXPR
operator|)
operator|&&
operator|!
name|has_cleanups
argument_list|(
name|arg00
argument_list|)
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code0
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg01
argument_list|)
argument_list|,
name|arg01
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg01
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code0
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|,
name|arg00
argument_list|)
argument_list|)
argument_list|,
name|arg01
argument_list|)
argument_list|)
return|;
block|}
return|return
name|t
return|;
block|}
case|case
name|CALL_EXPR
case|:
comment|/* Check for a built-in function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|fold_builtin
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
return|;
block|}
return|return
name|t
return|;
default|default:
return|return
name|t
return|;
block|}
comment|/* switch (code) */
block|}
end_function

begin_comment
comment|/* Determine if first argument is a multiple of second argument.  Return 0 if    it is not, or we cannot easily determined it to be.     An example of the sort of thing we care about (at this point; this routine    could surely be made more general, and expanded to do what the *_DIV_EXPR's    fold cases do now) is discovering that       SAVE_EXPR (I) * SAVE_EXPR (J * 8)     is a multiple of       SAVE_EXPR (J * 8)     when we know that the two SAVE_EXPR (J * 8) nodes are the same node.     This code also handles discovering that       SAVE_EXPR (I) * SAVE_EXPR (J * 8)     is a multiple of 8 so we don't have to worry about dealing with a    possible remainder.     Note that we *look* inside a SAVE_EXPR only to determine how it was    calculated; it is not safe for fold to do much of anything else with the    internals of a SAVE_EXPR, since it cannot know when it will be evaluated    at run time.  For example, the latter example above *cannot* be implemented    as SAVE_EXPR (I) * J or any variant thereof, since the value of J at    evaluation time of the original SAVE_EXPR is not necessarily the same at    the time the new expression is evaluated.  The only optimization of this    sort that would be valid is changing       SAVE_EXPR (I) * SAVE_EXPR (SAVE_EXPR (J) * 8)     divided by 8 to       SAVE_EXPR (I) * SAVE_EXPR (J)     (where the same SAVE_EXPR (J) is used in the original and the    transformed version).  */
end_comment

begin_function
specifier|static
name|int
name|multiple_of_p
parameter_list|(
name|type
parameter_list|,
name|top
parameter_list|,
name|bottom
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|top
decl_stmt|;
name|tree
name|bottom
decl_stmt|;
block|{
if|if
condition|(
name|operand_equal_p
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|top
argument_list|)
condition|)
block|{
case|case
name|MULT_EXPR
case|:
return|return
operator|(
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|||
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
operator|(
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|&&
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|)
return|;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|op1
decl_stmt|,
name|t1
decl_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* const_binop may not detect overflow correctly, 	     so check for it explicitly here.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|size_one_node
argument_list|)
argument_list|)
operator|>
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
literal|0
operator|!=
operator|(
name|t1
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|size_one_node
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|t1
argument_list|,
name|bottom
argument_list|)
return|;
block|}
return|return
literal|0
return|;
case|case
name|NOP_EXPR
case|:
comment|/* Can't handle conversions from non-integral or wider integral type.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|)
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* .. fall through ...  */
case|case
name|SAVE_EXPR
case|:
return|return
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bottom
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bottom
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|tree_int_cst_sgn
argument_list|(
name|top
argument_list|)
operator|<
literal|0
operator|||
name|tree_int_cst_sgn
argument_list|(
name|bottom
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|top
argument_list|,
name|bottom
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if `t' is known to be non-negative.  */
end_comment

begin_function
name|int
name|tree_expr_nonnegative_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ABS_EXPR
case|:
case|case
name|FFS_EXPR
case|:
return|return
literal|1
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|tree_int_cst_sgn
argument_list|(
name|t
argument_list|)
operator|>=
literal|0
return|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MIN_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MAX_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MODIFY_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|BIND_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|RTL_EXPR
case|:
return|return
name|rtl_expr_nonnegative_p
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
default|default:
if|if
condition|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
comment|/* Truth values evaluate to 0 or 1, which is nonnegative.  */
return|return
literal|1
return|;
else|else
comment|/* We don't know sign of `t', so be conservative and return false.  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if `r' is known to be non-negative.    Only handles constants at the moment.  */
end_comment

begin_function
name|int
name|rtl_expr_nonnegative_p
parameter_list|(
name|r
parameter_list|)
name|rtx
name|r
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
return|return
name|INTVAL
argument_list|(
name|r
argument_list|)
operator|>=
literal|0
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|CONST_DOUBLE_HIGH
argument_list|(
name|r
argument_list|)
operator|>=
literal|0
return|;
return|return
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
comment|/* These are always nonnegative.  */
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

end_unit

