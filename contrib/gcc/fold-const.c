begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fold a constant sub-tree into a single node for C-compiler    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*@@ This file should be rewritten to use an arbitrary precision   @@ representation for "struct tree_int_cst" and "struct tree_real_cst".   @@ Perhaps the routines could also be used for bc/dc, and made a lib.   @@ The routines that translate from the ap rep should   @@ warn if precision et. al. is lost.   @@ This would also make life easier when this technology is used   @@ for cross-compilers.  */
end_comment

begin_comment
comment|/* The entry points in this file are fold, size_int_wide, size_binop    and force_fit_type.     fold takes a tree as argument and returns a simplified tree.     size_binop takes a tree code for an arithmetic operation    and two operands that are trees, and produces a tree for the    result, assuming the type comes from `sizetype'.     size_int takes an integer value, and creates a tree constant    with type from `sizetype'.     force_fit_type takes a constant and prior overflow indicator, and    forces the value to fit the type.  It returns an overflow indicator.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_function_decl
specifier|static
name|void
name|encode
parameter_list|(
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode
parameter_list|(
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|negate_mathfn_p
parameter_list|(
name|enum
name|built_in_function
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|negate_expr_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|negate_expr
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|split_tree
parameter_list|(
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|associate_trees
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|int_const_binop
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|const_binop
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|size_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|size_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_convert_const
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_convert
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|invert_tree_comparison
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|swap_tree_comparison
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comparison_to_compcode
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|compcode_to_comparison
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|truth_value_p
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|operand_equal_for_comparison_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twoval_comparison_p
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|eval_subst
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pedantic_omit_one_operand
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|distribute_bit_expr
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|make_bit_field_ref
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|optimize_bit_field_compare
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|decode_field_reference
parameter_list|(
name|tree
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|enum
name|machine_mode
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|all_ones_mask_p
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|sign_bit_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|simple_operand_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|range_binop
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|make_range
parameter_list|(
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_range_check
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|merge_ranges
parameter_list|(
name|int
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_range_test
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|unextend
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_truthop
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|optimize_minmax_comparison
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|extract_muldiv
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|extract_muldiv_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|strip_compound_expr
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|multiple_of_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|constant_boolean_node
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_cond
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_binary_op_with_conditional_arg
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|fold_real_zero_addition_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_mathfn_compare
parameter_list|(
name|enum
name|built_in_function
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|fold_inf_compare
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|reorder_operands_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|tree_swap_operands_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The following constants represent a bit based encoding of GCC's    comparison operators.  This encoding simplifies transformations    on relational comparison operators, such as AND and OR.  */
end_comment

begin_define
define|#
directive|define
name|COMPCODE_FALSE
value|0
end_define

begin_define
define|#
directive|define
name|COMPCODE_LT
value|1
end_define

begin_define
define|#
directive|define
name|COMPCODE_EQ
value|2
end_define

begin_define
define|#
directive|define
name|COMPCODE_LE
value|3
end_define

begin_define
define|#
directive|define
name|COMPCODE_GT
value|4
end_define

begin_define
define|#
directive|define
name|COMPCODE_NE
value|5
end_define

begin_define
define|#
directive|define
name|COMPCODE_GE
value|6
end_define

begin_define
define|#
directive|define
name|COMPCODE_TRUE
value|7
end_define

begin_comment
comment|/* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring    overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,    and SUM1.  Then this yields nonzero if overflow occurred during the    addition.     Overflow occurs if A and B have the same sign, but A and SUM differ in    sign.  Use `^' to test whether signs differ, and `< 0' to isolate the    sign.  */
end_comment

begin_define
define|#
directive|define
name|OVERFLOW_SUM_SIGN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|sum
parameter_list|)
value|((~((a) ^ (b))& ((a) ^ (sum)))< 0)
end_define

begin_escape
end_escape

begin_comment
comment|/* To do constant folding on INTEGER_CST nodes requires two-word arithmetic.    We do that by representing the two-word integer in 4 words, with only    HOST_BITS_PER_WIDE_INT / 2 bits stored in each word, as a positive    number.  The value of the word is LOWPART + HIGHPART * BASE.  */
end_comment

begin_define
define|#
directive|define
name|LOWPART
parameter_list|(
name|x
parameter_list|)
define|\
value|((x)& (((unsigned HOST_WIDE_INT) 1<< (HOST_BITS_PER_WIDE_INT / 2)) - 1))
end_define

begin_define
define|#
directive|define
name|HIGHPART
parameter_list|(
name|x
parameter_list|)
define|\
value|((unsigned HOST_WIDE_INT) (x)>> HOST_BITS_PER_WIDE_INT / 2)
end_define

begin_define
define|#
directive|define
name|BASE
value|((unsigned HOST_WIDE_INT) 1<< HOST_BITS_PER_WIDE_INT / 2)
end_define

begin_comment
comment|/* Unpack a two-word integer into 4 words.    LOW and HI are the integer, as two `HOST_WIDE_INT' pieces.    WORDS points to the array of HOST_WIDE_INTs.  */
end_comment

begin_function
specifier|static
name|void
name|encode
parameter_list|(
name|HOST_WIDE_INT
modifier|*
name|words
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|low
parameter_list|,
name|HOST_WIDE_INT
name|hi
parameter_list|)
block|{
name|words
index|[
literal|0
index|]
operator|=
name|LOWPART
argument_list|(
name|low
argument_list|)
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
name|HIGHPART
argument_list|(
name|low
argument_list|)
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
name|LOWPART
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
name|HIGHPART
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pack an array of 4 words into a two-word integer.    WORDS points to the array of words.    The integer is stored into *LOW and *HI as two `HOST_WIDE_INT' pieces.  */
end_comment

begin_function
specifier|static
name|void
name|decode
parameter_list|(
name|HOST_WIDE_INT
modifier|*
name|words
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|low
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hi
parameter_list|)
block|{
operator|*
name|low
operator|=
name|words
index|[
literal|0
index|]
operator|+
name|words
index|[
literal|1
index|]
operator|*
name|BASE
expr_stmt|;
operator|*
name|hi
operator|=
name|words
index|[
literal|2
index|]
operator|+
name|words
index|[
literal|3
index|]
operator|*
name|BASE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make the integer constant T valid for its type by setting to 0 or 1 all    the bits in the constant that don't belong in the type.     Return 1 if a signed overflow occurs, 0 otherwise.  If OVERFLOW is    nonzero, a signed overflow has already occurred in calculating T, so    propagate it.  */
end_comment

begin_function
name|int
name|force_fit_type
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|overflow
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|unsigned
name|int
name|prec
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
comment|/* ??? Used to check for overflow here via CHECK_FLOAT_TYPE. 	 Consider doing it via real_convert now.  */
return|return
name|overflow
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|overflow
return|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|prec
operator|=
name|POINTER_SIZE
expr_stmt|;
else|else
name|prec
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First clear all bits that are beyond the type's precision.  */
if|if
condition|(
name|prec
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|&=
operator|~
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
comment|/* Unsigned types do not suffer sign extension or overflow unless they      are a sizetype.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|overflow
return|;
comment|/* If the value's sign bit is set, extend the sign.  */
if|if
condition|(
name|prec
operator|!=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|?
literal|0
operator|!=
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|)
else|:
literal|0
operator|!=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Value is negative: 	 set to 1 all the bits that are outside this type's precision.  */
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator||=
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
block|}
comment|/* Return nonzero if signed overflow occurred.  */
return|return
operator|(
operator|(
name|overflow
operator||
operator|(
name|low
operator|^
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|)
operator||
operator|(
name|high
operator|^
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add two doubleword integers with doubleword result.    Each argument is given as two `HOST_WIDE_INT' pieces.    One argument is L1 and H1; the other, L2 and H2.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|int
name|add_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|l2
parameter_list|,
name|HOST_WIDE_INT
name|h2
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|HOST_WIDE_INT
name|h
decl_stmt|;
name|l
operator|=
name|l1
operator|+
name|l2
expr_stmt|;
name|h
operator|=
name|h1
operator|+
name|h2
operator|+
operator|(
name|l
operator|<
name|l1
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|l
expr_stmt|;
operator|*
name|hv
operator|=
name|h
expr_stmt|;
return|return
name|OVERFLOW_SUM_SIGN
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
name|h
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Negate a doubleword integer with doubleword result.    Return nonzero if the operation overflows, assuming it's signed.    The argument is given as two `HOST_WIDE_INT' pieces in L1 and H1.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|int
name|neg_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|)
block|{
if|if
condition|(
name|l1
operator|==
literal|0
condition|)
block|{
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
operator|*
name|hv
operator|=
operator|-
name|h1
expr_stmt|;
return|return
operator|(
operator|*
name|hv
operator|&
name|h1
operator|)
operator|<
literal|0
return|;
block|}
else|else
block|{
operator|*
name|lv
operator|=
operator|-
name|l1
expr_stmt|;
operator|*
name|hv
operator|=
operator|~
name|h1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Multiply two doubleword integers with doubleword result.    Return nonzero if the operation overflows, assuming it's signed.    Each argument is given as two `HOST_WIDE_INT' pieces.    One argument is L1 and H1; the other, L2 and H2.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|int
name|mul_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|l2
parameter_list|,
name|HOST_WIDE_INT
name|h2
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|)
block|{
name|HOST_WIDE_INT
name|arg1
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|arg2
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|prod
index|[
literal|4
operator|*
literal|2
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|carry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|toplow
decl_stmt|,
name|neglow
decl_stmt|;
name|HOST_WIDE_INT
name|tophigh
decl_stmt|,
name|neghigh
decl_stmt|;
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|arg2
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|prod
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|prod
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|i
operator|+
name|j
expr_stmt|;
comment|/* This product is<= 0xFFFE0001, the sum<= 0xFFFF0000.  */
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
operator|*
name|arg2
index|[
name|j
index|]
expr_stmt|;
comment|/* Since prod[p]< 0xFFFF, this sum<= 0xFFFFFFFF.  */
name|carry
operator|+=
name|prod
index|[
name|k
index|]
expr_stmt|;
name|prod
index|[
name|k
index|]
operator|=
name|LOWPART
argument_list|(
name|carry
argument_list|)
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|carry
argument_list|)
expr_stmt|;
block|}
name|prod
index|[
name|i
operator|+
literal|4
index|]
operator|=
name|carry
expr_stmt|;
block|}
name|decode
argument_list|(
name|prod
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
comment|/* This ignores prod[4] through prod[4*2-1] */
comment|/* Check for overflow by calculating the top half of the answer in full;      it should agree with the low half's sign bit.  */
name|decode
argument_list|(
name|prod
operator|+
literal|4
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
if|if
condition|(
name|h1
operator|<
literal|0
condition|)
block|{
name|neg_double
argument_list|(
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|neglow
argument_list|,
operator|&
name|neghigh
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|neglow
argument_list|,
name|neghigh
argument_list|,
name|toplow
argument_list|,
name|tophigh
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h2
operator|<
literal|0
condition|)
block|{
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|neglow
argument_list|,
operator|&
name|neghigh
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|neglow
argument_list|,
name|neghigh
argument_list|,
name|toplow
argument_list|,
name|tophigh
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|hv
operator|<
literal|0
condition|?
operator|~
operator|(
name|toplow
operator|&
name|tophigh
operator|)
else|:
name|toplow
operator||
name|tophigh
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Shift the doubleword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.    Shift right if COUNT is negative.    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|lshift_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|HOST_WIDE_INT
name|count
parameter_list|,
name|unsigned
name|int
name|prec
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|,
name|int
name|arith
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|signmask
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|-
name|count
argument_list|,
name|prec
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|arith
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|count
operator|%=
name|prec
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Shifting by the host word size is undefined according to the 	 ANSI standard, so we must handle this as a special case.  */
operator|*
name|hv
operator|=
literal|0
expr_stmt|;
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|=
name|l1
operator|<<
operator|(
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|<<
name|count
operator|)
operator||
operator|(
name|l1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|count
operator|-
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|l1
operator|<<
name|count
expr_stmt|;
block|}
comment|/* Sign extend all bits that are beyond the precision.  */
name|signmask
operator|=
operator|-
operator|(
operator|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|?
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|*
name|hv
operator|>>
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
else|:
operator|(
operator|*
name|lv
operator|>>
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|prec
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
operator|*
name|hv
operator||=
name|signmask
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
name|signmask
expr_stmt|;
operator|*
name|lv
operator|&=
operator|~
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
operator|*
name|lv
operator||=
name|signmask
operator|<<
name|prec
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift the doubleword integer in L1, H1 right by COUNT places    keeping only PREC bits of result.  COUNT must be positive.    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|rshift_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|HOST_WIDE_INT
name|count
parameter_list|,
name|unsigned
name|int
name|prec
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|,
name|int
name|arith
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|signmask
decl_stmt|;
name|signmask
operator|=
operator|(
name|arith
condition|?
operator|-
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
else|:
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
name|count
operator|%=
name|prec
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Shifting by the host word size is undefined according to the 	 ANSI standard, so we must handle this as a special case.  */
operator|*
name|hv
operator|=
literal|0
expr_stmt|;
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|=
literal|0
expr_stmt|;
operator|*
name|lv
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>>
operator|(
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|>>
name|count
expr_stmt|;
operator|*
name|lv
operator|=
operator|(
operator|(
name|l1
operator|>>
name|count
operator|)
operator||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|h1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|count
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Zero / sign extend all bits that are beyond the precision.  */
if|if
condition|(
name|count
operator|>=
operator|(
name|HOST_WIDE_INT
operator|)
name|prec
condition|)
block|{
operator|*
name|hv
operator|=
name|signmask
expr_stmt|;
operator|*
name|lv
operator|=
name|signmask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|prec
operator|-
name|count
operator|)
operator|>=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|prec
operator|-
name|count
operator|)
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
operator|*
name|hv
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
operator|*
name|hv
operator||=
name|signmask
operator|<<
operator|(
name|prec
operator|-
name|count
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hv
operator|=
name|signmask
expr_stmt|;
operator|*
name|lv
operator|&=
operator|~
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|count
operator|)
operator|)
expr_stmt|;
operator|*
name|lv
operator||=
name|signmask
operator|<<
operator|(
name|prec
operator|-
name|count
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Rotate the doubleword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.    Rotate right if COUNT is negative.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|lrotate_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|HOST_WIDE_INT
name|count
parameter_list|,
name|unsigned
name|int
name|prec
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|s1l
decl_stmt|,
name|s2l
decl_stmt|;
name|HOST_WIDE_INT
name|s1h
decl_stmt|,
name|s2h
decl_stmt|;
name|count
operator|%=
name|prec
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|+=
name|prec
expr_stmt|;
name|lshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s1l
argument_list|,
operator|&
name|s1h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|prec
operator|-
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s2l
argument_list|,
operator|&
name|s2h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|lv
operator|=
name|s1l
operator||
name|s2l
expr_stmt|;
operator|*
name|hv
operator|=
name|s1h
operator||
name|s2h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rotate the doubleword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.  COUNT must be positive.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|rrotate_double
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l1
parameter_list|,
name|HOST_WIDE_INT
name|h1
parameter_list|,
name|HOST_WIDE_INT
name|count
parameter_list|,
name|unsigned
name|int
name|prec
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lv
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hv
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|s1l
decl_stmt|,
name|s2l
decl_stmt|;
name|HOST_WIDE_INT
name|s1h
decl_stmt|,
name|s2h
decl_stmt|;
name|count
operator|%=
name|prec
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|+=
name|prec
expr_stmt|;
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s1l
argument_list|,
operator|&
name|s1h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|prec
operator|-
name|count
argument_list|,
name|prec
argument_list|,
operator|&
name|s2l
argument_list|,
operator|&
name|s2h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|lv
operator|=
name|s1l
operator||
name|s2l
expr_stmt|;
operator|*
name|hv
operator|=
name|s1h
operator||
name|s2h
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Divide doubleword integer LNUM, HNUM by doubleword integer LDEN, HDEN    for a quotient (stored in *LQUO, *HQUO) and remainder (in *LREM, *HREM).    CODE is a tree code for a kind of division, one of    TRUNC_DIV_EXPR, FLOOR_DIV_EXPR, CEIL_DIV_EXPR, ROUND_DIV_EXPR    or EXACT_DIV_EXPR    It controls how the quotient is rounded to an integer.    Return nonzero if the operation overflows.    UNS nonzero says do unsigned division.  */
end_comment

begin_function
name|int
name|div_and_round_double
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|int
name|uns
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|lnum_orig
parameter_list|,
comment|/* num == numerator == dividend */
name|HOST_WIDE_INT
name|hnum_orig
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|lden_orig
parameter_list|,
comment|/* den == denominator == divisor */
name|HOST_WIDE_INT
name|hden_orig
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lquo
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hquo
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lrem
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|hrem
parameter_list|)
block|{
name|int
name|quo_neg
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|num
index|[
literal|4
operator|+
literal|1
index|]
decl_stmt|;
comment|/* extra element for scaling.  */
name|HOST_WIDE_INT
name|den
index|[
literal|4
index|]
decl_stmt|,
name|quo
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|work
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|carry
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lnum
init|=
name|lnum_orig
decl_stmt|;
name|HOST_WIDE_INT
name|hnum
init|=
name|hnum_orig
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lden
init|=
name|lden_orig
decl_stmt|;
name|HOST_WIDE_INT
name|hden
init|=
name|hden_orig
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hden
operator|==
literal|0
operator|&&
name|lden
operator|==
literal|0
condition|)
name|overflow
operator|=
literal|1
operator|,
name|lden
operator|=
literal|1
expr_stmt|;
comment|/* Calculate quotient sign and convert operands to unsigned.  */
if|if
condition|(
operator|!
name|uns
condition|)
block|{
if|if
condition|(
name|hnum
operator|<
literal|0
condition|)
block|{
name|quo_neg
operator|=
operator|~
name|quo_neg
expr_stmt|;
comment|/* (minimum integer) / (-1) is the only overflow case.  */
if|if
condition|(
name|neg_double
argument_list|(
name|lnum
argument_list|,
name|hnum
argument_list|,
operator|&
name|lnum
argument_list|,
operator|&
name|hnum
argument_list|)
operator|&&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|lden
operator|&
name|hden
operator|)
operator|==
operator|-
literal|1
condition|)
name|overflow
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hden
operator|<
literal|0
condition|)
block|{
name|quo_neg
operator|=
operator|~
name|quo_neg
expr_stmt|;
name|neg_double
argument_list|(
name|lden
argument_list|,
name|hden
argument_list|,
operator|&
name|lden
argument_list|,
operator|&
name|hden
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hnum
operator|==
literal|0
operator|&&
name|hden
operator|==
literal|0
condition|)
block|{
comment|/* single precision */
operator|*
name|hquo
operator|=
operator|*
name|hrem
operator|=
literal|0
expr_stmt|;
comment|/* This unsigned division rounds toward zero.  */
operator|*
name|lquo
operator|=
name|lnum
operator|/
name|lden
expr_stmt|;
goto|goto
name|finish_up
goto|;
block|}
if|if
condition|(
name|hnum
operator|==
literal|0
condition|)
block|{
comment|/* trivial case: dividend< divisor */
comment|/* hden != 0 already checked.  */
operator|*
name|hquo
operator|=
operator|*
name|lquo
operator|=
literal|0
expr_stmt|;
operator|*
name|hrem
operator|=
name|hnum
expr_stmt|;
operator|*
name|lrem
operator|=
name|lnum
expr_stmt|;
goto|goto
name|finish_up
goto|;
block|}
name|memset
argument_list|(
name|quo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|quo
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|num
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|num
argument_list|)
expr_stmt|;
comment|/* to zero 9th element */
name|memset
argument_list|(
name|den
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|den
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|num
argument_list|,
name|lnum
argument_list|,
name|hnum
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|den
argument_list|,
name|lden
argument_list|,
name|hden
argument_list|)
expr_stmt|;
comment|/* Special code for when the divisor< BASE.  */
if|if
condition|(
name|hden
operator|==
literal|0
operator|&&
name|lden
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|BASE
condition|)
block|{
comment|/* hnum != 0 already checked.  */
for|for
control|(
name|i
operator|=
literal|4
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|work
operator|=
name|num
index|[
name|i
index|]
operator|+
name|carry
operator|*
name|BASE
expr_stmt|;
name|quo
index|[
name|i
index|]
operator|=
name|work
operator|/
name|lden
expr_stmt|;
name|carry
operator|=
name|work
operator|%
name|lden
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Full double precision division, 	 with thanks to Don Knuth's "Seminumerical Algorithms".  */
name|int
name|num_hi_sig
decl_stmt|,
name|den_hi_sig
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|quo_est
decl_stmt|,
name|scale
decl_stmt|;
comment|/* Find the highest nonzero divisor digit.  */
for|for
control|(
name|i
operator|=
literal|4
operator|-
literal|1
init|;
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|den
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|den_hi_sig
operator|=
name|i
expr_stmt|;
break|break;
block|}
comment|/* Insure that the first digit of the divisor is at least BASE/2. 	 This is required by the quotient digit estimation algorithm.  */
name|scale
operator|=
name|BASE
operator|/
operator|(
name|den
index|[
name|den_hi_sig
index|]
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|scale
operator|>
literal|1
condition|)
block|{
comment|/* scale divisor and dividend */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|4
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|num
index|[
name|i
index|]
operator|*
name|scale
operator|)
operator|+
name|carry
expr_stmt|;
name|num
index|[
name|i
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
name|num
index|[
literal|4
index|]
operator|=
name|carry
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|4
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|den
index|[
name|i
index|]
operator|*
name|scale
operator|)
operator|+
name|carry
expr_stmt|;
name|den
index|[
name|i
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|den
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|den_hi_sig
operator|=
name|i
expr_stmt|;
block|}
block|}
name|num_hi_sig
operator|=
literal|4
expr_stmt|;
comment|/* Main loop */
for|for
control|(
name|i
operator|=
name|num_hi_sig
operator|-
name|den_hi_sig
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Guess the next quotient digit, quo_est, by dividing the first 	     two remaining dividend digits by the high order quotient digit. 	     quo_est is never low and is at most 2 high.  */
name|unsigned
name|HOST_WIDE_INT
name|tmp
decl_stmt|;
name|num_hi_sig
operator|=
name|i
operator|+
name|den_hi_sig
operator|+
literal|1
expr_stmt|;
name|work
operator|=
name|num
index|[
name|num_hi_sig
index|]
operator|*
name|BASE
operator|+
name|num
index|[
name|num_hi_sig
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|num
index|[
name|num_hi_sig
index|]
operator|!=
name|den
index|[
name|den_hi_sig
index|]
condition|)
name|quo_est
operator|=
name|work
operator|/
name|den
index|[
name|den_hi_sig
index|]
expr_stmt|;
else|else
name|quo_est
operator|=
name|BASE
operator|-
literal|1
expr_stmt|;
comment|/* Refine quo_est so it's usually correct, and at most one high.  */
name|tmp
operator|=
name|work
operator|-
name|quo_est
operator|*
name|den
index|[
name|den_hi_sig
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|BASE
operator|&&
operator|(
name|den
index|[
name|den_hi_sig
operator|-
literal|1
index|]
operator|*
name|quo_est
operator|>
operator|(
name|tmp
operator|*
name|BASE
operator|+
name|num
index|[
name|num_hi_sig
operator|-
literal|2
index|]
operator|)
operator|)
condition|)
name|quo_est
operator|--
expr_stmt|;
comment|/* Try QUO_EST as the quotient digit, by multiplying the 	     divisor by QUO_EST and subtracting from the remaining dividend. 	     Keep in mind that QUO_EST is the I - 1st digit.  */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|den_hi_sig
condition|;
name|j
operator|++
control|)
block|{
name|work
operator|=
name|quo_est
operator|*
name|den
index|[
name|j
index|]
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|work
operator|=
name|num
index|[
name|i
operator|+
name|j
index|]
operator|-
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|num
index|[
name|i
operator|+
name|j
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|carry
operator|+=
name|HIGHPART
argument_list|(
name|work
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
comment|/* If quo_est was high by one, then num[i] went negative and 	     we need to correct things.  */
if|if
condition|(
name|num
index|[
name|num_hi_sig
index|]
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|carry
condition|)
block|{
name|quo_est
operator|--
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
comment|/* add divisor back in */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|den_hi_sig
condition|;
name|j
operator|++
control|)
block|{
name|work
operator|=
name|num
index|[
name|i
operator|+
name|j
index|]
operator|+
name|den
index|[
name|j
index|]
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|HIGHPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|num
index|[
name|i
operator|+
name|j
index|]
operator|=
name|LOWPART
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
name|num
index|[
name|num_hi_sig
index|]
operator|+=
name|carry
expr_stmt|;
block|}
comment|/* Store the quotient digit.  */
name|quo
index|[
name|i
index|]
operator|=
name|quo_est
expr_stmt|;
block|}
block|}
name|decode
argument_list|(
name|quo
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
name|finish_up
label|:
comment|/* If result is negative, make it so.  */
if|if
condition|(
name|quo_neg
condition|)
name|neg_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
comment|/* compute trial remainder:  rem = num - (quo * den)  */
name|mul_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lden_orig
argument_list|,
name|hden_orig
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lnum_orig
argument_list|,
name|hnum_orig
argument_list|,
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
comment|/* round toward zero */
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* for this one, it shouldn't matter */
return|return
name|overflow
return|;
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
comment|/* round toward negative infinity */
if|if
condition|(
name|quo_neg
operator|&&
operator|(
operator|*
name|lrem
operator|!=
literal|0
operator|||
operator|*
name|hrem
operator|!=
literal|0
operator|)
condition|)
comment|/* ratio< 0&& rem != 0 */
block|{
comment|/* quo = quo - 1;  */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
break|break;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
comment|/* round toward positive infinity */
if|if
condition|(
operator|!
name|quo_neg
operator|&&
operator|(
operator|*
name|lrem
operator|!=
literal|0
operator|||
operator|*
name|hrem
operator|!=
literal|0
operator|)
condition|)
comment|/* ratio> 0&& rem != 0 */
block|{
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
break|break;
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
comment|/* round to closest integer */
block|{
name|unsigned
name|HOST_WIDE_INT
name|labs_rem
init|=
operator|*
name|lrem
decl_stmt|;
name|HOST_WIDE_INT
name|habs_rem
init|=
operator|*
name|hrem
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|labs_den
init|=
name|lden
decl_stmt|,
name|ltwice
decl_stmt|;
name|HOST_WIDE_INT
name|habs_den
init|=
name|hden
decl_stmt|,
name|htwice
decl_stmt|;
comment|/* Get absolute values.  */
if|if
condition|(
operator|*
name|hrem
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
operator|&
name|labs_rem
argument_list|,
operator|&
name|habs_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|hden
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|lden
argument_list|,
name|hden
argument_list|,
operator|&
name|labs_den
argument_list|,
operator|&
name|habs_den
argument_list|)
expr_stmt|;
comment|/* If (2 * abs (lrem)>= abs (lden)) */
name|mul_double
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|labs_rem
argument_list|,
name|habs_rem
argument_list|,
operator|&
name|ltwice
argument_list|,
operator|&
name|htwice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|habs_den
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|htwice
operator|)
operator|||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|habs_den
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|htwice
operator|)
operator|&&
operator|(
name|labs_den
operator|<
name|ltwice
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|hquo
operator|<
literal|0
condition|)
comment|/* quo = quo - 1;  */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
else|else
comment|/* quo = quo + 1; */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Compute true remainder:  rem = num - (quo * den)  */
name|mul_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lden_orig
argument_list|,
name|hden_orig
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lnum_orig
argument_list|,
name|hnum_orig
argument_list|,
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
return|return
name|overflow
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if built-in mathematical function specified by CODE    preserves the sign of it argument, i.e. -f(x) == f(-x).  */
end_comment

begin_function
specifier|static
name|bool
name|negate_mathfn_p
parameter_list|(
name|enum
name|built_in_function
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BUILT_IN_ASIN
case|:
case|case
name|BUILT_IN_ASINF
case|:
case|case
name|BUILT_IN_ASINL
case|:
case|case
name|BUILT_IN_ATAN
case|:
case|case
name|BUILT_IN_ATANF
case|:
case|case
name|BUILT_IN_ATANL
case|:
case|case
name|BUILT_IN_SIN
case|:
case|case
name|BUILT_IN_SINF
case|:
case|case
name|BUILT_IN_SINL
case|:
case|case
name|BUILT_IN_TAN
case|:
case|case
name|BUILT_IN_TANF
case|:
case|case
name|BUILT_IN_TANL
case|:
return|return
name|true
return|;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determine whether an expression T can be cheaply negated using    the function negate_expr.  */
end_comment

begin_function
specifier|static
name|bool
name|negate_expr_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|unsigned
name|int
name|prec
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|flag_trapv
condition|)
return|return
name|true
return|;
comment|/* Check that -CST will not overflow type.  */
name|prec
operator|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
name|prec
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|val
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|val
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|val
operator|!=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
return|;
case|case
name|REAL_CST
case|:
case|case
name|NEGATE_EXPR
case|:
return|return
name|true
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|negate_expr_p
argument_list|(
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|negate_expr_p
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
comment|/* We can't turn -(A-B) into B-A when we honor signed zeros.  */
return|return
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|RDIV_EXPR
case|:
if|if
condition|(
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|negate_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|negate_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|NOP_EXPR
case|:
comment|/* Negate -((double)float) as (double)(-float).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
name|tree
name|tem
init|=
name|strip_float_extensions
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
name|t
condition|)
return|return
name|negate_expr_p
argument_list|(
name|tem
argument_list|)
return|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* Negate -f(x) as f(-x).  */
if|if
condition|(
name|negate_mathfn_p
argument_list|(
name|builtin_mathfn_code
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|negate_expr_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Given T, an expression, return the negation of T.  Allow for T to be    null, in which case return null.  */
end_comment

begin_function
specifier|static
name|tree
name|negate_expr
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|tem
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|int
name|overflow
init|=
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
decl_stmt|;
name|tem
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|tem
argument_list|)
operator|=
operator|(
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|force_fit_type
argument_list|(
name|tem
argument_list|,
name|overflow
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|tem
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TREE_OVERFLOW
argument_list|(
name|tem
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|flag_trapv
condition|)
return|return
name|tem
return|;
break|break;
case|case
name|REAL_CST
case|:
name|tem
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Two's complement FP formats, such as c4x, may overflow.  */
if|if
condition|(
operator|!
name|TREE_OVERFLOW
argument_list|(
name|tem
argument_list|)
operator|||
operator|!
name|flag_trapping_math
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
break|break;
case|case
name|COMPLEX_CST
case|:
block|{
name|tree
name|rpart
init|=
name|negate_expr
argument_list|(
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ipart
init|=
name|negate_expr
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|rpart
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|ipart
argument_list|)
operator|==
name|REAL_CST
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|rpart
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|ipart
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
return|return
name|build_complex
argument_list|(
name|type
argument_list|,
name|rpart
argument_list|,
name|ipart
argument_list|)
return|;
block|}
break|break;
case|case
name|NEGATE_EXPR
case|:
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
comment|/* - (A - B) -> B - A  */
if|if
condition|(
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|reorder_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|RDIV_EXPR
case|:
if|if
condition|(
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|negate_expr_p
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|negate_expr_p
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|tem
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|NOP_EXPR
case|:
comment|/* Convert -((double)float) into (double)(-float).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
name|tem
operator|=
name|strip_float_extensions
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|t
operator|&&
name|negate_expr_p
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* Negate -f(x) as f(-x).  */
if|if
condition|(
name|negate_mathfn_p
argument_list|(
name|builtin_mathfn_code
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|negate_expr_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|fndecl
decl_stmt|,
name|arg
decl_stmt|,
name|arglist
decl_stmt|;
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|arg
operator|=
name|negate_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
name|tem
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split a tree IN into a constant, literal and variable parts that could be    combined with CODE to make IN.  "constant" means an expression with    TREE_CONSTANT but that isn't an actual constant.  CODE must be a    commutative arithmetic operation.  Store the constant part into *CONP,    the literal in *LITP and return the variable part.  If a part isn't    present, set it to null.  If the tree does not decompose in this way,    return the entire tree as the variable part and the other parts as null.     If CODE is PLUS_EXPR we also split trees that use MINUS_EXPR.  In that    case, we negate an operand that was subtracted.  Except if it is a    literal for which we use *MINUS_LITP instead.     If NEGATE_P is true, we are negating all of IN, again except a literal    for which we use *MINUS_LITP instead.     If IN is itself a literal or constant, return it as appropriate.     Note that we do not guarantee that any of the three values will be the    same type as IN, but they will have the same signedness and mode.  */
end_comment

begin_function
specifier|static
name|tree
name|split_tree
parameter_list|(
name|tree
name|in
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
modifier|*
name|conp
parameter_list|,
name|tree
modifier|*
name|litp
parameter_list|,
name|tree
modifier|*
name|minus_litp
parameter_list|,
name|int
name|negate_p
parameter_list|)
block|{
name|tree
name|var
init|=
literal|0
decl_stmt|;
operator|*
name|conp
operator|=
literal|0
expr_stmt|;
operator|*
name|litp
operator|=
literal|0
expr_stmt|;
operator|*
name|minus_litp
operator|=
literal|0
expr_stmt|;
comment|/* Strip any conversions that don't change the machine mode or signedness.  */
name|STRIP_SIGN_NOPS
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REAL_CST
condition|)
operator|*
name|litp
operator|=
name|in
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|code
operator|||
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|in
argument_list|)
argument_list|)
comment|/* We can associate addition and subtraction together (even 		  though the C standard doesn't say so) for integers because 		  the value is not affected.  For reals, the value might be 		  affected, so we can't.  */
operator|&&
operator|(
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|||
operator|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|PLUS_EXPR
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|neg1_p
init|=
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
decl_stmt|;
name|int
name|neg_litp_p
init|=
literal|0
decl_stmt|,
name|neg_conp_p
init|=
literal|0
decl_stmt|,
name|neg_var_p
init|=
literal|0
decl_stmt|;
comment|/* First see if either of the operands is a literal, then a constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REAL_CST
condition|)
operator|*
name|litp
operator|=
name|op0
operator|,
name|op0
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REAL_CST
condition|)
operator|*
name|litp
operator|=
name|op1
operator|,
name|neg_litp_p
operator|=
name|neg1_p
operator|,
name|op1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
literal|0
operator|&&
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
condition|)
operator|*
name|conp
operator|=
name|op0
operator|,
name|op0
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|op1
operator|!=
literal|0
operator|&&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
condition|)
operator|*
name|conp
operator|=
name|op1
operator|,
name|neg_conp_p
operator|=
name|neg1_p
operator|,
name|op1
operator|=
literal|0
expr_stmt|;
comment|/* If we haven't dealt with either operand, this is not a case we can 	 decompose.  Otherwise, VAR is either of the ones remaining, if any.  */
if|if
condition|(
name|op0
operator|!=
literal|0
operator|&&
name|op1
operator|!=
literal|0
condition|)
name|var
operator|=
name|in
expr_stmt|;
elseif|else
if|if
condition|(
name|op0
operator|!=
literal|0
condition|)
name|var
operator|=
name|op0
expr_stmt|;
else|else
name|var
operator|=
name|op1
operator|,
name|neg_var_p
operator|=
name|neg1_p
expr_stmt|;
comment|/* Now do any needed negations.  */
if|if
condition|(
name|neg_litp_p
condition|)
operator|*
name|minus_litp
operator|=
operator|*
name|litp
operator|,
operator|*
name|litp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|neg_conp_p
condition|)
operator|*
name|conp
operator|=
name|negate_expr
argument_list|(
operator|*
name|conp
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg_var_p
condition|)
name|var
operator|=
name|negate_expr
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|in
argument_list|)
condition|)
operator|*
name|conp
operator|=
name|in
expr_stmt|;
else|else
name|var
operator|=
name|in
expr_stmt|;
if|if
condition|(
name|negate_p
condition|)
block|{
if|if
condition|(
operator|*
name|litp
condition|)
operator|*
name|minus_litp
operator|=
operator|*
name|litp
operator|,
operator|*
name|litp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|minus_litp
condition|)
operator|*
name|litp
operator|=
operator|*
name|minus_litp
operator|,
operator|*
name|minus_litp
operator|=
literal|0
expr_stmt|;
operator|*
name|conp
operator|=
name|negate_expr
argument_list|(
operator|*
name|conp
argument_list|)
expr_stmt|;
name|var
operator|=
name|negate_expr
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Re-associate trees split by the above function.  T1 and T2 are either    expressions to associate or null.  Return the new expression, if any.  If    we build an operation, do it in TYPE and with CODE.  */
end_comment

begin_function
specifier|static
name|tree
name|associate_trees
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|t1
operator|==
literal|0
condition|)
return|return
name|t2
return|;
elseif|else
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
return|return
name|t1
return|;
comment|/* If either input is CODE, a PLUS_EXPR, or a MINUS_EXPR, don't      try to fold this since we will have infinite recursion.  But do      deal with any NEGATE_EXPRs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|code
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|code
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|MINUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
return|return
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|)
return|;
block|}
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Combine two integer constants ARG1 and ARG2 under operation CODE    to produce a new constant.     If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */
end_comment

begin_function
specifier|static
name|tree
name|int_const_binop
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|,
name|int
name|notrunc
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|int1l
decl_stmt|,
name|int2l
decl_stmt|;
name|HOST_WIDE_INT
name|int1h
decl_stmt|,
name|int2h
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|garbagel
decl_stmt|;
name|HOST_WIDE_INT
name|garbageh
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|is_sizetype
init|=
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|no_overflow
init|=
literal|0
decl_stmt|;
name|int1l
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|int1h
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|int2l
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|int2h
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BIT_IOR_EXPR
case|:
name|low
operator|=
name|int1l
operator||
name|int2l
operator|,
name|hi
operator|=
name|int1h
operator||
name|int2h
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|low
operator|=
name|int1l
operator|^
name|int2l
operator|,
name|hi
operator|=
name|int1h
operator|^
name|int2h
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|low
operator|=
name|int1l
operator|&
name|int2l
operator|,
name|hi
operator|=
name|int1h
operator|&
name|int2h
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|int2l
operator|=
operator|-
name|int2l
expr_stmt|;
case|case
name|LSHIFT_EXPR
case|:
comment|/* It's unclear from the C standard whether shifts can overflow. 	 The following code ignores overflow; perhaps a C standard 	 interpretation ruling is needed.  */
name|lshift_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|,
operator|!
name|uns
argument_list|)
expr_stmt|;
name|no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RROTATE_EXPR
case|:
name|int2l
operator|=
operator|-
name|int2l
expr_stmt|;
case|case
name|LROTATE_EXPR
case|:
name|lrotate_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
name|overflow
operator|=
name|add_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|neg_double
argument_list|(
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|low
argument_list|,
name|hi
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|OVERFLOW_SUM_SIGN
argument_list|(
name|hi
argument_list|,
name|int2h
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|overflow
operator|=
name|mul_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* This is a shortcut for a common special case.  */
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int2l
operator|>
literal|0
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|&&
name|int1h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int1l
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CEIL_DIV_EXPR
condition|)
name|int1l
operator|+=
name|int2l
operator|-
literal|1
expr_stmt|;
name|low
operator|=
name|int1l
operator|/
name|int2l
operator|,
name|hi
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* ... fall through ...  */
case|case
name|ROUND_DIV_EXPR
case|:
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
name|int2l
operator|==
literal|1
condition|)
block|{
name|low
operator|=
name|int1l
operator|,
name|hi
operator|=
name|int1h
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int1l
operator|==
name|int2l
operator|&&
name|int1h
operator|==
name|int2h
operator|&&
operator|!
operator|(
name|int1l
operator|==
literal|0
operator|&&
name|int1h
operator|==
literal|0
operator|)
condition|)
block|{
name|low
operator|=
literal|1
operator|,
name|hi
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|overflow
operator|=
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|garbagel
argument_list|,
operator|&
name|garbageh
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
comment|/* This is a shortcut for a common special case.  */
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int2l
operator|>
literal|0
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|&&
name|int1h
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|int1l
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CEIL_MOD_EXPR
condition|)
name|int1l
operator|+=
name|int2l
operator|-
literal|1
expr_stmt|;
name|low
operator|=
name|int1l
operator|%
name|int2l
operator|,
name|hi
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* ... fall through ...  */
case|case
name|ROUND_MOD_EXPR
case|:
name|overflow
operator|=
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|garbagel
argument_list|,
operator|&
name|garbageh
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
if|if
condition|(
name|uns
condition|)
name|low
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int1h
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int2h
operator|)
operator|||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int1h
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int2h
operator|)
operator|&&
name|int1l
operator|<
name|int2l
operator|)
operator|)
expr_stmt|;
else|else
name|low
operator|=
operator|(
name|int1h
operator|<
name|int2h
operator|||
operator|(
name|int1h
operator|==
name|int2h
operator|&&
name|int1l
operator|<
name|int2l
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|low
operator|==
operator|(
name|code
operator|==
name|MIN_EXPR
operator|)
condition|)
name|low
operator|=
name|int1l
operator|,
name|hi
operator|=
name|int1h
expr_stmt|;
else|else
name|low
operator|=
name|int2l
operator|,
name|hi
operator|=
name|int2h
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this is for a sizetype, can be represented as one (signed)      HOST_WIDE_INT word, and doesn't overflow, use size_int since it caches      constants.  */
if|if
condition|(
name|is_sizetype
operator|&&
operator|(
operator|(
name|hi
operator|==
literal|0
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|low
operator|>=
literal|0
operator|)
operator|||
operator|(
name|hi
operator|==
operator|-
literal|1
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|low
operator|<
literal|0
operator|)
operator|)
operator|&&
name|overflow
operator|==
literal|0
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|arg2
argument_list|)
condition|)
return|return
name|size_int_type_wide
argument_list|(
name|low
argument_list|,
name|type
argument_list|)
return|;
else|else
block|{
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
operator|(
operator|(
name|notrunc
condition|?
operator|(
operator|!
name|uns
operator|||
name|is_sizetype
operator|)
operator|&&
name|overflow
else|:
operator|(
name|force_fit_type
argument_list|(
name|t
argument_list|,
operator|(
operator|!
name|uns
operator|||
name|is_sizetype
operator|)
operator|&&
name|overflow
argument_list|)
operator|&&
operator|!
name|no_overflow
operator|)
operator|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|)
expr_stmt|;
comment|/* If we're doing a size calculation, unsigned arithmetic does overflow.      So check if force_fit_type truncated the value.  */
if|if
condition|(
name|is_sizetype
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|!=
name|hi
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|!=
name|low
operator|)
condition|)
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Combine two constants ARG1 and ARG2 under operation CODE to produce a new    constant.  We assume ARG1 and ARG2 have the same data type, or at least    are the same kind of constant and the same machine mode.     If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */
end_comment

begin_function
specifier|static
name|tree
name|const_binop
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|,
name|int
name|notrunc
parameter_list|)
block|{
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|int_const_binop
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|notrunc
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
name|d1
decl_stmt|;
name|REAL_VALUE_TYPE
name|d2
decl_stmt|;
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|type
decl_stmt|;
name|d1
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Don't perform operation if we honor signaling NaNs and 	 either operand is a NaN.  */
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d1
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|d2
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Don't perform operation if it would raise a division 	 by zero exception.  */
if|if
condition|(
name|code
operator|==
name|RDIV_EXPR
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|d2
argument_list|,
name|dconst0
argument_list|)
operator|&&
operator|(
name|flag_trapping_math
operator|||
operator|!
name|MODE_HAS_INFINITIES
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If either operand is a NaN, just return it.  Otherwise, set up 	 for floating-point trap; we return an overflow.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d1
argument_list|)
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d2
argument_list|)
condition|)
return|return
name|arg2
return|;
name|REAL_ARITHMETIC
argument_list|(
name|value
argument_list|,
name|code
argument_list|,
name|d1
argument_list|,
name|d2
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|real_value_truncate
argument_list|(
name|mode
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_OVERFLOW
argument_list|(
name|arg2
argument_list|)
operator|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|r1
init|=
name|TREE_REALPART
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|i1
init|=
name|TREE_IMAGPART
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|r2
init|=
name|TREE_REALPART
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|tree
name|i2
init|=
name|TREE_IMAGPART
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
block|{
name|tree
name|magsquared
init|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r2
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i2
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_complex
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|r1
argument_list|)
argument_list|)
condition|?
name|TRUNC_DIV_EXPR
else|:
name|RDIV_EXPR
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|magsquared
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|r1
argument_list|)
argument_list|)
condition|?
name|TRUNC_DIV_EXPR
else|:
name|RDIV_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|r2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|i2
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|notrunc
argument_list|)
argument_list|,
name|magsquared
argument_list|,
name|notrunc
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* These are the hash table functions for the hash table of INTEGER_CST    nodes of a sizetype.  */
end_comment

begin_comment
comment|/* Return the hash code code X, an INTEGER_CST.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|size_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|x
decl_stmt|;
return|return
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|^
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|^
name|htab_hash_pointer
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|^
operator|(
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|<<
literal|20
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the value represented by *X (an INTEGER_CST tree node)    is the same as that given by *Y, which is the same.  */
end_comment

begin_function
specifier|static
name|int
name|size_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
name|tree
name|xt
init|=
operator|(
name|tree
operator|)
name|x
decl_stmt|;
name|tree
name|yt
init|=
operator|(
name|tree
operator|)
name|y
decl_stmt|;
return|return
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|xt
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|yt
argument_list|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|xt
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|yt
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|xt
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|yt
argument_list|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|xt
argument_list|)
operator|==
name|TREE_OVERFLOW
argument_list|(
name|yt
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an INTEGER_CST with value whose low-order HOST_BITS_PER_WIDE_INT    bits are given by NUMBER and of the sizetype represented by KIND.  */
end_comment

begin_function
name|tree
name|size_int_wide
parameter_list|(
name|HOST_WIDE_INT
name|number
parameter_list|,
name|enum
name|size_type_kind
name|kind
parameter_list|)
block|{
return|return
name|size_int_type_wide
argument_list|(
name|number
argument_list|,
name|sizetype_tab
index|[
operator|(
name|int
operator|)
name|kind
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but the desired type is specified explicitly.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|new_const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"ggc_marked_p"
argument|), param_is (union tree_node))
argument_list|)
name|htab_t
name|size_htab
expr_stmt|;
end_expr_stmt

begin_function
name|tree
name|size_int_type_wide
parameter_list|(
name|HOST_WIDE_INT
name|number
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|size_htab
operator|==
literal|0
condition|)
block|{
name|size_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|1024
argument_list|,
name|size_htab_hash
argument_list|,
name|size_htab_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new_const
operator|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust NEW_CONST to be the constant we want.  If it's already in the      hash table, we return the value from the hash table.  Otherwise, we      place that in the hash table and make a new node for the next time.  */
name|TREE_INT_CST_LOW
argument_list|(
name|new_const
argument_list|)
operator|=
name|number
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|new_const
argument_list|)
operator|=
name|number
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_const
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|new_const
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|new_const
argument_list|)
operator|=
name|force_fit_type
argument_list|(
name|new_const
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|size_htab
argument_list|,
name|new_const
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
literal|0
condition|)
block|{
name|tree
name|t
init|=
name|new_const
decl_stmt|;
operator|*
name|slot
operator|=
name|new_const
expr_stmt|;
name|new_const
operator|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
else|else
return|return
operator|(
name|tree
operator|)
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Combine operands OP1 and OP2 with arithmetic operation CODE.  CODE    is a tree code.  The type of the result is taken from the operands.    Both must be the same type integer type and it must be a size type.    If the operands are constant, so is the result.  */
end_comment

begin_function
name|tree
name|size_binop
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
operator|!
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
operator|||
name|type
operator|!=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Handle the special case of two integer constants faster.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* And some specific cases even faster than that.  */
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|MINUS_EXPR
operator|||
name|code
operator|==
name|PLUS_EXPR
operator|)
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|arg0
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg1
return|;
comment|/* Handle general case of two integer constants.  */
return|return
name|int_const_binop
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given two values, either both of sizetype or both of bitsizetype,    compute the difference between the two values.  Return the value    in signed type corresponding to the type of the operands.  */
end_comment

begin_function
name|tree
name|size_diffop
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|ctype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
operator|!
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
operator|||
name|type
operator|!=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the type is already signed, just do the simple thing.  */
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
name|ctype
operator|=
operator|(
name|type
operator|==
name|bitsizetype
operator|||
name|type
operator|==
name|ubitsizetype
condition|?
name|sbitsizetype
else|:
name|ssizetype
operator|)
expr_stmt|;
comment|/* If either operand is not a constant, do the conversions to the signed      type and subtract.  The hardware will do the right thing with any      overflow in the subtraction.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* If ARG0 is larger than ARG1, subtract and return the result in CTYPE.      Otherwise, subtract the other way, convert to CTYPE (we know that can't      overflow) and negate (which can't either).  Special-case a result      of zero while we're here.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|integer_zero_node
argument_list|)
return|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|arg1
argument_list|,
name|arg0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to fold type conversion operation CODE of expression ARG1 to    type TYPE.  If no simplification can be done return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_convert_const
parameter_list|(
name|enum
name|tree_code
name|code
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|==
name|type
condition|)
return|return
name|arg1
return|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* If we would build a constant wider than GCC supports, 	     leave the conversion unfolded.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we are trying to make a sizetype for a small integer, use 	     size_int to pick up cached types to reduce duplicate nodes.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|compare_tree_int
argument_list|(
name|arg1
argument_list|,
literal|10000
argument_list|)
operator|<
literal|0
condition|)
return|return
name|size_int_type_wide
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
comment|/* Given an integer constant, make new constant with new type, 	     appropriately sign-extended or truncated.  */
name|t
operator|=
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Indicate an overflow if (1) ARG1 already overflowed, 	     or (2) force_fit_type indicates an overflow. 	     Tell force_fit_type that an overflow has already occurred 	     if ARG1 is a too-large unsigned value and T is signed. 	     But don't indicate an overflow if converting a pointer.  */
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
operator|(
operator|(
name|force_fit_type
argument_list|(
name|t
argument_list|,
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|<
literal|0
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|<
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|)
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
comment|/* The following code implements the floating point to integer 	     conversion rules required by the Java Language Specification, 	     that IEEE NaNs are mapped to zero and values that overflow 	     the target precision saturate, i.e. values greater than 	     INT_MAX are mapped to INT_MAX, and values less than INT_MIN 	     are mapped to INT_MIN.  These semantics are allowed by the 	     C and C++ standards that simply state that the behavior of 	     FP-to-integer conversion is unspecified upon overflow.  */
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|REAL_VALUE_TYPE
name|x
init|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
comment|/* If x is NaN, return zero and show we have an overflow.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
block|}
comment|/* See if X will be in range after truncation towards 0. 	     To compensate for truncation, move the bounds away from 0, 	     but reject if X exactly equals the adjusted bounds.  */
if|if
condition|(
operator|!
name|overflow
condition|)
block|{
name|tree
name|lt
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|l
init|=
name|real_value_from_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|lt
argument_list|)
decl_stmt|;
name|REAL_ARITHMETIC
argument_list|(
name|l
argument_list|,
name|MINUS_EXPR
argument_list|,
name|l
argument_list|,
name|dconst1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_VALUES_LESS
argument_list|(
name|l
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|lt
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|lt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|overflow
condition|)
block|{
name|tree
name|ut
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ut
condition|)
block|{
name|REAL_VALUE_TYPE
name|u
init|=
name|real_value_from_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|ut
argument_list|)
decl_stmt|;
name|REAL_ARITHMETIC
argument_list|(
name|u
argument_list|,
name|PLUS_EXPR
argument_list|,
name|u
argument_list|,
name|dconst1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REAL_VALUES_LESS
argument_list|(
name|x
argument_list|,
name|u
argument_list|)
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|ut
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|ut
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|overflow
condition|)
name|REAL_VALUE_TO_INT
argument_list|(
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|force_fit_type
argument_list|(
name|t
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|build_real_from_int_cst
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We make a copy of ARG1 so that we don't modify an 		 existing constant tree.  */
name|t
operator|=
name|copy_node
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Convert expression ARG to type TYPE.  Used by the middle-end for    simple conversions in preference to calling the front-end's convert.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_convert
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|orig
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|orig
condition|)
return|return
name|arg
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|orig
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tem
operator|=
name|fold_convert_const
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|orig
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|orig
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tem
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tem
operator|=
name|fold_convert_const
argument_list|(
name|FLOAT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|tem
operator|=
name|fold_convert_const
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|orig
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|orig
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|FLOAT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|flag_float_store
condition|?
name|CONVERT_EXPR
else|:
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tem
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|orig
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|orig
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|rpart
decl_stmt|,
name|ipart
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
block|{
name|rpart
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|rpart
argument_list|,
name|ipart
argument_list|)
argument_list|)
return|;
block|}
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|rpart
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|rpart
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|rpart
argument_list|)
expr_stmt|;
name|ipart
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ipart
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|rpart
argument_list|,
name|ipart
argument_list|)
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
if|if
condition|(
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|orig
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|orig
argument_list|)
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an expr equal to X but certainly not valid as an lvalue.  */
end_comment

begin_function
name|tree
name|non_lvalue
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
comment|/* These things are certainly not lvalues.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|x
return|;
name|result
operator|=
name|build1
argument_list|(
name|NON_LVALUE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Nonzero means lvalues are limited to those valid in pedantic ANSI C.    Zero means allow extended lvalues.  */
end_comment

begin_decl_stmt
name|int
name|pedantic_lvalues
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When pedantic, return an expr equal to X but certainly not valid as a    pedantic lvalue.  Otherwise, return X.  */
end_comment

begin_function
name|tree
name|pedantic_non_lvalue
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
if|if
condition|(
name|pedantic_lvalues
condition|)
return|return
name|non_lvalue
argument_list|(
name|x
argument_list|)
return|;
else|else
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a tree comparison code, return the code that is the logical inverse    of the given code.  It is not safe to do this for floating-point    comparisons, except for NE_EXPR and EQ_EXPR.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|invert_tree_comparison
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
return|return
name|NE_EXPR
return|;
case|case
name|NE_EXPR
case|:
return|return
name|EQ_EXPR
return|;
case|case
name|GT_EXPR
case|:
return|return
name|LE_EXPR
return|;
case|case
name|GE_EXPR
case|:
return|return
name|LT_EXPR
return|;
case|case
name|LT_EXPR
case|:
return|return
name|GE_EXPR
return|;
case|case
name|LE_EXPR
case|:
return|return
name|GT_EXPR
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar, but return the comparison that results if the operands are    swapped.  This is safe for floating-point.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|swap_tree_comparison
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
return|return
name|code
return|;
case|case
name|GT_EXPR
case|:
return|return
name|LT_EXPR
return|;
case|case
name|GE_EXPR
case|:
return|return
name|LE_EXPR
return|;
case|case
name|LT_EXPR
case|:
return|return
name|GT_EXPR
return|;
case|case
name|LE_EXPR
case|:
return|return
name|GE_EXPR
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a comparison tree code from an enum tree_code representation    into a compcode bit-based encoding.  This function is the inverse of    compcode_to_comparison.  */
end_comment

begin_function
specifier|static
name|int
name|comparison_to_compcode
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
return|return
name|COMPCODE_LT
return|;
case|case
name|EQ_EXPR
case|:
return|return
name|COMPCODE_EQ
return|;
case|case
name|LE_EXPR
case|:
return|return
name|COMPCODE_LE
return|;
case|case
name|GT_EXPR
case|:
return|return
name|COMPCODE_GT
return|;
case|case
name|NE_EXPR
case|:
return|return
name|COMPCODE_NE
return|;
case|case
name|GE_EXPR
case|:
return|return
name|COMPCODE_GE
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a compcode bit-based encoding of a comparison operator back    to GCC's enum tree_code representation.  This function is the    inverse of comparison_to_compcode.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|compcode_to_comparison
parameter_list|(
name|int
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COMPCODE_LT
case|:
return|return
name|LT_EXPR
return|;
case|case
name|COMPCODE_EQ
case|:
return|return
name|EQ_EXPR
return|;
case|case
name|COMPCODE_LE
case|:
return|return
name|LE_EXPR
return|;
case|case
name|COMPCODE_GT
case|:
return|return
name|GT_EXPR
return|;
case|case
name|COMPCODE_NE
case|:
return|return
name|NE_EXPR
return|;
case|case
name|COMPCODE_GE
case|:
return|return
name|GE_EXPR
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if CODE is a tree code that represents a truth value.  */
end_comment

begin_function
specifier|static
name|int
name|truth_value_p
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_XOR_EXPR
operator|||
name|code
operator|==
name|TRUTH_NOT_EXPR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if two operands (typically of the same tree node)    are necessarily equal.  If either argument has side-effects this    function returns zero.     If ONLY_CONST is nonzero, only return nonzero for constants.    This function tests whether the operands are indistinguishable;    it does not test whether they are equal using C's == operation.    The distinction is important for IEEE floating point, because    (1) -0.0 and 0.0 are distinguishable, but -0.0==0.0, and    (2) two NaNs may be indistinguishable, but NaN!=NaN.     If ONLY_CONST is zero, a VAR_DECL is considered equal to itself    even though it may hold multiple values during a function.    This is because a GCC tree node guarantees that nothing else is    executed between the evaluation of its "operands" (which may often    be evaluated in arbitrary order).  Hence if the operands themselves    don't side-effect, the VAR_DECLs, PARM_DECLs etc... must hold the    same value in each operand/subexpression.  Hence a zero value for    ONLY_CONST assumes isochronic (or instantaneous) tree equivalence.    If comparing arbitrary expression trees, such as from different    statements, ONLY_CONST must usually be nonzero.  */
end_comment

begin_function
name|int
name|operand_equal_p
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|int
name|only_const
parameter_list|)
block|{
name|tree
name|fndecl
decl_stmt|;
comment|/* If both types don't have the same signedness, then we can't consider      them equal.  We must check this before the STRIP_NOPS calls      because they may change the signedness of the arguments.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
comment|/* This is needed for conversions and for COMPONENT_REF. 	 Might as well play it safe and always test this.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If ARG0 and ARG1 are the same SAVE_EXPR, they are necessarily equal.      We don't care about side effects in that case because the SAVE_EXPR      takes care of that for us. In all other cases, two expressions are      equal if they have no side effects.  If we have two identical      expressions with side effects that should be treated the same due      to the only side effects being identical SAVE_EXPR's, that will      be detected in the recursive calls below.  */
if|if
condition|(
name|arg0
operator|==
name|arg1
operator|&&
operator|!
name|only_const
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|SAVE_EXPR
operator|||
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Next handle constant cases, those for which we can return 1 even      if ONLY_CONST is set.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
operator|(
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
return|;
case|case
name|REAL_CST
case|:
return|return
operator|(
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|REAL_VALUES_IDENTICAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|VECTOR_CST
case|:
block|{
name|tree
name|v1
decl_stmt|,
name|v2
decl_stmt|;
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|0
return|;
name|v1
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|v2
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
while|while
condition|(
name|v1
operator|&&
name|v2
condition|)
block|{
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|only_const
argument_list|)
condition|)
return|return
literal|0
return|;
name|v1
operator|=
name|TREE_CHAIN
argument_list|(
name|v1
argument_list|)
expr_stmt|;
name|v2
operator|=
name|TREE_CHAIN
argument_list|(
name|v2
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
case|case
name|COMPLEX_CST
case|:
return|return
operator|(
name|operand_equal_p
argument_list|(
name|TREE_REALPART
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REALPART
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|only_const
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_IMAGPART
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|only_const
argument_list|)
operator|)
return|;
case|case
name|STRING_CST
case|:
return|return
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|only_const
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* Two conversions are equal only if signedness and modes match.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|'<'
case|:
case|case
literal|'2'
case|:
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* For commutative ops, allow the other order.  */
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MIN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MAX_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|EQ_EXPR
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
literal|'r'
case|:
comment|/* If either of the pointer (or reference) expressions we are 	 dereferencing contain a side effect, these cannot be equal.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
return|return
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
return|return
operator|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|BIT_FIELD_REF
case|:
return|return
operator|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
case|case
literal|'e'
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
return|return
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|RTL_EXPR
case|:
return|return
name|rtx_equal_p
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|RTL_EXPR_RTL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
comment|/* If the CALL_EXPRs call different functions, then they 	     clearly can not be equal.  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Only consider const functions equivalent.  */
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
operator|||
operator|!
operator|(
name|flags_from_decl_or_type
argument_list|(
name|fndecl
argument_list|)
operator|&
name|ECF_CONST
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Now see if all the arguments are the same.  operand_equal_p 	     does not handle TREE_LIST, so we walk the operands here 	     feeding them to operand_equal_p.  */
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|arg0
operator|&&
name|arg1
condition|)
block|{
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|arg0
operator|=
name|TREE_CHAIN
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_CHAIN
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
comment|/* If we get here and both argument lists are exhausted 	     then the CALL_EXPRs are equal.  */
return|return
operator|!
operator|(
name|arg0
operator|||
name|arg1
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
case|case
literal|'d'
case|:
comment|/* Consider __builtin_sqrt equal to sqrt.  */
return|return
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|arg0
argument_list|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|arg1
argument_list|)
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|arg0
argument_list|)
operator|==
name|DECL_BUILT_IN_CLASS
argument_list|(
name|arg1
argument_list|)
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|DECL_FUNCTION_CODE
argument_list|(
name|arg1
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similar to operand_equal_p, but see if ARG0 might have been made by    shorten_compare from ARG1 when ARG1 was being compared with OTHER.     When in doubt, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|operand_equal_for_comparison_p
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|other
parameter_list|)
block|{
name|int
name|unsignedp1
decl_stmt|,
name|unsignedpo
decl_stmt|;
name|tree
name|primarg0
decl_stmt|,
name|primarg1
decl_stmt|,
name|primother
decl_stmt|;
name|unsigned
name|int
name|correct_width
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Discard any conversions that don't change the modes of ARG0 and ARG1      and see if the inner values are the same.  This removes any      signedness comparison, which doesn't matter here.  */
name|primarg0
operator|=
name|arg0
operator|,
name|primarg1
operator|=
name|arg1
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|primarg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|primarg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|primarg0
argument_list|,
name|primarg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Duplicate what shorten_compare does to ARG1 and see if that gives the      actual comparison operand, ARG0.       First throw away any conversions to wider types      already present in the operands.  */
name|primarg1
operator|=
name|get_narrower
argument_list|(
name|arg1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
name|primother
operator|=
name|get_narrower
argument_list|(
name|other
argument_list|,
operator|&
name|unsignedpo
argument_list|)
expr_stmt|;
name|correct_width
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp1
operator|==
name|unsignedpo
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primarg1
argument_list|)
argument_list|)
operator|<
name|correct_width
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primother
argument_list|)
argument_list|)
operator|<
name|correct_width
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primarg1
operator|=
name|fold_convert
argument_list|(
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|signed_or_unsigned_type
call|)
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primarg1
argument_list|)
argument_list|)
argument_list|,
name|primarg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|primarg1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if ARG is an expression that is either a comparison or is performing    arithmetic on comparisons.  The comparisons must only be comparing    two different values, which will be stored in *CVAL1 and *CVAL2; if    they are nonzero it means that some operands have already been found.    No variables may be used anywhere else in the expression except in the    comparisons.  If SAVE_P is true it means we removed a SAVE_EXPR around    the expression and save_expr needs to be called with CVAL1 and CVAL2.     If this is true, return 1.  Otherwise, return zero.  */
end_comment

begin_function
specifier|static
name|int
name|twoval_comparison_p
parameter_list|(
name|tree
name|arg
parameter_list|,
name|tree
modifier|*
name|cval1
parameter_list|,
name|tree
modifier|*
name|cval2
parameter_list|,
name|int
modifier|*
name|save_p
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|char
name|class
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* We can handle some of the 'e' cases here.  */
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
name|code
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|class
operator|=
literal|'1'
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|COMPOUND_EXPR
operator|)
condition|)
name|class
operator|=
literal|'2'
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
name|code
operator|==
name|SAVE_EXPR
operator|&&
name|SAVE_EXPR_RTL
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If we've already found a CVAL1 or CVAL2, this expression is 	 two complex to handle.  */
if|if
condition|(
operator|*
name|cval1
operator|||
operator|*
name|cval2
condition|)
return|return
literal|0
return|;
name|class
operator|=
literal|'1'
expr_stmt|;
operator|*
name|save_p
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|'1'
case|:
return|return
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
return|;
case|case
literal|'2'
case|:
return|return
operator|(
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|)
return|;
case|case
literal|'c'
case|:
return|return
literal|1
return|;
case|case
literal|'e'
case|:
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
return|return
operator|(
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|,
name|save_p
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
case|case
literal|'<'
case|:
comment|/* First see if we can handle the first operand, then the second.  For 	 the second operand, we know *CVAL1 can't be zero.  It must be that 	 one side of the comparison is each of the values; test for the 	 case where this isn't true by failing if the two operands 	 are the same.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|cval1
operator|==
literal|0
condition|)
operator|*
name|cval1
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cval2
operator|==
literal|0
condition|)
operator|*
name|cval2
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cval2
operator|==
literal|0
condition|)
operator|*
name|cval2
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ARG is a tree that is known to contain just arithmetic operations and    comparisons.  Evaluate the operations in the tree substituting NEW0 for    any occurrence of OLD0 as an operand of a comparison and likewise for    NEW1 and OLD1.  */
end_comment

begin_function
specifier|static
name|tree
name|eval_subst
parameter_list|(
name|tree
name|arg
parameter_list|,
name|tree
name|old0
parameter_list|,
name|tree
name|new0
parameter_list|,
name|tree
name|old1
parameter_list|,
name|tree
name|new1
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|char
name|class
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* We can handle some of the 'e' cases here.  */
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
name|code
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|class
operator|=
literal|'1'
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
condition|)
name|class
operator|=
literal|'2'
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|'1'
case|:
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
literal|'2'
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
literal|'e'
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SAVE_EXPR
case|:
return|return
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* Fall through - ???  */
case|case
literal|'<'
case|:
block|{
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* We need to check both for exact equality and tree equality.  The 	   former will be true if the operand has a side-effect.  In that 	   case, we know the operand occurred exactly once.  */
if|if
condition|(
name|arg0
operator|==
name|old0
operator|||
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|old0
argument_list|,
literal|0
argument_list|)
condition|)
name|arg0
operator|=
name|new0
expr_stmt|;
elseif|else
if|if
condition|(
name|arg0
operator|==
name|old1
operator|||
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|old1
argument_list|,
literal|0
argument_list|)
condition|)
name|arg0
operator|=
name|new1
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|old0
operator|||
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|old0
argument_list|,
literal|0
argument_list|)
condition|)
name|arg1
operator|=
name|new0
expr_stmt|;
elseif|else
if|if
condition|(
name|arg1
operator|==
name|old1
operator|||
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|old1
argument_list|,
literal|0
argument_list|)
condition|)
name|arg1
operator|=
name|new1
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
default|default:
return|return
name|arg
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the case when the result of an expression is RESULT    converted to TYPE and OMITTED was previously an operand of the expression    but is now not needed (e.g., we folded OMITTED * 0).     If OMITTED has side effects, we must evaluate it.  Otherwise, just do    the conversion of RESULT to TYPE.  */
end_comment

begin_function
name|tree
name|omit_one_operand
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|result
parameter_list|,
name|tree
name|omitted
parameter_list|)
block|{
name|tree
name|t
init|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|omitted
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|omitted
argument_list|,
name|t
argument_list|)
return|;
return|return
name|non_lvalue
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but call pedantic_non_lvalue instead of non_lvalue.  */
end_comment

begin_function
specifier|static
name|tree
name|pedantic_omit_one_operand
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|result
parameter_list|,
name|tree
name|omitted
parameter_list|)
block|{
name|tree
name|t
init|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|omitted
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|omitted
argument_list|,
name|t
argument_list|)
return|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a simplified tree node for the truth-negation of ARG.  This    never alters ARG itself.  We assume that ARG is an operation that    returns a truth value (0 or 1).  */
end_comment

begin_function
name|tree
name|invert_truthvalue
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|arg
return|;
comment|/* If this is a comparison, we can simply invert it, except for      floating-point non-equality comparisons, in which case we just      enclose a TRUTH_NOT_EXPR around what we have.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|flag_unsafe_math_optimizations
operator|&&
name|code
operator|!=
name|NE_EXPR
operator|&&
name|code
operator|!=
name|EQ_EXPR
condition|)
return|return
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
else|else
return|return
name|build
argument_list|(
name|invert_tree_comparison
argument_list|(
name|code
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|build_int_2
argument_list|(
name|integer_zerop
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_AND_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_OR_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_OR_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_XOR_EXPR
case|:
comment|/* Here we can invert either operand.  We invert the first operand 	 unless the second operand is a TRUTH_NOT_EXPR in which case our 	 result is the XOR of the first operand with the inside of the 	 negation of the second operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
return|return
name|build
argument_list|(
name|TRUTH_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|build
argument_list|(
name|TRUTH_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|WITH_RECORD_EXPR
case|:
return|return
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
operator|!
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
break|break;
return|return
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
return|return
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|CLEANUP_POINT_EXPR
case|:
return|return
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a bit-wise operation CODE applied to ARG0 and ARG1, see if both    operands are another bit-wise operation with a common input.  If so,    distribute the bit operations to save an operation and possibly two if    constants are involved.  For example, convert 	(A | B)& (A | C) into A | (B& C)    Further simplification will occur if B and C are constants.     If this optimization cannot be done, 0 will be returned.  */
end_comment

begin_function
specifier|static
name|tree
name|distribute_bit_expr
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|tree
name|common
decl_stmt|;
name|tree
name|left
decl_stmt|,
name|right
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|code
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|BIT_IOR_EXPR
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|common
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a BIT_FIELD_REF of type TYPE to refer to BITSIZE bits of INNER    starting at BITPOS.  The field is unsigned if UNSIGNEDP is nonzero.  */
end_comment

begin_function
specifier|static
name|tree
name|make_bit_field_ref
parameter_list|(
name|tree
name|inner
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|bitsize
parameter_list|,
name|int
name|bitpos
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|tree
name|result
init|=
name|build
argument_list|(
name|BIT_FIELD_REF
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|size_int
argument_list|(
name|bitsize
argument_list|)
argument_list|,
name|bitsize_int
argument_list|(
name|bitpos
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|result
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Optimize a bit-field compare.     There are two cases:  First is a compare against a constant and the    second is a comparison of two items where the fields are at the same    bit position relative to the start of a chunk (byte, halfword, word)    large enough to contain it.  In these cases we can avoid the shift    implicit in bitfield extractions.     For constants, we emit a compare of the shifted constant with the    BIT_AND_EXPR of a mask and a byte, halfword, or word of the operand being    compared.  For two fields at the same position, we do the ANDs with the    similar mask and compare the result of the ANDs.     CODE is the comparison code, known to be either NE_EXPR or EQ_EXPR.    COMPARE_TYPE is the type of the comparison, and LHS and RHS    are the left and right operands of the comparison, respectively.     If the optimization described above can be done, we return the resulting    tree.  Otherwise we return zero.  */
end_comment

begin_function
specifier|static
name|tree
name|optimize_bit_field_compare
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|compare_type
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|HOST_WIDE_INT
name|lbitpos
decl_stmt|,
name|lbitsize
decl_stmt|,
name|rbitpos
decl_stmt|,
name|rbitsize
decl_stmt|,
name|nbitpos
decl_stmt|,
name|nbitsize
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|signed_type
decl_stmt|,
name|unsigned_type
decl_stmt|;
name|int
name|const_p
init|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
decl_stmt|;
name|enum
name|machine_mode
name|lmode
decl_stmt|,
name|rmode
decl_stmt|,
name|nmode
decl_stmt|;
name|int
name|lunsignedp
decl_stmt|,
name|runsignedp
decl_stmt|;
name|int
name|lvolatilep
init|=
literal|0
decl_stmt|,
name|rvolatilep
init|=
literal|0
decl_stmt|;
name|tree
name|linner
decl_stmt|,
name|rinner
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|mask
decl_stmt|;
name|tree
name|offset
decl_stmt|;
comment|/* Get all the information about the extractions being done.  If the bit size      if the same as the size of the underlying object, we aren't doing an      extraction at all and so can do nothing.  We also don't want to      do anything if the inner expression is a PLACEHOLDER_EXPR since we      then will no longer be able to replace it.  */
name|linner
operator|=
name|get_inner_reference
argument_list|(
name|lhs
argument_list|,
operator|&
name|lbitsize
argument_list|,
operator|&
name|lbitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|lmode
argument_list|,
operator|&
name|lunsignedp
argument_list|,
operator|&
name|lvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|linner
operator|==
name|lhs
operator|||
name|lbitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|lmode
argument_list|)
operator|||
name|lbitsize
operator|<
literal|0
operator|||
name|offset
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|linner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|const_p
condition|)
block|{
comment|/* If this is not a constant, we can only do something if bit positions, 	sizes, and signedness are the same.  */
name|rinner
operator|=
name|get_inner_reference
argument_list|(
name|rhs
argument_list|,
operator|&
name|rbitsize
argument_list|,
operator|&
name|rbitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|rmode
argument_list|,
operator|&
name|runsignedp
argument_list|,
operator|&
name|rvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|rinner
operator|==
name|rhs
operator|||
name|lbitpos
operator|!=
name|rbitpos
operator|||
name|lbitsize
operator|!=
name|rbitsize
operator|||
name|lunsignedp
operator|!=
name|runsignedp
operator|||
name|offset
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|rinner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
literal|0
return|;
block|}
comment|/* See if we can find a mode to refer to this field.  We should be able to,      but fail if we can't.  */
name|nmode
operator|=
name|get_best_mode
argument_list|(
name|lbitsize
argument_list|,
name|lbitpos
argument_list|,
name|const_p
condition|?
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|linner
argument_list|)
argument_list|)
else|:
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|linner
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|rinner
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|lvolatilep
operator|||
name|rvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
comment|/* Set signed and unsigned types of the precision of this mode for the      shifts below.  */
name|signed_type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|nmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unsigned_type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|nmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the bit position and size for the new reference and our offset      within it. If the new reference is the same size as the original, we      won't optimize anything, so return zero.  */
name|nbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|nmode
argument_list|)
expr_stmt|;
name|nbitpos
operator|=
name|lbitpos
operator|&
operator|~
operator|(
name|nbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|lbitpos
operator|-=
name|nbitpos
expr_stmt|;
if|if
condition|(
name|nbitsize
operator|==
name|lbitsize
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|lbitpos
operator|=
name|nbitsize
operator|-
name|lbitsize
operator|-
name|lbitpos
expr_stmt|;
comment|/* Make the mask to be used against the extracted field.  */
name|mask
operator|=
name|build_int_2
argument_list|(
operator|~
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|mask
argument_list|)
operator|=
name|unsigned_type
expr_stmt|;
name|force_fit_type
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|nbitsize
operator|-
name|lbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|nbitsize
operator|-
name|lbitsize
operator|-
name|lbitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|const_p
condition|)
comment|/* If not comparing with constant, just rework the comparison        and return.  */
return|return
name|build
argument_list|(
name|code
argument_list|,
name|compare_type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|make_bit_field_ref
argument_list|(
name|linner
argument_list|,
name|unsigned_type
argument_list|,
name|nbitsize
argument_list|,
name|nbitpos
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|make_bit_field_ref
argument_list|(
name|rinner
argument_list|,
name|unsigned_type
argument_list|,
name|nbitsize
argument_list|,
name|nbitpos
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
return|;
comment|/* Otherwise, we are handling the constant case. See if the constant is too      big for the field.  Warn and return a tree of for 0 (false) if so.  We do      this not only for its own sake, but to avoid having to test for this      error case below.  If we didn't, we might generate wrong code.       For unsigned fields, the constant shifted right by the field length should      be all zero.  For signed fields, the high-order bits should agree with      the sign bit.  */
if|if
condition|(
name|lunsignedp
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison is always %d due to width of bit-field"
argument_list|,
name|code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|compare_type
argument_list|,
operator|(
name|code
operator|==
name|NE_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
operator|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|tree
name|tem
init|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|signed_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitsize
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison is always %d due to width of bit-field"
argument_list|,
name|code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|compare_type
argument_list|,
operator|(
name|code
operator|==
name|NE_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
operator|)
argument_list|)
return|;
block|}
block|}
comment|/* Single-bit compares should always be against zero.  */
if|if
condition|(
name|lbitsize
operator|==
literal|1
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|code
operator|=
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
expr_stmt|;
name|rhs
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
comment|/* Make a new bitfield reference, shift the constant over the      appropriate number of bits and mask it with the computed mask      (in case this was a signed field).  If we changed it, make a new one.  */
name|lhs
operator|=
name|make_bit_field_ref
argument_list|(
name|linner
argument_list|,
name|unsigned_type
argument_list|,
name|nbitsize
argument_list|,
name|nbitpos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvolatilep
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|lhs
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|rhs
operator|=
name|fold
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|code
argument_list|,
name|compare_type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|lhs
argument_list|,
name|mask
argument_list|)
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine for fold_truthop: decode a field reference.     If EXP is a comparison reference, we return the innermost reference.     *PBITSIZE is set to the number of bits in the reference, *PBITPOS is    set to the starting bit number.     If the innermost field can be completely contained in a mode-sized    unit, *PMODE is set to that mode.  Otherwise, it is set to VOIDmode.     *PVOLATILEP is set to 1 if the any expression encountered is volatile;    otherwise it is not changed.     *PUNSIGNEDP is set to the signedness of the field.     *PMASK is set to the mask used.  This is either contained in a    BIT_AND_EXPR or derived from the width of the field.     *PAND_MASK is set to the mask found in a BIT_AND_EXPR, if any.     Return 0 if this is not a component reference or is one that we can't    do anything with.  */
end_comment

begin_function
specifier|static
name|tree
name|decode_field_reference
parameter_list|(
name|tree
name|exp
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|pbitsize
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|pbitpos
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|pmode
parameter_list|,
name|int
modifier|*
name|punsignedp
parameter_list|,
name|int
modifier|*
name|pvolatilep
parameter_list|,
name|tree
modifier|*
name|pmask
parameter_list|,
name|tree
modifier|*
name|pand_mask
parameter_list|)
block|{
name|tree
name|outer_type
init|=
literal|0
decl_stmt|;
name|tree
name|and_mask
init|=
literal|0
decl_stmt|;
name|tree
name|mask
decl_stmt|,
name|inner
decl_stmt|,
name|offset
decl_stmt|;
name|tree
name|unsigned_type
decl_stmt|;
name|unsigned
name|int
name|precision
decl_stmt|;
comment|/* All the optimizations using this function assume integer fields.      There are problems with FP fields since the type_for_size call      below can fail for, e.g., XFmode.  */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We are interested in the bare arrangement of bits, so strip everything      that doesn't affect the machine mode.  However, record the type of the      outermost expression if it may matter below.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|outer_type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|)
block|{
name|and_mask
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|and_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|and_mask
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
block|}
name|inner
operator|=
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
name|pbitsize
argument_list|,
name|pbitpos
argument_list|,
operator|&
name|offset
argument_list|,
name|pmode
argument_list|,
name|punsignedp
argument_list|,
name|pvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inner
operator|==
name|exp
operator|&&
name|and_mask
operator|==
literal|0
operator|)
operator|||
operator|*
name|pbitsize
operator|<
literal|0
operator|||
name|offset
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
return|return
literal|0
return|;
comment|/* If the number of bits in the reference is the same as the bitsize of      the outer type, then the outer type gives the signedness. Otherwise      (in case of a small bitfield) the signedness is unchanged.  */
if|if
condition|(
name|outer_type
operator|&&
operator|*
name|pbitsize
operator|==
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|outer_type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
operator|*
name|punsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|outer_type
argument_list|)
expr_stmt|;
comment|/* Compute the mask to access the bitfield.  */
name|unsigned_type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
call|)
argument_list|(
operator|*
name|pbitsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type
argument_list|)
expr_stmt|;
name|mask
operator|=
name|build_int_2
argument_list|(
operator|~
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|mask
argument_list|)
operator|=
name|unsigned_type
expr_stmt|;
name|force_fit_type
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
operator|*
name|pbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
operator|*
name|pbitsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Merge it with the mask we found in the BIT_AND_EXPR, if any.  */
if|if
condition|(
name|and_mask
operator|!=
literal|0
condition|)
name|mask
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|fold_convert
argument_list|(
name|unsigned_type
argument_list|,
name|and_mask
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pmask
operator|=
name|mask
expr_stmt|;
operator|*
name|pand_mask
operator|=
name|and_mask
expr_stmt|;
return|return
name|inner
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if MASK represents a mask of SIZE ones in the low-order    bit positions.  */
end_comment

begin_function
specifier|static
name|int
name|all_ones_mask_p
parameter_list|(
name|tree
name|mask
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|mask
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|tmask
decl_stmt|;
name|tmask
operator|=
name|build_int_2
argument_list|(
operator|~
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmask
argument_list|)
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
call|)
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|force_fit_type
argument_list|(
name|tmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|tree_int_cst_equal
argument_list|(
name|mask
argument_list|,
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tmask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
name|size
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
name|size
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine for fold: determine if VAL is the INTEGER_CONST that    represents the sign bit of EXP's type.  If EXP represents a sign    or zero extension, also test VAL against the unextended type.    The return value is the (sub)expression whose sign bit is VAL,    or NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|sign_bit_p
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask_lo
decl_stmt|,
name|lo
decl_stmt|;
name|HOST_WIDE_INT
name|mask_hi
decl_stmt|,
name|hi
decl_stmt|;
name|int
name|width
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Tree EXP must have an integral type.  */
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Tree VAL must be an integer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|width
operator|=
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|mask_hi
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|-
name|width
operator|)
operator|)
expr_stmt|;
name|mask_lo
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
expr_stmt|;
name|mask_hi
operator|=
literal|0
expr_stmt|;
name|mask_lo
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|width
operator|)
operator|)
expr_stmt|;
block|}
comment|/* We mask off those bits beyond TREE_TYPE (exp) so that we can      treat VAL as if it were unsigned.  */
if|if
condition|(
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
operator|&
name|mask_hi
operator|)
operator|==
name|hi
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
operator|&
name|mask_lo
operator|)
operator|==
name|lo
condition|)
return|return
name|exp
return|;
comment|/* Handle extension from a narrower type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|width
condition|)
return|return
name|sign_bit_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine for fold_truthop: determine if an operand is simple enough    to be evaluated unconditionally.  */
end_comment

begin_function
specifier|static
name|int
name|simple_operand_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
comment|/* Strip any conversions that don't change the machine mode.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
operator|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|DECL_NONLOCAL
argument_list|(
name|exp
argument_list|)
comment|/* Don't regard global variables as simple.  They may be 		 allocated in ways unknown to the compiler (shared memory, 		 #pragma weak, etc).  */
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|exp
argument_list|)
comment|/* Loading a static variable is unduly expensive, but global 		 registers aren't expensive.  */
operator|&&
operator|(
operator|!
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|||
name|DECL_REGISTER
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following functions are subroutines to fold_range_test and allow it to    try to change a logical combination of comparisons into a range test.     For example, both 	X == 2 || X == 3 || X == 4 || X == 5    and 	X>= 2&& X<= 5    are converted to 	(unsigned) (X - 2)<= 3     We describe each set of comparisons as being either inside or outside    a range, using a variable named like IN_P, and then describe the    range with a lower and upper bound.  If one of the bounds is omitted,    it represents either the highest or lowest value of the type.     In the comments below, we represent a range by two numbers in brackets    preceded by a "+" to designate being inside that range, or a "-" to    designate being outside that range, so the condition can be inverted by    flipping the prefix.  An omitted bound is represented by a "-".  For    example, "- [-, 10]" means being outside the range starting at the lowest    possible value and ending at 10, in other words, being greater than 10.    The range "+ [-, -]" is always true and hence the range "- [-, -]" is    always false.     We set up things so that the missing bounds are handled in a consistent    manner so neither a missing bound nor "true" and "false" need to be    handled using a special case.  */
end_comment

begin_comment
comment|/* Return the result of applying CODE to ARG0 and ARG1, but handle the case    of ARG0 and/or ARG1 being omitted, meaning an unlimited range. UPPER0_P    and UPPER1_P are nonzero if the respective argument is an upper bound    and zero for a lower.  TYPE, if nonzero, is the type of the result; it    must be specified for a comparison.  ARG1 will be converted to ARG0's    type if both are specified.  */
end_comment

begin_function
specifier|static
name|tree
name|range_binop
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|int
name|upper0_p
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|int
name|upper1_p
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|sgn0
decl_stmt|,
name|sgn1
decl_stmt|;
comment|/* If neither arg represents infinity, do the normal operation.      Else, if not a comparison, return infinity.  Else handle the special      comparison rules. Note that most of the cases below won't occur, but      are handled for consistency.  */
if|if
condition|(
name|arg0
operator|!=
literal|0
operator|&&
name|arg1
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
operator|!=
literal|0
condition|?
name|type
else|:
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INTEGER_CST
condition|?
name|tem
else|:
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
comment|/* Set SGN[01] to -1 if ARG[01] is a lower bound, 1 for upper, and 0      for neither.  In real maths, we cannot assume open ended ranges are      the same. But, this is computer arithmetic, where numbers are finite.      We can therefore make the transformation of any unbounded range with      the value Z, Z being greater than any representable number. This permits      us to treat unbounded ranges as equal.  */
name|sgn0
operator|=
name|arg0
operator|!=
literal|0
condition|?
literal|0
else|:
operator|(
name|upper0_p
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
expr_stmt|;
name|sgn1
operator|=
name|arg1
operator|!=
literal|0
condition|?
literal|0
else|:
operator|(
name|upper1_p
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
name|result
operator|=
name|sgn0
operator|==
name|sgn1
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|result
operator|=
name|sgn0
operator|!=
name|sgn1
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|result
operator|=
name|sgn0
operator|<
name|sgn1
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|result
operator|=
name|sgn0
operator|<=
name|sgn1
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|result
operator|=
name|sgn0
operator|>
name|sgn1
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|result
operator|=
name|sgn0
operator|>=
name|sgn1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|result
condition|?
name|integer_one_node
else|:
name|integer_zero_node
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given EXP, a logical expression, set the range it is testing into    variables denoted by PIN_P, PLOW, and PHIGH.  Return the expression    actually being tested.  *PLOW and *PHIGH will be made of the same type    as the returned expression.  If EXP is not a comparison, we will most    likely not be returning a useful value and range.  */
end_comment

begin_function
specifier|static
name|tree
name|make_range
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
modifier|*
name|pin_p
parameter_list|,
name|tree
modifier|*
name|plow
parameter_list|,
name|tree
modifier|*
name|phigh
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg0
init|=
name|NULL_TREE
decl_stmt|,
name|arg1
init|=
name|NULL_TREE
decl_stmt|,
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|orig_type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|in_p
decl_stmt|,
name|n_in_p
decl_stmt|;
name|tree
name|low
decl_stmt|,
name|high
decl_stmt|,
name|n_low
decl_stmt|,
name|n_high
decl_stmt|;
comment|/* Start with simply saying "EXP != 0" and then look at the code of EXP      and see if we can refine the range.  Some of the cases below may not      happen, but it doesn't seem worth worrying about this.  We "continue"      the outer loop when we've changed something; otherwise we "break"      the switch, which will "break" the while.  */
name|in_p
operator|=
literal|0
expr_stmt|;
name|low
operator|=
name|high
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|code
operator|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|first_rtl_op
argument_list|(
name|code
argument_list|)
operator|>
literal|0
condition|)
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'e'
operator|&&
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
operator|>
literal|1
operator|)
condition|)
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Set ORIG_TYPE as soon as TYPE is non-null so that we do not 	 lose a cast by accident.  */
if|if
condition|(
name|type
operator|!=
name|NULL_TREE
operator|&&
name|orig_type
operator|==
name|NULL_TREE
condition|)
name|orig_type
operator|=
name|type
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUTH_NOT_EXPR
case|:
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|exp
operator|=
name|arg0
expr_stmt|;
continue|continue;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
comment|/* We can only do something if the range is testing for zero 	     and if the second operand is an integer constant.  Note that 	     saying something is "in" the range we make is done by 	     complementing IN_P since it will set in the initial case of 	     being not equal to zero; "out" is leaving it alone.  */
if|if
condition|(
name|low
operator|==
literal|0
operator|||
name|high
operator|==
literal|0
operator|||
operator|!
name|integer_zerop
argument_list|(
name|low
argument_list|)
operator|||
operator|!
name|integer_zerop
argument_list|(
name|high
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE_EXPR
case|:
comment|/* - [c, c]  */
name|low
operator|=
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
comment|/* + [c, c]  */
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|low
operator|=
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
comment|/* - [-, c] */
name|low
operator|=
literal|0
operator|,
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
comment|/* + [c, -] */
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|low
operator|=
name|arg1
operator|,
name|high
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
comment|/* - [c, -] */
name|low
operator|=
name|arg1
operator|,
name|high
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
comment|/* + [-, c] */
name|in_p
operator|=
operator|!
name|in_p
operator|,
name|low
operator|=
literal|0
operator|,
name|high
operator|=
name|arg1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|exp
operator|=
name|arg0
expr_stmt|;
comment|/* If this is an unsigned comparison, we also know that EXP is 	     greater than or equal to zero.  We base the range tests we make 	     on that fact, so we record it here so we can parse existing 	     range tests.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|low
operator|==
literal|0
operator|||
name|high
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|merge_ranges
argument_list|(
operator|&
name|n_in_p
argument_list|,
operator|&
name|n_low
argument_list|,
operator|&
name|n_high
argument_list|,
name|in_p
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
literal|1
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
break|break;
name|in_p
operator|=
name|n_in_p
operator|,
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
comment|/* If the high bound is missing, but we have a nonzero low 		 bound, reverse the range so it goes from zero to the low bound 		 minus 1.  */
if|if
condition|(
name|high
operator|==
literal|0
operator|&&
name|low
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|in_p
operator|=
operator|!
name|in_p
expr_stmt|;
name|high
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|low
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|low
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
case|case
name|NEGATE_EXPR
case|:
comment|/* (-x) IN [a,b] -> x in [-b, -a]  */
name|n_low
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|high
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n_high
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|low
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
name|exp
operator|=
name|arg0
expr_stmt|;
continue|continue;
case|case
name|BIT_NOT_EXPR
case|:
comment|/* ~ X -> -X - 1  */
name|exp
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
comment|/* If EXP is signed, any overflow in the computation is undefined, 	     so we don't worry about it so long as our computations on 	     the bounds don't overflow.  For unsigned, overflow is defined 	     and this is exactly the right thing.  */
name|n_low
operator|=
name|range_binop
argument_list|(
name|code
operator|==
name|MINUS_EXPR
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|low
argument_list|,
literal|0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n_high
operator|=
name|range_binop
argument_list|(
name|code
operator|==
name|MINUS_EXPR
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|high
argument_list|,
literal|1
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n_low
operator|!=
literal|0
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|n_low
argument_list|)
operator|)
operator|||
operator|(
name|n_high
operator|!=
literal|0
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|n_high
argument_list|)
operator|)
condition|)
break|break;
comment|/* Check for an unsigned range which has wrapped around the maximum 	     value thus making n_high< n_low, and normalize it.  */
if|if
condition|(
name|n_low
operator|&&
name|n_high
operator|&&
name|tree_int_cst_lt
argument_list|(
name|n_high
argument_list|,
name|n_low
argument_list|)
condition|)
block|{
name|low
operator|=
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|n_high
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|high
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|n_low
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the range is of the form +/- [ x+1, x ], we won't 		 be able to normalize it.  But then, it represents the 		 whole range or the empty set, so make it 		 +/- [ -, - ].  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|n_low
argument_list|,
name|low
argument_list|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|n_high
argument_list|,
name|high
argument_list|)
condition|)
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
else|else
name|in_p
operator|=
operator|!
name|in_p
expr_stmt|;
block|}
else|else
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
name|exp
operator|=
name|arg0
expr_stmt|;
continue|continue;
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|orig_type
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|low
operator|!=
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|low
argument_list|,
name|type
argument_list|)
operator|)
operator|||
operator|(
name|high
operator|!=
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|high
argument_list|,
name|type
argument_list|)
operator|)
condition|)
break|break;
name|n_low
operator|=
name|low
operator|,
name|n_high
operator|=
name|high
expr_stmt|;
if|if
condition|(
name|n_low
operator|!=
literal|0
condition|)
name|n_low
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|n_low
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_high
operator|!=
literal|0
condition|)
name|n_high
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|n_high
argument_list|)
expr_stmt|;
comment|/* If we're converting from an unsigned to a signed type, 	     we will be doing the comparison as unsigned.  The tests above 	     have already verified that LOW and HIGH are both positive.  	     So we have to make sure that the original unsigned value will 	     be interpreted as positive.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|equiv_type
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|high_positive
decl_stmt|;
comment|/* A range without an upper bound is, naturally, unbounded. 		 Since convert would have cropped a very large value, use 		 the max value for the destination type.  */
name|high_positive
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|equiv_type
argument_list|)
condition|?
name|TYPE_MAX_VALUE
argument_list|(
name|equiv_type
argument_list|)
else|:
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|high_positive
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|high_positive
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the low bound is specified, "and" the range with the 		 range for which the original unsigned value will be 		 positive.  */
if|if
condition|(
name|low
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|merge_ranges
argument_list|(
operator|&
name|n_in_p
argument_list|,
operator|&
name|n_low
argument_list|,
operator|&
name|n_high
argument_list|,
literal|1
argument_list|,
name|n_low
argument_list|,
name|n_high
argument_list|,
literal|1
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|high_positive
argument_list|)
condition|)
break|break;
name|in_p
operator|=
operator|(
name|n_in_p
operator|==
name|in_p
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, "or" the range with the range of the input 		     that will be interpreted as negative.  */
if|if
condition|(
operator|!
name|merge_ranges
argument_list|(
operator|&
name|n_in_p
argument_list|,
operator|&
name|n_low
argument_list|,
operator|&
name|n_high
argument_list|,
literal|0
argument_list|,
name|n_low
argument_list|,
name|n_high
argument_list|,
literal|1
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|high_positive
argument_list|)
condition|)
break|break;
name|in_p
operator|=
operator|(
name|in_p
operator|!=
name|n_in_p
operator|)
expr_stmt|;
block|}
block|}
name|exp
operator|=
name|arg0
expr_stmt|;
name|low
operator|=
name|n_low
operator|,
name|high
operator|=
name|n_high
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* If EXP is a constant, we can evaluate whether this is true or false.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|in_p
operator|=
name|in_p
operator|==
operator|(
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|low
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|,
name|high
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|pin_p
operator|=
name|in_p
operator|,
operator|*
name|plow
operator|=
name|low
operator|,
operator|*
name|phigh
operator|=
name|high
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a range, LOW, HIGH, and IN_P, an expression, EXP, and a result    type, TYPE, return an expression to test if EXP is in (or out of, depending    on IN_P) the range.  */
end_comment

begin_function
specifier|static
name|tree
name|build_range_check
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|exp
parameter_list|,
name|int
name|in_p
parameter_list|,
name|tree
name|low
parameter_list|,
name|tree
name|high
parameter_list|)
block|{
name|tree
name|etype
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|in_p
operator|&&
operator|(
literal|0
operator|!=
operator|(
name|value
operator|=
name|build_range_check
argument_list|(
name|type
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
operator|)
operator|)
condition|)
return|return
name|invert_truthvalue
argument_list|(
name|value
argument_list|)
return|;
if|if
condition|(
name|low
operator|==
literal|0
operator|&&
name|high
operator|==
literal|0
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
return|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|high
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|high
operator|==
literal|0
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|low
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|low
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|low
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|etype
argument_list|)
condition|)
block|{
name|etype
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
call|)
argument_list|(
name|etype
argument_list|)
expr_stmt|;
name|high
operator|=
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|exp
operator|=
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|build_range_check
argument_list|(
name|type
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|high
argument_list|)
return|;
block|}
comment|/* Optimize (c>=1)&& (c<=127) into (signed char)c> 0.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|low
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|high
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|lo
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|;
name|int
name|prec
decl_stmt|;
comment|/* For enums the comparison will be done in the underlying type, 	 so using enum's precision is wrong here. 	 Consider e.g. enum { A, B, C, D, E }, low == B and high == D.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|etype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|prec
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|etype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prec
operator|=
name|TYPE_PRECISION
argument_list|(
name|etype
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|lo
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|high
argument_list|)
operator|==
name|hi
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|high
argument_list|)
operator|==
name|lo
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|etype
argument_list|)
condition|)
block|{
name|etype
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
call|)
argument_list|(
name|etype
argument_list|)
expr_stmt|;
name|exp
operator|=
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|value
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|high
argument_list|,
name|low
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|build_range_check
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|etype
argument_list|,
name|exp
argument_list|,
name|low
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fold_convert
argument_list|(
name|etype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given two ranges, see if we can merge them into one.  Return 1 if we    can, 0 if we can't.  Set the output range into the specified parameters.  */
end_comment

begin_function
specifier|static
name|int
name|merge_ranges
parameter_list|(
name|int
modifier|*
name|pin_p
parameter_list|,
name|tree
modifier|*
name|plow
parameter_list|,
name|tree
modifier|*
name|phigh
parameter_list|,
name|int
name|in0_p
parameter_list|,
name|tree
name|low0
parameter_list|,
name|tree
name|high0
parameter_list|,
name|int
name|in1_p
parameter_list|,
name|tree
name|low1
parameter_list|,
name|tree
name|high1
parameter_list|)
block|{
name|int
name|no_overlap
decl_stmt|;
name|int
name|subset
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|int
name|in_p
decl_stmt|;
name|tree
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|lowequal
init|=
operator|(
operator|(
name|low0
operator|==
literal|0
operator|&&
name|low1
operator|==
literal|0
operator|)
operator|||
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|low0
argument_list|,
literal|0
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|highequal
init|=
operator|(
operator|(
name|high0
operator|==
literal|0
operator|&&
name|high1
operator|==
literal|0
operator|)
operator|||
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|,
name|high1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Make range 0 be the range that starts first, or ends last if they      start at the same value.  Swap them if it isn't.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|low0
argument_list|,
literal|0
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|lowequal
operator|&&
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high1
argument_list|,
literal|1
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|in0_p
operator|,
name|in0_p
operator|=
name|in1_p
operator|,
name|in1_p
operator|=
name|temp
expr_stmt|;
name|tem
operator|=
name|low0
operator|,
name|low0
operator|=
name|low1
operator|,
name|low1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|high0
operator|,
name|high0
operator|=
name|high1
operator|,
name|high1
operator|=
name|tem
expr_stmt|;
block|}
comment|/* Now flag two cases, whether the ranges are disjoint or whether the      second range is totally subsumed in the first.  Note that the tests      below are simplified by the ones above.  */
name|no_overlap
operator|=
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|subset
operator|=
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|high1
argument_list|,
literal|1
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We now have four cases, depending on whether we are including or      excluding the two ranges.  */
if|if
condition|(
name|in0_p
operator|&&
name|in1_p
condition|)
block|{
comment|/* If they don't overlap, the result is false.  If the second range 	 is a subset it is the result.  Otherwise, the range is from the start 	 of the second to the end of the first.  */
if|if
condition|(
name|no_overlap
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|subset
condition|)
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low1
operator|,
name|high
operator|=
name|high1
expr_stmt|;
else|else
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low1
operator|,
name|high
operator|=
name|high0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in0_p
operator|&&
operator|!
name|in1_p
condition|)
block|{
comment|/* If they don't overlap, the result is the first range.  If they are 	 equal, the result is false.  If the second range is a subset of the 	 first, and the ranges begin at the same place, we go from just after 	 the end of the first range to the end of the second.  If the second 	 range is not a subset of the first, or if it is a subset and both 	 ranges end at the same place, the range starts at the start of the 	 first range and ends just before the second range. 	 Otherwise, we can't describe this as a single range.  */
if|if
condition|(
name|no_overlap
condition|)
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high0
expr_stmt|;
elseif|else
if|if
condition|(
name|lowequal
operator|&&
name|highequal
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|subset
operator|&&
name|lowequal
condition|)
block|{
name|in_p
operator|=
literal|1
operator|,
name|high
operator|=
name|high0
expr_stmt|;
name|low
operator|=
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|high1
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|subset
operator|||
name|highequal
condition|)
block|{
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low0
expr_stmt|;
name|high
operator|=
name|range_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|in0_p
operator|&&
name|in1_p
condition|)
block|{
comment|/* If they don't overlap, the result is the second range.  If the second 	 is a subset of the first, the result is false.  Otherwise, 	 the range starts just after the first range and ends at the 	 end of the second.  */
if|if
condition|(
name|no_overlap
condition|)
name|in_p
operator|=
literal|1
operator|,
name|low
operator|=
name|low1
operator|,
name|high
operator|=
name|high1
expr_stmt|;
elseif|else
if|if
condition|(
name|subset
operator|||
name|highequal
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|high
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|in_p
operator|=
literal|1
operator|,
name|high
operator|=
name|high1
expr_stmt|;
name|low
operator|=
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The case where we are excluding both ranges.  Here the complex case 	 is if they don't overlap.  In that case, the only time we have a 	 range is if they are adjacent.  If the second is a subset of the 	 first, the result is the first.  Otherwise, the range to exclude 	 starts at the beginning of the first range and ends at the end of the 	 second.  */
if|if
condition|(
name|no_overlap
condition|)
block|{
if|if
condition|(
name|integer_onep
argument_list|(
name|range_binop
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|range_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|high0
argument_list|,
literal|1
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
name|low1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high1
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|subset
condition|)
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high0
expr_stmt|;
else|else
name|in_p
operator|=
literal|0
operator|,
name|low
operator|=
name|low0
operator|,
name|high
operator|=
name|high1
expr_stmt|;
block|}
operator|*
name|pin_p
operator|=
name|in_p
operator|,
operator|*
name|plow
operator|=
name|low
operator|,
operator|*
name|phigh
operator|=
name|high
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|RANGE_TEST_NON_SHORT_CIRCUIT
end_ifndef

begin_define
define|#
directive|define
name|RANGE_TEST_NON_SHORT_CIRCUIT
value|(BRANCH_COST>= 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXP is some logical combination of boolean tests.  See if we can    merge it into some range test.  Return the new tree if so.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_range_test
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|int
name|or_op
init|=
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_OR_EXPR
operator|)
decl_stmt|;
name|int
name|in0_p
decl_stmt|,
name|in1_p
decl_stmt|,
name|in_p
decl_stmt|;
name|tree
name|low0
decl_stmt|,
name|low1
decl_stmt|,
name|low
decl_stmt|,
name|high0
decl_stmt|,
name|high1
decl_stmt|,
name|high
decl_stmt|;
name|tree
name|lhs
init|=
name|make_range
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|in0_p
argument_list|,
operator|&
name|low0
argument_list|,
operator|&
name|high0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|make_range
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|in1_p
argument_list|,
operator|&
name|low1
argument_list|,
operator|&
name|high1
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* If this is an OR operation, invert both sides; we will invert      again at the end.  */
if|if
condition|(
name|or_op
condition|)
name|in0_p
operator|=
operator|!
name|in0_p
operator|,
name|in1_p
operator|=
operator|!
name|in1_p
expr_stmt|;
comment|/* If both expressions are the same, if we can merge the ranges, and we      can build the range test, return it or it inverted.  If one of the      ranges is always true or always false, consider it to be the same      expression as the other.  */
if|if
condition|(
operator|(
name|lhs
operator|==
literal|0
operator|||
name|rhs
operator|==
literal|0
operator|||
name|operand_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|merge_ranges
argument_list|(
operator|&
name|in_p
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|,
name|in0_p
argument_list|,
name|low0
argument_list|,
name|high0
argument_list|,
name|in1_p
argument_list|,
name|low1
argument_list|,
name|high1
argument_list|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
operator|(
name|build_range_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|lhs
operator|!=
literal|0
condition|?
name|lhs
else|:
name|rhs
operator|!=
literal|0
condition|?
name|rhs
else|:
name|integer_zero_node
argument_list|,
name|in_p
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
operator|)
operator|)
condition|)
return|return
name|or_op
condition|?
name|invert_truthvalue
argument_list|(
name|tem
argument_list|)
else|:
name|tem
return|;
comment|/* On machines where the branch cost is expensive, if this is a      short-circuited branch and the underlying object on both sides      is the same, make a non-short-circuit operation.  */
elseif|else
if|if
condition|(
name|RANGE_TEST_NON_SHORT_CIRCUIT
operator|&&
name|lhs
operator|!=
literal|0
operator|&&
name|rhs
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If simple enough, just rewrite.  Otherwise, make a SAVE_EXPR 	 unless we are at top level or LHS contains a PLACEHOLDER_EXPR, in 	 which cases we can't do this.  */
if|if
condition|(
name|simple_operand_p
argument_list|(
name|lhs
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
condition|?
name|TRUTH_AND_EXPR
else|:
name|TRUTH_OR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
call|)
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|tree
name|common
init|=
name|save_expr
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|lhs
operator|=
name|build_range_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|common
argument_list|,
name|or_op
condition|?
operator|!
name|in0_p
else|:
name|in0_p
argument_list|,
name|low0
argument_list|,
name|high0
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|!=
operator|(
name|rhs
operator|=
name|build_range_check
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|common
argument_list|,
name|or_op
condition|?
operator|!
name|in1_p
else|:
name|in1_p
argument_list|,
name|low1
argument_list|,
name|high1
argument_list|)
operator|)
operator|)
condition|)
return|return
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
condition|?
name|TRUTH_AND_EXPR
else|:
name|TRUTH_OR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine for fold_truthop: C is an INTEGER_CST interpreted as a P    bit value.  Arrange things so the extra bits will be set to zero if and    only if C is signed-extended to its full width.  If MASK is nonzero,    it is an INTEGER_CST that should be AND'ed with the extra bits.  */
end_comment

begin_function
specifier|static
name|tree
name|unextend
parameter_list|(
name|tree
name|c
parameter_list|,
name|int
name|p
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|tree
name|mask
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|int
name|modesize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|temp
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|modesize
operator|||
name|unsignedp
condition|)
return|return
name|c
return|;
comment|/* We work by getting just the sign bit into the low-order bit, then      into the high-order bit, then sign-extend.  We then XOR that value      with C.  */
name|temp
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|c
argument_list|,
name|size_int
argument_list|(
name|p
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We must use a signed type in order to get an arithmetic right shift.      However, we must also avoid introducing accidental overflows, so that      a subsequent call to integer_zerop will work.  Hence we must      do the type conversion here.  At this point, the constant is either      zero or one, and the conversion to a signed type can never overflow.      We could get an overflow if this conversion is done anywhere else.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|temp
operator|=
name|fold_convert
argument_list|(
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
call|)
argument_list|(
name|type
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
name|modesize
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
name|modesize
operator|-
name|p
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
name|temp
operator|=
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|temp
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If necessary, convert the type back to match the type of C.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|temp
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|c
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find ways of folding logical expressions of LHS and RHS:    Try to merge two comparisons to the same innermost item.    Look for range tests like "ch>= '0'&& ch<= '9'".    Look for combinations of simple terms on machines with expensive branches    and evaluate the RHS unconditionally.     For example, if we have p->a == 2&& p->b == 4 and we can make an    object large enough to span both A and B, we can do this with a comparison    against the object ANDed with the a mask.     If we have p->a == q->a&& p->b == q->b, we may be able to use bit masking    operations to do this with one comparison.     We check for both normal comparisons and the BIT_AND_EXPRs made this by    function and the one above.     CODE is the logical operation being done.  It can be TRUTH_ANDIF_EXPR,    TRUTH_AND_EXPR, TRUTH_ORIF_EXPR, or TRUTH_OR_EXPR.     TRUTH_TYPE is the type of the logical operand and LHS and RHS are its    two operands.     We return the simplified tree or 0 if no optimization is possible.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_truthop
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|truth_type
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
comment|/* If this is the "or" of two comparisons, we can do something if      the comparisons are NE_EXPR.  If this is the "and", we can do something      if the comparisons are EQ_EXPR.  I.e., 	(a->b == 2&& a->c == 4) can become (a->new == NEW).       WANTED_CODE is this operation code.  For single bit fields, we can      convert EQ_EXPR to NE_EXPR so we need not reject the "wrong"      comparison for one-bit fields.  */
name|enum
name|tree_code
name|wanted_code
decl_stmt|;
name|enum
name|tree_code
name|lcode
decl_stmt|,
name|rcode
decl_stmt|;
name|tree
name|ll_arg
decl_stmt|,
name|lr_arg
decl_stmt|,
name|rl_arg
decl_stmt|,
name|rr_arg
decl_stmt|;
name|tree
name|ll_inner
decl_stmt|,
name|lr_inner
decl_stmt|,
name|rl_inner
decl_stmt|,
name|rr_inner
decl_stmt|;
name|HOST_WIDE_INT
name|ll_bitsize
decl_stmt|,
name|ll_bitpos
decl_stmt|,
name|lr_bitsize
decl_stmt|,
name|lr_bitpos
decl_stmt|;
name|HOST_WIDE_INT
name|rl_bitsize
decl_stmt|,
name|rl_bitpos
decl_stmt|,
name|rr_bitsize
decl_stmt|,
name|rr_bitpos
decl_stmt|;
name|HOST_WIDE_INT
name|xll_bitpos
decl_stmt|,
name|xlr_bitpos
decl_stmt|,
name|xrl_bitpos
decl_stmt|,
name|xrr_bitpos
decl_stmt|;
name|HOST_WIDE_INT
name|lnbitsize
decl_stmt|,
name|lnbitpos
decl_stmt|,
name|rnbitsize
decl_stmt|,
name|rnbitpos
decl_stmt|;
name|int
name|ll_unsignedp
decl_stmt|,
name|lr_unsignedp
decl_stmt|,
name|rl_unsignedp
decl_stmt|,
name|rr_unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|ll_mode
decl_stmt|,
name|lr_mode
decl_stmt|,
name|rl_mode
decl_stmt|,
name|rr_mode
decl_stmt|;
name|enum
name|machine_mode
name|lnmode
decl_stmt|,
name|rnmode
decl_stmt|;
name|tree
name|ll_mask
decl_stmt|,
name|lr_mask
decl_stmt|,
name|rl_mask
decl_stmt|,
name|rr_mask
decl_stmt|;
name|tree
name|ll_and_mask
decl_stmt|,
name|lr_and_mask
decl_stmt|,
name|rl_and_mask
decl_stmt|,
name|rr_and_mask
decl_stmt|;
name|tree
name|l_const
decl_stmt|,
name|r_const
decl_stmt|;
name|tree
name|lntype
decl_stmt|,
name|rntype
decl_stmt|,
name|result
decl_stmt|;
name|int
name|first_bit
decl_stmt|,
name|end_bit
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
comment|/* Start by getting the comparison codes.  Fail if anything is volatile.      If one operand is a BIT_AND_EXPR with the constant one, treat it as if      it were surrounded with a NE_EXPR.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
literal|0
return|;
name|lcode
operator|=
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcode
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|lcode
operator|=
name|NE_EXPR
operator|,
name|lhs
operator|=
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|rcode
operator|=
name|NE_EXPR
operator|,
name|rhs
operator|=
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|truth_type
argument_list|,
name|rhs
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|lcode
argument_list|)
operator|!=
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|rcode
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|code
operator|=
operator|(
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|)
condition|?
name|TRUTH_AND_EXPR
else|:
name|TRUTH_OR_EXPR
operator|)
expr_stmt|;
name|ll_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lr_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rl_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rr_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Simplify (x<y)&& (x==y) into (x<=y) and related optimizations.  */
if|if
condition|(
name|simple_operand_p
argument_list|(
name|ll_arg
argument_list|)
operator|&&
name|simple_operand_p
argument_list|(
name|lr_arg
argument_list|)
operator|&&
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|compcode
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|ll_arg
argument_list|,
name|rl_arg
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|lr_arg
argument_list|,
name|rr_arg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|lcompcode
decl_stmt|,
name|rcompcode
decl_stmt|;
name|lcompcode
operator|=
name|comparison_to_compcode
argument_list|(
name|lcode
argument_list|)
expr_stmt|;
name|rcompcode
operator|=
name|comparison_to_compcode
argument_list|(
name|rcode
argument_list|)
expr_stmt|;
name|compcode
operator|=
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|)
condition|?
name|lcompcode
operator|&
name|rcompcode
else|:
name|lcompcode
operator||
name|rcompcode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|ll_arg
argument_list|,
name|rr_arg
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|lr_arg
argument_list|,
name|rl_arg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|lcompcode
decl_stmt|,
name|rcompcode
decl_stmt|;
name|rcode
operator|=
name|swap_tree_comparison
argument_list|(
name|rcode
argument_list|)
expr_stmt|;
name|lcompcode
operator|=
name|comparison_to_compcode
argument_list|(
name|lcode
argument_list|)
expr_stmt|;
name|rcompcode
operator|=
name|comparison_to_compcode
argument_list|(
name|rcode
argument_list|)
expr_stmt|;
name|compcode
operator|=
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|)
condition|?
name|lcompcode
operator|&
name|rcompcode
else|:
name|lcompcode
operator||
name|rcompcode
expr_stmt|;
block|}
else|else
name|compcode
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|compcode
operator|==
name|COMPCODE_TRUE
condition|)
return|return
name|fold_convert
argument_list|(
name|truth_type
argument_list|,
name|integer_one_node
argument_list|)
return|;
elseif|else
if|if
condition|(
name|compcode
operator|==
name|COMPCODE_FALSE
condition|)
return|return
name|fold_convert
argument_list|(
name|truth_type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
elseif|else
if|if
condition|(
name|compcode
operator|!=
operator|-
literal|1
condition|)
return|return
name|build
argument_list|(
name|compcode_to_comparison
argument_list|(
name|compcode
argument_list|)
argument_list|,
name|truth_type
argument_list|,
name|ll_arg
argument_list|,
name|lr_arg
argument_list|)
return|;
block|}
comment|/* If the RHS can be evaluated unconditionally and its operands are      simple, it wins to evaluate the RHS unconditionally on machines      with expensive branches.  In this case, this isn't a comparison      that can be merged.  Avoid doing this if the RHS is a floating-point      comparison since those can trap.  */
if|if
condition|(
name|BRANCH_COST
operator|>=
literal|2
operator|&&
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rl_arg
argument_list|)
argument_list|)
operator|&&
name|simple_operand_p
argument_list|(
name|rl_arg
argument_list|)
operator|&&
name|simple_operand_p
argument_list|(
name|rr_arg
argument_list|)
condition|)
block|{
comment|/* Convert (a != 0) || (b != 0) into (a | b) != 0.  */
if|if
condition|(
name|code
operator|==
name|TRUTH_OR_EXPR
operator|&&
name|lcode
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|lr_arg
argument_list|)
operator|&&
name|rcode
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|rr_arg
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|rl_arg
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|truth_type
argument_list|,
name|build
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
argument_list|,
name|ll_arg
argument_list|,
name|rl_arg
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
return|;
comment|/* Convert (a == 0)&& (b == 0) into (a | b) == 0.  */
if|if
condition|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|&&
name|lcode
operator|==
name|EQ_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|lr_arg
argument_list|)
operator|&&
name|rcode
operator|==
name|EQ_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|rr_arg
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|rl_arg
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|truth_type
argument_list|,
name|build
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ll_arg
argument_list|)
argument_list|,
name|ll_arg
argument_list|,
name|rl_arg
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
return|;
return|return
name|build
argument_list|(
name|code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* See if the comparisons can be merged.  Then get all the parameters for      each side.  */
if|if
condition|(
operator|(
name|lcode
operator|!=
name|EQ_EXPR
operator|&&
name|lcode
operator|!=
name|NE_EXPR
operator|)
operator|||
operator|(
name|rcode
operator|!=
name|EQ_EXPR
operator|&&
name|rcode
operator|!=
name|NE_EXPR
operator|)
condition|)
return|return
literal|0
return|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|ll_inner
operator|=
name|decode_field_reference
argument_list|(
name|ll_arg
argument_list|,
operator|&
name|ll_bitsize
argument_list|,
operator|&
name|ll_bitpos
argument_list|,
operator|&
name|ll_mode
argument_list|,
operator|&
name|ll_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|ll_mask
argument_list|,
operator|&
name|ll_and_mask
argument_list|)
expr_stmt|;
name|lr_inner
operator|=
name|decode_field_reference
argument_list|(
name|lr_arg
argument_list|,
operator|&
name|lr_bitsize
argument_list|,
operator|&
name|lr_bitpos
argument_list|,
operator|&
name|lr_mode
argument_list|,
operator|&
name|lr_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|lr_mask
argument_list|,
operator|&
name|lr_and_mask
argument_list|)
expr_stmt|;
name|rl_inner
operator|=
name|decode_field_reference
argument_list|(
name|rl_arg
argument_list|,
operator|&
name|rl_bitsize
argument_list|,
operator|&
name|rl_bitpos
argument_list|,
operator|&
name|rl_mode
argument_list|,
operator|&
name|rl_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|rl_mask
argument_list|,
operator|&
name|rl_and_mask
argument_list|)
expr_stmt|;
name|rr_inner
operator|=
name|decode_field_reference
argument_list|(
name|rr_arg
argument_list|,
operator|&
name|rr_bitsize
argument_list|,
operator|&
name|rr_bitpos
argument_list|,
operator|&
name|rr_mode
argument_list|,
operator|&
name|rr_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|rr_mask
argument_list|,
operator|&
name|rr_and_mask
argument_list|)
expr_stmt|;
comment|/* It must be true that the inner operation on the lhs of each      comparison must be the same if we are to be able to do anything.      Then see if we have constants.  If not, the same must be true for      the rhs's.  */
if|if
condition|(
name|volatilep
operator|||
name|ll_inner
operator|==
literal|0
operator|||
name|rl_inner
operator|==
literal|0
operator|||
operator|!
name|operand_equal_p
argument_list|(
name|ll_inner
argument_list|,
name|rl_inner
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lr_arg
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|rr_arg
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|l_const
operator|=
name|lr_arg
operator|,
name|r_const
operator|=
name|rr_arg
expr_stmt|;
elseif|else
if|if
condition|(
name|lr_inner
operator|==
literal|0
operator|||
name|rr_inner
operator|==
literal|0
operator|||
operator|!
name|operand_equal_p
argument_list|(
name|lr_inner
argument_list|,
name|rr_inner
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
name|l_const
operator|=
name|r_const
operator|=
literal|0
expr_stmt|;
comment|/* If either comparison code is not correct for our logical operation,      fail.  However, we can convert a one-bit comparison against zero into      the opposite comparison against that bit being set in the field.  */
name|wanted_code
operator|=
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
operator|)
expr_stmt|;
if|if
condition|(
name|lcode
operator|!=
name|wanted_code
condition|)
block|{
if|if
condition|(
name|l_const
operator|&&
name|integer_zerop
argument_list|(
name|l_const
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|ll_mask
argument_list|)
condition|)
block|{
comment|/* Make the left operand unsigned, since we are only interested 	     in the value of one bit.  Otherwise we are doing the wrong 	     thing below.  */
name|ll_unsignedp
operator|=
literal|1
expr_stmt|;
name|l_const
operator|=
name|ll_mask
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* This is analogous to the code for l_const above.  */
if|if
condition|(
name|rcode
operator|!=
name|wanted_code
condition|)
block|{
if|if
condition|(
name|r_const
operator|&&
name|integer_zerop
argument_list|(
name|r_const
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|rl_mask
argument_list|)
condition|)
block|{
name|rl_unsignedp
operator|=
literal|1
expr_stmt|;
name|r_const
operator|=
name|rl_mask
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* After this point all optimizations will generate bit-field      references, which we might not want.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|lang_hooks
operator|.
name|can_use_bit_fields_p
call|)
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* See if we can find a mode that contains both fields being compared on      the left.  If we can't, fail.  Otherwise, update all constants and masks      to be relative to a field of that size.  */
name|first_bit
operator|=
name|MIN
argument_list|(
name|ll_bitpos
argument_list|,
name|rl_bitpos
argument_list|)
expr_stmt|;
name|end_bit
operator|=
name|MAX
argument_list|(
name|ll_bitpos
operator|+
name|ll_bitsize
argument_list|,
name|rl_bitpos
operator|+
name|rl_bitsize
argument_list|)
expr_stmt|;
name|lnmode
operator|=
name|get_best_mode
argument_list|(
name|end_bit
operator|-
name|first_bit
argument_list|,
name|first_bit
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|ll_inner
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
name|lnbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|lnmode
argument_list|)
expr_stmt|;
name|lnbitpos
operator|=
name|first_bit
operator|&
operator|~
operator|(
name|lnbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|lntype
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
call|)
argument_list|(
name|lnbitsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xll_bitpos
operator|=
name|ll_bitpos
operator|-
name|lnbitpos
operator|,
name|xrl_bitpos
operator|=
name|rl_bitpos
operator|-
name|lnbitpos
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|xll_bitpos
operator|=
name|lnbitsize
operator|-
name|xll_bitpos
operator|-
name|ll_bitsize
expr_stmt|;
name|xrl_bitpos
operator|=
name|lnbitsize
operator|-
name|xrl_bitpos
operator|-
name|rl_bitsize
expr_stmt|;
block|}
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|ll_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xll_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|rl_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xrl_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_const
condition|)
block|{
name|l_const
operator|=
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|l_const
argument_list|)
expr_stmt|;
name|l_const
operator|=
name|unextend
argument_list|(
name|l_const
argument_list|,
name|ll_bitsize
argument_list|,
name|ll_unsignedp
argument_list|,
name|ll_and_mask
argument_list|)
expr_stmt|;
name|l_const
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|l_const
argument_list|,
name|size_int
argument_list|(
name|xll_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|l_const
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|lntype
argument_list|,
name|ll_mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison is always %d"
argument_list|,
name|wanted_code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|truth_type
argument_list|,
name|wanted_code
operator|==
name|NE_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|r_const
condition|)
block|{
name|r_const
operator|=
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|r_const
argument_list|)
expr_stmt|;
name|r_const
operator|=
name|unextend
argument_list|(
name|r_const
argument_list|,
name|rl_bitsize
argument_list|,
name|rl_unsignedp
argument_list|,
name|rl_and_mask
argument_list|)
expr_stmt|;
name|r_const
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|r_const
argument_list|,
name|size_int
argument_list|(
name|xrl_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|r_const
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|lntype
argument_list|,
name|rl_mask
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison is always %d"
argument_list|,
name|wanted_code
operator|==
name|NE_EXPR
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|truth_type
argument_list|,
name|wanted_code
operator|==
name|NE_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
comment|/* If the right sides are not constant, do the same for it.  Also,      disallow this optimization if a size or signedness mismatch occurs      between the left and right sides.  */
if|if
condition|(
name|l_const
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ll_bitsize
operator|!=
name|lr_bitsize
operator|||
name|rl_bitsize
operator|!=
name|rr_bitsize
operator|||
name|ll_unsignedp
operator|!=
name|lr_unsignedp
operator|||
name|rl_unsignedp
operator|!=
name|rr_unsignedp
comment|/* Make sure the two fields on the right 	     correspond to the left without being swapped.  */
operator|||
name|ll_bitpos
operator|-
name|rl_bitpos
operator|!=
name|lr_bitpos
operator|-
name|rr_bitpos
condition|)
return|return
literal|0
return|;
name|first_bit
operator|=
name|MIN
argument_list|(
name|lr_bitpos
argument_list|,
name|rr_bitpos
argument_list|)
expr_stmt|;
name|end_bit
operator|=
name|MAX
argument_list|(
name|lr_bitpos
operator|+
name|lr_bitsize
argument_list|,
name|rr_bitpos
operator|+
name|rr_bitsize
argument_list|)
expr_stmt|;
name|rnmode
operator|=
name|get_best_mode
argument_list|(
name|end_bit
operator|-
name|first_bit
argument_list|,
name|first_bit
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|lr_inner
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
name|rnbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|rnmode
argument_list|)
expr_stmt|;
name|rnbitpos
operator|=
name|first_bit
operator|&
operator|~
operator|(
name|rnbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|rntype
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
call|)
argument_list|(
name|rnbitsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xlr_bitpos
operator|=
name|lr_bitpos
operator|-
name|rnbitpos
operator|,
name|xrr_bitpos
operator|=
name|rr_bitpos
operator|-
name|rnbitpos
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|xlr_bitpos
operator|=
name|rnbitsize
operator|-
name|xlr_bitpos
operator|-
name|lr_bitsize
expr_stmt|;
name|xrr_bitpos
operator|=
name|rnbitsize
operator|-
name|xrr_bitpos
operator|-
name|rr_bitsize
expr_stmt|;
block|}
name|lr_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|rntype
argument_list|,
name|lr_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xlr_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rr_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|rntype
argument_list|,
name|rr_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xrr_bitpos
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a mask that corresponds to both fields being compared. 	 Do this for both items being compared.  If the operands are the 	 same size and the bits being compared are in the same position 	 then we can do this by masking both and comparing the masked 	 results.  */
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lr_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|lr_mask
argument_list|,
name|rr_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnbitsize
operator|==
name|rnbitsize
operator|&&
name|xll_bitpos
operator|==
name|xlr_bitpos
condition|)
block|{
name|lhs
operator|=
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|lntype
argument_list|,
name|lnbitsize
argument_list|,
name|lnbitpos
argument_list|,
name|ll_unsignedp
operator|||
name|rl_unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|ll_mask
argument_list|,
name|lnbitsize
argument_list|)
condition|)
name|lhs
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|lntype
argument_list|,
name|lhs
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|make_bit_field_ref
argument_list|(
name|lr_inner
argument_list|,
name|rntype
argument_list|,
name|rnbitsize
argument_list|,
name|rnbitpos
argument_list|,
name|lr_unsignedp
operator|||
name|rr_unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|lr_mask
argument_list|,
name|rnbitsize
argument_list|)
condition|)
name|rhs
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|rntype
argument_list|,
name|rhs
argument_list|,
name|lr_mask
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* There is still another way we can do something:  If both pairs of 	 fields being compared are adjacent, we may be able to make a wider 	 field containing them both.  	 Note that we still must mask the lhs/rhs expressions.  Furthermore, 	 the mask must be shifted to account for the shift done by 	 make_bit_field_ref.  */
if|if
condition|(
operator|(
name|ll_bitsize
operator|+
name|ll_bitpos
operator|==
name|rl_bitpos
operator|&&
name|lr_bitsize
operator|+
name|lr_bitpos
operator|==
name|rr_bitpos
operator|)
operator|||
operator|(
name|ll_bitpos
operator|==
name|rl_bitpos
operator|+
name|rl_bitsize
operator|&&
name|lr_bitpos
operator|==
name|rr_bitpos
operator|+
name|rr_bitsize
operator|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|lhs
operator|=
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|lntype
argument_list|,
name|ll_bitsize
operator|+
name|rl_bitsize
argument_list|,
name|MIN
argument_list|(
name|ll_bitpos
argument_list|,
name|rl_bitpos
argument_list|)
argument_list|,
name|ll_unsignedp
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|make_bit_field_ref
argument_list|(
name|lr_inner
argument_list|,
name|rntype
argument_list|,
name|lr_bitsize
operator|+
name|rr_bitsize
argument_list|,
name|MIN
argument_list|(
name|lr_bitpos
argument_list|,
name|rr_bitpos
argument_list|)
argument_list|,
name|lr_unsignedp
argument_list|)
expr_stmt|;
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|size_int
argument_list|(
name|MIN
argument_list|(
name|xll_bitpos
argument_list|,
name|xrl_bitpos
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lr_mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|lr_mask
argument_list|,
name|size_int
argument_list|(
name|MIN
argument_list|(
name|xlr_bitpos
argument_list|,
name|xrr_bitpos
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert to the smaller type before masking out unwanted bits.  */
name|type
operator|=
name|lntype
expr_stmt|;
if|if
condition|(
name|lntype
operator|!=
name|rntype
condition|)
block|{
if|if
condition|(
name|lnbitsize
operator|>
name|rnbitsize
condition|)
block|{
name|lhs
operator|=
name|fold_convert
argument_list|(
name|rntype
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|ll_mask
operator|=
name|fold_convert
argument_list|(
name|rntype
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
name|type
operator|=
name|rntype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lnbitsize
operator|<
name|rnbitsize
condition|)
block|{
name|rhs
operator|=
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|lr_mask
operator|=
name|fold_convert
argument_list|(
name|lntype
argument_list|,
name|lr_mask
argument_list|)
expr_stmt|;
name|type
operator|=
name|lntype
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|ll_mask
argument_list|,
name|ll_bitsize
operator|+
name|rl_bitsize
argument_list|)
condition|)
name|lhs
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|lhs
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|lr_mask
argument_list|,
name|lr_bitsize
operator|+
name|rr_bitsize
argument_list|)
condition|)
name|rhs
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|,
name|lr_mask
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Handle the case of comparisons with constants.  If there is something in      common between the masks, those bits of the constants must be the same.      If not, the condition is always false.  Test for this to avoid generating      incorrect code below.  */
name|result
operator|=
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|result
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|result
argument_list|,
name|l_const
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|result
argument_list|,
name|r_const
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|wanted_code
operator|==
name|NE_EXPR
condition|)
block|{
name|warning
argument_list|(
literal|"`or' of unmatched not-equal tests is always 1"
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|truth_type
argument_list|,
name|integer_one_node
argument_list|)
return|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`and' of mutually exclusive equal-tests is always 0"
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|truth_type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
comment|/* Construct the expression we will return.  First get the component      reference we will make.  Unless the mask is all ones the width of      that field, perform the mask operation.  Then compare with the      merged constant.  */
name|result
operator|=
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|lntype
argument_list|,
name|lnbitsize
argument_list|,
name|lnbitpos
argument_list|,
name|ll_unsignedp
operator|||
name|rl_unsignedp
argument_list|)
expr_stmt|;
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|ll_mask
argument_list|,
name|lnbitsize
argument_list|)
condition|)
name|result
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|lntype
argument_list|,
name|result
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|result
argument_list|,
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|l_const
argument_list|,
name|r_const
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimize T, which is a comparison of a MIN_EXPR or MAX_EXPR with a    constant.  */
end_comment

begin_function
specifier|static
name|tree
name|optimize_minmax_comparison
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|op_code
decl_stmt|;
name|tree
name|comp_const
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|minmax_const
decl_stmt|;
name|int
name|consts_equal
decl_stmt|,
name|consts_lt
decl_stmt|;
name|tree
name|inner
decl_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op_code
operator|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|minmax_const
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|consts_equal
operator|=
name|tree_int_cst_equal
argument_list|(
name|minmax_const
argument_list|,
name|comp_const
argument_list|)
expr_stmt|;
name|consts_lt
operator|=
name|tree_int_cst_lt
argument_list|(
name|minmax_const
argument_list|,
name|comp_const
argument_list|)
expr_stmt|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If something does not permit us to optimize, return the original tree.  */
if|if
condition|(
operator|(
name|op_code
operator|!=
name|MIN_EXPR
operator|&&
name|op_code
operator|!=
name|MAX_EXPR
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|comp_const
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|comp_const
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|minmax_const
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|minmax_const
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Now handle all the various comparison codes.  We only handle EQ_EXPR      and GT_EXPR, doing the rest with recursive calls using logical      simplifications.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
return|return
name|invert_truthvalue
argument_list|(
name|optimize_minmax_comparison
argument_list|(
name|invert_truthvalue
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|optimize_minmax_comparison
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|comp_const
argument_list|)
argument_list|)
argument_list|,
name|optimize_minmax_comparison
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|comp_const
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|EQ_EXPR
case|:
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
operator|&&
name|consts_equal
condition|)
comment|/* MAX (X, 0) == 0  ->  X<= 0  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
operator|&&
name|consts_lt
condition|)
comment|/* MAX (X, 0) == 5  ->  X == 5   */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
condition|)
comment|/* MAX (X, 0) == -1  ->  false  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|inner
argument_list|)
return|;
elseif|else
if|if
condition|(
name|consts_equal
condition|)
comment|/* MIN (X, 0) == 0  ->  X>= 0  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|consts_lt
condition|)
comment|/* MIN (X, 0) == 5  ->  false  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|inner
argument_list|)
return|;
else|else
comment|/* MIN (X, 0) == -1  ->  X == -1  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
operator|&&
operator|(
name|consts_equal
operator|||
name|consts_lt
operator|)
condition|)
comment|/* MAX (X, 0)> 0  ->  X> 0 	   MAX (X, 0)> 5  ->  X> 5  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MAX_EXPR
condition|)
comment|/* MAX (X, 0)> -1  ->  true  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|inner
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op_code
operator|==
name|MIN_EXPR
operator|&&
operator|(
name|consts_equal
operator|||
name|consts_lt
operator|)
condition|)
comment|/* MIN (X, 0)> 0  ->  false 	   MIN (X, 0)> 5  ->  false  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|inner
argument_list|)
return|;
else|else
comment|/* MIN (X, 0)> -1  ->  X> -1  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|comp_const
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|t
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* T is an integer expression that is being multiplied, divided, or taken a    modulus (CODE says which and what kind of divide or modulus) by a    constant C.  See if we can eliminate that operation by folding it with    other operations already in T.  WIDE_TYPE, if non-null, is a type that    should be used for the computation if wider than our type.     For example, if we are dividing (X * 8) + (Y * 16) by 4, we can return    (X * 2) + (Y * 4).  We must, however, be assured that either the original    expression would not overflow or that overflow is undefined for the type    in the language in question.     We also canonicalize (X + 7) * 4 into X * 4 + 28 in the hope that either    the machine has a multiply-accumulate insn or that this is part of an    addressing calculation.     If we return a non-null expression, it is an equivalent form of the    original computation, but need not be in the original type.  */
end_comment

begin_function
specifier|static
name|tree
name|extract_muldiv
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|c
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|wide_type
parameter_list|)
block|{
comment|/* To avoid exponential search depth, refuse to allow recursion past      three levels.  Beyond that (1) it's highly unlikely that we'll find      something interesting and (2) we've probably processed it before      when we built the inner expression.  */
specifier|static
name|int
name|depth
decl_stmt|;
name|tree
name|ret
decl_stmt|;
if|if
condition|(
name|depth
operator|>
literal|3
condition|)
return|return
name|NULL
return|;
name|depth
operator|++
expr_stmt|;
name|ret
operator|=
name|extract_muldiv_1
argument_list|(
name|t
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
expr_stmt|;
name|depth
operator|--
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|extract_muldiv_1
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|c
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|wide_type
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|tcode
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|ctype
init|=
operator|(
name|wide_type
operator|!=
literal|0
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|wide_type
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|?
name|wide_type
else|:
name|type
operator|)
decl_stmt|;
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|same_p
init|=
name|tcode
operator|==
name|code
decl_stmt|;
name|tree
name|op0
init|=
name|NULL_TREE
decl_stmt|,
name|op1
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Don't deal with constants of zero here; they confuse the code below.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|tcode
argument_list|)
operator|==
literal|'1'
condition|)
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|tcode
argument_list|)
operator|==
literal|'2'
condition|)
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Note that we need not handle conditional operations here since fold      already handles those cases.  So just do arithmetic here.  */
switch|switch
condition|(
name|tcode
condition|)
block|{
case|case
name|INTEGER_CST
case|:
comment|/* For a constant, we can always simplify if we are a multiply 	 or (for divide and modulus) if it is a multiple of our constant.  */
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|||
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|t
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|const_binop
argument_list|(
name|code
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* If op0 is an expression ...  */
if|if
condition|(
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
literal|'e'
operator|)
comment|/* ... and is unsigned, and its type is smaller than ctype, 	     then we cannot pass through as widening.  */
operator|&&
operator|(
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
comment|/* ... or this is a truncation (t is narrower than op0), 		 then we cannot pass through this narrowing.  */
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* ... or signedness changes for division or modulus, 		 then we cannot pass through this conversion.  */
operator|||
operator|(
name|code
operator|!=
name|MULT_EXPR
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
break|break;
comment|/* Pass the constant down and see if we can make a simplification.  If 	 we can, replace this expression with the inner simplification for 	 possible later conversion to our or some other type.  */
if|if
condition|(
operator|(
name|t2
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|c
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t2
argument_list|)
operator|&&
operator|(
literal|0
operator|!=
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|t2
argument_list|,
name|code
argument_list|,
name|code
operator|==
name|MULT_EXPR
condition|?
name|ctype
else|:
name|NULL_TREE
argument_list|)
operator|)
operator|)
condition|)
return|return
name|t1
return|;
break|break;
case|case
name|ABS_EXPR
case|:
comment|/* If widening the type changes it from signed to unsigned, then we          must avoid building ABS_EXPR itself as unsigned.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|cstype
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
call|)
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|cstype
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|t1
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|tcode
argument_list|,
name|cstype
argument_list|,
name|fold_convert
argument_list|(
name|cstype
argument_list|,
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
return|;
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
comment|/* If widening the type changes the signedness, then we can't perform 	 this optimization as that changes the result.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
break|break;
comment|/* MIN (a, b) / 5 -> MIN (a / 5, b / 5)  */
if|if
condition|(
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|t2
operator|=
name|extract_muldiv
argument_list|(
name|op1
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
name|tcode
operator|=
operator|(
name|tcode
operator|==
name|MIN_EXPR
condition|?
name|MAX_EXPR
else|:
name|MIN_EXPR
operator|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|WITH_RECORD_EXPR
case|:
if|if
condition|(
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|t1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
comment|/* If the second operand is constant, this is a multiplication 	 or floor division, by a power of two, so we can treat it that 	 way unless the multiplier or divisor overflows.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
comment|/* const_binop may not detect overflow correctly, 	     so check for it explicitly here.  */
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|size_one_node
argument_list|)
argument_list|)
operator|>
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
literal|0
operator|!=
operator|(
name|t1
operator|=
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|size_one_node
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|extract_muldiv
argument_list|(
name|build
argument_list|(
name|tcode
operator|==
name|LSHIFT_EXPR
condition|?
name|MULT_EXPR
else|:
name|FLOOR_DIV_EXPR
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|t1
argument_list|)
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
return|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
comment|/* See if we can eliminate the operation on both sides.  If we can, we 	 can return a new PLUS or MINUS.  If we can't, the only remaining 	 cases where we can do anything are if the second operand is a 	 constant.  */
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
expr_stmt|;
name|t2
operator|=
name|extract_muldiv
argument_list|(
name|op1
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
literal|0
operator|&&
name|t2
operator|!=
literal|0
operator|&&
operator|(
name|code
operator|==
name|MULT_EXPR
comment|/* If not multiplication, we can only do this if both operands 		 are divisible by c.  */
operator|||
operator|(
name|multiple_of_p
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|,
name|c
argument_list|)
operator|&&
name|multiple_of_p
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|,
name|c
argument_list|)
operator|)
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If this was a subtraction, negate OP1 and set it to be an addition. 	 This simplifies the logic below.  */
if|if
condition|(
name|tcode
operator|==
name|MINUS_EXPR
condition|)
name|tcode
operator|=
name|PLUS_EXPR
operator|,
name|op1
operator|=
name|negate_expr
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
comment|/* If either OP1 or C are negative, this optimization is not safe for 	 some of the division and remainder types while for others we need 	 to change the code.  */
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
operator|||
name|tree_int_cst_sgn
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CEIL_DIV_EXPR
condition|)
name|code
operator|=
name|FLOOR_DIV_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|FLOOR_DIV_EXPR
condition|)
name|code
operator|=
name|CEIL_DIV_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|!=
name|MULT_EXPR
operator|&&
name|code
operator|!=
name|CEIL_MOD_EXPR
operator|&&
name|code
operator|!=
name|FLOOR_MOD_EXPR
condition|)
break|break;
block|}
comment|/* If it's a multiply or a division/modulus operation of a multiple          of our constant, do the operation and verify it doesn't overflow.  */
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|||
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|op1
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We allow the constant to overflow with wrapping semantics.  */
if|if
condition|(
name|op1
operator|==
literal|0
operator|||
operator|(
name|TREE_OVERFLOW
argument_list|(
name|op1
argument_list|)
operator|&&
operator|!
name|flag_wrapv
operator|)
condition|)
break|break;
block|}
else|else
break|break;
comment|/* If we have an unsigned type is not a sizetype, we cannot widen 	 the operation since it will change the result if the original 	 computation overflowed.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|ctype
argument_list|)
operator|)
operator|&&
name|ctype
operator|!=
name|type
condition|)
break|break;
comment|/* If we were able to eliminate our operation from the first side, 	 apply our operation to the second side and reform the PLUS.  */
if|if
condition|(
name|t1
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|code
operator|||
name|code
operator|==
name|MULT_EXPR
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
comment|/* The last case is if we are a multiply.  In that case, we can 	 apply the distributive law to commute the multiply and addition 	 if the multiplication of the constants doesn't overflow.  */
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MULT_EXPR
case|:
comment|/* We have a special case here if we are doing something like 	 (C * 8) % 4 since we know that's zero.  */
if|if
condition|(
operator|(
name|code
operator|==
name|TRUNC_MOD_EXPR
operator|||
name|code
operator|==
name|CEIL_MOD_EXPR
operator|||
name|code
operator|==
name|FLOOR_MOD_EXPR
operator|||
name|code
operator|==
name|ROUND_MOD_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|op0
argument_list|)
return|;
comment|/* ... fall through ...  */
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* If we can extract our operation from the LHS, do so and return a 	 new operation.  Likewise for the RHS from a MULT_EXPR.  Otherwise, 	 do something only if the second operand is a constant.  */
if|if
condition|(
name|same_p
operator|&&
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op0
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|tcode
operator|==
name|MULT_EXPR
operator|&&
name|code
operator|==
name|MULT_EXPR
operator|&&
operator|(
name|t1
operator|=
name|extract_muldiv
argument_list|(
name|op1
argument_list|,
name|c
argument_list|,
name|code
argument_list|,
name|wide_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|t1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
comment|/* If these are the same operation types, we can associate them 	 assuming no overflow.  */
if|if
condition|(
name|tcode
operator|==
name|code
operator|&&
literal|0
operator|!=
operator|(
name|t1
operator|=
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|t1
argument_list|)
argument_list|)
return|;
comment|/* If these operations "cancel" each other, we have the main 	 optimizations of this pass, which occur when either constant is a 	 multiple of the other, in which case we replace this with either an 	 operation or CODE or TCODE.  	 If we have an unsigned type that is not a sizetype, we cannot do 	 this since it will change the result if the original computation 	 overflowed.  */
if|if
condition|(
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|ctype
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|ctype
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|flag_wrapv
operator|&&
operator|(
operator|(
name|code
operator|==
name|MULT_EXPR
operator|&&
name|tcode
operator|==
name|EXACT_DIV_EXPR
operator|)
operator|||
operator|(
name|tcode
operator|==
name|MULT_EXPR
operator|&&
name|code
operator|!=
name|TRUNC_MOD_EXPR
operator|&&
name|code
operator|!=
name|CEIL_MOD_EXPR
operator|&&
name|code
operator|!=
name|FLOOR_MOD_EXPR
operator|&&
name|code
operator|!=
name|ROUND_MOD_EXPR
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|tcode
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|const_binop
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|op1
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|c
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|ctype
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|const_binop
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|c
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If T contains a COMPOUND_EXPR which was inserted merely to evaluate    S, a SAVE_EXPR, return the expression actually being evaluated.   Note    that we may sometimes modify the tree.  */
end_comment

begin_function
specifier|static
name|tree
name|strip_compound_expr
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|s
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* See if this is the COMPOUND_EXPR we want to eliminate.  */
if|if
condition|(
name|code
operator|==
name|COMPOUND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|s
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
return|;
comment|/* See if this is a COND_EXPR or a simple arithmetic operator.   We      don't bother handling any other types.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|strip_compound_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a node which has the indicated constant VALUE (either 0 or    1), and is of the indicated TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|constant_boolean_node
parameter_list|(
name|int
name|value
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
return|return
name|value
condition|?
name|integer_one_node
else|:
name|integer_zero_node
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
call|(
modifier|*
name|lang_hooks
operator|.
name|truthvalue_conversion
call|)
argument_list|(
name|value
condition|?
name|integer_one_node
else|:
name|integer_zero_node
argument_list|)
return|;
else|else
block|{
name|tree
name|t
init|=
name|build_int_2
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* Utility function for the following routine, to see how complex a nesting of    COND_EXPRs can be.  EXPR is the expression and LIMIT is a count beyond which    we don't care (to avoid spending too much time on complex expressions.).  */
end_comment

begin_function
specifier|static
name|int
name|count_cond
parameter_list|(
name|tree
name|expr
parameter_list|,
name|int
name|lim
parameter_list|)
block|{
name|int
name|ctrue
decl_stmt|,
name|cfalse
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|lim
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|ctrue
operator|=
name|count_cond
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|lim
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cfalse
operator|=
name|count_cond
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
name|lim
operator|-
literal|1
operator|-
name|ctrue
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|lim
argument_list|,
literal|1
operator|+
name|ctrue
operator|+
name|cfalse
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Transform `a + (b ? x : y)' into `b ? (a + x) : (a + y)'.    Transform, `a + (x< y)' into `(x< y) ? (a + 1) : (a + 0)'.  Here    CODE corresponds to the `+', COND to the `(b ? x : y)' or `(x< y)'    expression, and ARG to `a'.  If COND_FIRST_P is nonzero, then the    COND is the first argument to CODE; otherwise (as in the example    given here), it is the second argument.  TYPE is the type of the    original expression.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_binary_op_with_conditional_arg
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|cond
parameter_list|,
name|tree
name|arg
parameter_list|,
name|int
name|cond_first_p
parameter_list|)
block|{
name|tree
name|test
decl_stmt|,
name|true_value
decl_stmt|,
name|false_value
decl_stmt|;
name|tree
name|lhs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|rhs
init|=
name|NULL_TREE
decl_stmt|;
comment|/* In the end, we'll produce a COND_EXPR.  Both arms of the      conditional expression will be binary operations.  The left-hand      side of the expression to be executed if the condition is true      will be pointed to by TRUE_LHS.  Similarly, the right-hand side      of the expression to be executed if the condition is true will be      pointed to by TRUE_RHS.  FALSE_LHS and FALSE_RHS are analogous --      but apply to the expression to be executed if the conditional is      false.  */
name|tree
modifier|*
name|true_lhs
decl_stmt|;
name|tree
modifier|*
name|true_rhs
decl_stmt|;
name|tree
modifier|*
name|false_lhs
decl_stmt|;
name|tree
modifier|*
name|false_rhs
decl_stmt|;
comment|/* These are the codes to use for the left-hand side and right-hand      side of the COND_EXPR.  Normally, they are the same as CODE.  */
name|enum
name|tree_code
name|lhs_code
init|=
name|code
decl_stmt|;
name|enum
name|tree_code
name|rhs_code
init|=
name|code
decl_stmt|;
comment|/* And these are the types of the expressions.  */
name|tree
name|lhs_type
init|=
name|type
decl_stmt|;
name|tree
name|rhs_type
init|=
name|type
decl_stmt|;
name|int
name|save
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cond_first_p
condition|)
block|{
name|true_rhs
operator|=
name|false_rhs
operator|=
operator|&
name|arg
expr_stmt|;
name|true_lhs
operator|=
operator|&
name|true_value
expr_stmt|;
name|false_lhs
operator|=
operator|&
name|false_value
expr_stmt|;
block|}
else|else
block|{
name|true_lhs
operator|=
name|false_lhs
operator|=
operator|&
name|arg
expr_stmt|;
name|true_rhs
operator|=
operator|&
name|true_value
expr_stmt|;
name|false_rhs
operator|=
operator|&
name|false_value
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|test
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|true_value
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|false_value
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If this operand throws an expression, then it does not make 	 sense to try to perform a logical or arithmetic operation 	 involving it.  Instead of building `a + throw 3' for example, 	 we simply build `a, throw 3'.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|true_value
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cond_first_p
condition|)
block|{
name|lhs_code
operator|=
name|COMPOUND_EXPR
expr_stmt|;
name|lhs_type
operator|=
name|void_type_node
expr_stmt|;
block|}
else|else
name|lhs
operator|=
name|true_value
expr_stmt|;
block|}
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|false_value
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cond_first_p
condition|)
block|{
name|rhs_code
operator|=
name|COMPOUND_EXPR
expr_stmt|;
name|rhs_type
operator|=
name|void_type_node
expr_stmt|;
block|}
else|else
name|rhs
operator|=
name|false_value
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|testtype
init|=
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|test
operator|=
name|cond
expr_stmt|;
name|true_value
operator|=
name|fold_convert
argument_list|(
name|testtype
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|false_value
operator|=
name|fold_convert
argument_list|(
name|testtype
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
comment|/* If ARG is complex we want to make sure we only evaluate it once.  Though      this is only required if it is volatile, it might be more efficient even      if it is not.  However, if we succeed in folding one part to a constant,      we do not need to make this SAVE_EXPR.  Since we do this optimization      primarily to see if we do end up with constant and this SAVE_EXPR      interferes with later optimizations, suppressing it when we can is      important.       If we are not in a function, we can't make a SAVE_EXPR, so don't try to      do so.  Don't try to see if the result is a constant if an arm is a      COND_EXPR since we get exponential behavior in that case.  */
if|if
condition|(
name|saved_expr_p
argument_list|(
name|arg
argument_list|)
condition|)
name|save
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lhs
operator|==
literal|0
operator|&&
name|rhs
operator|==
literal|0
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
operator|&&
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
call|)
argument_list|()
operator|==
literal|0
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|PARM_DECL
operator|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|true_value
argument_list|)
operator|!=
name|COND_EXPR
condition|)
name|lhs
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|lhs_code
argument_list|,
name|lhs_type
argument_list|,
operator|*
name|true_lhs
argument_list|,
operator|*
name|true_rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|false_value
argument_list|)
operator|!=
name|COND_EXPR
condition|)
name|rhs
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|rhs_code
argument_list|,
name|rhs_type
argument_list|,
operator|*
name|false_lhs
argument_list|,
operator|*
name|false_rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lhs
operator|==
literal|0
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|lhs
argument_list|)
operator|)
operator|&&
operator|(
name|rhs
operator|==
literal|0
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
block|{
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|rhs
operator|=
literal|0
expr_stmt|;
name|save
operator|=
name|saved_expr_p
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lhs
operator|==
literal|0
condition|)
name|lhs
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|lhs_code
argument_list|,
name|lhs_type
argument_list|,
operator|*
name|true_lhs
argument_list|,
operator|*
name|true_rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
literal|0
condition|)
name|rhs
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|rhs_code
argument_list|,
name|rhs_type
argument_list|,
operator|*
name|false_lhs
argument_list|,
operator|*
name|false_rhs
argument_list|)
argument_list|)
expr_stmt|;
name|test
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|test
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If ARG involves a SAVE_EXPR, we need to ensure it is evaluated      ahead of the COND_EXPR we made.  Otherwise we would have it only      evaluated in one branch, with the other branch using the result      but missing the evaluation code.  Beware that the save_expr call      above might not return a SAVE_EXPR, so testing the TREE_CODE      of ARG is not enough to decide here. */
if|if
condition|(
name|save
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|void_type_node
argument_list|,
name|arg
argument_list|)
argument_list|,
name|strip_compound_expr
argument_list|(
name|test
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
else|else
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|test
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of fold() that checks for the addition of +/- 0.0.     If !NEGATE, return true if ADDEND is +/-0.0 and, for all X of type    TYPE, X + ADDEND is the same as X.  If NEGATE, return true if X -    ADDEND is the same as X.     X + 0 and X - 0 both give X when X is NaN, infinite, or nonzero    and finite.  The problematic cases are when X is zero, and its mode    has signed zeros.  In the case of rounding towards -infinity,    X - 0 is not the same as X because 0 - 0 is -0.  In other rounding    modes, X + 0 is not the same as X because -0 + 0 is 0.  */
end_comment

begin_function
specifier|static
name|bool
name|fold_real_zero_addition_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|addend
parameter_list|,
name|int
name|negate
parameter_list|)
block|{
if|if
condition|(
operator|!
name|real_zerop
argument_list|(
name|addend
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Don't allow the fold with -fsignaling-nans.  */
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Allow the fold if zeros aren't signed, or their sign isn't important.  */
if|if
condition|(
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Treat x + -0 as x - 0 and x - -0 as x + 0.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|addend
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|addend
argument_list|)
argument_list|)
condition|)
name|negate
operator|=
operator|!
name|negate
expr_stmt|;
comment|/* The mode has signed zeros, and we have to honor their sign.      In this situation, there is only one case we can return true for.      X - 0 is the same as X unless rounding towards -infinity is      supported.  */
return|return
name|negate
operator|&&
operator|!
name|HONOR_SIGN_DEPENDENT_ROUNDING
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of fold() that checks comparisons of built-in math    functions against real constants.     FCODE is the DECL_FUNCTION_CODE of the built-in, CODE is the comparison    operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR, GE_EXPR or LE_EXPR.  TYPE    is the type of the result and ARG0 and ARG1 are the operands of the    comparison.  ARG1 must be a TREE_REAL_CST.     The function returns the constant folded tree if a simplification    can be made, and NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_mathfn_compare
parameter_list|(
name|enum
name|built_in_function
name|fcode
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_SQRT
operator|||
name|fcode
operator|==
name|BUILT_IN_SQRTF
operator|||
name|fcode
operator|==
name|BUILT_IN_SQRTL
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_NEGATIVE
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* sqrt(x)< y is always false, if y is negative.  */
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|LT_EXPR
operator|||
name|code
operator|==
name|LE_EXPR
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
comment|/* sqrt(x)> y is always true, if y is negative and we 	     don't care about NaNs, i.e. negative values of x.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|||
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
comment|/* sqrt(x)> y is the same as x>= 0, if y is negative.  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GT_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
condition|)
block|{
name|REAL_VALUE_TYPE
name|c2
decl_stmt|;
name|REAL_ARITHMETIC
argument_list|(
name|c2
argument_list|,
name|MULT_EXPR
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
operator|&
name|c2
argument_list|,
name|mode
argument_list|,
operator|&
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|c2
argument_list|)
condition|)
block|{
comment|/* sqrt(x)> y is x == +Inf, when y is very large.  */
if|if
condition|(
name|HONOR_INFINITIES
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* sqrt(x)> y is always false, when y is very large 		 and we don't care about infinities.  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
block|}
comment|/* sqrt(x)> c is the same as x> c*c.  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LT_EXPR
operator|||
name|code
operator|==
name|LE_EXPR
condition|)
block|{
name|REAL_VALUE_TYPE
name|c2
decl_stmt|;
name|REAL_ARITHMETIC
argument_list|(
name|c2
argument_list|,
name|MULT_EXPR
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|real_convert
argument_list|(
operator|&
name|c2
argument_list|,
name|mode
argument_list|,
operator|&
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|c2
argument_list|)
condition|)
block|{
comment|/* sqrt(x)< y is always true, when y is a very large 		 value and we don't care about NaNs or Infinities.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|HONOR_INFINITIES
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
comment|/* sqrt(x)< y is x != +Inf when y is very large and we 		 don't care about NaNs.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* sqrt(x)< y is x>= 0 when y is very large and we 		 don't care about Infinities.  */
if|if
condition|(
operator|!
name|HONOR_INFINITIES
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* sqrt(x)< y is x>= 0&& x != +Inf, when y is large.  */
if|if
condition|(
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
call|)
argument_list|()
operator|!=
literal|0
operator|||
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* sqrt(x)< c is the same as x< c*c, if we ignore NaNs.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* sqrt(x)< c is the same as x>= 0&& x< c*c.  */
if|if
condition|(
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
call|)
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|c2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of fold() that optimizes comparisons against Infinities,    either +Inf or -Inf.     CODE is the comparison operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR,    GE_EXPR or LE_EXPR.  TYPE is the type of the result and ARG0 and ARG1    are the operands of the comparison.  ARG1 must be a TREE_REAL_CST.     The function returns the constant folded tree if a simplification    can be made, and NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_inf_compare
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
name|max
decl_stmt|;
name|tree
name|temp
decl_stmt|;
name|bool
name|neg
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For negative infinity swap the sense of the comparison.  */
name|neg
operator|=
name|REAL_VALUE_NEGATIVE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|code
operator|=
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT_EXPR
case|:
comment|/* x> +Inf is always false, if with ignore sNANs.  */
if|if
condition|(
name|HONOR_SNANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
comment|/* x<= +Inf is always true, if we don't case about NaNs.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* x<= +Inf is the same as x == x, i.e. isfinite(x).  */
if|if
condition|(
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
call|)
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|arg0
operator|=
name|save_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|GE_EXPR
case|:
comment|/* x == +Inf and x>= +Inf are always equal to x> DBL_MAX.  */
name|real_maxval
argument_list|(
operator|&
name|max
argument_list|,
name|neg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|neg
condition|?
name|LT_EXPR
else|:
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|max
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
comment|/* x< +Inf is always equal to x<= DBL_MAX.  */
name|real_maxval
argument_list|(
operator|&
name|max
argument_list|,
name|neg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|neg
condition|?
name|GE_EXPR
else|:
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|max
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
comment|/* x != +Inf is always equal to !(x> DBL_MAX).  */
name|real_maxval
argument_list|(
operator|&
name|max
argument_list|,
name|neg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|neg
condition|?
name|GE_EXPR
else|:
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|max
argument_list|)
argument_list|)
argument_list|)
return|;
name|temp
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|neg
condition|?
name|LT_EXPR
else|:
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|max
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|temp
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* If CODE with arguments ARG0 and ARG1 represents a single bit    equality/inequality test, then return a simplified form of    the test using shifts and logical operations.  Otherwise return    NULL.  TYPE is the desired result type.  */
end_comment

begin_function
name|tree
name|fold_single_bit_test
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|result_type
parameter_list|)
block|{
comment|/* If this is a TRUTH_NOT_EXPR, it may have a single bit test inside      operand 0.  */
if|if
condition|(
name|code
operator|==
name|TRUTH_NOT_EXPR
condition|)
block|{
name|code
operator|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|NE_EXPR
operator|&&
name|code
operator|!=
name|EQ_EXPR
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Extract the arguments of the EQ/NE.  */
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This requires us to invert the code.  */
name|code
operator|=
operator|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
operator|)
expr_stmt|;
block|}
comment|/* If this is testing a single bit, we can optimize the test.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|int
name|bitnum
init|=
name|tree_log2
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|operand_mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|ops_unsigned
decl_stmt|;
name|tree
name|signed_type
decl_stmt|,
name|unsigned_type
decl_stmt|,
name|intermediate_type
decl_stmt|;
name|tree
name|arg00
decl_stmt|;
comment|/* If we have (A& C) != 0 where C is the sign bit of A, convert 	 this into A< 0.  Similarly for (A& C) == 0 into A>= 0.  */
name|arg00
operator|=
name|sign_bit_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg00
operator|!=
name|NULL_TREE
comment|/* This is only a win if casting to a signed type is cheap, 	     i.e. when arg00's type is not a partial mode.  */
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|stype
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|GE_EXPR
else|:
name|LT_EXPR
argument_list|,
name|result_type
argument_list|,
name|fold_convert
argument_list|(
name|stype
argument_list|,
name|arg00
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|stype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Otherwise we have (A& C) != 0 where C is a single bit,  	 convert that into ((A>> C2)& 1).  Where C2 = log2(C). 	 Similarly for (A& C) == 0.  */
comment|/* If INNER is a right shift of a constant and it plus BITNUM does 	 not overflow, adjust BITNUM and INNER.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|RSHIFT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|bitnum
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bitnum
operator|-
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|bitnum
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we are going to be able to omit the AND below, we must do our 	 operations as unsigned.  If we must use the AND, we have a choice. 	 Normally unsigned is faster, but for some machines signed is.  */
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
name|ops_unsigned
operator|=
operator|(
name|LOAD_EXTEND_OP
argument_list|(
name|operand_mode
argument_list|)
operator|==
name|SIGN_EXTEND
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|ops_unsigned
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|signed_type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|operand_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unsigned_type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|operand_mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intermediate_type
operator|=
name|ops_unsigned
condition|?
name|unsigned_type
else|:
name|signed_type
expr_stmt|;
name|inner
operator|=
name|fold_convert
argument_list|(
name|intermediate_type
argument_list|,
name|inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitnum
operator|!=
literal|0
condition|)
name|inner
operator|=
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|intermediate_type
argument_list|,
name|inner
argument_list|,
name|size_int
argument_list|(
name|bitnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|inner
operator|=
name|build
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|intermediate_type
argument_list|,
name|inner
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
comment|/* Put the AND last so it can combine with more things.  */
name|inner
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|intermediate_type
argument_list|,
name|inner
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
comment|/* Make sure to return the proper type.  */
name|inner
operator|=
name|fold_convert
argument_list|(
name|result_type
argument_list|,
name|inner
argument_list|)
expr_stmt|;
return|return
name|inner
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Check whether we are allowed to reorder operands arg0 and arg1,    such that the evaluation of arg1 occurs before arg0.  */
end_comment

begin_function
specifier|static
name|bool
name|reorder_operands_p
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_evaluation_order
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
operator|||
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|true
return|;
return|return
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Test whether it is preferable two swap two operands, ARG0 and    ARG1, for example because ARG0 is an integer constant and ARG1    isn't.  If REORDER is true, only recommend swapping if we can    evaluate the operands in reverse order.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_swap_operands_p
parameter_list|(
name|tree
name|arg0
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|bool
name|reorder
parameter_list|)
block|{
name|STRIP_SIGN_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_SIGN_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|optimize_size
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reorder
operator|&&
name|flag_evaluation_order
operator|&&
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_P
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_P
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Perform constant folding and related simplification of EXPR.    The related simplifications include x*1 => x, x*0 => 0, etc.,    and application of the associative law.    NOP_EXPR conversions may be removed freely (as long as we    are careful not to change the C type of the overall expression)    We cannot simplify through a CONVERT_EXPR, FIX_EXPR or FLOAT_EXPR,    but we can constant-fold them if they have constant operands.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_FOLD_CHECKING
end_ifdef

begin_define
define|#
directive|define
name|fold
parameter_list|(
name|x
parameter_list|)
value|fold_1 (x)
end_define

begin_function_decl
specifier|static
name|tree
name|fold_1
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
endif|#
directive|endif
name|tree
name|fold
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|t
init|=
name|expr
decl_stmt|,
name|orig_t
decl_stmt|;
name|tree
name|t1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|NULL_TREE
decl_stmt|,
name|arg1
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|kind
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|invert
decl_stmt|;
comment|/* WINS will be nonzero when the switch is done      if all operands are constant.  */
name|int
name|wins
init|=
literal|1
decl_stmt|;
comment|/* Don't try to process an RTL_EXPR since its operands aren't trees.      Likewise for a SAVE_EXPR that's already been evaluated.  */
if|if
condition|(
name|code
operator|==
name|RTL_EXPR
operator|||
operator|(
name|code
operator|==
name|SAVE_EXPR
operator|&&
name|SAVE_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|t
return|;
comment|/* Return right away if a constant.  */
if|if
condition|(
name|kind
operator|==
literal|'c'
condition|)
return|return
name|t
return|;
name|orig_t
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|FLOAT_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|tree
name|subop
decl_stmt|;
comment|/* Special case for conversion ops that can have fixed point args.  */
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't use STRIP_NOPS, because signedness of argument type matters.  */
if|if
condition|(
name|arg0
operator|!=
literal|0
condition|)
name|STRIP_SIGN_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
name|subop
operator|=
name|TREE_REALPART
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
else|else
name|subop
operator|=
name|arg0
expr_stmt|;
if|if
condition|(
name|subop
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|subop
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|subop
argument_list|)
operator|!=
name|REAL_CST
condition|)
comment|/* Note that TREE_CONSTANT isn't enough: 	   static var addresses are constant but we can't 	   do arithmetic on them.  */
name|wins
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|kind
argument_list|)
condition|)
block|{
name|int
name|len
init|=
name|first_rtl_op
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|subop
decl_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
continue|continue;
comment|/* Valid for CALL_EXPR, at least.  */
if|if
condition|(
name|kind
operator|==
literal|'<'
operator|||
name|code
operator|==
name|RSHIFT_EXPR
condition|)
block|{
comment|/* Signedness matters here.  Perhaps we can refine this 		 later.  */
name|STRIP_SIGN_NOPS
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Strip any conversions that don't change the mode.  */
name|STRIP_NOPS
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
name|subop
operator|=
name|TREE_REALPART
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|subop
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|subop
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|subop
argument_list|)
operator|!=
name|REAL_CST
condition|)
comment|/* Note that TREE_CONSTANT isn't enough: 	       static var addresses are constant but we can't 	       do arithmetic on them.  */
name|wins
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|arg0
operator|=
name|op
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|arg1
operator|=
name|op
expr_stmt|;
block|}
block|}
comment|/* If this is a commutative operation, and ARG0 is a constant, move it      to ARG1 to reduce the number of tests below.  */
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MULT_EXPR
operator|||
name|code
operator|==
name|MIN_EXPR
operator|||
name|code
operator|==
name|MAX_EXPR
operator|||
name|code
operator|==
name|BIT_IOR_EXPR
operator|||
name|code
operator|==
name|BIT_XOR_EXPR
operator|||
name|code
operator|==
name|BIT_AND_EXPR
operator|)
operator|&&
name|tree_swap_operands_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Now WINS is set as described above,      ARG0 is the first operand of EXPR,      and ARG1 is the second operand (if it has more than one operand).       First check for cases where an arithmetic operation is applied to a      compound, conditional, or comparison operation.  Push the arithmetic      operation inside the compound or conditional to see if any folding      can then be done.  Convert comparison to conditional for this purpose.      The also optimizes non-constant cases that used to be done in      expand_expr.       Before we do that, see if this is a BIT_AND_EXPR or a BIT_IOR_EXPR,      one of the operands is a comparison and the other is a comparison, a      BIT_AND_EXPR with the constant 1, or a truth value.  In that case, the      code below would make the expression more complex.  Change it to a      TRUTH_{AND,OR}_EXPR.  Likewise, convert a similar NE_EXPR to      TRUTH_XOR_EXPR and an EQ_EXPR to the inversion of a TRUTH_XOR_EXPR.  */
if|if
condition|(
operator|(
name|code
operator|==
name|BIT_AND_EXPR
operator|||
name|code
operator|==
name|BIT_IOR_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
operator|(
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|&&
operator|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
operator|==
name|BIT_AND_EXPR
condition|?
name|TRUTH_AND_EXPR
else|:
name|code
operator|==
name|BIT_IOR_EXPR
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|t
operator|=
name|invert_truthvalue
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|tree
name|arg01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg02
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg01
argument_list|)
argument_list|)
condition|)
name|arg01
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg01
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg02
argument_list|)
argument_list|)
condition|)
name|arg02
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg02
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg01
argument_list|,
name|arg02
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this was a conversion, and all we did was to move into 	     inside the COND_EXPR, bring it back out.  But leave it if 	     it is a conversion from integer to integer and the 	     result precision is no wider than a word since such a 	     conversion is cheap and may be optimized away by combine, 	     while it couldn't if it were outside the COND_EXPR.  Then return 	     so we don't get into an infinite recursion loop taking the 	     conversion out and then back in.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_WORD
operator|)
condition|)
name|t
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COND_EXPR
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
operator|)
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|COND_EXPR
operator|||
name|count_cond
argument_list|(
name|arg0
argument_list|,
literal|25
argument_list|)
operator|+
name|count_cond
argument_list|(
name|arg1
argument_list|,
literal|25
argument_list|)
operator|<=
literal|25
operator|)
operator|&&
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|||
operator|(
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
call|)
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|arg0
argument_list|)
operator|)
operator|)
condition|)
return|return
name|fold_binary_op_with_conditional_arg
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|,
comment|/*cond_first_p=*/
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COND_EXPR
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
operator|)
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|COND_EXPR
operator|||
name|count_cond
argument_list|(
name|arg0
argument_list|,
literal|25
argument_list|)
operator|+
name|count_cond
argument_list|(
name|arg1
argument_list|,
literal|25
argument_list|)
operator|<=
literal|25
operator|)
operator|&&
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
operator|||
operator|(
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|global_bindings_p
call|)
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|arg1
argument_list|)
operator|)
operator|)
condition|)
return|return
name|fold_binary_op_with_conditional_arg
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
comment|/*cond_first_p=*/
literal|1
argument_list|)
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|CONSTRUCTOR
case|:
return|return
name|t
return|;
case|case
name|CONST_DECL
case|:
return|return
name|fold
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
comment|/* Other kinds of FIX are not handled properly by fold_convert.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Handle cases of two conversions in a row.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|tree
name|inside_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|inter_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|final_type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|inside_int
init|=
name|INTEGRAL_TYPE_P
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inside_ptr
init|=
name|POINTER_TYPE_P
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inside_float
init|=
name|FLOAT_TYPE_P
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|inside_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inside_unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|inside_type
argument_list|)
decl_stmt|;
name|int
name|inter_int
init|=
name|INTEGRAL_TYPE_P
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|inter_ptr
init|=
name|POINTER_TYPE_P
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|inter_float
init|=
name|FLOAT_TYPE_P
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|inter_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|inter_unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|inter_type
argument_list|)
decl_stmt|;
name|int
name|final_int
init|=
name|INTEGRAL_TYPE_P
argument_list|(
name|final_type
argument_list|)
decl_stmt|;
name|int
name|final_ptr
init|=
name|POINTER_TYPE_P
argument_list|(
name|final_type
argument_list|)
decl_stmt|;
name|int
name|final_float
init|=
name|FLOAT_TYPE_P
argument_list|(
name|final_type
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|final_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|final_type
argument_list|)
decl_stmt|;
name|int
name|final_unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
decl_stmt|;
comment|/* In addition to the cases of two conversions in a row 	     handled below, if we are converting something to its own 	     type via an object of identical or wider precision, neither 	     conversion is needed.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|inside_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|final_type
argument_list|)
operator|&&
operator|(
operator|(
name|inter_int
operator|&&
name|final_int
operator|)
operator|||
operator|(
name|inter_float
operator|&&
name|final_float
operator|)
operator|)
operator|&&
name|inter_prec
operator|>=
name|final_prec
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|final_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Likewise, if the intermediate and final types are either both 	     float or both integer, we don't need the middle conversion if 	     it is wider than the final type and doesn't change the signedness 	     (for integers).  Avoid this if the final type is a pointer 	     since then we sometimes need the inner conversion.  Likewise if 	     the outer has a precision not equal to the size of its mode.  */
if|if
condition|(
operator|(
operator|(
operator|(
name|inter_int
operator|||
name|inter_ptr
operator|)
operator|&&
operator|(
name|inside_int
operator|||
name|inside_ptr
operator|)
operator|)
operator|||
operator|(
name|inter_float
operator|&&
name|inside_float
operator|)
operator|)
operator|&&
name|inter_prec
operator|>=
name|inside_prec
operator|&&
operator|(
name|inter_float
operator|||
name|inter_unsignedp
operator|==
name|inside_unsignedp
operator|)
operator|&&
operator|!
operator|(
name|final_prec
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|final_type
argument_list|)
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|final_type
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|inter_type
argument_list|)
operator|)
operator|&&
operator|!
name|final_ptr
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|final_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If we have a sign-extension of a zero-extended value, we can 	     replace that by a single zero-extension.  */
if|if
condition|(
name|inside_int
operator|&&
name|inter_int
operator|&&
name|final_int
operator|&&
name|inside_prec
operator|<
name|inter_prec
operator|&&
name|inter_prec
operator|<
name|final_prec
operator|&&
name|inside_unsignedp
operator|&&
operator|!
name|inter_unsignedp
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|final_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Two conversions in a row are not needed unless: 	     - some conversion is floating-point (overstrict for now), or 	     - the intermediate type is narrower than both initial and 	       final, or 	     - the intermediate type and innermost type differ in signedness, 	       and the outermost type is wider than the intermediate, or 	     - the initial type is a pointer type and the precisions of the 	       intermediate and final types differ, or 	     - the final type is a pointer type and the precisions of the 	       initial and intermediate types differ.  */
if|if
condition|(
operator|!
name|inside_float
operator|&&
operator|!
name|inter_float
operator|&&
operator|!
name|final_float
operator|&&
operator|(
name|inter_prec
operator|>
name|inside_prec
operator|||
name|inter_prec
operator|>
name|final_prec
operator|)
operator|&&
operator|!
operator|(
name|inside_int
operator|&&
name|inter_int
operator|&&
name|inter_unsignedp
operator|!=
name|inside_unsignedp
operator|&&
name|inter_prec
operator|<
name|final_prec
operator|)
operator|&&
operator|(
operator|(
name|inter_unsignedp
operator|&&
name|inter_prec
operator|>
name|inside_prec
operator|)
operator|==
operator|(
name|final_unsignedp
operator|&&
name|final_prec
operator|>
name|inter_prec
operator|)
operator|)
operator|&&
operator|!
operator|(
name|inside_ptr
operator|&&
name|inter_prec
operator|!=
name|final_prec
operator|)
operator|&&
operator|!
operator|(
name|final_ptr
operator|&&
name|inside_prec
operator|!=
name|inter_prec
operator|)
operator|&&
operator|!
operator|(
name|final_prec
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|final_type
argument_list|)
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|final_type
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|inter_type
argument_list|)
operator|)
operator|&&
operator|!
name|final_ptr
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|final_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
comment|/* Detect assigning a bitfield.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Don't leave an assignment inside a conversion 	     unless assigning a bitfield.  */
name|tree
name|prev
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|orig_t
condition|)
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* First do the assignment, then return converted constant.  */
name|t
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|prev
argument_list|,
name|fold
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* Convert (T)(x& c) into (T)x& (T)c, if c is an integer 	 constants (if x has signed type, the sign bit cannot be set 	 in c).  This folds extension into the BIT_AND_EXPR.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|BOOLEAN_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|and
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|and0
init|=
name|TREE_OPERAND
argument_list|(
name|and
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|and1
init|=
name|TREE_OPERAND
argument_list|(
name|and
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|change
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|and
argument_list|)
argument_list|)
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|and
argument_list|)
argument_list|)
operator|)
condition|)
name|change
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|and1
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|host_integerp
argument_list|(
name|and1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|cst
decl_stmt|;
name|cst
operator|=
name|tree_low_cst
argument_list|(
name|and1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cst
operator|&=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|and1
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|change
operator|=
operator|(
name|cst
operator|==
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
if|if
condition|(
name|change
operator|&&
operator|(
name|LOAD_EXTEND_OP
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|and0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
condition|)
block|{
name|tree
name|uns
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|and0
argument_list|)
argument_list|)
decl_stmt|;
name|and0
operator|=
name|fold_convert
argument_list|(
name|uns
argument_list|,
name|and0
argument_list|)
expr_stmt|;
name|and1
operator|=
name|fold_convert
argument_list|(
name|uns
argument_list|,
name|and1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|change
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|and0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|and1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|tem
operator|=
name|fold_convert_const
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
return|return
name|tem
condition|?
name|tem
else|:
name|t
return|;
case|case
name|VIEW_CONVERT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
condition|)
return|return
name|build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
operator|!
name|type_contains_placeholder_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|m
init|=
name|purpose_member
argument_list|(
name|arg1
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|RANGE_EXPR
case|:
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|!=
name|wins
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|orig_t
condition|)
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|wins
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
name|negate_expr_p
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
name|wins
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* If the value is unsigned, then the absolute value is 		 the same as the ordinary value.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|arg0
return|;
comment|/* Similarly, if the value is non-negative.  */
elseif|else
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|integer_minus_one_node
argument_list|,
name|arg0
argument_list|)
condition|)
return|return
name|arg0
return|;
comment|/* If the value is negative, then the absolute value is 		 its negation.  */
else|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|int
name|overflow
init|=
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|TREE_OVERFLOW
argument_list|(
name|arg0
argument_list|)
operator||
name|force_fit_type
argument_list|(
name|t
argument_list|,
name|overflow
argument_list|)
operator|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|REAL_VALUE_NEGATIVE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Convert fabs((double)float) into (double)fabsf(float).  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
name|tree
name|targ0
init|=
name|strip_float_extensions
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
if|if
condition|(
name|targ0
operator|!=
name|arg0
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|targ0
argument_list|)
argument_list|,
name|targ0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|tree_expr_nonnegative_p
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg0
return|;
return|return
name|t
return|;
case|case
name|CONJ_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|build_complex
argument_list|(
name|type
argument_list|,
name|TREE_REALPART
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|CONJ_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|CONJ_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONJ_EXPR
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|wins
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|PLUS_EXPR
case|:
comment|/* A + (-B) -> A - B */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* (-A) + B -> B - A */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If we are adding two BIT_AND_EXPR's, both of which are and'ing 	     with a constant, and the two constants have no bits in common, 	     we should treat this as a BIT_IOR_EXPR since this may produce more 	     simplifications.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
goto|goto
name|bit_ior
goto|;
block|}
comment|/* Reassociate (plus (plus (mult) (foo)) (mult)) as 	     (plus (plus (mult) (mult)) (foo)) so that we can 	     take advantage of the factoring cases below.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|)
condition|)
block|{
name|tree
name|parg0
decl_stmt|,
name|parg1
decl_stmt|,
name|parg
decl_stmt|,
name|marg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
name|parg
operator|=
name|arg0
operator|,
name|marg
operator|=
name|arg1
expr_stmt|;
else|else
name|parg
operator|=
name|arg1
operator|,
name|marg
operator|=
name|arg0
expr_stmt|;
name|parg0
operator|=
name|TREE_OPERAND
argument_list|(
name|parg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parg1
operator|=
name|TREE_OPERAND
argument_list|(
name|parg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|parg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|parg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parg0
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|parg1
argument_list|)
operator|!=
name|MULT_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|parg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|marg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|parg1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parg0
argument_list|)
operator|!=
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|parg1
argument_list|)
operator|==
name|MULT_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|parg1
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|marg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|parg0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
condition|)
block|{
name|tree
name|arg00
decl_stmt|,
name|arg01
decl_stmt|,
name|arg10
decl_stmt|,
name|arg11
decl_stmt|;
name|tree
name|alt0
init|=
name|NULL_TREE
decl_stmt|,
name|alt1
init|=
name|NULL_TREE
decl_stmt|,
name|same
decl_stmt|;
comment|/* (A * C) + (B * C) -> (A+B) * C. 		 We are most concerned about the case where C is a constant, 		 but other combinations show up during loop reduction.  Since 		 it is not difficult, try all four possibilities.  */
name|arg00
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg01
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg10
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg11
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|same
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|arg11
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg01
operator|,
name|alt0
operator|=
name|arg00
operator|,
name|alt1
operator|=
name|arg10
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg00
operator|,
name|alt0
operator|=
name|arg01
operator|,
name|alt1
operator|=
name|arg11
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg11
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg00
operator|,
name|alt0
operator|=
name|arg01
operator|,
name|alt1
operator|=
name|arg10
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
condition|)
name|same
operator|=
name|arg01
operator|,
name|alt0
operator|=
name|arg00
operator|,
name|alt1
operator|=
name|arg11
expr_stmt|;
comment|/* No identical multiplicands; see if we can find a common 		 power-of-two factor in non-power-of-two multiplies.  This 		 can help in multi-dimensional array access.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg11
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg01
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg11
argument_list|)
operator|==
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|int01
decl_stmt|,
name|int11
decl_stmt|,
name|tmp
decl_stmt|;
name|int01
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg01
argument_list|)
expr_stmt|;
name|int11
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg11
argument_list|)
expr_stmt|;
comment|/* Move min of absolute values to int11.  */
if|if
condition|(
operator|(
name|int01
operator|>=
literal|0
condition|?
name|int01
else|:
operator|-
name|int01
operator|)
operator|<
operator|(
name|int11
operator|>=
literal|0
condition|?
name|int11
else|:
operator|-
name|int11
operator|)
condition|)
block|{
name|tmp
operator|=
name|int01
operator|,
name|int01
operator|=
name|int11
operator|,
name|int11
operator|=
name|tmp
expr_stmt|;
name|alt0
operator|=
name|arg00
operator|,
name|arg00
operator|=
name|arg10
operator|,
name|arg10
operator|=
name|alt0
expr_stmt|;
name|alt0
operator|=
name|arg01
operator|,
name|arg01
operator|=
name|arg11
operator|,
name|arg11
operator|=
name|alt0
expr_stmt|;
block|}
if|if
condition|(
name|exact_log2
argument_list|(
name|int11
argument_list|)
operator|>
literal|0
operator|&&
name|int01
operator|%
name|int11
operator|==
literal|0
condition|)
block|{
name|alt0
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|build_int_2
argument_list|(
name|int01
operator|/
name|int11
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|alt1
operator|=
name|arg10
expr_stmt|;
name|same
operator|=
name|arg11
expr_stmt|;
block|}
block|}
if|if
condition|(
name|same
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|alt0
argument_list|,
name|alt1
argument_list|)
argument_list|)
argument_list|,
name|same
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* See if ARG1 is zero and X + ARG1 reduces to X.  */
if|if
condition|(
name|fold_real_zero_addition_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Likewise if the operands are reversed.  */
if|if
condition|(
name|fold_real_zero_addition_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* Convert x+x into x*2.0.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|&&
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Convert x*c+x into x*(c+1).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|c
argument_list|,
name|PLUS_EXPR
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|dconst1
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|c
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Convert x+x*c into x*(c+1).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|c
argument_list|,
name|PLUS_EXPR
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|dconst1
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|c
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Convert x*c1+x*c2 into x*(c1+c2).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|c1
operator|=
name|TREE_REAL_CST
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|c2
operator|=
name|TREE_REAL_CST
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|c1
argument_list|,
name|PLUS_EXPR
argument_list|,
operator|&
name|c1
argument_list|,
operator|&
name|c2
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|c1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
name|bit_rotate
label|:
comment|/* (A<< C1) + (A>> C2) if A is unsigned and C1+C2 is the size of A 	 is a rotate of A by C1 bits.  */
comment|/* (A<< B) + (A>> (Z - B)) if A is unsigned and Z is the size of A 	 is a rotate of A by B bits.  */
block|{
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|code0
operator|==
name|RSHIFT_EXPR
operator|&&
name|code1
operator|==
name|LSHIFT_EXPR
operator|)
operator|||
operator|(
name|code1
operator|==
name|RSHIFT_EXPR
operator|&&
name|code0
operator|==
name|LSHIFT_EXPR
operator|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tree01
decl_stmt|,
name|tree11
decl_stmt|;
name|enum
name|tree_code
name|code01
decl_stmt|,
name|code11
decl_stmt|;
name|tree01
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tree11
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree01
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree11
argument_list|)
expr_stmt|;
name|code01
operator|=
name|TREE_CODE
argument_list|(
name|tree01
argument_list|)
expr_stmt|;
name|code11
operator|=
name|TREE_CODE
argument_list|(
name|tree11
argument_list|)
expr_stmt|;
if|if
condition|(
name|code01
operator|==
name|INTEGER_CST
operator|&&
name|code11
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|tree01
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|tree11
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|tree01
argument_list|)
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|tree11
argument_list|)
operator|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|build
argument_list|(
name|LROTATE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code0
operator|==
name|LSHIFT_EXPR
condition|?
name|tree01
else|:
name|tree11
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code11
operator|==
name|MINUS_EXPR
condition|)
block|{
name|tree
name|tree110
decl_stmt|,
name|tree111
decl_stmt|;
name|tree110
operator|=
name|TREE_OPERAND
argument_list|(
name|tree11
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tree111
operator|=
name|TREE_OPERAND
argument_list|(
name|tree11
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree110
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree111
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tree110
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|==
name|compare_tree_int
argument_list|(
name|tree110
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|tree01
argument_list|,
name|tree111
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build
argument_list|(
operator|(
name|code0
operator|==
name|LSHIFT_EXPR
condition|?
name|LROTATE_EXPR
else|:
name|RROTATE_EXPR
operator|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree01
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code01
operator|==
name|MINUS_EXPR
condition|)
block|{
name|tree
name|tree010
decl_stmt|,
name|tree011
decl_stmt|;
name|tree010
operator|=
name|TREE_OPERAND
argument_list|(
name|tree01
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tree011
operator|=
name|TREE_OPERAND
argument_list|(
name|tree01
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree010
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|tree011
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tree010
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|==
name|compare_tree_int
argument_list|(
name|tree010
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|tree11
argument_list|,
name|tree011
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build
argument_list|(
operator|(
name|code0
operator|!=
name|LSHIFT_EXPR
condition|?
name|LROTATE_EXPR
else|:
name|RROTATE_EXPR
operator|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree11
argument_list|)
return|;
block|}
block|}
block|}
name|associate
label|:
comment|/* In most languages, can't associate operations on floats through 	 parentheses.  Rather than remember where the parentheses were, we 	 don't associate floats at all, unless the user has specified 	 -funsafe-math-optimizations.  */
if|if
condition|(
operator|!
name|wins
operator|&&
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
condition|)
block|{
name|tree
name|var0
decl_stmt|,
name|con0
decl_stmt|,
name|lit0
decl_stmt|,
name|minus_lit0
decl_stmt|;
name|tree
name|var1
decl_stmt|,
name|con1
decl_stmt|,
name|lit1
decl_stmt|,
name|minus_lit1
decl_stmt|;
comment|/* Split both trees into variables, constants, and literals.  Then 	     associate each group together, the constants with literals, 	     then the result with variables.  This increases the chances of 	     literals being recombined later and of generating relocatable 	     expressions for the sum of a constant and literal.  */
name|var0
operator|=
name|split_tree
argument_list|(
name|arg0
argument_list|,
name|code
argument_list|,
operator|&
name|con0
argument_list|,
operator|&
name|lit0
argument_list|,
operator|&
name|minus_lit0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|var1
operator|=
name|split_tree
argument_list|(
name|arg1
argument_list|,
name|code
argument_list|,
operator|&
name|con1
argument_list|,
operator|&
name|lit1
argument_list|,
operator|&
name|minus_lit1
argument_list|,
name|code
operator|==
name|MINUS_EXPR
argument_list|)
expr_stmt|;
comment|/* Only do something if we found more than two objects.  Otherwise, 	     nothing has changed and we risk infinite recursion.  */
if|if
condition|(
literal|2
operator|<
operator|(
operator|(
name|var0
operator|!=
literal|0
operator|)
operator|+
operator|(
name|var1
operator|!=
literal|0
operator|)
operator|+
operator|(
name|con0
operator|!=
literal|0
operator|)
operator|+
operator|(
name|con1
operator|!=
literal|0
operator|)
operator|+
operator|(
name|lit0
operator|!=
literal|0
operator|)
operator|+
operator|(
name|lit1
operator|!=
literal|0
operator|)
operator|+
operator|(
name|minus_lit0
operator|!=
literal|0
operator|)
operator|+
operator|(
name|minus_lit1
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Recombine MINUS_EXPR operands by using PLUS_EXPR.  */
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
name|var0
operator|=
name|associate_trees
argument_list|(
name|var0
argument_list|,
name|var1
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|con0
operator|=
name|associate_trees
argument_list|(
name|con0
argument_list|,
name|con1
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|lit0
operator|=
name|associate_trees
argument_list|(
name|lit0
argument_list|,
name|lit1
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|minus_lit0
operator|=
name|associate_trees
argument_list|(
name|minus_lit0
argument_list|,
name|minus_lit1
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Preserve the MINUS_EXPR if the negative part of the literal is 		 greater than the positive part.  Otherwise, the multiplicative 		 folding code (i.e extract_muldiv) may be fooled in case 		 unsigned constants are subtracted, like in the following 		 example: ((X*2 + 4) - 8U)/2.  */
if|if
condition|(
name|minus_lit0
operator|&&
name|lit0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lit0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|minus_lit0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|lit0
argument_list|,
name|minus_lit0
argument_list|)
condition|)
block|{
name|minus_lit0
operator|=
name|associate_trees
argument_list|(
name|minus_lit0
argument_list|,
name|lit0
argument_list|,
name|MINUS_EXPR
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|lit0
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lit0
operator|=
name|associate_trees
argument_list|(
name|lit0
argument_list|,
name|minus_lit0
argument_list|,
name|MINUS_EXPR
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|minus_lit0
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|minus_lit0
condition|)
block|{
if|if
condition|(
name|con0
operator|==
literal|0
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|associate_trees
argument_list|(
name|var0
argument_list|,
name|minus_lit0
argument_list|,
name|MINUS_EXPR
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
else|else
block|{
name|con0
operator|=
name|associate_trees
argument_list|(
name|con0
argument_list|,
name|minus_lit0
argument_list|,
name|MINUS_EXPR
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|associate_trees
argument_list|(
name|var0
argument_list|,
name|con0
argument_list|,
name|PLUS_EXPR
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
block|}
name|con0
operator|=
name|associate_trees
argument_list|(
name|con0
argument_list|,
name|lit0
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|associate_trees
argument_list|(
name|var0
argument_list|,
name|con0
argument_list|,
name|code
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
block|}
name|binary
label|:
if|if
condition|(
name|wins
condition|)
name|t1
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* The return value should always have 	     the same type as the original expression.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
name|t1
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t1
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
return|return
name|t
return|;
case|case
name|MINUS_EXPR
case|:
comment|/* A - (-B) -> A + B */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* (-A) - B -> (-B) - A  where B is easily negated and we can swap.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
operator|(
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|flag_wrapv
operator|&&
operator|!
name|flag_trapv
operator|)
operator|)
operator|&&
name|negate_expr_p
argument_list|(
name|arg1
argument_list|)
operator|&&
name|reorder_operands_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|wins
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|negate_expr
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* (A * C) - (B * C) -> (A-B) * C.  Since we are most concerned 	     about the case where C is a constant, just try one of the 	     four possibilities.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Fold A - (A& B) into ~B& A.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|)
block|{
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fold (A& ~B) - (A& B) into (A ^ B) - B, where B is 	     any power of 2 minus 1.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|mask0
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|mask1
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|tem
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|mask0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|tem
argument_list|,
name|mask1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_XOR_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mask1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|mask1
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
comment|/* See if ARG1 is zero and X - ARG1 reduces to X.  */
elseif|else
if|if
condition|(
name|fold_real_zero_addition_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* (ARG0 - ARG1) is the same as (-ARG1 + ARG0).  So check whether 	 ARG0 is zero and X + ARG0 reduces to X, since that would mean 	 (-ARG1 + ARG0) reduces to -ARG1.  */
elseif|else
if|if
condition|(
operator|!
name|wins
operator|&&
name|fold_real_zero_addition_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|negate_expr
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* Fold&x -&x.  This can happen from&x.foo -&x. 	 This is unsafe for certain floats even in non-IEEE formats. 	 In IEEE, it is unsafe because it does wrong for NaNs. 	 Also note that operand_equal_p is always false if an operand 	 is volatile.  */
if|if
condition|(
operator|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|flag_unsafe_math_optimizations
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|MULT_EXPR
case|:
comment|/* (-A) * (-B) -> A * B  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|negate_expr_p
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|negate_expr_p
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* (a * (1<< b)) is (a<< b)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|extract_muldiv
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|code
argument_list|,
name|NULL_TREE
argument_list|)
operator|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Maybe fold x * 0 to 0.  The expressions aren't the same 	     when x is NaN, since x * 0 is also NaN.  Nor are they the 	     same in modes with signed zeros, since multiplying a 	     negative value by 0 gives -0, not +0.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* In IEEE floating point, x*1 is not equivalent to x for snans.  */
if|if
condition|(
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Transform x * -1.0 into -x.  */
if|if
condition|(
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_minus_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Convert (C1/X)*C2 into (C1*C2)/X.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RDIV_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|tree
name|tem
init|=
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
name|enum
name|built_in_function
name|fcode0
init|=
name|builtin_mathfn_code
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode1
init|=
name|builtin_mathfn_code
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
comment|/* Optimizations of sqrt(...)*sqrt(...).  */
if|if
condition|(
operator|(
name|fcode0
operator|==
name|BUILT_IN_SQRT
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SQRT
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_SQRTF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SQRTF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_SQRTL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SQRTL
operator|)
condition|)
block|{
name|tree
name|sqrtfn
decl_stmt|,
name|arg
decl_stmt|,
name|arglist
decl_stmt|;
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg10
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Optimize sqrt(x)*sqrt(x) as x.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|arg00
return|;
comment|/* Optimize sqrt(x)*sqrt(y) as sqrt(x*y).  */
name|sqrtfn
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|arg10
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|sqrtfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimize expN(x)*expN(y) as expN(x+y).  */
if|if
condition|(
name|fcode0
operator|==
name|fcode1
operator|&&
operator|(
name|fcode0
operator|==
name|BUILT_IN_EXP
operator|||
name|fcode0
operator|==
name|BUILT_IN_EXPF
operator|||
name|fcode0
operator|==
name|BUILT_IN_EXPL
operator|||
name|fcode0
operator|==
name|BUILT_IN_EXP2
operator|||
name|fcode0
operator|==
name|BUILT_IN_EXP2F
operator|||
name|fcode0
operator|==
name|BUILT_IN_EXP2L
operator|||
name|fcode0
operator|==
name|BUILT_IN_EXP10
operator|||
name|fcode0
operator|==
name|BUILT_IN_EXP10F
operator|||
name|fcode0
operator|==
name|BUILT_IN_EXP10L
operator|||
name|fcode0
operator|==
name|BUILT_IN_POW10
operator|||
name|fcode0
operator|==
name|BUILT_IN_POW10F
operator|||
name|fcode0
operator|==
name|BUILT_IN_POW10L
operator|)
condition|)
block|{
name|tree
name|expfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|expfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimizations of pow(...)*pow(...).  */
if|if
condition|(
operator|(
name|fcode0
operator|==
name|BUILT_IN_POW
operator|&&
name|fcode1
operator|==
name|BUILT_IN_POW
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_POWF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_POWF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_POWL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_POWL
operator|)
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg10
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg11
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Optimize pow(x,y)*pow(z,y) as pow(x*z,y).  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg01
argument_list|,
name|arg11
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|arg10
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fold
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg01
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
comment|/* Optimize pow(x,y)*pow(x,z) as pow(x,y+z).  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg00
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg01
argument_list|,
name|arg11
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg00
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Optimize tan(x)*cos(x) as sin(x).  */
if|if
condition|(
operator|(
operator|(
name|fcode0
operator|==
name|BUILT_IN_TAN
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COS
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_TANF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COSF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_TANL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COSL
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_COS
operator|&&
name|fcode1
operator|==
name|BUILT_IN_TAN
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_COSF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_TANF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_COSL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_TANL
operator|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|sinfn
decl_stmt|;
switch|switch
condition|(
name|fcode0
condition|)
block|{
case|case
name|BUILT_IN_TAN
case|:
case|case
name|BUILT_IN_COS
case|:
name|sinfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SIN
index|]
expr_stmt|;
break|break;
case|case
name|BUILT_IN_TANF
case|:
case|case
name|BUILT_IN_COSF
case|:
name|sinfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SINF
index|]
expr_stmt|;
break|break;
case|case
name|BUILT_IN_TANL
case|:
case|case
name|BUILT_IN_COSL
case|:
name|sinfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SINL
index|]
expr_stmt|;
break|break;
default|default:
name|sinfn
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|sinfn
operator|!=
name|NULL_TREE
condition|)
return|return
name|build_function_call_expr
argument_list|(
name|sinfn
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Optimize x*pow(x,c) as pow(x,c+1).  */
if|if
condition|(
name|fcode1
operator|==
name|BUILT_IN_POW
operator|||
name|fcode1
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode1
operator|==
name|BUILT_IN_POWL
condition|)
block|{
name|tree
name|arg10
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg11
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg11
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg11
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg10
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|arglist
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg11
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|c
argument_list|,
name|PLUS_EXPR
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|dconst1
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Optimize pow(x,c)*x as pow(x,c+1).  */
if|if
condition|(
name|fcode0
operator|==
name|BUILT_IN_POW
operator|||
name|fcode0
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode0
operator|==
name|BUILT_IN_POWL
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg01
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg00
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|arglist
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg01
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|c
argument_list|,
name|PLUS_EXPR
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|dconst1
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
comment|/* Optimize x*x as pow(x,2.0), which is expanded as x*x.  */
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|double_type_node
condition|)
name|powfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_POW
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|powfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_POWF
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|powfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_POWL
index|]
expr_stmt|;
else|else
name|powfn
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|powfn
condition|)
block|{
name|tree
name|arg
init|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst2
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg0
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
block|}
block|}
goto|goto
name|associate
goto|;
case|case
name|BIT_IOR_EXPR
case|:
name|bit_ior
label|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
name|t1
operator|=
name|distribute_bit_expr
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
return|return
name|t1
return|;
comment|/* Convert (or (not arg0) (not arg1)) to (not (and (arg0) (arg1))).  	 This results in more efficient code for machines without a NAND 	 instruction.  Combine will canonicalize to the first form 	 which will allow use of NAND instructions provided by the 	 backend if they exist.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* See if this can be simplified into a rotate first.  If that 	 is unsuccessful continue in the association code.  */
goto|goto
name|bit_rotate
goto|;
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If we are XORing two BIT_AND_EXPR's, both of which are and'ing          with a constant, and the two constants have no bits in common, 	 we should treat this as a BIT_IOR_EXPR since this may produce more 	 simplifications.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
goto|goto
name|bit_ior
goto|;
block|}
comment|/* See if this can be simplified into a rotate first.  If that 	 is unsuccessful continue in the association code.  */
goto|goto
name|bit_rotate
goto|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
name|t1
operator|=
name|distribute_bit_expr
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
return|return
name|t1
return|;
comment|/* Simplify ((int)c& 0377) into (int)c, if c is unsigned char.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prec
operator|<
name|BITS_PER_WORD
operator|&&
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Convert (and (not arg0) (not arg1)) to (not (or (arg0) (arg1))).  	 This results in more efficient code for machines without a NOR 	 instruction.  Combine will canonicalize to the first form 	 which will allow use of NOR instructions provided by the 	 backend if they exist.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
goto|goto
name|associate
goto|;
case|case
name|RDIV_EXPR
case|:
comment|/* Don't touch a floating-point divide by zero unless the mode 	 of the constant can represent infinity.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|MODE_HAS_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* (-A) / (-B) -> A / B  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|negate_expr_p
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negate_expr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|negate_expr_p
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* In IEEE floating point, x/1 is not equivalent to x for snans.  */
if|if
condition|(
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* In IEEE floating point, x/-1 is not equivalent to -x for snans.  */
if|if
condition|(
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|real_minus_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If ARG1 is a constant, we can convert this to a multiply by the 	 reciprocal.  This does not have the same rounding properties, 	 so only do this if -funsafe-math-optimizations.  We can actually 	 always safely do it if ARG1 is a power of two, but it's hard to 	 tell if it is or not in a portable manner.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
comment|/* Find the reciprocal if optimizing and the result is exact.  */
if|if
condition|(
name|optimize
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|r
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exact_real_inverse
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
name|tem
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Convert A/B/C to A/(B*C).  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RDIV_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Convert A/(B/C) to (A/B)*C.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|RDIV_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Convert C1/(X*C2) into (C1/C2)/X.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|tree
name|tem
init|=
name|const_binop
argument_list|(
name|RDIV_EXPR
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
name|enum
name|built_in_function
name|fcode
init|=
name|builtin_mathfn_code
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
comment|/* Optimize x/expN(y) into x*expN(-y).  */
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_EXP
operator|||
name|fcode
operator|==
name|BUILT_IN_EXPF
operator|||
name|fcode
operator|==
name|BUILT_IN_EXPL
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP2
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP2F
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP2L
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP10
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP10F
operator|||
name|fcode
operator|==
name|BUILT_IN_EXP10L
operator|||
name|fcode
operator|==
name|BUILT_IN_POW10
operator|||
name|fcode
operator|==
name|BUILT_IN_POW10F
operator|||
name|fcode
operator|==
name|BUILT_IN_POW10L
condition|)
block|{
name|tree
name|expfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|arg1
operator|=
name|build_function_call_expr
argument_list|(
name|expfn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Optimize x/pow(y,z) into x*pow(y,-z).  */
if|if
condition|(
name|fcode
operator|==
name|BUILT_IN_POW
operator|||
name|fcode
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode
operator|==
name|BUILT_IN_POWL
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg10
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg11
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|neg11
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|arg11
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg10
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|neg11
argument_list|)
argument_list|)
decl_stmt|;
name|arg1
operator|=
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
name|enum
name|built_in_function
name|fcode0
init|=
name|builtin_mathfn_code
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode1
init|=
name|builtin_mathfn_code
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
comment|/* Optimize sin(x)/cos(x) as tan(x).  */
if|if
condition|(
operator|(
operator|(
name|fcode0
operator|==
name|BUILT_IN_SIN
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COS
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_SINF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COSF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_SINL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_COSL
operator|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|tanfn
decl_stmt|;
if|if
condition|(
name|fcode0
operator|==
name|BUILT_IN_SIN
condition|)
name|tanfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_TAN
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|fcode0
operator|==
name|BUILT_IN_SINF
condition|)
name|tanfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_TANF
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|fcode0
operator|==
name|BUILT_IN_SINL
condition|)
name|tanfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_TANL
index|]
expr_stmt|;
else|else
name|tanfn
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|tanfn
operator|!=
name|NULL_TREE
condition|)
return|return
name|build_function_call_expr
argument_list|(
name|tanfn
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Optimize cos(x)/sin(x) as 1.0/tan(x).  */
if|if
condition|(
operator|(
operator|(
name|fcode0
operator|==
name|BUILT_IN_COS
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SIN
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_COSF
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SINF
operator|)
operator|||
operator|(
name|fcode0
operator|==
name|BUILT_IN_COSL
operator|&&
name|fcode1
operator|==
name|BUILT_IN_SINL
operator|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|tanfn
decl_stmt|;
if|if
condition|(
name|fcode0
operator|==
name|BUILT_IN_COS
condition|)
name|tanfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_TAN
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|fcode0
operator|==
name|BUILT_IN_COSF
condition|)
name|tanfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_TANF
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|fcode0
operator|==
name|BUILT_IN_COSL
condition|)
name|tanfn
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_TANL
index|]
expr_stmt|;
else|else
name|tanfn
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|tanfn
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|build_function_call_expr
argument_list|(
name|tanfn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|tmp
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Optimize pow(x,c)/x as pow(x,c-1).  */
if|if
condition|(
name|fcode0
operator|==
name|BUILT_IN_POW
operator|||
name|fcode0
operator|==
name|BUILT_IN_POWF
operator|||
name|fcode0
operator|==
name|BUILT_IN_POWL
condition|)
block|{
name|tree
name|arg00
init|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg01
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg01
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg01
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|arg00
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|powfn
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|c
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|arglist
decl_stmt|;
name|c
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg01
argument_list|)
expr_stmt|;
name|real_arithmetic
argument_list|(
operator|&
name|c
argument_list|,
name|MINUS_EXPR
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|dconst1
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|build_function_call_expr
argument_list|(
name|powfn
argument_list|,
name|arglist
argument_list|)
return|;
block|}
block|}
block|}
goto|goto
name|binary
goto|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* If arg0 is a multiple of arg1, then rewrite to the fastest div 	 operation, EXACT_DIV_EXPR.  	 Note that only CEIL_DIV_EXPR and FLOOR_DIV_EXPR are rewritten now. 	 At one time others generated faster code, it's not clear if they do 	 after the last round to changes to the DIV code in expmed.c.  */
if|if
condition|(
operator|(
name|code
operator|==
name|CEIL_DIV_EXPR
operator|||
name|code
operator|==
name|FLOOR_DIV_EXPR
operator|)
operator|&&
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|extract_muldiv
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|code
argument_list|,
name|NULL_TREE
argument_list|)
operator|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
goto|goto
name|binary
goto|;
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|extract_muldiv
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|code
argument_list|,
name|NULL_TREE
argument_list|)
operator|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
goto|goto
name|binary
goto|;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
goto|goto
name|shift
goto|;
case|case
name|RSHIFT_EXPR
case|:
comment|/* Optimize -1>> x for arithmetic right shifts.  */
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* ... fall through ...  */
case|case
name|LSHIFT_EXPR
case|:
name|shift
label|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* Since negative shift count is not well-defined, 	 don't try to compute it in the compiler.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|arg1
argument_list|)
operator|<
literal|0
condition|)
return|return
name|t
return|;
comment|/* Rewrite an LROTATE_EXPR by a constant into an 	 RROTATE_EXPR by a new constant.  */
if|if
condition|(
name|code
operator|==
name|LROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|tem
init|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tem
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|tem
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|RROTATE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
comment|/* If we have a rotate of a bit operation with the rotate count and 	 the second operand of the bit operation both constant, 	 permute the two operations.  */
if|if
condition|(
name|code
operator|==
name|RROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Two consecutive rotates adding up to the width of the mode can 	 be ignored.  */
if|if
condition|(
name|code
operator|==
name|RROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|RROTATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
goto|goto
name|binary
goto|;
case|case
name|MIN_EXPR
case|:
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|MAX_EXPR
case|:
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|TRUTH_NOT_EXPR
case|:
comment|/* Note that the operand of this must be an int 	 and its values must be 0 or 1. 	 ("true" is a fixed value perhaps depending on the language, 	 but we don't handle values other than 1 correctly yet.)  */
name|tem
operator|=
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
comment|/* Avoid infinite recursion.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
block|{
name|tem
operator|=
name|fold_single_bit_test
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
return|return
name|t
return|;
block|}
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|tem
argument_list|)
return|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
comment|/* Note that the operands of this must be ints 	 and their values must be 0 or 1. 	 ("true" is a fixed value perhaps depending on the language.)  */
comment|/* If first arg is constant zero, return it.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|TRUTH_AND_EXPR
case|:
comment|/* If either arg is constant true, drop it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
comment|/* Preserve sequence points.  */
operator|&&
operator|(
name|code
operator|!=
name|TRUTH_ANDIF_EXPR
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If second arg is constant zero, result is zero, but first arg 	 must be evaluated.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Likewise for first arg, but note that only the TRUTH_AND_EXPR 	 case will be handled here.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
name|truth_andor
label|:
comment|/* We only do these simplifications if we are optimizing.  */
if|if
condition|(
operator|!
name|optimize
condition|)
return|return
name|t
return|;
comment|/* Check for things like (A || B)&& (A || C).  We can convert this 	 to A || (B&& C).  Note that either operator can be any of the four 	 truth and/or operations and the transformation will still be 	 valid.   Also note that we only care about order for the 	 ANDIF and ORIF operators.  If B contains side effects, this 	 might change the truth-value of A.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_AND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_OR_EXPR
operator|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|a00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|a01
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|a10
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|a11
init|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|commutative
init|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_OR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUTH_AND_EXPR
operator|)
operator|&&
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|a00
argument_list|,
name|a10
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a01
argument_list|,
name|a11
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|commutative
operator|&&
name|operand_equal_p
argument_list|(
name|a00
argument_list|,
name|a11
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a01
argument_list|,
name|a10
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|commutative
operator|&&
name|operand_equal_p
argument_list|(
name|a01
argument_list|,
name|a10
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|a01
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|a11
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* This case if tricky because we must either have commutative 	     operators or else A10 must not have side-effects.  */
elseif|else
if|if
condition|(
operator|(
name|commutative
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|a10
argument_list|)
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|a01
argument_list|,
name|a11
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|a00
argument_list|,
name|a10
argument_list|)
argument_list|)
argument_list|,
name|a01
argument_list|)
argument_list|)
return|;
block|}
comment|/* See if we can build a range comparison.  */
if|if
condition|(
literal|0
operator|!=
operator|(
name|tem
operator|=
name|fold_range_test
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
comment|/* Check for the possibility of merging component references.  If our 	 lhs is another similar operation, try to merge its rhs with our 	 rhs.  Then try to merge our lhs and rhs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|code
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|fold_truthop
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|tem
operator|=
name|fold_truthop
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
return|return
name|t
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
comment|/* Note that the operands of this must be ints 	 and their values must be 0 or true. 	 ("true" is a fixed value perhaps depending on the language.)  */
comment|/* If first arg is constant true, return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|TRUTH_OR_EXPR
case|:
comment|/* If either arg is constant zero, drop it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
comment|/* Preserve sequence points.  */
operator|&&
operator|(
name|code
operator|!=
name|TRUTH_ORIF_EXPR
operator|||
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If second arg is constant true, result is true, but we must 	 evaluate first arg.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Likewise for first arg, but note this only occurs here for 	 TRUTH_OR_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
goto|goto
name|truth_andor
goto|;
case|case
name|TRUTH_XOR_EXPR
case|:
comment|/* If either arg is constant zero, drop it.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If either arg is constant true, this is a logical inversion.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
comment|/* If one arg is a real or integer constant, put it last.  */
if|if
condition|(
name|tree_swap_operands_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|targ0
init|=
name|strip_float_extensions
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|targ1
init|=
name|strip_float_extensions
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|targ0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|targ1
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
condition|)
name|newtype
operator|=
name|TREE_TYPE
argument_list|(
name|targ1
argument_list|)
expr_stmt|;
comment|/* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|targ0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|targ1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* (-a) CMP (-b) -> b CMP a  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|REAL_VALUE_TYPE
name|cst
decl_stmt|;
name|cst
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* (-a) CMP CST -> a swap(CMP) (-CST)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|cst
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* IEEE doesn't distinguish +0 and -0 in comparisons.  */
comment|/* a CMP (-0) -> a CMP 0  */
if|if
condition|(
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|cst
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|dconst0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* x != NaN is always true, other ops are always false.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|cst
argument_list|)
operator|&&
operator|!
name|HONOR_SNANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|t
operator|=
operator|(
name|code
operator|==
name|NE_EXPR
operator|)
condition|?
name|integer_one_node
else|:
name|integer_zero_node
expr_stmt|;
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* Fold comparisons against infinity.  */
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|cst
argument_list|)
condition|)
block|{
name|tem
operator|=
name|fold_inf_compare
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
block|}
comment|/* If this is a comparison of a real constant with a PLUS_EXPR 	     or a MINUS_EXPR of a real constant, we can convert it into a 	     comparison with a revised real constant as long as no overflow 	     occurs when unsafe_math_optimizations are enabled.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|const_binop
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
comment|/* Likewise, we can simplify a comparison of a real constant with 	     a MINUS_EXPR whose first operand is also a real constant, i.e. 	     (c1 - x)< c2 becomes x> c1-c2.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
comment|/* Fold comparisons against built-in math functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|flag_unsafe_math_optimizations
operator|&&
operator|!
name|flag_errno_math
condition|)
block|{
name|enum
name|built_in_function
name|fcode
init|=
name|builtin_mathfn_code
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
if|if
condition|(
name|fcode
operator|!=
name|END_BUILTINS
condition|)
block|{
name|tem
operator|=
name|fold_mathfn_compare
argument_list|(
name|fcode
argument_list|,
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|NULL_TREE
condition|)
return|return
name|tem
return|;
block|}
block|}
block|}
comment|/* Convert foo++ == CONST into ++foo == CONST + INCR.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
operator|)
comment|/* This optimization is invalid for ordered comparisons 	     if CONST+INCR overflows or if foo+incr might overflow. 	     This optimization is invalid for floating point due to rounding. 	     For pointer types we assume overflow doesn't happen.  */
operator|&&
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|varop
decl_stmt|,
name|newconst
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|POSTINCREMENT_EXPR
condition|)
block|{
name|newconst
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|varop
operator|=
name|build
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newconst
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|varop
operator|=
name|build
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If VAROP is a reference to a bitfield, we must mask 	     the constant by the width of the field.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|fielddecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|fielddecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|folded_compare
decl_stmt|,
name|shift
decl_stmt|;
comment|/* First check whether the comparison would come out 		 always the same.  If we don't do that we would 		 change the meaning with the masking.  */
name|folded_compare
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|folded_compare
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|folded_compare
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|folded_compare
argument_list|,
name|varop
argument_list|)
return|;
name|shift
operator|=
name|build_int_2
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|-
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newconst
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|newconst
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|newconst
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|newconst
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|varop
argument_list|,
name|newconst
argument_list|)
argument_list|)
return|;
block|}
comment|/* Change X>= C to X> (C - 1) and X< C to X<= (C - 1) if C> 0. 	 This transformation affects the cases which are handled in later 	 optimizations involving comparisons with non-negative constants.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|arg1
argument_list|)
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE_EXPR
case|:
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
comment|/* Comparisons with the highest or lowest possible integer of 	 the specified size will have known values.  */
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|signed_max
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max
decl_stmt|,
name|min
decl_stmt|;
name|signed_max
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|max
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
name|signed_max
expr_stmt|;
name|min
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
name|max
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
comment|/* The GE_EXPR and LT_EXPR cases above are not normally 		   reached because of previous transformations.  */
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
name|max
operator|-
literal|1
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT_EXPR
case|:
name|arg1
operator|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
name|arg1
operator|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
operator|(
name|min
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
name|min
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|GT_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
operator|(
name|min
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
name|min
operator|+
literal|1
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE_EXPR
case|:
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
name|signed_max
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
comment|/* signed_type does not work on pointer types.  */
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The following case also applies to X< signed_max+1 		   and X>= signed_max+1 because previous transformations.  */
if|if
condition|(
name|code
operator|==
name|LE_EXPR
operator|||
name|code
operator|==
name|GT_EXPR
condition|)
block|{
name|tree
name|st0
decl_stmt|,
name|st1
decl_stmt|;
name|st0
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|st1
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
operator|==
name|LE_EXPR
condition|?
name|GE_EXPR
else|:
name|LT_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|st0
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|st1
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
block|}
comment|/* If this is an EQ or NE comparison of a constant with a PLUS_EXPR or 	 a MINUS_EXPR of a constant, we can convert it into a comparison with 	 a revised constant as long as no overflow occurs.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|const_binop
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
comment|/* Similarly for a NEGATE_EXPR.  */
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|negate_expr
argument_list|(
name|arg1
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
comment|/* If we have X - Y == 0, we can convert that to X == Y and similarly 	 for !=.  Don't do this for ordered comparisons due to overflow.  */
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|)
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If we are widening one operand of an integer comparison, 	 see if the other operand is similarly being widened.  Perhaps we 	 can do the comparison in the narrower type.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|tem
operator|=
name|get_unwidened
argument_list|(
name|arg0
argument_list|,
name|NULL_TREE
argument_list|)
operator|)
operator|!=
name|arg0
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|t1
operator|=
name|get_unwidened
argument_list|(
name|arg1
argument_list|,
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|t1
argument_list|,
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|t1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a 	 constant, we can simplify it.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MIN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MAX_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|optimize_minmax_comparison
argument_list|(
name|t
argument_list|)
return|;
comment|/* If we are comparing an ABS_EXPR with a constant, we can 	 convert all the cases into explicit comparisons, but they may 	 well not be faster than doing the ABS and one comparison. 	 But ABS (X)<= C is a range comparison, which becomes a subtraction 	 and a comparison, and is probably faster.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|LE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ABS_EXPR
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|&&
operator|(
literal|0
operator|!=
operator|(
name|tem
operator|=
name|negate_expr
argument_list|(
name|arg1
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|,
name|build
argument_list|(
name|LE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If this is an EQ or NE comparison with zero and ARG0 is 	 (1<< foo)& bar, convert it to (bar>> foo)& 1.  Both require 	 two operations, but the latter can be done in one less insn 	 on machines that have only two-operand insns or on which a 	 constant cannot be the first operand.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
comment|/* If this is an NE or EQ comparison of zero against the result of a 	 signed MOD operation whose second operand is a power of 2, make 	 the MOD operation unsigned since it is simpler and equivalent.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|)
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TRUNC_MOD_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CEIL_MOD_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|FLOOR_MOD_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ROUND_MOD_EXPR
operator|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|newtype
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newmod
init|=
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|newtype
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|newmod
argument_list|,
name|fold_convert
argument_list|(
name|newtype
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
comment|/* If this is an NE comparison of zero with an AND of one, remove the 	 comparison since the AND will give the correct value.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* If we have (A& C) == C where C is a power of 2, convert this into 	 (A& C) != 0.  Similarly for NE_EXPR.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
comment|/* If we have (A& C) != 0 or (A& C) == 0 and C is a power of 	 2, then fold the expression into shifts and logical operations.  */
name|tem
operator|=
name|fold_single_bit_test
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
comment|/* If we have (A& C) == D where D& ~C != 0, convert this into 0. 	 Similarly for NE_EXPR.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|dandnotc
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|rslt
init|=
name|code
operator|==
name|EQ_EXPR
condition|?
name|integer_zero_node
else|:
name|integer_one_node
decl_stmt|;
if|if
condition|(
name|integer_nonzerop
argument_list|(
name|dandnotc
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|rslt
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* If we have (A | C) == D where C& ~D != 0, convert this into 0. 	 Similarly for NE_EXPR.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|candnotd
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|rslt
init|=
name|code
operator|==
name|EQ_EXPR
condition|?
name|integer_zero_node
else|:
name|integer_one_node
decl_stmt|;
if|if
condition|(
name|integer_nonzerop
argument_list|(
name|candnotd
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|rslt
argument_list|,
name|arg0
argument_list|)
return|;
block|}
comment|/* If X is unsigned, convert X< (1<< Y) into X>> Y == 0 	 and similarly for>= into !=.  */
if|if
condition|(
operator|(
name|code
operator|==
name|LT_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|code
operator|==
name|LT_EXPR
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|LT_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|code
operator|==
name|LT_EXPR
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
comment|/* Simplify comparison of something with itself.  (For IEEE 	 floating-point, we can only do some of these simplifications.)  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
break|break;
case|case
name|GE_EXPR
case|:
case|case
name|LE_EXPR
case|:
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|constant_boolean_node
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
comment|/* For NE, we can only do this simplification if integer 		 or we don't honor IEEE floating point NaNs.  */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* ... fall through ...  */
case|case
name|GT_EXPR
case|:
case|case
name|LT_EXPR
case|:
return|return
name|constant_boolean_node
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If we are comparing an expression that just has comparisons 	 of two integer values, arithmetic expressions of those comparisons, 	 and constants, we can simplify it.  There are only three cases 	 to check: the two values can either be equal, the first can be 	 greater, or the second can be greater.  Fold the expression for 	 those three values.  Since each value must be 0 or 1, we have 	 eight possibilities, each of which corresponds to the constant 0 	 or 1 or one of the six possible comparisons.  	 This handles common cases like (a> b) == 0 but also handles 	 expressions like  ((x> y) - (y> x))> 0, which supposedly 	 occur in macroized code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|tree
name|cval1
init|=
literal|0
decl_stmt|,
name|cval2
init|=
literal|0
decl_stmt|;
name|int
name|save_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|twoval_comparison_p
argument_list|(
name|arg0
argument_list|,
operator|&
name|cval1
argument_list|,
operator|&
name|cval2
argument_list|,
operator|&
name|save_p
argument_list|)
comment|/* Don't handle degenerate cases here; they should already 		 have been handled anyway.  */
operator|&&
name|cval1
operator|!=
literal|0
operator|&&
name|cval2
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CONSTANT
argument_list|(
name|cval1
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|cval2
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|cval2
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval2
argument_list|)
argument_list|)
operator|&&
operator|!
name|operand_equal_p
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval2
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|maxval
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|minval
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We can't just pass T to eval_subst in case cval1 or cval2 		 was the same as ARG1.  */
name|tree
name|high_result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|maxval
argument_list|,
name|cval2
argument_list|,
name|minval
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|equal_result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|maxval
argument_list|,
name|cval2
argument_list|,
name|maxval
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|low_result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|minval
argument_list|,
name|cval2
argument_list|,
name|maxval
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* All three of these results should be 0 or 1.  Confirm they 		 are.  Then use those values to select the proper code 		 to use.  */
if|if
condition|(
operator|(
name|integer_zerop
argument_list|(
name|high_result
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|high_result
argument_list|)
operator|)
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|equal_result
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|equal_result
argument_list|)
operator|)
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|low_result
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|low_result
argument_list|)
operator|)
condition|)
block|{
comment|/* Make a 3-bit mask with the high-order bit being the 		     value for `>', the next for '=', and the low for '<'.  */
switch|switch
condition|(
operator|(
name|integer_onep
argument_list|(
name|high_result
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|integer_onep
argument_list|(
name|equal_result
argument_list|)
operator|*
literal|2
operator|)
operator|+
name|integer_onep
argument_list|(
name|low_result
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Always false.  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
case|case
literal|1
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|code
operator|=
name|NE_EXPR
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* Always true.  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
block|}
name|t
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_p
condition|)
return|return
name|save_expr
argument_list|(
name|t
argument_list|)
return|;
else|else
return|return
name|fold
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
block|}
comment|/* If this is a comparison of a field, we may be able to simplify it.  */
if|if
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
call|(
modifier|*
name|lang_hooks
operator|.
name|can_use_bit_fields_p
call|)
argument_list|()
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|)
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
comment|/* Handle the constant case even without -O 	     to make sure the warnings are given.  */
operator|&&
operator|(
name|optimize
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
block|{
name|t1
operator|=
name|optimize_bit_field_compare
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
condition|)
return|return
name|t1
return|;
block|}
comment|/* If this is a comparison of complex values and either or both sides 	 are a COMPLEX_EXPR or COMPLEX_CST, it is best to split up the 	 comparisons and join them with a TRUTH_ANDIF_EXPR or TRUTH_ORIF_EXPR. 	 This may prevent needless evaluations.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_CST
operator|)
condition|)
block|{
name|tree
name|subtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|real0
decl_stmt|,
name|imag0
decl_stmt|,
name|real1
decl_stmt|,
name|imag1
decl_stmt|;
name|arg0
operator|=
name|save_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|save_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|real0
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|subtype
argument_list|,
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|imag0
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|subtype
argument_list|,
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|real1
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|subtype
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|imag1
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|subtype
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
operator|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|TRUTH_ANDIF_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|real0
argument_list|,
name|real1
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|imag0
argument_list|,
name|imag1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Optimize comparisons of strlen vs zero to a compare of the 	 first character of the string vs zero.  To wit, 		strlen(ptr) == 0   =>  *ptr == 0 		strlen(ptr) != 0   =>  *ptr != 0 	 Other cases should reduce to one of these two (or a constant) 	 due to the return value of strlen being unsigned.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
if|if
condition|(
name|fndecl
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|BUILT_IN_MD
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_STRLEN
operator|&&
operator|(
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|!
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|char_type_node
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
block|}
comment|/* From here on, the only cases we handle are when the result is 	 known to be a constant.  	 To compute GT, swap the arguments and do LT. 	 To compute GE, do LT and invert the result. 	 To compute LE, swap the arguments, do LT and invert the result. 	 To compute NE, do EQ and invert the result.  	 Therefore, the code below must handle only EQ and LT.  */
if|if
condition|(
name|code
operator|==
name|LE_EXPR
operator|||
name|code
operator|==
name|GT_EXPR
condition|)
block|{
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Note that it is safe to invert for real values here because we 	 will check below in the one case that it matters.  */
name|t1
operator|=
name|NULL_TREE
expr_stmt|;
name|invert
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
condition|)
block|{
name|invert
operator|=
literal|1
expr_stmt|;
name|code
operator|=
name|invert_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Compute a result for LT or EQ if args permit; 	 otherwise return T.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|t1
operator|=
name|build_int_2
argument_list|(
name|tree_int_cst_equal
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|t1
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|?
name|INT_CST_LT_UNSIGNED
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
else|:
name|INT_CST_LT
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This is no longer useful, but breaks some real code.  */
comment|/* Assume a nonexplicit constant cannot equal an explicit one, 	 since such code would be undefined anyway. 	 Exception: on sysvr4, using #pragma weak, 	 a label can come out as 0.  */
if|else if (TREE_CODE (arg1) == INTEGER_CST&& !integer_zerop (arg1)&& TREE_CONSTANT (arg0)&& TREE_CODE (arg0) == ADDR_EXPR&& code == EQ_EXPR) 	t1 = build_int_2 (0, 0);
endif|#
directive|endif
comment|/* Two real constants can be compared explicitly.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
comment|/* If either operand is a NaN, the result is false with two 	     exceptions: First, an NE_EXPR is true on NaNs, but that case 	     is already handled correctly since we will be inverting the 	     result for NE_EXPR.  Second, if we had inverted a LE_EXPR 	     or a GE_EXPR into a LT_EXPR, we must return true so that it 	     will be inverted into false.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|t1
operator|=
name|build_int_2
argument_list|(
name|invert
operator|&&
name|code
operator|==
name|LT_EXPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|t1
operator|=
name|build_int_2
argument_list|(
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|t1
operator|=
name|build_int_2
argument_list|(
name|REAL_VALUES_LESS
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
return|return
name|t
return|;
if|if
condition|(
name|invert
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|^=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
call|(
modifier|*
name|lang_hooks
operator|.
name|truthvalue_conversion
call|)
argument_list|(
name|t1
argument_list|)
return|;
return|return
name|t1
return|;
case|case
name|COND_EXPR
case|:
comment|/* Pedantic ANSI C says that a conditional expression is never an lvalue, 	 so all simple results must be passed through pedantic_non_lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
operator|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Only optimize constant conditions when the selected branch 	     has the same type as the COND_EXPR.  This avoids optimizing 	     away "c ? x : throw", where the throw has a void type.  */
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|tem
argument_list|)
return|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|pedantic_omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* If we have A op B ? A : C, we may be able to convert this to a 	 simpler expression, depending on the operation and the values 	 of B and C.  Signed zeros prevent all of these transformations, 	 for reasons given above each one.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|operand_equal_for_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|arg2
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|comp_code
init|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* If we have A op 0 ? A : -A, consider applying the following 	     transformations:  	     A == 0? A : -A    same as -A 	     A != 0? A : -A    same as A 	     A>= 0? A : -A    same as abs (A) 	     A> 0?  A : -A    same as abs (A) 	     A<= 0? A : -A    same as -abs (A) 	     A< 0?  A : -A    same as -abs (A)  	     None of these transformations work for modes with signed 	     zeros.  If A is +/-0, the first two transformations will 	     change the sign of the result (from +0 to -0, or vice 	     versa).  The last four will fix the sign of the result, 	     even though the original expressions could be positive or 	     negative, depending on the sign of A.  	     Note that all these transformations are correct if A is 	     NaN, since the two alternatives (A and -A) are also NaNs.  */
if|if
condition|(
operator|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|?
name|real_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
name|tem
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|negate_expr
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|tem
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|arg1
operator|=
name|fold_convert
argument_list|(
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|arg1
operator|=
name|fold_convert
argument_list|(
call|(
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|negate_expr
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pedantic_non_lvalue
argument_list|(
name|arg1
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* A != 0 ? A : 0 is simply A, unless A is -0.  Likewise 	     A == 0 ? A : 0 is always 0 unless A is -0.  Note that 	     both transformations are correct when A is NaN: A != 0 	     is then true, and A == 0 is false.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|arg2
argument_list|)
condition|)
block|{
if|if
condition|(
name|comp_code
operator|==
name|NE_EXPR
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|comp_code
operator|==
name|EQ_EXPR
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
block|}
comment|/* Try some transformations of A op B ? A : B.  	     A == B? A : B    same as B 	     A != B? A : B    same as A 	     A>= B? A : B    same as max (A, B) 	     A> B?  A : B    same as max (B, A) 	     A<= B? A : B    same as min (A, B) 	     A< B?  A : B    same as min (B, A)  	     As above, these transformations don't work in the presence 	     of signed zeros.  For example, if A and B are zeros of 	     opposite sign, the first two transformations will change 	     the sign of the result.  In the last four, the original 	     expressions give different results for (A=+0, B=-0) and 	     (A=-0, B=+0), but the transformed expressions do not.  	     The first two transformations are correct if either A or B 	     is a NaN.  In the first transformation, the condition will 	     be false, and B will indeed be chosen.  In the case of the 	     second transformation, the condition A != B will be true, 	     and A will be chosen.  	     The conversions to max() and min() are not correct if B is 	     a number and A is not.  The conditions in the original 	     expressions will be false, so all four give B.  The min() 	     and max() versions would give a NaN instead.  */
if|if
condition|(
name|operand_equal_for_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|comp_op0
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|comp_op1
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|comp_type
init|=
name|TREE_TYPE
argument_list|(
name|comp_op0
argument_list|)
decl_stmt|;
comment|/* Avoid adding NOP_EXPRs in case this is an lvalue.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|comp_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|comp_type
operator|=
name|type
expr_stmt|;
name|comp_op0
operator|=
name|arg1
expr_stmt|;
name|comp_op1
operator|=
name|arg2
expr_stmt|;
block|}
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
case|case
name|LT_EXPR
case|:
comment|/* In C++ a ?: expression can be an lvalue, so put the 		     operand which will be used if they are equal first 		     so that we can convert this back to the 		     corresponding COND_EXPR.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MIN_EXPR
argument_list|,
name|comp_type
argument_list|,
operator|(
name|comp_code
operator|==
name|LE_EXPR
condition|?
name|comp_op0
else|:
name|comp_op1
operator|)
argument_list|,
operator|(
name|comp_code
operator|==
name|LE_EXPR
condition|?
name|comp_op1
else|:
name|comp_op0
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MAX_EXPR
argument_list|,
name|comp_type
argument_list|,
operator|(
name|comp_code
operator|==
name|GE_EXPR
condition|?
name|comp_op0
else|:
name|comp_op1
operator|)
argument_list|,
operator|(
name|comp_code
operator|==
name|GE_EXPR
condition|?
name|comp_op1
else|:
name|comp_op0
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If this is A op C1 ? A : C2 with C1 and C2 constant integers, 	     we might still be able to simplify this.  For example, 	     if C1 is one less or one more than C2, this might have started 	     out as a MIN or MAX and been transformed by this function. 	     Only good for INTEGER_TYPEs, because we need TYPE_MAX_VALUE.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|INTEGER_CST
condition|)
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
comment|/* We can replace A with C1 in this case.  */
name|arg1
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
comment|/* If C1 is C2 + 1, this is min(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|LE_EXPR
case|:
comment|/* If C1 is C2 - 1, this is min(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|GT_EXPR
case|:
comment|/* If C1 is C2 - 1, this is max(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MAX_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|GE_EXPR
case|:
comment|/* If C1 is C2 + 1, this is max(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|MAX_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|NE_EXPR
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If the second operand is simpler than the third, swap them 	 since that produces better jump optimization results.  */
if|if
condition|(
name|tree_swap_operands_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|false
argument_list|)
condition|)
block|{
comment|/* See if this can be inverted.  If it can't, possibly because 	     it was a floating-point inequality comparison, don't do 	     anything.  */
name|tem
operator|=
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|TRUTH_NOT_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Convert A ? 1 : 0 to simply A.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
comment|/* If we try to convert TREE_OPERAND (t, 0) to our type, the 	     call to fold will try to move the conversion inside 	     a COND, which will recurse.  In that case, the COND_EXPR 	     is probably the best choice, so leave it alone.  */
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|arg0
argument_list|)
return|;
comment|/* Convert A ? 0 : 1 to !A.  This prefers the use of NOT_EXPR 	 over COND_EXPR in cases such as floating point comparisons.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Look for expressions of the form A& 2 ? 2 : 0.  The result of this 	 operation is simply A& 2.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold_convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Convert A ? B : 0 into A&& B if A and B are truth values.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Convert A ? B : 1 into !A || B if A and B are truth values.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Only perform transformation if ARG0 is easily inverted.  */
name|tem
operator|=
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|TRUTH_NOT_EXPR
condition|)
return|return
name|pedantic_non_lvalue
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|tem
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
return|return
name|t
return|;
case|case
name|COMPOUND_EXPR
case|:
comment|/* When pedantic, a compound expression can be neither an lvalue 	 nor an integer constant expression.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|||
name|pedantic
condition|)
return|return
name|t
return|;
comment|/* Don't let (0, 0) be null pointer constant.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
return|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|COMPLEX_EXPR
case|:
if|if
condition|(
name|wins
condition|)
return|return
name|build_complex
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|REALPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return
name|t
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_REALPART
argument_list|(
name|arg0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|IMAGPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_IMAGPART
argument_list|(
name|arg0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
comment|/* Pull arithmetic ops out of the CLEANUP_POINT_EXPR where          appropriate.  */
case|case
name|CLEANUP_POINT_EXPR
case|:
if|if
condition|(
operator|!
name|has_cleanups
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
return|;
block|{
name|enum
name|tree_code
name|code0
init|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|int
name|kind0
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code0
argument_list|)
decl_stmt|;
name|tree
name|arg00
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg01
decl_stmt|;
if|if
condition|(
name|kind0
operator|==
literal|'1'
operator|||
name|code0
operator|==
name|TRUTH_NOT_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code0
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|,
name|arg00
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|kind0
operator|==
literal|'<'
operator|||
name|kind0
operator|==
literal|'2'
operator|||
name|code0
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code0
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code0
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code0
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code0
operator|==
name|TRUTH_XOR_EXPR
condition|)
block|{
name|arg01
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg00
argument_list|)
operator|||
operator|(
operator|(
name|code0
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code0
operator|==
name|TRUTH_ORIF_EXPR
operator|)
operator|&&
operator|!
name|has_cleanups
argument_list|(
name|arg00
argument_list|)
operator|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code0
argument_list|,
name|type
argument_list|,
name|arg00
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg01
argument_list|)
argument_list|,
name|arg01
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg01
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code0
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg00
argument_list|)
argument_list|,
name|arg00
argument_list|)
argument_list|)
argument_list|,
name|arg01
argument_list|)
argument_list|)
return|;
block|}
return|return
name|t
return|;
block|}
case|case
name|CALL_EXPR
case|:
comment|/* Check for a built-in function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|fold_builtin
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
return|;
block|}
return|return
name|t
return|;
default|default:
return|return
name|t
return|;
block|}
comment|/* switch (code) */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_FOLD_CHECKING
end_ifdef

begin_undef
undef|#
directive|undef
name|fold
end_undef

begin_function_decl
specifier|static
name|void
name|fold_checksum_tree
parameter_list|(
name|tree
parameter_list|,
name|struct
name|md5_ctx
modifier|*
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fold_check_failed
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_fold_checksum
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* When --enable-checking=fold, compute a digest of expr before    and after actual fold call to see if fold did not accidentally    change original expr.  */
end_comment

begin_function
name|tree
name|fold
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|ret
decl_stmt|;
name|struct
name|md5_ctx
name|ctx
decl_stmt|;
name|unsigned
name|char
name|checksum_before
index|[
literal|16
index|]
decl_stmt|,
name|checksum_after
index|[
literal|16
index|]
decl_stmt|;
name|htab_t
name|ht
decl_stmt|;
name|ht
operator|=
name|htab_create
argument_list|(
literal|32
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|expr
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_before
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|ht
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fold_1
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|expr
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum_after
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|checksum_before
argument_list|,
name|checksum_after
argument_list|,
literal|16
argument_list|)
condition|)
name|fold_check_failed
argument_list|(
name|expr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|print_fold_checksum
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|struct
name|md5_ctx
name|ctx
decl_stmt|;
name|unsigned
name|char
name|checksum
index|[
literal|16
index|]
decl_stmt|,
name|cnt
decl_stmt|;
name|htab_t
name|ht
decl_stmt|;
name|ht
operator|=
name|htab_create
argument_list|(
literal|32
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|expr
argument_list|,
operator|&
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|ht
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|16
condition|;
operator|++
name|cnt
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02x"
argument_list|,
name|checksum
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fold_check_failed
parameter_list|(
name|tree
name|expr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|ret
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"fold check: original tree changed by fold"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fold_checksum_tree
parameter_list|(
name|tree
name|expr
parameter_list|,
name|struct
name|md5_ctx
modifier|*
name|ctx
parameter_list|,
name|htab_t
name|ht
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_exp
argument_list|)
operator|+
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
operator|||
sizeof|sizeof
argument_list|(
expr|struct
name|tree_type
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
condition|)
return|return;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|ht
argument_list|,
name|expr
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|!=
name|NULL
condition|)
return|return;
operator|*
name|slot
operator|=
name|expr
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SAVE_EXPR
operator|&&
name|SAVE_EXPR_NOPLACEHOLDER
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* Allow SAVE_EXPR_NOPLACEHOLDER flag to be modified.  */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
operator|(
name|tree
operator|)
name|buf
expr_stmt|;
name|SAVE_EXPR_NOPLACEHOLDER
argument_list|(
name|expr
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'d'
operator|&&
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* Allow DECL_ASSEMBLER_NAME to be modified.  */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
operator|(
name|tree
operator|)
name|buf
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'t'
operator|&&
operator|(
name|TYPE_POINTER_TO
argument_list|(
name|expr
argument_list|)
operator|||
name|TYPE_REFERENCE_TO
argument_list|(
name|expr
argument_list|)
operator|)
condition|)
block|{
comment|/* Allow TYPE_POINTER_TO and TYPE_REFERENCE_TO to be modified.  */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
operator|(
name|tree
operator|)
name|buf
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|expr
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|expr
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|md5_process_bytes
argument_list|(
name|expr
argument_list|,
name|tree_size
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'t'
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'d'
condition|)
name|fold_checksum_tree
argument_list|(
name|TREE_CHAIN
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'c'
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|STRING_CST
case|:
name|md5_process_bytes
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_CST
case|:
name|fold_checksum_tree
argument_list|(
name|TREE_REALPART
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_CST
case|:
name|fold_checksum_tree
argument_list|(
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'x'
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TREE_LIST
case|:
name|fold_checksum_tree
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TREE_VALUE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_VEC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|expr
argument_list|)
condition|;
operator|++
name|i
control|)
name|fold_checksum_tree
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'e'
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SAVE_EXPR
case|:
name|len
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GOTO_SUBROUTINE_EXPR
case|:
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RTL_EXPR
case|:
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|len
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Fall through.  */
case|case
literal|'r'
case|:
case|case
literal|'<'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'s'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|fold_checksum_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|fold_checksum_tree
argument_list|(
name|DECL_SIZE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_NAME
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_RESULT_FLD
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_INITIAL
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_ATTRIBUTES
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|DECL_VINDEX
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|fold_checksum_tree
argument_list|(
name|TYPE_VALUES
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_SIZE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_NAME
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_BINFO
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|fold_checksum_tree
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|expr
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|ht
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Perform constant folding and related simplification of initializer    expression EXPR.  This behaves identically to "fold" but ignores    potential run-time traps and exceptions that fold must preserve.  */
end_comment

begin_function
name|tree
name|fold_initializer
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|int
name|saved_signaling_nans
init|=
name|flag_signaling_nans
decl_stmt|;
name|int
name|saved_trapping_math
init|=
name|flag_trapping_math
decl_stmt|;
name|int
name|saved_trapv
init|=
name|flag_trapv
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|flag_signaling_nans
operator|=
literal|0
expr_stmt|;
name|flag_trapping_math
operator|=
literal|0
expr_stmt|;
name|flag_trapv
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|fold
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|flag_signaling_nans
operator|=
name|saved_signaling_nans
expr_stmt|;
name|flag_trapping_math
operator|=
name|saved_trapping_math
expr_stmt|;
name|flag_trapv
operator|=
name|saved_trapv
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Determine if first argument is a multiple of second argument.  Return 0 if    it is not, or we cannot easily determined it to be.     An example of the sort of thing we care about (at this point; this routine    could surely be made more general, and expanded to do what the *_DIV_EXPR's    fold cases do now) is discovering that       SAVE_EXPR (I) * SAVE_EXPR (J * 8)     is a multiple of       SAVE_EXPR (J * 8)     when we know that the two SAVE_EXPR (J * 8) nodes are the same node.     This code also handles discovering that       SAVE_EXPR (I) * SAVE_EXPR (J * 8)     is a multiple of 8 so we don't have to worry about dealing with a    possible remainder.     Note that we *look* inside a SAVE_EXPR only to determine how it was    calculated; it is not safe for fold to do much of anything else with the    internals of a SAVE_EXPR, since it cannot know when it will be evaluated    at run time.  For example, the latter example above *cannot* be implemented    as SAVE_EXPR (I) * J or any variant thereof, since the value of J at    evaluation time of the original SAVE_EXPR is not necessarily the same at    the time the new expression is evaluated.  The only optimization of this    sort that would be valid is changing       SAVE_EXPR (I) * SAVE_EXPR (SAVE_EXPR (J) * 8)     divided by 8 to       SAVE_EXPR (I) * SAVE_EXPR (J)     (where the same SAVE_EXPR (J) is used in the original and the    transformed version).  */
end_comment

begin_function
specifier|static
name|int
name|multiple_of_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|top
parameter_list|,
name|tree
name|bottom
parameter_list|)
block|{
if|if
condition|(
name|operand_equal_p
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|top
argument_list|)
condition|)
block|{
case|case
name|MULT_EXPR
case|:
return|return
operator|(
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|||
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
operator|(
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|&&
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bottom
argument_list|)
operator|)
return|;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|op1
decl_stmt|,
name|t1
decl_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* const_binop may not detect overflow correctly, 	     so check for it explicitly here.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|size_one_node
argument_list|)
argument_list|)
operator|>
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
literal|0
operator|!=
operator|(
name|t1
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|size_one_node
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|t1
argument_list|,
name|bottom
argument_list|)
return|;
block|}
return|return
literal|0
return|;
case|case
name|NOP_EXPR
case|:
comment|/* Can't handle conversions from non-integral or wider integral type.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|)
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* .. fall through ...  */
case|case
name|SAVE_EXPR
case|:
return|return
name|multiple_of_p
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bottom
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bottom
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|tree_int_cst_sgn
argument_list|(
name|top
argument_list|)
operator|<
literal|0
operator|||
name|tree_int_cst_sgn
argument_list|(
name|bottom
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|top
argument_list|,
name|bottom
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if `t' is known to be non-negative.  */
end_comment

begin_function
name|int
name|tree_expr_nonnegative_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ABS_EXPR
case|:
return|return
literal|1
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|tree_int_cst_sgn
argument_list|(
name|t
argument_list|)
operator|>=
literal|0
return|;
case|case
name|REAL_CST
case|:
return|return
operator|!
name|REAL_VALUE_NEGATIVE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* zero_extend(x) + zero_extend(y) is non-negative if x and y are 	 both unsigned and at least 2 bits shorter than the result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|tree
name|inner1
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|inner2
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner1
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|inner1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|inner2
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|inner2
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|prec
init|=
name|MAX
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|inner1
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|inner2
argument_list|)
argument_list|)
operator|+
literal|1
decl_stmt|;
return|return
name|prec
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
comment|/* x * x for floating point x is always non-negative.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* zero_extend(x) * zero_extend(y) is non-negative if x and y are 	 both unsigned and their total bits is shorter than the result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|tree
name|inner1
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|inner2
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner1
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|inner1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|inner2
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|inner2
argument_list|)
condition|)
return|return
name|TYPE_PRECISION
argument_list|(
name|inner1
argument_list|)
operator|+
name|TYPE_PRECISION
argument_list|(
name|inner2
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|RDIV_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|outer_type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|outer_type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|inner_type
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|outer_type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|TYPE_PRECISION
argument_list|(
name|inner_type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|inner_type
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|COND_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MIN_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MAX_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MODIFY_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|BIND_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|FLOAT_EXPR
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|RTL_EXPR
case|:
return|return
name|rtl_expr_nonnegative_p
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|fndecl
init|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fndecl
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|BUILT_IN_MD
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_CABS
case|:
case|case
name|BUILT_IN_CABSL
case|:
case|case
name|BUILT_IN_CABSF
case|:
case|case
name|BUILT_IN_EXP
case|:
case|case
name|BUILT_IN_EXPF
case|:
case|case
name|BUILT_IN_EXPL
case|:
case|case
name|BUILT_IN_EXP2
case|:
case|case
name|BUILT_IN_EXP2F
case|:
case|case
name|BUILT_IN_EXP2L
case|:
case|case
name|BUILT_IN_EXP10
case|:
case|case
name|BUILT_IN_EXP10F
case|:
case|case
name|BUILT_IN_EXP10L
case|:
case|case
name|BUILT_IN_FABS
case|:
case|case
name|BUILT_IN_FABSF
case|:
case|case
name|BUILT_IN_FABSL
case|:
case|case
name|BUILT_IN_FFS
case|:
case|case
name|BUILT_IN_FFSL
case|:
case|case
name|BUILT_IN_FFSLL
case|:
case|case
name|BUILT_IN_PARITY
case|:
case|case
name|BUILT_IN_PARITYL
case|:
case|case
name|BUILT_IN_PARITYLL
case|:
case|case
name|BUILT_IN_POPCOUNT
case|:
case|case
name|BUILT_IN_POPCOUNTL
case|:
case|case
name|BUILT_IN_POPCOUNTLL
case|:
case|case
name|BUILT_IN_POW10
case|:
case|case
name|BUILT_IN_POW10F
case|:
case|case
name|BUILT_IN_POW10L
case|:
case|case
name|BUILT_IN_SQRT
case|:
case|case
name|BUILT_IN_SQRTF
case|:
case|case
name|BUILT_IN_SQRTL
case|:
return|return
literal|1
return|;
case|case
name|BUILT_IN_ATAN
case|:
case|case
name|BUILT_IN_ATANF
case|:
case|case
name|BUILT_IN_ATANL
case|:
case|case
name|BUILT_IN_CEIL
case|:
case|case
name|BUILT_IN_CEILF
case|:
case|case
name|BUILT_IN_CEILL
case|:
case|case
name|BUILT_IN_FLOOR
case|:
case|case
name|BUILT_IN_FLOORF
case|:
case|case
name|BUILT_IN_FLOORL
case|:
case|case
name|BUILT_IN_NEARBYINT
case|:
case|case
name|BUILT_IN_NEARBYINTF
case|:
case|case
name|BUILT_IN_NEARBYINTL
case|:
case|case
name|BUILT_IN_ROUND
case|:
case|case
name|BUILT_IN_ROUNDF
case|:
case|case
name|BUILT_IN_ROUNDL
case|:
case|case
name|BUILT_IN_TRUNC
case|:
case|case
name|BUILT_IN_TRUNCF
case|:
case|case
name|BUILT_IN_TRUNCL
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_POW
case|:
case|case
name|BUILT_IN_POWF
case|:
case|case
name|BUILT_IN_POWL
case|:
return|return
name|tree_expr_nonnegative_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
comment|/* ... fall through ...  */
default|default:
if|if
condition|(
name|truth_value_p
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
comment|/* Truth values evaluate to 0 or 1, which is nonnegative.  */
return|return
literal|1
return|;
block|}
comment|/* We don't know sign of `t', so be conservative and return false.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if `r' is known to be non-negative.    Only handles constants at the moment.  */
end_comment

begin_function
name|int
name|rtl_expr_nonnegative_p
parameter_list|(
name|rtx
name|r
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
return|return
name|INTVAL
argument_list|(
name|r
argument_list|)
operator|>=
literal|0
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|CONST_DOUBLE_HIGH
argument_list|(
name|r
argument_list|)
operator|>=
literal|0
return|;
return|return
literal|0
return|;
case|case
name|CONST_VECTOR
case|:
block|{
name|int
name|units
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|elt
decl_stmt|;
name|units
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
operator|++
name|i
control|)
block|{
name|elt
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtl_expr_nonnegative_p
argument_list|(
name|elt
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
comment|/* These are always nonnegative.  */
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"gt-fold-const.h"
end_include

end_unit

