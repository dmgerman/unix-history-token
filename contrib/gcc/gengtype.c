begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process source files and output type information.    Copyright (C) 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"gengtype.h"
end_include

begin_include
include|#
directive|include
file|"gtyp-gen.h"
end_include

begin_comment
comment|/* Nonzero iff an error has occurred.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hit_error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_rtx_next
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rtx_next
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|open_base_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_output_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report an error at POS, printing MSG.  */
end_comment

begin_decl_stmt
name|void
name|error_at_line
name|VPARAMS
argument_list|(
operator|(
expr|struct
name|fileloc
operator|*
name|pos
operator|,
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
expr|struct
name|fileloc
operator|*
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|pos
operator|->
name|file
argument_list|,
name|pos
operator|->
name|line
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|hit_error
operator|=
literal|1
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* vasprintf, but produces fatal message on out-of-memory.  */
end_comment

begin_function
name|int
name|xvasprintf
parameter_list|(
name|result
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|int
name|ret
init|=
name|vasprintf
argument_list|(
name|result
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|result
operator|==
name|NULL
operator|||
name|ret
operator|<
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"gengtype: out of memory"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Wrapper for xvasprintf.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|xasprintf
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|xvasprintf
argument_list|(
operator|&
name|result
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_decl_stmt

begin_comment
comment|/* The one and only TYPE_STRING.  */
end_comment

begin_decl_stmt
name|struct
name|type
name|string_type
init|=
block|{
name|TYPE_STRING
block|,
name|NULL
block|,
name|NULL
block|,
name|GC_USED
name|UNION_INIT_ZERO
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lists of various things.  */
end_comment

begin_decl_stmt
specifier|static
name|pair_p
name|typedefs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|type_p
name|structures
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|type_p
name|param_structs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pair_p
name|variables
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_scalar_typedef
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|fileloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|type_p
name|find_param_structure
name|PARAMS
argument_list|(
operator|(
name|type_p
name|t
operator|,
name|type_p
name|param
index|[
name|NUM_PARAM
index|]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|type_p
name|adjust_field_tree_exp
name|PARAMS
argument_list|(
operator|(
name|type_p
name|t
operator|,
name|options_p
name|opt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|type_p
name|adjust_field_rtx_def
name|PARAMS
argument_list|(
operator|(
name|type_p
name|t
operator|,
name|options_p
name|opt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define S as a typedef to T at POS.  */
end_comment

begin_function
name|void
name|do_typedef
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|pos
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|type_p
name|t
decl_stmt|;
name|struct
name|fileloc
modifier|*
name|pos
decl_stmt|;
block|{
name|pair_p
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|typedefs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|t
condition|)
block|{
name|error_at_line
argument_list|(
name|pos
argument_list|,
literal|"type `%s' previously defined"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|error_at_line
argument_list|(
operator|&
name|p
operator|->
name|line
argument_list|,
literal|"previously defined here"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|typedefs
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|s
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|p
operator|->
name|line
operator|=
operator|*
name|pos
expr_stmt|;
name|typedefs
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define S as a typename of a scalar.  */
end_comment

begin_function
specifier|static
name|void
name|do_scalar_typedef
parameter_list|(
name|s
parameter_list|,
name|pos
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|fileloc
modifier|*
name|pos
decl_stmt|;
block|{
name|do_typedef
argument_list|(
name|s
argument_list|,
name|create_scalar_type
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the type previously defined for S.  Use POS to report errors.  */
end_comment

begin_function
name|type_p
name|resolve_typedef
parameter_list|(
name|s
parameter_list|,
name|pos
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|fileloc
modifier|*
name|pos
decl_stmt|;
block|{
name|pair_p
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|typedefs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
operator|->
name|type
return|;
name|error_at_line
argument_list|(
name|pos
argument_list|,
literal|"unidentified type `%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|create_scalar_type
argument_list|(
literal|"char"
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new structure with tag NAME (or a union iff ISUNION is nonzero),    at POS with fields FIELDS and options O.  */
end_comment

begin_function
name|void
name|new_structure
parameter_list|(
name|name
parameter_list|,
name|isunion
parameter_list|,
name|pos
parameter_list|,
name|fields
parameter_list|,
name|o
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|isunion
decl_stmt|;
name|struct
name|fileloc
modifier|*
name|pos
decl_stmt|;
name|pair_p
name|fields
decl_stmt|;
name|options_p
name|o
decl_stmt|;
block|{
name|type_p
name|si
decl_stmt|;
name|type_p
name|s
init|=
name|NULL
decl_stmt|;
name|lang_bitmap
name|bitmap
init|=
name|get_base_file_bitmap
argument_list|(
name|pos
operator|->
name|file
argument_list|)
decl_stmt|;
for|for
control|(
name|si
operator|=
name|structures
init|;
name|si
operator|!=
name|NULL
condition|;
name|si
operator|=
name|si
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|si
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
operator|==
literal|0
operator|&&
name|UNION_P
argument_list|(
name|si
argument_list|)
operator|==
name|isunion
condition|)
block|{
name|type_p
name|ls
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|si
operator|->
name|kind
operator|==
name|TYPE_LANG_STRUCT
condition|)
block|{
name|ls
operator|=
name|si
expr_stmt|;
for|for
control|(
name|si
operator|=
name|ls
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
init|;
name|si
operator|!=
name|NULL
condition|;
name|si
operator|=
name|si
operator|->
name|next
control|)
if|if
condition|(
name|si
operator|->
name|u
operator|.
name|s
operator|.
name|bitmap
operator|==
name|bitmap
condition|)
name|s
operator|=
name|si
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|si
operator|->
name|u
operator|.
name|s
operator|.
name|line
operator|.
name|file
operator|!=
name|NULL
operator|&&
name|si
operator|->
name|u
operator|.
name|s
operator|.
name|bitmap
operator|!=
name|bitmap
condition|)
block|{
name|ls
operator|=
name|si
expr_stmt|;
name|si
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|si
argument_list|,
name|ls
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ls
operator|->
name|kind
operator|=
name|TYPE_LANG_STRUCT
expr_stmt|;
name|ls
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
operator|=
name|si
expr_stmt|;
name|ls
operator|->
name|u
operator|.
name|s
operator|.
name|fields
operator|=
name|NULL
expr_stmt|;
name|si
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|si
operator|->
name|pointer_to
operator|=
name|NULL
expr_stmt|;
name|si
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
operator|=
name|ls
expr_stmt|;
block|}
else|else
name|s
operator|=
name|si
expr_stmt|;
if|if
condition|(
name|ls
operator|!=
name|NULL
operator|&&
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|ls
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
expr_stmt|;
name|ls
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
operator|=
name|ls
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|structures
expr_stmt|;
name|structures
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
operator|.
name|file
operator|!=
name|NULL
operator|||
operator|(
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
operator|&&
operator|(
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
operator|->
name|u
operator|.
name|s
operator|.
name|bitmap
operator|&
name|bitmap
operator|)
operator|)
condition|)
block|{
name|error_at_line
argument_list|(
name|pos
argument_list|,
literal|"duplicate structure definition"
argument_list|)
expr_stmt|;
name|error_at_line
argument_list|(
operator|&
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
argument_list|,
literal|"previous definition here"
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|kind
operator|=
name|isunion
condition|?
name|TYPE_UNION
else|:
name|TYPE_STRUCT
expr_stmt|;
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
operator|=
name|name
expr_stmt|;
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
operator|=
operator|*
name|pos
expr_stmt|;
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|fields
operator|=
name|fields
expr_stmt|;
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|opt
operator|=
name|o
expr_stmt|;
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|bitmap
operator|=
name|bitmap
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
condition|)
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
operator|->
name|u
operator|.
name|s
operator|.
name|bitmap
operator||=
name|bitmap
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the previously-defined structure with tag NAME (or a union    iff ISUNION is nonzero), or a new empty structure or union if none    was defined previously.  */
end_comment

begin_function
name|type_p
name|find_structure
parameter_list|(
name|name
parameter_list|,
name|isunion
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|isunion
decl_stmt|;
block|{
name|type_p
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|structures
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
operator|==
literal|0
operator|&&
name|UNION_P
argument_list|(
name|s
argument_list|)
operator|==
name|isunion
condition|)
return|return
name|s
return|;
name|s
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|structures
expr_stmt|;
name|structures
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|kind
operator|=
name|isunion
condition|?
name|TYPE_UNION
else|:
name|TYPE_STRUCT
expr_stmt|;
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
operator|=
name|name
expr_stmt|;
name|structures
operator|=
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Return the previously-defined parameterised structure for structure    T and parameters PARAM, or a new parameterised empty structure or    union if none was defined previously.  */
end_comment

begin_function
specifier|static
name|type_p
name|find_param_structure
parameter_list|(
name|t
parameter_list|,
name|param
parameter_list|)
name|type_p
name|t
decl_stmt|;
name|type_p
name|param
index|[
name|NUM_PARAM
index|]
decl_stmt|;
block|{
name|type_p
name|res
decl_stmt|;
for|for
control|(
name|res
operator|=
name|param_structs
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|next
control|)
if|if
condition|(
name|res
operator|->
name|u
operator|.
name|param_struct
operator|.
name|stru
operator|==
name|t
operator|&&
name|memcmp
argument_list|(
name|res
operator|->
name|u
operator|.
name|param_struct
operator|.
name|param
argument_list|,
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|type_p
argument_list|)
operator|*
name|NUM_PARAM
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|res
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|kind
operator|=
name|TYPE_PARAM_STRUCT
expr_stmt|;
name|res
operator|->
name|next
operator|=
name|param_structs
expr_stmt|;
name|param_structs
operator|=
name|res
expr_stmt|;
name|res
operator|->
name|u
operator|.
name|param_struct
operator|.
name|stru
operator|=
name|t
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|u
operator|.
name|param_struct
operator|.
name|param
argument_list|,
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|type_p
argument_list|)
operator|*
name|NUM_PARAM
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Return a scalar type with name NAME.  */
end_comment

begin_function
name|type_p
name|create_scalar_type
parameter_list|(
name|name
parameter_list|,
name|name_len
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
block|{
name|type_p
name|r
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|r
operator|->
name|kind
operator|=
name|TYPE_SCALAR
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|sc
operator|=
name|xmemdup
argument_list|(
name|name
argument_list|,
name|name_len
argument_list|,
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to T.  */
end_comment

begin_function
name|type_p
name|create_pointer
parameter_list|(
name|t
parameter_list|)
name|type_p
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|pointer_to
condition|)
block|{
name|type_p
name|r
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|r
operator|->
name|kind
operator|=
name|TYPE_POINTER
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|p
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|pointer_to
operator|=
name|r
expr_stmt|;
block|}
return|return
name|t
operator|->
name|pointer_to
return|;
block|}
end_function

begin_comment
comment|/* Return an array of length LEN.  */
end_comment

begin_function
name|type_p
name|create_array
parameter_list|(
name|t
parameter_list|,
name|len
parameter_list|)
name|type_p
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|len
decl_stmt|;
block|{
name|type_p
name|v
decl_stmt|;
name|v
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|kind
operator|=
name|TYPE_ARRAY
expr_stmt|;
name|v
operator|->
name|u
operator|.
name|a
operator|.
name|p
operator|=
name|t
expr_stmt|;
name|v
operator|->
name|u
operator|.
name|a
operator|.
name|len
operator|=
name|len
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Add a variable named S of type T with options O defined at POS,    to `variables'.  */
end_comment

begin_function
name|void
name|note_variable
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|o
parameter_list|,
name|pos
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|type_p
name|t
decl_stmt|;
name|options_p
name|o
decl_stmt|;
name|struct
name|fileloc
modifier|*
name|pos
decl_stmt|;
block|{
name|pair_p
name|n
decl_stmt|;
name|n
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|s
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|n
operator|->
name|line
operator|=
operator|*
name|pos
expr_stmt|;
name|n
operator|->
name|opt
operator|=
name|o
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|variables
expr_stmt|;
name|variables
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_enum
enum|enum
name|rtx_code
block|{
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|ENUM ,
include|#
directive|include
file|"rtl.def"
undef|#
directive|undef
name|DEF_RTL_EXPR
name|NUM_RTX_CODE
block|}
enum|;
end_enum

begin_comment
comment|/* We really don't care how long a CONST_DOUBLE is.  */
end_comment

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|"ww"
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|rtx_format
index|[
name|NUM_RTX_CODE
index|]
init|=
block|{
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|FORMAT ,
include|#
directive|include
file|"rtl.def"
undef|#
directive|undef
name|DEF_RTL_EXPR
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtx_next
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate the contents of the rtx_next array.  This really doesn't belong    in gengtype at all, but it's needed for adjust_field_rtx_def.  */
end_comment

begin_function
specifier|static
name|void
name|gen_rtx_next
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
block|{
name|int
name|k
decl_stmt|;
name|rtx_next
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|rtx_format
index|[
name|i
index|]
argument_list|,
literal|"iuu"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|rtx_next
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|COND_EXEC
operator|||
name|i
operator|==
name|SET
operator|||
name|i
operator|==
name|EXPR_LIST
operator|||
name|i
operator|==
name|INSN_LIST
condition|)
name|rtx_next
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|k
operator|=
name|strlen
argument_list|(
name|rtx_format
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
if|if
condition|(
name|rtx_format
index|[
name|i
index|]
index|[
name|k
index|]
operator|==
literal|'e'
operator|||
name|rtx_format
index|[
name|i
index|]
index|[
name|k
index|]
operator|==
literal|'u'
condition|)
name|rtx_next
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out the contents of the rtx_next array.  */
end_comment

begin_function
specifier|static
name|void
name|write_rtx_next
parameter_list|()
block|{
name|outf_p
name|f
init|=
name|get_output_file_with_visibility
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"\n/* Used to implement the RTX_NEXT macro.  */\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"const unsigned char rtx_next[NUM_RTX_CODE] = {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtx_next
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  0,\n"
argument_list|)
expr_stmt|;
else|else
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  offsetof (struct rtx_def, fld) + %d * sizeof (rtunion),\n"
argument_list|,
name|rtx_next
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle `special("rtx_def")'.  This is a special case for field    `fld' of struct rtx_def, which is an array of unions whose values    are based in a complex way on the type of RTL.  */
end_comment

begin_function
specifier|static
name|type_p
name|adjust_field_rtx_def
parameter_list|(
name|t
parameter_list|,
name|opt
parameter_list|)
name|type_p
name|t
decl_stmt|;
name|options_p
name|opt
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|pair_p
name|flds
init|=
name|NULL
decl_stmt|;
name|options_p
name|nodot
decl_stmt|;
name|int
name|i
decl_stmt|;
name|type_p
name|rtx_tp
decl_stmt|,
name|rtvec_tp
decl_stmt|,
name|tree_tp
decl_stmt|,
name|mem_attrs_tp
decl_stmt|,
name|note_union_tp
decl_stmt|,
name|scalar_tp
decl_stmt|;
name|type_p
name|bitmap_tp
decl_stmt|,
name|basic_block_tp
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|rtx_name
index|[
name|NUM_RTX_CODE
index|]
init|=
block|{
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|NAME ,
include|#
directive|include
file|"rtl.def"
undef|#
directive|undef
name|DEF_RTL_EXPR
block|}
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|kind
operator|!=
name|TYPE_ARRAY
condition|)
block|{
name|error_at_line
argument_list|(
operator|&
name|lexer_line
argument_list|,
literal|"special `rtx_def' must be applied to an array"
argument_list|)
expr_stmt|;
return|return
operator|&
name|string_type
return|;
block|}
name|nodot
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nodot
argument_list|)
argument_list|)
expr_stmt|;
name|nodot
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|nodot
operator|->
name|name
operator|=
literal|"dot"
expr_stmt|;
name|nodot
operator|->
name|info
operator|=
literal|""
expr_stmt|;
name|rtx_tp
operator|=
name|create_pointer
argument_list|(
name|find_structure
argument_list|(
literal|"rtx_def"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rtvec_tp
operator|=
name|create_pointer
argument_list|(
name|find_structure
argument_list|(
literal|"rtvec_def"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tree_tp
operator|=
name|create_pointer
argument_list|(
name|find_structure
argument_list|(
literal|"tree_node"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|mem_attrs_tp
operator|=
name|create_pointer
argument_list|(
name|find_structure
argument_list|(
literal|"mem_attrs"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_tp
operator|=
name|create_pointer
argument_list|(
name|find_structure
argument_list|(
literal|"bitmap_element_def"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|basic_block_tp
operator|=
name|create_pointer
argument_list|(
name|find_structure
argument_list|(
literal|"basic_block_def"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|scalar_tp
operator|=
name|create_scalar_type
argument_list|(
literal|"rtunion scalar"
argument_list|,
literal|14
argument_list|)
expr_stmt|;
block|{
name|pair_p
name|note_flds
init|=
name|NULL
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|3
condition|;
name|c
operator|++
control|)
block|{
name|pair_p
name|old_note_flds
init|=
name|note_flds
decl_stmt|;
name|note_flds
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|note_flds
argument_list|)
argument_list|)
expr_stmt|;
name|note_flds
operator|->
name|line
operator|.
name|file
operator|=
name|__FILE__
expr_stmt|;
name|note_flds
operator|->
name|line
operator|.
name|line
operator|=
name|__LINE__
expr_stmt|;
name|note_flds
operator|->
name|name
operator|=
literal|"rttree"
expr_stmt|;
name|note_flds
operator|->
name|type
operator|=
name|tree_tp
expr_stmt|;
name|note_flds
operator|->
name|opt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|note_flds
operator|->
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|note_flds
operator|->
name|opt
operator|->
name|next
operator|=
name|nodot
expr_stmt|;
name|note_flds
operator|->
name|opt
operator|->
name|name
operator|=
literal|"tag"
expr_stmt|;
name|note_flds
operator|->
name|next
operator|=
name|old_note_flds
expr_stmt|;
block|}
name|note_flds
operator|->
name|type
operator|=
name|rtx_tp
expr_stmt|;
name|note_flds
operator|->
name|name
operator|=
literal|"rtx"
expr_stmt|;
name|note_flds
operator|->
name|opt
operator|->
name|info
operator|=
literal|"NOTE_INSN_EXPECTED_VALUE"
expr_stmt|;
name|note_flds
operator|->
name|next
operator|->
name|opt
operator|->
name|info
operator|=
literal|"NOTE_INSN_BLOCK_BEG"
expr_stmt|;
name|note_flds
operator|->
name|next
operator|->
name|next
operator|->
name|opt
operator|->
name|info
operator|=
literal|"NOTE_INSN_BLOCK_END"
expr_stmt|;
name|new_structure
argument_list|(
literal|"rtx_def_note_subunion"
argument_list|,
literal|1
argument_list|,
operator|&
name|lexer_line
argument_list|,
name|note_flds
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|note_union_tp
operator|=
name|find_structure
argument_list|(
literal|"rtx_def_note_subunion"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
block|{
name|pair_p
name|old_flds
init|=
name|flds
decl_stmt|;
name|pair_p
name|subfields
init|=
name|NULL
decl_stmt|;
name|size_t
name|aindex
decl_stmt|,
name|nmindex
decl_stmt|;
specifier|const
name|char
modifier|*
name|sname
decl_stmt|;
name|char
modifier|*
name|ftag
decl_stmt|;
for|for
control|(
name|aindex
operator|=
literal|0
init|;
name|aindex
operator|<
name|strlen
argument_list|(
name|rtx_format
index|[
name|i
index|]
argument_list|)
condition|;
name|aindex
operator|++
control|)
block|{
name|pair_p
name|old_subf
init|=
name|subfields
decl_stmt|;
name|type_p
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|subname
decl_stmt|;
switch|switch
condition|(
name|rtx_format
index|[
name|i
index|]
index|[
name|aindex
index|]
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'w'
case|:
name|t
operator|=
name|scalar_tp
expr_stmt|;
name|subname
operator|=
literal|"rtint"
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
if|if
condition|(
name|i
operator|==
name|MEM
operator|&&
name|aindex
operator|==
literal|1
condition|)
name|t
operator|=
name|mem_attrs_tp
operator|,
name|subname
operator|=
literal|"rtmem"
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|JUMP_INSN
operator|&&
name|aindex
operator|==
literal|9
condition|)
name|t
operator|=
name|rtx_tp
operator|,
name|subname
operator|=
literal|"rtx"
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|CODE_LABEL
operator|&&
name|aindex
operator|==
literal|4
condition|)
name|t
operator|=
name|scalar_tp
operator|,
name|subname
operator|=
literal|"rtint"
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|CODE_LABEL
operator|&&
name|aindex
operator|==
literal|5
condition|)
name|t
operator|=
name|rtx_tp
operator|,
name|subname
operator|=
literal|"rtx"
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|LABEL_REF
operator|&&
operator|(
name|aindex
operator|==
literal|1
operator|||
name|aindex
operator|==
literal|2
operator|)
condition|)
name|t
operator|=
name|rtx_tp
operator|,
name|subname
operator|=
literal|"rtx"
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|NOTE
operator|&&
name|aindex
operator|==
literal|4
condition|)
name|t
operator|=
name|note_union_tp
operator|,
name|subname
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|NOTE
operator|&&
name|aindex
operator|>=
literal|7
condition|)
name|t
operator|=
name|scalar_tp
operator|,
name|subname
operator|=
literal|"rtint"
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|ADDR_DIFF_VEC
operator|&&
name|aindex
operator|==
literal|4
condition|)
name|t
operator|=
name|scalar_tp
operator|,
name|subname
operator|=
literal|"rtint"
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|VALUE
operator|&&
name|aindex
operator|==
literal|0
condition|)
name|t
operator|=
name|scalar_tp
operator|,
name|subname
operator|=
literal|"rtint"
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|REG
operator|&&
name|aindex
operator|==
literal|1
condition|)
name|t
operator|=
name|scalar_tp
operator|,
name|subname
operator|=
literal|"rtint"
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|SCRATCH
operator|&&
name|aindex
operator|==
literal|0
condition|)
name|t
operator|=
name|scalar_tp
operator|,
name|subname
operator|=
literal|"rtint"
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|BARRIER
operator|&&
name|aindex
operator|>=
literal|3
condition|)
name|t
operator|=
name|scalar_tp
operator|,
name|subname
operator|=
literal|"rtint"
expr_stmt|;
else|else
block|{
name|error_at_line
argument_list|(
operator|&
name|lexer_line
argument_list|,
literal|"rtx type `%s' has `0' in position %lu, can't handle"
argument_list|,
name|rtx_name
index|[
name|i
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|aindex
argument_list|)
expr_stmt|;
name|t
operator|=
operator|&
name|string_type
expr_stmt|;
name|subname
operator|=
literal|"rtint"
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
name|t
operator|=
operator|&
name|string_type
expr_stmt|;
name|subname
operator|=
literal|"rtstr"
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|t
operator|=
name|rtx_tp
expr_stmt|;
name|subname
operator|=
literal|"rtx"
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
name|t
operator|=
name|rtvec_tp
expr_stmt|;
name|subname
operator|=
literal|"rtvec"
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|t
operator|=
name|tree_tp
expr_stmt|;
name|subname
operator|=
literal|"rttree"
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|t
operator|=
name|bitmap_tp
expr_stmt|;
name|subname
operator|=
literal|"rtbit"
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|t
operator|=
name|basic_block_tp
expr_stmt|;
name|subname
operator|=
literal|"bb"
expr_stmt|;
break|break;
default|default:
name|error_at_line
argument_list|(
operator|&
name|lexer_line
argument_list|,
literal|"rtx type `%s' has `%c' in position %lu, can't handle"
argument_list|,
name|rtx_name
index|[
name|i
index|]
argument_list|,
name|rtx_format
index|[
name|i
index|]
index|[
name|aindex
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|aindex
argument_list|)
expr_stmt|;
name|t
operator|=
operator|&
name|string_type
expr_stmt|;
name|subname
operator|=
literal|"rtint"
expr_stmt|;
break|break;
block|}
name|subfields
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|subfields
argument_list|)
argument_list|)
expr_stmt|;
name|subfields
operator|->
name|next
operator|=
name|old_subf
expr_stmt|;
name|subfields
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|subfields
operator|->
name|name
operator|=
name|xasprintf
argument_list|(
literal|"[%lu].%s"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|aindex
argument_list|,
name|subname
argument_list|)
expr_stmt|;
name|subfields
operator|->
name|line
operator|.
name|file
operator|=
name|__FILE__
expr_stmt|;
name|subfields
operator|->
name|line
operator|.
name|line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|note_union_tp
condition|)
block|{
name|subfields
operator|->
name|opt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|subfields
operator|->
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|subfields
operator|->
name|opt
operator|->
name|next
operator|=
name|nodot
expr_stmt|;
name|subfields
operator|->
name|opt
operator|->
name|name
operator|=
literal|"desc"
expr_stmt|;
name|subfields
operator|->
name|opt
operator|->
name|info
operator|=
literal|"NOTE_LINE_NUMBER (&%0)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|basic_block_tp
condition|)
block|{
comment|/* We don't presently GC basic block structures...  */
name|subfields
operator|->
name|opt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|subfields
operator|->
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|subfields
operator|->
name|opt
operator|->
name|next
operator|=
name|nodot
expr_stmt|;
name|subfields
operator|->
name|opt
operator|->
name|name
operator|=
literal|"skip"
expr_stmt|;
name|subfields
operator|->
name|opt
operator|->
name|info
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|rtx_next
index|[
name|i
index|]
operator|==
name|aindex
condition|)
block|{
comment|/* The 'next' field will be marked by the chain_next option.  */
name|subfields
operator|->
name|opt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|subfields
operator|->
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|subfields
operator|->
name|opt
operator|->
name|next
operator|=
name|nodot
expr_stmt|;
name|subfields
operator|->
name|opt
operator|->
name|name
operator|=
literal|"skip"
expr_stmt|;
name|subfields
operator|->
name|opt
operator|->
name|info
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|subfields
operator|->
name|opt
operator|=
name|nodot
expr_stmt|;
block|}
name|flds
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|flds
argument_list|)
argument_list|)
expr_stmt|;
name|flds
operator|->
name|next
operator|=
name|old_flds
expr_stmt|;
name|flds
operator|->
name|name
operator|=
literal|""
expr_stmt|;
name|sname
operator|=
name|xasprintf
argument_list|(
literal|"rtx_def_%s"
argument_list|,
name|rtx_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|new_structure
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|,
operator|&
name|lexer_line
argument_list|,
name|subfields
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|flds
operator|->
name|type
operator|=
name|find_structure
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flds
operator|->
name|line
operator|.
name|file
operator|=
name|__FILE__
expr_stmt|;
name|flds
operator|->
name|line
operator|.
name|line
operator|=
name|__LINE__
expr_stmt|;
name|flds
operator|->
name|opt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|flds
operator|->
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|next
operator|=
name|nodot
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|name
operator|=
literal|"tag"
expr_stmt|;
name|ftag
operator|=
name|xstrdup
argument_list|(
name|rtx_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|nmindex
operator|=
literal|0
init|;
name|nmindex
operator|<
name|strlen
argument_list|(
name|ftag
argument_list|)
condition|;
name|nmindex
operator|++
control|)
name|ftag
index|[
name|nmindex
index|]
operator|=
name|TOUPPER
argument_list|(
name|ftag
index|[
name|nmindex
index|]
argument_list|)
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|info
operator|=
name|ftag
expr_stmt|;
block|}
name|new_structure
argument_list|(
literal|"rtx_def_subunion"
argument_list|,
literal|1
argument_list|,
operator|&
name|lexer_line
argument_list|,
name|flds
argument_list|,
name|nodot
argument_list|)
expr_stmt|;
return|return
name|find_structure
argument_list|(
literal|"rtx_def_subunion"
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle `special("tree_exp")'.  This is a special case for    field `operands' of struct tree_exp, which although it claims to contain    pointers to trees, actually sometimes contains pointers to RTL too.      Passed T, the old type of the field, and OPT its options.  Returns    a new type for the field.  */
end_comment

begin_function
specifier|static
name|type_p
name|adjust_field_tree_exp
parameter_list|(
name|t
parameter_list|,
name|opt
parameter_list|)
name|type_p
name|t
decl_stmt|;
name|options_p
name|opt
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|pair_p
name|flds
decl_stmt|;
name|options_p
name|nodot
decl_stmt|;
name|size_t
name|i
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|first_rtl
decl_stmt|;
name|int
name|num_rtl
decl_stmt|;
block|}
name|data
index|[]
init|=
block|{
block|{
literal|"SAVE_EXPR"
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|"GOTO_SUBROUTINE_EXPR"
block|,
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|"RTL_EXPR"
block|,
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|"WITH_CLEANUP_EXPR"
block|,
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|"METHOD_CALL_EXPR"
block|,
literal|3
block|,
literal|1
block|}
block|}
struct|;
if|if
condition|(
name|t
operator|->
name|kind
operator|!=
name|TYPE_ARRAY
condition|)
block|{
name|error_at_line
argument_list|(
operator|&
name|lexer_line
argument_list|,
literal|"special `tree_exp' must be applied to an array"
argument_list|)
expr_stmt|;
return|return
operator|&
name|string_type
return|;
block|}
name|nodot
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nodot
argument_list|)
argument_list|)
expr_stmt|;
name|nodot
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|nodot
operator|->
name|name
operator|=
literal|"dot"
expr_stmt|;
name|nodot
operator|->
name|info
operator|=
literal|""
expr_stmt|;
name|flds
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|flds
argument_list|)
argument_list|)
expr_stmt|;
name|flds
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|flds
operator|->
name|name
operator|=
literal|""
expr_stmt|;
name|flds
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|flds
operator|->
name|line
operator|.
name|file
operator|=
name|__FILE__
expr_stmt|;
name|flds
operator|->
name|line
operator|.
name|line
operator|=
name|__LINE__
expr_stmt|;
name|flds
operator|->
name|opt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|flds
operator|->
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|next
operator|=
name|nodot
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|name
operator|=
literal|"length"
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|info
operator|=
literal|"TREE_CODE_LENGTH (TREE_CODE ((tree)&%0))"
expr_stmt|;
block|{
name|options_p
name|oldopt
init|=
name|flds
operator|->
name|opt
decl_stmt|;
name|flds
operator|->
name|opt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|flds
operator|->
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|next
operator|=
name|oldopt
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|name
operator|=
literal|"default"
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|info
operator|=
literal|""
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|pair_p
name|old_flds
init|=
name|flds
decl_stmt|;
name|pair_p
name|subfields
init|=
name|NULL
decl_stmt|;
name|int
name|r_index
decl_stmt|;
specifier|const
name|char
modifier|*
name|sname
decl_stmt|;
for|for
control|(
name|r_index
operator|=
literal|0
init|;
name|r_index
operator|<
name|data
index|[
name|i
index|]
operator|.
name|first_rtl
operator|+
name|data
index|[
name|i
index|]
operator|.
name|num_rtl
condition|;
name|r_index
operator|++
control|)
block|{
name|pair_p
name|old_subf
init|=
name|subfields
decl_stmt|;
name|subfields
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|subfields
argument_list|)
argument_list|)
expr_stmt|;
name|subfields
operator|->
name|next
operator|=
name|old_subf
expr_stmt|;
name|subfields
operator|->
name|name
operator|=
name|xasprintf
argument_list|(
literal|"[%d]"
argument_list|,
name|r_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_index
operator|<
name|data
index|[
name|i
index|]
operator|.
name|first_rtl
condition|)
name|subfields
operator|->
name|type
operator|=
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|p
expr_stmt|;
else|else
name|subfields
operator|->
name|type
operator|=
name|create_pointer
argument_list|(
name|find_structure
argument_list|(
literal|"rtx_def"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|subfields
operator|->
name|line
operator|.
name|file
operator|=
name|__FILE__
expr_stmt|;
name|subfields
operator|->
name|line
operator|.
name|line
operator|=
name|__LINE__
expr_stmt|;
name|subfields
operator|->
name|opt
operator|=
name|nodot
expr_stmt|;
block|}
name|flds
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|flds
argument_list|)
argument_list|)
expr_stmt|;
name|flds
operator|->
name|next
operator|=
name|old_flds
expr_stmt|;
name|flds
operator|->
name|name
operator|=
literal|""
expr_stmt|;
name|sname
operator|=
name|xasprintf
argument_list|(
literal|"tree_exp_%s"
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|new_structure
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|,
operator|&
name|lexer_line
argument_list|,
name|subfields
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|flds
operator|->
name|type
operator|=
name|find_structure
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flds
operator|->
name|line
operator|.
name|file
operator|=
name|__FILE__
expr_stmt|;
name|flds
operator|->
name|line
operator|.
name|line
operator|=
name|__LINE__
expr_stmt|;
name|flds
operator|->
name|opt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|flds
operator|->
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|next
operator|=
name|nodot
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|name
operator|=
literal|"tag"
expr_stmt|;
name|flds
operator|->
name|opt
operator|->
name|info
operator|=
name|data
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
block|}
name|new_structure
argument_list|(
literal|"tree_exp_subunion"
argument_list|,
literal|1
argument_list|,
operator|&
name|lexer_line
argument_list|,
name|flds
argument_list|,
name|nodot
argument_list|)
expr_stmt|;
return|return
name|find_structure
argument_list|(
literal|"tree_exp_subunion"
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform any special processing on a type T, about to become the type    of a field.  Return the appropriate type for the field.    At present:    - Converts pointer-to-char, with no length parameter, to TYPE_STRING;    - Similarly for arrays of pointer-to-char;    - Converts structures for which a parameter is provided to      TYPE_PARAM_STRUCT;    - Handles "special" options. */
end_comment

begin_function
name|type_p
name|adjust_field_type
parameter_list|(
name|t
parameter_list|,
name|opt
parameter_list|)
name|type_p
name|t
decl_stmt|;
name|options_p
name|opt
decl_stmt|;
block|{
name|int
name|length_p
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|pointer_p
init|=
name|t
operator|->
name|kind
operator|==
name|TYPE_POINTER
decl_stmt|;
name|type_p
name|params
index|[
name|NUM_PARAM
index|]
decl_stmt|;
name|int
name|params_p
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_PARAM
condition|;
name|i
operator|++
control|)
name|params
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|opt
condition|;
name|opt
operator|=
name|opt
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
name|length_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
literal|"param_is"
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|strncmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
literal|"param"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|ISDIGIT
argument_list|(
name|opt
operator|->
name|name
index|[
literal|5
index|]
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|opt
operator|->
name|name
operator|+
literal|6
argument_list|,
literal|"_is"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|num
init|=
name|ISDIGIT
argument_list|(
name|opt
operator|->
name|name
index|[
literal|5
index|]
argument_list|)
condition|?
name|opt
operator|->
name|name
index|[
literal|5
index|]
operator|-
literal|'0'
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|UNION_OR_STRUCT_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|t
operator|->
name|kind
operator|!=
name|TYPE_POINTER
operator|||
operator|!
name|UNION_OR_STRUCT_P
argument_list|(
name|t
operator|->
name|u
operator|.
name|p
argument_list|)
operator|)
condition|)
block|{
name|error_at_line
argument_list|(
operator|&
name|lexer_line
argument_list|,
literal|"option `%s' may only be applied to structures or structure pointers"
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
name|params_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|params
index|[
name|num
index|]
operator|!=
name|NULL
condition|)
name|error_at_line
argument_list|(
operator|&
name|lexer_line
argument_list|,
literal|"duplicate `%s' option"
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|opt
operator|->
name|name
index|[
literal|5
index|]
argument_list|)
condition|)
name|params
index|[
name|num
index|]
operator|=
name|create_pointer
argument_list|(
operator|(
name|type_p
operator|)
name|opt
operator|->
name|info
argument_list|)
expr_stmt|;
else|else
name|params
index|[
name|num
index|]
operator|=
operator|(
name|type_p
operator|)
name|opt
operator|->
name|info
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
literal|"special"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|special_name
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|opt
operator|->
name|info
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|special_name
argument_list|,
literal|"tree_exp"
argument_list|)
operator|==
literal|0
condition|)
name|t
operator|=
name|adjust_field_tree_exp
argument_list|(
name|t
argument_list|,
name|opt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|special_name
argument_list|,
literal|"rtx_def"
argument_list|)
operator|==
literal|0
condition|)
name|t
operator|=
name|adjust_field_rtx_def
argument_list|(
name|t
argument_list|,
name|opt
argument_list|)
expr_stmt|;
else|else
name|error_at_line
argument_list|(
operator|&
name|lexer_line
argument_list|,
literal|"unknown special `%s'"
argument_list|,
name|special_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params_p
condition|)
block|{
name|type_p
name|realt
decl_stmt|;
if|if
condition|(
name|pointer_p
condition|)
name|t
operator|=
name|t
operator|->
name|u
operator|.
name|p
expr_stmt|;
name|realt
operator|=
name|find_param_structure
argument_list|(
name|t
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|t
operator|=
name|pointer_p
condition|?
name|create_pointer
argument_list|(
name|realt
argument_list|)
else|:
name|realt
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|length_p
operator|&&
name|pointer_p
operator|&&
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_SCALAR
operator|&&
operator|(
name|strcmp
argument_list|(
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|sc
argument_list|,
literal|"char"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|sc
argument_list|,
literal|"unsigned char"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|&
name|string_type
return|;
if|if
condition|(
name|t
operator|->
name|kind
operator|==
name|TYPE_ARRAY
operator|&&
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_POINTER
operator|&&
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|p
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_SCALAR
operator|&&
operator|(
name|strcmp
argument_list|(
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|p
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|sc
argument_list|,
literal|"char"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|p
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|sc
argument_list|,
literal|"unsigned char"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|create_array
argument_list|(
operator|&
name|string_type
argument_list|,
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|len
argument_list|)
return|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a union for YYSTYPE, as yacc would do it, given a fieldlist FIELDS    and information about the correspondance between token types and fields    in TYPEINFO.  POS is used for error messages.  */
end_comment

begin_function
name|void
name|note_yacc_type
parameter_list|(
name|o
parameter_list|,
name|fields
parameter_list|,
name|typeinfo
parameter_list|,
name|pos
parameter_list|)
name|options_p
name|o
decl_stmt|;
name|pair_p
name|fields
decl_stmt|;
name|pair_p
name|typeinfo
decl_stmt|;
name|struct
name|fileloc
modifier|*
name|pos
decl_stmt|;
block|{
name|pair_p
name|p
decl_stmt|;
name|pair_p
modifier|*
name|p_p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|typeinfo
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|pair_p
name|m
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|type
operator|==
operator|(
name|type_p
operator|)
literal|1
condition|)
block|{
name|pair_p
name|pp
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|typeinfo
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|next
control|)
if|if
condition|(
name|pp
operator|->
name|type
operator|!=
operator|(
name|type_p
operator|)
literal|1
operator|&&
name|strcmp
argument_list|(
name|pp
operator|->
name|opt
operator|->
name|info
argument_list|,
name|p
operator|->
name|opt
operator|->
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
block|}
for|for
control|(
name|m
operator|=
name|fields
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|p
operator|->
name|type
operator|=
name|m
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|NULL
condition|)
block|{
name|error_at_line
argument_list|(
operator|&
name|p
operator|->
name|line
argument_list|,
literal|"couldn't match fieldname `%s'"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|p_p
operator|=
operator|&
name|typeinfo
expr_stmt|;
while|while
condition|(
operator|*
name|p_p
condition|)
block|{
name|pair_p
name|p
init|=
operator|*
name|p_p
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|name
operator|==
name|NULL
operator|||
name|p
operator|->
name|type
operator|==
operator|(
name|type_p
operator|)
literal|1
condition|)
operator|*
name|p_p
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|p_p
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
name|new_structure
argument_list|(
literal|"yy_union"
argument_list|,
literal|1
argument_list|,
name|pos
argument_list|,
name|typeinfo
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|do_typedef
argument_list|(
literal|"YYSTYPE"
argument_list|,
name|find_structure
argument_list|(
literal|"yy_union"
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|process_gc_options
name|PARAMS
argument_list|(
operator|(
name|options_p
operator|,
expr|enum
name|gc_used_enum
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_gc_used_type
name|PARAMS
argument_list|(
operator|(
name|type_p
operator|,
expr|enum
name|gc_used_enum
operator|,
name|type_p
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_gc_used
name|PARAMS
argument_list|(
operator|(
name|pair_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle OPT for set_gc_used_type.  */
end_comment

begin_function
specifier|static
name|void
name|process_gc_options
parameter_list|(
name|opt
parameter_list|,
name|level
parameter_list|,
name|maybe_undef
parameter_list|,
name|pass_param
parameter_list|,
name|length
parameter_list|)
name|options_p
name|opt
decl_stmt|;
name|enum
name|gc_used_enum
name|level
decl_stmt|;
name|int
modifier|*
name|maybe_undef
decl_stmt|;
name|int
modifier|*
name|pass_param
decl_stmt|;
name|int
modifier|*
name|length
decl_stmt|;
block|{
name|options_p
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|opt
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"ptr_alias"
argument_list|)
operator|==
literal|0
operator|&&
name|level
operator|==
name|GC_POINTED_TO
condition|)
name|set_gc_used_type
argument_list|(
operator|(
name|type_p
operator|)
name|o
operator|->
name|info
argument_list|,
name|GC_POINTED_TO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"maybe_undef"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|maybe_undef
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"use_params"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|pass_param
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|length
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the gc_used field of T to LEVEL, and handle the types it references.  */
end_comment

begin_function
specifier|static
name|void
name|set_gc_used_type
parameter_list|(
name|t
parameter_list|,
name|level
parameter_list|,
name|param
parameter_list|)
name|type_p
name|t
decl_stmt|;
name|enum
name|gc_used_enum
name|level
decl_stmt|;
name|type_p
name|param
index|[
name|NUM_PARAM
index|]
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|->
name|gc_used
operator|>=
name|level
condition|)
return|return;
name|t
operator|->
name|gc_used
operator|=
name|level
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|kind
condition|)
block|{
case|case
name|TYPE_STRUCT
case|:
case|case
name|TYPE_UNION
case|:
block|{
name|pair_p
name|f
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|process_gc_options
argument_list|(
name|t
operator|->
name|u
operator|.
name|s
operator|.
name|opt
argument_list|,
name|level
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|t
operator|->
name|u
operator|.
name|s
operator|.
name|fields
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
name|int
name|maybe_undef
init|=
literal|0
decl_stmt|;
name|int
name|pass_param
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|process_gc_options
argument_list|(
name|f
operator|->
name|opt
argument_list|,
name|level
argument_list|,
operator|&
name|maybe_undef
argument_list|,
operator|&
name|pass_param
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|&&
name|f
operator|->
name|type
operator|->
name|kind
operator|==
name|TYPE_POINTER
condition|)
name|set_gc_used_type
argument_list|(
name|f
operator|->
name|type
operator|->
name|u
operator|.
name|p
argument_list|,
name|GC_USED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|maybe_undef
operator|&&
name|f
operator|->
name|type
operator|->
name|kind
operator|==
name|TYPE_POINTER
condition|)
name|set_gc_used_type
argument_list|(
name|f
operator|->
name|type
operator|->
name|u
operator|.
name|p
argument_list|,
name|GC_MAYBE_POINTED_TO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pass_param
operator|&&
name|f
operator|->
name|type
operator|->
name|kind
operator|==
name|TYPE_POINTER
operator|&&
name|param
condition|)
name|set_gc_used_type
argument_list|(
name|find_param_structure
argument_list|(
name|f
operator|->
name|type
operator|->
name|u
operator|.
name|p
argument_list|,
name|param
argument_list|)
argument_list|,
name|GC_POINTED_TO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|set_gc_used_type
argument_list|(
name|f
operator|->
name|type
argument_list|,
name|GC_USED
argument_list|,
name|pass_param
condition|?
name|param
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TYPE_POINTER
case|:
name|set_gc_used_type
argument_list|(
name|t
operator|->
name|u
operator|.
name|p
argument_list|,
name|GC_POINTED_TO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_ARRAY
case|:
name|set_gc_used_type
argument_list|(
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|p
argument_list|,
name|GC_USED
argument_list|,
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_LANG_STRUCT
case|:
for|for
control|(
name|t
operator|=
name|t
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
name|set_gc_used_type
argument_list|(
name|t
argument_list|,
name|level
argument_list|,
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_PARAM_STRUCT
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_PARAM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|u
operator|.
name|param_struct
operator|.
name|param
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|set_gc_used_type
argument_list|(
name|t
operator|->
name|u
operator|.
name|param_struct
operator|.
name|param
index|[
name|i
index|]
argument_list|,
name|GC_USED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|u
operator|.
name|param_struct
operator|.
name|stru
operator|->
name|gc_used
operator|==
name|GC_POINTED_TO
condition|)
name|level
operator|=
name|GC_POINTED_TO
expr_stmt|;
else|else
name|level
operator|=
name|GC_USED
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|param_struct
operator|.
name|stru
operator|->
name|gc_used
operator|=
name|GC_UNUSED
expr_stmt|;
name|set_gc_used_type
argument_list|(
name|t
operator|->
name|u
operator|.
name|param_struct
operator|.
name|stru
argument_list|,
name|level
argument_list|,
name|t
operator|->
name|u
operator|.
name|param_struct
operator|.
name|param
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Set the gc_used fields of all the types pointed to by VARIABLES.  */
end_comment

begin_function
specifier|static
name|void
name|set_gc_used
parameter_list|(
name|variables
parameter_list|)
name|pair_p
name|variables
decl_stmt|;
block|{
name|pair_p
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|variables
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|set_gc_used_type
argument_list|(
name|p
operator|->
name|type
argument_list|,
name|GC_USED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* File mapping routines.  For each input file, there is one output .c file    (but some output files have many input files), and there is one .h file    for the whole build.  */
end_comment

begin_comment
comment|/* The list of output files.  */
end_comment

begin_decl_stmt
specifier|static
name|outf_p
name|output_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The output header file that is included into pretty much every    source file.  */
end_comment

begin_decl_stmt
name|outf_p
name|header_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of files specified in gtfiles.  */
end_comment

begin_define
define|#
directive|define
name|NUM_GT_FILES
value|(ARRAY_SIZE (all_files) - 1)
end_define

begin_comment
comment|/* Number of files in the language files array.  */
end_comment

begin_define
define|#
directive|define
name|NUM_LANG_FILES
value|(ARRAY_SIZE (lang_files) - 1)
end_define

begin_comment
comment|/* Length of srcdir name.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srcdir_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_BASE_FILES
value|(ARRAY_SIZE (lang_dir_names) - 1)
end_define

begin_decl_stmt
name|outf_p
name|base_files
index|[
name|NUM_BASE_FILES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|outf_p
name|create_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_file_basename
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create and return an outf_p for a new file for NAME, to be called    ONAME.  */
end_comment

begin_function
specifier|static
name|outf_p
name|create_file
parameter_list|(
name|name
parameter_list|,
name|oname
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|oname
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|hdr
index|[]
init|=
block|{
literal|"   Copyright (C) 2002 Free Software Foundation, Inc.\n"
block|,
literal|"\n"
block|,
literal|"This file is part of GCC.\n"
block|,
literal|"\n"
block|,
literal|"GCC is free software; you can redistribute it and/or modify it under\n"
block|,
literal|"the terms of the GNU General Public License as published by the Free\n"
block|,
literal|"Software Foundation; either version 2, or (at your option) any later\n"
block|,
literal|"version.\n"
block|,
literal|"\n"
block|,
literal|"GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n"
block|,
literal|"WARRANTY; without even the implied warranty of MERCHANTABILITY or\n"
block|,
literal|"FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n"
block|,
literal|"for more details.\n"
block|,
literal|"\n"
block|,
literal|"You should have received a copy of the GNU General Public License\n"
block|,
literal|"along with GCC; see the file COPYING.  If not, write to the Free\n"
block|,
literal|"Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n"
block|,
literal|"02111-1307, USA.  */\n"
block|,
literal|"\n"
block|,
literal|"/* This file is machine generated.  Do not edit.  */\n"
block|}
decl_stmt|;
name|outf_p
name|f
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|f
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|output_files
expr_stmt|;
name|f
operator|->
name|name
operator|=
name|oname
expr_stmt|;
name|output_files
operator|=
name|f
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"/* Type information for %s.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|hdr
argument_list|)
condition|;
name|i
operator|++
control|)
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|hdr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Print, like fprintf, to O.  */
end_comment

begin_decl_stmt
name|void
name|oprintf
name|VPARAMS
argument_list|(
operator|(
name|outf_p
name|o
operator|,
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|slength
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|outf_p
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|slength
operator|=
name|xvasprintf
argument_list|(
operator|&
name|s
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|bufused
operator|+
name|slength
operator|>
name|o
operator|->
name|buflength
condition|)
block|{
name|size_t
name|new_len
init|=
name|o
operator|->
name|buflength
decl_stmt|;
if|if
condition|(
name|new_len
operator|==
literal|0
condition|)
name|new_len
operator|=
literal|1024
expr_stmt|;
do|do
block|{
name|new_len
operator|*=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|o
operator|->
name|bufused
operator|+
name|slength
operator|>=
name|new_len
condition|)
do|;
name|o
operator|->
name|buf
operator|=
name|xrealloc
argument_list|(
name|o
operator|->
name|buf
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|o
operator|->
name|buflength
operator|=
name|new_len
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|o
operator|->
name|buf
operator|+
name|o
operator|->
name|bufused
argument_list|,
name|s
argument_list|,
name|slength
argument_list|)
expr_stmt|;
name|o
operator|->
name|bufused
operator|+=
name|slength
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Open the global header file and the language-specific header files.  */
end_comment

begin_function
specifier|static
name|void
name|open_base_files
parameter_list|()
block|{
name|size_t
name|i
decl_stmt|;
name|header_file
operator|=
name|create_file
argument_list|(
literal|"GCC"
argument_list|,
literal|"gtype-desc.h"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_BASE_FILES
condition|;
name|i
operator|++
control|)
name|base_files
index|[
name|i
index|]
operator|=
name|create_file
argument_list|(
name|lang_dir_names
index|[
name|i
index|]
argument_list|,
name|xasprintf
argument_list|(
literal|"gtype-%s.h"
argument_list|,
name|lang_dir_names
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* gtype-desc.c is a little special, so we create it here.  */
block|{
comment|/* The order of files here matters very much.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ifiles
index|[]
init|=
block|{
literal|"config.h"
block|,
literal|"system.h"
block|,
literal|"varray.h"
block|,
literal|"hashtab.h"
block|,
literal|"splay-tree.h"
block|,
literal|"bitmap.h"
block|,
literal|"tree.h"
block|,
literal|"rtl.h"
block|,
literal|"function.h"
block|,
literal|"insn-config.h"
block|,
literal|"expr.h"
block|,
literal|"hard-reg-set.h"
block|,
literal|"basic-block.h"
block|,
literal|"cselib.h"
block|,
literal|"insn-addr.h"
block|,
literal|"ssa.h"
block|,
literal|"optabs.h"
block|,
literal|"libfuncs.h"
block|,
literal|"debug.h"
block|,
literal|"ggc.h"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|ifp
decl_stmt|;
name|outf_p
name|gtype_desc_c
decl_stmt|;
name|gtype_desc_c
operator|=
name|create_file
argument_list|(
literal|"GCC"
argument_list|,
literal|"gtype-desc.c"
argument_list|)
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifiles
init|;
operator|*
name|ifp
condition|;
name|ifp
operator|++
control|)
name|oprintf
argument_list|(
name|gtype_desc_c
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
operator|*
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine the pathname to F relative to $(srcdir).  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_file_basename
parameter_list|(
name|f
parameter_list|)
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|basename
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|basename
operator|=
name|strrchr
argument_list|(
name|f
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basename
condition|)
return|return
name|f
return|;
name|len
operator|=
name|strlen
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|basename
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUM_BASE_FILES
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|s1
decl_stmt|;
specifier|const
name|char
modifier|*
name|s2
decl_stmt|;
name|int
name|l1
decl_stmt|;
name|int
name|l2
decl_stmt|;
name|s1
operator|=
name|basename
operator|-
name|strlen
argument_list|(
name|lang_dir_names
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|s2
operator|=
name|lang_dir_names
index|[
name|i
index|]
expr_stmt|;
name|l1
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1
operator|>=
name|l2
operator|&&
operator|!
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|l2
argument_list|)
condition|)
block|{
name|basename
operator|-=
name|l2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|basename
operator|-
name|f
operator|-
literal|1
operator|)
operator|!=
name|srcdir_len
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Match is wrong - should be preceded by $srcdir.  */
break|break;
block|}
block|}
return|return
name|basename
return|;
block|}
end_function

begin_comment
comment|/* Return a bitmap which has bit `1<< BASE_FILE_<lang>' set iff    INPUT_FILE is used by<lang>.       This function should be written to assume that a file _is_ used    if the situation is unclear.  If it wrongly assumes a file _is_ used,    a linker error will result.  If it wrongly assumes a file _is not_ used,    some GC roots may be missed, which is a much harder-to-debug problem.  */
end_comment

begin_function
name|unsigned
name|get_base_file_bitmap
parameter_list|(
name|input_file
parameter_list|)
specifier|const
name|char
modifier|*
name|input_file
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|basename
init|=
name|get_file_basename
argument_list|(
name|input_file
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|slashpos
init|=
name|strchr
argument_list|(
name|basename
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|unsigned
name|k
decl_stmt|;
name|unsigned
name|bitmap
decl_stmt|;
if|if
condition|(
name|slashpos
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUM_BASE_FILES
condition|;
name|i
operator|++
control|)
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|slashpos
operator|-
name|basename
argument_list|)
operator|==
name|strlen
argument_list|(
name|lang_dir_names
index|[
name|i
index|]
argument_list|)
operator|&&
name|memcmp
argument_list|(
name|basename
argument_list|,
name|lang_dir_names
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|lang_dir_names
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It's in a language directory, set that language.  */
name|bitmap
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
return|return
name|bitmap
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* Should have found the language.  */
block|}
comment|/* If it's in any config-lang.in, then set for the languages      specified.  */
name|bitmap
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_LANG_FILES
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|input_file
argument_list|,
name|lang_files
index|[
name|j
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_BASE_FILES
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|lang_dir_names
index|[
name|k
index|]
argument_list|,
name|langs_for_lang_files
index|[
name|j
index|]
argument_list|)
condition|)
name|bitmap
operator||=
operator|(
literal|1
operator|<<
name|k
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Otherwise, set all languages.  */
if|if
condition|(
operator|!
name|bitmap
condition|)
name|bitmap
operator|=
operator|(
literal|1
operator|<<
name|NUM_BASE_FILES
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|bitmap
return|;
block|}
end_function

begin_comment
comment|/* An output file, suitable for definitions, that can see declarations    made in INPUT_FILE and is linked into every language that uses    INPUT_FILE.  */
end_comment

begin_function
name|outf_p
name|get_output_file_with_visibility
parameter_list|(
name|input_file
parameter_list|)
specifier|const
name|char
modifier|*
name|input_file
decl_stmt|;
block|{
name|outf_p
name|r
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|basename
decl_stmt|;
specifier|const
name|char
modifier|*
name|for_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|output_name
decl_stmt|;
comment|/* This can happen when we need a file with visibility on a      structure that we've never seen.  We have to just hope that it's      globally visible.  */
if|if
condition|(
name|input_file
operator|==
name|NULL
condition|)
name|input_file
operator|=
literal|"system.h"
expr_stmt|;
comment|/* Determine the output file name.  */
name|basename
operator|=
name|get_file_basename
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>
literal|2
operator|&&
name|memcmp
argument_list|(
name|basename
operator|+
name|len
operator|-
literal|2
argument_list|,
literal|".c"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|len
operator|>
literal|2
operator|&&
name|memcmp
argument_list|(
name|basename
operator|+
name|len
operator|-
literal|2
argument_list|,
literal|".y"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|len
operator|>
literal|3
operator|&&
name|memcmp
argument_list|(
name|basename
operator|+
name|len
operator|-
literal|3
argument_list|,
literal|".in"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|output_name
operator|=
name|s
operator|=
name|xasprintf
argument_list|(
literal|"gt-%s"
argument_list|,
name|basename
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|'.'
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'-'
condition|)
operator|*
name|s
operator|=
literal|'-'
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
literal|".h"
argument_list|,
sizeof|sizeof
argument_list|(
literal|".h"
argument_list|)
argument_list|)
expr_stmt|;
name|for_name
operator|=
name|basename
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|basename
argument_list|,
literal|"c-common.h"
argument_list|)
operator|==
literal|0
condition|)
name|output_name
operator|=
literal|"gt-c-common.h"
operator|,
name|for_name
operator|=
literal|"c-common.c"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|basename
argument_list|,
literal|"c-tree.h"
argument_list|)
operator|==
literal|0
condition|)
name|output_name
operator|=
literal|"gt-c-decl.h"
operator|,
name|for_name
operator|=
literal|"c-decl.c"
expr_stmt|;
else|else
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_BASE_FILES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|basename
argument_list|,
name|lang_dir_names
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|lang_dir_names
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|basename
index|[
name|strlen
argument_list|(
name|lang_dir_names
index|[
name|i
index|]
argument_list|)
index|]
operator|==
literal|'/'
condition|)
return|return
name|base_files
index|[
name|i
index|]
return|;
name|output_name
operator|=
literal|"gtype-desc.c"
expr_stmt|;
name|for_name
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Look through to see if we've ever seen this output filename before.  */
for|for
control|(
name|r
operator|=
name|output_files
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|r
operator|->
name|name
argument_list|,
name|output_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|r
return|;
comment|/* If not, create it.  */
name|r
operator|=
name|create_file
argument_list|(
name|for_name
argument_list|,
name|output_name
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* The name of an output file, suitable for definitions, that can see    declarations made in INPUT_FILE and is linked into every language    that uses INPUT_FILE.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_output_file_name
parameter_list|(
name|input_file
parameter_list|)
specifier|const
name|char
modifier|*
name|input_file
decl_stmt|;
block|{
return|return
name|get_output_file_with_visibility
argument_list|(
name|input_file
argument_list|)
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Copy the output to its final destination,    but don't unnecessarily change modification times.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|close_output_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|close_output_files
parameter_list|()
block|{
name|outf_p
name|of
decl_stmt|;
for|for
control|(
name|of
operator|=
name|output_files
init|;
name|of
condition|;
name|of
operator|=
name|of
operator|->
name|next
control|)
block|{
name|FILE
modifier|*
name|newfile
decl_stmt|;
name|newfile
operator|=
name|fopen
argument_list|(
name|of
operator|->
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfile
operator|!=
name|NULL
condition|)
block|{
name|int
name|no_write_p
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|of
operator|->
name|bufused
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|fgetc
argument_list|(
name|newfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
operator|||
name|ch
operator|!=
operator|(
name|unsigned
name|char
operator|)
name|of
operator|->
name|buf
index|[
name|i
index|]
condition|)
break|break;
block|}
name|no_write_p
operator|=
name|i
operator|==
name|of
operator|->
name|bufused
operator|&&
name|fgetc
argument_list|(
name|newfile
argument_list|)
operator|==
name|EOF
expr_stmt|;
name|fclose
argument_list|(
name|newfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_write_p
condition|)
continue|continue;
block|}
name|newfile
operator|=
name|fopen
argument_list|(
name|of
operator|->
name|name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfile
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"opening output file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|of
operator|->
name|buf
argument_list|,
literal|1
argument_list|,
name|of
operator|->
name|bufused
argument_list|,
name|newfile
argument_list|)
operator|!=
name|of
operator|->
name|bufused
condition|)
block|{
name|perror
argument_list|(
literal|"writing output file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|newfile
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"closing output file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|flist
block|{
name|struct
name|flist
modifier|*
name|next
decl_stmt|;
name|int
name|started_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|outf_p
name|f
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|output_escaped_param
name|PARAMS
argument_list|(
operator|(
name|outf_p
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|fileloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_mangled_typename
name|PARAMS
argument_list|(
operator|(
name|outf_p
operator|,
name|type_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_gc_structure_fields
name|PARAMS
argument_list|(
operator|(
name|outf_p
operator|,
name|type_p
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|options_p
operator|,
name|int
operator|,
expr|struct
name|fileloc
operator|*
operator|,
name|lang_bitmap
operator|,
name|type_p
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_gc_marker_routine_for_structure
name|PARAMS
argument_list|(
operator|(
name|type_p
operator|,
name|type_p
operator|,
name|type_p
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_gc_types
name|PARAMS
argument_list|(
operator|(
name|type_p
name|structures
operator|,
name|type_p
name|param_structs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_enum_defn
name|PARAMS
argument_list|(
operator|(
name|type_p
name|structures
operator|,
name|type_p
name|param_structs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|put_mangled_filename
name|PARAMS
argument_list|(
operator|(
name|outf_p
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_root_table
name|PARAMS
argument_list|(
operator|(
expr|struct
name|flist
operator|*
name|flp
operator|,
specifier|const
name|char
operator|*
name|pfx
operator|,
specifier|const
name|char
operator|*
name|tname
operator|,
specifier|const
name|char
operator|*
name|lastname
operator|,
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_gc_root
name|PARAMS
argument_list|(
operator|(
name|outf_p
operator|,
name|pair_p
operator|,
name|type_p
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|fileloc
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_gc_roots
name|PARAMS
argument_list|(
operator|(
name|pair_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gc_counter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print PARAM to OF processing escapes.  VAL references the current object,    PREV_VAL the object containing the current object, ONAME is the name    of the option and LINE is used to print error messages.  */
end_comment

begin_function
specifier|static
name|void
name|output_escaped_param
parameter_list|(
name|of
parameter_list|,
name|param
parameter_list|,
name|val
parameter_list|,
name|prev_val
parameter_list|,
name|oname
parameter_list|,
name|line
parameter_list|)
name|outf_p
name|of
decl_stmt|;
specifier|const
name|char
modifier|*
name|param
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|prev_val
decl_stmt|;
specifier|const
name|char
modifier|*
name|oname
decl_stmt|;
name|struct
name|fileloc
modifier|*
name|line
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|param
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'%'
condition|)
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'h'
case|:
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"(%s)"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"(*x)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"(%s)"
argument_list|,
name|prev_val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
block|{
specifier|const
name|char
modifier|*
name|pp
init|=
name|val
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
decl_stmt|;
while|while
condition|(
name|pp
index|[
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
while|while
condition|(
operator|*
name|pp
operator|!=
literal|'['
condition|)
name|pp
operator|--
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%s"
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error_at_line
argument_list|(
name|line
argument_list|,
literal|"`%s' option contains bad escape %c%c"
argument_list|,
name|oname
argument_list|,
literal|'%'
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a mangled name representing T to OF.  */
end_comment

begin_function
specifier|static
name|void
name|output_mangled_typename
parameter_list|(
name|of
parameter_list|,
name|t
parameter_list|)
name|outf_p
name|of
decl_stmt|;
name|type_p
name|t
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"Z"
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|t
operator|->
name|kind
condition|)
block|{
case|case
name|TYPE_POINTER
case|:
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"P"
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|of
argument_list|,
name|t
operator|->
name|u
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_SCALAR
case|:
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"I"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_STRING
case|:
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"S"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_STRUCT
case|:
case|case
name|TYPE_UNION
case|:
case|case
name|TYPE_LANG_STRUCT
case|:
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%lu%s"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|strlen
argument_list|(
name|t
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
argument_list|,
name|t
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_PARAM_STRUCT
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_PARAM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|u
operator|.
name|param_struct
operator|.
name|param
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|output_mangled_typename
argument_list|(
name|of
argument_list|,
name|t
operator|->
name|u
operator|.
name|param_struct
operator|.
name|param
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|of
argument_list|,
name|t
operator|->
name|u
operator|.
name|param_struct
operator|.
name|stru
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_ARRAY
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out code to OF which marks the fields of S.  VAL references    the current object, PREV_VAL the object containing the current    object, OPTS is a list of options to apply, INDENT is the current    indentation level, LINE is used to print error messages, BITMAP    indicates which languages to print the structure for, and PARAM is    the current parameter (from an enclosing param_is option).  */
end_comment

begin_function
specifier|static
name|void
name|write_gc_structure_fields
parameter_list|(
name|of
parameter_list|,
name|s
parameter_list|,
name|val
parameter_list|,
name|prev_val
parameter_list|,
name|opts
parameter_list|,
name|indent
parameter_list|,
name|line
parameter_list|,
name|bitmap
parameter_list|,
name|param
parameter_list|)
name|outf_p
name|of
decl_stmt|;
name|type_p
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|prev_val
decl_stmt|;
name|options_p
name|opts
decl_stmt|;
name|int
name|indent
decl_stmt|;
name|struct
name|fileloc
modifier|*
name|line
decl_stmt|;
name|lang_bitmap
name|bitmap
decl_stmt|;
name|type_p
modifier|*
name|param
decl_stmt|;
block|{
name|pair_p
name|f
decl_stmt|;
name|int
name|seen_default
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
operator|.
name|file
condition|)
name|error_at_line
argument_list|(
name|line
argument_list|,
literal|"incomplete structure `%s'"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|bitmap
operator|&
name|bitmap
operator|)
operator|!=
name|bitmap
condition|)
block|{
name|error_at_line
argument_list|(
name|line
argument_list|,
literal|"structure defined for mismatching languages"
argument_list|)
expr_stmt|;
name|error_at_line
argument_list|(
operator|&
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
argument_list|,
literal|"one structure defined here"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|)
block|{
specifier|const
name|char
modifier|*
name|tagexpr
init|=
name|NULL
decl_stmt|;
name|options_p
name|oo
decl_stmt|;
for|for
control|(
name|oo
operator|=
name|opts
init|;
name|oo
condition|;
name|oo
operator|=
name|oo
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"desc"
argument_list|)
operator|==
literal|0
condition|)
name|tagexpr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|oo
operator|->
name|info
expr_stmt|;
if|if
condition|(
name|tagexpr
operator|==
name|NULL
condition|)
block|{
name|tagexpr
operator|=
literal|"1"
expr_stmt|;
name|error_at_line
argument_list|(
name|line
argument_list|,
literal|"missing `desc' option"
argument_list|)
expr_stmt|;
block|}
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sswitch ("
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|output_escaped_param
argument_list|(
name|of
argument_list|,
name|tagexpr
argument_list|,
name|val
argument_list|,
name|prev_val
argument_list|,
literal|"desc"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|indent
operator|+=
literal|2
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*s{\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|f
operator|=
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|fields
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|tagid
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|length
init|=
name|NULL
decl_stmt|;
name|int
name|skip_p
init|=
literal|0
decl_stmt|;
name|int
name|default_p
init|=
literal|0
decl_stmt|;
name|int
name|maybe_undef_p
init|=
literal|0
decl_stmt|;
name|int
name|use_param_num
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|use_params_p
init|=
literal|0
decl_stmt|;
name|int
name|needs_cast_p
init|=
literal|0
decl_stmt|;
name|options_p
name|oo
decl_stmt|;
name|type_p
name|t
init|=
name|f
operator|->
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|dot
init|=
literal|"."
decl_stmt|;
for|for
control|(
name|oo
operator|=
name|f
operator|->
name|opt
init|;
name|oo
condition|;
name|oo
operator|=
name|oo
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
name|length
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|oo
operator|->
name|info
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"maybe_undef"
argument_list|)
operator|==
literal|0
condition|)
name|maybe_undef_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"tag"
argument_list|)
operator|==
literal|0
condition|)
name|tagid
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|oo
operator|->
name|info
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"special"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"skip"
argument_list|)
operator|==
literal|0
condition|)
name|skip_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
name|default_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"desc"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"descbits"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"param_is"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"use_param"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|oo
operator|->
name|name
index|[
literal|9
index|]
operator|==
literal|'\0'
operator|||
name|ISDIGIT
argument_list|(
name|oo
operator|->
name|name
index|[
literal|9
index|]
argument_list|)
operator|)
condition|)
name|use_param_num
operator|=
name|oo
operator|->
name|name
index|[
literal|9
index|]
operator|==
literal|'\0'
condition|?
literal|0
else|:
name|oo
operator|->
name|name
index|[
literal|9
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"use_params"
argument_list|)
operator|==
literal|0
condition|)
name|use_params_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"dot"
argument_list|)
operator|==
literal|0
condition|)
name|dot
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|oo
operator|->
name|info
expr_stmt|;
else|else
name|error_at_line
argument_list|(
operator|&
name|f
operator|->
name|line
argument_list|,
literal|"unknown field option `%s'\n"
argument_list|,
name|oo
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_p
condition|)
continue|continue;
if|if
condition|(
name|use_params_p
condition|)
block|{
name|int
name|pointer_p
init|=
name|t
operator|->
name|kind
operator|==
name|TYPE_POINTER
decl_stmt|;
if|if
condition|(
name|pointer_p
condition|)
name|t
operator|=
name|t
operator|->
name|u
operator|.
name|p
expr_stmt|;
name|t
operator|=
name|find_param_structure
argument_list|(
name|t
argument_list|,
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointer_p
condition|)
name|t
operator|=
name|create_pointer
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_param_num
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|param
operator|!=
name|NULL
operator|&&
name|param
index|[
name|use_param_num
index|]
operator|!=
name|NULL
condition|)
block|{
name|type_p
name|nt
init|=
name|param
index|[
name|use_param_num
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|kind
operator|==
name|TYPE_ARRAY
condition|)
name|nt
operator|=
name|create_array
argument_list|(
name|nt
argument_list|,
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|length
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|kind
operator|==
name|TYPE_POINTER
condition|)
name|nt
operator|=
name|create_pointer
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|needs_cast_p
operator|=
operator|(
name|t
operator|->
name|kind
operator|!=
name|TYPE_POINTER
operator|&&
name|nt
operator|->
name|kind
operator|==
name|TYPE_POINTER
operator|)
expr_stmt|;
name|t
operator|=
name|nt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|kind
operator|!=
name|TYPE_UNION
condition|)
name|error_at_line
argument_list|(
operator|&
name|f
operator|->
name|line
argument_list|,
literal|"no parameter defined"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|kind
operator|==
name|TYPE_SCALAR
operator|||
operator|(
name|t
operator|->
name|kind
operator|==
name|TYPE_ARRAY
operator|&&
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_SCALAR
operator|)
condition|)
continue|continue;
name|seen_default
operator||=
name|default_p
expr_stmt|;
if|if
condition|(
name|maybe_undef_p
operator|&&
operator|(
name|t
operator|->
name|kind
operator|!=
name|TYPE_POINTER
operator|||
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|!=
name|TYPE_STRUCT
operator|)
condition|)
name|error_at_line
argument_list|(
operator|&
name|f
operator|->
name|line
argument_list|,
literal|"field `%s' has invalid option `maybe_undef_p'\n"
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|)
block|{
if|if
condition|(
name|tagid
condition|)
block|{
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*scase %s:\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|tagid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|default_p
condition|)
block|{
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sdefault:\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error_at_line
argument_list|(
operator|&
name|f
operator|->
name|line
argument_list|,
literal|"field `%s' has no tag"
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|indent
operator|+=
literal|2
expr_stmt|;
block|}
switch|switch
condition|(
name|t
operator|->
name|kind
condition|)
block|{
case|case
name|TYPE_STRING
case|:
comment|/* Do nothing; strings go in the string pool.  */
break|break;
case|case
name|TYPE_LANG_STRUCT
case|:
block|{
name|type_p
name|ti
decl_stmt|;
for|for
control|(
name|ti
operator|=
name|t
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
init|;
name|ti
condition|;
name|ti
operator|=
name|ti
operator|->
name|next
control|)
if|if
condition|(
name|ti
operator|->
name|u
operator|.
name|s
operator|.
name|bitmap
operator|&
name|bitmap
condition|)
block|{
name|t
operator|=
name|ti
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ti
operator|==
name|NULL
condition|)
block|{
name|error_at_line
argument_list|(
operator|&
name|f
operator|->
name|line
argument_list|,
literal|"structure not defined for this language"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fall through...  */
case|case
name|TYPE_STRUCT
case|:
case|case
name|TYPE_UNION
case|:
block|{
name|char
modifier|*
name|newval
decl_stmt|;
name|newval
operator|=
name|xasprintf
argument_list|(
literal|"%s%s%s"
argument_list|,
name|val
argument_list|,
name|dot
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
name|write_gc_structure_fields
argument_list|(
name|of
argument_list|,
name|t
argument_list|,
name|newval
argument_list|,
name|val
argument_list|,
name|f
operator|->
name|opt
argument_list|,
name|indent
argument_list|,
operator|&
name|f
operator|->
name|line
argument_list|,
name|bitmap
argument_list|,
name|param
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newval
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TYPE_POINTER
case|:
if|if
condition|(
operator|!
name|length
condition|)
block|{
if|if
condition|(
name|maybe_undef_p
operator|&&
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|s
operator|.
name|line
operator|.
name|file
operator|==
name|NULL
condition|)
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sif (%s%s%s) abort();\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|val
argument_list|,
name|dot
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|UNION_OR_STRUCT_P
argument_list|(
name|t
operator|->
name|u
operator|.
name|p
argument_list|)
operator|||
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_PARAM_STRUCT
condition|)
block|{
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sgt_ggc_m_"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|of
argument_list|,
name|t
operator|->
name|u
operator|.
name|p
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_cast_p
condition|)
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"(%s %s *)"
argument_list|,
name|UNION_P
argument_list|(
name|t
operator|->
name|u
operator|.
name|p
argument_list|)
condition|?
literal|"union"
else|:
literal|"struct"
argument_list|,
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%s%s%s);\n"
argument_list|,
name|val
argument_list|,
name|dot
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error_at_line
argument_list|(
operator|&
name|f
operator|->
name|line
argument_list|,
literal|"field `%s' is pointer to scalar"
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_SCALAR
operator|||
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_STRING
condition|)
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sggc_mark (%s%s%s);\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|val
argument_list|,
name|dot
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|loopcounter
init|=
operator|++
name|gc_counter
decl_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sif (%s%s%s != NULL) {\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|val
argument_list|,
name|dot
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
name|indent
operator|+=
literal|2
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*ssize_t i%d;\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|loopcounter
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sggc_set_mark (%s%s%s);\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|val
argument_list|,
name|dot
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sfor (i%d = 0; i%d< (size_t)("
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|loopcounter
argument_list|,
name|loopcounter
argument_list|)
expr_stmt|;
name|output_escaped_param
argument_list|(
name|of
argument_list|,
name|length
argument_list|,
name|val
argument_list|,
name|prev_val
argument_list|,
literal|"length"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"); i%d++) {\n"
argument_list|,
name|loopcounter
argument_list|)
expr_stmt|;
name|indent
operator|+=
literal|2
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|kind
condition|)
block|{
case|case
name|TYPE_STRUCT
case|:
case|case
name|TYPE_UNION
case|:
block|{
name|char
modifier|*
name|newval
decl_stmt|;
name|newval
operator|=
name|xasprintf
argument_list|(
literal|"%s%s%s[i%d]"
argument_list|,
name|val
argument_list|,
name|dot
argument_list|,
name|f
operator|->
name|name
argument_list|,
name|loopcounter
argument_list|)
expr_stmt|;
name|write_gc_structure_fields
argument_list|(
name|of
argument_list|,
name|t
operator|->
name|u
operator|.
name|p
argument_list|,
name|newval
argument_list|,
name|val
argument_list|,
name|f
operator|->
name|opt
argument_list|,
name|indent
argument_list|,
operator|&
name|f
operator|->
name|line
argument_list|,
name|bitmap
argument_list|,
name|param
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newval
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TYPE_POINTER
case|:
if|if
condition|(
name|UNION_OR_STRUCT_P
argument_list|(
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|p
argument_list|)
operator|||
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_PARAM_STRUCT
condition|)
block|{
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sgt_ggc_m_"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|of
argument_list|,
name|t
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|p
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|" (%s%s%s[i%d]);\n"
argument_list|,
name|val
argument_list|,
name|dot
argument_list|,
name|f
operator|->
name|name
argument_list|,
name|loopcounter
argument_list|)
expr_stmt|;
block|}
else|else
name|error_at_line
argument_list|(
operator|&
name|f
operator|->
name|line
argument_list|,
literal|"field `%s' is array of pointer to scalar"
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error_at_line
argument_list|(
operator|&
name|f
operator|->
name|line
argument_list|,
literal|"field `%s' is array of unimplemented type"
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|indent
operator|-=
literal|2
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*s}\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*s}\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_ARRAY
case|:
block|{
name|int
name|loopcounter
init|=
operator|++
name|gc_counter
decl_stmt|;
name|type_p
name|ta
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|length
operator|&&
operator|(
name|strcmp
argument_list|(
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|len
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|len
argument_list|,
literal|"1"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|error_at_line
argument_list|(
operator|&
name|f
operator|->
name|line
argument_list|,
literal|"field `%s' is array of size %s"
argument_list|,
name|f
operator|->
name|name
argument_list|,
name|t
operator|->
name|u
operator|.
name|a
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* Arrays of scalars can be ignored.  */
for|for
control|(
name|ta
operator|=
name|t
init|;
name|ta
operator|->
name|kind
operator|==
name|TYPE_ARRAY
condition|;
name|ta
operator|=
name|ta
operator|->
name|u
operator|.
name|a
operator|.
name|p
control|)
empty_stmt|;
if|if
condition|(
name|ta
operator|->
name|kind
operator|==
name|TYPE_SCALAR
operator|||
name|ta
operator|->
name|kind
operator|==
name|TYPE_STRING
condition|)
break|break;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*s{\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|indent
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|ta
operator|=
name|t
operator|,
name|i
operator|=
literal|0
init|;
name|ta
operator|->
name|kind
operator|==
name|TYPE_ARRAY
condition|;
name|ta
operator|=
name|ta
operator|->
name|u
operator|.
name|a
operator|.
name|p
operator|,
name|i
operator|++
control|)
block|{
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*ssize_t i%d_%d;\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|loopcounter
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sconst size_t ilimit%d_%d = ("
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|loopcounter
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|length
operator|!=
name|NULL
condition|)
name|output_escaped_param
argument_list|(
name|of
argument_list|,
name|length
argument_list|,
name|val
argument_list|,
name|prev_val
argument_list|,
literal|"length"
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%s"
argument_list|,
name|ta
operator|->
name|u
operator|.
name|a
operator|.
name|len
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ta
operator|=
name|t
operator|,
name|i
operator|=
literal|0
init|;
name|ta
operator|->
name|kind
operator|==
name|TYPE_ARRAY
condition|;
name|ta
operator|=
name|ta
operator|->
name|u
operator|.
name|a
operator|.
name|p
operator|,
name|i
operator|++
control|)
block|{
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sfor (i%d_%d = 0; i%d_%d< ilimit%d_%d; i%d_%d++) {\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|loopcounter
argument_list|,
name|i
argument_list|,
name|loopcounter
argument_list|,
name|i
argument_list|,
name|loopcounter
argument_list|,
name|i
argument_list|,
name|loopcounter
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|indent
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ta
operator|->
name|kind
operator|==
name|TYPE_POINTER
operator|&&
operator|(
name|UNION_OR_STRUCT_P
argument_list|(
name|ta
operator|->
name|u
operator|.
name|p
argument_list|)
operator|||
name|ta
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_PARAM_STRUCT
operator|)
condition|)
block|{
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sgt_ggc_m_"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|of
argument_list|,
name|ta
operator|->
name|u
operator|.
name|p
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|" (%s%s%s"
argument_list|,
name|val
argument_list|,
name|dot
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|ta
operator|=
name|t
operator|,
name|i
operator|=
literal|0
init|;
name|ta
operator|->
name|kind
operator|==
name|TYPE_ARRAY
condition|;
name|ta
operator|=
name|ta
operator|->
name|u
operator|.
name|a
operator|.
name|p
operator|,
name|i
operator|++
control|)
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"[i%d_%d]"
argument_list|,
name|loopcounter
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ta
operator|->
name|kind
operator|==
name|TYPE_STRUCT
operator|||
name|ta
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|)
block|{
name|char
modifier|*
name|newval
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
name|strlen
argument_list|(
name|f
operator|->
name|name
argument_list|)
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|ta
operator|=
name|t
init|;
name|ta
operator|->
name|kind
operator|==
name|TYPE_ARRAY
condition|;
name|ta
operator|=
name|ta
operator|->
name|u
operator|.
name|a
operator|.
name|p
control|)
name|len
operator|+=
sizeof|sizeof
argument_list|(
literal|"[i_]"
argument_list|)
operator|+
literal|2
operator|*
literal|6
expr_stmt|;
name|newval
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newval
argument_list|,
literal|"%s%s%s"
argument_list|,
name|val
argument_list|,
name|dot
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|ta
operator|=
name|t
operator|,
name|i
operator|=
literal|0
init|;
name|ta
operator|->
name|kind
operator|==
name|TYPE_ARRAY
condition|;
name|ta
operator|=
name|ta
operator|->
name|u
operator|.
name|a
operator|.
name|p
operator|,
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|newval
operator|+
name|strlen
argument_list|(
name|newval
argument_list|)
argument_list|,
literal|"[i%d_%d]"
argument_list|,
name|loopcounter
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|write_gc_structure_fields
argument_list|(
name|of
argument_list|,
name|t
operator|->
name|u
operator|.
name|p
argument_list|,
name|newval
argument_list|,
name|val
argument_list|,
name|f
operator|->
name|opt
argument_list|,
name|indent
argument_list|,
operator|&
name|f
operator|->
name|line
argument_list|,
name|bitmap
argument_list|,
name|param
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ta
operator|->
name|kind
operator|==
name|TYPE_POINTER
operator|&&
name|ta
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_SCALAR
operator|&&
name|use_param_num
operator|!=
operator|-
literal|1
operator|&&
name|param
operator|==
name|NULL
condition|)
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sabort();\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|error_at_line
argument_list|(
operator|&
name|f
operator|->
name|line
argument_list|,
literal|"field `%s' is array of unimplemented type"
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|ta
operator|=
name|t
operator|,
name|i
operator|=
literal|0
init|;
name|ta
operator|->
name|kind
operator|==
name|TYPE_ARRAY
condition|;
name|ta
operator|=
name|ta
operator|->
name|u
operator|.
name|a
operator|.
name|p
operator|,
name|i
operator|++
control|)
block|{
name|indent
operator|-=
literal|2
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*s}\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|indent
operator|-=
literal|2
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*s}\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error_at_line
argument_list|(
operator|&
name|f
operator|->
name|line
argument_list|,
literal|"field `%s' is unimplemented type"
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|)
block|{
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sbreak;\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|)
block|{
if|if
condition|(
operator|!
name|seen_default
condition|)
block|{
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*sdefault:\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*s  break;\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|oprintf
argument_list|(
name|of
argument_list|,
literal|"%*s}\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out a marker routine for S.  PARAM is the parameter from an    enclosing PARAM_IS option.  */
end_comment

begin_function
specifier|static
name|void
name|write_gc_marker_routine_for_structure
parameter_list|(
name|orig_s
parameter_list|,
name|s
parameter_list|,
name|param
parameter_list|)
name|type_p
name|orig_s
decl_stmt|;
name|type_p
name|s
decl_stmt|;
name|type_p
modifier|*
name|param
decl_stmt|;
block|{
name|outf_p
name|f
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
init|=
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
operator|.
name|file
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|chain_next
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|chain_prev
init|=
name|NULL
decl_stmt|;
name|options_p
name|opt
decl_stmt|;
comment|/* This is a hack, and not the good kind either.  */
for|for
control|(
name|i
operator|=
name|NUM_PARAM
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|param
operator|&&
name|param
index|[
name|i
index|]
operator|&&
name|param
index|[
name|i
index|]
operator|->
name|kind
operator|==
name|TYPE_POINTER
operator|&&
name|UNION_OR_STRUCT_P
argument_list|(
name|param
index|[
name|i
index|]
operator|->
name|u
operator|.
name|p
argument_list|)
condition|)
name|fn
operator|=
name|param
index|[
name|i
index|]
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|s
operator|.
name|line
operator|.
name|file
expr_stmt|;
name|f
operator|=
name|get_output_file_with_visibility
argument_list|(
name|fn
argument_list|)
expr_stmt|;
for|for
control|(
name|opt
operator|=
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|opt
init|;
name|opt
condition|;
name|opt
operator|=
name|opt
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
literal|"chain_next"
argument_list|)
operator|==
literal|0
condition|)
name|chain_next
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|opt
operator|->
name|info
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
literal|"chain_prev"
argument_list|)
operator|==
literal|0
condition|)
name|chain_prev
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|opt
operator|->
name|info
expr_stmt|;
if|if
condition|(
name|chain_prev
operator|!=
name|NULL
operator|&&
name|chain_next
operator|==
name|NULL
condition|)
name|error_at_line
argument_list|(
operator|&
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
argument_list|,
literal|"chain_prev without chain_next"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"void\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|==
name|NULL
condition|)
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"gt_ggc_mx_%s"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
else|else
block|{
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"gt_ggc_m_"
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|f
argument_list|,
name|orig_s
argument_list|)
expr_stmt|;
block|}
name|oprintf
argument_list|(
name|f
argument_list|,
literal|" (x_p)\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"      void *x_p;\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  %s %s * %sx = (%s %s *)x_p;\n"
argument_list|,
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|?
literal|"union"
else|:
literal|"struct"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|,
name|chain_next
operator|==
name|NULL
condition|?
literal|"const "
else|:
literal|""
argument_list|,
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|?
literal|"union"
else|:
literal|"struct"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain_next
operator|!=
name|NULL
condition|)
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  %s %s * xlimit = x;\n"
argument_list|,
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|?
literal|"union"
else|:
literal|"struct"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain_next
operator|==
name|NULL
condition|)
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  if (ggc_test_and_set_mark (x))\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  while (ggc_test_and_set_mark (xlimit))\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"   xlimit = ("
argument_list|)
expr_stmt|;
name|output_escaped_param
argument_list|(
name|f
argument_list|,
name|chain_next
argument_list|,
literal|"*xlimit"
argument_list|,
literal|"*xlimit"
argument_list|,
literal|"chain_next"
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain_prev
operator|!=
name|NULL
condition|)
block|{
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  if (x != xlimit)\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"    for (;;)\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"      {\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"        %s %s * const xprev = ("
argument_list|,
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|?
literal|"union"
else|:
literal|"struct"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
name|output_escaped_param
argument_list|(
name|f
argument_list|,
name|chain_prev
argument_list|,
literal|"*x"
argument_list|,
literal|"*x"
argument_list|,
literal|"chain_prev"
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"        if (xprev == NULL) break;\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"        x = xprev;\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"        ggc_set_mark (xprev);\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"      }\n"
argument_list|)
expr_stmt|;
block|}
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  while (x != xlimit)\n"
argument_list|)
expr_stmt|;
block|}
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"    {\n"
argument_list|)
expr_stmt|;
name|gc_counter
operator|=
literal|0
expr_stmt|;
name|write_gc_structure_fields
argument_list|(
name|f
argument_list|,
name|s
argument_list|,
literal|"(*x)"
argument_list|,
literal|"not valid postage"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|opt
argument_list|,
literal|6
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|bitmap
argument_list|,
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain_next
operator|!=
name|NULL
condition|)
block|{
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"      x = ("
argument_list|)
expr_stmt|;
name|output_escaped_param
argument_list|(
name|f
argument_list|,
name|chain_next
argument_list|,
literal|"*x"
argument_list|,
literal|"*x"
argument_list|,
literal|"chain_next"
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
block|}
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  }\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out marker routines for STRUCTURES and PARAM_STRUCTS.  */
end_comment

begin_function
specifier|static
name|void
name|write_gc_types
parameter_list|(
name|structures
parameter_list|,
name|param_structs
parameter_list|)
name|type_p
name|structures
decl_stmt|;
name|type_p
name|param_structs
decl_stmt|;
block|{
name|type_p
name|s
decl_stmt|;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|"\n/* GC marker procedures.  */\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|structures
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|gc_used
operator|==
name|GC_POINTED_TO
operator|||
name|s
operator|->
name|gc_used
operator|==
name|GC_MAYBE_POINTED_TO
condition|)
block|{
name|options_p
name|opt
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|gc_used
operator|==
name|GC_MAYBE_POINTED_TO
operator|&&
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
operator|.
name|file
operator|==
name|NULL
condition|)
continue|continue;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|"#define gt_ggc_m_"
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|header_file
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|"(X) do { \\\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|"  if (X != NULL) gt_ggc_mx_%s (X);\\\n"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|"  } while (0)\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|opt
operator|=
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|opt
init|;
name|opt
condition|;
name|opt
operator|=
name|opt
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
literal|"ptr_alias"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type_p
name|t
init|=
operator|(
name|type_p
operator|)
name|opt
operator|->
name|info
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|kind
operator|==
name|TYPE_STRUCT
operator|||
name|t
operator|->
name|kind
operator|==
name|TYPE_UNION
operator|||
name|t
operator|->
name|kind
operator|==
name|TYPE_LANG_STRUCT
condition|)
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|"#define gt_ggc_mx_%s gt_ggc_mx_%s\n"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|,
name|t
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
else|else
name|error_at_line
argument_list|(
operator|&
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
argument_list|,
literal|"structure alias is not a structure"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opt
condition|)
continue|continue;
comment|/* Declare the marker procedure only once.  */
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|"extern void gt_ggc_mx_%s PARAMS ((void *));\n"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
operator|.
name|file
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: structure `%s' used but not defined\n"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|kind
operator|==
name|TYPE_LANG_STRUCT
condition|)
block|{
name|type_p
name|ss
decl_stmt|;
for|for
control|(
name|ss
operator|=
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
init|;
name|ss
condition|;
name|ss
operator|=
name|ss
operator|->
name|next
control|)
name|write_gc_marker_routine_for_structure
argument_list|(
name|s
argument_list|,
name|ss
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|write_gc_marker_routine_for_structure
argument_list|(
name|s
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|param_structs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|gc_used
operator|==
name|GC_POINTED_TO
condition|)
block|{
name|type_p
modifier|*
name|param
init|=
name|s
operator|->
name|u
operator|.
name|param_struct
operator|.
name|param
decl_stmt|;
name|type_p
name|stru
init|=
name|s
operator|->
name|u
operator|.
name|param_struct
operator|.
name|stru
decl_stmt|;
comment|/* Declare the marker procedure.  */
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|"extern void gt_ggc_m_"
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|header_file
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|" PARAMS ((void *));\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stru
operator|->
name|u
operator|.
name|s
operator|.
name|line
operator|.
name|file
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: structure `%s' used but not defined\n"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|stru
operator|->
name|kind
operator|==
name|TYPE_LANG_STRUCT
condition|)
block|{
name|type_p
name|ss
decl_stmt|;
for|for
control|(
name|ss
operator|=
name|stru
operator|->
name|u
operator|.
name|s
operator|.
name|lang_struct
init|;
name|ss
condition|;
name|ss
operator|=
name|ss
operator|->
name|next
control|)
name|write_gc_marker_routine_for_structure
argument_list|(
name|s
argument_list|,
name|ss
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
else|else
name|write_gc_marker_routine_for_structure
argument_list|(
name|s
argument_list|,
name|stru
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out the 'enum' definition for gt_types_enum.  */
end_comment

begin_function
specifier|static
name|void
name|write_enum_defn
parameter_list|(
name|structures
parameter_list|,
name|param_structs
parameter_list|)
name|type_p
name|structures
decl_stmt|;
name|type_p
name|param_structs
decl_stmt|;
block|{
name|type_p
name|s
decl_stmt|;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|"\n/* Enumeration of types known.  */\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|"enum gt_types_enum {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|structures
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|gc_used
operator|==
name|GC_POINTED_TO
operator|||
name|s
operator|->
name|gc_used
operator|==
name|GC_MAYBE_POINTED_TO
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|gc_used
operator|==
name|GC_MAYBE_POINTED_TO
operator|&&
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|line
operator|.
name|file
operator|==
name|NULL
condition|)
continue|continue;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|" gt_ggc_e_"
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|header_file
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|", \n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|param_structs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|gc_used
operator|==
name|GC_POINTED_TO
condition|)
block|{
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|" gt_e_"
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|header_file
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|", \n"
argument_list|)
expr_stmt|;
block|}
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|" gt_types_enum_last\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|header_file
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mangle FN and print it to F.  */
end_comment

begin_function
specifier|static
name|void
name|put_mangled_filename
parameter_list|(
name|f
parameter_list|,
name|fn
parameter_list|)
name|outf_p
name|f
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|get_output_file_name
argument_list|(
name|fn
argument_list|)
decl_stmt|;
for|for
control|(
init|;
operator|*
name|name
operator|!=
literal|0
condition|;
name|name
operator|++
control|)
if|if
condition|(
name|ISALNUM
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
else|else
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"%c"
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish off the currently-created root tables in FLP.  PFX, TNAME,    LASTNAME, and NAME are all strings to insert in various places in    the resulting code.  */
end_comment

begin_function
specifier|static
name|void
name|finish_root_table
parameter_list|(
name|flp
parameter_list|,
name|pfx
parameter_list|,
name|lastname
parameter_list|,
name|tname
parameter_list|,
name|name
parameter_list|)
name|struct
name|flist
modifier|*
name|flp
decl_stmt|;
specifier|const
name|char
modifier|*
name|pfx
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
decl_stmt|;
specifier|const
name|char
modifier|*
name|lastname
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|flist
modifier|*
name|fli2
decl_stmt|;
name|unsigned
name|started_bitmap
init|=
literal|0
decl_stmt|;
for|for
control|(
name|fli2
operator|=
name|flp
init|;
name|fli2
condition|;
name|fli2
operator|=
name|fli2
operator|->
name|next
control|)
if|if
condition|(
name|fli2
operator|->
name|started_p
condition|)
block|{
name|oprintf
argument_list|(
name|fli2
operator|->
name|f
argument_list|,
literal|"  %s\n"
argument_list|,
name|lastname
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|fli2
operator|->
name|f
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|fli2
operator|=
name|flp
init|;
name|fli2
condition|;
name|fli2
operator|=
name|fli2
operator|->
name|next
control|)
if|if
condition|(
name|fli2
operator|->
name|started_p
condition|)
block|{
name|lang_bitmap
name|bitmap
init|=
name|get_base_file_bitmap
argument_list|(
name|fli2
operator|->
name|name
argument_list|)
decl_stmt|;
name|int
name|fnum
decl_stmt|;
for|for
control|(
name|fnum
operator|=
literal|0
init|;
name|bitmap
operator|!=
literal|0
condition|;
name|fnum
operator|++
operator|,
name|bitmap
operator|>>=
literal|1
control|)
if|if
condition|(
name|bitmap
operator|&
literal|1
condition|)
block|{
name|oprintf
argument_list|(
name|base_files
index|[
name|fnum
index|]
argument_list|,
literal|"extern const struct %s gt_ggc_%s_"
argument_list|,
name|tname
argument_list|,
name|pfx
argument_list|)
expr_stmt|;
name|put_mangled_filename
argument_list|(
name|base_files
index|[
name|fnum
index|]
argument_list|,
name|fli2
operator|->
name|name
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|base_files
index|[
name|fnum
index|]
argument_list|,
literal|"[];\n"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|fli2
operator|=
name|flp
init|;
name|fli2
condition|;
name|fli2
operator|=
name|fli2
operator|->
name|next
control|)
if|if
condition|(
name|fli2
operator|->
name|started_p
condition|)
block|{
name|lang_bitmap
name|bitmap
init|=
name|get_base_file_bitmap
argument_list|(
name|fli2
operator|->
name|name
argument_list|)
decl_stmt|;
name|int
name|fnum
decl_stmt|;
name|fli2
operator|->
name|started_p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fnum
operator|=
literal|0
init|;
name|bitmap
operator|!=
literal|0
condition|;
name|fnum
operator|++
operator|,
name|bitmap
operator|>>=
literal|1
control|)
if|if
condition|(
name|bitmap
operator|&
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|started_bitmap
operator|&
operator|(
literal|1
operator|<<
name|fnum
operator|)
operator|)
condition|)
block|{
name|oprintf
argument_list|(
name|base_files
index|[
name|fnum
index|]
argument_list|,
literal|"const struct %s * const %s[] = {\n"
argument_list|,
name|tname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|started_bitmap
operator||=
literal|1
operator|<<
name|fnum
expr_stmt|;
block|}
name|oprintf
argument_list|(
name|base_files
index|[
name|fnum
index|]
argument_list|,
literal|"  gt_ggc_%s_"
argument_list|,
name|pfx
argument_list|)
expr_stmt|;
name|put_mangled_filename
argument_list|(
name|base_files
index|[
name|fnum
index|]
argument_list|,
name|fli2
operator|->
name|name
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|base_files
index|[
name|fnum
index|]
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|unsigned
name|bitmap
decl_stmt|;
name|int
name|fnum
decl_stmt|;
for|for
control|(
name|bitmap
operator|=
name|started_bitmap
operator|,
name|fnum
operator|=
literal|0
init|;
name|bitmap
operator|!=
literal|0
condition|;
name|fnum
operator|++
operator|,
name|bitmap
operator|>>=
literal|1
control|)
if|if
condition|(
name|bitmap
operator|&
literal|1
condition|)
block|{
name|oprintf
argument_list|(
name|base_files
index|[
name|fnum
index|]
argument_list|,
literal|"  NULL\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|base_files
index|[
name|fnum
index|]
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Write out to F the table entry and any marker routines needed to    mark NAME as TYPE.  The original variable is V, at LINE.    HAS_LENGTH is nonzero iff V was a variable-length array.  IF_MARKED    is nonzero iff we are building the root table for hash table caches.  */
end_comment

begin_function
specifier|static
name|void
name|write_gc_root
parameter_list|(
name|f
parameter_list|,
name|v
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|,
name|has_length
parameter_list|,
name|line
parameter_list|,
name|if_marked
parameter_list|)
name|outf_p
name|f
decl_stmt|;
name|pair_p
name|v
decl_stmt|;
name|type_p
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|has_length
decl_stmt|;
name|struct
name|fileloc
modifier|*
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|if_marked
decl_stmt|;
block|{
switch|switch
condition|(
name|type
operator|->
name|kind
condition|)
block|{
case|case
name|TYPE_STRUCT
case|:
block|{
name|pair_p
name|fld
decl_stmt|;
for|for
control|(
name|fld
operator|=
name|type
operator|->
name|u
operator|.
name|s
operator|.
name|fields
init|;
name|fld
condition|;
name|fld
operator|=
name|fld
operator|->
name|next
control|)
block|{
name|int
name|skip_p
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
init|=
name|NULL
decl_stmt|;
name|options_p
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|fld
operator|->
name|opt
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"skip"
argument_list|)
operator|==
literal|0
condition|)
name|skip_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"desc"
argument_list|)
operator|==
literal|0
condition|)
name|desc
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|o
operator|->
name|info
expr_stmt|;
else|else
name|error_at_line
argument_list|(
name|line
argument_list|,
literal|"field `%s' of global `%s' has unknown option `%s'"
argument_list|,
name|fld
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_p
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|desc
operator|&&
name|fld
operator|->
name|type
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|)
block|{
name|pair_p
name|validf
init|=
name|NULL
decl_stmt|;
name|pair_p
name|ufld
decl_stmt|;
for|for
control|(
name|ufld
operator|=
name|fld
operator|->
name|type
operator|->
name|u
operator|.
name|s
operator|.
name|fields
init|;
name|ufld
condition|;
name|ufld
operator|=
name|ufld
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
name|options_p
name|oo
decl_stmt|;
for|for
control|(
name|oo
operator|=
name|ufld
operator|->
name|opt
init|;
name|oo
condition|;
name|oo
operator|=
name|oo
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|oo
operator|->
name|name
argument_list|,
literal|"tag"
argument_list|)
operator|==
literal|0
condition|)
name|tag
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|oo
operator|->
name|info
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|tag
argument_list|,
name|desc
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|validf
operator|!=
name|NULL
condition|)
name|error_at_line
argument_list|(
name|line
argument_list|,
literal|"both `%s.%s.%s' and `%s.%s.%s' have tag `%s'"
argument_list|,
name|name
argument_list|,
name|fld
operator|->
name|name
argument_list|,
name|validf
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|fld
operator|->
name|name
argument_list|,
name|ufld
operator|->
name|name
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|validf
operator|=
name|ufld
expr_stmt|;
block|}
if|if
condition|(
name|validf
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|newname
decl_stmt|;
name|newname
operator|=
name|xasprintf
argument_list|(
literal|"%s.%s.%s"
argument_list|,
name|name
argument_list|,
name|fld
operator|->
name|name
argument_list|,
name|validf
operator|->
name|name
argument_list|)
expr_stmt|;
name|write_gc_root
argument_list|(
name|f
argument_list|,
name|v
argument_list|,
name|validf
operator|->
name|type
argument_list|,
name|newname
argument_list|,
literal|0
argument_list|,
name|line
argument_list|,
name|if_marked
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|desc
condition|)
name|error_at_line
argument_list|(
name|line
argument_list|,
literal|"global `%s.%s' has `desc' option but is not union"
argument_list|,
name|name
argument_list|,
name|fld
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|newname
decl_stmt|;
name|newname
operator|=
name|xasprintf
argument_list|(
literal|"%s.%s"
argument_list|,
name|name
argument_list|,
name|fld
operator|->
name|name
argument_list|)
expr_stmt|;
name|write_gc_root
argument_list|(
name|f
argument_list|,
name|v
argument_list|,
name|fld
operator|->
name|type
argument_list|,
name|newname
argument_list|,
literal|0
argument_list|,
name|line
argument_list|,
name|if_marked
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|TYPE_ARRAY
case|:
block|{
name|char
modifier|*
name|newname
decl_stmt|;
name|newname
operator|=
name|xasprintf
argument_list|(
literal|"%s[0]"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|write_gc_root
argument_list|(
name|f
argument_list|,
name|v
argument_list|,
name|type
operator|->
name|u
operator|.
name|a
operator|.
name|p
argument_list|,
name|newname
argument_list|,
name|has_length
argument_list|,
name|line
argument_list|,
name|if_marked
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_POINTER
case|:
block|{
name|type_p
name|ap
decl_stmt|,
name|tp
decl_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  {\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"&%s,\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"    1"
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|v
operator|->
name|type
init|;
name|ap
operator|->
name|kind
operator|==
name|TYPE_ARRAY
condition|;
name|ap
operator|=
name|ap
operator|->
name|u
operator|.
name|a
operator|.
name|p
control|)
if|if
condition|(
name|ap
operator|->
name|u
operator|.
name|a
operator|.
name|len
index|[
literal|0
index|]
condition|)
name|oprintf
argument_list|(
name|f
argument_list|,
literal|" * (%s)"
argument_list|,
name|ap
operator|->
name|u
operator|.
name|a
operator|.
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|==
name|v
operator|->
name|type
condition|)
name|oprintf
argument_list|(
name|f
argument_list|,
literal|" * ARRAY_SIZE (%s)"
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"    sizeof (%s"
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|v
operator|->
name|type
init|;
name|ap
operator|->
name|kind
operator|==
name|TYPE_ARRAY
condition|;
name|ap
operator|=
name|ap
operator|->
name|u
operator|.
name|a
operator|.
name|p
control|)
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"[0]"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"),\n"
argument_list|)
expr_stmt|;
name|tp
operator|=
name|type
operator|->
name|u
operator|.
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|has_length
operator|&&
name|UNION_OR_STRUCT_P
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"&gt_ggc_mx_%s\n"
argument_list|,
name|tp
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|has_length
operator|&&
name|tp
operator|->
name|kind
operator|==
name|TYPE_PARAM_STRUCT
condition|)
block|{
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"&gt_ggc_m_"
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|f
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_length
operator|&&
operator|(
name|tp
operator|->
name|kind
operator|==
name|TYPE_POINTER
operator|||
name|UNION_OR_STRUCT_P
argument_list|(
name|tp
argument_list|)
operator|)
condition|)
block|{
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"&gt_ggc_ma_%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error_at_line
argument_list|(
name|line
argument_list|,
literal|"global `%s' is pointer to unimplemented type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_marked
condition|)
name|oprintf
argument_list|(
name|f
argument_list|,
literal|",\n&%s"
argument_list|,
name|if_marked
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"\n  },\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_SCALAR
case|:
case|case
name|TYPE_STRING
case|:
break|break;
default|default:
name|error_at_line
argument_list|(
name|line
argument_list|,
literal|"global `%s' is unimplemented type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a table describing the locations and types of VARIABLES.  */
end_comment

begin_function
specifier|static
name|void
name|write_gc_roots
parameter_list|(
name|variables
parameter_list|)
name|pair_p
name|variables
decl_stmt|;
block|{
name|pair_p
name|v
decl_stmt|;
name|struct
name|flist
modifier|*
name|flp
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|v
operator|=
name|variables
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
name|outf_p
name|f
init|=
name|get_output_file_with_visibility
argument_list|(
name|v
operator|->
name|line
operator|.
name|file
argument_list|)
decl_stmt|;
name|struct
name|flist
modifier|*
name|fli
decl_stmt|;
specifier|const
name|char
modifier|*
name|length
init|=
name|NULL
decl_stmt|;
name|int
name|deletable_p
init|=
literal|0
decl_stmt|;
name|options_p
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|v
operator|->
name|opt
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
name|length
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|o
operator|->
name|info
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"deletable"
argument_list|)
operator|==
literal|0
condition|)
name|deletable_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"param_is"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"param"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|ISDIGIT
argument_list|(
name|o
operator|->
name|name
index|[
literal|5
index|]
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|o
operator|->
name|name
operator|+
literal|6
argument_list|,
literal|"_is"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"if_marked"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
else|else
name|error_at_line
argument_list|(
operator|&
name|v
operator|->
name|line
argument_list|,
literal|"global `%s' has unknown option `%s'"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|fli
operator|=
name|flp
init|;
name|fli
condition|;
name|fli
operator|=
name|fli
operator|->
name|next
control|)
if|if
condition|(
name|fli
operator|->
name|f
operator|==
name|f
condition|)
break|break;
if|if
condition|(
name|fli
operator|==
name|NULL
condition|)
block|{
name|fli
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fli
argument_list|)
argument_list|)
expr_stmt|;
name|fli
operator|->
name|f
operator|=
name|f
expr_stmt|;
name|fli
operator|->
name|next
operator|=
name|flp
expr_stmt|;
name|fli
operator|->
name|started_p
operator|=
literal|0
expr_stmt|;
name|fli
operator|->
name|name
operator|=
name|v
operator|->
name|line
operator|.
name|file
expr_stmt|;
name|flp
operator|=
name|fli
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"\n/* GC roots.  */\n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|deletable_p
operator|&&
name|length
operator|&&
name|v
operator|->
name|type
operator|->
name|kind
operator|==
name|TYPE_POINTER
operator|&&
operator|(
name|v
operator|->
name|type
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_POINTER
operator|||
name|v
operator|->
name|type
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_STRUCT
operator|)
condition|)
block|{
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"static void gt_ggc_ma_%s PARAMS ((void *));\n"
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"static void\ngt_ggc_ma_%s (x_p)\n      void *x_p;\n"
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  size_t i;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|type
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|==
name|TYPE_POINTER
condition|)
block|{
name|type_p
name|s
init|=
name|v
operator|->
name|type
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|p
decl_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  %s %s ** const x = (%s %s **)x_p;\n"
argument_list|,
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|?
literal|"union"
else|:
literal|"struct"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|,
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|?
literal|"union"
else|:
literal|"struct"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  if (ggc_test_and_set_mark (x))\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"    for (i = 0; i< (%s); i++)\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|UNION_OR_STRUCT_P
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|s
operator|->
name|kind
operator|==
name|TYPE_PARAM_STRUCT
condition|)
block|{
name|error_at_line
argument_list|(
operator|&
name|v
operator|->
name|line
argument_list|,
literal|"global `%s' has unsupported ** type"
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"      gt_ggc_m_"
argument_list|)
expr_stmt|;
name|output_mangled_typename
argument_list|(
name|f
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|" (x[i]);\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type_p
name|s
init|=
name|v
operator|->
name|type
operator|->
name|u
operator|.
name|p
decl_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  %s %s * const x = (%s %s *)x_p;\n"
argument_list|,
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|?
literal|"union"
else|:
literal|"struct"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|,
name|s
operator|->
name|kind
operator|==
name|TYPE_UNION
condition|?
literal|"union"
else|:
literal|"struct"
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|tag
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  if (ggc_test_and_set_mark (x))\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"    for (i = 0; i< (%s); i++)\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"      {\n"
argument_list|)
expr_stmt|;
name|write_gc_structure_fields
argument_list|(
name|f
argument_list|,
name|s
argument_list|,
literal|"x[i]"
argument_list|,
literal|"x[i]"
argument_list|,
name|v
operator|->
name|opt
argument_list|,
literal|8
argument_list|,
operator|&
name|v
operator|->
name|line
argument_list|,
name|s
operator|->
name|u
operator|.
name|s
operator|.
name|bitmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"      }\n"
argument_list|)
expr_stmt|;
block|}
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|v
operator|=
name|variables
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
name|outf_p
name|f
init|=
name|get_output_file_with_visibility
argument_list|(
name|v
operator|->
name|line
operator|.
name|file
argument_list|)
decl_stmt|;
name|struct
name|flist
modifier|*
name|fli
decl_stmt|;
name|int
name|skip_p
init|=
literal|0
decl_stmt|;
name|int
name|length_p
init|=
literal|0
decl_stmt|;
name|options_p
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|v
operator|->
name|opt
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
name|length_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"deletable"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"if_marked"
argument_list|)
operator|==
literal|0
condition|)
name|skip_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip_p
condition|)
continue|continue;
for|for
control|(
name|fli
operator|=
name|flp
init|;
name|fli
condition|;
name|fli
operator|=
name|fli
operator|->
name|next
control|)
if|if
condition|(
name|fli
operator|->
name|f
operator|==
name|f
condition|)
break|break;
if|if
condition|(
operator|!
name|fli
operator|->
name|started_p
condition|)
block|{
name|fli
operator|->
name|started_p
operator|=
literal|1
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"const struct ggc_root_tab gt_ggc_r_"
argument_list|)
expr_stmt|;
name|put_mangled_filename
argument_list|(
name|f
argument_list|,
name|v
operator|->
name|line
operator|.
name|file
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"[] = {\n"
argument_list|)
expr_stmt|;
block|}
name|write_gc_root
argument_list|(
name|f
argument_list|,
name|v
argument_list|,
name|v
operator|->
name|type
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|length_p
argument_list|,
operator|&
name|v
operator|->
name|line
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|finish_root_table
argument_list|(
name|flp
argument_list|,
literal|"r"
argument_list|,
literal|"LAST_GGC_ROOT_TAB"
argument_list|,
literal|"ggc_root_tab"
argument_list|,
literal|"gt_ggc_rtab"
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|variables
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
name|outf_p
name|f
init|=
name|get_output_file_with_visibility
argument_list|(
name|v
operator|->
name|line
operator|.
name|file
argument_list|)
decl_stmt|;
name|struct
name|flist
modifier|*
name|fli
decl_stmt|;
name|int
name|skip_p
init|=
literal|1
decl_stmt|;
name|options_p
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|v
operator|->
name|opt
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"deletable"
argument_list|)
operator|==
literal|0
condition|)
name|skip_p
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"if_marked"
argument_list|)
operator|==
literal|0
condition|)
name|skip_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip_p
condition|)
continue|continue;
for|for
control|(
name|fli
operator|=
name|flp
init|;
name|fli
condition|;
name|fli
operator|=
name|fli
operator|->
name|next
control|)
if|if
condition|(
name|fli
operator|->
name|f
operator|==
name|f
condition|)
break|break;
if|if
condition|(
operator|!
name|fli
operator|->
name|started_p
condition|)
block|{
name|fli
operator|->
name|started_p
operator|=
literal|1
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"const struct ggc_root_tab gt_ggc_rd_"
argument_list|)
expr_stmt|;
name|put_mangled_filename
argument_list|(
name|f
argument_list|,
name|v
operator|->
name|line
operator|.
name|file
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"[] = {\n"
argument_list|)
expr_stmt|;
block|}
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"  {&%s, 1, sizeof (%s), NULL },\n"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|finish_root_table
argument_list|(
name|flp
argument_list|,
literal|"rd"
argument_list|,
literal|"LAST_GGC_ROOT_TAB"
argument_list|,
literal|"ggc_root_tab"
argument_list|,
literal|"gt_ggc_deletable_rtab"
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|variables
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
name|outf_p
name|f
init|=
name|get_output_file_with_visibility
argument_list|(
name|v
operator|->
name|line
operator|.
name|file
argument_list|)
decl_stmt|;
name|struct
name|flist
modifier|*
name|fli
decl_stmt|;
specifier|const
name|char
modifier|*
name|if_marked
init|=
name|NULL
decl_stmt|;
name|int
name|length_p
init|=
literal|0
decl_stmt|;
name|options_p
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|v
operator|->
name|opt
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
name|length_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|"if_marked"
argument_list|)
operator|==
literal|0
condition|)
name|if_marked
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|o
operator|->
name|info
expr_stmt|;
if|if
condition|(
name|if_marked
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|v
operator|->
name|type
operator|->
name|kind
operator|!=
name|TYPE_POINTER
operator|||
name|v
operator|->
name|type
operator|->
name|u
operator|.
name|p
operator|->
name|kind
operator|!=
name|TYPE_PARAM_STRUCT
operator|||
name|v
operator|->
name|type
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|param_struct
operator|.
name|stru
operator|!=
name|find_structure
argument_list|(
literal|"htab"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error_at_line
argument_list|(
operator|&
name|v
operator|->
name|line
argument_list|,
literal|"if_marked option used but not hash table"
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|fli
operator|=
name|flp
init|;
name|fli
condition|;
name|fli
operator|=
name|fli
operator|->
name|next
control|)
if|if
condition|(
name|fli
operator|->
name|f
operator|==
name|f
condition|)
break|break;
if|if
condition|(
operator|!
name|fli
operator|->
name|started_p
condition|)
block|{
name|fli
operator|->
name|started_p
operator|=
literal|1
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"const struct ggc_cache_tab gt_ggc_rc_"
argument_list|)
expr_stmt|;
name|put_mangled_filename
argument_list|(
name|f
argument_list|,
name|v
operator|->
name|line
operator|.
name|file
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
name|f
argument_list|,
literal|"[] = {\n"
argument_list|)
expr_stmt|;
block|}
name|write_gc_root
argument_list|(
name|f
argument_list|,
name|v
argument_list|,
name|v
operator|->
name|type
operator|->
name|u
operator|.
name|p
operator|->
name|u
operator|.
name|param_struct
operator|.
name|param
index|[
literal|0
index|]
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|length_p
argument_list|,
operator|&
name|v
operator|->
name|line
argument_list|,
name|if_marked
argument_list|)
expr_stmt|;
block|}
name|finish_root_table
argument_list|(
name|flp
argument_list|,
literal|"rc"
argument_list|,
literal|"LAST_GGC_CACHE_TAB"
argument_list|,
literal|"ggc_cache_tab"
argument_list|,
literal|"gt_ggc_cache_rtab"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
specifier|static
name|struct
name|fileloc
name|pos
init|=
block|{
name|__FILE__
block|,
name|__LINE__
block|}
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|gen_rtx_next
argument_list|()
expr_stmt|;
name|srcdir_len
operator|=
name|strlen
argument_list|(
name|srcdir
argument_list|)
expr_stmt|;
name|do_scalar_typedef
argument_list|(
literal|"CUMULATIVE_ARGS"
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|do_scalar_typedef
argument_list|(
literal|"REAL_VALUE_TYPE"
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|do_scalar_typedef
argument_list|(
literal|"uint8"
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|do_scalar_typedef
argument_list|(
literal|"jword"
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|do_scalar_typedef
argument_list|(
literal|"JCF_u2"
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|do_typedef
argument_list|(
literal|"PTR"
argument_list|,
name|create_pointer
argument_list|(
name|create_scalar_type
argument_list|(
literal|"void"
argument_list|,
name|strlen
argument_list|(
literal|"void"
argument_list|)
argument_list|)
argument_list|)
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|do_typedef
argument_list|(
literal|"HARD_REG_SET"
argument_list|,
name|create_array
argument_list|(
name|create_scalar_type
argument_list|(
literal|"unsigned long"
argument_list|,
name|strlen
argument_list|(
literal|"unsigned long"
argument_list|)
argument_list|)
argument_list|,
literal|"2"
argument_list|)
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_GT_FILES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|dupflag
init|=
literal|0
decl_stmt|;
comment|/* Omit if already seen.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|all_files
index|[
name|i
index|]
argument_list|,
name|all_files
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|dupflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|dupflag
condition|)
name|parse_file
argument_list|(
name|all_files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hit_error
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|set_gc_used
argument_list|(
name|variables
argument_list|)
expr_stmt|;
name|open_base_files
argument_list|()
expr_stmt|;
name|write_enum_defn
argument_list|(
name|structures
argument_list|,
name|param_structs
argument_list|)
expr_stmt|;
name|write_gc_types
argument_list|(
name|structures
argument_list|,
name|param_structs
argument_list|)
expr_stmt|;
name|write_gc_roots
argument_list|(
name|variables
argument_list|)
expr_stmt|;
name|write_rtx_next
argument_list|()
expr_stmt|;
name|close_output_files
argument_list|()
expr_stmt|;
return|return
operator|(
name|hit_error
operator|!=
literal|0
operator|)
return|;
block|}
end_function

end_unit

