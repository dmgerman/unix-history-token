begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Basic block reordering routines for the GNU compiler.    Copyright (C) 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_comment
comment|/* The contents of the current function definition are allocated    in this obstack, and all are freed at the end of the function.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|flow_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the interesting trailing notes for the function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|function_tail_eff_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|skip_insns_after_block
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_effective_endpoints
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|label_for_bb
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_reorder_chain
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_block_levels
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|change_scope
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|verify_insn_chain
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_fallthru_exit_predecessor
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map insn uid to lexical block.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|insn_scopes
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Skip over inter-block insns occurring after BB which are typically    associated with BB (e.g., barriers). If there are any such insns,    we return the last one. Otherwise, we return the end of BB.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_insns_after_block
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|last_insn
decl_stmt|,
name|next_head
decl_stmt|,
name|prev
decl_stmt|;
name|next_head
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|index
operator|+
literal|1
operator|!=
name|n_basic_blocks
condition|)
name|next_head
operator|=
name|BASIC_BLOCK
argument_list|(
name|bb
operator|->
name|index
operator|+
literal|1
argument_list|)
operator|->
name|head
expr_stmt|;
for|for
control|(
name|last_insn
operator|=
name|insn
operator|=
name|bb
operator|->
name|end
init|;
operator|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|insn
operator|==
name|next_head
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|BARRIER
case|:
name|last_insn
operator|=
name|insn
expr_stmt|;
continue|continue;
case|case
name|NOTE
case|:
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_LOOP_END
case|:
case|case
name|NOTE_INSN_BLOCK_END
case|:
name|last_insn
operator|=
name|insn
expr_stmt|;
continue|continue;
case|case
name|NOTE_INSN_DELETED
case|:
case|case
name|NOTE_INSN_DELETED_LABEL
case|:
continue|continue;
default|default:
continue|continue;
break|break;
block|}
break|break;
case|case
name|CODE_LABEL
case|:
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|last_insn
operator|=
name|insn
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* It is possible to hit contradictory sequence.  For instance:           jump_insn      NOTE_INSN_LOOP_BEG      barrier       Where barrier belongs to jump_insn, but the note does not.  This can be      created by removing the basic block originally following      NOTE_INSN_LOOP_BEG.  In such case reorder the notes.  */
for|for
control|(
name|insn
operator|=
name|last_insn
init|;
name|insn
operator|!=
name|bb
operator|->
name|end
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_LOOP_END
case|:
case|case
name|NOTE_INSN_BLOCK_END
case|:
case|case
name|NOTE_INSN_DELETED
case|:
case|case
name|NOTE_INSN_DELETED_LABEL
case|:
continue|continue;
default|default:
name|reorder_insns
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|last_insn
return|;
block|}
end_function

begin_comment
comment|/* Locate or create a label for a given basic block.  */
end_comment

begin_function
specifier|static
name|rtx
name|label_for_bb
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|label
init|=
name|bb
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Emitting label for block %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|label
operator|=
name|block_label
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|head
operator|==
name|PREV_INSN
argument_list|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|eff_head
argument_list|)
condition|)
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|eff_head
operator|=
name|label
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Locate the effective beginning and end of the insn chain for each    block, as defined by skip_insns_after_block above.  */
end_comment

begin_function
specifier|static
name|void
name|record_effective_endpoints
parameter_list|()
block|{
name|rtx
name|next_insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|eff_head
operator|=
name|next_insn
expr_stmt|;
name|end
operator|=
name|skip_insns_after_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|eff_end
operator|=
name|end
expr_stmt|;
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
name|function_tail_eff_head
operator|=
name|next_insn
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a varray mapping INSN_UID to lexical block.  Return it.  */
end_comment

begin_function
name|void
name|scope_to_insns_initialize
parameter_list|()
block|{
name|tree
name|block
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|insn_scopes
argument_list|,
name|get_max_uid
argument_list|()
argument_list|,
literal|"insn scopes"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_insn_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
condition|)
name|VARRAY_TREE
argument_list|(
name|insn_scopes
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_BLOCK_BEG
case|:
name|block
operator|=
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_BLOCK_END
case|:
name|block
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* For each lexical block, set BLOCK_NUMBER to the depth at which it is    found in the block tree.  */
end_comment

begin_function
specifier|static
name|void
name|set_block_levels
parameter_list|(
name|block
parameter_list|,
name|level
parameter_list|)
name|tree
name|block
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
while|while
condition|(
name|block
condition|)
block|{
name|BLOCK_NUMBER
argument_list|(
name|block
argument_list|)
operator|=
name|level
expr_stmt|;
name|set_block_levels
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit lexical block notes needed to change scope from S1 to S2.  */
end_comment

begin_function
specifier|static
name|void
name|change_scope
parameter_list|(
name|orig_insn
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
name|rtx
name|orig_insn
decl_stmt|;
name|tree
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|orig_insn
decl_stmt|;
name|tree
name|com
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ts1
init|=
name|s1
decl_stmt|,
name|ts2
init|=
name|s2
decl_stmt|;
name|tree
name|s
decl_stmt|;
while|while
condition|(
name|ts1
operator|!=
name|ts2
condition|)
block|{
if|if
condition|(
name|ts1
operator|==
name|NULL
operator|||
name|ts2
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|BLOCK_NUMBER
argument_list|(
name|ts1
argument_list|)
operator|>
name|BLOCK_NUMBER
argument_list|(
name|ts2
argument_list|)
condition|)
name|ts1
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|ts1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BLOCK_NUMBER
argument_list|(
name|ts1
argument_list|)
operator|<
name|BLOCK_NUMBER
argument_list|(
name|ts2
argument_list|)
condition|)
name|ts2
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|ts2
argument_list|)
expr_stmt|;
else|else
block|{
name|ts1
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|ts1
argument_list|)
expr_stmt|;
name|ts2
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|ts2
argument_list|)
expr_stmt|;
block|}
block|}
name|com
operator|=
name|ts1
expr_stmt|;
comment|/* Close scopes.  */
name|s
operator|=
name|s1
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|com
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_BLOCK_END
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|NOTE_BLOCK
argument_list|(
name|note
argument_list|)
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Open scopes.  */
name|s
operator|=
name|s2
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|com
condition|)
block|{
name|insn
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_BLOCK_BEG
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rebuild all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes based    on the scope tree and the newly reordered instructions.  */
end_comment

begin_function
name|void
name|scope_to_insns_finalize
parameter_list|()
block|{
name|tree
name|cur_block
init|=
name|DECL_INITIAL
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|note
decl_stmt|;
comment|/* Tag the blocks with a depth number so that change_scope can find      the common parent easily.  */
name|set_block_levels
argument_list|(
name|cur_block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|tree
name|this_block
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>=
name|insn_scopes
operator|->
name|num_elements
condition|)
continue|continue;
name|this_block
operator|=
name|VARRAY_TREE
argument_list|(
name|insn_scopes
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_block
condition|)
continue|continue;
if|if
condition|(
name|this_block
operator|!=
name|cur_block
condition|)
block|{
name|change_scope
argument_list|(
name|insn
argument_list|,
name|cur_block
argument_list|,
name|this_block
argument_list|)
expr_stmt|;
name|cur_block
operator|=
name|this_block
expr_stmt|;
block|}
block|}
name|VARRAY_FREE
argument_list|(
name|insn_scopes
argument_list|)
expr_stmt|;
comment|/* change_scope emits before the insn, not after.  */
name|note
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|change_scope
argument_list|(
name|note
argument_list|,
name|cur_block
argument_list|,
name|DECL_INITIAL
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|reorder_blocks
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a reorder chain, rearrange the code to match.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_reorder_chain
parameter_list|()
block|{
name|basic_block
name|bb
decl_stmt|,
name|last_bb
decl_stmt|;
name|int
name|index
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|old_n_basic_blocks
init|=
name|n_basic_blocks
decl_stmt|;
comment|/* First do the bulk reordering -- rechain the blocks without regard to      the needed changes to jumps and labels.  */
for|for
control|(
name|last_bb
operator|=
name|BASIC_BLOCK
argument_list|(
literal|0
argument_list|)
operator|,
name|bb
operator|=
name|RBI
argument_list|(
name|last_bb
argument_list|)
operator|->
name|next
operator|,
name|index
operator|=
literal|1
init|;
name|bb
operator|!=
literal|0
condition|;
name|last_bb
operator|=
name|bb
operator|,
name|bb
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|,
name|index
operator|++
control|)
block|{
name|rtx
name|last_e
init|=
name|RBI
argument_list|(
name|last_bb
argument_list|)
operator|->
name|eff_end
decl_stmt|;
name|rtx
name|curr_h
init|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|eff_head
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|last_e
argument_list|)
operator|=
name|curr_h
expr_stmt|;
name|PREV_INSN
argument_list|(
name|curr_h
argument_list|)
operator|=
name|last_e
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|!=
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insn
operator|=
name|RBI
argument_list|(
name|last_bb
argument_list|)
operator|->
name|eff_end
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|function_tail_eff_head
expr_stmt|;
if|if
condition|(
name|function_tail_eff_head
condition|)
name|PREV_INSN
argument_list|(
name|function_tail_eff_head
argument_list|)
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|set_last_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_insn_chain
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Now add jumps and labels as needed to match the blocks new      outgoing edges.  */
for|for
control|(
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
literal|0
argument_list|)
init|;
name|bb
condition|;
name|bb
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
control|)
block|{
name|edge
name|e_fall
decl_stmt|,
name|e_taken
decl_stmt|,
name|e
decl_stmt|;
name|rtx
name|bb_end_insn
decl_stmt|;
name|basic_block
name|nb
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|succ
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Find the old fallthru edge, and another non-EH edge for 	 a taken jump.  */
name|e_taken
operator|=
name|e_fall
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|e_fall
operator|=
name|e
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
operator|)
condition|)
name|e_taken
operator|=
name|e
expr_stmt|;
name|bb_end_insn
operator|=
name|bb
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|bb_end_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|any_condjump_p
argument_list|(
name|bb_end_insn
argument_list|)
condition|)
block|{
comment|/* If the old fallthru is still next, nothing to do.  */
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|==
name|e_fall
operator|->
name|dest
operator|||
operator|(
operator|!
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|&&
name|e_fall
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|)
condition|)
continue|continue;
comment|/* There is one special case: if *neither* block is next, 		 such as happens at the very end of a function, then we'll 		 need to add a new unconditional jump.  Choose the taken 		 edge based on known or assumed probability.  */
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|!=
name|e_taken
operator|->
name|dest
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|bb_end_insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|REG_BR_PROB_BASE
operator|/
literal|2
operator|&&
name|invert_jump
argument_list|(
name|bb_end_insn
argument_list|,
name|label_for_bb
argument_list|(
name|e_fall
operator|->
name|dest
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|e_fall
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|e_taken
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|update_br_prob_note
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|e
operator|=
name|e_fall
operator|,
name|e_fall
operator|=
name|e_taken
operator|,
name|e_taken
operator|=
name|e
expr_stmt|;
block|}
block|}
comment|/* Otherwise we can try to invert the jump.  This will  		 basically never fail, however, keep up the pretense.  */
elseif|else
if|if
condition|(
name|invert_jump
argument_list|(
name|bb_end_insn
argument_list|,
name|label_for_bb
argument_list|(
name|e_fall
operator|->
name|dest
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|e_fall
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|e_taken
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|update_br_prob_note
argument_list|(
name|bb
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|returnjump_p
argument_list|(
name|bb_end_insn
argument_list|)
condition|)
continue|continue;
else|else
block|{
comment|/* Otherwise we have some switch or computed jump.  In the 		 99% case, there should not have been a fallthru edge.  */
if|if
condition|(
operator|!
name|e_fall
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|CASE_DROPS_THROUGH
comment|/* Except for VAX.  Since we didn't have predication for the 		 tablejump, the fallthru block should not have moved.  */
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|==
name|e_fall
operator|->
name|dest
condition|)
continue|continue;
name|bb_end_insn
operator|=
name|skip_insns_after_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* No fallthru implies a noreturn function with EH edges, or 	     something similarly bizarre.  In any case, we don't need to 	     do anything.  */
if|if
condition|(
operator|!
name|e_fall
condition|)
continue|continue;
comment|/* If the fallthru block is still next, nothing to do.  */
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|==
name|e_fall
operator|->
name|dest
condition|)
continue|continue;
comment|/* A fallthru to exit block.  */
if|if
condition|(
operator|!
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|&&
name|e_fall
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
block|}
comment|/* We got here if we need to add a new jump insn.  */
name|nb
operator|=
name|force_nonfallthru
argument_list|(
name|e_fall
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
condition|)
block|{
name|alloc_aux_for_block
argument_list|(
name|nb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reorder_block_def
argument_list|)
argument_list|)
expr_stmt|;
name|RBI
argument_list|(
name|nb
argument_list|)
operator|->
name|eff_head
operator|=
name|nb
operator|->
name|head
expr_stmt|;
name|RBI
argument_list|(
name|nb
argument_list|)
operator|->
name|eff_end
operator|=
name|NEXT_INSN
argument_list|(
name|nb
operator|->
name|end
argument_list|)
expr_stmt|;
name|RBI
argument_list|(
name|nb
argument_list|)
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
name|RBI
argument_list|(
name|nb
argument_list|)
operator|->
name|next
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
expr_stmt|;
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|=
name|nb
expr_stmt|;
comment|/* Don't process this new block.  */
name|bb
operator|=
name|nb
expr_stmt|;
block|}
block|}
comment|/* Put basic_block_info in the new order.  */
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Reordered sequence:\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|bb
condition|;
name|bb
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|,
name|index
operator|++
control|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" %i %sbb %i freq %i\n"
argument_list|,
name|index
argument_list|,
name|bb
operator|->
name|index
operator|>=
name|old_n_basic_blocks
condition|?
literal|"compensation "
else|:
literal|""
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|bb
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|BASIC_BLOCK
argument_list|(
name|index
argument_list|)
operator|=
name|bb
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform sanity checks on the insn chain.    1. Check that next/prev pointers are consistent in both the forward and       reverse direction.    2. Count insns in chain, going both directions, and check if equal.    3. Check that get_last_insn () returns the actual end of chain.  */
end_comment

begin_function
name|void
name|verify_insn_chain
parameter_list|()
block|{
name|rtx
name|x
decl_stmt|,
name|prevx
decl_stmt|,
name|nextx
decl_stmt|;
name|int
name|insn_cnt1
decl_stmt|,
name|insn_cnt2
decl_stmt|;
for|for
control|(
name|prevx
operator|=
name|NULL
operator|,
name|insn_cnt1
operator|=
literal|1
operator|,
name|x
operator|=
name|get_insns
argument_list|()
init|;
name|x
operator|!=
literal|0
condition|;
name|prevx
operator|=
name|x
operator|,
name|insn_cnt1
operator|++
operator|,
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|PREV_INSN
argument_list|(
name|x
argument_list|)
operator|!=
name|prevx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevx
operator|!=
name|get_last_insn
argument_list|()
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|nextx
operator|=
name|NULL
operator|,
name|insn_cnt2
operator|=
literal|1
operator|,
name|x
operator|=
name|get_last_insn
argument_list|()
init|;
name|x
operator|!=
literal|0
condition|;
name|nextx
operator|=
name|x
operator|,
name|insn_cnt2
operator|++
operator|,
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
operator|!=
name|nextx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn_cnt1
operator|!=
name|insn_cnt2
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The block falling through to exit must be the last one in the reordered    chain.  Ensure it is.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_fallthru_exit_predecessor
parameter_list|()
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|bb
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|bb
operator|=
name|e
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|bb
operator|&&
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
condition|)
block|{
name|basic_block
name|c
init|=
name|BASIC_BLOCK
argument_list|(
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
operator|!=
name|bb
condition|)
name|c
operator|=
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
expr_stmt|;
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
condition|)
name|c
operator|=
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
expr_stmt|;
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
operator|=
name|bb
expr_stmt|;
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main entry point to this module: initialize the datastructures for CFG    layout changes.  */
end_comment

begin_function
name|void
name|cfg_layout_initialize
parameter_list|()
block|{
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reorder_block_def
argument_list|)
argument_list|)
expr_stmt|;
name|scope_to_insns_initialize
argument_list|()
expr_stmt|;
name|record_effective_endpoints
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finalize the changes: reorder insn list according to the sequence, enter    compensation code, rebuild scope forest.  */
end_comment

begin_function
name|void
name|cfg_layout_finalize
parameter_list|()
block|{
name|fixup_fallthru_exit_predecessor
argument_list|()
expr_stmt|;
name|fixup_reorder_chain
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_insn_chain
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|scope_to_insns_finalize
argument_list|()
expr_stmt|;
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

