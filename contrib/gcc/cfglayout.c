begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Basic block reordering routines for the GNU compiler.    Copyright (C) 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_comment
comment|/* The contents of the current function definition are allocated    in this obstack, and all are freed at the end of the function.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|flow_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the interesting trailing notes for the function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|function_footer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|skip_insns_after_block
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_effective_endpoints
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|label_for_bb
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_reorder_chain
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_block_levels
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|change_scope
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|verify_insn_chain
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup_unconditional_jumps
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_fallthru_exit_predecessor
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|unlink_insn_chain
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|duplicate_insn_chain
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|rtx
name|unlink_insn_chain
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|rtx
name|last
decl_stmt|;
block|{
name|rtx
name|prevfirst
init|=
name|PREV_INSN
argument_list|(
name|first
argument_list|)
decl_stmt|;
name|rtx
name|nextlast
init|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
decl_stmt|;
name|PREV_INSN
argument_list|(
name|first
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prevfirst
condition|)
name|NEXT_INSN
argument_list|(
name|prevfirst
argument_list|)
operator|=
name|nextlast
expr_stmt|;
if|if
condition|(
name|nextlast
condition|)
name|PREV_INSN
argument_list|(
name|nextlast
argument_list|)
operator|=
name|prevfirst
expr_stmt|;
else|else
name|set_last_insn
argument_list|(
name|prevfirst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prevfirst
condition|)
name|set_first_insn
argument_list|(
name|nextlast
argument_list|)
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip over inter-block insns occurring after BB which are typically    associated with BB (e.g., barriers). If there are any such insns,    we return the last one. Otherwise, we return the end of BB.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_insns_after_block
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|last_insn
decl_stmt|,
name|next_head
decl_stmt|,
name|prev
decl_stmt|;
name|next_head
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|next_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|next_head
operator|=
name|bb
operator|->
name|next_bb
operator|->
name|head
expr_stmt|;
for|for
control|(
name|last_insn
operator|=
name|insn
operator|=
name|bb
operator|->
name|end
init|;
operator|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|insn
operator|==
name|next_head
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|BARRIER
case|:
name|last_insn
operator|=
name|insn
expr_stmt|;
continue|continue;
case|case
name|NOTE
case|:
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_LOOP_END
case|:
case|case
name|NOTE_INSN_BLOCK_END
case|:
name|last_insn
operator|=
name|insn
expr_stmt|;
continue|continue;
case|case
name|NOTE_INSN_DELETED
case|:
case|case
name|NOTE_INSN_DELETED_LABEL
case|:
continue|continue;
default|default:
continue|continue;
break|break;
block|}
break|break;
case|case
name|CODE_LABEL
case|:
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|last_insn
operator|=
name|insn
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* It is possible to hit contradictory sequence.  For instance:       jump_insn      NOTE_INSN_LOOP_BEG      barrier       Where barrier belongs to jump_insn, but the note does not.  This can be      created by removing the basic block originally following      NOTE_INSN_LOOP_BEG.  In such case reorder the notes.  */
for|for
control|(
name|insn
operator|=
name|last_insn
init|;
name|insn
operator|!=
name|bb
operator|->
name|end
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_LOOP_END
case|:
case|case
name|NOTE_INSN_BLOCK_END
case|:
case|case
name|NOTE_INSN_DELETED
case|:
case|case
name|NOTE_INSN_DELETED_LABEL
case|:
continue|continue;
default|default:
name|reorder_insns
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|last_insn
return|;
block|}
end_function

begin_comment
comment|/* Locate or create a label for a given basic block.  */
end_comment

begin_function
specifier|static
name|rtx
name|label_for_bb
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|label
init|=
name|bb
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Emitting label for block %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|label
operator|=
name|block_label
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Locate the effective beginning and end of the insn chain for each    block, as defined by skip_insns_after_block above.  */
end_comment

begin_function
specifier|static
name|void
name|record_effective_endpoints
parameter_list|()
block|{
name|rtx
name|next_insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|end
decl_stmt|;
if|if
condition|(
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|head
argument_list|)
operator|&&
name|next_insn
operator|!=
name|bb
operator|->
name|head
condition|)
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|header
operator|=
name|unlink_insn_chain
argument_list|(
name|next_insn
argument_list|,
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|skip_insns_after_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
operator|&&
name|bb
operator|->
name|end
operator|!=
name|end
condition|)
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|footer
operator|=
name|unlink_insn_chain
argument_list|(
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
name|function_footer
operator|=
name|next_insn
expr_stmt|;
if|if
condition|(
name|function_footer
condition|)
name|function_footer
operator|=
name|unlink_insn_chain
argument_list|(
name|function_footer
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a varray mapping INSN_UID to lexical block.  Return it.  */
end_comment

begin_function
name|void
name|scope_to_insns_initialize
parameter_list|()
block|{
name|tree
name|block
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_insn_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
condition|)
name|INSN_SCOPE
argument_list|(
name|insn
argument_list|)
operator|=
name|block
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_BLOCK_BEG
case|:
name|block
operator|=
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_BLOCK_END
case|:
name|block
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
comment|/* Tag the blocks with a depth number so that change_scope can find      the common parent easily.  */
name|set_block_levels
argument_list|(
name|DECL_INITIAL
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each lexical block, set BLOCK_NUMBER to the depth at which it is    found in the block tree.  */
end_comment

begin_function
specifier|static
name|void
name|set_block_levels
parameter_list|(
name|block
parameter_list|,
name|level
parameter_list|)
name|tree
name|block
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
while|while
condition|(
name|block
condition|)
block|{
name|BLOCK_NUMBER
argument_list|(
name|block
argument_list|)
operator|=
name|level
expr_stmt|;
name|set_block_levels
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return sope resulting from combination of S1 and S2.  */
end_comment

begin_function
name|tree
name|choose_inner_scope
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|tree
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|s1
condition|)
return|return
name|s2
return|;
if|if
condition|(
operator|!
name|s2
condition|)
return|return
name|s1
return|;
if|if
condition|(
name|BLOCK_NUMBER
argument_list|(
name|s1
argument_list|)
operator|>
name|BLOCK_NUMBER
argument_list|(
name|s2
argument_list|)
condition|)
return|return
name|s1
return|;
return|return
name|s2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit lexical block notes needed to change scope from S1 to S2.  */
end_comment

begin_function
specifier|static
name|void
name|change_scope
parameter_list|(
name|orig_insn
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
name|rtx
name|orig_insn
decl_stmt|;
name|tree
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|orig_insn
decl_stmt|;
name|tree
name|com
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ts1
init|=
name|s1
decl_stmt|,
name|ts2
init|=
name|s2
decl_stmt|;
name|tree
name|s
decl_stmt|;
while|while
condition|(
name|ts1
operator|!=
name|ts2
condition|)
block|{
if|if
condition|(
name|ts1
operator|==
name|NULL
operator|||
name|ts2
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|BLOCK_NUMBER
argument_list|(
name|ts1
argument_list|)
operator|>
name|BLOCK_NUMBER
argument_list|(
name|ts2
argument_list|)
condition|)
name|ts1
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|ts1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BLOCK_NUMBER
argument_list|(
name|ts1
argument_list|)
operator|<
name|BLOCK_NUMBER
argument_list|(
name|ts2
argument_list|)
condition|)
name|ts2
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|ts2
argument_list|)
expr_stmt|;
else|else
block|{
name|ts1
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|ts1
argument_list|)
expr_stmt|;
name|ts2
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|ts2
argument_list|)
expr_stmt|;
block|}
block|}
name|com
operator|=
name|ts1
expr_stmt|;
comment|/* Close scopes.  */
name|s
operator|=
name|s1
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|com
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_BLOCK_END
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|NOTE_BLOCK
argument_list|(
name|note
argument_list|)
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Open scopes.  */
name|s
operator|=
name|s2
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|com
condition|)
block|{
name|insn
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_BLOCK_BEG
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rebuild all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes based    on the scope tree and the newly reordered instructions.  */
end_comment

begin_function
name|void
name|scope_to_insns_finalize
parameter_list|()
block|{
name|tree
name|cur_block
init|=
name|DECL_INITIAL
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|note
decl_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|tree
name|this_block
decl_stmt|;
name|this_block
operator|=
name|INSN_SCOPE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* For sequences compute scope resulting from merging all scopes          of instructions nested inside.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|this_block
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|this_block
operator|=
name|choose_inner_scope
argument_list|(
name|this_block
argument_list|,
name|INSN_SCOPE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this_block
condition|)
continue|continue;
if|if
condition|(
name|this_block
operator|!=
name|cur_block
condition|)
block|{
name|change_scope
argument_list|(
name|insn
argument_list|,
name|cur_block
argument_list|,
name|this_block
argument_list|)
expr_stmt|;
name|cur_block
operator|=
name|this_block
expr_stmt|;
block|}
block|}
comment|/* change_scope emits before the insn, not after.  */
name|note
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|change_scope
argument_list|(
name|note
argument_list|,
name|cur_block
argument_list|,
name|DECL_INITIAL
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|reorder_blocks
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a reorder chain, rearrange the code to match.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_reorder_chain
parameter_list|()
block|{
name|basic_block
name|bb
decl_stmt|,
name|prev_bb
decl_stmt|;
name|int
name|index
decl_stmt|;
name|rtx
name|insn
init|=
name|NULL
decl_stmt|;
comment|/* First do the bulk reordering -- rechain the blocks without regard to      the needed changes to jumps and labels.  */
for|for
control|(
name|bb
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|,
name|index
operator|=
literal|0
init|;
name|bb
operator|!=
literal|0
condition|;
name|bb
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|,
name|index
operator|++
control|)
block|{
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|header
condition|)
block|{
if|if
condition|(
name|insn
condition|)
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|header
expr_stmt|;
else|else
name|set_first_insn
argument_list|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|header
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|header
argument_list|)
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|header
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
condition|)
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|bb
operator|->
name|head
expr_stmt|;
else|else
name|set_first_insn
argument_list|(
name|bb
operator|->
name|head
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|head
argument_list|)
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|bb
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|footer
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|footer
expr_stmt|;
name|PREV_INSN
argument_list|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|footer
argument_list|)
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|index
operator|!=
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|function_footer
expr_stmt|;
if|if
condition|(
name|function_footer
condition|)
name|PREV_INSN
argument_list|(
name|function_footer
argument_list|)
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|set_last_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_insn_chain
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Now add jumps and labels as needed to match the blocks new      outgoing edges.  */
for|for
control|(
name|bb
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
init|;
name|bb
condition|;
name|bb
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
control|)
block|{
name|edge
name|e_fall
decl_stmt|,
name|e_taken
decl_stmt|,
name|e
decl_stmt|;
name|rtx
name|bb_end_insn
decl_stmt|;
name|basic_block
name|nb
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|succ
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Find the old fallthru edge, and another non-EH edge for 	 a taken jump.  */
name|e_taken
operator|=
name|e_fall
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|e_fall
operator|=
name|e
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
operator|)
condition|)
name|e_taken
operator|=
name|e
expr_stmt|;
name|bb_end_insn
operator|=
name|bb
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|bb_end_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|any_condjump_p
argument_list|(
name|bb_end_insn
argument_list|)
condition|)
block|{
comment|/* If the old fallthru is still next, nothing to do.  */
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|==
name|e_fall
operator|->
name|dest
operator|||
operator|(
operator|!
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|&&
name|e_fall
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|e_taken
condition|)
name|e_taken
operator|=
name|e_fall
expr_stmt|;
comment|/* The degenerated case of conditional jump jumping to the next 		 instruction can happen on target having jumps with side 		 effects.    		 Create temporarily the duplicated edge representing branch. 		 It will get unidentified by force_nonfallthru_and_redirect 		 that would otherwise get confused by fallthru edge not pointing 		 to the next basic block.  */
if|if
condition|(
operator|!
name|e_taken
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|edge
name|e_fake
decl_stmt|;
name|e_fake
operator|=
name|unchecked_make_edge
argument_list|(
name|bb
argument_list|,
name|e_fall
operator|->
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|bb
operator|->
name|end
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|int
name|prob
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|e_fake
operator|->
name|probability
operator|=
name|prob
expr_stmt|;
name|e_fake
operator|->
name|count
operator|=
name|e_fall
operator|->
name|count
operator|*
name|prob
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|e_fall
operator|->
name|probability
operator|-=
name|e_fall
operator|->
name|probability
expr_stmt|;
name|e_fall
operator|->
name|count
operator|-=
name|e_fake
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|e_fall
operator|->
name|probability
operator|<
literal|0
condition|)
name|e_fall
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|e_fall
operator|->
name|count
operator|<
literal|0
condition|)
name|e_fall
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* There is one special case: if *neither* block is next, 		 such as happens at the very end of a function, then we'll 		 need to add a new unconditional jump.  Choose the taken 		 edge based on known or assumed probability.  */
elseif|else
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|!=
name|e_taken
operator|->
name|dest
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|bb_end_insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|REG_BR_PROB_BASE
operator|/
literal|2
operator|&&
name|invert_jump
argument_list|(
name|bb_end_insn
argument_list|,
name|label_for_bb
argument_list|(
name|e_fall
operator|->
name|dest
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|e_fall
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|e_taken
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|update_br_prob_note
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|e
operator|=
name|e_fall
operator|,
name|e_fall
operator|=
name|e_taken
operator|,
name|e_taken
operator|=
name|e
expr_stmt|;
block|}
block|}
comment|/* Otherwise we can try to invert the jump.  This will 		 basically never fail, however, keep up the pretense.  */
elseif|else
if|if
condition|(
name|invert_jump
argument_list|(
name|bb_end_insn
argument_list|,
name|label_for_bb
argument_list|(
name|e_fall
operator|->
name|dest
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|e_fall
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|e_taken
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|update_br_prob_note
argument_list|(
name|bb
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|returnjump_p
argument_list|(
name|bb_end_insn
argument_list|)
condition|)
continue|continue;
else|else
block|{
comment|/* Otherwise we have some switch or computed jump.  In the 		 99% case, there should not have been a fallthru edge.  */
if|if
condition|(
operator|!
name|e_fall
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|CASE_DROPS_THROUGH
comment|/* Except for VAX.  Since we didn't have predication for the 		 tablejump, the fallthru block should not have moved.  */
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|==
name|e_fall
operator|->
name|dest
condition|)
continue|continue;
name|bb_end_insn
operator|=
name|skip_insns_after_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* No fallthru implies a noreturn function with EH edges, or 	     something similarly bizarre.  In any case, we don't need to 	     do anything.  */
if|if
condition|(
operator|!
name|e_fall
condition|)
continue|continue;
comment|/* If the fallthru block is still next, nothing to do.  */
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|==
name|e_fall
operator|->
name|dest
condition|)
continue|continue;
comment|/* A fallthru to exit block.  */
if|if
condition|(
operator|!
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|&&
name|e_fall
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
block|}
comment|/* We got here if we need to add a new jump insn.  */
name|nb
operator|=
name|force_nonfallthru
argument_list|(
name|e_fall
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
condition|)
block|{
name|alloc_aux_for_block
argument_list|(
name|nb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reorder_block_def
argument_list|)
argument_list|)
expr_stmt|;
name|RBI
argument_list|(
name|nb
argument_list|)
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
name|RBI
argument_list|(
name|nb
argument_list|)
operator|->
name|next
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
expr_stmt|;
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|=
name|nb
expr_stmt|;
comment|/* Don't process this new block.  */
name|bb
operator|=
name|nb
expr_stmt|;
block|}
block|}
comment|/* Put basic_block_info in the new order.  */
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Reordered sequence:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|,
name|index
operator|=
literal|0
init|;
name|bb
condition|;
name|bb
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|,
name|index
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" %i "
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|original
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"duplicate of %i "
argument_list|,
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|original
operator|->
name|index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|forwarder_block_p
argument_list|(
name|bb
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|bb
operator|->
name|head
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"compensation "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"bb %i "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" [%i]\n"
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
block|}
name|prev_bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
name|bb
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bb
condition|;
name|prev_bb
operator|=
name|bb
operator|,
name|bb
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|,
name|index
operator|++
control|)
block|{
name|bb
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|BASIC_BLOCK
argument_list|(
name|index
argument_list|)
operator|=
name|bb
expr_stmt|;
name|bb
operator|->
name|prev_bb
operator|=
name|prev_bb
expr_stmt|;
name|prev_bb
operator|->
name|next_bb
operator|=
name|bb
expr_stmt|;
block|}
name|prev_bb
operator|->
name|next_bb
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
operator|=
name|prev_bb
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform sanity checks on the insn chain.    1. Check that next/prev pointers are consistent in both the forward and       reverse direction.    2. Count insns in chain, going both directions, and check if equal.    3. Check that get_last_insn () returns the actual end of chain.  */
end_comment

begin_function
name|void
name|verify_insn_chain
parameter_list|()
block|{
name|rtx
name|x
decl_stmt|,
name|prevx
decl_stmt|,
name|nextx
decl_stmt|;
name|int
name|insn_cnt1
decl_stmt|,
name|insn_cnt2
decl_stmt|;
for|for
control|(
name|prevx
operator|=
name|NULL
operator|,
name|insn_cnt1
operator|=
literal|1
operator|,
name|x
operator|=
name|get_insns
argument_list|()
init|;
name|x
operator|!=
literal|0
condition|;
name|prevx
operator|=
name|x
operator|,
name|insn_cnt1
operator|++
operator|,
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|PREV_INSN
argument_list|(
name|x
argument_list|)
operator|!=
name|prevx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevx
operator|!=
name|get_last_insn
argument_list|()
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|nextx
operator|=
name|NULL
operator|,
name|insn_cnt2
operator|=
literal|1
operator|,
name|x
operator|=
name|get_last_insn
argument_list|()
init|;
name|x
operator|!=
literal|0
condition|;
name|nextx
operator|=
name|x
operator|,
name|insn_cnt2
operator|++
operator|,
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
operator|!=
name|nextx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn_cnt1
operator|!=
name|insn_cnt2
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove any unconditional jumps and forwarder block creating fallthru    edges instead.  During BB reordering, fallthru edges are not required    to target next basic block in the linear CFG layout, so the unconditional    jumps are not needed.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_unconditional_jumps
parameter_list|()
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
operator|!
name|bb
operator|->
name|succ
condition|)
continue|continue;
if|if
condition|(
name|bb
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
continue|continue;
if|if
condition|(
operator|!
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|bb
operator|->
name|head
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|forwarder_block_p
argument_list|(
name|bb
argument_list|)
operator|&&
name|bb
operator|->
name|prev_bb
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|basic_block
name|prev
init|=
name|bb
operator|->
name|prev_bb
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Removing forwarder BB %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|redirect_edge_succ_nodup
argument_list|(
name|bb
operator|->
name|pred
argument_list|,
name|bb
operator|->
name|succ
operator|->
name|dest
argument_list|)
expr_stmt|;
name|flow_delete_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|=
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|simplejump_p
argument_list|(
name|bb
operator|->
name|end
argument_list|)
condition|)
block|{
name|rtx
name|jump
init|=
name|bb
operator|->
name|end
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Removing jump %i in BB %i\n"
argument_list|,
name|INSN_UID
argument_list|(
name|jump
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|bb
operator|->
name|succ
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
else|else
continue|continue;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
operator|)
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|delete_barrier
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The block falling through to exit must be the last one in the    reordered chain.  Ensure that this condition is met.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_fallthru_exit_predecessor
parameter_list|()
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|bb
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|bb
operator|=
name|e
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|bb
operator|&&
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
condition|)
block|{
name|basic_block
name|c
init|=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
decl_stmt|;
while|while
condition|(
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
operator|!=
name|bb
condition|)
name|c
operator|=
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
expr_stmt|;
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
condition|)
name|c
operator|=
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
expr_stmt|;
name|RBI
argument_list|(
name|c
argument_list|)
operator|->
name|next
operator|=
name|bb
expr_stmt|;
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true in case it is possible to duplicate the basic block BB.  */
end_comment

begin_function
name|bool
name|cfg_layout_can_duplicate_bb_p
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|next
decl_stmt|;
name|edge
name|s
decl_stmt|;
if|if
condition|(
name|bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|bb
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return
name|false
return|;
comment|/* Duplicating fallthru block to exit would require adding a jump      and splitting the real last BB.  */
for|for
control|(
name|s
operator|=
name|bb
operator|->
name|succ
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|succ_next
control|)
if|if
condition|(
name|s
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|s
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
return|return
name|false
return|;
comment|/* Do not attempt to duplicate tablejumps, as we need to unshare      the dispatch table.  This is dificult to do, as the instructions      computing jump destination may be hoisted outside the basic block.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|bb
operator|->
name|end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|bb
operator|->
name|end
argument_list|)
operator|&&
operator|(
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|bb
operator|->
name|end
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|duplicate_insn_chain
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|;
comment|/* Avoid updating of boundaries of previous basic block.  The      note will get removed from insn stream in fixup.  */
name|last
operator|=
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Create copy at the end of INSN chain.  The chain will      be reordered later.  */
for|for
control|(
name|insn
operator|=
name|from
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|new
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|JUMP_INSN
case|:
comment|/* Avoid copying of dispatch tables.  We never duplicate 	     tablejumps, so this can hit only in case the table got 	     moved far from original jump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
break|break;
name|new
operator|=
name|emit_copy_of_insn_after
argument_list|(
name|insn
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
break|break;
case|case
name|BARRIER
case|:
name|emit_barrier
argument_list|()
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* In case prologue is empty and function contain label 	         in first BB, we may want to copy the block.  */
case|case
name|NOTE_INSN_PROLOGUE_END
case|:
case|case
name|NOTE_INSN_LOOP_VTOP
case|:
case|case
name|NOTE_INSN_LOOP_CONT
case|:
case|case
name|NOTE_INSN_LOOP_BEG
case|:
case|case
name|NOTE_INSN_LOOP_END
case|:
comment|/* Strip down the loop notes - we don't really want to keep 	         them consistent in loop copies.  */
case|case
name|NOTE_INSN_DELETED
case|:
case|case
name|NOTE_INSN_DELETED_LABEL
case|:
comment|/* No problem to strip these.  */
case|case
name|NOTE_INSN_EPILOGUE_BEG
case|:
case|case
name|NOTE_INSN_FUNCTION_END
case|:
comment|/* Debug code expect these notes to exist just once. 	         Keep them in the master copy. 	         ??? It probably makes more sense to duplicate them for each 	         epilogue copy.  */
case|case
name|NOTE_INSN_FUNCTION_BEG
case|:
comment|/* There is always just single entry to function.  */
case|case
name|NOTE_INSN_BASIC_BLOCK
case|:
break|break;
comment|/* There is no purpose to duplicate prologue.  */
case|case
name|NOTE_INSN_BLOCK_BEG
case|:
case|case
name|NOTE_INSN_BLOCK_END
case|:
comment|/* The BLOCK_BEG/BLOCK_END notes should be eliminated when BB 	         reordering is in the progress.  */
case|case
name|NOTE_INSN_EH_REGION_BEG
case|:
case|case
name|NOTE_INSN_EH_REGION_END
case|:
comment|/* Should never exist at BB duplication time.  */
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_REPEATED_LINE_NUMBER
case|:
name|emit_note
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* It is possible that no_line_number is set and the note 	         won't be emitted.  */
name|emit_note
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Redirect Edge to DEST.  */
end_comment

begin_function
name|void
name|cfg_layout_redirect_edge
parameter_list|(
name|e
parameter_list|,
name|dest
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|basic_block
name|old_next_bb
init|=
name|src
operator|->
name|next_bb
decl_stmt|;
comment|/* Redirect_edge_and_branch may decide to turn branch into fallthru edge      in the case the basic block appears to be in sequence.  Avoid this      transformation.  */
name|src
operator|->
name|next_bb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
comment|/* Redirect any branch edges unified with the fallthru one.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
operator|->
name|end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|src
operator|->
name|end
argument_list|)
operator|==
name|e
operator|->
name|dest
operator|->
name|head
condition|)
block|{
if|if
condition|(
operator|!
name|redirect_jump
argument_list|(
name|src
operator|->
name|end
argument_list|,
name|block_label
argument_list|(
name|dest
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* In case we are redirecting fallthru edge to the branch edge          of conditional jump, remove it.  */
if|if
condition|(
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|&&
operator|!
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|succ_next
condition|)
block|{
name|edge
name|s
init|=
name|e
operator|->
name|succ_next
condition|?
name|e
operator|->
name|succ_next
else|:
name|src
operator|->
name|succ
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|dest
operator|==
name|dest
operator|&&
name|any_condjump_p
argument_list|(
name|src
operator|->
name|end
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|src
operator|->
name|end
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|src
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
name|redirect_edge_succ_nodup
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* We don't want simplejumps in the insn stream during cfglayout.  */
if|if
condition|(
name|simplejump_p
argument_list|(
name|src
operator|->
name|end
argument_list|)
condition|)
block|{
name|delete_insn
argument_list|(
name|src
operator|->
name|end
argument_list|)
expr_stmt|;
name|delete_barrier
argument_list|(
name|NEXT_INSN
argument_list|(
name|src
operator|->
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|->
name|succ
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
name|src
operator|->
name|next_bb
operator|=
name|old_next_bb
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a duplicate of the basic block BB and redirect edge E into it.  */
end_comment

begin_function
name|basic_block
name|cfg_layout_duplicate_bb
parameter_list|(
name|bb
parameter_list|,
name|e
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|edge
name|s
decl_stmt|,
name|n
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|;
name|gcov_type
name|new_count
init|=
name|e
condition|?
name|e
operator|->
name|count
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|count
operator|<
name|new_count
condition|)
name|new_count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|bb
operator|->
name|pred
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
operator|!
name|cfg_layout_can_duplicate_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|insn
operator|=
name|duplicate_insn_chain
argument_list|(
name|bb
operator|->
name|head
argument_list|,
name|bb
operator|->
name|end
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|create_basic_block
argument_list|(
name|insn
argument_list|,
name|insn
condition|?
name|get_last_insn
argument_list|()
else|:
name|NULL
argument_list|,
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
name|alloc_aux_for_block
argument_list|(
name|new_bb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reorder_block_def
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|header
condition|)
block|{
name|insn
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|header
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|duplicate_insn_chain
argument_list|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|header
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|RBI
argument_list|(
name|new_bb
argument_list|)
operator|->
name|header
operator|=
name|unlink_insn_chain
argument_list|(
name|insn
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|footer
condition|)
block|{
name|insn
operator|=
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|footer
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|duplicate_insn_chain
argument_list|(
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|footer
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|RBI
argument_list|(
name|new_bb
argument_list|)
operator|->
name|footer
operator|=
name|unlink_insn_chain
argument_list|(
name|insn
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|global_live_at_start
condition|)
block|{
name|new_bb
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|global_live_at_start
argument_list|,
name|bb
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new_bb
operator|->
name|global_live_at_end
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
block|}
name|new_bb
operator|->
name|loop_depth
operator|=
name|bb
operator|->
name|loop_depth
expr_stmt|;
name|new_bb
operator|->
name|flags
operator|=
name|bb
operator|->
name|flags
expr_stmt|;
for|for
control|(
name|s
operator|=
name|bb
operator|->
name|succ
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|succ_next
control|)
block|{
name|n
operator|=
name|make_edge
argument_list|(
name|new_bb
argument_list|,
name|s
operator|->
name|dest
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
name|n
operator|->
name|probability
operator|=
name|s
operator|->
name|probability
expr_stmt|;
if|if
condition|(
name|new_count
condition|)
comment|/* Take care for overflows!  */
name|n
operator|->
name|count
operator|=
name|s
operator|->
name|count
operator|*
operator|(
name|new_count
operator|*
literal|10000
operator|/
name|bb
operator|->
name|count
operator|)
operator|/
literal|10000
expr_stmt|;
else|else
name|n
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|count
operator|-=
name|n
operator|->
name|count
expr_stmt|;
block|}
name|new_bb
operator|->
name|count
operator|=
name|new_count
expr_stmt|;
name|bb
operator|->
name|count
operator|-=
name|new_count
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|new_bb
operator|->
name|frequency
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|bb
operator|->
name|frequency
operator|-=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|cfg_layout_redirect_edge
argument_list|(
name|e
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|count
operator|<
literal|0
condition|)
name|bb
operator|->
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|frequency
operator|<
literal|0
condition|)
name|bb
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
name|RBI
argument_list|(
name|new_bb
argument_list|)
operator|->
name|original
operator|=
name|bb
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main entry point to this module - initialize the datastructures for    CFG layout changes.  It keeps LOOPS up-to-date if not null.  */
end_comment

begin_function
name|void
name|cfg_layout_initialize
parameter_list|()
block|{
comment|/* Our algorithm depends on fact that there are now dead jumptables      around the code.  */
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reorder_block_def
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_unconditional_jumps
argument_list|()
expr_stmt|;
name|record_effective_endpoints
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finalize the changes: reorder insn list according to the sequence, enter    compensation code, rebuild scope forest.  */
end_comment

begin_function
name|void
name|cfg_layout_finalize
parameter_list|()
block|{
name|fixup_fallthru_exit_predecessor
argument_list|()
expr_stmt|;
name|fixup_reorder_chain
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_insn_chain
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

