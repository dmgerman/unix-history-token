begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Command line option handling.    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Contributed by Neil Booth.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* For OPTIMIZATION_OPTIONS.  */
end_comment

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* For INSN_SCHEDULING.  */
end_comment

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_comment
comment|/* Value of the -G xx switch, and whether it was passed or not.  */
end_comment

begin_decl_stmt
name|unsigned
name|HOST_WIDE_INT
name|g_switch_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|g_switch_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we should exit after parsing options.  */
end_comment

begin_decl_stmt
name|bool
name|exit_after_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print various extra warnings.  -W/-Wextra.  */
end_comment

begin_decl_stmt
name|bool
name|extra_warnings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True to warn about any objects definitions whose size is larger    than N bytes.  Also want about function definitions whose returned    values are larger than N bytes, where N is `larger_than_size'.  */
end_comment

begin_decl_stmt
name|bool
name|warn_larger_than
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|larger_than_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True to warn about any function whose frame size is larger  * than N bytes. */
end_comment

begin_decl_stmt
name|bool
name|warn_frame_larger_than
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|frame_larger_than_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about constructs which might not be    strict-aliasing safe.  */
end_comment

begin_decl_stmt
name|int
name|warn_strict_aliasing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about optimizations which rely on undefined    signed overflow.  */
end_comment

begin_decl_stmt
name|int
name|warn_strict_overflow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hack for cooperation between set_Wunused and set_Wextra.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|maybe_warn_unused_parameter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type(s) of debugging information we are producing (if any).  See    flags.h for the definitions of the different possible types of    debugging information.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_type
name|write_symbols
init|=
name|NO_DEBUG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level of debugging information we are producing.  See flags.h for    the definitions of the different possible levels.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_level
name|debug_info_level
init|=
name|DINFO_LEVEL_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A major contribution to object and executable size is debug    information size.  A major contribution to debug information size    is struct descriptions replicated in several object files. The    following flags attempt to reduce this information.  The basic    idea is to not emit struct debugging information in the current    compilation unit when that information will be generated by    another compilation unit.     Debug information for a struct defined in the current source    file should be generated in the object file.  Likewise the    debug information for a struct defined in a header should be    generated in the object file of the corresponding source file.    Both of these case are handled when the base name of the file of    the struct definition matches the base name of the source file    of thet current compilation unit.  This matching emits minimal    struct debugging information.     The base file name matching rule above will fail to emit debug    information for structs defined in system headers.  So a second    category of files includes system headers in addition to files    with matching bases.     The remaining types of files are library headers and application    headers.  We cannot currently distinguish these two types.  */
end_comment

begin_enum
enum|enum
name|debug_struct_file
block|{
name|DINFO_STRUCT_FILE_NONE
block|,
comment|/* Debug no structs. */
name|DINFO_STRUCT_FILE_BASE
block|,
comment|/* Debug structs defined in files with the                                same base name as the compilation unit. */
name|DINFO_STRUCT_FILE_SYS
block|,
comment|/* Also debug structs defined in system                                header files.  */
name|DINFO_STRUCT_FILE_ANY
comment|/* Debug structs defined in all files. */
block|}
enum|;
end_enum

begin_comment
comment|/* Generic structs (e.g. templates not explicitly specialized)    may not have a compilation unit associated with them, and so    may need to be treated differently from ordinary structs.     Structs only handled by reference (indirectly), will also usually    not need as much debugging information.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|debug_struct_file
name|debug_struct_ordinary
index|[
name|DINFO_USAGE_NUM_ENUMS
index|]
init|=
block|{
name|DINFO_STRUCT_FILE_ANY
block|,
name|DINFO_STRUCT_FILE_ANY
block|,
name|DINFO_STRUCT_FILE_ANY
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|debug_struct_file
name|debug_struct_generic
index|[
name|DINFO_USAGE_NUM_ENUMS
index|]
init|=
block|{
name|DINFO_STRUCT_FILE_ANY
block|,
name|DINFO_STRUCT_FILE_ANY
block|,
name|DINFO_STRUCT_FILE_ANY
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse the -femit-struct-debug-detailed option value    and set the flag variables. */
end_comment

begin_define
define|#
directive|define
name|MATCH
parameter_list|(
name|prefix
parameter_list|,
name|string
parameter_list|)
define|\
value|((strncmp (prefix, string, sizeof prefix - 1) == 0) \    ? ((string += sizeof prefix - 1), 1) : 0)
end_define

begin_function
name|void
name|set_struct_debug_option
parameter_list|(
specifier|const
name|char
modifier|*
name|spec
parameter_list|)
block|{
comment|/* various labels for comparison */
specifier|static
name|char
name|dfn_lbl
index|[]
init|=
literal|"dfn:"
decl_stmt|,
name|dir_lbl
index|[]
init|=
literal|"dir:"
decl_stmt|,
name|ind_lbl
index|[]
init|=
literal|"ind:"
decl_stmt|;
specifier|static
name|char
name|ord_lbl
index|[]
init|=
literal|"ord:"
decl_stmt|,
name|gen_lbl
index|[]
init|=
literal|"gen:"
decl_stmt|;
specifier|static
name|char
name|none_lbl
index|[]
init|=
literal|"none"
decl_stmt|,
name|any_lbl
index|[]
init|=
literal|"any"
decl_stmt|;
specifier|static
name|char
name|base_lbl
index|[]
init|=
literal|"base"
decl_stmt|,
name|sys_lbl
index|[]
init|=
literal|"sys"
decl_stmt|;
name|enum
name|debug_struct_file
name|files
init|=
name|DINFO_STRUCT_FILE_ANY
decl_stmt|;
comment|/* Default is to apply to as much as possible. */
name|enum
name|debug_info_usage
name|usage
init|=
name|DINFO_USAGE_NUM_ENUMS
decl_stmt|;
name|int
name|ord
init|=
literal|1
decl_stmt|,
name|gen
init|=
literal|1
decl_stmt|;
comment|/* What usage? */
if|if
condition|(
name|MATCH
argument_list|(
name|dfn_lbl
argument_list|,
name|spec
argument_list|)
condition|)
name|usage
operator|=
name|DINFO_USAGE_DFN
expr_stmt|;
elseif|else
if|if
condition|(
name|MATCH
argument_list|(
name|dir_lbl
argument_list|,
name|spec
argument_list|)
condition|)
name|usage
operator|=
name|DINFO_USAGE_DIR_USE
expr_stmt|;
elseif|else
if|if
condition|(
name|MATCH
argument_list|(
name|ind_lbl
argument_list|,
name|spec
argument_list|)
condition|)
name|usage
operator|=
name|DINFO_USAGE_IND_USE
expr_stmt|;
comment|/* Generics or not? */
if|if
condition|(
name|MATCH
argument_list|(
name|ord_lbl
argument_list|,
name|spec
argument_list|)
condition|)
name|gen
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|MATCH
argument_list|(
name|gen_lbl
argument_list|,
name|spec
argument_list|)
condition|)
name|ord
operator|=
literal|0
expr_stmt|;
comment|/* What allowable environment? */
if|if
condition|(
name|MATCH
argument_list|(
name|none_lbl
argument_list|,
name|spec
argument_list|)
condition|)
name|files
operator|=
name|DINFO_STRUCT_FILE_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|MATCH
argument_list|(
name|any_lbl
argument_list|,
name|spec
argument_list|)
condition|)
name|files
operator|=
name|DINFO_STRUCT_FILE_ANY
expr_stmt|;
elseif|else
if|if
condition|(
name|MATCH
argument_list|(
name|sys_lbl
argument_list|,
name|spec
argument_list|)
condition|)
name|files
operator|=
name|DINFO_STRUCT_FILE_SYS
expr_stmt|;
elseif|else
if|if
condition|(
name|MATCH
argument_list|(
name|base_lbl
argument_list|,
name|spec
argument_list|)
condition|)
name|files
operator|=
name|DINFO_STRUCT_FILE_BASE
expr_stmt|;
else|else
name|error
argument_list|(
literal|"argument %qs to %<-femit-struct-debug-detailed%> not recognized"
argument_list|,
name|spec
argument_list|)
expr_stmt|;
comment|/* Effect the specification. */
if|if
condition|(
name|usage
operator|==
name|DINFO_USAGE_NUM_ENUMS
condition|)
block|{
if|if
condition|(
name|ord
condition|)
block|{
name|debug_struct_ordinary
index|[
name|DINFO_USAGE_DFN
index|]
operator|=
name|files
expr_stmt|;
name|debug_struct_ordinary
index|[
name|DINFO_USAGE_DIR_USE
index|]
operator|=
name|files
expr_stmt|;
name|debug_struct_ordinary
index|[
name|DINFO_USAGE_IND_USE
index|]
operator|=
name|files
expr_stmt|;
block|}
if|if
condition|(
name|gen
condition|)
block|{
name|debug_struct_generic
index|[
name|DINFO_USAGE_DFN
index|]
operator|=
name|files
expr_stmt|;
name|debug_struct_generic
index|[
name|DINFO_USAGE_DIR_USE
index|]
operator|=
name|files
expr_stmt|;
name|debug_struct_generic
index|[
name|DINFO_USAGE_IND_USE
index|]
operator|=
name|files
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ord
condition|)
name|debug_struct_ordinary
index|[
name|usage
index|]
operator|=
name|files
expr_stmt|;
if|if
condition|(
name|gen
condition|)
name|debug_struct_generic
index|[
name|usage
index|]
operator|=
name|files
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|spec
operator|==
literal|','
condition|)
name|set_struct_debug_option
argument_list|(
name|spec
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* No more -femit-struct-debug-detailed specifications.          Do final checks. */
if|if
condition|(
operator|*
name|spec
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|"argument %qs to %<-femit-struct-debug-detailed%> unknown"
argument_list|,
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_struct_ordinary
index|[
name|DINFO_USAGE_DIR_USE
index|]
operator|<
name|debug_struct_ordinary
index|[
name|DINFO_USAGE_IND_USE
index|]
operator|||
name|debug_struct_generic
index|[
name|DINFO_USAGE_DIR_USE
index|]
operator|<
name|debug_struct_generic
index|[
name|DINFO_USAGE_IND_USE
index|]
condition|)
name|error
argument_list|(
literal|"%<-femit-struct-debug-detailed=dir:...%> must allow at least"
literal|" as much as %<-femit-struct-debug-detailed=ind:...%>"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the base name of a path, stripping off both directories and    a single final extension. */
end_comment

begin_function
specifier|static
name|int
name|base_of_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|base_out
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|base
init|=
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|dot
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|path
decl_stmt|;
name|char
name|c
init|=
operator|*
name|p
decl_stmt|;
while|while
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|base
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|dot
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
name|dot
operator|=
name|p
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dot
condition|)
name|dot
operator|=
name|p
expr_stmt|;
operator|*
name|base_out
operator|=
name|base
expr_stmt|;
return|return
name|dot
operator|-
name|base
return|;
block|}
end_function

begin_comment
comment|/* Match the base name of a file to the base name of a compilation unit. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|main_input_basename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|main_input_baselength
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|matches_main_base
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
comment|/* Cache the last query. */
specifier|static
specifier|const
name|char
modifier|*
name|last_path
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|last_match
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|path
operator|!=
name|last_path
condition|)
block|{
specifier|const
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|length
init|=
name|base_of_path
argument_list|(
name|path
argument_list|,
operator|&
name|base
argument_list|)
decl_stmt|;
name|last_path
operator|=
name|path
expr_stmt|;
name|last_match
operator|=
operator|(
name|length
operator|==
name|main_input_baselength
operator|&&
name|memcmp
argument_list|(
name|base
argument_list|,
name|main_input_basename
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|last_match
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_DEBUG_STRUCT
end_ifdef

begin_function
specifier|static
name|int
name|dump_struct_debug
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|debug_info_usage
name|usage
parameter_list|,
name|enum
name|debug_struct_file
name|criterion
parameter_list|,
name|int
name|generic
parameter_list|,
name|int
name|matches
parameter_list|,
name|int
name|result
parameter_list|)
block|{
comment|/* Find the type name. */
name|tree
name|type_decl
init|=
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
init|=
name|type_decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|t
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	struct %d %s %s %s %s %d %p %s\n"
argument_list|,
name|criterion
argument_list|,
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|type_decl
argument_list|)
condition|?
literal|"sys"
else|:
literal|"usr"
argument_list|,
name|matches
condition|?
literal|"bas"
else|:
literal|"hdr"
argument_list|,
name|generic
condition|?
literal|"gen"
else|:
literal|"ord"
argument_list|,
name|usage
operator|==
name|DINFO_USAGE_DFN
condition|?
literal|";"
else|:
name|usage
operator|==
name|DINFO_USAGE_DIR_USE
condition|?
literal|"."
else|:
literal|"*"
argument_list|,
name|result
argument_list|,
operator|(
name|void
operator|*
operator|)
name|type_decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DUMP_GSTRUCT
parameter_list|(
name|type
parameter_list|,
name|usage
parameter_list|,
name|criterion
parameter_list|,
name|generic
parameter_list|,
name|matches
parameter_list|,
name|result
parameter_list|)
define|\
value|dump_struct_debug (type, usage, criterion, generic, matches, result)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DUMP_GSTRUCT
parameter_list|(
name|type
parameter_list|,
name|usage
parameter_list|,
name|criterion
parameter_list|,
name|generic
parameter_list|,
name|matches
parameter_list|,
name|result
parameter_list|)
define|\
value|(result)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|bool
name|should_emit_struct_debug
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|debug_info_usage
name|usage
parameter_list|)
block|{
name|enum
name|debug_struct_file
name|criterion
decl_stmt|;
name|tree
name|type_decl
decl_stmt|;
name|bool
name|generic
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|generic_p
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|generic
condition|)
name|criterion
operator|=
name|debug_struct_generic
index|[
name|usage
index|]
expr_stmt|;
else|else
name|criterion
operator|=
name|debug_struct_ordinary
index|[
name|usage
index|]
expr_stmt|;
if|if
condition|(
name|criterion
operator|==
name|DINFO_STRUCT_FILE_NONE
condition|)
return|return
name|DUMP_GSTRUCT
argument_list|(
name|type
argument_list|,
name|usage
argument_list|,
name|criterion
argument_list|,
name|generic
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
return|;
if|if
condition|(
name|criterion
operator|==
name|DINFO_STRUCT_FILE_ANY
condition|)
return|return
name|DUMP_GSTRUCT
argument_list|(
name|type
argument_list|,
name|usage
argument_list|,
name|criterion
argument_list|,
name|generic
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
return|;
name|type_decl
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|criterion
operator|==
name|DINFO_STRUCT_FILE_SYS
operator|&&
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|type_decl
argument_list|)
condition|)
return|return
name|DUMP_GSTRUCT
argument_list|(
name|type
argument_list|,
name|usage
argument_list|,
name|criterion
argument_list|,
name|generic
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
return|;
if|if
condition|(
name|matches_main_base
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|type_decl
argument_list|)
argument_list|)
condition|)
return|return
name|DUMP_GSTRUCT
argument_list|(
name|type
argument_list|,
name|usage
argument_list|,
name|criterion
argument_list|,
name|generic
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
return|;
return|return
name|DUMP_GSTRUCT
argument_list|(
name|type
argument_list|,
name|usage
argument_list|,
name|criterion
argument_list|,
name|generic
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero means use GNU-only extensions in the generated symbolic    debugging information.  Currently, this only has an effect when    write_symbols is set to DBX_DEBUG, XCOFF_DEBUG, or DWARF_DEBUG.  */
end_comment

begin_decl_stmt
name|bool
name|use_gnu_debug_info_extensions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default visibility for all symbols (unless overridden) */
end_comment

begin_decl_stmt
name|enum
name|symbol_visibility
name|default_visibility
init|=
name|VISIBILITY_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disable unit-at-a-time for frontends that might be still broken in this    respect.  */
end_comment

begin_decl_stmt
name|bool
name|no_unit_at_a_time_default
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global visibility options.  */
end_comment

begin_decl_stmt
name|struct
name|visibility_flags
name|visibility_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Columns of --help display.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|columns
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What to print when a switch has no documentation.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|undocumented_msg
index|[]
init|=
name|N_
argument_list|(
literal|"This switch lacks documentation"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for bookkeeping on whether user set these flags so    -fprofile-use/-fprofile-generate does not use them.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|profile_arc_flag_set
decl_stmt|,
name|flag_profile_values_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|flag_unroll_loops_set
decl_stmt|,
name|flag_tracer_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|flag_value_profile_transformations_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|flag_peel_loops_set
decl_stmt|,
name|flag_branch_probabilities_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions excluded from profiling.  */
end_comment

begin_typedef
typedef|typedef
name|char
modifier|*
name|char_p
typedef|;
end_typedef

begin_comment
comment|/* For DEF_VEC_P.  */
end_comment

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|char_p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|char_p
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|char_p
argument_list|,
name|heap
argument_list|)
operator|*
name|flag_instrument_functions_exclude_functions
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|char_p
argument_list|,
name|heap
argument_list|)
operator|*
name|flag_instrument_functions_exclude_files
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Input file names.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
modifier|*
name|in_fnames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|num_in_fnames
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|common_handle_option
parameter_list|(
name|size_t
name|scode
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_param
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_Wextra
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|handle_option
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|write_langs
parameter_list|(
name|unsigned
name|int
name|lang_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|complain_wrong_lang
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|cl_option
modifier|*
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_options
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wrap_help
parameter_list|(
specifier|const
name|char
modifier|*
name|help
parameter_list|,
specifier|const
name|char
modifier|*
name|item
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_target_help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_param_help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_filtered_help
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|print_switch
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|unsigned
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_debug_level
parameter_list|(
name|enum
name|debug_info_type
name|type
parameter_list|,
name|int
name|extended
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If ARG is a non-negative integer made up solely of digits, return its    value, otherwise return -1.  */
end_comment

begin_function
specifier|static
name|int
name|integral_argument
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|arg
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|atoi
argument_list|(
name|arg
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a malloced slash-separated list of languages in MASK.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|write_langs
parameter_list|(
name|unsigned
name|int
name|mask
parameter_list|)
block|{
name|unsigned
name|int
name|n
init|=
literal|0
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|lang_name
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|lang_name
operator|=
name|lang_names
index|[
name|n
index|]
operator|)
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1U
operator|<<
name|n
operator|)
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|lang_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|result
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|lang_name
operator|=
name|lang_names
index|[
name|n
index|]
operator|)
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1U
operator|<<
name|n
operator|)
condition|)
block|{
if|if
condition|(
name|len
condition|)
name|result
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len
argument_list|,
name|lang_name
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|lang_name
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Complain that switch OPT_INDEX does not apply to this front end.  */
end_comment

begin_function
specifier|static
name|void
name|complain_wrong_lang
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
specifier|const
name|struct
name|cl_option
modifier|*
name|option
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
block|{
name|char
modifier|*
name|ok_langs
decl_stmt|,
modifier|*
name|bad_lang
decl_stmt|;
name|ok_langs
operator|=
name|write_langs
argument_list|(
name|option
operator|->
name|flags
argument_list|)
expr_stmt|;
name|bad_lang
operator|=
name|write_langs
argument_list|(
name|lang_mask
argument_list|)
expr_stmt|;
comment|/* Eventually this should become a hard error IMO.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"command line option \"%s\" is valid for %s but not for %s"
argument_list|,
name|text
argument_list|,
name|ok_langs
argument_list|,
name|bad_lang
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ok_langs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bad_lang
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the switch beginning at ARGV for the language indicated by    LANG_MASK.  Returns the number of switches consumed.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|handle_option
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
block|{
name|size_t
name|opt_index
decl_stmt|;
specifier|const
name|char
modifier|*
name|opt
decl_stmt|,
modifier|*
name|arg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|dup
init|=
literal|0
decl_stmt|;
name|int
name|value
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|result
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|cl_option
modifier|*
name|option
decl_stmt|;
name|opt
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|opt_index
operator|=
name|find_opt
argument_list|(
name|opt
operator|+
literal|1
argument_list|,
name|lang_mask
operator||
name|CL_COMMON
operator||
name|CL_TARGET
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_index
operator|==
name|cl_options_count
operator|&&
operator|(
name|opt
index|[
literal|1
index|]
operator|==
literal|'W'
operator|||
name|opt
index|[
literal|1
index|]
operator|==
literal|'f'
operator|||
name|opt
index|[
literal|1
index|]
operator|==
literal|'m'
operator|)
operator|&&
name|opt
index|[
literal|2
index|]
operator|==
literal|'n'
operator|&&
name|opt
index|[
literal|3
index|]
operator|==
literal|'o'
operator|&&
name|opt
index|[
literal|4
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* Drop the "no-" from negative switches.  */
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|opt
argument_list|)
operator|-
literal|3
decl_stmt|;
name|dup
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dup
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|dup
index|[
literal|1
index|]
operator|=
name|opt
index|[
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|dup
operator|+
literal|2
argument_list|,
name|opt
operator|+
literal|5
argument_list|,
name|len
operator|-
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|opt
operator|=
name|dup
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|opt_index
operator|=
name|find_opt
argument_list|(
name|opt
operator|+
literal|1
argument_list|,
name|lang_mask
operator||
name|CL_COMMON
operator||
name|CL_TARGET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt_index
operator|==
name|cl_options_count
condition|)
goto|goto
name|done
goto|;
name|option
operator|=
operator|&
name|cl_options
index|[
name|opt_index
index|]
expr_stmt|;
comment|/* Reject negative form of switches that don't take negatives as      unrecognized.  */
if|if
condition|(
operator|!
name|value
operator|&&
operator|(
name|option
operator|->
name|flags
operator|&
name|CL_REJECT_NEGATIVE
operator|)
condition|)
goto|goto
name|done
goto|;
comment|/* We've recognized this switch.  */
name|result
operator|=
literal|1
expr_stmt|;
comment|/* Check to see if the option is disabled for this configuration.  */
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|CL_DISABLED
condition|)
block|{
name|error
argument_list|(
literal|"command line option %qs"
literal|" is not supported by this configuration"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Sort out any argument the switch takes.  */
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|CL_JOINED
condition|)
block|{
comment|/* Have arg point to the original switch.  This is because 	 some code, such as disable_builtin_function, expects its 	 argument to be persistent until the program exits.  */
name|arg
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|cl_options
index|[
name|opt_index
index|]
operator|.
name|opt_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
name|arg
operator|+=
name|strlen
argument_list|(
literal|"no-"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'\0'
operator|&&
operator|!
operator|(
name|option
operator|->
name|flags
operator|&
name|CL_MISSING_OK
operator|)
condition|)
block|{
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|CL_SEPARATE
condition|)
block|{
name|arg
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|result
operator|=
literal|2
expr_stmt|;
block|}
else|else
comment|/* Missing argument.  */
name|arg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|CL_SEPARATE
condition|)
block|{
name|arg
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|result
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Now we've swallowed any potential argument, complain if this      is a switch for a different front end.  */
if|if
condition|(
operator|!
operator|(
name|option
operator|->
name|flags
operator|&
operator|(
name|lang_mask
operator||
name|CL_COMMON
operator||
name|CL_TARGET
operator|)
operator|)
condition|)
block|{
name|complain_wrong_lang
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|option
argument_list|,
name|lang_mask
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|arg
operator|==
name|NULL
operator|&&
operator|(
name|option
operator|->
name|flags
operator|&
operator|(
name|CL_JOINED
operator||
name|CL_SEPARATE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|missing_argument
argument_list|(
name|opt
argument_list|,
name|opt_index
argument_list|)
condition|)
name|error
argument_list|(
literal|"missing argument to \"%s\""
argument_list|,
name|opt
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* If the switch takes an integer, convert it.  */
if|if
condition|(
name|arg
operator|&&
operator|(
name|option
operator|->
name|flags
operator|&
name|CL_UINTEGER
operator|)
condition|)
block|{
name|value
operator|=
name|integral_argument
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"argument to \"%s\" should be a non-negative integer"
argument_list|,
name|option
operator|->
name|opt_text
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|option
operator|->
name|flag_var
condition|)
switch|switch
condition|(
name|option
operator|->
name|var_type
condition|)
block|{
case|case
name|CLVC_BOOLEAN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|option
operator|->
name|flag_var
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|CLVC_EQUAL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|option
operator|->
name|flag_var
operator|=
operator|(
name|value
condition|?
name|option
operator|->
name|var_value
else|:
operator|!
name|option
operator|->
name|var_value
operator|)
expr_stmt|;
break|break;
case|case
name|CLVC_BIT_CLEAR
case|:
case|case
name|CLVC_BIT_SET
case|:
if|if
condition|(
operator|(
name|value
operator|!=
literal|0
operator|)
operator|==
operator|(
name|option
operator|->
name|var_type
operator|==
name|CLVC_BIT_SET
operator|)
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|option
operator|->
name|flag_var
operator||=
name|option
operator|->
name|var_value
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|option
operator|->
name|flag_var
operator|&=
operator|~
name|option
operator|->
name|var_value
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|flag_var
operator|==
operator|&
name|target_flags
condition|)
name|target_flags_explicit
operator||=
name|option
operator|->
name|var_value
expr_stmt|;
break|break;
case|case
name|CLVC_STRING
case|:
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|option
operator|->
name|flag_var
operator|=
name|arg
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|lang_mask
condition|)
if|if
condition|(
name|lang_hooks
operator|.
name|handle_option
argument_list|(
name|opt_index
argument_list|,
name|arg
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|&&
operator|(
name|option
operator|->
name|flags
operator|&
name|CL_COMMON
operator|)
condition|)
if|if
condition|(
name|common_handle_option
argument_list|(
name|opt_index
argument_list|,
name|arg
argument_list|,
name|value
argument_list|,
name|lang_mask
argument_list|)
operator|==
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|&&
operator|(
name|option
operator|->
name|flags
operator|&
name|CL_TARGET
operator|)
condition|)
if|if
condition|(
operator|!
name|targetm
operator|.
name|handle_option
argument_list|(
name|opt_index
argument_list|,
name|arg
argument_list|,
name|value
argument_list|)
condition|)
name|result
operator|=
literal|0
expr_stmt|;
name|done
label|:
if|if
condition|(
name|dup
condition|)
name|free
argument_list|(
name|dup
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Handle FILENAME from the command line.  */
end_comment

begin_function
specifier|static
name|void
name|add_input_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|num_in_fnames
operator|++
expr_stmt|;
name|in_fnames
operator|=
name|xrealloc
argument_list|(
name|in_fnames
argument_list|,
name|num_in_fnames
operator|*
sizeof|sizeof
argument_list|(
name|in_fnames
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|in_fnames
index|[
name|num_in_fnames
operator|-
literal|1
index|]
operator|=
name|filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add functions or file names to a vector of names to exclude from    instrumentation.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|add_instrument_functions_exclude_list
argument_list|(
name|VEC
argument_list|(
name|char_p
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|pvec
argument_list|,
specifier|const
name|char
operator|*
name|arg
argument_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|;
name|char
modifier|*
name|token_start
decl_stmt|;
comment|/* We never free this string.  */
name|tmp
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|r
operator|=
name|tmp
expr_stmt|;
name|w
operator|=
name|tmp
expr_stmt|;
name|token_start
operator|=
name|tmp
expr_stmt|;
while|while
condition|(
operator|*
name|r
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|r
operator|==
literal|','
condition|)
block|{
operator|*
name|w
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|r
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|char_p
argument_list|,
name|heap
argument_list|,
operator|*
name|pvec
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
name|token_start
operator|=
name|w
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|r
operator|==
literal|'\\'
operator|&&
name|r
index|[
literal|1
index|]
operator|==
literal|','
condition|)
block|{
operator|*
name|w
operator|++
operator|=
literal|','
expr_stmt|;
name|r
operator|+=
literal|2
expr_stmt|;
block|}
else|else
operator|*
name|w
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|token_start
operator|!=
literal|'\0'
condition|)
name|VEC_safe_push
argument_list|(
name|char_p
argument_list|,
name|heap
argument_list|,
operator|*
name|pvec
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Return whether we should exclude FNDECL from instrumentation.  */
end_comment

begin_function
name|bool
name|flag_instrument_functions_exclude_p
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
if|if
condition|(
name|VEC_length
argument_list|(
name|char_p
argument_list|,
name|flag_instrument_functions_exclude_functions
argument_list|)
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|name
operator|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|char_p
argument_list|,
name|flag_instrument_functions_exclude_functions
argument_list|,
name|i
argument_list|,
name|s
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
name|s
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
block|}
block|}
if|if
condition|(
name|VEC_length
argument_list|(
name|char_p
argument_list|,
name|flag_instrument_functions_exclude_files
argument_list|)
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|name
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|char_p
argument_list|,
name|flag_instrument_functions_exclude_files
argument_list|,
name|i
argument_list|,
name|s
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
name|s
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Decode and handle the vector of command line options.  LANG_MASK    contains has a single bit set representing the current    language.  */
end_comment

begin_function
specifier|static
name|void
name|handle_options
parameter_list|(
name|unsigned
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
block|{
name|unsigned
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|+=
name|n
control|)
block|{
specifier|const
name|char
modifier|*
name|opt
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
comment|/* Interpret "-" or a non-switch as a file name.  */
if|if
condition|(
name|opt
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|opt
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|main_input_filename
operator|==
name|NULL
condition|)
block|{
name|main_input_filename
operator|=
name|opt
expr_stmt|;
name|main_input_baselength
operator|=
name|base_of_path
argument_list|(
name|main_input_filename
argument_list|,
operator|&
name|main_input_basename
argument_list|)
expr_stmt|;
block|}
name|add_input_filename
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|n
operator|=
name|handle_option
argument_list|(
name|argv
operator|+
name|i
argument_list|,
name|lang_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|n
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"unrecognized command line option \"%s\""
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Parse command line options and set default flag values.  Do minimal    options processing.  */
end_comment

begin_function
name|void
name|decode_options
parameter_list|(
name|unsigned
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|lang_mask
decl_stmt|;
comment|/* Perform language-specific options initialization.  */
name|lang_mask
operator|=
name|lang_hooks
operator|.
name|init_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|initialize_diagnostics
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
comment|/* Scan to see what optimization level has been specified.  That will      determine the default value of many flags.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-O"
argument_list|)
condition|)
block|{
name|optimize
operator|=
literal|1
expr_stmt|;
name|optimize_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'O'
condition|)
block|{
comment|/* Handle -Os, -O2, -O3, -O69, ...  */
specifier|const
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|optimize_size
operator|=
literal|1
expr_stmt|;
comment|/* Optimizing for size forces optimize to be 2.  */
name|optimize
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|optimize_val
init|=
name|read_integral_parameter
argument_list|(
name|p
argument_list|,
name|p
operator|-
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|optimize_val
operator|!=
operator|-
literal|1
condition|)
block|{
name|optimize
operator|=
name|optimize_val
expr_stmt|;
name|optimize_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|optimize
condition|)
block|{
name|flag_merge_constants
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>=
literal|1
condition|)
block|{
name|flag_defer_pop
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
name|flag_delayed_branch
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CAN_DEBUG_WITHOUT_FP
name|flag_omit_frame_pointer
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|flag_guess_branch_prob
operator|=
literal|1
expr_stmt|;
name|flag_cprop_registers
operator|=
literal|1
expr_stmt|;
name|flag_if_conversion
operator|=
literal|1
expr_stmt|;
name|flag_if_conversion2
operator|=
literal|1
expr_stmt|;
name|flag_ipa_pure_const
operator|=
literal|1
expr_stmt|;
name|flag_ipa_reference
operator|=
literal|1
expr_stmt|;
name|flag_tree_ccp
operator|=
literal|1
expr_stmt|;
name|flag_tree_dce
operator|=
literal|1
expr_stmt|;
name|flag_tree_dom
operator|=
literal|1
expr_stmt|;
name|flag_tree_dse
operator|=
literal|1
expr_stmt|;
name|flag_tree_ter
operator|=
literal|1
expr_stmt|;
name|flag_tree_live_range_split
operator|=
literal|1
expr_stmt|;
name|flag_tree_sra
operator|=
literal|1
expr_stmt|;
name|flag_tree_copyrename
operator|=
literal|1
expr_stmt|;
name|flag_tree_fre
operator|=
literal|1
expr_stmt|;
name|flag_tree_copy_prop
operator|=
literal|1
expr_stmt|;
name|flag_tree_sink
operator|=
literal|1
expr_stmt|;
name|flag_tree_salias
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|no_unit_at_a_time_default
condition|)
name|flag_unit_at_a_time
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|optimize_size
condition|)
block|{
comment|/* Loop header copying usually increases size of the code.  This used 	     not to be true, since quite often it is possible to verify that 	     the condition is satisfied in the first iteration and therefore 	     to eliminate it.  Jump threading handles these cases now.  */
name|flag_tree_ch
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optimize
operator|>=
literal|2
condition|)
block|{
name|flag_thread_jumps
operator|=
literal|1
expr_stmt|;
name|flag_crossjumping
operator|=
literal|1
expr_stmt|;
name|flag_optimize_sibling_calls
operator|=
literal|1
expr_stmt|;
name|flag_cse_follow_jumps
operator|=
literal|1
expr_stmt|;
name|flag_cse_skip_blocks
operator|=
literal|1
expr_stmt|;
name|flag_gcse
operator|=
literal|1
expr_stmt|;
name|flag_expensive_optimizations
operator|=
literal|1
expr_stmt|;
name|flag_ipa_type_escape
operator|=
literal|1
expr_stmt|;
name|flag_rerun_cse_after_loop
operator|=
literal|1
expr_stmt|;
name|flag_caller_saves
operator|=
literal|1
expr_stmt|;
name|flag_peephole2
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
name|flag_schedule_insns
operator|=
literal|1
expr_stmt|;
name|flag_schedule_insns_after_reload
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|flag_regmove
operator|=
literal|1
expr_stmt|;
name|flag_strict_aliasing
operator|=
literal|1
expr_stmt|;
name|flag_strict_overflow
operator|=
literal|1
expr_stmt|;
name|flag_delete_null_pointer_checks
operator|=
literal|1
expr_stmt|;
name|flag_reorder_blocks
operator|=
literal|1
expr_stmt|;
name|flag_reorder_functions
operator|=
literal|1
expr_stmt|;
name|flag_tree_store_ccp
operator|=
literal|1
expr_stmt|;
name|flag_tree_store_copy_prop
operator|=
literal|1
expr_stmt|;
comment|/* XXX: some issues with ports have been traced to -ftree-vrp.          So remove it from -O2 and above.  Note that jdk1{5,6} are affected          and they build with w/-O3 - so we cannot just move it to -O3. */
comment|// flag_tree_vrp = 1;
if|if
condition|(
operator|!
name|optimize_size
condition|)
block|{
comment|/* PRE tends to generate bigger code.  */
name|flag_tree_pre
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optimize
operator|>=
literal|3
condition|)
block|{
name|flag_inline_functions
operator|=
literal|1
expr_stmt|;
name|flag_unswitch_loops
operator|=
literal|1
expr_stmt|;
name|flag_gcse_after_reload
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|optimize_size
condition|)
block|{
name|align_loops
operator|=
literal|1
expr_stmt|;
name|align_jumps
operator|=
literal|1
expr_stmt|;
name|align_labels
operator|=
literal|1
expr_stmt|;
name|align_functions
operator|=
literal|1
expr_stmt|;
comment|/* Don't reorder blocks when optimizing for size because extra 	 jump insns may be created; also barrier may create extra padding.  	 More correctly we should have a block reordering mode that tried 	 to minimize the combined size of all the jumps.  This would more 	 or less automatically remove extra jumps, but would also try to 	 use more short jumps instead of long jumps.  */
name|flag_reorder_blocks
operator|=
literal|0
expr_stmt|;
name|flag_reorder_blocks_and_partition
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|optimize_size
condition|)
block|{
comment|/* Inlining of very small functions usually reduces total size.  */
name|set_param_value
argument_list|(
literal|"max-inline-insns-single"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|set_param_value
argument_list|(
literal|"max-inline-insns-auto"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|flag_inline_functions
operator|=
literal|1
expr_stmt|;
comment|/* We want to crossjump as much as possible.  */
name|set_param_value
argument_list|(
literal|"min-crossjump-insns"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize whether `char' is signed.  */
name|flag_signed_char
operator|=
name|DEFAULT_SIGNED_CHAR
expr_stmt|;
comment|/* Set this to a special "uninitialized" value.  The actual default is set      after target options have been processed.  */
name|flag_short_enums
operator|=
literal|2
expr_stmt|;
comment|/* Initialize target_flags before OPTIMIZATION_OPTIONS so the latter can      modify it.  */
name|target_flags
operator|=
name|targetm
operator|.
name|default_target_flags
expr_stmt|;
comment|/* Some tagets have ABI-specified unwind tables.  */
name|flag_unwind_tables
operator|=
name|targetm
operator|.
name|unwind_tables_default
expr_stmt|;
ifdef|#
directive|ifdef
name|OPTIMIZATION_OPTIONS
comment|/* Allow default optimizations to be specified on a per-machine basis.  */
name|OPTIMIZATION_OPTIONS
argument_list|(
name|optimize
argument_list|,
name|optimize_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|handle_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|lang_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pie
condition|)
name|flag_pic
operator|=
name|flag_pie
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|flag_pie
condition|)
name|flag_shlib
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_no_inline
operator|==
literal|2
condition|)
name|flag_no_inline
operator|=
literal|0
expr_stmt|;
else|else
name|flag_really_no_inline
operator|=
name|flag_no_inline
expr_stmt|;
comment|/* Set flag_no_inline before the post_options () hook.  The C front      ends use it to determine tree inlining defaults.  FIXME: such      code should be lang-independent when all front ends use tree      inlining, in which case it, and this condition, should be moved      to the top of process_options() instead.  */
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
block|{
comment|/* Inlining does not work if not optimizing, 	 so force it not to be done.  */
name|flag_no_inline
operator|=
literal|1
expr_stmt|;
name|warn_inline
operator|=
literal|0
expr_stmt|;
comment|/* The c_decode_option function and decode_option hook set 	 this to `2' if -Wall is used, so we can avoid giving out 	 lots of errors for people who don't realize what -Wall does.  */
if|if
condition|(
name|warn_uninitialized
operator|==
literal|1
condition|)
name|warning
argument_list|(
name|OPT_Wuninitialized
argument_list|,
literal|"-Wuninitialized is not supported without -O"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_really_no_inline
operator|==
literal|2
condition|)
name|flag_really_no_inline
operator|=
name|flag_no_inline
expr_stmt|;
comment|/* The optimization to partition hot and cold basic blocks into separate      sections of the .o and executable files does not work (currently)      with exception handling.  This is because there is no support for      generating unwind info.  If flag_exceptions is turned on we need to      turn off the partitioning optimization.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|flag_reorder_blocks_and_partition
condition|)
block|{
name|inform
argument_list|(
literal|"-freorder-blocks-and-partition does not work with exceptions"
argument_list|)
expr_stmt|;
name|flag_reorder_blocks_and_partition
operator|=
literal|0
expr_stmt|;
name|flag_reorder_blocks
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If user requested unwind info, then turn off the partitioning      optimization.  */
if|if
condition|(
name|flag_unwind_tables
operator|&&
operator|!
name|targetm
operator|.
name|unwind_tables_default
operator|&&
name|flag_reorder_blocks_and_partition
condition|)
block|{
name|inform
argument_list|(
literal|"-freorder-blocks-and-partition does not support unwind info"
argument_list|)
expr_stmt|;
name|flag_reorder_blocks_and_partition
operator|=
literal|0
expr_stmt|;
name|flag_reorder_blocks
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the target requested unwind info, then turn off the partitioning      optimization with a different message.  Likewise, if the target does not      support named sections.  */
if|if
condition|(
name|flag_reorder_blocks_and_partition
operator|&&
operator|(
operator|!
name|targetm
operator|.
name|have_named_sections
operator|||
operator|(
name|flag_unwind_tables
operator|&&
name|targetm
operator|.
name|unwind_tables_default
operator|)
operator|)
condition|)
block|{
name|inform
argument_list|(
literal|"-freorder-blocks-and-partition does not work on this architecture"
argument_list|)
expr_stmt|;
name|flag_reorder_blocks_and_partition
operator|=
literal|0
expr_stmt|;
name|flag_reorder_blocks
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle target- and language-independent options.  Return zero to    generate an "unknown option" message.  Only options that need    extra handling need to be listed here; if you simply want    VALUE assigned to a variable, it happens automatically.  */
end_comment

begin_function
specifier|static
name|int
name|common_handle_option
parameter_list|(
name|size_t
name|scode
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
block|{
name|enum
name|opt_code
name|code
init|=
operator|(
expr|enum
name|opt_code
operator|)
name|scode
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|OPT__help
case|:
name|print_help
argument_list|()
expr_stmt|;
name|exit_after_options
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT__param
case|:
name|handle_param
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT__target_help
case|:
name|print_target_help
argument_list|()
expr_stmt|;
name|exit_after_options
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT__version
case|:
name|print_version
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit_after_options
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_G
case|:
name|g_switch_value
operator|=
name|value
expr_stmt|;
name|g_switch_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_O
case|:
case|case
name|OPT_Os
case|:
comment|/* Currently handled in a prescan.  */
break|break;
case|case
name|OPT_W
case|:
comment|/* For backward compatibility, -W is the same as -Wextra.  */
name|set_Wextra
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_Werror_
case|:
block|{
name|char
modifier|*
name|new_option
decl_stmt|;
name|int
name|option_index
decl_stmt|;
name|new_option
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|new_option
index|[
literal|0
index|]
operator|=
literal|'W'
expr_stmt|;
name|strcpy
argument_list|(
name|new_option
operator|+
literal|1
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|option_index
operator|=
name|find_opt
argument_list|(
name|new_option
argument_list|,
name|lang_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_index
operator|==
name|N_OPTS
condition|)
block|{
name|error
argument_list|(
literal|"-Werror=%s: No option -%s"
argument_list|,
name|arg
argument_list|,
name|new_option
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|kind
init|=
name|value
condition|?
name|DK_ERROR
else|:
name|DK_WARNING
decl_stmt|;
name|diagnostic_classify_diagnostic
argument_list|(
name|global_dc
argument_list|,
name|option_index
argument_list|,
name|kind
argument_list|)
expr_stmt|;
comment|/* -Werror=foo implies -Wfoo.  */
if|if
condition|(
name|cl_options
index|[
name|option_index
index|]
operator|.
name|var_type
operator|==
name|CLVC_BOOLEAN
operator|&&
name|cl_options
index|[
name|option_index
index|]
operator|.
name|flag_var
operator|&&
name|kind
operator|==
name|DK_ERROR
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|cl_options
index|[
name|option_index
index|]
operator|.
name|flag_var
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|new_option
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPT_Wextra
case|:
name|set_Wextra
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_Wlarger_than_
case|:
name|larger_than_size
operator|=
name|value
expr_stmt|;
name|warn_larger_than
operator|=
name|value
operator|!=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_Wframe_larger_than_
case|:
name|frame_larger_than_size
operator|=
name|value
expr_stmt|;
name|warn_frame_larger_than
operator|=
name|value
operator|!=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_Wstrict_aliasing
case|:
name|set_warn_strict_aliasing
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_Wstrict_aliasing_
case|:
name|warn_strict_aliasing
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wstrict_overflow
case|:
name|warn_strict_overflow
operator|=
operator|(
name|value
condition|?
operator|(
name|int
operator|)
name|WARN_STRICT_OVERFLOW_CONDITIONAL
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|OPT_Wstrict_overflow_
case|:
name|warn_strict_overflow
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wunused
case|:
name|set_Wunused
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_aux_info
case|:
case|case
name|OPT_aux_info_
case|:
name|aux_info_file_name
operator|=
name|arg
expr_stmt|;
name|flag_gen_aux_info
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_auxbase
case|:
name|aux_base_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_auxbase_strip
case|:
block|{
name|char
modifier|*
name|tmp
init|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|strip_off_ending
argument_list|(
name|tmp
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
condition|)
name|aux_base_name
operator|=
name|tmp
expr_stmt|;
block|}
break|break;
case|case
name|OPT_d
case|:
name|decode_d_option
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_dumpbase
case|:
name|dump_base_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_falign_functions_
case|:
name|align_functions
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_falign_jumps_
case|:
name|align_jumps
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_falign_labels_
case|:
name|align_labels
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_falign_loops_
case|:
name|align_loops
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fbranch_probabilities
case|:
name|flag_branch_probabilities_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_fcall_used_
case|:
name|fix_register
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_fcall_saved_
case|:
name|fix_register
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_fdiagnostics_show_location_
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"once"
argument_list|)
condition|)
name|diagnostic_prefixing_rule
argument_list|(
name|global_dc
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"every-line"
argument_list|)
condition|)
name|diagnostic_prefixing_rule
argument_list|(
name|global_dc
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|OPT_fdiagnostics_show_option
case|:
name|global_dc
operator|->
name|show_option_requested
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_fdump_
case|:
if|if
condition|(
operator|!
name|dump_switch_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|OPT_ffast_math
case|:
name|set_fast_math_flags
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ffixed_
case|:
name|fix_register
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_finline_limit_
case|:
case|case
name|OPT_finline_limit_eq
case|:
name|set_param_value
argument_list|(
literal|"max-inline-insns-single"
argument_list|,
name|value
operator|/
literal|2
argument_list|)
expr_stmt|;
name|set_param_value
argument_list|(
literal|"max-inline-insns-auto"
argument_list|,
name|value
operator|/
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_finstrument_functions_exclude_function_list_
case|:
name|add_instrument_functions_exclude_list
argument_list|(
operator|&
name|flag_instrument_functions_exclude_functions
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_finstrument_functions_exclude_file_list_
case|:
name|add_instrument_functions_exclude_list
argument_list|(
operator|&
name|flag_instrument_functions_exclude_files
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_fmessage_length_
case|:
name|pp_set_line_maximum_length
argument_list|(
name|global_dc
operator|->
name|printer
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_fpack_struct_
case|:
if|if
condition|(
name|value
operator|<=
literal|0
operator|||
operator|(
name|value
operator|&
operator|(
name|value
operator|-
literal|1
operator|)
operator|)
operator|||
name|value
operator|>
literal|16
condition|)
name|error
argument_list|(
literal|"structure alignment must be a small power of two, not %d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|initial_max_fld_align
operator|=
name|value
expr_stmt|;
name|maximum_field_alignment
operator|=
name|value
operator|*
name|BITS_PER_UNIT
expr_stmt|;
block|}
break|break;
case|case
name|OPT_fpeel_loops
case|:
name|flag_peel_loops_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_fprofile_arcs
case|:
name|profile_arc_flag_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_fprofile_use
case|:
if|if
condition|(
operator|!
name|flag_branch_probabilities_set
condition|)
name|flag_branch_probabilities
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_profile_values_set
condition|)
name|flag_profile_values
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_unroll_loops_set
condition|)
name|flag_unroll_loops
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_peel_loops_set
condition|)
name|flag_peel_loops
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_tracer_set
condition|)
name|flag_tracer
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_value_profile_transformations_set
condition|)
name|flag_value_profile_transformations
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fprofile_generate
case|:
if|if
condition|(
operator|!
name|profile_arc_flag_set
condition|)
name|profile_arc_flag
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_profile_values_set
condition|)
name|flag_profile_values
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_value_profile_transformations_set
condition|)
name|flag_value_profile_transformations
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fprofile_values
case|:
name|flag_profile_values_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_fvisibility_
case|:
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"default"
argument_list|)
condition|)
name|default_visibility
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"internal"
argument_list|)
condition|)
name|default_visibility
operator|=
name|VISIBILITY_INTERNAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"hidden"
argument_list|)
condition|)
name|default_visibility
operator|=
name|VISIBILITY_HIDDEN
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"protected"
argument_list|)
condition|)
name|default_visibility
operator|=
name|VISIBILITY_PROTECTED
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unrecognized visibility value \"%s\""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPT_fvpt
case|:
name|flag_value_profile_transformations_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_frandom_seed
case|:
comment|/* The real switch is -fno-random-seed.  */
if|if
condition|(
name|value
condition|)
return|return
literal|0
return|;
name|flag_random_seed
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPT_frandom_seed_
case|:
name|flag_random_seed
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_fsched_verbose_
case|:
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
name|fix_sched_param
argument_list|(
literal|"verbose"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
case|case
name|OPT_fsched_stalled_insns_
case|:
name|flag_sched_stalled_insns
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|flag_sched_stalled_insns
operator|==
literal|0
condition|)
name|flag_sched_stalled_insns
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_fsched_stalled_insns_dep_
case|:
name|flag_sched_stalled_insns_dep
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fstack_limit
case|:
comment|/* The real switch is -fno-stack-limit.  */
if|if
condition|(
name|value
condition|)
return|return
literal|0
return|;
name|stack_limit_rtx
operator|=
name|NULL_RTX
expr_stmt|;
break|break;
case|case
name|OPT_fstack_limit_register_
case|:
block|{
name|int
name|reg
init|=
name|decode_reg_name
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"unrecognized register name \"%s\""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|stack_limit_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPT_fstack_limit_symbol_
case|:
name|stack_limit_rtx
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ftree_vectorizer_verbose_
case|:
name|vect_set_verbosity_level
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ftls_model_
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"global-dynamic"
argument_list|)
condition|)
name|flag_tls_default
operator|=
name|TLS_MODEL_GLOBAL_DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"local-dynamic"
argument_list|)
condition|)
name|flag_tls_default
operator|=
name|TLS_MODEL_LOCAL_DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"initial-exec"
argument_list|)
condition|)
name|flag_tls_default
operator|=
name|TLS_MODEL_INITIAL_EXEC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"local-exec"
argument_list|)
condition|)
name|flag_tls_default
operator|=
name|TLS_MODEL_LOCAL_EXEC
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unknown tls-model \"%s\""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ftracer
case|:
name|flag_tracer_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_funroll_loops
case|:
name|flag_unroll_loops_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_g
case|:
name|set_debug_level
argument_list|(
name|NO_DEBUG
argument_list|,
name|DEFAULT_GDB_EXTENSIONS
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_gcoff
case|:
name|set_debug_level
argument_list|(
name|SDB_DEBUG
argument_list|,
name|false
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_gdwarf_2
case|:
name|set_debug_level
argument_list|(
name|DWARF2_DEBUG
argument_list|,
name|false
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ggdb
case|:
name|set_debug_level
argument_list|(
name|NO_DEBUG
argument_list|,
literal|2
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_gstabs
case|:
case|case
name|OPT_gstabs_
case|:
name|set_debug_level
argument_list|(
name|DBX_DEBUG
argument_list|,
name|code
operator|==
name|OPT_gstabs_
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_gvms
case|:
name|set_debug_level
argument_list|(
name|VMS_DEBUG
argument_list|,
name|false
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_gxcoff
case|:
case|case
name|OPT_gxcoff_
case|:
name|set_debug_level
argument_list|(
name|XCOFF_DEBUG
argument_list|,
name|code
operator|==
name|OPT_gxcoff_
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_o
case|:
name|asm_file_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_pedantic_errors
case|:
name|flag_pedantic_errors
operator|=
name|pedantic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_fforce_mem
case|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-f[no-]force-mem is nop and option will be removed in 4.3"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_floop_optimize
case|:
case|case
name|OPT_frerun_loop_opt
case|:
case|case
name|OPT_fstrength_reduce
case|:
comment|/* These are no-ops, preserved for backward compatibility.  */
break|break;
default|default:
comment|/* If the flag was handled in a standard way, assume the lack of 	 processing here is intentional.  */
name|gcc_assert
argument_list|(
name|cl_options
index|[
name|scode
index|]
operator|.
name|flag_var
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle --param NAME=VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|handle_param
parameter_list|(
specifier|const
name|char
modifier|*
name|carg
parameter_list|)
block|{
name|char
modifier|*
name|equal
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|int
name|value
decl_stmt|;
name|arg
operator|=
name|xstrdup
argument_list|(
name|carg
argument_list|)
expr_stmt|;
name|equal
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|equal
condition|)
name|error
argument_list|(
literal|"%s: --param arguments should be of the form NAME=VALUE"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
name|integral_argument
argument_list|(
name|equal
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"invalid --param value %qs"
argument_list|,
name|equal
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|equal
operator|=
literal|'\0'
expr_stmt|;
name|set_param_value
argument_list|(
name|arg
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle -W and -Wextra.  */
end_comment

begin_function
specifier|static
name|void
name|set_Wextra
parameter_list|(
name|int
name|setting
parameter_list|)
block|{
name|extra_warnings
operator|=
name|setting
expr_stmt|;
name|warn_unused_value
operator|=
name|setting
expr_stmt|;
name|warn_unused_parameter
operator|=
operator|(
name|setting
operator|&&
name|maybe_warn_unused_parameter
operator|)
expr_stmt|;
comment|/* We save the value of warn_uninitialized, since if they put      -Wuninitialized on the command line, we need to generate a      warning about not using it without also specifying -O.  */
if|if
condition|(
name|setting
operator|==
literal|0
condition|)
name|warn_uninitialized
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_uninitialized
operator|!=
literal|1
condition|)
name|warn_uninitialized
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize unused warning flags.  */
end_comment

begin_function
name|void
name|set_Wunused
parameter_list|(
name|int
name|setting
parameter_list|)
block|{
name|warn_unused_function
operator|=
name|setting
expr_stmt|;
name|warn_unused_label
operator|=
name|setting
expr_stmt|;
comment|/* Unused function parameter warnings are reported when either      ``-Wextra -Wunused'' or ``-Wunused-parameter'' is specified.      Thus, if -Wextra has already been seen, set warn_unused_parameter;      otherwise set maybe_warn_extra_parameter, which will be picked up      by set_Wextra.  */
name|maybe_warn_unused_parameter
operator|=
name|setting
expr_stmt|;
name|warn_unused_parameter
operator|=
operator|(
name|setting
operator|&&
name|extra_warnings
operator|)
expr_stmt|;
name|warn_unused_variable
operator|=
name|setting
expr_stmt|;
name|warn_unused_value
operator|=
name|setting
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used to set the level of strict aliasing warnings,     when no level is specified (i.e., when -Wstrict-aliasing, and not    -Wstrict-aliasing=level was given).    ONOFF is assumed to take value 1 when -Wstrict-aliasing is specified,    and 0 otherwise.  After calling this function, wstrict_aliasing will be    set to the default value of -Wstrict_aliasing=level, currently 3.  */
end_comment

begin_function
name|void
name|set_warn_strict_aliasing
parameter_list|(
name|int
name|onoff
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|onoff
operator|==
literal|0
operator|||
name|onoff
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
operator|!=
literal|0
condition|)
name|warn_strict_aliasing
operator|=
literal|3
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following routines are useful in setting all the flags that    -ffast-math and -fno-fast-math imply.  */
end_comment

begin_function
name|void
name|set_fast_math_flags
parameter_list|(
name|int
name|set
parameter_list|)
block|{
name|flag_trapping_math
operator|=
operator|!
name|set
expr_stmt|;
name|flag_unsafe_math_optimizations
operator|=
name|set
expr_stmt|;
name|flag_finite_math_only
operator|=
name|set
expr_stmt|;
name|flag_errno_math
operator|=
operator|!
name|set
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|flag_signaling_nans
operator|=
literal|0
expr_stmt|;
name|flag_rounding_math
operator|=
literal|0
expr_stmt|;
name|flag_cx_limited_range
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true iff flags are set as if -ffast-math.  */
end_comment

begin_function
name|bool
name|fast_math_flags_set_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|!
name|flag_trapping_math
operator|&&
name|flag_unsafe_math_optimizations
operator|&&
name|flag_finite_math_only
operator|&&
operator|!
name|flag_errno_math
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle a debug output -g switch.  EXTENDED is true or false to support    extended output (2 is special and means "-ggdb" was given).  */
end_comment

begin_function
specifier|static
name|void
name|set_debug_level
parameter_list|(
name|enum
name|debug_info_type
name|type
parameter_list|,
name|int
name|extended
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|bool
name|type_explicit
decl_stmt|;
name|use_gnu_debug_info_extensions
operator|=
name|extended
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NO_DEBUG
condition|)
block|{
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
block|{
name|write_symbols
operator|=
name|PREFERRED_DEBUGGING_TYPE
expr_stmt|;
if|if
condition|(
name|extended
operator|==
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
name|write_symbols
operator|=
name|DWARF2_DEBUG
expr_stmt|;
elif|#
directive|elif
name|defined
name|DBX_DEBUGGING_INFO
name|write_symbols
operator|=
name|DBX_DEBUG
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"target system does not support debug output"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Does it conflict with an already selected type?  */
if|if
condition|(
name|type_explicit
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|type
operator|!=
name|write_symbols
condition|)
name|error
argument_list|(
literal|"debug format \"%s\" conflicts with prior selection"
argument_list|,
name|debug_type_names
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|write_symbols
operator|=
name|type
expr_stmt|;
name|type_explicit
operator|=
name|true
expr_stmt|;
block|}
comment|/* A debug flag without a level defaults to level 2.  */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|debug_info_level
condition|)
name|debug_info_level
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|debug_info_level
operator|=
name|integral_argument
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"unrecognised debug output level \"%s\""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|debug_info_level
operator|>
literal|3
condition|)
name|error
argument_list|(
literal|"debug output level %s is too high"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Display help for target options.  */
end_comment

begin_function
specifier|static
name|void
name|print_target_help
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
name|bool
name|displayed
init|=
name|false
decl_stmt|;
comment|/* Avoid double printing for --help --target-help.  */
if|if
condition|(
name|displayed
condition|)
return|return;
name|displayed
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl_options_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|cl_options
index|[
name|i
index|]
operator|.
name|flags
operator|&
operator|(
name|CL_TARGET
operator||
name|CL_UNDOCUMENTED
operator|)
operator|)
operator|==
name|CL_TARGET
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nTarget specific options:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|print_filtered_help
argument_list|(
name|CL_TARGET
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Output --help text.  */
end_comment

begin_function
specifier|static
name|void
name|print_help
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|GET_ENVIRONMENT
argument_list|(
name|p
argument_list|,
literal|"COLUMNS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|int
name|value
init|=
name|atoi
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|>
literal|0
condition|)
name|columns
operator|=
name|value
expr_stmt|;
block|}
name|puts
argument_list|(
name|_
argument_list|(
literal|"The following options are language-independent:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|print_filtered_help
argument_list|(
name|CL_COMMON
argument_list|)
expr_stmt|;
name|print_param_help
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lang_names
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"The %s front end recognizes the following options:\n\n"
argument_list|)
argument_list|,
name|lang_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|print_filtered_help
argument_list|(
literal|1U
operator|<<
name|i
argument_list|)
expr_stmt|;
block|}
name|print_target_help
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the help for --param.  */
end_comment

begin_function
specifier|static
name|void
name|print_param_help
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"The --param option recognizes the following as parameters:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LAST_PARAM
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|help
init|=
name|compiler_params
index|[
name|i
index|]
operator|.
name|help
decl_stmt|;
specifier|const
name|char
modifier|*
name|param
init|=
name|compiler_params
index|[
name|i
index|]
operator|.
name|option
decl_stmt|;
if|if
condition|(
name|help
operator|==
name|NULL
operator|||
operator|*
name|help
operator|==
literal|'\0'
condition|)
name|help
operator|=
name|undocumented_msg
expr_stmt|;
comment|/* Get the translation.  */
name|help
operator|=
name|_
argument_list|(
name|help
argument_list|)
expr_stmt|;
name|wrap_help
argument_list|(
name|help
argument_list|,
name|param
argument_list|,
name|strlen
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print help for a specific front-end, etc.  */
end_comment

begin_function
specifier|static
name|void
name|print_filtered_help
parameter_list|(
name|unsigned
name|int
name|flag
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|filter
decl_stmt|,
name|indent
init|=
literal|0
decl_stmt|;
name|bool
name|duplicates
init|=
name|false
decl_stmt|;
specifier|const
name|char
modifier|*
name|help
decl_stmt|,
modifier|*
name|opt
decl_stmt|,
modifier|*
name|tab
decl_stmt|;
specifier|static
name|char
modifier|*
name|printed
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|CL_COMMON
operator|||
name|flag
operator|==
name|CL_TARGET
condition|)
block|{
name|filter
operator|=
name|flag
expr_stmt|;
if|if
condition|(
operator|!
name|printed
condition|)
name|printed
operator|=
name|xmalloc
argument_list|(
name|cl_options_count
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|printed
argument_list|,
literal|0
argument_list|,
name|cl_options_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't print COMMON options twice.  */
name|filter
operator|=
name|flag
operator||
name|CL_COMMON
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl_options_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cl_options
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|filter
operator|)
operator|!=
name|flag
condition|)
continue|continue;
comment|/* Skip help for internal switches.  */
if|if
condition|(
name|cl_options
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CL_UNDOCUMENTED
condition|)
continue|continue;
comment|/* Skip switches that have already been printed, mark them to be 	     listed later.  */
if|if
condition|(
name|printed
index|[
name|i
index|]
condition|)
block|{
name|duplicates
operator|=
name|true
expr_stmt|;
name|indent
operator|=
name|print_switch
argument_list|(
name|cl_options
index|[
name|i
index|]
operator|.
name|opt_text
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|duplicates
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl_options_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cl_options
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|filter
operator|)
operator|!=
name|flag
condition|)
continue|continue;
comment|/* Skip help for internal switches.  */
if|if
condition|(
name|cl_options
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CL_UNDOCUMENTED
condition|)
continue|continue;
comment|/* Skip switches that have already been printed.  */
if|if
condition|(
name|printed
index|[
name|i
index|]
condition|)
continue|continue;
name|printed
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
name|help
operator|=
name|cl_options
index|[
name|i
index|]
operator|.
name|help
expr_stmt|;
if|if
condition|(
operator|!
name|help
condition|)
name|help
operator|=
name|undocumented_msg
expr_stmt|;
comment|/* Get the translation.  */
name|help
operator|=
name|_
argument_list|(
name|help
argument_list|)
expr_stmt|;
name|tab
operator|=
name|strchr
argument_list|(
name|help
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
condition|)
block|{
name|len
operator|=
name|tab
operator|-
name|help
expr_stmt|;
name|opt
operator|=
name|help
expr_stmt|;
name|help
operator|=
name|tab
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|opt
operator|=
name|cl_options
index|[
name|i
index|]
operator|.
name|opt_text
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
name|wrap_help
argument_list|(
name|help
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output ITEM, of length ITEM_WIDTH, in the left column, followed by    word-wrapped HELP in a second column.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|print_switch
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|unsigned
name|int
name|indent
parameter_list|)
block|{
name|unsigned
name|int
name|len
init|=
name|strlen
argument_list|(
name|text
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* trailing comma */
if|if
condition|(
name|indent
condition|)
block|{
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
operator|+
name|len
operator|>
name|columns
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|indent
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|text
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
name|indent
operator|+
name|len
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Output ITEM, of length ITEM_WIDTH, in the left column, followed by    word-wrapped HELP in a second column.  */
end_comment

begin_function
specifier|static
name|void
name|wrap_help
parameter_list|(
specifier|const
name|char
modifier|*
name|help
parameter_list|,
specifier|const
name|char
modifier|*
name|item
parameter_list|,
name|unsigned
name|int
name|item_width
parameter_list|)
block|{
name|unsigned
name|int
name|col_width
init|=
literal|27
decl_stmt|;
name|unsigned
name|int
name|remaining
decl_stmt|,
name|room
decl_stmt|,
name|len
decl_stmt|;
name|remaining
operator|=
name|strlen
argument_list|(
name|help
argument_list|)
expr_stmt|;
do|do
block|{
name|room
operator|=
name|columns
operator|-
literal|3
operator|-
name|MAX
argument_list|(
name|col_width
argument_list|,
name|item_width
argument_list|)
expr_stmt|;
if|if
condition|(
name|room
operator|>
name|columns
condition|)
name|room
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|remaining
expr_stmt|;
if|if
condition|(
name|room
operator|<
name|len
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|help
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|room
operator|&&
name|len
operator|!=
name|remaining
condition|)
break|break;
if|if
condition|(
name|help
index|[
name|i
index|]
operator|==
literal|' '
condition|)
name|len
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|help
index|[
name|i
index|]
operator|==
literal|'-'
operator|||
name|help
index|[
name|i
index|]
operator|==
literal|'/'
operator|)
operator|&&
name|help
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|i
operator|>
literal|0
operator|&&
name|ISALPHA
argument_list|(
name|help
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"  %-*.*s %.*s\n"
argument_list|,
name|col_width
argument_list|,
name|item_width
argument_list|,
name|item
argument_list|,
name|len
argument_list|,
name|help
argument_list|)
expr_stmt|;
name|item_width
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|help
index|[
name|len
index|]
operator|==
literal|' '
condition|)
name|len
operator|++
expr_stmt|;
name|help
operator|+=
name|len
expr_stmt|;
name|remaining
operator|-=
name|len
expr_stmt|;
block|}
do|while
condition|(
name|remaining
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Return 1 if OPTION is enabled, 0 if it is disabled, or -1 if it isn't    a simple on-off switch.  */
end_comment

begin_function
name|int
name|option_enabled
parameter_list|(
name|int
name|opt_idx
parameter_list|)
block|{
specifier|const
name|struct
name|cl_option
modifier|*
name|option
init|=
operator|&
operator|(
name|cl_options
index|[
name|opt_idx
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|option
operator|->
name|flag_var
condition|)
switch|switch
condition|(
name|option
operator|->
name|var_type
condition|)
block|{
case|case
name|CLVC_BOOLEAN
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|option
operator|->
name|flag_var
operator|!=
literal|0
return|;
case|case
name|CLVC_EQUAL
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|option
operator|->
name|flag_var
operator|==
name|option
operator|->
name|var_value
return|;
case|case
name|CLVC_BIT_CLEAR
case|:
return|return
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|option
operator|->
name|flag_var
operator|&
name|option
operator|->
name|var_value
operator|)
operator|==
literal|0
return|;
case|case
name|CLVC_BIT_SET
case|:
return|return
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|option
operator|->
name|flag_var
operator|&
name|option
operator|->
name|var_value
operator|)
operator|!=
literal|0
return|;
case|case
name|CLVC_STRING
case|:
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill STATE with the current state of option OPTION.  Return true if    there is some state to store.  */
end_comment

begin_function
name|bool
name|get_option_state
parameter_list|(
name|int
name|option
parameter_list|,
name|struct
name|cl_option_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|cl_options
index|[
name|option
index|]
operator|.
name|flag_var
operator|==
literal|0
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|cl_options
index|[
name|option
index|]
operator|.
name|var_type
condition|)
block|{
case|case
name|CLVC_BOOLEAN
case|:
case|case
name|CLVC_EQUAL
case|:
name|state
operator|->
name|data
operator|=
name|cl_options
index|[
name|option
index|]
operator|.
name|flag_var
expr_stmt|;
name|state
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLVC_BIT_CLEAR
case|:
case|case
name|CLVC_BIT_SET
case|:
name|state
operator|->
name|ch
operator|=
name|option_enabled
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|state
operator|->
name|data
operator|=
operator|&
name|state
operator|->
name|ch
expr_stmt|;
name|state
operator|->
name|size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CLVC_STRING
case|:
name|state
operator|->
name|data
operator|=
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|cl_options
index|[
name|option
index|]
operator|.
name|flag_var
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|data
operator|==
literal|0
condition|)
name|state
operator|->
name|data
operator|=
literal|""
expr_stmt|;
name|state
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|state
operator|->
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

end_unit

