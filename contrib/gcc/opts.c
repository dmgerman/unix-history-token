begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Command line option handling.    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Neil Booth.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* For OPTIMIZATION_OPTIONS.  */
end_comment

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* For INSN_SCHEDULING.  */
end_comment

begin_comment
comment|/* Value of the -G xx switch, and whether it was passed or not.  */
end_comment

begin_decl_stmt
name|unsigned
name|HOST_WIDE_INT
name|g_switch_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|g_switch_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we should exit after parsing options.  */
end_comment

begin_decl_stmt
name|bool
name|exit_after_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If -version.  */
end_comment

begin_decl_stmt
name|bool
name|version_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print various extra warnings.  -W/-Wextra.  */
end_comment

begin_decl_stmt
name|bool
name|extra_warnings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't print warning messages.  -w.  */
end_comment

begin_decl_stmt
name|bool
name|inhibit_warnings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Treat warnings as errors.  -Werror.  */
end_comment

begin_decl_stmt
name|bool
name|warnings_are_errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a function returns an aggregate, since there are often    incompatible calling conventions for doing this.  */
end_comment

begin_decl_stmt
name|bool
name|warn_aggregate_return
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about pointer casts that increase the required    alignment of the target type (and might therefore lead to a crash    due to a misaligned access).  */
end_comment

begin_decl_stmt
name|bool
name|warn_cast_align
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about uses of __attribute__((deprecated))    declarations.  */
end_comment

begin_decl_stmt
name|bool
name|warn_deprecated_decl
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn when an optimization pass is disabled.  */
end_comment

begin_decl_stmt
name|bool
name|warn_disabled_optimization
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if inline function is too large.  */
end_comment

begin_decl_stmt
name|bool
name|warn_inline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True to warn about any objects definitions whose size is larger    than N bytes.  Also want about function definitions whose returned    values are larger than N bytes, where N is `larger_than_size'.  */
end_comment

begin_decl_stmt
name|bool
name|warn_larger_than
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|larger_than_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about functions which might be candidates for attribute noreturn.  */
end_comment

begin_decl_stmt
name|bool
name|warn_missing_noreturn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True to warn about code which is never reached.  */
end_comment

begin_decl_stmt
name|bool
name|warn_notreached
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if packed attribute on struct is unnecessary and inefficient.  */
end_comment

begin_decl_stmt
name|bool
name|warn_packed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn when gcc pads a structure to an alignment boundary.  */
end_comment

begin_decl_stmt
name|bool
name|warn_padded
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True means warn about all declarations which shadow others.  */
end_comment

begin_decl_stmt
name|bool
name|warn_shadow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about constructs which might not be    strict-aliasing safe.  */
end_comment

begin_decl_stmt
name|bool
name|warn_strict_aliasing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True to warn if a switch on an enum, that does not have a default    case, fails to have a case for every enum value.  */
end_comment

begin_decl_stmt
name|bool
name|warn_switch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a switch does not have a default case.  */
end_comment

begin_decl_stmt
name|bool
name|warn_switch_default
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a switch on an enum fails to have a case for every enum    value (regardless of the presence or otherwise of a default case).  */
end_comment

begin_decl_stmt
name|bool
name|warn_switch_enum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't suppress warnings from system headers.  -Wsystem-headers.  */
end_comment

begin_decl_stmt
name|bool
name|warn_system_headers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True to warn about variables used before they are initialized.  */
end_comment

begin_decl_stmt
name|int
name|warn_uninitialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True to warn about unused variables, functions et.al.  */
end_comment

begin_decl_stmt
name|bool
name|warn_unused_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|warn_unused_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|warn_unused_parameter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|warn_unused_variable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|warn_unused_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hack for cooperation between set_Wunused and set_Wextra.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|maybe_warn_unused_parameter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type(s) of debugging information we are producing (if any).  See    flags.h for the definitions of the different possible types of    debugging information.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_type
name|write_symbols
init|=
name|NO_DEBUG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level of debugging information we are producing.  See flags.h for    the definitions of the different possible levels.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_level
name|debug_info_level
init|=
name|DINFO_LEVEL_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use GNU-only extensions in the generated symbolic    debugging information.  Currently, this only has an effect when    write_symbols is set to DBX_DEBUG, XCOFF_DEBUG, or DWARF_DEBUG.  */
end_comment

begin_decl_stmt
name|bool
name|use_gnu_debug_info_extensions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Columns of --help display.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|columns
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What to print when a switch has no documentation.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|undocumented_msg
index|[]
init|=
name|N_
argument_list|(
literal|"This switch lacks documentation"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for bookkeeping on whether user set these flags so    -fprofile-use/-fprofile-generate does not use them.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|profile_arc_flag_set
decl_stmt|,
name|flag_profile_values_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|flag_unroll_loops_set
decl_stmt|,
name|flag_tracer_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|flag_value_profile_transformations_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|flag_peel_loops_set
decl_stmt|,
name|flag_branch_probabilities_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input file names.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
modifier|*
name|in_fnames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|num_in_fnames
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|size_t
name|find_opt
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|common_handle_option
parameter_list|(
name|size_t
name|scode
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_param
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_Wextra
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|handle_option
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|write_langs
parameter_list|(
name|unsigned
name|int
name|lang_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|complain_wrong_lang
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|cl_option
modifier|*
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_options
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wrap_help
parameter_list|(
specifier|const
name|char
modifier|*
name|help
parameter_list|,
specifier|const
name|char
modifier|*
name|item
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_param_help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_filtered_help
parameter_list|(
name|unsigned
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|print_switch
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|unsigned
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_debug_level
parameter_list|(
name|enum
name|debug_info_type
name|type
parameter_list|,
name|int
name|extended
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Perform a binary search to find which option the command-line INPUT    matches.  Returns its index in the option array, and N_OPTS    (cl_options_count) on failure.     This routine is quite subtle.  A normal binary search is not good    enough because some options can be suffixed with an argument, and    multiple sub-matches can occur, e.g. input of "-pedantic" matching    the initial substring of "-pedantic-errors".     A more complicated example is -gstabs.  It should match "-g" with    an argument of "stabs".  Suppose, however, that the number and list    of switches are such that the binary search tests "-gen-decls"    before having tested "-g".  This doesn't match, and as "-gen-decls"    is less than "-gstabs", it will become the lower bound of the    binary search range, and "-g" will never be seen.  To resolve this    issue, opts.sh makes "-gen-decls" point, via the back_chain member,    to "-g" so that failed searches that end between "-gen-decls" and    the lexicographically subsequent switch know to go back and see if    "-g" causes a match (which it does in this example).     This search is done in such a way that the longest match for the    front end in question wins.  If there is no match for the current    front end, the longest match for a different front end is returned    (or N_OPTS if none) and the caller emits an error message.  */
end_comment

begin_function
specifier|static
name|size_t
name|find_opt
parameter_list|(
specifier|const
name|char
modifier|*
name|input
parameter_list|,
name|int
name|lang_mask
parameter_list|)
block|{
name|size_t
name|mn
decl_stmt|,
name|mx
decl_stmt|,
name|md
decl_stmt|,
name|opt_len
decl_stmt|;
name|size_t
name|match_wrong_lang
decl_stmt|;
name|int
name|comp
decl_stmt|;
name|mn
operator|=
literal|0
expr_stmt|;
name|mx
operator|=
name|cl_options_count
expr_stmt|;
comment|/* Find mn such this lexicographical inequality holds:      cl_options[mn]<= input< cl_options[mn + 1].  */
while|while
condition|(
name|mx
operator|-
name|mn
operator|>
literal|1
condition|)
block|{
name|md
operator|=
operator|(
name|mn
operator|+
name|mx
operator|)
operator|/
literal|2
expr_stmt|;
name|opt_len
operator|=
name|cl_options
index|[
name|md
index|]
operator|.
name|opt_len
expr_stmt|;
name|comp
operator|=
name|strncmp
argument_list|(
name|input
argument_list|,
name|cl_options
index|[
name|md
index|]
operator|.
name|opt_text
operator|+
literal|1
argument_list|,
name|opt_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|<
literal|0
condition|)
name|mx
operator|=
name|md
expr_stmt|;
else|else
name|mn
operator|=
name|md
expr_stmt|;
block|}
comment|/* This is the switch that is the best match but for a different      front end, or cl_options_count if there is no match at all.  */
name|match_wrong_lang
operator|=
name|cl_options_count
expr_stmt|;
comment|/* Backtrace the chain of possible matches, returning the longest      one, if any, that fits best.  With current GCC switches, this      loop executes at most twice.  */
do|do
block|{
specifier|const
name|struct
name|cl_option
modifier|*
name|opt
init|=
operator|&
name|cl_options
index|[
name|mn
index|]
decl_stmt|;
comment|/* Is this switch a prefix of the input?  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|input
argument_list|,
name|opt
operator|->
name|opt_text
operator|+
literal|1
argument_list|,
name|opt
operator|->
name|opt_len
argument_list|)
condition|)
block|{
comment|/* If language is OK, and the match is exact or the switch 	     takes a joined argument, return it.  */
if|if
condition|(
operator|(
name|opt
operator|->
name|flags
operator|&
name|lang_mask
operator|)
operator|&&
operator|(
name|input
index|[
name|opt
operator|->
name|opt_len
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|opt
operator|->
name|flags
operator|&
name|CL_JOINED
operator|)
operator|)
condition|)
return|return
name|mn
return|;
comment|/* If we haven't remembered a prior match, remember this 	     one.  Any prior match is necessarily better.  */
if|if
condition|(
name|match_wrong_lang
operator|==
name|cl_options_count
condition|)
name|match_wrong_lang
operator|=
name|mn
expr_stmt|;
block|}
comment|/* Try the next possibility.  This is cl_options_count if there 	 are no more.  */
name|mn
operator|=
name|opt
operator|->
name|back_chain
expr_stmt|;
block|}
do|while
condition|(
name|mn
operator|!=
name|cl_options_count
condition|)
do|;
comment|/* Return the best wrong match, or cl_options_count if none.  */
return|return
name|match_wrong_lang
return|;
block|}
end_function

begin_comment
comment|/* If ARG is a non-negative integer made up solely of digits, return its    value, otherwise return -1.  */
end_comment

begin_function
specifier|static
name|int
name|integral_argument
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|arg
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|atoi
argument_list|(
name|arg
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a malloced slash-separated list of languages in MASK.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|write_langs
parameter_list|(
name|unsigned
name|int
name|mask
parameter_list|)
block|{
name|unsigned
name|int
name|n
init|=
literal|0
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|lang_name
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|lang_name
operator|=
name|lang_names
index|[
name|n
index|]
operator|)
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1U
operator|<<
name|n
operator|)
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|lang_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|lang_name
operator|=
name|lang_names
index|[
name|n
index|]
operator|)
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1U
operator|<<
name|n
operator|)
condition|)
block|{
if|if
condition|(
name|len
condition|)
name|result
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len
argument_list|,
name|lang_name
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|lang_name
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Complain that switch OPT_INDEX does not apply to this front end.  */
end_comment

begin_function
specifier|static
name|void
name|complain_wrong_lang
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
specifier|const
name|struct
name|cl_option
modifier|*
name|option
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
block|{
name|char
modifier|*
name|ok_langs
decl_stmt|,
modifier|*
name|bad_lang
decl_stmt|;
name|ok_langs
operator|=
name|write_langs
argument_list|(
name|option
operator|->
name|flags
argument_list|)
expr_stmt|;
name|bad_lang
operator|=
name|write_langs
argument_list|(
name|lang_mask
argument_list|)
expr_stmt|;
comment|/* Eventually this should become a hard error IMO.  */
name|warning
argument_list|(
literal|"command line option \"%s\" is valid for %s but not for %s"
argument_list|,
name|text
argument_list|,
name|ok_langs
argument_list|,
name|bad_lang
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ok_langs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bad_lang
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the switch beginning at ARGV for the language indicated by    LANG_MASK.  Returns the number of switches consumed.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|handle_option
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
block|{
name|size_t
name|opt_index
decl_stmt|;
specifier|const
name|char
modifier|*
name|opt
decl_stmt|,
modifier|*
name|arg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|dup
init|=
literal|0
decl_stmt|;
name|int
name|value
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|result
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|cl_option
modifier|*
name|option
decl_stmt|;
name|opt
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Drop the "no-" from negative switches.  */
if|if
condition|(
operator|(
name|opt
index|[
literal|1
index|]
operator|==
literal|'W'
operator|||
name|opt
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
operator|&&
name|opt
index|[
literal|2
index|]
operator|==
literal|'n'
operator|&&
name|opt
index|[
literal|3
index|]
operator|==
literal|'o'
operator|&&
name|opt
index|[
literal|4
index|]
operator|==
literal|'-'
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|opt
argument_list|)
operator|-
literal|3
decl_stmt|;
name|dup
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dup
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|dup
index|[
literal|1
index|]
operator|=
name|opt
index|[
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|dup
operator|+
literal|2
argument_list|,
name|opt
operator|+
literal|5
argument_list|,
name|len
operator|-
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|opt
operator|=
name|dup
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|opt_index
operator|=
name|find_opt
argument_list|(
name|opt
operator|+
literal|1
argument_list|,
name|lang_mask
operator||
name|CL_COMMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_index
operator|==
name|cl_options_count
condition|)
goto|goto
name|done
goto|;
name|option
operator|=
operator|&
name|cl_options
index|[
name|opt_index
index|]
expr_stmt|;
comment|/* Reject negative form of switches that don't take negatives as      unrecognized.  */
if|if
condition|(
operator|!
name|value
operator|&&
operator|(
name|option
operator|->
name|flags
operator|&
name|CL_REJECT_NEGATIVE
operator|)
condition|)
goto|goto
name|done
goto|;
comment|/* We've recognized this switch.  */
name|result
operator|=
literal|1
expr_stmt|;
comment|/* Sort out any argument the switch takes.  */
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|CL_JOINED
condition|)
block|{
comment|/* Have arg point to the original switch.  This is because 	 some code, such as disable_builtin_function, expects its 	 argument to be persistent until the program exits.  */
name|arg
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|cl_options
index|[
name|opt_index
index|]
operator|.
name|opt_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
name|arg
operator|+=
name|strlen
argument_list|(
literal|"no-"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'\0'
operator|&&
operator|!
operator|(
name|option
operator|->
name|flags
operator|&
name|CL_MISSING_OK
operator|)
condition|)
block|{
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|CL_SEPARATE
condition|)
block|{
name|arg
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|result
operator|=
literal|2
expr_stmt|;
block|}
else|else
comment|/* Missing argument.  */
name|arg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|CL_SEPARATE
condition|)
block|{
name|arg
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|result
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Now we've swallowed any potential argument, complain if this      is a switch for a different front end.  */
if|if
condition|(
operator|!
operator|(
name|option
operator|->
name|flags
operator|&
operator|(
name|lang_mask
operator||
name|CL_COMMON
operator|)
operator|)
condition|)
block|{
name|complain_wrong_lang
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|option
argument_list|,
name|lang_mask
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|arg
operator|==
name|NULL
operator|&&
operator|(
name|option
operator|->
name|flags
operator|&
operator|(
name|CL_JOINED
operator||
name|CL_SEPARATE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|lang_hooks
operator|.
name|missing_argument
call|)
argument_list|(
name|opt
argument_list|,
name|opt_index
argument_list|)
condition|)
name|error
argument_list|(
literal|"missing argument to \"%s\""
argument_list|,
name|opt
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* If the switch takes an integer, convert it.  */
if|if
condition|(
name|arg
operator|&&
operator|(
name|option
operator|->
name|flags
operator|&
name|CL_UINTEGER
operator|)
condition|)
block|{
name|value
operator|=
name|integral_argument
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"argument to \"%s\" should be a non-negative integer"
argument_list|,
name|option
operator|->
name|opt_text
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|lang_mask
condition|)
if|if
condition|(
call|(
modifier|*
name|lang_hooks
operator|.
name|handle_option
call|)
argument_list|(
name|opt_index
argument_list|,
name|arg
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|&&
operator|(
name|option
operator|->
name|flags
operator|&
name|CL_COMMON
operator|)
condition|)
if|if
condition|(
name|common_handle_option
argument_list|(
name|opt_index
argument_list|,
name|arg
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
name|done
label|:
if|if
condition|(
name|dup
condition|)
name|free
argument_list|(
name|dup
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Decode and handle the vector of command line options.  LANG_MASK    contains has a single bit set representing the current    language.  */
end_comment

begin_function
specifier|static
name|void
name|handle_options
parameter_list|(
name|unsigned
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|unsigned
name|int
name|lang_mask
parameter_list|)
block|{
name|unsigned
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|+=
name|n
control|)
block|{
specifier|const
name|char
modifier|*
name|opt
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
comment|/* Interpret "-" or a non-switch as a file name.  */
if|if
condition|(
name|opt
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|opt
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|main_input_filename
operator|==
name|NULL
condition|)
name|main_input_filename
operator|=
name|opt
expr_stmt|;
name|add_input_filename
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|n
operator|=
name|handle_option
argument_list|(
name|argv
operator|+
name|i
argument_list|,
name|lang_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|n
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"unrecognized command line option \"%s\""
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle FILENAME from the command line.  */
end_comment

begin_function
name|void
name|add_input_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|num_in_fnames
operator|++
expr_stmt|;
name|in_fnames
operator|=
name|xrealloc
argument_list|(
name|in_fnames
argument_list|,
name|num_in_fnames
operator|*
sizeof|sizeof
argument_list|(
name|in_fnames
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|in_fnames
index|[
name|num_in_fnames
operator|-
literal|1
index|]
operator|=
name|filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse command line options and set default flag values.  Do minimal    options processing.  */
end_comment

begin_function
name|void
name|decode_options
parameter_list|(
name|unsigned
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|lang_mask
decl_stmt|;
comment|/* Perform language-specific options initialization.  */
name|lang_mask
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|init_options
call|)
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|initialize_diagnostics
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
comment|/* Scan to see what optimization level has been specified.  That will      determine the default value of many flags.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-O"
argument_list|)
condition|)
block|{
name|optimize
operator|=
literal|1
expr_stmt|;
name|optimize_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'O'
condition|)
block|{
comment|/* Handle -Os, -O2, -O3, -O69, ...  */
specifier|const
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|optimize_size
operator|=
literal|1
expr_stmt|;
comment|/* Optimizing for size forces optimize to be 2.  */
name|optimize
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|optimize_val
init|=
name|read_integral_parameter
argument_list|(
name|p
argument_list|,
name|p
operator|-
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|optimize_val
operator|!=
operator|-
literal|1
condition|)
block|{
name|optimize
operator|=
name|optimize_val
expr_stmt|;
name|optimize_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|optimize
condition|)
block|{
name|flag_merge_constants
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>=
literal|1
condition|)
block|{
name|flag_defer_pop
operator|=
literal|1
expr_stmt|;
name|flag_thread_jumps
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
name|flag_delayed_branch
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CAN_DEBUG_WITHOUT_FP
name|flag_omit_frame_pointer
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|flag_guess_branch_prob
operator|=
literal|1
expr_stmt|;
name|flag_cprop_registers
operator|=
literal|1
expr_stmt|;
name|flag_loop_optimize
operator|=
literal|1
expr_stmt|;
name|flag_if_conversion
operator|=
literal|1
expr_stmt|;
name|flag_if_conversion2
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>=
literal|2
condition|)
block|{
name|flag_crossjumping
operator|=
literal|1
expr_stmt|;
name|flag_optimize_sibling_calls
operator|=
literal|1
expr_stmt|;
name|flag_cse_follow_jumps
operator|=
literal|1
expr_stmt|;
name|flag_cse_skip_blocks
operator|=
literal|1
expr_stmt|;
name|flag_gcse
operator|=
literal|1
expr_stmt|;
name|flag_expensive_optimizations
operator|=
literal|1
expr_stmt|;
name|flag_strength_reduce
operator|=
literal|1
expr_stmt|;
name|flag_rerun_cse_after_loop
operator|=
literal|1
expr_stmt|;
name|flag_rerun_loop_opt
operator|=
literal|1
expr_stmt|;
name|flag_caller_saves
operator|=
literal|1
expr_stmt|;
name|flag_force_mem
operator|=
literal|1
expr_stmt|;
name|flag_peephole2
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
name|flag_schedule_insns
operator|=
literal|1
expr_stmt|;
name|flag_schedule_insns_after_reload
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|flag_regmove
operator|=
literal|1
expr_stmt|;
name|flag_strict_aliasing
operator|=
literal|1
expr_stmt|;
name|flag_delete_null_pointer_checks
operator|=
literal|1
expr_stmt|;
name|flag_reorder_blocks
operator|=
literal|1
expr_stmt|;
name|flag_reorder_functions
operator|=
literal|1
expr_stmt|;
name|flag_unit_at_a_time
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>=
literal|3
condition|)
block|{
name|flag_inline_functions
operator|=
literal|1
expr_stmt|;
name|flag_rename_registers
operator|=
literal|1
expr_stmt|;
name|flag_unswitch_loops
operator|=
literal|1
expr_stmt|;
name|flag_web
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|<
literal|2
operator|||
name|optimize_size
condition|)
block|{
name|align_loops
operator|=
literal|1
expr_stmt|;
name|align_jumps
operator|=
literal|1
expr_stmt|;
name|align_labels
operator|=
literal|1
expr_stmt|;
name|align_functions
operator|=
literal|1
expr_stmt|;
comment|/* Don't reorder blocks when optimizing for size because extra 	 jump insns may be created; also barrier may create extra padding.  	 More correctly we should have a block reordering mode that tried 	 to minimize the combined size of all the jumps.  This would more 	 or less automatically remove extra jumps, but would also try to 	 use more short jumps instead of long jumps.  */
name|flag_reorder_blocks
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Initialize whether `char' is signed.  */
name|flag_signed_char
operator|=
name|DEFAULT_SIGNED_CHAR
expr_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_SHORT_ENUMS
comment|/* Initialize how much space enums occupy, by default.  */
name|flag_short_enums
operator|=
name|DEFAULT_SHORT_ENUMS
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize target_flags before OPTIMIZATION_OPTIONS so the latter can      modify it.  */
name|target_flags
operator|=
literal|0
expr_stmt|;
name|set_target_switch
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Unwind tables are always present in an ABI-conformant IA-64      object file, so the default should be ON.  */
ifdef|#
directive|ifdef
name|IA64_UNWIND_INFO
name|flag_unwind_tables
operator|=
name|IA64_UNWIND_INFO
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTIMIZATION_OPTIONS
comment|/* Allow default optimizations to be specified on a per-machine basis.  */
name|OPTIMIZATION_OPTIONS
argument_list|(
name|optimize
argument_list|,
name|optimize_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|handle_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|lang_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pie
condition|)
name|flag_pic
operator|=
name|flag_pie
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|flag_pie
condition|)
name|flag_shlib
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_no_inline
operator|==
literal|2
condition|)
name|flag_no_inline
operator|=
literal|0
expr_stmt|;
else|else
name|flag_really_no_inline
operator|=
name|flag_no_inline
expr_stmt|;
comment|/* Set flag_no_inline before the post_options () hook.  The C front      ends use it to determine tree inlining defaults.  FIXME: such      code should be lang-independent when all front ends use tree      inlining, in which case it, and this condition, should be moved      to the top of process_options() instead.  */
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
block|{
comment|/* Inlining does not work if not optimizing, 	 so force it not to be done.  */
name|flag_no_inline
operator|=
literal|1
expr_stmt|;
name|warn_inline
operator|=
literal|0
expr_stmt|;
comment|/* The c_decode_option function and decode_option hook set 	 this to `2' if -Wall is used, so we can avoid giving out 	 lots of errors for people who don't realize what -Wall does.  */
if|if
condition|(
name|warn_uninitialized
operator|==
literal|1
condition|)
name|warning
argument_list|(
literal|"-Wuninitialized is not supported without -O"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_really_no_inline
operator|==
literal|2
condition|)
name|flag_really_no_inline
operator|=
name|flag_no_inline
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle target- and language-independent options.  Return zero to    generate an "unknown option" message.  */
end_comment

begin_function
specifier|static
name|int
name|common_handle_option
parameter_list|(
name|size_t
name|scode
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|opt_code
name|code
init|=
operator|(
expr|enum
name|opt_code
operator|)
name|scode
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|OPT__help
case|:
name|print_help
argument_list|()
expr_stmt|;
name|exit_after_options
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT__param
case|:
name|handle_param
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT__target_help
case|:
name|display_target_options
argument_list|()
expr_stmt|;
name|exit_after_options
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT__version
case|:
name|print_version
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit_after_options
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_G
case|:
name|g_switch_value
operator|=
name|value
expr_stmt|;
name|g_switch_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_O
case|:
case|case
name|OPT_Os
case|:
comment|/* Currently handled in a prescan.  */
break|break;
case|case
name|OPT_W
case|:
comment|/* For backward compatibility, -W is the same as -Wextra.  */
name|set_Wextra
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_Waggregate_return
case|:
name|warn_aggregate_return
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wcast_align
case|:
name|warn_cast_align
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wdeprecated_declarations
case|:
name|warn_deprecated_decl
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wdisabled_optimization
case|:
name|warn_disabled_optimization
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Werror
case|:
name|warnings_are_errors
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wextra
case|:
name|set_Wextra
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_Winline
case|:
name|warn_inline
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wlarger_than_
case|:
name|larger_than_size
operator|=
name|value
expr_stmt|;
name|warn_larger_than
operator|=
name|value
operator|!=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_Wmissing_noreturn
case|:
name|warn_missing_noreturn
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wpacked
case|:
name|warn_packed
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wpadded
case|:
name|warn_padded
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wshadow
case|:
name|warn_shadow
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wstrict_aliasing
case|:
name|warn_strict_aliasing
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wswitch
case|:
name|warn_switch
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wswitch_default
case|:
name|warn_switch_default
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wswitch_enum
case|:
name|warn_switch_enum
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wsystem_headers
case|:
name|warn_system_headers
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wuninitialized
case|:
name|warn_uninitialized
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wunreachable_code
case|:
name|warn_notreached
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wunused
case|:
name|set_Wunused
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_Wunused_function
case|:
name|warn_unused_function
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wunused_label
case|:
name|warn_unused_label
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wunused_parameter
case|:
name|warn_unused_parameter
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wunused_value
case|:
name|warn_unused_value
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wunused_variable
case|:
name|warn_unused_variable
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_aux_info
case|:
case|case
name|OPT_aux_info_
case|:
name|aux_info_file_name
operator|=
name|arg
expr_stmt|;
name|flag_gen_aux_info
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_auxbase
case|:
name|aux_base_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_auxbase_strip
case|:
block|{
name|char
modifier|*
name|tmp
init|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|strip_off_ending
argument_list|(
name|tmp
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
condition|)
name|aux_base_name
operator|=
name|tmp
expr_stmt|;
block|}
break|break;
case|case
name|OPT_d
case|:
name|decode_d_option
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_dumpbase
case|:
name|dump_base_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_fPIC
case|:
name|flag_pic
operator|=
name|value
operator|+
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fPIE
case|:
name|flag_pie
operator|=
name|value
operator|+
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fabi_version_
case|:
name|flag_abi_version
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_falign_functions
case|:
name|align_functions
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_falign_functions_
case|:
name|align_functions
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_falign_jumps
case|:
name|align_jumps
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_falign_jumps_
case|:
name|align_jumps
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_falign_labels
case|:
name|align_labels
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_falign_labels_
case|:
name|align_labels
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_falign_loops
case|:
name|align_loops
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_falign_loops_
case|:
name|align_loops
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fargument_alias
case|:
name|flag_argument_noalias
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fargument_noalias
case|:
name|flag_argument_noalias
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fargument_noalias_global
case|:
name|flag_argument_noalias
operator|=
name|value
operator|+
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fasynchronous_unwind_tables
case|:
name|flag_asynchronous_unwind_tables
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fbounds_check
case|:
name|flag_bounds_check
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fbranch_count_reg
case|:
name|flag_branch_on_count_reg
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fbranch_probabilities
case|:
name|flag_branch_probabilities_set
operator|=
name|true
expr_stmt|;
name|flag_branch_probabilities
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fbranch_target_load_optimize
case|:
name|flag_branch_target_load_optimize
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fbranch_target_load_optimize2
case|:
name|flag_branch_target_load_optimize2
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fcall_used_
case|:
name|fix_register
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_fcall_saved_
case|:
name|fix_register
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_fcaller_saves
case|:
name|flag_caller_saves
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fcommon
case|:
name|flag_no_common
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fcprop_registers
case|:
name|flag_cprop_registers
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fcrossjumping
case|:
name|flag_crossjumping
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fcse_follow_jumps
case|:
name|flag_cse_follow_jumps
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fcse_skip_blocks
case|:
name|flag_cse_skip_blocks
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fdata_sections
case|:
name|flag_data_sections
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fdefer_pop
case|:
name|flag_defer_pop
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fdelayed_branch
case|:
name|flag_delayed_branch
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fdelete_null_pointer_checks
case|:
name|flag_delete_null_pointer_checks
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fdiagnostics_show_location_
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"once"
argument_list|)
condition|)
name|diagnostic_prefixing_rule
argument_list|(
name|global_dc
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"every-line"
argument_list|)
condition|)
name|diagnostic_prefixing_rule
argument_list|(
name|global_dc
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|OPT_fdump_unnumbered
case|:
name|flag_dump_unnumbered
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_feliminate_dwarf2_dups
case|:
name|flag_eliminate_dwarf2_dups
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_feliminate_unused_debug_types
case|:
name|flag_eliminate_unused_debug_types
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_feliminate_unused_debug_symbols
case|:
name|flag_debug_only_used_symbols
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fexceptions
case|:
name|flag_exceptions
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fexpensive_optimizations
case|:
name|flag_expensive_optimizations
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ffast_math
case|:
name|set_fast_math_flags
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ffinite_math_only
case|:
name|flag_finite_math_only
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ffixed_
case|:
name|fix_register
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ffunction_cse
case|:
name|flag_no_function_cse
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ffloat_store
case|:
name|flag_float_store
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fforce_addr
case|:
name|flag_force_addr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fforce_mem
case|:
name|flag_force_mem
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ffunction_sections
case|:
name|flag_function_sections
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fgcse
case|:
name|flag_gcse
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fgcse_lm
case|:
name|flag_gcse_lm
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fgcse_sm
case|:
name|flag_gcse_sm
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fgcse_las
case|:
name|flag_gcse_las
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fguess_branch_probability
case|:
name|flag_guess_branch_prob
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fident
case|:
name|flag_no_ident
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fif_conversion
case|:
name|flag_if_conversion
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fif_conversion2
case|:
name|flag_if_conversion2
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_finhibit_size_directive
case|:
name|flag_inhibit_size_directive
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_finline
case|:
name|flag_no_inline
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_finline_functions
case|:
name|flag_inline_functions
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_finline_limit_
case|:
case|case
name|OPT_finline_limit_eq
case|:
name|set_param_value
argument_list|(
literal|"max-inline-insns-single"
argument_list|,
name|value
operator|/
literal|2
argument_list|)
expr_stmt|;
name|set_param_value
argument_list|(
literal|"max-inline-insns-auto"
argument_list|,
name|value
operator|/
literal|2
argument_list|)
expr_stmt|;
name|set_param_value
argument_list|(
literal|"max-inline-insns-rtl"
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_finstrument_functions
case|:
name|flag_instrument_function_entry_exit
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fkeep_inline_functions
case|:
name|flag_keep_inline_functions
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fkeep_static_consts
case|:
name|flag_keep_static_consts
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fleading_underscore
case|:
name|flag_leading_underscore
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_floop_optimize
case|:
name|flag_loop_optimize
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fmath_errno
case|:
name|flag_errno_math
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fmem_report
case|:
name|mem_report
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fmerge_all_constants
case|:
name|flag_merge_constants
operator|=
name|value
operator|+
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fmerge_constants
case|:
name|flag_merge_constants
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fmessage_length_
case|:
name|pp_set_line_maximum_length
argument_list|(
name|global_dc
operator|->
name|printer
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_fmove_all_movables
case|:
name|flag_move_all_movables
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fnew_ra
case|:
name|flag_new_regalloc
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fnon_call_exceptions
case|:
name|flag_non_call_exceptions
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fold_unroll_all_loops
case|:
name|flag_old_unroll_all_loops
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fold_unroll_loops
case|:
name|flag_old_unroll_loops
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fomit_frame_pointer
case|:
name|flag_omit_frame_pointer
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_foptimize_register_move
case|:
name|flag_regmove
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_foptimize_sibling_calls
case|:
name|flag_optimize_sibling_calls
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fpack_struct
case|:
name|flag_pack_struct
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fpeel_loops
case|:
name|flag_peel_loops_set
operator|=
name|true
expr_stmt|;
name|flag_peel_loops
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fpcc_struct_return
case|:
name|flag_pcc_struct_return
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fpeephole
case|:
name|flag_no_peephole
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fpeephole2
case|:
name|flag_peephole2
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fpic
case|:
name|flag_pic
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fpie
case|:
name|flag_pie
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fprefetch_loop_arrays
case|:
name|flag_prefetch_loop_arrays
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fprofile
case|:
name|profile_flag
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fprofile_arcs
case|:
name|profile_arc_flag_set
operator|=
name|true
expr_stmt|;
name|profile_arc_flag
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fprofile_use
case|:
if|if
condition|(
operator|!
name|flag_branch_probabilities_set
condition|)
name|flag_branch_probabilities
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_profile_values_set
condition|)
name|flag_profile_values
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_unroll_loops_set
condition|)
name|flag_unroll_loops
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_peel_loops_set
condition|)
name|flag_peel_loops
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_tracer_set
condition|)
name|flag_tracer
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_value_profile_transformations_set
condition|)
name|flag_value_profile_transformations
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fprofile_generate
case|:
if|if
condition|(
operator|!
name|profile_arc_flag_set
condition|)
name|profile_arc_flag
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_profile_values_set
condition|)
name|flag_profile_values
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|flag_value_profile_transformations_set
condition|)
name|flag_value_profile_transformations
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fprofile_values
case|:
name|flag_profile_values_set
operator|=
name|true
expr_stmt|;
name|flag_profile_values
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fvpt
case|:
name|flag_value_profile_transformations_set
operator|=
name|value
expr_stmt|;
name|flag_value_profile_transformations
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_frandom_seed
case|:
comment|/* The real switch is -fno-random-seed.  */
if|if
condition|(
name|value
condition|)
return|return
literal|0
return|;
name|flag_random_seed
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPT_frandom_seed_
case|:
name|flag_random_seed
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_freduce_all_givs
case|:
name|flag_reduce_all_givs
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_freg_struct_return
case|:
name|flag_pcc_struct_return
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fregmove
case|:
name|flag_regmove
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_frename_registers
case|:
name|flag_rename_registers
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_freorder_blocks
case|:
name|flag_reorder_blocks
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_freorder_functions
case|:
name|flag_reorder_functions
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_frerun_cse_after_loop
case|:
name|flag_rerun_cse_after_loop
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_frerun_loop_opt
case|:
name|flag_rerun_loop_opt
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_frounding_math
case|:
name|flag_rounding_math
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsched_interblock
case|:
name|flag_schedule_interblock
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsched_spec
case|:
name|flag_schedule_speculative
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsched_spec_load
case|:
name|flag_schedule_speculative_load
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsched_spec_load_dangerous
case|:
name|flag_schedule_speculative_load_dangerous
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsched_verbose_
case|:
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
name|fix_sched_param
argument_list|(
literal|"verbose"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
case|case
name|OPT_fsched2_use_superblocks
case|:
name|flag_sched2_use_superblocks
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsched2_use_traces
case|:
name|flag_sched2_use_traces
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fschedule_insns
case|:
name|flag_schedule_insns
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fschedule_insns2
case|:
name|flag_schedule_insns_after_reload
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsched_stalled_insns
case|:
name|flag_sched_stalled_insns
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsched_stalled_insns_
case|:
name|flag_sched_stalled_insns
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|flag_sched_stalled_insns
operator|==
literal|0
condition|)
name|flag_sched_stalled_insns
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_fsched_stalled_insns_dep
case|:
name|flag_sched_stalled_insns_dep
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_fsched_stalled_insns_dep_
case|:
name|flag_sched_stalled_insns_dep
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fshared_data
case|:
name|flag_shared_data
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsignaling_nans
case|:
name|flag_signaling_nans
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsingle_precision_constant
case|:
name|flag_single_precision_constant
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fstack_check
case|:
name|flag_stack_check
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fstack_limit
case|:
comment|/* The real switch is -fno-stack-limit.  */
if|if
condition|(
name|value
condition|)
return|return
literal|0
return|;
name|stack_limit_rtx
operator|=
name|NULL_RTX
expr_stmt|;
break|break;
case|case
name|OPT_fstack_limit_register_
case|:
block|{
name|int
name|reg
init|=
name|decode_reg_name
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"unrecognized register name \"%s\""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|stack_limit_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPT_fstack_limit_symbol_
case|:
name|stack_limit_rtx
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_fstrength_reduce
case|:
name|flag_strength_reduce
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fstrict_aliasing
case|:
name|flag_strict_aliasing
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsyntax_only
case|:
name|flag_syntax_only
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ftest_coverage
case|:
name|flag_test_coverage
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fthread_jumps
case|:
name|flag_thread_jumps
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ftime_report
case|:
name|time_report
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ftls_model_
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"global-dynamic"
argument_list|)
condition|)
name|flag_tls_default
operator|=
name|TLS_MODEL_GLOBAL_DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"local-dynamic"
argument_list|)
condition|)
name|flag_tls_default
operator|=
name|TLS_MODEL_LOCAL_DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"initial-exec"
argument_list|)
condition|)
name|flag_tls_default
operator|=
name|TLS_MODEL_INITIAL_EXEC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"local-exec"
argument_list|)
condition|)
name|flag_tls_default
operator|=
name|TLS_MODEL_LOCAL_EXEC
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"unknown tls-model \"%s\""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ftracer
case|:
name|flag_tracer_set
operator|=
name|true
expr_stmt|;
name|flag_tracer
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ftrapping_math
case|:
name|flag_trapping_math
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ftrapv
case|:
name|flag_trapv
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_funit_at_a_time
case|:
name|flag_unit_at_a_time
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_funroll_all_loops
case|:
name|flag_unroll_all_loops
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_funroll_loops
case|:
name|flag_unroll_loops_set
operator|=
name|true
expr_stmt|;
name|flag_unroll_loops
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_funsafe_math_optimizations
case|:
name|flag_unsafe_math_optimizations
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_funswitch_loops
case|:
name|flag_unswitch_loops
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_funwind_tables
case|:
name|flag_unwind_tables
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fverbose_asm
case|:
name|flag_verbose_asm
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fweb
case|:
name|flag_web
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fwrapv
case|:
name|flag_wrapv
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fwritable_strings
case|:
name|flag_writable_strings
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|flag_writable_strings
condition|)
name|inform
argument_list|(
literal|"-fwritable-strings is deprecated; "
literal|"see documentation for details"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_fzero_initialized_in_bss
case|:
name|flag_zero_initialized_in_bss
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_g
case|:
name|set_debug_level
argument_list|(
name|NO_DEBUG
argument_list|,
name|DEFAULT_GDB_EXTENSIONS
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_gcoff
case|:
name|set_debug_level
argument_list|(
name|SDB_DEBUG
argument_list|,
name|false
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_gdwarf_2
case|:
name|set_debug_level
argument_list|(
name|DWARF2_DEBUG
argument_list|,
name|false
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ggdb
case|:
name|set_debug_level
argument_list|(
name|NO_DEBUG
argument_list|,
literal|2
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_gstabs
case|:
case|case
name|OPT_gstabs_
case|:
name|set_debug_level
argument_list|(
name|DBX_DEBUG
argument_list|,
name|code
operator|==
name|OPT_gstabs_
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_gvms
case|:
name|set_debug_level
argument_list|(
name|VMS_DEBUG
argument_list|,
name|false
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_gxcoff
case|:
case|case
name|OPT_gxcoff_
case|:
name|set_debug_level
argument_list|(
name|XCOFF_DEBUG
argument_list|,
name|code
operator|==
name|OPT_gxcoff_
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_m
case|:
name|set_target_switch
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_o
case|:
name|asm_file_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_p
case|:
name|profile_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_pedantic
case|:
name|pedantic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_pedantic_errors
case|:
name|flag_pedantic_errors
operator|=
name|pedantic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_quiet
case|:
name|quiet_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_version
case|:
name|version_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_w
case|:
name|inhibit_warnings
operator|=
name|true
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle --param NAME=VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|handle_param
parameter_list|(
specifier|const
name|char
modifier|*
name|carg
parameter_list|)
block|{
name|char
modifier|*
name|equal
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|int
name|value
decl_stmt|;
name|arg
operator|=
name|xstrdup
argument_list|(
name|carg
argument_list|)
expr_stmt|;
name|equal
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|equal
condition|)
name|error
argument_list|(
literal|"%s: --param arguments should be of the form NAME=VALUE"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
name|integral_argument
argument_list|(
name|equal
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"invalid --param value `%s'"
argument_list|,
name|equal
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|equal
operator|=
literal|'\0'
expr_stmt|;
name|set_param_value
argument_list|(
name|arg
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle -W and -Wextra.  */
end_comment

begin_function
specifier|static
name|void
name|set_Wextra
parameter_list|(
name|int
name|setting
parameter_list|)
block|{
name|extra_warnings
operator|=
name|setting
expr_stmt|;
name|warn_unused_value
operator|=
name|setting
expr_stmt|;
name|warn_unused_parameter
operator|=
operator|(
name|setting
operator|&&
name|maybe_warn_unused_parameter
operator|)
expr_stmt|;
comment|/* We save the value of warn_uninitialized, since if they put      -Wuninitialized on the command line, we need to generate a      warning about not using it without also specifying -O.  */
if|if
condition|(
name|setting
operator|==
literal|0
condition|)
name|warn_uninitialized
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_uninitialized
operator|!=
literal|1
condition|)
name|warn_uninitialized
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize unused warning flags.  */
end_comment

begin_function
name|void
name|set_Wunused
parameter_list|(
name|int
name|setting
parameter_list|)
block|{
name|warn_unused_function
operator|=
name|setting
expr_stmt|;
name|warn_unused_label
operator|=
name|setting
expr_stmt|;
comment|/* Unused function parameter warnings are reported when either      ``-Wextra -Wunused'' or ``-Wunused-parameter'' is specified.      Thus, if -Wextra has already been seen, set warn_unused_parameter;      otherwise set maybe_warn_extra_parameter, which will be picked up      by set_Wextra.  */
name|maybe_warn_unused_parameter
operator|=
name|setting
expr_stmt|;
name|warn_unused_parameter
operator|=
operator|(
name|setting
operator|&&
name|extra_warnings
operator|)
expr_stmt|;
name|warn_unused_variable
operator|=
name|setting
expr_stmt|;
name|warn_unused_value
operator|=
name|setting
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following routines are useful in setting all the flags that    -ffast-math and -fno-fast-math imply.  */
end_comment

begin_function
name|void
name|set_fast_math_flags
parameter_list|(
name|int
name|set
parameter_list|)
block|{
name|flag_trapping_math
operator|=
operator|!
name|set
expr_stmt|;
name|flag_unsafe_math_optimizations
operator|=
name|set
expr_stmt|;
name|flag_finite_math_only
operator|=
name|set
expr_stmt|;
name|flag_errno_math
operator|=
operator|!
name|set
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|flag_signaling_nans
operator|=
literal|0
expr_stmt|;
name|flag_rounding_math
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true iff flags are set as if -ffast-math.  */
end_comment

begin_function
name|bool
name|fast_math_flags_set_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|!
name|flag_trapping_math
operator|&&
name|flag_unsafe_math_optimizations
operator|&&
name|flag_finite_math_only
operator|&&
operator|!
name|flag_errno_math
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle a debug output -g switch.  EXTENDED is true or false to support    extended output (2 is special and means "-ggdb" was given).  */
end_comment

begin_function
specifier|static
name|void
name|set_debug_level
parameter_list|(
name|enum
name|debug_info_type
name|type
parameter_list|,
name|int
name|extended
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|bool
name|type_explicit
decl_stmt|;
name|use_gnu_debug_info_extensions
operator|=
name|extended
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NO_DEBUG
condition|)
block|{
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
block|{
name|write_symbols
operator|=
name|PREFERRED_DEBUGGING_TYPE
expr_stmt|;
if|if
condition|(
name|extended
operator|==
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
name|write_symbols
operator|=
name|DWARF2_DEBUG
expr_stmt|;
elif|#
directive|elif
name|defined
name|DBX_DEBUGGING_INFO
name|write_symbols
operator|=
name|DBX_DEBUG
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
name|warning
argument_list|(
literal|"target system does not support debug output"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Does it conflict with an already selected type?  */
if|if
condition|(
name|type_explicit
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|type
operator|!=
name|write_symbols
condition|)
name|error
argument_list|(
literal|"debug format \"%s\" conflicts with prior selection"
argument_list|,
name|debug_type_names
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|write_symbols
operator|=
name|type
expr_stmt|;
name|type_explicit
operator|=
name|true
expr_stmt|;
block|}
comment|/* A debug flag without a level defaults to level 2.  */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|debug_info_level
condition|)
name|debug_info_level
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|debug_info_level
operator|=
name|integral_argument
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"unrecognised debug output level \"%s\""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|debug_info_level
operator|>
literal|3
condition|)
name|error
argument_list|(
literal|"debug output level %s is too high"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output --help text.  */
end_comment

begin_function
specifier|static
name|void
name|print_help
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|GET_ENVIRONMENT
argument_list|(
name|p
argument_list|,
literal|"COLUMNS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|int
name|value
init|=
name|atoi
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|>
literal|0
condition|)
name|columns
operator|=
name|value
expr_stmt|;
block|}
name|puts
argument_list|(
name|_
argument_list|(
literal|"The following options are language-independent:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|print_filtered_help
argument_list|(
name|CL_COMMON
argument_list|)
expr_stmt|;
name|print_param_help
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lang_names
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"The %s front end recognizes the following options:\n\n"
argument_list|)
argument_list|,
name|lang_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|print_filtered_help
argument_list|(
literal|1U
operator|<<
name|i
argument_list|)
expr_stmt|;
block|}
name|display_target_options
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the help for --param.  */
end_comment

begin_function
specifier|static
name|void
name|print_param_help
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"The --param option recognizes the following as parameters:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LAST_PARAM
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|help
init|=
name|compiler_params
index|[
name|i
index|]
operator|.
name|help
decl_stmt|;
specifier|const
name|char
modifier|*
name|param
init|=
name|compiler_params
index|[
name|i
index|]
operator|.
name|option
decl_stmt|;
if|if
condition|(
name|help
operator|==
name|NULL
operator|||
operator|*
name|help
operator|==
literal|'\0'
condition|)
name|help
operator|=
name|undocumented_msg
expr_stmt|;
comment|/* Get the translation.  */
name|help
operator|=
name|_
argument_list|(
name|help
argument_list|)
expr_stmt|;
name|wrap_help
argument_list|(
name|help
argument_list|,
name|param
argument_list|,
name|strlen
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print help for a specific front-end, etc.  */
end_comment

begin_function
specifier|static
name|void
name|print_filtered_help
parameter_list|(
name|unsigned
name|int
name|flag
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|filter
decl_stmt|,
name|indent
init|=
literal|0
decl_stmt|;
name|bool
name|duplicates
init|=
name|false
decl_stmt|;
specifier|const
name|char
modifier|*
name|help
decl_stmt|,
modifier|*
name|opt
decl_stmt|,
modifier|*
name|tab
decl_stmt|;
specifier|static
name|char
modifier|*
name|printed
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|CL_COMMON
condition|)
block|{
name|filter
operator|=
name|flag
expr_stmt|;
if|if
condition|(
operator|!
name|printed
condition|)
name|printed
operator|=
name|xmalloc
argument_list|(
name|cl_options_count
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|printed
argument_list|,
literal|0
argument_list|,
name|cl_options_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't print COMMON options twice.  */
name|filter
operator|=
name|flag
operator||
name|CL_COMMON
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl_options_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cl_options
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|filter
operator|)
operator|!=
name|flag
condition|)
continue|continue;
comment|/* Skip help for internal switches.  */
if|if
condition|(
name|cl_options
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CL_UNDOCUMENTED
condition|)
continue|continue;
comment|/* Skip switches that have already been printed, mark them to be 	     listed later.  */
if|if
condition|(
name|printed
index|[
name|i
index|]
condition|)
block|{
name|duplicates
operator|=
name|true
expr_stmt|;
name|indent
operator|=
name|print_switch
argument_list|(
name|cl_options
index|[
name|i
index|]
operator|.
name|opt_text
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|duplicates
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl_options_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cl_options
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|filter
operator|)
operator|!=
name|flag
condition|)
continue|continue;
comment|/* Skip help for internal switches.  */
if|if
condition|(
name|cl_options
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CL_UNDOCUMENTED
condition|)
continue|continue;
comment|/* Skip switches that have already been printed.  */
if|if
condition|(
name|printed
index|[
name|i
index|]
condition|)
continue|continue;
name|printed
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
name|help
operator|=
name|cl_options
index|[
name|i
index|]
operator|.
name|help
expr_stmt|;
if|if
condition|(
operator|!
name|help
condition|)
name|help
operator|=
name|undocumented_msg
expr_stmt|;
comment|/* Get the translation.  */
name|help
operator|=
name|_
argument_list|(
name|help
argument_list|)
expr_stmt|;
name|tab
operator|=
name|strchr
argument_list|(
name|help
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
condition|)
block|{
name|len
operator|=
name|tab
operator|-
name|help
expr_stmt|;
name|opt
operator|=
name|help
expr_stmt|;
name|help
operator|=
name|tab
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|opt
operator|=
name|cl_options
index|[
name|i
index|]
operator|.
name|opt_text
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
name|wrap_help
argument_list|(
name|help
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output ITEM, of length ITEM_WIDTH, in the left column, followed by    word-wrapped HELP in a second column.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|print_switch
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|unsigned
name|int
name|indent
parameter_list|)
block|{
name|unsigned
name|int
name|len
init|=
name|strlen
argument_list|(
name|text
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* trailing comma */
if|if
condition|(
name|indent
condition|)
block|{
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
operator|+
name|len
operator|>
name|columns
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|indent
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|text
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
name|indent
operator|+
name|len
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Output ITEM, of length ITEM_WIDTH, in the left column, followed by    word-wrapped HELP in a second column.  */
end_comment

begin_function
specifier|static
name|void
name|wrap_help
parameter_list|(
specifier|const
name|char
modifier|*
name|help
parameter_list|,
specifier|const
name|char
modifier|*
name|item
parameter_list|,
name|unsigned
name|int
name|item_width
parameter_list|)
block|{
name|unsigned
name|int
name|col_width
init|=
literal|27
decl_stmt|;
name|unsigned
name|int
name|remaining
decl_stmt|,
name|room
decl_stmt|,
name|len
decl_stmt|;
name|remaining
operator|=
name|strlen
argument_list|(
name|help
argument_list|)
expr_stmt|;
do|do
block|{
name|room
operator|=
name|columns
operator|-
literal|3
operator|-
name|MAX
argument_list|(
name|col_width
argument_list|,
name|item_width
argument_list|)
expr_stmt|;
if|if
condition|(
name|room
operator|>
name|columns
condition|)
name|room
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|remaining
expr_stmt|;
if|if
condition|(
name|room
operator|<
name|len
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|help
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|room
operator|&&
name|len
operator|!=
name|remaining
condition|)
break|break;
if|if
condition|(
name|help
index|[
name|i
index|]
operator|==
literal|' '
condition|)
name|len
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|help
index|[
name|i
index|]
operator|==
literal|'-'
operator|||
name|help
index|[
name|i
index|]
operator|==
literal|'/'
operator|)
operator|&&
name|help
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|i
operator|>
literal|0
operator|&&
name|ISALPHA
argument_list|(
name|help
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"  %-*.*s %.*s\n"
argument_list|,
name|col_width
argument_list|,
name|item_width
argument_list|,
name|item
argument_list|,
name|len
argument_list|,
name|help
argument_list|)
expr_stmt|;
name|item_width
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|help
index|[
name|len
index|]
operator|==
literal|' '
condition|)
name|len
operator|++
expr_stmt|;
name|help
operator|+=
name|len
expr_stmt|;
name|remaining
operator|-=
name|len
expr_stmt|;
block|}
do|while
condition|(
name|remaining
condition|)
do|;
block|}
end_function

end_unit

