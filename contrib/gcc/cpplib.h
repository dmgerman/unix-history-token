begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Definitions for CPP library.    Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.    Written by Per Bothner, 1994-95.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GCC_CPPLIB__
end_ifndef

begin_define
define|#
directive|define
name|__GCC_CPPLIB__
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
typedef|typedef
name|unsigned
name|char
name|U_CHAR
typedef|;
typedef|typedef
name|struct
name|cpp_reader
name|cpp_reader
typedef|;
typedef|typedef
name|struct
name|cpp_buffer
name|cpp_buffer
typedef|;
typedef|typedef
name|struct
name|cpp_options
name|cpp_options
typedef|;
typedef|typedef
name|struct
name|hashnode
name|cpp_hashnode
typedef|;
enum|enum
name|cpp_token
block|{
name|CPP_EOF
init|=
operator|-
literal|1
block|,
name|CPP_OTHER
init|=
literal|0
block|,
name|CPP_COMMENT
init|=
literal|1
block|,
name|CPP_HSPACE
block|,
name|CPP_VSPACE
block|,
comment|/* newlines and #line directives */
name|CPP_NAME
block|,
name|CPP_NUMBER
block|,
name|CPP_CHAR
block|,
name|CPP_STRING
block|,
name|CPP_DIRECTIVE
block|,
name|CPP_LPAREN
block|,
comment|/* "(" */
name|CPP_RPAREN
block|,
comment|/* ")" */
name|CPP_LBRACE
block|,
comment|/* "{" */
name|CPP_RBRACE
block|,
comment|/* "}" */
name|CPP_COMMA
block|,
comment|/* "," */
name|CPP_SEMICOLON
block|,
comment|/* ";" */
name|CPP_3DOTS
block|,
comment|/* "..." */
if|#
directive|if
literal|0
block|CPP_ANDAND,
comment|/* "&&" */
block|CPP_OROR,
comment|/* "||" */
block|CPP_LSH,
comment|/* "<<" */
block|CPP_RSH,
comment|/* ">>" */
block|CPP_EQL,
comment|/* "==" */
block|CPP_NEQ,
comment|/* "!=" */
block|CPP_LEQ,
comment|/* "<=" */
block|CPP_GEQ,
comment|/* ">=" */
block|CPP_PLPL,
comment|/* "++" */
block|CPP_MINMIN,
comment|/* "--" */
endif|#
directive|endif
comment|/* POP_TOKEN is returned when we've popped a cpp_buffer. */
name|CPP_POP
block|}
enum|;
typedef|typedef
name|enum
name|cpp_token
argument_list|(
operator|*
name|parse_underflow_t
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
typedef|;
typedef|typedef
name|int
argument_list|(
argument|*parse_cleanup_t
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|cpp_buffer
operator|*
operator|,
name|cpp_reader
operator|*
operator|)
argument_list|)
expr_stmt|;
specifier|extern
name|void
name|parse_set_mark
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|parse_clear_mark
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|parse_goto_mark
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|cpp_handle_option
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|cpp_handle_options
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|enum
name|cpp_token
name|cpp_get_token
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_skip_hspace
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|enum
name|cpp_token
name|cpp_get_non_space_token
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* This frees resources used by PFILE. */
specifier|extern
name|void
name|cpp_cleanup
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
name|PFILE
operator|)
argument_list|)
decl_stmt|;
struct|struct
name|cpp_buffer
block|{
name|unsigned
name|char
modifier|*
name|cur
decl_stmt|;
comment|/* current position */
name|unsigned
name|char
modifier|*
name|rlimit
decl_stmt|;
comment|/* end of valid data */
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* entire buffer */
name|unsigned
name|char
modifier|*
name|alimit
decl_stmt|;
comment|/* end of allocated buffer */
name|unsigned
name|char
modifier|*
name|line_base
decl_stmt|;
comment|/* start of current line */
name|struct
name|cpp_buffer
modifier|*
name|prev
decl_stmt|;
comment|/* Real filename.  (Alias to ->ihash->fname, obsolete). */
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Filename specified with #line command.  */
name|char
modifier|*
name|nominal_fname
decl_stmt|;
comment|/* Last filename specified with #line command.  */
name|char
modifier|*
name|last_nominal_fname
decl_stmt|;
comment|/* Actual directory of this file, used only for "" includes */
name|struct
name|file_name_list
modifier|*
name|actual_dir
decl_stmt|;
comment|/* Pointer into the include hash table.  Used for include_next and      to record control macros. */
name|struct
name|include_hash
modifier|*
name|ihash
decl_stmt|;
name|long
name|lineno
decl_stmt|;
comment|/* Line number at CPP_LINE_BASE. */
name|long
name|colno
decl_stmt|;
comment|/* Column number at CPP_LINE_BASE. */
name|long
name|mark
decl_stmt|;
comment|/* Saved position for lengthy backtrack. */
name|parse_underflow_t
name|underflow
decl_stmt|;
name|parse_cleanup_t
name|cleanup
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
comment|/* Value of if_stack at start of this file.      Used to prohibit unmatched #endif (etc) in an include file.  */
name|struct
name|if_stack
modifier|*
name|if_stack
decl_stmt|;
comment|/* True if this is a header file included using<FILENAME>.  */
name|char
name|system_header_p
decl_stmt|;
name|char
name|seen_eof
decl_stmt|;
comment|/* True if buffer contains escape sequences.      Currently there are two kinds:      "\r-" means following identifier should not be macro-expanded.      "\r " means a token-separator.  This turns into " " in final output           if not stringizing and needed to separate tokens; otherwise nothing.      Any other two-character sequence beginning with \r is an error.       If this is NOT set, then \r is a one-character escape meaning backslash      newline.  This is guaranteed not to occur in the middle of a token.      The two interpretations of \r do not conflict, because the two-character      escapes are used only in macro buffers, and backslash-newline is removed      from macro expansion text in collect_expansion and/or macarg.  */
name|char
name|has_escapes
decl_stmt|;
block|}
struct|;
struct_decl|struct
name|file_name_map_list
struct_decl|;
comment|/* Maximum nesting of cpp_buffers.  We use a static limit, partly for    efficiency, and partly to limit runaway recursion.  */
define|#
directive|define
name|CPP_STACK_MAX
value|200
comment|/* A cpp_reader encapsulates the "state" of a pre-processor run.    Applying cpp_get_token repeatedly yields a stream of pre-processor    tokens.  Usually, there is only one cpp_reader object active. */
struct|struct
name|cpp_reader
block|{
name|parse_underflow_t
name|get_token
decl_stmt|;
name|cpp_buffer
modifier|*
name|buffer
decl_stmt|;
name|cpp_options
modifier|*
name|opts
decl_stmt|;
comment|/* A buffer used for both for cpp_get_token's output, and also internally. */
name|unsigned
name|char
modifier|*
name|token_buffer
decl_stmt|;
comment|/* Allocated size of token_buffer.  CPP_RESERVE allocates space.  */
name|unsigned
name|int
name|token_buffer_size
decl_stmt|;
comment|/* End of the written part of token_buffer. */
name|unsigned
name|char
modifier|*
name|limit
decl_stmt|;
comment|/* Error counter for exit code */
name|int
name|errors
decl_stmt|;
comment|/* Line where a newline was first seen in a string constant.  */
name|int
name|multiline_string_line
decl_stmt|;
comment|/* Current depth in #include directives that use<...>.  */
name|int
name|system_include_depth
decl_stmt|;
comment|/* Current depth of buffer stack. */
name|int
name|buffer_stack_depth
decl_stmt|;
comment|/* Hash table of macros and assertions.  See cpphash.c */
define|#
directive|define
name|HASHSIZE
value|1403
name|struct
name|hashnode
modifier|*
modifier|*
name|hashtab
decl_stmt|;
comment|/* Hash table of other included files.  See cppfiles.c */
define|#
directive|define
name|ALL_INCLUDE_HASHSIZE
value|71
name|struct
name|include_hash
modifier|*
name|all_include_files
index|[
name|ALL_INCLUDE_HASHSIZE
index|]
decl_stmt|;
comment|/* Chain of `actual directory' file_name_list entries,      for "" inclusion. */
name|struct
name|file_name_list
modifier|*
name|actual_dirs
decl_stmt|;
comment|/* Current maximum length of directory names in the search path      for include files.  (Altered as we get more of them.)  */
name|unsigned
name|int
name|max_include_len
decl_stmt|;
name|struct
name|if_stack
modifier|*
name|if_stack
decl_stmt|;
comment|/* Nonzero means we are inside an IF during a -pcp run.  In this mode      macro expansion is done, and preconditions are output for all macro      uses requiring them. */
name|char
name|pcp_inside_if
decl_stmt|;
comment|/* Nonzero means we have printed (while error reporting) a list of      containing files that matches the current status. */
name|char
name|input_stack_listing_current
decl_stmt|;
comment|/* If non-zero, macros are not expanded. */
name|char
name|no_macro_expand
decl_stmt|;
comment|/* Print column number in error messages. */
name|char
name|show_column
decl_stmt|;
comment|/* We're printed a warning recommending against using #import. */
name|char
name|import_warning
decl_stmt|;
comment|/* If true, character between '<' and '>' are a single (string) token. */
name|char
name|parsing_include_directive
decl_stmt|;
comment|/* True if escape sequences (as described for has_escapes in      parse_buffer) should be emitted. */
name|char
name|output_escapes
decl_stmt|;
comment|/* 0: Have seen non-white-space on this line.      1: Only seen white space so far on this line.      2: Only seen white space so far in this file. */
name|char
name|only_seen_white
decl_stmt|;
comment|/* Nonzero means this file was included with a -imacros or -include      command line and should not be recorded as an include file.  */
name|int
name|no_record_file
decl_stmt|;
name|long
name|lineno
decl_stmt|;
name|struct
name|tm
modifier|*
name|timebuf
decl_stmt|;
comment|/* Buffer of -M output.  */
name|char
modifier|*
name|deps_buffer
decl_stmt|;
comment|/* Number of bytes allocated in above.  */
name|int
name|deps_allocated_size
decl_stmt|;
comment|/* Number of bytes used.  */
name|int
name|deps_size
decl_stmt|;
comment|/* Number of bytes since the last newline.  */
name|int
name|deps_column
decl_stmt|;
comment|/* A buffer and a table, used only by read_and_prescan (in cppfiles.c)      which are allocated once per cpp_reader object to keep them off the      stack and avoid setup costs.  */
name|U_CHAR
modifier|*
name|input_buffer
decl_stmt|;
name|U_CHAR
modifier|*
name|input_speccase
decl_stmt|;
name|size_t
name|input_buffer_len
decl_stmt|;
block|}
struct|;
define|#
directive|define
name|CPP_FATAL_LIMIT
value|1000
comment|/* True if we have seen a "fatal" error. */
define|#
directive|define
name|CPP_FATAL_ERRORS
parameter_list|(
name|READER
parameter_list|)
value|((READER)->errors>= CPP_FATAL_LIMIT)
define|#
directive|define
name|CPP_BUF_PEEK
parameter_list|(
name|BUFFER
parameter_list|)
define|\
value|((BUFFER)->cur< (BUFFER)->rlimit ? *(BUFFER)->cur : EOF)
define|#
directive|define
name|CPP_BUF_GET
parameter_list|(
name|BUFFER
parameter_list|)
define|\
value|((BUFFER)->cur< (BUFFER)->rlimit ? *(BUFFER)->cur++ : EOF)
define|#
directive|define
name|CPP_FORWARD
parameter_list|(
name|BUFFER
parameter_list|,
name|N
parameter_list|)
value|((BUFFER)->cur += (N))
comment|/* Macros for manipulating the token_buffer. */
define|#
directive|define
name|CPP_OUT_BUFFER
parameter_list|(
name|PFILE
parameter_list|)
value|((PFILE)->token_buffer)
comment|/* Number of characters currently in PFILE's output buffer. */
define|#
directive|define
name|CPP_WRITTEN
parameter_list|(
name|PFILE
parameter_list|)
value|((size_t)((PFILE)->limit - (PFILE)->token_buffer))
define|#
directive|define
name|CPP_PWRITTEN
parameter_list|(
name|PFILE
parameter_list|)
value|((PFILE)->limit)
comment|/* Make sure PFILE->token_buffer has space for at least N more characters. */
define|#
directive|define
name|CPP_RESERVE
parameter_list|(
name|PFILE
parameter_list|,
name|N
parameter_list|)
define|\
value|(CPP_WRITTEN (PFILE) + (size_t)(N)> (PFILE)->token_buffer_size \&& (cpp_grow_buffer (PFILE, N), 0))
comment|/* Append string STR (of length N) to PFILE's output buffer.    Assume there is enough space. */
define|#
directive|define
name|CPP_PUTS_Q
parameter_list|(
name|PFILE
parameter_list|,
name|STR
parameter_list|,
name|N
parameter_list|)
define|\
value|(memcpy ((PFILE)->limit, STR, (N)), (PFILE)->limit += (N))
comment|/* Append string STR (of length N) to PFILE's output buffer.  Make space. */
define|#
directive|define
name|CPP_PUTS
parameter_list|(
name|PFILE
parameter_list|,
name|STR
parameter_list|,
name|N
parameter_list|)
value|CPP_RESERVE(PFILE, N), CPP_PUTS_Q(PFILE, STR,N)
comment|/* Append character CH to PFILE's output buffer.  Assume sufficient space. */
define|#
directive|define
name|CPP_PUTC_Q
parameter_list|(
name|PFILE
parameter_list|,
name|CH
parameter_list|)
value|(*(PFILE)->limit++ = (CH))
comment|/* Append character CH to PFILE's output buffer.  Make space if need be. */
define|#
directive|define
name|CPP_PUTC
parameter_list|(
name|PFILE
parameter_list|,
name|CH
parameter_list|)
value|(CPP_RESERVE (PFILE, 1), CPP_PUTC_Q (PFILE, CH))
comment|/* Make sure PFILE->limit is followed by '\0'. */
define|#
directive|define
name|CPP_NUL_TERMINATE_Q
parameter_list|(
name|PFILE
parameter_list|)
value|(*(PFILE)->limit = 0)
define|#
directive|define
name|CPP_NUL_TERMINATE
parameter_list|(
name|PFILE
parameter_list|)
value|(CPP_RESERVE(PFILE, 1), *(PFILE)->limit = 0)
define|#
directive|define
name|CPP_ADJUST_WRITTEN
parameter_list|(
name|PFILE
parameter_list|,
name|DELTA
parameter_list|)
value|((PFILE)->limit += (DELTA))
define|#
directive|define
name|CPP_SET_WRITTEN
parameter_list|(
name|PFILE
parameter_list|,
name|N
parameter_list|)
value|((PFILE)->limit = (PFILE)->token_buffer + (N))
comment|/* Advance the current line by one. */
define|#
directive|define
name|CPP_BUMP_BUFFER_LINE
parameter_list|(
name|PBUF
parameter_list|)
value|((PBUF)->lineno++,\ 				    (PBUF)->line_base = (PBUF)->cur)
define|#
directive|define
name|CPP_BUMP_LINE
parameter_list|(
name|PFILE
parameter_list|)
value|CPP_BUMP_BUFFER_LINE(CPP_BUFFER(PFILE))
define|#
directive|define
name|CPP_OPTIONS
parameter_list|(
name|PFILE
parameter_list|)
value|((PFILE)->opts)
define|#
directive|define
name|CPP_BUFFER
parameter_list|(
name|PFILE
parameter_list|)
value|((PFILE)->buffer)
define|#
directive|define
name|CPP_PREV_BUFFER
parameter_list|(
name|BUFFER
parameter_list|)
value|((BUFFER)->prev)
comment|/* The bottom of the buffer stack. */
define|#
directive|define
name|CPP_NULL_BUFFER
parameter_list|(
name|PFILE
parameter_list|)
value|NULL
comment|/* The `pending' structure accumulates all the options that are not    actually processed until we hit cpp_start_read.  It consists of    several lists, one for each type of option.  We keep both head and    tail pointers for quick insertion. */
struct|struct
name|cpp_pending
block|{
name|struct
name|pending_option
modifier|*
name|define_head
decl_stmt|,
modifier|*
name|define_tail
decl_stmt|;
name|struct
name|pending_option
modifier|*
name|assert_head
decl_stmt|,
modifier|*
name|assert_tail
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|quote_head
decl_stmt|,
modifier|*
name|quote_tail
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|brack_head
decl_stmt|,
modifier|*
name|brack_tail
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|systm_head
decl_stmt|,
modifier|*
name|systm_tail
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|after_head
decl_stmt|,
modifier|*
name|after_tail
decl_stmt|;
name|struct
name|pending_option
modifier|*
name|imacros_head
decl_stmt|,
modifier|*
name|imacros_tail
decl_stmt|;
name|struct
name|pending_option
modifier|*
name|include_head
decl_stmt|,
modifier|*
name|include_tail
decl_stmt|;
block|}
struct|;
comment|/* Pointed to by cpp_reader.opts. */
struct|struct
name|cpp_options
block|{
name|char
modifier|*
name|in_fname
decl_stmt|;
comment|/* Name of output file, for error messages.  */
name|char
modifier|*
name|out_fname
decl_stmt|;
name|struct
name|file_name_map_list
modifier|*
name|map_list
decl_stmt|;
comment|/* Non-0 means -v, so print the full set of include dirs.  */
name|char
name|verbose
decl_stmt|;
comment|/* Nonzero means use extra default include directories for C++.  */
name|char
name|cplusplus
decl_stmt|;
comment|/* Nonzero means handle cplusplus style comments */
name|char
name|cplusplus_comments
decl_stmt|;
comment|/* Nonzero means handle #import, for objective C.  */
name|char
name|objc
decl_stmt|;
comment|/* Nonzero means this is an assembly file, and allow      unknown directives, which could be comments.  */
name|int
name|lang_asm
decl_stmt|;
comment|/* Nonzero means turn NOTREACHED into #pragma NOTREACHED etc */
name|char
name|for_lint
decl_stmt|;
comment|/* Nonzero means handle CHILL comment syntax      and output CHILL string delimiter for __DATE___ etc. */
name|char
name|chill
decl_stmt|;
comment|/* Nonzero means copy comments into the output file.  */
name|char
name|put_out_comments
decl_stmt|;
comment|/* Nonzero means process the ANSI trigraph sequences.  */
name|char
name|trigraphs
decl_stmt|;
comment|/* Nonzero means print the names of included files rather than      the preprocessed output.  1 means just the #include "...",      2 means #include<...> as well.  */
name|char
name|print_deps
decl_stmt|;
comment|/* Nonzero if missing .h files in -M output are assumed to be generated      files and not errors.  */
name|char
name|print_deps_missing_files
decl_stmt|;
comment|/* If true, fopen (deps_file, "a") else fopen (deps_file, "w"). */
name|char
name|print_deps_append
decl_stmt|;
comment|/* Nonzero means print names of header files (-H).  */
name|char
name|print_include_names
decl_stmt|;
comment|/* Nonzero means try to make failure to fit ANSI C an error.  */
name|char
name|pedantic_errors
decl_stmt|;
comment|/* Nonzero means don't print warning messages.  -w.  */
name|char
name|inhibit_warnings
decl_stmt|;
comment|/* Nonzero means warn if slash-star appears in a comment.  */
name|char
name|warn_comments
decl_stmt|;
comment|/* Nonzero means warn if there are any trigraphs.  */
name|char
name|warn_trigraphs
decl_stmt|;
comment|/* Nonzero means warn if #import is used.  */
name|char
name|warn_import
decl_stmt|;
comment|/* Nonzero means warn if a macro argument is (or would be)      stringified with -traditional.  */
name|char
name|warn_stringify
decl_stmt|;
comment|/* Nonzero means turn warnings into errors.  */
name|char
name|warnings_are_errors
decl_stmt|;
comment|/* Nonzero causes output not to be done,      but directives such as #define that have side effects      are still obeyed.  */
name|char
name|no_output
decl_stmt|;
comment|/* Nonzero means we should look for header.gcc files that remap file      names.  */
name|char
name|remap
decl_stmt|;
comment|/* Nonzero means don't output line number information.  */
name|char
name|no_line_commands
decl_stmt|;
comment|/* Nonzero means output the text in failing conditionals,    inside #failed ... #endfailed.  */
name|char
name|output_conditionals
decl_stmt|;
comment|/* Nonzero means -I- has been seen,      so don't look for #include "foo" the source-file directory.  */
name|char
name|ignore_srcdir
decl_stmt|;
comment|/* Zero means dollar signs are punctuation.      This used to be needed for conformance to the C Standard,      before the C Standard was corrected.  */
name|char
name|dollars_in_ident
decl_stmt|;
comment|/* Nonzero means try to imitate old fashioned non-ANSI preprocessor.  */
name|char
name|traditional
decl_stmt|;
comment|/* Nonzero means warn if undefined identifiers are evaluated in an #if.  */
name|char
name|warn_undef
decl_stmt|;
comment|/* Nonzero for the 1989 C Standard, including corrigenda and amendments.  */
name|char
name|c89
decl_stmt|;
comment|/* Nonzero for the 199x C Standard, including corrigenda and amendments.  */
name|char
name|c9x
decl_stmt|;
comment|/* Nonzero means give all the error messages the ANSI standard requires.  */
name|char
name|pedantic
decl_stmt|;
name|char
name|done_initializing
decl_stmt|;
comment|/* Search paths for include files.  */
name|struct
name|file_name_list
modifier|*
name|quote_include
decl_stmt|;
comment|/* First dir to search for "file" */
name|struct
name|file_name_list
modifier|*
name|bracket_include
decl_stmt|;
comment|/* First dir to search for<file> */
comment|/* Directory prefix that should replace `/usr/lib/gcc-lib/TARGET/VERSION'      in the standard include file directories.  */
name|char
modifier|*
name|include_prefix
decl_stmt|;
name|int
name|include_prefix_len
decl_stmt|;
name|char
name|no_standard_includes
decl_stmt|;
name|char
name|no_standard_cplusplus_includes
decl_stmt|;
comment|/* dump_only means inhibit output of the preprocessed text              and instead output the definitions of all user-defined              macros in a form suitable for use as input to cccp.    dump_names means pass #define and the macro name through to output.    dump_definitions means pass the whole definition (plus #define) through */
enum|enum
block|{
name|dump_none
init|=
literal|0
block|,
name|dump_only
block|,
name|dump_names
block|,
name|dump_definitions
block|}
name|dump_macros
enum|;
comment|/* Nonzero means pass all #define and #undef directives which we actually    process through to the output stream.  This feature is used primarily    to allow cc1 to record the #defines and #undefs for the sake of    debuggers which understand about preprocessor macros, but it may    also be useful with -E to figure out how symbols are defined, and    where they are defined.  */
name|int
name|debug_output
decl_stmt|;
comment|/* Nonzero means pass #include lines through to the output,      even if they are ifdefed out.  */
name|int
name|dump_includes
decl_stmt|;
comment|/* Pending options - -D, -U, -A, -I, -ixxx. */
name|struct
name|cpp_pending
modifier|*
name|pending
decl_stmt|;
comment|/* File name which deps are being written to.      This is 0 if deps are being written to stdout.  */
name|char
modifier|*
name|deps_file
decl_stmt|;
comment|/* Target-name to write with the dependency information.  */
name|char
modifier|*
name|deps_target
decl_stmt|;
block|}
struct|;
define|#
directive|define
name|CPP_TRADITIONAL
parameter_list|(
name|PFILE
parameter_list|)
value|(CPP_OPTIONS(PFILE)-> traditional)
define|#
directive|define
name|CPP_WARN_UNDEF
parameter_list|(
name|PFILE
parameter_list|)
value|(CPP_OPTIONS(PFILE)->warn_undef)
define|#
directive|define
name|CPP_C89
parameter_list|(
name|PFILE
parameter_list|)
value|(CPP_OPTIONS(PFILE)->c89)
define|#
directive|define
name|CPP_PEDANTIC
parameter_list|(
name|PFILE
parameter_list|)
value|(CPP_OPTIONS (PFILE)->pedantic)
define|#
directive|define
name|CPP_PRINT_DEPS
parameter_list|(
name|PFILE
parameter_list|)
value|(CPP_OPTIONS (PFILE)->print_deps)
comment|/* List of directories to look for include files in. */
struct|struct
name|file_name_list
block|{
name|struct
name|file_name_list
modifier|*
name|next
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|alloc
decl_stmt|;
comment|/* for the cache of 				   current directory entries */
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|nlen
decl_stmt|;
comment|/* We use these to tell if the directory mentioned here is a duplicate      of an earlier directory on the search path. */
name|ino_t
name|ino
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
comment|/* If the following is nonzero, it is a C-language system include      directory.  */
name|int
name|sysp
decl_stmt|;
comment|/* Mapping of file names for this directory.      Only used on MS-DOS and related platforms. */
name|struct
name|file_name_map
modifier|*
name|name_map
decl_stmt|;
block|}
struct|;
define|#
directive|define
name|ABSOLUTE_PATH
value|((struct file_name_list *)-1)
comment|/* This structure is used for the table of all includes.  It is    indexed by the `short name' (the name as it appeared in the    #include statement) which is stored in *nshort.  */
struct|struct
name|include_hash
block|{
name|struct
name|include_hash
modifier|*
name|next
decl_stmt|;
comment|/* Next file with the same short name but a      different (partial) pathname). */
name|struct
name|include_hash
modifier|*
name|next_this_file
decl_stmt|;
comment|/* Location of the file in the include search path.      Used for include_next */
name|struct
name|file_name_list
modifier|*
name|foundhere
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* (partial) pathname of file */
name|char
modifier|*
name|nshort
decl_stmt|;
comment|/* name of file as referenced in #include */
name|char
modifier|*
name|control_macro
decl_stmt|;
comment|/* macro, if any, preventing reinclusion - see 			   redundant_include_p */
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
comment|/* for file content cache, not yet implemented */
block|}
struct|;
comment|/* Name under which this program was invoked.  */
specifier|extern
name|char
modifier|*
name|progname
decl_stmt|;
comment|/* The structure of a node in the hash table.  The hash table    has entries for all tokens defined by #define commands (type T_MACRO),    plus some special tokens like __LINE__ (these each have their own    type, and the appropriate code is run when that type of node is seen.    It does not contain control words like "#define", which are recognized    by a separate piece of code. */
comment|/* different flavors of hash nodes --- also used in keyword table */
enum|enum
name|node_type
block|{
name|T_DEFINE
init|=
literal|1
block|,
comment|/* the `#define' keyword */
name|T_INCLUDE
block|,
comment|/* the `#include' keyword */
name|T_INCLUDE_NEXT
block|,
comment|/* the `#include_next' keyword */
name|T_IMPORT
block|,
comment|/* the `#import' keyword */
name|T_IFDEF
block|,
comment|/* the `#ifdef' keyword */
name|T_IFNDEF
block|,
comment|/* the `#ifndef' keyword */
name|T_IF
block|,
comment|/* the `#if' keyword */
name|T_ELSE
block|,
comment|/* `#else' */
name|T_PRAGMA
block|,
comment|/* `#pragma' */
name|T_ELIF
block|,
comment|/* `#elif' */
name|T_UNDEF
block|,
comment|/* `#undef' */
name|T_LINE
block|,
comment|/* `#line' */
name|T_ERROR
block|,
comment|/* `#error' */
name|T_WARNING
block|,
comment|/* `#warning' */
name|T_ENDIF
block|,
comment|/* `#endif' */
name|T_SCCS
block|,
comment|/* `#sccs', used on system V.  */
name|T_IDENT
block|,
comment|/* `#ident', used on system V.  */
name|T_ASSERT
block|,
comment|/* `#assert', taken from system V.  */
name|T_UNASSERT
block|,
comment|/* `#unassert', taken from system V.  */
name|T_SPECLINE
block|,
comment|/* special symbol `__LINE__' */
name|T_DATE
block|,
comment|/* `__DATE__' */
name|T_FILE
block|,
comment|/* `__FILE__' */
name|T_BASE_FILE
block|,
comment|/* `__BASE_FILE__' */
name|T_INCLUDE_LEVEL
block|,
comment|/* `__INCLUDE_LEVEL__' */
name|T_VERSION
block|,
comment|/* `__VERSION__' */
name|T_TIME
block|,
comment|/* `__TIME__' */
name|T_STDC
block|,
comment|/* `__STDC__' */
name|T_CONST
block|,
comment|/* Constant string, used by `__SIZE_TYPE__' etc */
name|T_MACRO
block|,
comment|/* macro defined by `#define' */
name|T_DISABLED
block|,
comment|/* macro temporarily turned off for rescan */
name|T_PCSTRING
block|,
comment|/* precompiled string (hashval is KEYDEF *) */
name|T_UNUSED
comment|/* Used for something not defined.  */
block|}
enum|;
comment|/* Structure returned by create_definition */
typedef|typedef
name|struct
name|macrodef
name|MACRODEF
typedef|;
struct|struct
name|macrodef
block|{
name|struct
name|definition
modifier|*
name|defn
decl_stmt|;
name|unsigned
name|char
modifier|*
name|symnam
decl_stmt|;
name|int
name|symlen
decl_stmt|;
block|}
struct|;
comment|/* Structure allocated for every #define.  For a simple replacement    such as    	#define foo bar ,    nargs = -1, the `pattern' list is null, and the expansion is just    the replacement text.  Nargs = 0 means a functionlike macro with no args,    e.g.,        #define getchar() getc (stdin) .    When there are args, the expansion is the replacement text with the    args squashed out, and the reflist is a list describing how to    build the output from the input: e.g., "3 chars, then the 1st arg,    then 9 chars, then the 3rd arg, then 0 chars, then the 2nd arg".    The chars here come from the expansion.  Whatever is left of the    expansion after the last arg-occurrence is copied after that arg.    Note that the reflist can be arbitrarily long---    its length depends on the number of times the arguments appear in    the replacement text, not how many args there are.  Example:    #define f(x) x+x+x+x+x+x+x would have replacement text "++++++" and    pattern list      { (0, 1), (1, 1), (1, 1), ..., (1, 1), NULL }    where (x, y) means (nchars, argno). */
typedef|typedef
name|struct
name|definition
name|DEFINITION
typedef|;
struct|struct
name|definition
block|{
name|int
name|nargs
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of expansion string */
name|int
name|predefined
decl_stmt|;
comment|/* True if the macro was builtin or */
comment|/* came from the command line */
name|unsigned
name|char
modifier|*
name|expansion
decl_stmt|;
name|int
name|line
decl_stmt|;
comment|/* Line number of definition */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* File of definition */
name|char
name|rest_args
decl_stmt|;
comment|/* Nonzero if last arg. absorbs the rest */
struct|struct
name|reflist
block|{
name|struct
name|reflist
modifier|*
name|next
decl_stmt|;
name|char
name|stringify
decl_stmt|;
comment|/* nonzero if this arg was preceded by a 				   # operator. */
name|char
name|raw_before
decl_stmt|;
comment|/* Nonzero if a ## operator before arg. */
name|char
name|raw_after
decl_stmt|;
comment|/* Nonzero if a ## operator after arg. */
name|char
name|rest_args
decl_stmt|;
comment|/* Nonzero if this arg. absorbs the rest */
name|int
name|nchars
decl_stmt|;
comment|/* Number of literal chars to copy before 				   this arg occurrence.  */
name|int
name|argno
decl_stmt|;
comment|/* Number of arg to substitute (origin-0) */
block|}
modifier|*
name|pattern
struct|;
union|union
block|{
comment|/* Names of macro args, concatenated in reverse order        with comma-space between them.        The only use of this is that we warn on redefinition        if this differs between the old and new definitions.  */
name|unsigned
name|char
modifier|*
name|argnames
decl_stmt|;
block|}
name|args
union|;
block|}
struct|;
comment|/* These tables are not really `const', but they are only modified at    initialization time, in a separate translation unit from the rest    of the library.  We let the rest of the library think they are `const'    to get better code and some additional sanity checks.  */
ifndef|#
directive|ifndef
name|FAKE_CONST
define|#
directive|define
name|FAKE_CONST
value|const
endif|#
directive|endif
specifier|extern
name|FAKE_CONST
name|unsigned
name|char
name|is_idstart
index|[
literal|256
index|]
decl_stmt|;
specifier|extern
name|FAKE_CONST
name|unsigned
name|char
name|is_idchar
index|[
literal|256
index|]
decl_stmt|;
specifier|extern
name|FAKE_CONST
name|unsigned
name|char
name|is_hor_space
index|[
literal|256
index|]
decl_stmt|;
specifier|extern
name|FAKE_CONST
name|unsigned
name|char
name|is_space
index|[
literal|256
index|]
decl_stmt|;
specifier|extern
name|FAKE_CONST
name|unsigned
name|char
name|trigraph_table
index|[
literal|256
index|]
decl_stmt|;
undef|#
directive|undef
name|FAKE_CONST
comment|/* Stack of conditionals currently in progress    (including both successful and failing conditionals).  */
struct|struct
name|if_stack
block|{
name|struct
name|if_stack
modifier|*
name|next
decl_stmt|;
comment|/* for chaining to the next stack frame */
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* copied from input when frame is made */
name|int
name|lineno
decl_stmt|;
comment|/* similarly */
name|int
name|if_succeeded
decl_stmt|;
comment|/* true if a leg of this if-group 				    has been passed through rescan */
name|unsigned
name|char
modifier|*
name|control_macro
decl_stmt|;
comment|/* For #ifndef at start of file, 				   this is the macro name tested.  */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* type of last directive seen in this group */
block|}
struct|;
typedef|typedef
name|struct
name|if_stack
name|IF_STACK_FRAME
typedef|;
specifier|extern
name|void
name|cpp_buf_line_and_col
name|PARAMS
argument_list|(
operator|(
name|cpp_buffer
operator|*
operator|,
name|long
operator|*
operator|,
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|cpp_buffer
modifier|*
name|cpp_file_buffer
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_define
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_assert
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_undef
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_unassert
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_error
name|PVPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
specifier|extern
name|void
name|cpp_warning
name|PVPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
specifier|extern
name|void
name|cpp_pedwarn
name|PVPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
specifier|extern
name|void
name|cpp_error_with_line
name|PVPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_4
decl_stmt|;
specifier|extern
name|void
name|cpp_warning_with_line
name|PVPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_4
decl_stmt|;
specifier|extern
name|void
name|cpp_pedwarn_with_line
name|PVPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_4
decl_stmt|;
specifier|extern
name|void
name|cpp_pedwarn_with_file_and_line
name|PVPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_4
decl_stmt|;
specifier|extern
name|void
name|cpp_message_from_errno
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_error_from_errno
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_perror_with_name
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|v_cpp_message
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_grow_buffer
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|HOST_WIDEST_INT
name|cpp_parse_escape
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|HOST_WIDEST_INT
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|cpp_buffer
modifier|*
name|cpp_push_buffer
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|cpp_buffer
modifier|*
name|cpp_pop_buffer
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|cpp_hashnode
modifier|*
name|cpp_lookup
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_reader_init
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_options_init
name|PARAMS
argument_list|(
operator|(
name|cpp_options
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|cpp_start_read
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|cpp_read_check_assertion
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|scan_decls
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|skip_rest_of_line
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_finish
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|quote_string
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_expand_to_buffer
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_scan_buffer
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|check_macro_name
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Last arg to output_line_command.  */
enum|enum
name|file_change_code
block|{
name|same_file
block|,
name|enter_file
block|,
name|leave_file
block|}
enum|;
specifier|extern
name|void
name|output_line_command
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|enum
name|file_change_code
operator|)
argument_list|)
decl_stmt|;
comment|/* From cpperror.c */
specifier|extern
name|void
name|cpp_fatal
name|PVPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
specifier|extern
name|void
name|cpp_message
name|PVPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_3
decl_stmt|;
specifier|extern
name|void
name|cpp_pfatal_with_name
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_file_line_for_message
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_print_containing_files
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|cpp_notice
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
comment|/* In cppfiles.c */
specifier|extern
name|void
name|simplify_pathname
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|merge_include_chains
name|PROTO
argument_list|(
operator|(
expr|struct
name|cpp_options
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|find_include_file
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|file_name_list
operator|*
operator|,
expr|struct
name|include_hash
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|finclude
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
expr|struct
name|include_hash
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|deps_output
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|struct
name|include_hash
modifier|*
name|include_hash
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|INCLUDE_LEN_FUDGE
define|#
directive|define
name|INCLUDE_LEN_FUDGE
value|0
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GCC_CPPLIB__ */
end_comment

end_unit

