begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert tree expression to rtl instructions, for GNU compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* Include expr.h after insn-config.h so we get HAVE_conditional_move.  */
end_comment

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"typeclass.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* Decide whether a function's arguments should be processed    from first to last or from last to first.     They should if the stack and args grow in opposite directions, but    only if we have push insns.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STACK_GROWS_DOWNWARD
argument_list|)
operator|!=
name|defined
argument_list|(
name|ARGS_GROW_DOWNWARD
argument_list|)
end_if

begin_define
define|#
directive|define
name|PUSH_ARGS_REVERSED
end_define

begin_comment
comment|/* If it's last to first.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_PUSH_CODE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_DEC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_INC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Assume that case vectors are not pc-relative.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CASE_VECTOR_PC_RELATIVE
end_ifndef

begin_define
define|#
directive|define
name|CASE_VECTOR_PC_RELATIVE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If this is nonzero, we do not bother generating VOLATILE    around volatile memory references, and we are willing to    output indirect addresses.  If cse is to follow, we reject    indirect addresses so a useful potential cse is generated;    if it is used only once, instruction combination will produce    the same indirect address eventually.  */
end_comment

begin_decl_stmt
name|int
name|cse_not_expected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of pending expressions for PLACEHOLDER_EXPR to replace.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|placeholder_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used by move_by_pieces to describe the move to    be performed.  */
end_comment

begin_struct
struct|struct
name|move_by_pieces
block|{
name|rtx
name|to
decl_stmt|;
name|rtx
name|to_addr
decl_stmt|;
name|int
name|autinc_to
decl_stmt|;
name|int
name|explicit_inc_to
decl_stmt|;
name|rtx
name|from
decl_stmt|;
name|rtx
name|from_addr
decl_stmt|;
name|int
name|autinc_from
decl_stmt|;
name|int
name|explicit_inc_from
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|reverse
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used by store_by_pieces to describe the clear to    be performed.  */
end_comment

begin_struct
struct|struct
name|store_by_pieces
block|{
name|rtx
name|to
decl_stmt|;
name|rtx
name|to_addr
decl_stmt|;
name|int
name|autinc_to
decl_stmt|;
name|int
name|explicit_inc_to
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|rtx
argument_list|(
argument|*constfun
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|HOST_WIDE_INT
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
expr_stmt|;
name|PTR
name|constfundata
decl_stmt|;
name|int
name|reverse
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|enqueue_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|move_by_pieces_ninsns
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move_by_pieces_1
name|PARAMS
argument_list|(
operator|(
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
operator|...
argument_list|)
operator|,
expr|enum
name|machine_mode
operator|,
expr|struct
name|move_by_pieces
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|clear_by_pieces_1
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|HOST_WIDE_INT
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_by_pieces
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_by_pieces_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|store_by_pieces
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_by_pieces_2
name|PARAMS
argument_list|(
operator|(
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
operator|...
argument_list|)
operator|,
expr|enum
name|machine_mode
operator|,
expr|struct
name|store_by_pieces
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|get_subtarget
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_zeros_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mostly_zeros_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_constructor_field
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|,
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_constructor
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|int
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|store_field
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|,
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|var_rtx
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|highest_pow2_factor
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|highest_pow2_factor_for_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_aligning_offset
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_increment
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_by_parts_greater
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_by_parts_equality
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_compare_and_jump
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|rtx_code
operator|,
expr|enum
name|rtx_code
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|do_store_flag
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|emit_single_push_insn
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|do_tablejump
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record for each mode whether we can move a register directly to or    from an object of that mode in memory.  If we can't, we won't try    to use that mode directly when accessing a field of that mode.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|direct_load
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|direct_store
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If a memory-to-memory move would take MOVE_RATIO or more simple    move-instruction sequences, we will do a movstr or libcall instead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MOVE_RATIO
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_movstrqi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrhi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrsi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrdi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrti
argument_list|)
end_if

begin_define
define|#
directive|define
name|MOVE_RATIO
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* If we are optimizing for space (-Os), cut down the default move ratio.  */
end_comment

begin_define
define|#
directive|define
name|MOVE_RATIO
value|(optimize_size ? 3 : 15)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This macro is used to determine whether move_by_pieces should be called    to perform a structure copy.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MOVE_BY_PIECES_P
end_ifndef

begin_define
define|#
directive|define
name|MOVE_BY_PIECES_P
parameter_list|(
name|SIZE
parameter_list|,
name|ALIGN
parameter_list|)
define|\
value|(move_by_pieces_ninsns (SIZE, ALIGN)< (unsigned int) MOVE_RATIO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array records the insn_code of insns to perform block moves.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|movstr_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array records the insn_code of insns to perform block clears.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|clrstr_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SLOW_UNALIGNED_ACCESS is non-zero if unaligned accesses are very slow.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SLOW_UNALIGNED_ACCESS
end_ifndef

begin_define
define|#
directive|define
name|SLOW_UNALIGNED_ACCESS
parameter_list|(
name|MODE
parameter_list|,
name|ALIGN
parameter_list|)
value|STRICT_ALIGNMENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This is run once per compilation to set up which modes can be used    directly in memory and to initialize the block move optab.  */
end_comment

begin_function
name|void
name|init_expr_once
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|num_clobbers
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|mem1
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Try indexing by frame ptr and try by stack ptr.      It is known that on the Convex the stack ptr isn't a valid index.      With luck, one or the other is valid on any machine.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|mem1
operator|=
name|gen_rtx_MEM
argument_list|(
name|VOIDmode
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|mode
operator|<
name|NUM_MACHINE_MODES
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|0
expr_stmt|;
name|PUT_MODE
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|mem1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* See if there is some register that can be used in this mode and 	 directly loaded or stored from memory.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|==
literal|0
operator|||
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|==
literal|0
operator|)
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
continue|continue;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|mem
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|mem1
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|mem
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|mem1
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is run at the start of compiling a function.  */
end_comment

begin_function
name|void
name|init_expr
parameter_list|()
block|{
name|cfun
operator|->
name|expr
operator|=
operator|(
expr|struct
name|expr_status
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expr_status
argument_list|)
argument_list|)
expr_stmt|;
name|pending_chain
operator|=
literal|0
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
name|stack_pointer_delta
operator|=
literal|0
expr_stmt|;
name|inhibit_defer_pop
operator|=
literal|0
expr_stmt|;
name|saveregs_value
operator|=
literal|0
expr_stmt|;
name|apply_args_value
operator|=
literal|0
expr_stmt|;
name|forced_labels
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mark_expr_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|expr_status
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|ggc_mark_rtx
argument_list|(
name|p
operator|->
name|x_saveregs_value
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|p
operator|->
name|x_apply_args_value
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|p
operator|->
name|x_forced_labels
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_expr_status
parameter_list|(
name|f
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
block|{
name|free
argument_list|(
name|f
operator|->
name|expr
argument_list|)
expr_stmt|;
name|f
operator|->
name|expr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Small sanity check that the queue is empty at the end of a function.  */
end_comment

begin_function
name|void
name|finish_expr_for_function
parameter_list|()
block|{
if|if
condition|(
name|pending_chain
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Manage the queue of increment instructions to be output    for POSTINCREMENT_EXPR expressions, etc.  */
end_comment

begin_comment
comment|/* Queue up to increment (or change) VAR later.  BODY says how:    BODY should be the same thing you would pass to emit_insn    to increment right away.  It will go to emit_insn later on.     The value is a QUEUED expression to be used in place of VAR    where you want to guarantee the pre-incrementation value of VAR.  */
end_comment

begin_function
specifier|static
name|rtx
name|enqueue_insn
parameter_list|(
name|var
parameter_list|,
name|body
parameter_list|)
name|rtx
name|var
decl_stmt|,
name|body
decl_stmt|;
block|{
name|pending_chain
operator|=
name|gen_rtx_QUEUED
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|var
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|body
argument_list|,
name|pending_chain
argument_list|)
expr_stmt|;
return|return
name|pending_chain
return|;
block|}
end_function

begin_comment
comment|/* Use protect_from_queue to convert a QUEUED expression    into something that you can put immediately into an instruction.    If the queued incrementation has not happened yet,    protect_from_queue returns the variable itself.    If the incrementation has happened, protect_from_queue returns a temp    that contains a copy of the old value of the variable.     Any time an rtx which might possibly be a QUEUED is to be put    into an instruction, it must be passed through protect_from_queue first.    QUEUED expressions are not meaningful in instructions.     Do not pass a value through protect_from_queue and then hold    on to it for a while before putting it in an instruction!    If the queue is flushed in between, incorrect code will result.  */
end_comment

begin_function
name|rtx
name|protect_from_queue
parameter_list|(
name|x
parameter_list|,
name|modify
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* A QUEUED can hang around after the queue is forced out.  */
comment|/* Shortcut for most common case.  */
block|if (pending_chain == 0)     return x;
endif|#
directive|endif
if|if
condition|(
name|code
operator|!=
name|QUEUED
condition|)
block|{
comment|/* A special hack for read access to (MEM (QUEUED ...)) to facilitate 	 use of autoincrement.  Make a copy of the contents of the memory 	 location rather than a copy of the address, but not if the value is 	 of mode BLKmode.  Don't modify X in place since it might be 	 shared.  */
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|QUEUED
operator|&&
operator|!
name|modify
condition|)
block|{
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|replace_equiv_address_nv
argument_list|(
name|x
argument_list|,
name|QUEUED_VAR
argument_list|(
name|y
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|QUEUED_INSN
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
argument_list|,
name|QUEUED_INSN
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* Copy the address into a pseudo, so that the returned value 	     remains correct across calls to emit_queue.  */
return|return
name|replace_equiv_address
argument_list|(
name|new
argument_list|,
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Otherwise, recursively protect the subexpressions of all 	 the kinds of rtx's that can contain a QUEUED.  */
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|rtx
name|tem
init|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|tem
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MULT
condition|)
block|{
name|rtx
name|new0
init|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|new1
init|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|new0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|new1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|new0
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|new1
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
comment|/* If the increment has not happened, use the variable itself.  Copy it      into a new pseudo so that the value remains correct across calls to      emit_queue.  */
if|if
condition|(
name|QUEUED_INSN
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
return|return
name|copy_to_reg
argument_list|(
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
comment|/* If the increment has happened and a pre-increment copy exists,      use that copy.  */
if|if
condition|(
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
return|;
comment|/* The increment has happened but we haven't set up a pre-increment copy.      Set one up now, and use it.  */
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
argument_list|,
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|QUEUED_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X contains a QUEUED expression:    if it contains anything that will be altered by a queued increment.    We handle only combinations of MEM, PLUS, MINUS and MULT operators    since memory addresses generally contain only those.  */
end_comment

begin_function
name|int
name|queued_subexp_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|QUEUED
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
operator|(
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Perform all the pending incrementations.  */
end_comment

begin_function
name|void
name|emit_queue
parameter_list|()
block|{
name|rtx
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|pending_chain
operator|)
condition|)
block|{
name|rtx
name|body
init|=
name|QUEUED_BODY
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|QUEUED_INSN
argument_list|(
name|p
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|QUEUED_BODY
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|QUEUED_BODY
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|QUEUED_INSN
argument_list|(
name|p
argument_list|)
operator|=
name|emit_insn
argument_list|(
name|QUEUED_BODY
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|pending_chain
operator|=
name|QUEUED_NEXT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy data from FROM to TO, where the machine modes are not the same.    Both modes may be integer, or both may be floating.    UNSIGNEDP should be nonzero if FROM is an unsigned type.    This causes zero-extension instead of sign-extension.  */
end_comment

begin_function
name|void
name|convert_move
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|machine_mode
name|to_mode
init|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|from_mode
init|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|int
name|to_real
init|=
name|GET_MODE_CLASS
argument_list|(
name|to_mode
argument_list|)
operator|==
name|MODE_FLOAT
decl_stmt|;
name|int
name|from_real
init|=
name|GET_MODE_CLASS
argument_list|(
name|from_mode
argument_list|)
operator|==
name|MODE_FLOAT
decl_stmt|;
name|enum
name|insn_code
name|code
decl_stmt|;
name|rtx
name|libcall
decl_stmt|;
comment|/* rtx code for making an equivalent value.  */
name|enum
name|rtx_code
name|equiv_code
init|=
operator|(
name|unsignedp
condition|?
name|ZERO_EXTEND
else|:
name|SIGN_EXTEND
operator|)
decl_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_real
operator|!=
name|from_real
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If FROM is a SUBREG that indicates that we have already done at least      the required extension, strip it.  We don't handle such SUBREGs as      TO here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
operator|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|from
argument_list|)
operator|==
name|unsignedp
condition|)
name|from
operator|=
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
operator|,
name|from_mode
operator|=
name|to_mode
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|to
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|to_mode
operator|==
name|from_mode
operator|||
operator|(
name|from_mode
operator|==
name|VOIDmode
operator|&&
name|CONSTANT_P
argument_list|(
name|from
argument_list|)
operator|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|to_mode
argument_list|)
operator|||
name|VECTOR_MODE_P
argument_list|(
name|from_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|to_mode
argument_list|)
condition|)
name|from
operator|=
name|simplify_gen_subreg
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|to
operator|=
name|simplify_gen_subreg
argument_list|(
name|from_mode
argument_list|,
name|to
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|to_real
operator|!=
name|from_real
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|to_real
condition|)
block|{
name|rtx
name|value
decl_stmt|,
name|insns
decl_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
condition|)
block|{
comment|/* Try converting directly if the insn is supported.  */
if|if
condition|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|from_mode
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_trunchfqf2
if|if
condition|(
name|HAVE_trunchfqf2
operator|&&
name|from_mode
operator|==
name|HFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunchfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctqfqf2
if|if
condition|(
name|HAVE_trunctqfqf2
operator|&&
name|from_mode
operator|==
name|TQFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctqfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncsfqf2
if|if
condition|(
name|HAVE_truncsfqf2
operator|&&
name|from_mode
operator|==
name|SFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdfqf2
if|if
condition|(
name|HAVE_truncdfqf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfqf2
if|if
condition|(
name|HAVE_truncxfqf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfqf2
if|if
condition|(
name|HAVE_trunctfqf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctqfhf2
if|if
condition|(
name|HAVE_trunctqfhf2
operator|&&
name|from_mode
operator|==
name|TQFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctqfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncsfhf2
if|if
condition|(
name|HAVE_truncsfhf2
operator|&&
name|from_mode
operator|==
name|SFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdfhf2
if|if
condition|(
name|HAVE_truncdfhf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfhf2
if|if
condition|(
name|HAVE_truncxfhf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfhf2
if|if
condition|(
name|HAVE_trunctfhf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncsftqf2
if|if
condition|(
name|HAVE_truncsftqf2
operator|&&
name|from_mode
operator|==
name|SFmode
operator|&&
name|to_mode
operator|==
name|TQFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsftqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdftqf2
if|if
condition|(
name|HAVE_truncdftqf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|TQFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdftqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxftqf2
if|if
condition|(
name|HAVE_truncxftqf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|TQFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxftqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctftqf2
if|if
condition|(
name|HAVE_trunctftqf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|TQFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctftqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdfsf2
if|if
condition|(
name|HAVE_truncdfsf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|SFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfsf2
if|if
condition|(
name|HAVE_truncxfsf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|SFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfsf2
if|if
condition|(
name|HAVE_trunctfsf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|SFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfdf2
if|if
condition|(
name|HAVE_truncxfdf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|DFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfdf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfdf2
if|if
condition|(
name|HAVE_trunctfdf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|DFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfdf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|libcall
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
switch|switch
condition|(
name|from_mode
condition|)
block|{
case|case
name|SFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|DFmode
case|:
name|libcall
operator|=
name|extendsfdf2_libfunc
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|libcall
operator|=
name|extendsfxf2_libfunc
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
name|libcall
operator|=
name|extendsftf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|DFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|libcall
operator|=
name|truncdfsf2_libfunc
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|libcall
operator|=
name|extenddfxf2_libfunc
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
name|libcall
operator|=
name|extenddftf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|XFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|libcall
operator|=
name|truncxfsf2_libfunc
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|libcall
operator|=
name|truncxfdf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|TFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|libcall
operator|=
name|trunctfsf2_libfunc
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|libcall
operator|=
name|trunctfdf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|libcall
operator|==
operator|(
name|rtx
operator|)
literal|0
condition|)
comment|/* This conversion is not implemented yet.  */
name|abort
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|libcall
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|to_mode
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|from_mode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|to
argument_list|,
name|value
argument_list|,
name|gen_rtx_FLOAT_TRUNCATE
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now both modes are integers.  */
comment|/* Handle expanding beyond a word.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|lowpart
decl_stmt|;
name|rtx
name|fill_value
decl_stmt|;
name|rtx
name|lowfrom
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|lowpart_mode
decl_stmt|;
name|int
name|nwords
init|=
name|CEIL
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
comment|/* Try converting directly if the insn is supported.  */
if|if
condition|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
comment|/* If FROM is a SUBREG, put it into a register.  Do this 	     so that we always generate the same set of insns for 	     better cse'ing; if an intermediate assignment occurred, 	     we won't be doing the operation directly on the SUBREG.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Next, try converting via full word.  */
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
operator|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|word_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REG
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|to
argument_list|)
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|to
argument_list|)
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* No special multiword conversion insn; do it by hand.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Since we will turn this into a no conflict block, we must ensure 	 that the source does not overlap the target.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
comment|/* Get a copy of FROM widened to a word, if necessary.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
name|lowpart_mode
operator|=
name|word_mode
expr_stmt|;
else|else
name|lowpart_mode
operator|=
name|from_mode
expr_stmt|;
name|lowfrom
operator|=
name|convert_to_mode
argument_list|(
name|lowpart_mode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|lowpart
operator|=
name|gen_lowpart
argument_list|(
name|lowpart_mode
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|lowpart
argument_list|,
name|lowfrom
argument_list|)
expr_stmt|;
comment|/* Compute the value to put in each remaining word.  */
if|if
condition|(
name|unsignedp
condition|)
name|fill_value
operator|=
name|const0_rtx
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_slt
if|if
condition|(
name|HAVE_slt
operator|&&
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_slt
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|==
name|word_mode
operator|&&
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|lowfrom
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|lowpart_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fill_value
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_slt
argument_list|(
name|fill_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|fill_value
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|lowpart_mode
argument_list|,
name|lowfrom
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|lowpart_mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fill_value
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|fill_value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fill the remaining words.  */
for|for
control|(
name|i
operator|=
name|GET_MODE_SIZE
argument_list|(
name|lowpart_mode
argument_list|)
operator|/
name|UNITS_PER_WORD
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|nwords
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
decl_stmt|;
name|rtx
name|subword
init|=
name|operand_subword
argument_list|(
name|to
argument_list|,
name|index
argument_list|,
literal|1
argument_list|,
name|to_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|subword
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fill_value
operator|!=
name|subword
condition|)
name|emit_move_insn
argument_list|(
name|subword
argument_list|,
name|fill_value
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|equiv_code
argument_list|,
name|to_mode
argument_list|,
name|copy_rtx
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Truncating multi-word to a word or less.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|>
name|BITS_PER_WORD
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<=
name|BITS_PER_WORD
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|from
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|to_mode
index|]
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|from
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle pointer conversion.  */
comment|/* SPEE 900220.  */
if|if
condition|(
name|to_mode
operator|==
name|PQImode
condition|)
block|{
if|if
condition|(
name|from_mode
operator|!=
name|QImode
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|QImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_truncqipqi2
if|if
condition|(
name|HAVE_truncqipqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncqipqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_truncqipqi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|from_mode
operator|==
name|PQImode
condition|)
block|{
if|if
condition|(
name|to_mode
operator|!=
name|QImode
condition|)
block|{
name|from
operator|=
name|convert_to_mode
argument_list|(
name|QImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|from_mode
operator|=
name|QImode
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extendpqiqi2
if|if
condition|(
name|HAVE_extendpqiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendpqiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_extendpqiqi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|to_mode
operator|==
name|PSImode
condition|)
block|{
if|if
condition|(
name|from_mode
operator|!=
name|SImode
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_truncsipsi2
if|if
condition|(
name|HAVE_truncsipsi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsipsi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_truncsipsi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|from_mode
operator|==
name|PSImode
condition|)
block|{
if|if
condition|(
name|to_mode
operator|!=
name|SImode
condition|)
block|{
name|from
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|from_mode
operator|=
name|SImode
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extendpsisi2
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|HAVE_extendpsisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendpsisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_extendpsisi2 */
ifdef|#
directive|ifdef
name|HAVE_zero_extendpsisi2
if|if
condition|(
name|unsignedp
operator|&&
name|HAVE_zero_extendpsisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_zero_extendpsisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_zero_extendpsisi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|to_mode
operator|==
name|PDImode
condition|)
block|{
if|if
condition|(
name|from_mode
operator|!=
name|DImode
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|DImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_truncdipdi2
if|if
condition|(
name|HAVE_truncdipdi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdipdi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_truncdipdi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|from_mode
operator|==
name|PDImode
condition|)
block|{
if|if
condition|(
name|to_mode
operator|!=
name|DImode
condition|)
block|{
name|from
operator|=
name|convert_to_mode
argument_list|(
name|DImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|from_mode
operator|=
name|DImode
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extendpdidi2
if|if
condition|(
name|HAVE_extendpdidi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendpdidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_extendpdidi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now follow all the conversions between integers      no more than a word long.  */
comment|/* For truncation, usually we can just refer to FROM in a narrower mode.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|from
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|to_mode
index|]
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|from
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|from
argument_list|)
argument_list|,
name|to_mode
argument_list|)
condition|)
name|from
operator|=
name|copy_to_reg
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle extension.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
condition|)
block|{
comment|/* Convert directly if that works.  */
if|if
condition|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|flag_force_mem
condition|)
name|from
operator|=
name|force_not_mem
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|enum
name|machine_mode
name|intermediate
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|tree
name|shift_amount
decl_stmt|;
comment|/* Search for a mode to convert via.  */
for|for
control|(
name|intermediate
operator|=
name|from_mode
init|;
name|intermediate
operator|!=
name|VOIDmode
condition|;
name|intermediate
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|intermediate
argument_list|)
control|)
if|if
condition|(
operator|(
operator|(
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|intermediate
argument_list|,
name|unsignedp
argument_list|)
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|intermediate
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|intermediate
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|can_extend_p
argument_list|(
name|intermediate
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|convert_move
argument_list|(
name|to
argument_list|,
name|convert_to_mode
argument_list|(
name|intermediate
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* No suitable intermediate mode. 	     Generate what we need with	shifts.  */
name|shift_amount
operator|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|from
operator|=
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|to_mode
argument_list|,
name|from
argument_list|,
name|shift_amount
argument_list|,
name|to
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|to_mode
argument_list|,
name|tmp
argument_list|,
name|shift_amount
argument_list|,
name|to
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|to
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Support special truncate insns for certain modes.  */
if|if
condition|(
name|from_mode
operator|==
name|DImode
operator|&&
name|to_mode
operator|==
name|SImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncdisi2
if|if
condition|(
name|HAVE_truncdisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|DImode
operator|&&
name|to_mode
operator|==
name|HImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncdihi2
if|if
condition|(
name|HAVE_truncdihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|DImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncdiqi2
if|if
condition|(
name|HAVE_truncdiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|SImode
operator|&&
name|to_mode
operator|==
name|HImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncsihi2
if|if
condition|(
name|HAVE_truncsihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|SImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncsiqi2
if|if
condition|(
name|HAVE_truncsiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|HImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunchiqi2
if|if
condition|(
name|HAVE_trunchiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunchiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|DImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctidi2
if|if
condition|(
name|HAVE_trunctidi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|SImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctisi2
if|if
condition|(
name|HAVE_trunctisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|HImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctihi2
if|if
condition|(
name|HAVE_trunctihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctiqi2
if|if
condition|(
name|HAVE_trunctiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle truncation of volatile memrefs, and so on;      the things that couldn't be truncated directly,      and for which there was no special instruction.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|force_reg
argument_list|(
name|to_mode
argument_list|,
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Mode combination is not recognized.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an rtx for a value that would result    from converting X to mode MODE.    Both X and MODE may be floating, or both integer.    UNSIGNEDP is nonzero if X is an unsigned value.    This can be done by referring to a part of X in place    or by copying to a new temporary with conversion.     This function *must not* call protect_from_queue    except when putting X into an insn (in which case convert_move does it).  */
end_comment

begin_function
name|rtx
name|convert_to_mode
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
return|return
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx for a value that would result    from converting X from mode OLDMODE to mode MODE.    Both modes may be floating, or both integer.    UNSIGNEDP is nonzero if X is an unsigned value.     This can be done by referring to a part of X in place    or by copying to a new temporary with conversion.     You can give VOIDmode for OLDMODE, if you are sure X has a nonvoid mode.     This function *must not* call protect_from_queue    except when putting X into an insn (in which case convert_move does it).  */
end_comment

begin_function
name|rtx
name|convert_modes
parameter_list|(
name|mode
parameter_list|,
name|oldmode
parameter_list|,
name|x
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|oldmode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* If FROM is a SUBREG that indicates that we have already done at least      the required extension, strip it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|x
argument_list|)
operator|==
name|unsignedp
condition|)
name|x
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|oldmode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|oldmode
condition|)
return|return
name|x
return|;
comment|/* There is one case that we must handle specially: If we are converting      a CONST_INT into a mode whose size is twice HOST_BITS_PER_WIDE_INT and      we are to interpret the constant as unsigned, gen_lowpart will do      the wrong if the constant appears negative.  What we want to do is      make the high-order word of the constant zero, not all ones.  */
if|if
condition|(
name|unsignedp
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldmode
operator|!=
name|VOIDmode
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|oldmode
argument_list|)
condition|)
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|oldmode
argument_list|)
decl_stmt|;
comment|/* We need to zero extend VAL.  */
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|val
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* We can do this with a gen_lowpart if both desired and current modes      are integer, and this is either a constant integer, a register, or a      non-volatile MEM.  Except for the constant case where MODE is no      wider than HOST_BITS_PER_WIDE_INT, we must be narrowing the operand.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|oldmode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|oldmode
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* ?? If we don't know OLDMODE, we have to assume here that 	 X does not need sign- or zero-extension.   This may not be 	 the case, but it's the best we can do.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|oldmode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|oldmode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|oldmode
argument_list|)
decl_stmt|;
comment|/* We must sign or zero-extend in this case.  Start by 	     zero-extending, then sign extend if we need to.  */
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|unsignedp
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
block|}
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This macro is used to determine what the largest unit size that    move_by_pieces can use is.  */
end_comment

begin_comment
comment|/* MOVE_MAX_PIECES is the number of bytes at a time which we can    move efficiently, as opposed to  MOVE_MAX which is the maximum    number of bytes we can move with a single instruction.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MOVE_MAX_PIECES
end_ifndef

begin_define
define|#
directive|define
name|MOVE_MAX_PIECES
value|MOVE_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate several move instructions to copy LEN bytes from block FROM to    block TO.  (These are MEM rtx's with BLKmode).  The caller must pass FROM    and TO through protect_from_queue before calling.     If PUSH_ROUNDING is defined and TO is NULL, emit_single_push_insn is    used to push FROM to the stack.     ALIGN is maximum alignment we can assume.  */
end_comment

begin_function
name|void
name|move_by_pieces
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|len
parameter_list|,
name|align
parameter_list|)
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
block|{
name|struct
name|move_by_pieces
name|data
decl_stmt|;
name|rtx
name|to_addr
decl_stmt|,
name|from_addr
init|=
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|max_size
init|=
name|MOVE_MAX_PIECES
operator|+
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|data
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|from_addr
operator|=
name|from_addr
expr_stmt|;
if|if
condition|(
name|to
condition|)
block|{
name|to_addr
operator|=
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|.
name|reverse
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
block|}
else|else
block|{
name|to_addr
operator|=
name|NULL_RTX
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|NULL_RTX
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|data
operator|.
name|reverse
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|data
operator|.
name|reverse
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|data
operator|.
name|to_addr
operator|=
name|to_addr
expr_stmt|;
name|data
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
operator|(
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|reverse
condition|)
name|data
operator|.
name|offset
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
comment|/* If copying requires more than two move insns,      copy addresses to registers (to make displacements shorter)      and use post-increment if available.  */
if|if
condition|(
operator|!
operator|(
name|data
operator|.
name|autinc_from
operator|&&
name|data
operator|.
name|autinc_to
operator|)
operator|&&
name|move_by_pieces_ninsns
argument_list|(
name|len
argument_list|,
name|align
argument_list|)
operator|>
literal|2
condition|)
block|{
comment|/* Find the mode of the largest move...  */
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|USE_LOAD_PRE_DECREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_from
condition|)
block|{
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|from_addr
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|USE_LOAD_POST_INCREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|data
operator|.
name|autinc_from
condition|)
block|{
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_from
operator|&&
name|CONSTANT_P
argument_list|(
name|from_addr
argument_list|)
condition|)
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|USE_STORE_PRE_DECREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|to_addr
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|USE_STORE_POST_INCREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_to
operator|&&
name|CONSTANT_P
argument_list|(
name|to_addr
argument_list|)
condition|)
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|word_mode
argument_list|,
name|align
argument_list|)
operator|||
name|align
operator|>
name|MOVE_MAX
operator|*
name|BITS_PER_UNIT
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
condition|)
name|align
operator|=
name|MOVE_MAX
operator|*
name|BITS_PER_UNIT
expr_stmt|;
comment|/* First move what we can in the largest integer mode, then go to      successively smaller modes.  */
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
condition|)
name|move_by_pieces_1
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|,
name|mode
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The code above should have handled everything.  */
if|if
condition|(
name|data
operator|.
name|len
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return number of insns required to move L bytes by pieces.    ALIGN (in bits) is maximum alignment we can assume.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|move_by_pieces_ninsns
parameter_list|(
name|l
parameter_list|,
name|align
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|n_insns
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max_size
init|=
name|MOVE_MAX
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|word_mode
argument_list|,
name|align
argument_list|)
operator|||
name|align
operator|>
name|MOVE_MAX
operator|*
name|BITS_PER_UNIT
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
condition|)
name|align
operator|=
name|MOVE_MAX
operator|*
name|BITS_PER_UNIT
expr_stmt|;
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
condition|)
name|n_insns
operator|+=
name|l
operator|/
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|,
name|l
operator|%=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|n_insns
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of move_by_pieces.  Move as many bytes as appropriate    with move instructions for mode MODE.  GENFUN is the gen_... function    to make a move insn for that mode.  DATA has all the other info.  */
end_comment

begin_function_decl
specifier|static
name|void
name|move_by_pieces_1
parameter_list|(
name|genfun
parameter_list|,
name|mode
parameter_list|,
name|data
parameter_list|)
function_decl|rtx
parameter_list|(
function_decl|*genfun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|move_by_pieces
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|to1
init|=
name|NULL_RTX
decl_stmt|,
name|from1
decl_stmt|;
while|while
condition|(
name|data
operator|->
name|len
operator|>=
name|size
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|to
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|autinc_to
condition|)
name|to1
operator|=
name|adjust_automodify_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|to_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|to1
operator|=
name|adjust_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|autinc_from
condition|)
name|from1
operator|=
name|adjust_automodify_address
argument_list|(
name|data
operator|->
name|from
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|from_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|from1
operator|=
name|adjust_address
argument_list|(
name|data
operator|->
name|from
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|data
operator|->
name|explicit_inc_from
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|to
condition|)
name|emit_insn
argument_list|(
call|(
modifier|*
name|genfun
call|)
argument_list|(
name|to1
argument_list|,
name|from1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|emit_single_push_insn
argument_list|(
name|mode
argument_list|,
name|from1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|data
operator|->
name|explicit_inc_from
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
name|data
operator|->
name|len
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Emit code to move a block Y to a block X.    This may be done with string-move instructions,    with multiple scalar move instructions, or with a library call.     Both X and Y must be MEM rtx's (perhaps inside VOLATILE)    with mode BLKmode.    SIZE is an rtx that says how long they are.    ALIGN is the maximum alignment we can assume they have.     Return the address of the new block, if memcpy is called and returns it,    0 otherwise.  */
end_comment

begin_function
name|rtx
name|emit_block_move
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|size
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|rtx
name|size
decl_stmt|;
block|{
name|rtx
name|retval
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
specifier|static
name|tree
name|fn
decl_stmt|;
name|tree
name|call_expr
decl_stmt|,
name|arg_list
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|align
init|=
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|y
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|!=
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
name|protect_from_queue
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|MOVE_BY_PIECES_P
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
condition|)
name|move_by_pieces
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Try the most limited insn first, because there's no point 	 including more than one in the machine description unless 	 the more limited one has some advantage.  */
name|rtx
name|opalign
init|=
name|GEN_INT
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Since this is a move insn, we don't care about volatility.  */
name|volatile_ok
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|enum
name|insn_code
name|code
init|=
name|movstr_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
name|insn_operand_predicate_fn
name|pred
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
comment|/* We don't need MODE to be narrower than BITS_PER_HOST_WIDE_INT 		 here because if SIZE is less than the mode mask, as it is 		 returned by the macro, it will definitely be less than the 		 actual mode mask.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|)
operator|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|BITS_PER_WORD
operator|)
operator|&&
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|==
literal|0
operator|||
call|(
modifier|*
name|pred
call|)
argument_list|(
name|x
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|==
literal|0
operator|||
call|(
modifier|*
name|pred
call|)
argument_list|(
name|y
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|==
literal|0
operator|||
call|(
modifier|*
name|pred
call|)
argument_list|(
name|opalign
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|op2
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|op2
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
expr_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|pred
call|)
argument_list|(
name|op2
argument_list|,
name|mode
argument_list|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
operator|(
name|int
operator|)
name|code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|op2
argument_list|,
name|opalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|volatile_ok
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
name|volatile_ok
operator|=
literal|0
expr_stmt|;
comment|/* X, Y, or SIZE may have been passed through protect_from_queue.  	 It is unsafe to save the value generated by protect_from_queue 	 and reuse it later.  Consider what happens if emit_queue is 	 called before the return value from protect_from_queue is used.  	 Expansion of the CALL_EXPR below will call emit_queue before 	 we are finished emitting RTL for argument setup.  So if we are 	 not careful we could get the wrong value for an argument.  	 To avoid this problem we go ahead and emit code to copy X, Y& 	 SIZE into new pseudos.  We can then place those new pseudos 	 into an RTL_EXPR and use them later, even after a call to 	 emit_queue.  	 Note this is not strictly needed for library calls since they 	 do not call emit_queue before loading their arguments.  However, 	 we may need to have library calls call emit_queue in the future 	 since failing to do so could cause problems for targets which 	 define SMALL_REGISTER_CLASSES and pass arguments in registers.  */
name|x
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
name|size
operator|=
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
comment|/* It is incorrect to use the libcall calling conventions to call 	 memcpy in this context.  	 This could be a user call to memcpy and the user may wish to 	 examine the return value from memcpy.  	 For targets where libcalls and normal calls have different conventions 	 for returning pointers, we could end up generating incorrect code.  	 So instead of using a libcall sequence we build up a suitable 	 CALL_EXPR and expand the call in the normal fashion.  */
if|if
condition|(
name|fn
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|fntype
decl_stmt|;
comment|/* This was copied from except.c, I don't know if all this is 	     necessary in this context or not.  */
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"memcpy"
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_function_type
argument_list|(
name|fntype
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|fntype
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|fn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* We need to make an argument list for the function call.  	 memcpy has three arguments, the first two are void * addresses and 	 the last is a size_t byte count for the copy.  */
name|arg_list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now we have to build up the CALL_EXPR itself.  */
name|call_expr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|call_expr
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|call_expr
argument_list|,
name|arg_list
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|call_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|expand_expr
argument_list|(
name|call_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bcopy_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|y
argument_list|,
name|Pmode
argument_list|,
name|x
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we are initializing a readonly value, show the above call 	 clobbered it.  Otherwise, a load from it may erroneously be hoisted 	 from a loop.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy all or part of a value X into registers starting at REGNO.    The number of registers to be filled is NREGS.  */
end_comment

begin_function
name|void
name|move_block_to_reg
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|,
name|nregs
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_load_multiple
name|rtx
name|pat
decl_stmt|;
name|rtx
name|last
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if the machine can do this with a load multiple insn.  */
ifdef|#
directive|ifdef
name|HAVE_load_multiple
if|if
condition|(
name|HAVE_load_multiple
condition|)
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pat
operator|=
name|gen_load_multiple
argument_list|(
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|nregs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|operand_subword_force
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy all or part of a BLKmode value X out of registers starting at REGNO.    The number of registers to be filled is NREGS.  SIZE indicates the number    of bytes in the object X.  */
end_comment

begin_function
name|void
name|move_block_from_reg
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|,
name|nregs
parameter_list|,
name|size
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_store_multiple
name|rtx
name|pat
decl_stmt|;
name|rtx
name|last
decl_stmt|;
endif|#
directive|endif
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
return|return;
comment|/* If SIZE is that of a mode no bigger than a word, just use that      mode's store operation.  */
if|if
condition|(
name|size
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|mode
operator|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|BLKmode
operator|&&
operator|!
name|FUNCTION_ARG_REG_LITTLE_ENDIAN
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Blocks smaller than a word on a BYTES_BIG_ENDIAN machine must be aligned      to the left before storing to memory.  Note that the previous test      doesn't handle all cases (e.g. SIZE == 3).  */
if|if
condition|(
name|size
operator|<
name|UNITS_PER_WORD
operator|&&
name|BYTES_BIG_ENDIAN
operator|&&
operator|!
name|FUNCTION_ARG_REG_LITTLE_ENDIAN
condition|)
block|{
name|rtx
name|tem
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BLKmode
argument_list|)
decl_stmt|;
name|rtx
name|shift
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|shift
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
operator|(
name|UNITS_PER_WORD
operator|-
name|size
operator|)
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|shift
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* See if the machine can do this with a store multiple insn.  */
ifdef|#
directive|ifdef
name|HAVE_store_multiple
if|if
condition|(
name|HAVE_store_multiple
condition|)
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pat
operator|=
name|gen_store_multiple
argument_list|(
name|x
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|nregs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|BLKmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to move a block SRC to a block DST, where DST is non-consecutive    registers represented by a PARALLEL.  SSIZE represents the total size of    block SRC in bytes, or -1 if not known.  */
end_comment

begin_comment
comment|/* ??? If SSIZE % UNITS_PER_WORD != 0, we make the blatant assumption that    the balance will be in what would be the low-order memory addresses, i.e.    left justified for big endian, right justified for little endian.  This    happens to be true for the targets currently using this support.  If this    ever changes, a new target macro along the lines of FUNCTION_ARG_PADDING    would be needed.  */
end_comment

begin_function
name|void
name|emit_group_load
parameter_list|(
name|dst
parameter_list|,
name|orig_src
parameter_list|,
name|ssize
parameter_list|)
name|rtx
name|dst
decl_stmt|,
name|orig_src
decl_stmt|;
name|int
name|ssize
decl_stmt|;
block|{
name|rtx
modifier|*
name|tmps
decl_stmt|,
name|src
decl_stmt|;
name|int
name|start
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check for a NULL entry, used to indicate that the parameter goes      both on the stack and in registers.  */
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
name|start
operator|=
literal|1
expr_stmt|;
name|tmps
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process the pieces.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bytepos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bytelen
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
comment|/* Handle trailing fragments that run over the size of the struct.  */
if|if
condition|(
name|ssize
operator|>=
literal|0
operator|&&
name|bytepos
operator|+
operator|(
name|HOST_WIDE_INT
operator|)
name|bytelen
operator|>
name|ssize
condition|)
block|{
name|shift
operator|=
operator|(
name|bytelen
operator|-
operator|(
name|ssize
operator|-
name|bytepos
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|bytelen
operator|=
name|ssize
operator|-
name|bytepos
expr_stmt|;
if|if
condition|(
name|bytelen
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If we won't be loading directly from memory, protect the real source 	 from strange tricks we might play; but make sure that the source can 	 be loaded directly into the destination.  */
name|src
operator|=
name|orig_src
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig_src
argument_list|)
operator|!=
name|MEM
operator|&&
operator|(
operator|!
name|CONSTANT_P
argument_list|(
name|orig_src
argument_list|)
operator|||
operator|(
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
operator|!=
name|VOIDmode
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
operator|==
name|VOIDmode
condition|)
name|src
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|src
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|src
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
block|}
comment|/* Optimize the access just a bit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_ALIGN
argument_list|(
name|src
argument_list|)
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|bytepos
operator|*
name|BITS_PER_UNIT
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|==
literal|0
operator|&&
name|bytelen
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|,
name|adjust_address
argument_list|(
name|src
argument_list|,
name|mode
argument_list|,
name|bytepos
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
if|if
condition|(
operator|(
name|bytepos
operator|==
literal|0
operator|&&
name|bytelen
operator|==
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|bytepos
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|bytelen
operator|==
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tmps
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
name|bytepos
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|)
operator|!=
name|mode
operator|)
condition|)
name|tmps
index|[
name|i
index|]
operator|=
name|extract_bit_field
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|,
name|bytelen
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytepos
operator|==
literal|0
condition|)
block|{
name|rtx
name|mem
init|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|tmps
index|[
name|i
index|]
operator|=
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|mode
operator|)
condition|)
name|tmps
index|[
name|i
index|]
operator|=
name|src
expr_stmt|;
else|else
name|tmps
index|[
name|i
index|]
operator|=
name|extract_bit_field
argument_list|(
name|src
argument_list|,
name|bytelen
operator|*
name|BITS_PER_UNIT
argument_list|,
name|bytepos
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|shift
condition|)
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashl_optab
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|shift
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Copy the extracted pieces into the proper (probable) hard regs.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to move a block SRC to a block DST, where SRC is non-consecutive    registers represented by a PARALLEL.  SSIZE represents the total size of    block DST, or -1 if not known.  */
end_comment

begin_function
name|void
name|emit_group_store
parameter_list|(
name|orig_dst
parameter_list|,
name|src
parameter_list|,
name|ssize
parameter_list|)
name|rtx
name|orig_dst
decl_stmt|,
name|src
decl_stmt|;
name|int
name|ssize
decl_stmt|;
block|{
name|rtx
modifier|*
name|tmps
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|start
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check for a NULL entry, used to indicate that the parameter goes      both on the stack and in registers.  */
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
name|start
operator|=
literal|1
expr_stmt|;
name|tmps
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the (probable) hard regs into pseudos.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* If we won't be storing directly into memory, protect the real destination      from strange tricks we might play.  */
name|dst
operator|=
name|orig_dst
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* We can get a PARALLEL dst if there is a conditional expression in 	 a return statement.  In that case, the dst and src are the same, 	 so no action is necessary.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
condition|)
return|return;
comment|/* It is unclear if we can ever reach here, but we may as well handle 	 it.  Allocate a temporary, and split this into a store/load to/from 	 the temporary.  */
name|temp
operator|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|ssize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_group_store
argument_list|(
name|temp
argument_list|,
name|src
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
name|emit_group_load
argument_list|(
name|dst
argument_list|,
name|temp
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|CONCAT
condition|)
block|{
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|orig_dst
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make life a bit easier for combine.  */
name|emit_move_insn
argument_list|(
name|dst
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* Process the pieces.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|HOST_WIDE_INT
name|bytepos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bytelen
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|dst
decl_stmt|;
comment|/* Handle trailing fragments that run over the size of the struct.  */
if|if
condition|(
name|ssize
operator|>=
literal|0
operator|&&
name|bytepos
operator|+
operator|(
name|HOST_WIDE_INT
operator|)
name|bytelen
operator|>
name|ssize
condition|)
block|{
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|int
name|shift
init|=
operator|(
name|bytelen
operator|-
operator|(
name|ssize
operator|-
name|bytepos
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashr_optab
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|shift
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
name|bytelen
operator|=
name|ssize
operator|-
name|bytepos
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
if|if
condition|(
name|bytepos
operator|+
name|bytelen
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bytepos
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|bytepos
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Optimize the access just a bit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_ALIGN
argument_list|(
name|dest
argument_list|)
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|bytepos
operator|*
name|BITS_PER_UNIT
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|==
literal|0
operator|&&
name|bytelen
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|,
name|bytepos
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|store_bit_field
argument_list|(
name|dest
argument_list|,
name|bytelen
operator|*
name|BITS_PER_UNIT
argument_list|,
name|bytepos
operator|*
name|BITS_PER_UNIT
argument_list|,
name|mode
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Copy from the pseudo into the (probable) hard reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|REG
condition|)
name|emit_move_insn
argument_list|(
name|orig_dst
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to copy a BLKmode object of TYPE out of a    set of registers starting with SRCREG into TGTBLK.  If TGTBLK    is null, a stack temporary is created.  TGTBLK is returned.     The primary purpose of this routine is to handle functions    that return BLKmode structures in registers.  Some machines    (the PA for example) want to return all small structures    in registers regardless of the structure's alignment.  */
end_comment

begin_function
name|rtx
name|copy_blkmode_from_reg
parameter_list|(
name|tgtblk
parameter_list|,
name|srcreg
parameter_list|,
name|type
parameter_list|)
name|rtx
name|tgtblk
decl_stmt|;
name|rtx
name|srcreg
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|NULL
decl_stmt|,
name|dst
init|=
name|NULL
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bitsize
init|=
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|,
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bitpos
decl_stmt|,
name|xbitpos
decl_stmt|,
name|big_endian_correction
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tgtblk
operator|==
literal|0
condition|)
block|{
name|tgtblk
operator|=
name|assign_temp
argument_list|(
name|build_qualified_type
argument_list|(
name|type
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|tgtblk
argument_list|)
expr_stmt|;
block|}
comment|/* This code assumes srcreg is at least a full word.  If it isn't, copy it      into a new pseudo which is a full word.       If FUNCTION_ARG_REG_LITTLE_ENDIAN is set and convert_to_mode does a copy,      the wrong part of the register gets copied so we fake a type conversion      in place.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|srcreg
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|srcreg
argument_list|)
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
block|{
if|if
condition|(
name|FUNCTION_ARG_REG_LITTLE_ENDIAN
condition|)
name|srcreg
operator|=
name|simplify_gen_subreg
argument_list|(
name|word_mode
argument_list|,
name|srcreg
argument_list|,
name|GET_MODE
argument_list|(
name|srcreg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|srcreg
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|srcreg
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Structures whose size is not a multiple of a word are aligned      to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN      machine, this means we must skip the empty high order bytes when      calculating the bit offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
operator|!
name|FUNCTION_ARG_REG_LITTLE_ENDIAN
operator|&&
name|bytes
operator|%
name|UNITS_PER_WORD
condition|)
name|big_endian_correction
operator|=
operator|(
name|BITS_PER_WORD
operator|-
operator|(
operator|(
name|bytes
operator|%
name|UNITS_PER_WORD
operator|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* Copy the structure BITSIZE bites at a time.       We could probably emit more efficient code for machines which do not use      strict alignment, but it doesn't seem worth the effort at the current      time.  */
for|for
control|(
name|bitpos
operator|=
literal|0
operator|,
name|xbitpos
operator|=
name|big_endian_correction
init|;
name|bitpos
operator|<
name|bytes
operator|*
name|BITS_PER_UNIT
condition|;
name|bitpos
operator|+=
name|bitsize
operator|,
name|xbitpos
operator|+=
name|bitsize
control|)
block|{
comment|/* We need a new source operand each time xbitpos is on a 	 word boundary and when xbitpos == big_endian_correction 	 (the first time through).  */
if|if
condition|(
name|xbitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|||
name|xbitpos
operator|==
name|big_endian_correction
condition|)
name|src
operator|=
name|operand_subword_force
argument_list|(
name|srcreg
argument_list|,
name|xbitpos
operator|/
name|BITS_PER_WORD
argument_list|,
name|GET_MODE
argument_list|(
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need a new destination operand each time bitpos is on 	 a word boundary.  */
if|if
condition|(
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
condition|)
name|dst
operator|=
name|operand_subword
argument_list|(
name|tgtblk
argument_list|,
name|bitpos
operator|/
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
comment|/* Use xbitpos for the source extraction (right justified) and 	 xbitpos for the destination store (left justified).  */
name|store_bit_field
argument_list|(
name|dst
argument_list|,
name|bitsize
argument_list|,
name|bitpos
operator|%
name|BITS_PER_WORD
argument_list|,
name|word_mode
argument_list|,
name|extract_bit_field
argument_list|(
name|src
argument_list|,
name|bitsize
argument_list|,
name|xbitpos
operator|%
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|,
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
return|return
name|tgtblk
return|;
block|}
end_function

begin_comment
comment|/* Add a USE expression for REG to the (possibly empty) list pointed    to by CALL_FUSAGE.  REG must denote a hard register.  */
end_comment

begin_function
name|void
name|use_reg
parameter_list|(
name|call_fusage
parameter_list|,
name|reg
parameter_list|)
name|rtx
modifier|*
name|call_fusage
decl_stmt|,
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|call_fusage
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|,
operator|*
name|call_fusage
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add USE expressions to *CALL_FUSAGE for each of NREGS consecutive regs,    starting at REGNO.  All of these registers must be hard registers.  */
end_comment

begin_function
name|void
name|use_regs
parameter_list|(
name|call_fusage
parameter_list|,
name|regno
parameter_list|,
name|nregs
parameter_list|)
name|rtx
modifier|*
name|call_fusage
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regno
operator|+
name|nregs
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add USE expressions to *CALL_FUSAGE for each REG contained in the    PARALLEL REGS.  This is for calls that pass values in multiple    non-contiguous locations.  The Irix 6 ABI has examples of this.  */
end_comment

begin_function
name|void
name|use_group_regs
parameter_list|(
name|call_fusage
parameter_list|,
name|regs
parameter_list|)
name|rtx
modifier|*
name|call_fusage
decl_stmt|;
name|rtx
name|regs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* A NULL entry means the parameter goes both on the stack and in 	 registers.  This can also be a MEM for targets that pass values 	 partially on the stack and partially in registers.  */
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function_decl
name|int
name|can_store_by_pieces
parameter_list|(
name|len
parameter_list|,
name|constfun
parameter_list|,
name|constfundata
parameter_list|,
name|align
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|len
decl_stmt|;
function_decl|rtx
parameter_list|(
function_decl|*constfun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|HOST_WIDE_INT
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|constfundata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|align
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|HOST_WIDE_INT
name|max_size
decl_stmt|,
name|l
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|rtx
name|cst
decl_stmt|;
if|if
condition|(
operator|!
name|MOVE_BY_PIECES_P
argument_list|(
name|len
argument_list|,
name|align
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|word_mode
argument_list|,
name|align
argument_list|)
operator|||
name|align
operator|>
name|MOVE_MAX
operator|*
name|BITS_PER_UNIT
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
condition|)
name|align
operator|=
name|MOVE_MAX
operator|*
name|BITS_PER_UNIT
expr_stmt|;
comment|/* We would first store what we can in the largest integer mode, then go to      successively smaller modes.  */
for|for
control|(
name|reverse
operator|=
literal|0
init|;
name|reverse
operator|<=
operator|(
name|HAVE_PRE_DECREMENT
operator|||
name|HAVE_POST_DECREMENT
operator|)
condition|;
name|reverse
operator|++
control|)
block|{
name|l
operator|=
name|len
expr_stmt|;
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|max_size
operator|=
name|MOVE_MAX_PIECES
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
while|while
condition|(
name|l
operator|>=
name|size
condition|)
block|{
if|if
condition|(
name|reverse
condition|)
name|offset
operator|-=
name|size
expr_stmt|;
name|cst
operator|=
call|(
modifier|*
name|constfun
call|)
argument_list|(
name|constfundata
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|cst
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|reverse
condition|)
name|offset
operator|+=
name|size
expr_stmt|;
name|l
operator|-=
name|size
expr_stmt|;
block|}
block|}
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The code above should have handled everything.  */
if|if
condition|(
name|l
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Generate several move instructions to store LEN bytes generated by    CONSTFUN to block TO.  (A MEM rtx with BLKmode).  CONSTFUNDATA is a    pointer which will be passed as argument in every CONSTFUN call.    ALIGN is maximum alignment we can assume.  */
end_comment

begin_function_decl
name|void
name|store_by_pieces
parameter_list|(
name|to
parameter_list|,
name|len
parameter_list|,
name|constfun
parameter_list|,
name|constfundata
parameter_list|,
name|align
parameter_list|)
name|rtx
name|to
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
decl_stmt|;
function_decl|rtx
parameter_list|(
function_decl|*constfun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|HOST_WIDE_INT
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|constfundata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|align
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|store_by_pieces
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|MOVE_BY_PIECES_P
argument_list|(
name|len
argument_list|,
name|align
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|data
operator|.
name|constfun
operator|=
name|constfun
expr_stmt|;
name|data
operator|.
name|constfundata
operator|=
name|constfundata
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|store_by_pieces_1
argument_list|(
operator|&
name|data
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Generate several move instructions to clear LEN bytes of block TO.  (A MEM    rtx with BLKmode).  The caller must pass TO through protect_from_queue    before calling. ALIGN is maximum alignment we can assume.  */
end_comment

begin_function
specifier|static
name|void
name|clear_by_pieces
parameter_list|(
name|to
parameter_list|,
name|len
parameter_list|,
name|align
parameter_list|)
name|rtx
name|to
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
block|{
name|struct
name|store_by_pieces
name|data
decl_stmt|;
name|data
operator|.
name|constfun
operator|=
name|clear_by_pieces_1
expr_stmt|;
name|data
operator|.
name|constfundata
operator|=
name|NULL
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|store_by_pieces_1
argument_list|(
operator|&
name|data
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback routine for clear_by_pieces.    Return const0_rtx unconditionally.  */
end_comment

begin_function
specifier|static
name|rtx
name|clear_by_pieces_1
parameter_list|(
name|data
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|offset
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of clear_by_pieces and store_by_pieces.    Generate several move instructions to store LEN bytes of block TO.  (A MEM    rtx with BLKmode).  The caller must pass TO through protect_from_queue    before calling.  ALIGN is maximum alignment we can assume.  */
end_comment

begin_function
specifier|static
name|void
name|store_by_pieces_1
parameter_list|(
name|data
parameter_list|,
name|align
parameter_list|)
name|struct
name|store_by_pieces
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
block|{
name|rtx
name|to_addr
init|=
name|XEXP
argument_list|(
name|data
operator|->
name|to
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max_size
init|=
name|MOVE_MAX_PIECES
operator|+
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|data
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|to_addr
operator|=
name|to_addr
expr_stmt|;
name|data
operator|->
name|autinc_to
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|->
name|explicit_inc_to
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|reverse
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|=
name|data
operator|->
name|len
expr_stmt|;
comment|/* If storing requires more than two move insns,      copy addresses to registers (to make displacements shorter)      and use post-increment if available.  */
if|if
condition|(
operator|!
name|data
operator|->
name|autinc_to
operator|&&
name|move_by_pieces_ninsns
argument_list|(
name|data
operator|->
name|len
argument_list|,
name|align
argument_list|)
operator|>
literal|2
condition|)
block|{
comment|/* Determine the main mode we'll be using.  */
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|USE_STORE_PRE_DECREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|data
operator|->
name|reverse
operator|&&
operator|!
name|data
operator|->
name|autinc_to
condition|)
block|{
name|data
operator|->
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|to_addr
argument_list|,
name|data
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|->
name|explicit_inc_to
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|USE_STORE_POST_INCREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|data
operator|->
name|reverse
operator|&&
operator|!
name|data
operator|->
name|autinc_to
condition|)
block|{
name|data
operator|->
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
name|data
operator|->
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|->
name|explicit_inc_to
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
operator|->
name|autinc_to
operator|&&
name|CONSTANT_P
argument_list|(
name|to_addr
argument_list|)
condition|)
name|data
operator|->
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|word_mode
argument_list|,
name|align
argument_list|)
operator|||
name|align
operator|>
name|MOVE_MAX
operator|*
name|BITS_PER_UNIT
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
condition|)
name|align
operator|=
name|MOVE_MAX
operator|*
name|BITS_PER_UNIT
expr_stmt|;
comment|/* First store what we can in the largest integer mode, then go to      successively smaller modes.  */
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
condition|)
name|store_by_pieces_2
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|,
name|mode
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The code above should have handled everything.  */
if|if
condition|(
name|data
operator|->
name|len
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of store_by_pieces_1.  Store as many bytes as appropriate    with move instructions for mode MODE.  GENFUN is the gen_... function    to make a move insn for that mode.  DATA has all the other info.  */
end_comment

begin_function_decl
specifier|static
name|void
name|store_by_pieces_2
parameter_list|(
name|genfun
parameter_list|,
name|mode
parameter_list|,
name|data
parameter_list|)
function_decl|rtx
parameter_list|(
function_decl|*genfun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|store_by_pieces
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|to1
decl_stmt|,
name|cst
decl_stmt|;
while|while
condition|(
name|data
operator|->
name|len
operator|>=
name|size
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|autinc_to
condition|)
name|to1
operator|=
name|adjust_automodify_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|to_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|to1
operator|=
name|adjust_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cst
operator|=
call|(
modifier|*
name|data
operator|->
name|constfun
call|)
argument_list|(
name|data
operator|->
name|constfundata
argument_list|,
name|data
operator|->
name|offset
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|genfun
call|)
argument_list|(
name|to1
argument_list|,
name|cst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
name|data
operator|->
name|len
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Write zeros through the storage of OBJECT.  If OBJECT has BLKmode, SIZE is    its length in bytes.  */
end_comment

begin_function
name|rtx
name|clear_storage
parameter_list|(
name|object
parameter_list|,
name|size
parameter_list|)
name|rtx
name|object
decl_stmt|;
name|rtx
name|size
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
specifier|static
name|tree
name|fn
decl_stmt|;
name|tree
name|call_expr
decl_stmt|,
name|arg_list
decl_stmt|;
endif|#
directive|endif
name|rtx
name|retval
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|align
init|=
operator|(
name|GET_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|MEM
condition|?
name|MEM_ALIGN
argument_list|(
name|object
argument_list|)
else|:
name|GET_MODE_ALIGNMENT
argument_list|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* If OBJECT is not BLKmode and SIZE is the same size as its mode,      just move a zero.  Otherwise, do this a piece at a time.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|object
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|object
operator|=
name|protect_from_queue
argument_list|(
name|object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|protect_from_queue
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|MOVE_BY_PIECES_P
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
condition|)
name|clear_by_pieces
argument_list|(
name|object
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Try the most limited insn first, because there's no point 	     including more than one in the machine description unless 	     the more limited one has some advantage.  */
name|rtx
name|opalign
init|=
name|GEN_INT
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|enum
name|insn_code
name|code
init|=
name|clrstr_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
name|insn_operand_predicate_fn
name|pred
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
comment|/* We don't need MODE to be narrower than 		     BITS_PER_HOST_WIDE_INT here because if SIZE is less than 		     the mode mask, as it is returned by the macro, it will 		     definitely be less than the actual mode mask.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|)
operator|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|BITS_PER_WORD
operator|)
operator|&&
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|==
literal|0
operator|||
call|(
modifier|*
name|pred
call|)
argument_list|(
name|object
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|==
literal|0
operator|||
call|(
modifier|*
name|pred
call|)
argument_list|(
name|opalign
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|op1
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|op1
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
expr_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|pred
call|)
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
operator|(
name|int
operator|)
name|code
argument_list|)
argument_list|(
name|object
argument_list|,
name|op1
argument_list|,
name|opalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* OBJECT or SIZE may have been passed through protect_from_queue.  	     It is unsafe to save the value generated by protect_from_queue 	     and reuse it later.  Consider what happens if emit_queue is 	     called before the return value from protect_from_queue is used.  	     Expansion of the CALL_EXPR below will call emit_queue before 	     we are finished emitting RTL for argument setup.  So if we are 	     not careful we could get the wrong value for an argument.  	     To avoid this problem we go ahead and emit code to copy OBJECT 	     and SIZE into new pseudos.  We can then place those new pseudos 	     into an RTL_EXPR and use them later, even after a call to 	     emit_queue.  	     Note this is not strictly needed for library calls since they 	     do not call emit_queue before loading their arguments.  However, 	     we may need to have library calls call emit_queue in the future 	     since failing to do so could cause problems for targets which 	     define SMALL_REGISTER_CLASSES and pass arguments in registers.  */
name|object
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
name|size
operator|=
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
comment|/* It is incorrect to use the libcall calling conventions to call 	     memset in this context.  	     This could be a user call to memset and the user may wish to 	     examine the return value from memset.  	     For targets where libcalls and normal calls have different 	     conventions for returning pointers, we could end up generating 	     incorrect code.  	     So instead of using a libcall sequence we build up a suitable 	     CALL_EXPR and expand the call in the normal fashion.  */
if|if
condition|(
name|fn
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|fntype
decl_stmt|;
comment|/* This was copied from except.c, I don't know if all this is 		 necessary in this context or not.  */
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"memset"
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_function_type
argument_list|(
name|fntype
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|fntype
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|fn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* We need to make an argument list for the function call.  	     memset has three arguments, the first is a void * addresses, the 	     second an integer with the initialization value, the last is a 	     size_t byte count for the copy.  */
name|arg_list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|object
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|integer_type_node
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now we have to build up the CALL_EXPR itself.  */
name|call_expr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|call_expr
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|call_expr
argument_list|,
name|arg_list
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|call_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|expand_expr
argument_list|(
name|call_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bzero_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|2
argument_list|,
name|object
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we are initializing a readonly value, show the above call 	     clobbered it.  Otherwise, a load from it may erroneously be 	     hoisted from a loop.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|object
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Generate code to copy Y into X.    Both Y and X must have the same mode, except that    Y can be a constant with VOIDmode.    This mode cannot be BLKmode; use emit_block_move for that.     Return the last instruction emitted.  */
end_comment

begin_function
name|rtx
name|emit_move_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|y_cst
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
operator|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Never force constant_p_rtx to memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|y_cst
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
comment|/* If X or Y are memory references, verify that their addresses are valid      for the machine.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|x
operator|=
name|validize_mem
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|y
operator|=
name|validize_mem
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|last_insn
operator|=
name|emit_move_insn_1
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y_cst
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|set_unique_reg_note
argument_list|(
name|last_insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|y_cst
argument_list|)
expr_stmt|;
return|return
name|last_insn
return|;
block|}
end_function

begin_comment
comment|/* Low level part of emit_move_insn.    Called just like emit_move_insn, but assumes X and Y    are basically valid.  */
end_comment

begin_function
name|rtx
name|emit_move_insn_1
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|submode
decl_stmt|;
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|mode
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|MAX_MACHINE_MODE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
comment|/* Expand complex moves by moving real part and imag part, if possible.  */
elseif|else
if|if
condition|(
operator|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_INT
operator|)
operator|&&
name|BLKmode
operator|!=
operator|(
name|submode
operator|=
name|mode_for_size
argument_list|(
operator|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
argument_list|,
operator|(
name|class
operator|==
name|MODE_COMPLEX_INT
condition|?
name|MODE_INT
else|:
name|MODE_FLOAT
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
comment|/* Don't split destination if it is a stack push.  */
name|int
name|stack
init|=
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* In case we output to the stack, but the size is smaller machine can 	 push exactly, we need to use move instructions.  */
if|if
condition|(
name|stack
operator|&&
operator|(
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|submode
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|submode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|HOST_WIDE_INT
name|offset1
decl_stmt|,
name|offset2
decl_stmt|;
comment|/* Do not use anti_adjust_stack, since we don't want to update 	     stack_pointer_delta.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|sub_optab
argument_list|,
else|#
directive|else
name|add_optab
argument_list|,
endif|#
directive|endif
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|stack_pointer_rtx
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|offset1
operator|=
literal|0
expr_stmt|;
name|offset2
operator|=
name|GET_MODE_SIZE
argument_list|(
name|submode
argument_list|)
expr_stmt|;
else|#
directive|else
name|offset1
operator|=
operator|-
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset2
operator|=
operator|(
operator|-
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|submode
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|x
argument_list|,
name|submode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|x
argument_list|,
name|submode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset2
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* If this is a stack, push the highpart first, so it 	 will be in the argument order.  	 In that case, change_address is used only to convert 	 the mode, not to change the address.  */
if|if
condition|(
name|stack
condition|)
block|{
comment|/* Note that the real part always precedes the imag part in memory 	     regardless of machine's endianness.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|submode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|submode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|submode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|submode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|rtx
name|realpart_x
decl_stmt|,
name|realpart_y
decl_stmt|;
name|rtx
name|imagpart_x
decl_stmt|,
name|imagpart_y
decl_stmt|;
comment|/* If this is a complex value with each part being smaller than a 	     word, the usual calling sequence will likely pack the pieces into 	     a single register.  Unfortunately, SUBREG of hard registers only 	     deals in terms of words, so we have a problem converting input 	     arguments to the CONCAT of two registers that is used elsewhere 	     for complex values.  If this is before reload, we can copy it into 	     memory and reload.  FIXME, we should see about using extract and 	     insert on integer registers, but complex short and complex char 	     variables should be rarely used.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
literal|2
operator|*
name|BITS_PER_WORD
operator|&&
operator|(
name|reload_in_progress
operator||
name|reload_completed
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|packed_dest_p
init|=
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
decl_stmt|;
name|int
name|packed_src_p
init|=
operator|(
name|REG_P
argument_list|(
name|y
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|y
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
decl_stmt|;
if|if
condition|(
name|packed_dest_p
operator|||
name|packed_src_p
condition|)
block|{
name|enum
name|mode_class
name|reg_class
init|=
operator|(
operator|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|)
condition|?
name|MODE_FLOAT
else|:
name|MODE_INT
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|reg_class
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_mode
operator|!=
name|BLKmode
condition|)
block|{
name|rtx
name|mem
init|=
name|assign_stack_temp
argument_list|(
name|reg_mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|cmem
init|=
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|cfun
operator|->
name|cannot_inline
operator|=
name|N_
argument_list|(
literal|"function using short complex types cannot be inline"
argument_list|)
expr_stmt|;
if|if
condition|(
name|packed_dest_p
condition|)
block|{
name|rtx
name|sreg
init|=
name|gen_rtx_SUBREG
argument_list|(
name|reg_mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn_1
argument_list|(
name|cmem
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn_1
argument_list|(
name|sreg
argument_list|,
name|mem
argument_list|)
return|;
block|}
else|else
block|{
name|rtx
name|sreg
init|=
name|gen_rtx_SUBREG
argument_list|(
name|reg_mode
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn_1
argument_list|(
name|mem
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn_1
argument_list|(
name|x
argument_list|,
name|cmem
argument_list|)
return|;
block|}
block|}
block|}
block|}
name|realpart_x
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|realpart_y
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|imagpart_x
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|imagpart_y
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Show the output dies here.  This is necessary for SUBREGs 	     of pseudos since we cannot track their lifetimes correctly; 	     hard regs shouldn't appear here except as return values. 	     We never want to emit such a clobber after reload.  */
if|if
condition|(
name|x
operator|!=
name|y
operator|&&
operator|!
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|realpart_x
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|imagpart_x
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|realpart_x
argument_list|,
name|realpart_y
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|imagpart_x
argument_list|,
name|imagpart_y
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|get_last_insn
argument_list|()
return|;
block|}
comment|/* This will handle any multi-word mode that lacks a move_insn pattern.      However, you will get better code if you define such patterns,      even if they must turn into multiple assembler instructions.  */
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
block|{
name|rtx
name|last_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|seq
decl_stmt|,
name|inner
decl_stmt|;
name|int
name|need_clobber
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* If X is a push on the stack, do the push now and replace 	 X with a reference to the stack pointer.  */
if|if
condition|(
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
comment|/* Do not use anti_adjust_stack, since we don't want to update 	     stack_pointer_delta.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|sub_optab
argument_list|,
else|#
directive|else
name|add_optab
argument_list|,
endif|#
directive|endif
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|stack_pointer_rtx
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Just hope that small offsets off SP are OK.  */
if|if
condition|(
name|code
operator|==
name|POST_INC
condition|)
name|temp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|POST_DEC
condition|)
name|temp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we are in reload, see if either operand is a MEM whose address 	 is scheduled for replacement.  */
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|inner
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|x
operator|=
name|replace_equiv_address_nv
argument_list|(
name|x
argument_list|,
name|inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|inner
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
condition|)
name|y
operator|=
name|replace_equiv_address_nv
argument_list|(
name|y
argument_list|,
name|inner
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|need_clobber
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|xpart
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|ypart
init|=
name|operand_subword
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
comment|/* If we can't get a part of Y, put Y into memory if it is a 	     constant.  Otherwise, force it into a register.  If we still 	     can't get a part of Y, abort.  */
if|if
condition|(
name|ypart
operator|==
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|y
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|ypart
operator|=
name|operand_subword
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ypart
operator|==
literal|0
condition|)
name|ypart
operator|=
name|operand_subword_force
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpart
operator|==
literal|0
operator|||
name|ypart
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|need_clobber
operator||=
operator|(
name|GET_CODE
argument_list|(
name|xpart
argument_list|)
operator|==
name|SUBREG
operator|)
expr_stmt|;
name|last_insn
operator|=
name|emit_move_insn
argument_list|(
name|xpart
argument_list|,
name|ypart
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Show the output dies here.  This is necessary for SUBREGs 	 of pseudos since we cannot track their lifetimes correctly; 	 hard regs shouldn't appear here except as return values. 	 We never want to emit such a clobber after reload.  */
if|if
condition|(
name|x
operator|!=
name|y
operator|&&
operator|!
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
operator|&&
name|need_clobber
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
return|return
name|last_insn
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pushing data onto the stack.  */
end_comment

begin_comment
comment|/* Push a block of length SIZE (perhaps variable)    and return an rtx to address the beginning of the block.    Note that it is not possible for the value returned to be a QUEUED.    The value may be virtual_outgoing_args_rtx.     EXTRA is the number of bytes of padding to push in addition to SIZE.    BELOW nonzero means this padding comes at low addresses;    otherwise, the padding comes at high addresses.  */
end_comment

begin_function
name|rtx
name|push_block
parameter_list|(
name|size
parameter_list|,
name|extra
parameter_list|,
name|below
parameter_list|)
name|rtx
name|size
decl_stmt|;
name|int
name|extra
decl_stmt|,
name|below
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
name|size
operator|=
name|convert_modes
argument_list|(
name|Pmode
argument_list|,
name|ptr_mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|size
argument_list|)
condition|)
name|anti_adjust_stack
argument_list|(
name|plus_constant
argument_list|(
name|size
argument_list|,
name|extra
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|REG
operator|&&
name|extra
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|anti_adjust_stack
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
if|if
condition|(
literal|0
condition|)
else|#
directive|else
if|if
condition|(
literal|1
condition|)
endif|#
directive|endif
block|{
name|temp
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
operator|&&
name|below
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
operator|(
name|below
condition|?
literal|0
else|:
name|extra
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra
operator|!=
literal|0
operator|&&
operator|!
name|below
condition|)
name|temp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|virtual_outgoing_args_rtx
argument_list|,
name|negate_rtx
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|size
argument_list|,
name|extra
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|virtual_outgoing_args_rtx
argument_list|,
name|negate_rtx
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|memory_address
argument_list|(
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
end_ifdef

begin_comment
comment|/* Emit single push insn.  */
end_comment

begin_function
specifier|static
name|void
name|emit_single_push_insn
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|type
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|rtx
name|dest_addr
decl_stmt|;
name|unsigned
name|rounded_size
init|=
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|insn_operand_predicate_fn
name|pred
decl_stmt|;
name|stack_pointer_delta
operator|+=
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is push pattern, use it.  Otherwise try old way of throwing      MEM representing push operation to move expander.  */
name|icode
operator|=
name|push_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|&&
operator|!
operator|(
call|(
modifier|*
name|pred
call|)
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|rounded_size
condition|)
name|dest_addr
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|STACK_PUSH_CODE
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|dest_addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|rounded_size
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|dest_addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|rounded_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dest_addr
operator|=
name|gen_rtx_PRE_MODIFY
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|dest_addr
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|dest_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
name|set_mem_attributes
argument_list|(
name|dest
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_optimize_sibling_calls
condition|)
comment|/* Function incoming arguments may overlap with sibling call 	   outgoing arguments and we cannot allow reordering of reads 	   from function arguments with stores to outgoing arguments 	   of sibling calls.  */
name|set_mem_alias_set
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate code to push X onto the stack, assuming it has mode MODE and    type TYPE.    MODE is redundant except when X is a CONST_INT (since they don't    carry mode info).    SIZE is an rtx for the size of data to be copied (in bytes),    needed only if X is BLKmode.     ALIGN (in bits) is maximum alignment we can assume.     If PARTIAL and REG are both nonzero, then copy that many of the first    words of X into registers starting with REG, and push the rest of X.    The amount of space pushed is decreased by PARTIAL words,    rounded *down* to a multiple of PARM_BOUNDARY.    REG must be a hard register in this case.    If REG is zero but PARTIAL is not, take any all others actions for an    argument partially in registers, but do not actually load any    registers.     EXTRA is the amount in bytes of extra space to leave next to this arg.    This is ignored if an argument block has already been allocated.     On a machine that lacks real push insns, ARGS_ADDR is the address of    the bottom of the argument block for this call.  We use indexing off there    to store the arg.  On machines with push insns, ARGS_ADDR is 0 when a    argument block has not been preallocated.     ARGS_SO_FAR is the size of args previously pushed for this call.     REG_PARM_STACK_SPACE is nonzero if functions require stack space    for arguments passed in registers.  If nonzero, it will be the number    of bytes required.  */
end_comment

begin_function
name|void
name|emit_push_insn
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|,
name|partial
parameter_list|,
name|reg
parameter_list|,
name|extra
parameter_list|,
name|args_addr
parameter_list|,
name|args_so_far
parameter_list|,
name|reg_parm_stack_space
parameter_list|,
name|alignment_pad
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|int
name|partial
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|rtx
name|args_addr
decl_stmt|;
name|rtx
name|args_so_far
decl_stmt|;
name|int
name|reg_parm_stack_space
decl_stmt|;
name|rtx
name|alignment_pad
decl_stmt|;
block|{
name|rtx
name|xinner
decl_stmt|;
name|enum
name|direction
name|stack_direction
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
init|=
name|downward
decl_stmt|;
else|#
directive|else
operator|=
name|upward
expr_stmt|;
endif|#
directive|endif
comment|/* Decide where to pad the argument: `downward' for below,      `upward' for above, or `none' for don't pad it.      Default is below for small data on big-endian machines; else above.  */
name|enum
name|direction
name|where_pad
init|=
name|FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* Invert direction if stack is post-decrement.       FIXME: why?  */
if|if
condition|(
name|STACK_PUSH_CODE
operator|==
name|POST_DEC
condition|)
if|if
condition|(
name|where_pad
operator|!=
name|none
condition|)
name|where_pad
operator|=
operator|(
name|where_pad
operator|==
name|downward
condition|?
name|upward
else|:
name|downward
operator|)
expr_stmt|;
name|xinner
operator|=
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* Copy a block into the stack, entirely or partially.  */
name|rtx
name|temp
decl_stmt|;
name|int
name|used
init|=
name|partial
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|offset
init|=
name|used
operator|%
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|int
name|skip
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|used
operator|-=
name|offset
expr_stmt|;
comment|/* USED is now the # of bytes we need not copy to the stack 	 because registers will take care of them.  */
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
name|xinner
operator|=
name|adjust_address
argument_list|(
name|xinner
argument_list|,
name|BLKmode
argument_list|,
name|used
argument_list|)
expr_stmt|;
comment|/* If the partial register-part of the arg counts in its stack size, 	 skip the part of stack space corresponding to the registers. 	 Otherwise, start copying to the beginning of the stack space, 	 by setting SKIP to 0.  */
name|skip
operator|=
operator|(
name|reg_parm_stack_space
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|used
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* Do it with several push insns if that doesn't take lots of insns 	 and if there is no difficulty with push insns that skip bytes 	 on the stack for alignment purposes.  */
if|if
condition|(
name|args_addr
operator|==
literal|0
operator|&&
name|PUSH_ARGS
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|skip
operator|==
literal|0
operator|&&
operator|(
name|MOVE_BY_PIECES_P
argument_list|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|,
name|align
argument_list|)
operator|)
comment|/* Here we avoid the case of a structure whose weak alignment 	     forces many pushes of a small amount of data, 	     and such small pushes do rounding that causes trouble.  */
operator|&&
operator|(
operator|(
operator|!
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|word_mode
argument_list|,
name|align
argument_list|)
operator|)
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
operator|||
operator|(
name|PUSH_ROUNDING
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
operator|==
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|)
operator|&&
name|PUSH_ROUNDING
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|size
argument_list|)
condition|)
block|{
comment|/* Push padding now if padding above and stack grows down, 	     or if padding below and stack grows up. 	     But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
name|move_by_pieces
argument_list|(
name|NULL
argument_list|,
name|xinner
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* PUSH_ROUNDING  */
block|{
name|rtx
name|target
decl_stmt|;
comment|/* Otherwise make space on the stack and copy the data 	     to the address of that space.  */
comment|/* Deduct words put into registers from the size we must copy.  */
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
name|size
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|size
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|used
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* Get the address of the stack space. 	     In this case, we do not deal with EXTRA separately. 	     A single stack adjust will do.  */
if|if
condition|(
operator|!
name|args_addr
condition|)
block|{
name|temp
operator|=
name|push_block
argument_list|(
name|size
argument_list|,
name|extra
argument_list|,
name|where_pad
operator|==
name|downward
argument_list|)
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|args_so_far
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|args_addr
argument_list|,
name|skip
operator|+
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|args_addr
argument_list|,
name|args_so_far
argument_list|)
argument_list|,
name|skip
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
name|set_mem_attributes
argument_list|(
name|target
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Function incoming arguments may overlap with sibling call 		 outgoing arguments and we cannot allow reordering of reads 		 from function arguments with stores to outgoing arguments 		 of sibling calls.  */
name|set_mem_alias_set
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|set_mem_align
argument_list|(
name|target
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* TEMP is the address of the block.  Copy the data there.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|MOVE_BY_PIECES_P
argument_list|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
condition|)
block|{
name|move_by_pieces
argument_list|(
name|target
argument_list|,
name|xinner
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
name|rtx
name|opalign
init|=
name|GEN_INT
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|enum
name|insn_code
name|code
init|=
name|movstr_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
name|insn_operand_predicate_fn
name|pred
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|)
operator|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|BITS_PER_WORD
operator|)
operator|&&
operator|(
operator|!
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|||
operator|(
call|(
modifier|*
name|pred
call|)
argument_list|(
name|target
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|||
operator|(
call|(
modifier|*
name|pred
call|)
argument_list|(
name|xinner
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|||
operator|(
call|(
modifier|*
name|pred
call|)
argument_list|(
name|opalign
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|op2
init|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
expr_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|pred
call|)
argument_list|(
name|op2
argument_list|,
name|mode
argument_list|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
operator|(
name|int
operator|)
name|code
argument_list|)
argument_list|(
name|target
argument_list|,
name|xinner
argument_list|,
name|op2
argument_list|,
name|opalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* If the source is referenced relative to the stack pointer, 		 copy it to another register to stabilize it.  We do not need 		 to do this if we know that we won't be changing sp.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|temp
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|temp
argument_list|)
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* Make inhibit_defer_pop nonzero around the library call 	     to force it to pop the bcopy-arguments right away.  */
name|NO_DEFER_POP
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memcpy_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|temp
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bcopy_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|temp
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OK_DEFER_POP
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|partial
operator|>
literal|0
condition|)
block|{
comment|/* Scalar partly in registers.  */
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|not_stack
decl_stmt|;
comment|/* # words of start of argument 	 that we must make space for but need not store.  */
name|int
name|offset
init|=
name|partial
operator|%
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_WORD
operator|)
decl_stmt|;
name|int
name|args_offset
init|=
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
decl_stmt|;
name|int
name|skip
decl_stmt|;
comment|/* Push padding now if padding above and stack grows down, 	 or if padding below and stack grows up. 	 But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we make space by pushing it, we might as well push 	 the real data.  Otherwise, we can leave OFFSET nonzero 	 and leave the space uninitialized.  */
if|if
condition|(
name|args_addr
operator|==
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Now NOT_STACK gets the number of words that we don't need to 	 allocate on the stack.  */
name|not_stack
operator|=
name|partial
operator|-
name|offset
expr_stmt|;
comment|/* If the partial register-part of the arg counts in its stack size, 	 skip the part of stack space corresponding to the registers. 	 Otherwise, start copying to the beginning of the stack space, 	 by setting SKIP to 0.  */
name|skip
operator|=
operator|(
name|reg_parm_stack_space
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|not_stack
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If X is a hard register in a non-integer mode, copy it into a pseudo; 	 SUBREGs of such registers are not allowed.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
operator|)
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Loop over all the words allocated on the stack for this arg.  */
comment|/* We can do it by words, because any scalar bigger than a word 	 has a size a multiple of a word.  */
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
for|for
control|(
name|i
operator|=
name|not_stack
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
name|not_stack
condition|;
name|i
operator|--
control|)
endif|#
directive|endif
if|if
condition|(
name|i
operator|>=
name|not_stack
operator|+
name|offset
condition|)
name|emit_push_insn
argument_list|(
name|operand_subword_force
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_RTX
argument_list|,
name|align
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|args_addr
argument_list|,
name|GEN_INT
argument_list|(
name|args_offset
operator|+
operator|(
operator|(
name|i
operator|-
name|not_stack
operator|+
name|skip
operator|)
operator|*
name|UNITS_PER_WORD
operator|)
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|,
name|alignment_pad
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|addr
decl_stmt|;
name|rtx
name|target
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
comment|/* Push padding now if padding above and stack grows down, 	 or if padding below and stack grows up. 	 But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|args_addr
operator|==
literal|0
operator|&&
name|PUSH_ARGS
condition|)
name|emit_single_push_insn
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|args_so_far
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|args_addr
argument_list|,
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|args_addr
argument_list|,
name|args_so_far
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|addr
expr_stmt|;
name|dest
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
name|set_mem_attributes
argument_list|(
name|dest
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Function incoming arguments may overlap with sibling call 		 outgoing arguments and we cannot allow reordering of reads 		 from function arguments with stores to outgoing arguments 		 of sibling calls.  */
name|set_mem_alias_set
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
label|:
comment|/* If part should go in registers, copy that part      into the appropriate registers.  Do this now, at the end,      since mem-to-mem copies above may do function calls.  */
if|if
condition|(
name|partial
operator|>
literal|0
operator|&&
name|reg
operator|!=
literal|0
condition|)
block|{
comment|/* Handle calls that pass values in multiple non-contiguous locations. 	 The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|reg
argument_list|,
name|x
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* ??? size? */
else|else
name|move_block_to_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|x
argument_list|,
name|partial
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|==
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment_pad
operator|&&
name|args_addr
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|alignment_pad
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return X if X can be used as a subtarget in a sequence of arithmetic    operations.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_subtarget
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|x
operator|==
literal|0
comment|/* Only registers can be subtargets.  */
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
comment|/* If the register is readonly, it can't be set more than once.  */
operator|||
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
comment|/* Don't use hard regs to avoid extending their life.  */
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
comment|/* Avoid subtargets inside loops, 	      since they hide some invariant expressions.  */
operator|||
name|preserve_subexpressions_p
argument_list|()
operator|)
condition|?
literal|0
else|:
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expand an assignment that stores the value of FROM into TO.    If WANT_VALUE is nonzero, return an rtx for the value of TO.    (This may contain a QUEUED rtx;    if the value is constant, this rtx is a constant.)    Otherwise, the returned value is NULL_RTX.     SUGGEST_REG is no longer actually used.    It used to mean, copy the value through a register    and return that register, if that is possible.    We now use WANT_VALUE to decide whether to do this.  */
end_comment

begin_function
name|rtx
name|expand_assignment
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|want_value
parameter_list|,
name|suggest_reg
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|want_value
decl_stmt|;
name|int
name|suggest_reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|to_rtx
init|=
literal|0
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* Don't crash if the lhs of the assignment was erroneous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
name|result
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|want_value
condition|?
name|result
else|:
name|NULL_RTX
return|;
block|}
comment|/* Assignment of a structure component needs special treatment      if the structure component's rtx is not simply a MEM.      Assignment of an array element at a constant index, and assignment of      an array element in an unaligned packed structure field, has the same      problem.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|||
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|rtx
name|orig_to_rtx
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|tem
operator|=
name|get_inner_reference
argument_list|(
name|to
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode1
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|)
expr_stmt|;
comment|/* If we are going to use store_bit_field and extract_bit_field, 	 make sure to_rtx will be safe for multiple use.  */
if|if
condition|(
name|mode1
operator|==
name|VOIDmode
operator|&&
name|want_value
condition|)
name|tem
operator|=
name|stabilize_reference
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|orig_to_rtx
operator|=
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|tem
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset_rtx
init|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|Pmode
condition|)
name|offset_rtx
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|ptr_mode
condition|)
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A constant address in TO_RTX can have VOIDmode, we must not try 	     to call force_reg for that case.  Avoid that case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|bitsize
operator|>
literal|0
operator|&&
operator|(
name|bitpos
operator|%
name|bitsize
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bitsize
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|MEM_ALIGN
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
condition|)
block|{
name|to_rtx
operator|=
name|adjust_address
argument_list|(
name|to_rtx
argument_list|,
name|mode1
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|bitpos
operator|=
literal|0
expr_stmt|;
block|}
name|to_rtx
operator|=
name|offset_address
argument_list|(
name|to_rtx
argument_list|,
name|offset_rtx
argument_list|,
name|highest_pow2_factor_for_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|tree
name|old_expr
init|=
name|MEM_EXPR
argument_list|(
name|to_rtx
argument_list|)
decl_stmt|;
comment|/* If the field is at offset zero, we could have been given the 	     DECL_RTX of the parent struct.  Don't munge it.  */
name|to_rtx
operator|=
name|shallow_copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|to_rtx
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we changed MEM_EXPR, that means we're now referencing 	     the COMPONENT_REF, which means that MEM_OFFSET must be 	     relative to that field.  But we've not yet reflected BITPOS 	     in TO_RTX.  This will be done in store_field.  Adjust for 	     that by biasing MEM_OFFSET by -bitpos.  */
if|if
condition|(
name|MEM_EXPR
argument_list|(
name|to_rtx
argument_list|)
operator|!=
name|old_expr
operator|&&
name|MEM_OFFSET
argument_list|(
name|to_rtx
argument_list|)
operator|&&
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
operator|!=
literal|0
condition|)
name|set_mem_offset
argument_list|(
name|to_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|MEM_OFFSET
argument_list|(
name|to_rtx
argument_list|)
argument_list|)
operator|-
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Deal with volatile and readonly fields.  The former is only done 	 for MEM.  Also set MEM_KEEP_ALIAS_SET_P if needed.  */
if|if
condition|(
name|volatilep
operator|&&
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|to_rtx
operator|==
name|orig_to_rtx
condition|)
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_READONLY
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|to_rtx
operator|==
name|orig_to_rtx
condition|)
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|can_address_p
argument_list|(
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|to_rtx
operator|==
name|orig_to_rtx
condition|)
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|result
operator|=
name|store_field
argument_list|(
name|to_rtx
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode1
argument_list|,
name|from
argument_list|,
operator|(
name|want_value
comment|/* Spurious cast for HPUX compiler.  */
condition|?
operator|(
operator|(
expr|enum
name|machine_mode
operator|)
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|)
else|:
name|VOIDmode
operator|)
argument_list|,
name|unsignedp
argument_list|,
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|get_alias_set
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* If the value is meaningful, convert RESULT to the proper mode. 	 Otherwise, return nothing.  */
return|return
operator|(
name|want_value
condition|?
name|convert_modes
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
else|:
name|NULL_RTX
operator|)
return|;
block|}
comment|/* If the rhs is a function call and its value is not an aggregate,      call the function before we start to compute the lhs.      This is needed for correct code for cases such as      val = setjmp (buf) on machines where reference to val      requires loading up part of an address in a separate insn.       Don't do this if TO is a VAR_DECL or PARM_DECL whose DECL_RTL is REG      since it might be a promoted variable where the zero- or sign- extension      needs to be done.  Handling this in the normal way is safe because no      computation is done before the call.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|!
name|aggregate_value_p
argument_list|(
name|from
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|to
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
condition|)
block|{
name|rtx
name|value
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|value
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_rtx
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|to
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_WRITE
argument_list|)
expr_stmt|;
comment|/* Handle calls that return values in multiple non-contiguous locations. 	 The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|to_rtx
argument_list|,
name|value
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|to_rtx
argument_list|,
name|value
argument_list|,
name|expr_size
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|convert_memory_address
argument_list|(
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|to_rtx
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|to_rtx
else|:
name|NULL_RTX
return|;
block|}
comment|/* Ordinary treatment.  Expand TO to get a REG or MEM rtx.      Don't re-expand if it was expanded already (in COMPONENT_REF case).  */
if|if
condition|(
name|to_rtx
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|to
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_WRITE
argument_list|)
expr_stmt|;
comment|/* Don't move directly into a return register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|RESULT_DECL
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|PARALLEL
operator|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|to_rtx
argument_list|,
name|temp
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|to_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|to_rtx
else|:
name|NULL_RTX
return|;
block|}
comment|/* In case we are returning the contents of an object which overlaps      the place the value is being stored, use a safe function when copying      a value through a pointer into a structure value return block.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|RESULT_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|current_function_returns_struct
operator|&&
operator|!
name|current_function_returns_pcc_struct
condition|)
block|{
name|rtx
name|from_rtx
decl_stmt|,
name|size
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|size
operator|=
name|expr_size
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|from_rtx
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memmove_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|from_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bcopy_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|from_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|to_rtx
else|:
name|NULL_RTX
return|;
block|}
comment|/* Compute FROM and store the value in the rtx we got.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
name|result
operator|=
name|store_expr
argument_list|(
name|from
argument_list|,
name|to_rtx
argument_list|,
name|want_value
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|result
else|:
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Generate code for computing expression EXP,    and storing the value into TARGET.    TARGET may contain a QUEUED rtx.     If WANT_VALUE is nonzero, return a copy of the value    not in TARGET, so that we can be sure to use the proper    value in a containing expression even if TARGET has something    else stored in it.  If possible, we copy the value through a pseudo    and return that pseudo.  Or, if the value is constant, we try to    return the constant.  In some cases, we return a pseudo    copied *from* TARGET.     If the mode is BLKmode then we may return TARGET itself.    It turns out that in BLKmode it doesn't cause a problem.    because C has no operators that could combine two different    assignments into the same BLKmode object with different values    with no sequence point.  Will other languages need this to    be more thorough?     If WANT_VALUE is 0, we return NULL, to make sure    to catch quickly any cases where the caller uses the value    and fails to set WANT_VALUE.  */
end_comment

begin_function
name|rtx
name|store_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|want_value
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|want_value
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
name|int
name|dont_return_target
init|=
literal|0
decl_stmt|;
name|int
name|dont_store_target
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
comment|/* Perform first part of compound expression, then assign from second 	 part.  */
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
return|return
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|want_value
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COND_EXPR
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
comment|/* For conditional expression, get safe form of the target.  Then 	 test the condition, doing the appropriate assignment on either 	 side.  This avoids the creation of unnecessary temporaries. 	 For non-BLKmode, it is more efficient not to do this.  */
name|rtx
name|lab1
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|,
name|lab2
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab2
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
return|return
name|want_value
condition|?
name|target
else|:
name|NULL_RTX
return|;
block|}
elseif|else
if|if
condition|(
name|queued_subexp_p
argument_list|(
name|target
argument_list|)
condition|)
comment|/* If target contains a postincrement, let's not risk        using it as the place to generate the rhs.  */
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* Expand EXP into a new pseudo.  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|temp
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If target is volatile, ANSI requires accessing the value 	 *from* the target, if it is accessed.  So make that happen. 	 In no case return the target itself.  */
if|if
condition|(
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|&&
name|want_value
condition|)
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|want_value
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
condition|)
comment|/* If target is in memory and caller wants value in a register instead,        arrange that.  Pass TARGET as target for expand_expr so that,        if EXP is another assignment, WANT_VALUE will be nonzero for it.        We know expand_expr will not use the target in that case.        Don't do this if TARGET is volatile because we are supposed        to write it and then read it.  */
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* If TEMP is already in the desired TARGET, only copy it from 	     memory and don't store it there again.  */
if|if
condition|(
name|temp
operator|==
name|target
operator|||
operator|(
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|temp
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|target
argument_list|)
operator|)
condition|)
name|dont_store_target
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|target
argument_list|)
condition|)
comment|/* If this is an scalar in a register that is stored in a wider mode        than the declared mode, compute the result into its declared mode        and then convert to the wider mode.  Our value is the computed        expression.  */
block|{
name|rtx
name|inner_target
init|=
literal|0
decl_stmt|;
comment|/* If we don't want a value, we can do the conversion inside EXP, 	 which will often result in some optimizations.  Do the conversion 	 in two steps: first change the signedness, if needed, then 	 the extend.  But don't do this if the type of EXP is a subtype 	 of something else since then the conversion might involve 	 more than just converting modes.  */
if|if
condition|(
operator|!
name|want_value
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
condition|)
name|exp
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|convert
argument_list|(
name|type_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|inner_target
operator|=
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|inner_target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If TEMP is a volatile MEM and we want a result value, make 	 the access now so it gets done only once.  Likewise if 	 it contains TARGET.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
operator|&&
name|want_value
operator|&&
operator|(
name|MEM_VOLATILE_P
argument_list|(
name|temp
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* If TEMP is a VOIDmode constant, use convert_modes to make 	 sure that we properly convert it.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|temp
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|convert_move
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we promoted a constant, change the mode back down to match 	 target.  Otherwise, the caller might get confused by a result whose 	 mode is larger than expected.  */
if|if
condition|(
name|want_value
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|temp
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|temp
argument_list|)
operator|=
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|want_value
condition|?
name|temp
else|:
name|NULL_RTX
return|;
block|}
else|else
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Return TARGET if it's a specified hardware register. 	 If TARGET is a volatile mem ref, either return TARGET 	 or return a reg copied *from* TARGET; ANSI requires this.  	 Otherwise, if TEMP is not TARGET, return TEMP 	 if it is constant (for efficiency), 	 or if we really want the correct value.  */
if|if
condition|(
operator|!
operator|(
name|target
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|||
name|want_value
operator|)
condition|)
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If TEMP is a VOIDmode constant and the mode of the type of EXP is not      the same as that of TARGET, adjust the constant.  This is needed, for      example, in case it is a CONST_DOUBLE and we want only a word-sized      value.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If value was not generated in the target, store it there.      Convert the value to TARGET's type first if necessary.      If TEMP and TARGET compare equal according to rtx_equal_p, but      one or both of them are volatile memory refs, we have to distinguish      two cases:      - expand_expr has used TARGET.  In this case, we must not generate        another copy.  This can be detected by TARGET being equal according        to == .      - expand_expr has not used TARGET - that means that the source just        happens to have the same RTX form.  Since temp will have been created        by expand_expr, it will compare unequal according to == .        We must generate a copy in this case, to reach the correct number        of volatile memory references.  */
if|if
condition|(
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
operator|||
operator|(
name|temp
operator|!=
name|target
operator|&&
operator|(
name|side_effects_p
argument_list|(
name|temp
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|target
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
operator|!
name|dont_store_target
comment|/* If store_expr stores a DECL whose DECL_RTL(exp) == TARGET, 	    but TARGET is not valid memory reference, TEMP will differ 	    from TARGET although it is really the same location.  */
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
literal|'d'
operator|||
name|target
operator|!=
name|DECL_RTL_IF_SET
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dont_return_target
condition|)
block|{
comment|/* In this case, we will return TEMP, 		 so make sure it has the proper mode. 		 But don't forget to store the value into TARGET.  */
name|temp
operator|=
name|convert_to_mode
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* Handle copying a string constant into an array.  The string 	     constant may be shorter than the array.  So copy just the string's 	     actual length, and clear the rest.  First get the size of the data 	     type of the string, which is actually the size of the target.  */
name|rtx
name|size
init|=
name|expr_size
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
condition|)
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Compute the size of the data to copy from the string.  */
name|tree
name|copy_size
init|=
name|size_binop
argument_list|(
name|MIN_EXPR
argument_list|,
name|make_tree
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|copy_size_rtx
init|=
name|expand_expr
argument_list|(
name|copy_size
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|label
init|=
literal|0
decl_stmt|;
comment|/* Copy that much.  */
name|copy_size_rtx
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|copy_size_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|copy_size_rtx
argument_list|)
expr_stmt|;
comment|/* Figure out how much is left in TARGET that we have to clear. 		 Do all calculations in ptr_mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy_size_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|size
operator|=
name|plus_constant
argument_list|(
name|size
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|copy_size_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|adjust_address
argument_list|(
name|target
argument_list|,
name|BLKmode
argument_list|,
name|INTVAL
argument_list|(
name|copy_size_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|expand_binop
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|size
argument_list|,
name|copy_size_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|copy_size_rtx
argument_list|)
operator|!=
name|Pmode
condition|)
name|copy_size_rtx
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|copy_size_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|target
operator|=
name|offset_address
argument_list|(
name|target
argument_list|,
name|copy_size_rtx
argument_list|,
name|highest_pow2_factor
argument_list|(
name|copy_size
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|size
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|size
argument_list|)
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|!=
name|const0_rtx
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle calls that return values in multiple non-contiguous locations. 	 The Irix 6 ABI has examples of this.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't want a value, return NULL_RTX.  */
if|if
condition|(
operator|!
name|want_value
condition|)
return|return
name|NULL_RTX
return|;
comment|/* If we are supposed to return TEMP, do so as long as it isn't a MEM.      ??? The latter test doesn't seem to make sense.  */
elseif|else
if|if
condition|(
name|dont_return_target
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|temp
return|;
comment|/* Return TARGET itself if it is a hard register.  */
elseif|else
if|if
condition|(
name|want_value
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
return|return
name|copy_to_reg
argument_list|(
name|target
argument_list|)
return|;
else|else
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if EXP just contains zeros.  */
end_comment

begin_function
specifier|static
name|int
name|is_zeros_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|elt
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
return|return
name|is_zeros_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|integer_zerop
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|is_zeros_p
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|is_zeros_p
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
case|case
name|REAL_CST
case|:
return|return
name|REAL_VALUES_IDENTICAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|dconst0
argument_list|)
return|;
case|case
name|VECTOR_CST
case|:
for|for
control|(
name|elt
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
if|if
condition|(
operator|!
name|is_zeros_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
return|return
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
operator|==
name|NULL_TREE
return|;
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
if|if
condition|(
operator|!
name|is_zeros_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if EXP contains mostly (3/4)  zeros.  */
end_comment

begin_function
specifier|static
name|int
name|mostly_zeros_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|int
name|elts
init|=
literal|0
decl_stmt|,
name|zeros
init|=
literal|0
decl_stmt|;
name|tree
name|elt
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
comment|/* If there are no ranges of true bits, it is all zero.  */
return|return
name|elt
operator|==
name|NULL_TREE
return|;
block|}
for|for
control|(
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
comment|/* We do not handle the case where the index is a RANGE_EXPR, 	     so the statistic will be somewhat inaccurate. 	     We do make a more accurate count in store_constructor itself, 	     so since this function is only used for nested array elements, 	     this should be close enough.  */
if|if
condition|(
name|mostly_zeros_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
name|zeros
operator|++
expr_stmt|;
name|elts
operator|++
expr_stmt|;
block|}
return|return
literal|4
operator|*
name|zeros
operator|>=
literal|3
operator|*
name|elts
return|;
block|}
return|return
name|is_zeros_p
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for store_constructor.    TARGET, BITSIZE, BITPOS, MODE, EXP are as for store_field.    TYPE is the type of the CONSTRUCTOR, not the element type.    CLEARED is as for store_constructor.    ALIAS_SET is the alias set to use for any stores.     This provides a recursive shortcut back to store_constructor when it isn't    necessary to go through store_field.  This is so that we can pass through    the cleared field to let store_constructor know that we may not have to    clear a substructure if the outer structure has already been cleared.  */
end_comment

begin_function
specifier|static
name|void
name|store_constructor_field
parameter_list|(
name|target
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|mode
parameter_list|,
name|exp
parameter_list|,
name|type
parameter_list|,
name|cleared
parameter_list|,
name|alias_set
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bitsize
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|exp
decl_stmt|,
name|type
decl_stmt|;
name|int
name|cleared
decl_stmt|;
name|int
name|alias_set
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
comment|/* If we have a non-zero bitpos for a register target, then we just 	 let store_field do the bitfield handling.  This is unlikely to 	 generate unnecessary clear instructions anyways.  */
operator|&&
operator|(
name|bitpos
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|target
operator|=
name|adjust_address
argument_list|(
name|target
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|BLKmode
operator|||
literal|0
operator|!=
operator|(
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|)
condition|?
name|BLKmode
else|:
name|VOIDmode
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Update the alias set, if required.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|target
argument_list|)
operator|&&
name|MEM_ALIAS_SET
argument_list|(
name|target
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|target
operator|=
name|copy_rtx
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|target
argument_list|,
name|alias_set
argument_list|)
expr_stmt|;
block|}
name|store_constructor
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|cleared
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
name|store_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|alias_set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the value of constructor EXP into the rtx TARGET.    TARGET is either a REG or a MEM; we know it cannot conflict, since    safe_from_p has been called.    CLEARED is true if TARGET is known to have been zero'd.    SIZE is the number of bytes of TARGET we are allowed to modify: this    may not be the same as the size of EXP if we are assigning to a field    which has been packed to exclude padding bits.  */
end_comment

begin_function
specifier|static
name|void
name|store_constructor
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|cleared
parameter_list|,
name|size
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|cleared
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
name|HOST_WIDE_INT
name|exp_size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
block|{
name|tree
name|elt
decl_stmt|;
comment|/* We either clear the aggregate or indicate the value is dead.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
operator|!
name|cleared
operator|&&
operator|!
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
condition|)
comment|/* If the constructor is empty, clear the union.  */
block|{
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we are building a static constructor into a register, 	 set the initial value as zero so we can fold the value into 	 a constant.  But if more than one register is involved, 	 this probably loses.  */
elseif|else
if|if
condition|(
operator|!
name|cleared
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the constructor has fewer fields than the structure 	 or if we are initializing the structure to mostly zeros, 	 clear the whole structure first.  Don't do this if TARGET is a 	 register whose mode size isn't equal to SIZE since clear_storage 	 can't handle this case.  */
elseif|else
if|if
condition|(
operator|!
name|cleared
operator|&&
name|size
operator|>
literal|0
operator|&&
operator|(
operator|(
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|fields_length
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|mostly_zeros_p
argument_list|(
name|exp
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|==
name|size
operator|)
operator|)
condition|)
block|{
name|clear_storage
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cleared
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store each element of the constructor into 	 the corresponding field of TARGET.  */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
name|tree
name|field
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|rtx
name|to_rtx
init|=
name|target
decl_stmt|;
comment|/* Just ignore missing fields. 	     We cleared the whole structure, above, 	     if any fields are missing.  */
if|if
condition|(
name|field
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cleared
operator|&&
name|is_zeros_p
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|bitsize
operator|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|bitsize
operator|=
operator|-
literal|1
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|offset
operator|=
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|bitpos
operator|=
name|int_bit_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|bitpos
operator|=
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|rtx
name|offset_rtx
decl_stmt|;
if|if
condition|(
name|contains_placeholder_p
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|offset
argument_list|,
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|offset_rtx
operator|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|Pmode
condition|)
name|offset_rtx
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|ptr_mode
condition|)
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|to_rtx
operator|=
name|offset_address
argument_list|(
name|to_rtx
argument_list|,
name|offset_rtx
argument_list|,
name|highest_pow2_factor
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
condition|)
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
comment|/* If this initializes a field that is smaller than a word, at the 	     start of a word, try to widen it to a full word. 	     This special case allows us to output C++ member function 	     initializations in a form that the optimizers can understand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|bitsize
operator|<
name|BITS_PER_WORD
operator|&&
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|exp_size
operator|>=
literal|0
operator|&&
name|bitpos
operator|+
name|BITS_PER_WORD
operator|<=
name|exp_size
operator|*
name|BITS_PER_UNIT
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
block|{
name|type
operator|=
name|type_for_size
argument_list|(
name|BITS_PER_WORD
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|value
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|build_int_2
argument_list|(
name|BITS_PER_WORD
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|BITS_PER_WORD
expr_stmt|;
name|mode
operator|=
name|word_mode
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|to_rtx
argument_list|)
operator|&&
name|DECL_NONADDRESSABLE_P
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|store_constructor_field
argument_list|(
name|to_rtx
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|type
argument_list|,
name|cleared
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
name|tree
name|elt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|need_to_clear
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|elttype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|const_bounds_p
decl_stmt|;
name|HOST_WIDE_INT
name|minelt
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|maxelt
init|=
literal|0
decl_stmt|;
comment|/* Vectors are like arrays, but the domain is stored via an array 	 type indirectly.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
comment|/* Note that although TYPE_DEBUG_REPRESENTATION_TYPE uses 	     the same field as TYPE_DOMAIN, we are not guaranteed that 	     it always will.  */
name|domain
operator|=
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|domain
operator|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|domain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|const_bounds_p
operator|=
operator|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
comment|/* If we have constant bounds for the range of the type, get them.  */
if|if
condition|(
name|const_bounds_p
condition|)
block|{
name|minelt
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|maxelt
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the constructor has fewer elements than the array,          clear the whole array first.  Similarly if this is          static constructor of a non-BLKmode object.  */
if|if
condition|(
name|cleared
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
name|need_to_clear
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|,
name|zero_count
init|=
literal|0
decl_stmt|;
name|need_to_clear
operator|=
operator|!
name|const_bounds_p
expr_stmt|;
comment|/* This loop is a more accurate version of the loop in 	     mostly_zeros_p (it handles RANGE_EXPR in an index). 	     It is also needed to check for missing elements.  */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|need_to_clear
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
name|tree
name|index
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|this_node_count
decl_stmt|;
if|if
condition|(
name|index
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|tree
name|lo_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|hi_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|lo_index
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|hi_index
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|need_to_clear
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|this_node_count
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|hi_index
argument_list|,
literal|1
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|lo_index
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
name|this_node_count
operator|=
literal|1
expr_stmt|;
name|count
operator|+=
name|this_node_count
expr_stmt|;
if|if
condition|(
name|mostly_zeros_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
name|zero_count
operator|+=
name|this_node_count
expr_stmt|;
block|}
comment|/* Clear the entire array first if there are any missing elements, 	     or if the incidence of zero elements is>= 75%.  */
if|if
condition|(
operator|!
name|need_to_clear
operator|&&
operator|(
name|count
operator|<
name|maxelt
operator|-
name|minelt
operator|+
literal|1
operator|||
literal|4
operator|*
name|zero_count
operator|>=
literal|3
operator|*
name|count
operator|)
condition|)
name|need_to_clear
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_to_clear
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|cleared
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|clear_storage
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
comment|/* Inform later passes that the old value is dead.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store each element of the constructor into 	 the corresponding element of TARGET, determined 	 by counting the elements.  */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|rtx
name|xtarget
init|=
name|target
decl_stmt|;
if|if
condition|(
name|cleared
operator|&&
name|is_zeros_p
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|bitsize
operator|=
operator|(
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|?
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
else|:
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|tree
name|lo_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|hi_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|index_r
decl_stmt|,
name|pos_rtx
decl_stmt|,
name|hi_r
decl_stmt|,
name|loop_top
decl_stmt|,
name|loop_end
decl_stmt|;
name|struct
name|nesting
modifier|*
name|loop
decl_stmt|;
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|count
decl_stmt|;
name|tree
name|position
decl_stmt|;
comment|/* If the range is constant and "small", unroll the loop.  */
if|if
condition|(
name|const_bounds_p
operator|&&
name|host_integerp
argument_list|(
name|lo_index
argument_list|,
literal|0
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|hi_index
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|lo
operator|=
name|tree_low_cst
argument_list|(
name|lo_index
argument_list|,
literal|0
argument_list|)
operator|,
name|hi
operator|=
name|tree_low_cst
argument_list|(
name|hi_index
argument_list|,
literal|0
argument_list|)
operator|,
name|count
operator|=
name|hi
operator|-
name|lo
operator|+
literal|1
operator|,
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
operator|||
name|count
operator|<=
literal|2
operator|||
operator|(
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
name|count
operator|<=
literal|40
operator|*
literal|8
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|lo
operator|-=
name|minelt
expr_stmt|;
name|hi
operator|-=
name|minelt
expr_stmt|;
for|for
control|(
init|;
name|lo
operator|<=
name|hi
condition|;
name|lo
operator|++
control|)
block|{
name|bitpos
operator|=
name|lo
operator|*
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|target
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_NONALIASED_COMPONENT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|target
operator|=
name|copy_rtx
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|store_constructor_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|type
argument_list|,
name|cleared
argument_list|,
name|get_alias_set
argument_list|(
name|elttype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hi_r
operator|=
name|expand_expr
argument_list|(
name|hi_index
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop_top
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|loop_end
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|index
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|index_r
operator|=
name|gen_reg_rtx
argument_list|(
name|promote_mode
argument_list|(
name|domain
argument_list|,
name|DECL_MODE
argument_list|(
name|index
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|index
argument_list|,
name|index_r
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|SAVE_EXPR_RTL
argument_list|(
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Make sure value gets expanded once before the                          loop.  */
name|expand_expr
argument_list|(
name|value
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
name|store_expr
argument_list|(
name|lo_index
argument_list|,
name|index_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop
operator|=
name|expand_start_loop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Assign value to element index.  */
name|position
operator|=
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|position
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|elttype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pos_rtx
operator|=
name|expand_expr
argument_list|(
name|position
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|offset_address
argument_list|(
name|target
argument_list|,
name|pos_rtx
argument_list|,
name|highest_pow2_factor
argument_list|(
name|position
argument_list|)
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|adjust_address
argument_list|(
name|xtarget
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|store_constructor
argument_list|(
name|value
argument_list|,
name|xtarget
argument_list|,
name|cleared
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|store_expr
argument_list|(
name|value
argument_list|,
name|xtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
name|loop
argument_list|,
name|build
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|index
argument_list|,
name|hi_index
argument_list|)
argument_list|)
expr_stmt|;
name|expand_increment
argument_list|(
name|build
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|index
operator|!=
literal|0
operator|&&
operator|!
name|host_integerp
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|position
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|index
operator|=
name|ssize_int
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|minelt
condition|)
name|index
operator|=
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|index
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|elttype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|offset_address
argument_list|(
name|target
argument_list|,
name|expand_expr
argument_list|(
name|position
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|highest_pow2_factor
argument_list|(
name|position
argument_list|)
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|adjust_address
argument_list|(
name|xtarget
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|value
argument_list|,
name|xtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
name|bitpos
operator|=
operator|(
operator|(
name|tree_low_cst
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
operator|-
name|minelt
operator|)
operator|*
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
else|else
name|bitpos
operator|=
operator|(
name|i
operator|*
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|target
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_NONALIASED_COMPONENT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|target
operator|=
name|copy_rtx
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|store_constructor_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|type
argument_list|,
name|cleared
argument_list|,
name|get_alias_set
argument_list|(
name|elttype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Set constructor assignments.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
name|tree
name|elt
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|nbytes
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|,
name|nbits
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|domain_min
decl_stmt|,
name|domain_max
decl_stmt|,
name|bitlength
decl_stmt|;
comment|/* The default implementation strategy is to extract the constant 	 parts of the constructor, use that to initialize the target, 	 and then "or" in whatever non-constant ranges we need in addition.  	 If a large set is all zero or all ones, it is 	 probably better to set it using memset (if available) or bzero. 	 Also, if a large set has just a single range, it may also be 	 better to first clear all the first clear the set (using 	 bzero/memset), and set the bits we want.  */
comment|/* Check for all zeros.  */
if|if
condition|(
name|elt
operator|==
name|NULL_TREE
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|cleared
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|domain_min
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
name|domain_max
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
name|bitlength
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_diffop
argument_list|(
name|domain_max
argument_list|,
name|domain_min
argument_list|)
argument_list|,
name|ssize_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|nbits
operator|=
name|tree_low_cst
argument_list|(
name|bitlength
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* For "small" sets, or "medium-sized" (up to 32 bytes) sets that 	 are "complicated" (more than one range), initialize (the 	 constant parts) by copying from a constant.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
operator|||
name|nbits
operator|<=
literal|2
operator|*
name|BITS_PER_WORD
operator|||
operator|(
name|nbytes
operator|<=
literal|32
operator|&&
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|!=
name|NULL_TREE
operator|)
condition|)
block|{
name|unsigned
name|int
name|set_word_size
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|set_word_size
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|bit_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nbits
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|word
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|bit_pos
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|ibit
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* In bytes from beginning of set.  */
name|elt
operator|=
name|get_set_constructor_bits
argument_list|(
name|exp
argument_list|,
name|bit_buffer
argument_list|,
name|nbits
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|bit_buffer
index|[
name|ibit
index|]
condition|)
block|{
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|word
operator||=
operator|(
literal|1
operator|<<
operator|(
name|set_word_size
operator|-
literal|1
operator|-
name|bit_pos
operator|)
operator|)
expr_stmt|;
else|else
name|word
operator||=
literal|1
operator|<<
name|bit_pos
expr_stmt|;
block|}
name|bit_pos
operator|++
expr_stmt|;
name|ibit
operator|++
expr_stmt|;
if|if
condition|(
name|bit_pos
operator|>=
name|set_word_size
operator|||
name|ibit
operator|==
name|nbits
condition|)
block|{
if|if
condition|(
name|word
operator|!=
literal|0
operator|||
operator|!
name|cleared
condition|)
block|{
name|rtx
name|datum
init|=
name|GEN_INT
argument_list|(
name|word
argument_list|)
decl_stmt|;
name|rtx
name|to_rtx
decl_stmt|;
comment|/* The assumption here is that it is safe to use 			 XEXP if the set is multi-word, but not if 			 it's single-word.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|to_rtx
operator|=
name|adjust_address
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|target
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to_rtx
argument_list|,
name|datum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ibit
operator|==
name|nbits
condition|)
break|break;
name|word
operator|=
literal|0
expr_stmt|;
name|bit_pos
operator|=
literal|0
expr_stmt|;
name|offset
operator|+=
name|set_word_size
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|cleared
condition|)
comment|/* Don't bother clearing storage if the set is all ones.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|!=
name|NULL_TREE
operator|||
operator|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
operator|==
name|NULL_TREE
condition|?
name|nbits
operator|!=
literal|1
else|:
operator|(
operator|!
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
operator|!=
operator|(
name|HOST_WIDE_INT
operator|)
name|nbits
operator|)
operator|)
operator|)
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elt
operator|!=
name|NULL_TREE
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
comment|/* Start of range of element or NULL.  */
name|tree
name|startbit
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
comment|/* End of range of element, or element value.  */
name|tree
name|endbit
init|=
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|HOST_WIDE_INT
name|startb
decl_stmt|,
name|endb
decl_stmt|;
endif|#
directive|endif
name|rtx
name|bitlength_rtx
decl_stmt|,
name|startbit_rtx
decl_stmt|,
name|endbit_rtx
decl_stmt|,
name|targetx
decl_stmt|;
name|bitlength_rtx
operator|=
name|expand_expr
argument_list|(
name|bitlength
argument_list|,
name|NULL_RTX
argument_list|,
name|MEM
argument_list|,
name|EXPAND_CONST_ADDRESS
argument_list|)
expr_stmt|;
comment|/* Handle non-range tuple element like [ expr ].  */
if|if
condition|(
name|startbit
operator|==
name|NULL_TREE
condition|)
block|{
name|startbit
operator|=
name|save_expr
argument_list|(
name|endbit
argument_list|)
expr_stmt|;
name|endbit
operator|=
name|startbit
expr_stmt|;
block|}
name|startbit
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|startbit
argument_list|)
expr_stmt|;
name|endbit
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|endbit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|domain_min
argument_list|)
condition|)
block|{
name|startbit
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|startbit
argument_list|,
name|domain_min
argument_list|)
expr_stmt|;
name|endbit
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|endbit
argument_list|,
name|domain_min
argument_list|)
expr_stmt|;
block|}
name|startbit_rtx
operator|=
name|expand_expr
argument_list|(
name|startbit
argument_list|,
name|NULL_RTX
argument_list|,
name|MEM
argument_list|,
name|EXPAND_CONST_ADDRESS
argument_list|)
expr_stmt|;
name|endbit_rtx
operator|=
name|expand_expr
argument_list|(
name|endbit
argument_list|,
name|NULL_RTX
argument_list|,
name|MEM
argument_list|,
name|EXPAND_CONST_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|targetx
operator|=
name|assign_temp
argument_list|(
operator|(
name|build_qualified_type
argument_list|(
name|type_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|targetx
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|targetx
operator|=
name|target
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
comment|/* Optimization:  If startbit and endbit are 	     constants divisible by BITS_PER_UNIT, 	     call memset instead.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|startbit
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|endbit
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|startb
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|startbit
argument_list|)
operator|)
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
operator|&&
operator|(
name|endb
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|endbit
argument_list|)
operator|+
literal|1
operator|)
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
condition|)
block|{
name|emit_library_call
argument_list|(
name|memset_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|targetx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|startb
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|constm1_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|endb
operator|-
name|startb
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__setbits"
argument_list|)
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|,
name|XEXP
argument_list|(
name|targetx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|bitlength_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|startbit_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|endbit_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|targetx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the value of EXP (an expression tree)    into a subfield of TARGET which has mode MODE and occupies    BITSIZE bits, starting BITPOS bits from the start of TARGET.    If MODE is VOIDmode, it means that we are storing into a bit-field.     If VALUE_MODE is VOIDmode, return nothing in particular.    UNSIGNEDP is not used in this case.     Otherwise, return an rtx for the value stored.  This rtx    has mode VALUE_MODE if that is convenient to do.    In this case, UNSIGNEDP must be nonzero if the value is an unsigned type.     TYPE is the type of the underlying object,     ALIAS_SET is the alias set for the destination.  This value will    (in general) be different from that for TARGET, since TARGET is a    reference to the containing structure.  */
end_comment

begin_function
specifier|static
name|rtx
name|store_field
parameter_list|(
name|target
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|mode
parameter_list|,
name|exp
parameter_list|,
name|value_mode
parameter_list|,
name|unsignedp
parameter_list|,
name|type
parameter_list|,
name|alias_set
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|enum
name|machine_mode
name|value_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|alias_set
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|width_mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|const0_rtx
return|;
comment|/* If we have nothing to store, do nothing unless the expression has      side-effects.  */
if|if
condition|(
name|bitsize
operator|==
literal|0
condition|)
return|return
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|bitsize
operator|>=
literal|0
operator|&&
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|width_mask
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If we are storing into an unaligned field of an aligned union that is      in a register, we may have the mode of TARGET being an integer mode but      MODE == BLKmode.  In that case, get an aligned object whose size and      alignment are the same as TARGET and store TARGET into it (we can avoid      the store if the field being stored is the entire width of TARGET).  Then      call ourselves recursively to store the field into a BLKmode version of      that object.  Finally, load from the object into TARGET.  This is not      very efficient in general, but should only be slightly more expensive      than the otherwise-required unaligned accesses.  Perhaps this can be      cleaned up later.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
block|{
name|rtx
name|object
init|=
name|assign_temp
argument_list|(
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
name|TYPE_QUAL_CONST
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|blk_object
init|=
name|adjust_address
argument_list|(
name|object
argument_list|,
name|BLKmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitsize
operator|!=
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|object
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|store_field
argument_list|(
name|blk_object
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|object
argument_list|)
expr_stmt|;
comment|/* We want to return the BLKmode version of the data.  */
return|return
name|blk_object
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
comment|/* We're storing into a struct containing a single __complex.  */
if|if
condition|(
name|bitpos
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|store_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* If the structure is in a register or if the component      is a bit field, we cannot use addressing to access it.      Use bit-field techniques or SUBREG to store in it.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
operator|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|!
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
operator|)
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
comment|/* If the field isn't aligned enough to store as an ordinary memref, 	 store it as a bit field.  */
operator|||
operator|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|mode
argument_list|,
name|MEM_ALIGN
argument_list|(
name|target
argument_list|)
argument_list|)
operator|&&
operator|(
name|MEM_ALIGN
argument_list|(
name|target
argument_list|)
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|||
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
comment|/* If the RHS and field are a constant size and the size of the 	 RHS isn't the same size as the bitfield, we must use bitfield 	 operations.  */
operator|||
operator|(
name|bitsize
operator|>=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|compare_tree_int
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|bitsize
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If BITSIZE is narrower than the size of the type of EXP 	 we will be narrowing TEMP.  Normally, what's wanted are the 	 low-order bits.  However, if EXP's type is a record and this is 	 big-endian machine, we want the upper BITSIZE bits.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|bitsize
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|temp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|-
name|bitsize
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Unless MODE is VOIDmode or BLKmode, convert TEMP to 	 MODE.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the modes of TARGET and TEMP are both BLKmode, both 	 must be in memory and BITPOS must be aligned on a byte 	 boundary.  If so, we simply do a block copy.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|MEM
operator|||
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|target
operator|=
name|adjust_address
argument_list|(
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|bitsize
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_mode
operator|==
name|VOIDmode
condition|?
name|const0_rtx
else|:
name|target
return|;
block|}
comment|/* Store the value in the bitfield.  */
name|store_bit_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_mode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* The caller wants an rtx for the value. 	     If possible, avoid refetching from the bitfield itself.  */
if|if
condition|(
name|width_mask
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
condition|)
block|{
name|tree
name|count
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|tmode
operator|=
name|GET_MODE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmode
operator|==
name|VOIDmode
condition|)
name|tmode
operator|=
name|value_mode
expr_stmt|;
if|if
condition|(
name|unsignedp
condition|)
return|return
name|expand_and
argument_list|(
name|tmode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|width_mask
argument_list|,
name|tmode
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
return|;
name|count
operator|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tmode
argument_list|,
name|temp
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|tmode
argument_list|,
name|temp
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|extract_bit_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
name|NULL_RTX
argument_list|,
name|value_mode
argument_list|,
name|VOIDmode
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
return|return
name|const0_rtx
return|;
block|}
else|else
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|to_rtx
init|=
name|target
decl_stmt|;
comment|/* If a value is wanted, it must be the lhs; 	 so make the address stable for multiple use.  */
if|if
condition|(
name|value_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|addr
argument_list|)
comment|/* A frame-pointer reference is already stable.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
operator|||
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|)
operator|)
condition|)
name|to_rtx
operator|=
name|replace_equiv_address
argument_list|(
name|to_rtx
argument_list|,
name|copy_to_reg
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now build a reference to just the desired component.  */
name|to_rtx
operator|=
name|adjust_address
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_rtx
operator|==
name|target
condition|)
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|to_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|to_rtx
argument_list|)
operator|&&
name|MEM_ALIAS_SET
argument_list|(
name|to_rtx
argument_list|)
operator|!=
literal|0
condition|)
name|set_mem_alias_set
argument_list|(
name|to_rtx
argument_list|,
name|alias_set
argument_list|)
expr_stmt|;
return|return
name|store_expr
argument_list|(
name|exp
argument_list|,
name|to_rtx
argument_list|,
name|value_mode
operator|!=
name|VOIDmode
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression EXP that may be a COMPONENT_REF, a BIT_FIELD_REF,    an ARRAY_REF, or an ARRAY_RANGE_REF, look for nested operations of these    codes and find the ultimate containing object, which we return.     We set *PBITSIZE to the size in bits that we want, *PBITPOS to the    bit position, and *PUNSIGNEDP to the signedness of the field.    If the position of the field is variable, we store a tree    giving the variable offset (in units) in *POFFSET.    This offset is in addition to the bit position.    If the position is not variable, we store 0 in *POFFSET.     If any of the extraction expressions is volatile,    we store 1 in *PVOLATILEP.  Otherwise we don't change that.     If the field is a bit-field, *PMODE is set to VOIDmode.  Otherwise, it    is a mode that can be used to access the field.  In that case, *PBITSIZE    is redundant.     If the field describes a variable-sized object, *PMODE is set to    VOIDmode and *PBITSIZE is set to -1.  An access cannot be made in    this case, but the address of the object can be found.  */
end_comment

begin_function
name|tree
name|get_inner_reference
parameter_list|(
name|exp
parameter_list|,
name|pbitsize
parameter_list|,
name|pbitpos
parameter_list|,
name|poffset
parameter_list|,
name|pmode
parameter_list|,
name|punsignedp
parameter_list|,
name|pvolatilep
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|pbitsize
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|pbitpos
decl_stmt|;
name|tree
modifier|*
name|poffset
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|pmode
decl_stmt|;
name|int
modifier|*
name|punsignedp
decl_stmt|;
name|int
modifier|*
name|pvolatilep
decl_stmt|;
block|{
name|tree
name|size_tree
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|tree
name|offset
init|=
name|size_zero_node
decl_stmt|;
name|tree
name|bit_offset
init|=
name|bitsize_zero_node
decl_stmt|;
name|tree
name|placeholder_ptr
init|=
literal|0
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* First get the mode, signedness, and size.  We do this from just the      outermost expression.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|size_tree
operator|=
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|size_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|size_tree
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|pbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size_tree
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size_tree
argument_list|,
literal|1
argument_list|)
condition|)
name|mode
operator|=
name|BLKmode
operator|,
operator|*
name|pbitsize
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|pbitsize
operator|=
name|tree_low_cst
argument_list|(
name|size_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Compute cumulative bit-offset for nested component-refs and array-refs,      and find the ultimate containing object.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
name|bit_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_offset
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|this_offset
init|=
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|/* If this field hasn't been filled in yet, don't go 	     past it.  This should only happen when folding expressions 	     made during type construction.  */
if|if
condition|(
name|this_offset
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|this_offset
argument_list|)
operator|&&
name|contains_placeholder_p
argument_list|(
name|this_offset
argument_list|)
condition|)
name|this_offset
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|this_offset
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|this_offset
argument_list|)
expr_stmt|;
name|bit_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_offset
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Right now we don't do anything with DECL_OFFSET_ALIGN.  */
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|array
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|low_bound
init|=
operator|(
name|domain
condition|?
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
name|tree
name|unit_size
init|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We assume all arrays have sizes that are a multiple of a byte. 	     First subtract the lower bound, if any, in the type of the 	     index, then convert to sizetype and multiply by the size of the 	     array element.  */
if|if
condition|(
name|low_bound
operator|!=
literal|0
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|low_bound
argument_list|)
condition|)
name|index
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|low_bound
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the index has a self-referential type, pass it to a 	     WITH_RECORD_EXPR; if the component size is, pass our 	     component to one.  */
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|index
argument_list|)
operator|&&
name|contains_placeholder_p
argument_list|(
name|index
argument_list|)
condition|)
name|index
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|unit_size
argument_list|)
operator|&&
name|contains_placeholder_p
argument_list|(
name|unit_size
argument_list|)
condition|)
name|unit_size
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|unit_size
argument_list|,
name|array
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|index
argument_list|)
argument_list|,
name|unit_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
block|{
name|tree
name|new
init|=
name|find_placeholder
argument_list|(
name|exp
argument_list|,
operator|&
name|placeholder_ptr
argument_list|)
decl_stmt|;
comment|/* If we couldn't find the replacement, return the PLACEHOLDER_EXPR. 	     We might have been called from tree optimization where we 	     haven't set up an object yet.  */
if|if
condition|(
name|new
operator|==
literal|0
condition|)
break|break;
else|else
name|exp
operator|=
name|new
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|NON_LVALUE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|VIEW_CONVERT_EXPR
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
break|break;
comment|/* If any reference in the chain is volatile, the effect is volatile.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
operator|*
name|pvolatilep
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If OFFSET is constant, see if we can return the whole thing as a      constant bit position.  Otherwise, split it up.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|offset
argument_list|)
argument_list|,
name|bitsize_unit_node
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|tem
argument_list|,
name|bit_offset
argument_list|)
operator|)
operator|&&
name|host_integerp
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
condition|)
operator|*
name|pbitpos
operator|=
name|tree_low_cst
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|,
operator|*
name|poffset
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|pbitpos
operator|=
name|tree_low_cst
argument_list|(
name|bit_offset
argument_list|,
literal|0
argument_list|)
operator|,
operator|*
name|poffset
operator|=
name|offset
expr_stmt|;
operator|*
name|pmode
operator|=
name|mode
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if T is an expression that get_inner_reference handles.  */
end_comment

begin_function
name|int
name|handled_component_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|BIT_FIELD_REF
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
return|return
literal|1
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
return|return
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an rtx VALUE that may contain additions and multiplications, return    an equivalent value that just refers to a register, memory, or constant.    This is done by generating instructions to perform the arithmetic and    returning a pseudo-register containing the value.     The returned value may be a REG, SUBREG, MEM or constant.  */
end_comment

begin_function
name|rtx
name|force_operand
parameter_list|(
name|value
parameter_list|,
name|target
parameter_list|)
name|rtx
name|value
decl_stmt|,
name|target
decl_stmt|;
block|{
name|optab
name|binoptab
init|=
literal|0
decl_stmt|;
comment|/* Use a temporary to force order of execution of calls to      `force_operand'.  */
name|rtx
name|tmp
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
comment|/* Use subtarget as the target for operand 0 of a binary operation.  */
name|rtx
name|subtarget
init|=
name|get_subtarget
argument_list|(
name|target
argument_list|)
decl_stmt|;
comment|/* Check for a PIC address load.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|subtarget
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|subtarget
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|subtarget
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PLUS
condition|)
name|binoptab
operator|=
name|add_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MINUS
condition|)
name|binoptab
operator|=
name|sub_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|op2
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|op2
operator|!=
name|subtarget
operator|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
return|return
name|expand_mult
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|force_operand
argument_list|(
name|op2
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|binoptab
condition|)
block|{
name|op2
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|op2
operator|!=
name|subtarget
operator|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|binoptab
operator|==
name|sub_optab
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|binoptab
operator|=
name|add_optab
expr_stmt|;
name|op2
operator|=
name|negate_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
comment|/* Check for an addition with OP2 a constant integer and our first 	 operand a PLUS of a virtual register and something else.  In that 	 case, we want to emit the sum of the virtual register and the 	 constant first and then add the other value.  This allows virtual 	 register instantiation to simply modify the constant rather than 	 creating another one around this addition.  */
if|if
condition|(
name|binoptab
operator|==
name|add_optab
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|rtx
name|temp
init|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|binoptab
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op2
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
return|return
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|binoptab
argument_list|,
name|temp
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
block|}
name|tmp
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|binoptab
argument_list|,
name|tmp
argument_list|,
name|force_operand
argument_list|(
name|op2
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
comment|/* We give UNSIGNEDP = 0 to expand_binop 	 because the only operations we are expanding here are signed ones.  */
block|}
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* On machines that have insn scheduling, we want all memory reference to be      explicit, so we need to deal with such paradoxical SUBREGs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|value
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of expand_expr: return nonzero iff there is no way that    EXP can reference X, which is being modified.  TOP_P is nonzero if this    call is going to be used to determine whether we need a temporary    for EXP, as opposed to a recursive call to this function.     It is always safe for this routine to return zero since it merely    searches for optimization opportunities.  */
end_comment

begin_function
name|int
name|safe_from_p
parameter_list|(
name|x
parameter_list|,
name|exp
parameter_list|,
name|top_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|int
name|top_p
decl_stmt|;
block|{
name|rtx
name|exp_rtl
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nops
decl_stmt|;
specifier|static
name|tree
name|save_expr_list
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
comment|/* If EXP has varying size, we MUST use a target since we currently 	 have no way of allocating temporaries of variable size 	 (except for arrays that have TYPE_ARRAY_MAX_SIZE set). 	 So we assume here that something at a higher level has prevented a 	 clash.  This is somewhat bogus, but the best we can do.  Only 	 do this when X is BLKmode and when we are at the top level.  */
operator|||
operator|(
name|top_p
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|||
name|TYPE_ARRAY_MAX_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_ARRAY_MAX_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|)
comment|/* If X is in the outgoing argument area, it is always safe.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If this is a subreg of a hard register, declare it unsafe, otherwise,      find the underlying pseudo.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
comment|/* A SAVE_EXPR might appear many times in the expression passed to the      top-level safe_from_p call, and if it has a complex subexpression,      examining it multiple times could result in a combinatorial explosion.      E.g. on an Alpha running at least 200MHz, a Fortran test case compiled      with optimization took about 28 minutes to compile -- even though it was      only a few lines long.  So we mark each SAVE_EXPR we see with TREE_PRIVATE      and turn that off when we are done.  We keep a list of the SAVE_EXPRs      we have processed.  Note that the only test of top_p was above.  */
if|if
condition|(
name|top_p
condition|)
block|{
name|int
name|rtn
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|save_expr_list
operator|=
literal|0
expr_stmt|;
name|rtn
operator|=
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|save_expr_list
init|;
name|t
operator|!=
literal|0
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|TREE_PRIVATE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|rtn
return|;
block|}
comment|/* Now look at our tree code and possibly recurse.  */
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
name|exp_rtl
operator|=
name|DECL_RTL_IF_SET
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
return|return
literal|1
return|;
case|case
literal|'x'
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
condition|)
return|return
operator|(
operator|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|||
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|||
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
comment|/* An already-visited SAVE_EXPR? */
else|else
return|return
literal|0
return|;
case|case
literal|'1'
case|:
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|'2'
case|:
case|case
literal|'<'
case|:
return|return
operator|(
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
literal|'e'
case|:
case|case
literal|'r'
case|:
comment|/* Now do code-specific tests.  EXP_RTL is set to any rtx we find in 	 the expression.  If it is set, we conflict iff we are that rtx or 	 both are in memory.  Otherwise, we check all operands of the 	 expression recursively.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
comment|/* If the operand is static or we are static, we can't conflict. 	     Likewise if we don't conflict with the operand at all.  */
if|if
condition|(
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|||
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, the only way this can conflict is if we are taking 	     the address of a DECL a that address if part of X, which is 	     very rare.  */
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|exp
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
else|else
name|exp_rtl
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|alias_sets_conflict_p
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|x
argument_list|)
argument_list|,
name|get_alias_set
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* Assume that the call will clobber all hard registers and 	     all of memory.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|RTL_EXPR
case|:
comment|/* If a sequence exists, we would have to scan every instruction 	     in the sequence to see if it was safe.  This is probably not 	     worthwhile.  */
if|if
condition|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
name|exp_rtl
operator|=
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|exp_rtl
operator|=
name|WITH_CLEANUP_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEANUP_POINT_EXPR
case|:
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
name|exp_rtl
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp_rtl
condition|)
break|break;
comment|/* If we've already scanned this, don't do it again.  Otherwise, 	     show we've scanned it and record for clearing the flag if we're 	     going on.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|1
return|;
name|TREE_PRIVATE
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|TREE_PRIVATE
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|save_expr_list
operator|=
name|tree_cons
argument_list|(
name|exp
argument_list|,
name|NULL_TREE
argument_list|,
name|save_expr_list
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|BIND_EXPR
case|:
comment|/* The only operand we look at is operand 1.  The rest aren't 	     part of the expression.  */
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|METHOD_CALL_EXPR
case|:
comment|/* This takes an rtx argument, but shouldn't appear here.  */
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
comment|/* If we have an rtx, we do not need to scan our operands.  */
if|if
condition|(
name|exp_rtl
condition|)
break|break;
name|nops
operator|=
name|first_rtl_op
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is a language-specific tree code, it may require 	 special handling.  */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|&&
operator|!
call|(
modifier|*
name|lang_hooks
operator|.
name|safe_from_p
call|)
argument_list|(
name|x
argument_list|,
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* If we have an rtl, find any enclosed object.  Then see if we conflict      with it.  */
if|if
condition|(
name|exp_rtl
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp_rtl
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|exp_rtl
operator|=
name|SUBREG_REG
argument_list|(
name|exp_rtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp_rtl
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|exp_rtl
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
comment|/* If the rtl is X, then it is not safe.  Otherwise, it is unless both 	 are memory and they conflict.  */
return|return
operator|!
operator|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|exp_rtl
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|exp_rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|true_dependence
argument_list|(
name|exp_rtl
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|rtx_addr_varies_p
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/* If we reach here, it is safe.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of expand_expr: return rtx if EXP is a    variable or parameter; else return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|var_rtx
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|PARM_DECL
case|:
case|case
name|VAR_DECL
case|:
return|return
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAX_INTEGER_COMPUTATION_MODE
end_ifdef

begin_function
name|void
name|check_max_integer_computation_mode
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Strip any NOPs that don't change the mode.  */
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* We must allow conversions of constants to MAX_INTEGER_COMPUTATION_MODE.  */
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return;
comment|/* First check the type of the overall operation.   We need only look at      unary, binary and relational operations.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|internal_error
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
block|}
comment|/* Check operand of a unary op.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|internal_error
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
block|}
comment|/* Check operands of a binary/comparison op.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|internal_error
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|internal_error
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return the highest power of two that EXP is known to be a multiple of.    This is used in updating alignment of MEMs in array references.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|highest_pow2_factor
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|c0
decl_stmt|,
name|c1
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
comment|/* We can find the lowest bit that's a one.  If the low 	 HOST_BITS_PER_WIDE_INT bits are zero, return BIGGEST_ALIGNMENT. 	 We need to handle this case since we can find it in a COND_EXPR, 	 a MIN_EXPR, or a MAX_EXPR.  If the constant overlows, we have an 	 erroneous program, so return BIGGEST_ALIGNMENT to avoid any 	 later ICE.  */
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|BIGGEST_ALIGNMENT
return|;
else|else
block|{
comment|/* Note: tree_low_cst is intentionally not used here, 	     we don't care about the upper bits.  */
name|c0
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|c0
operator|&=
operator|-
name|c0
expr_stmt|;
return|return
name|c0
condition|?
name|c0
else|:
name|BIGGEST_ALIGNMENT
return|;
block|}
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
name|c0
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
return|;
case|case
name|MULT_EXPR
case|:
name|c0
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c0
operator|*
name|c1
return|;
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
if|if
condition|(
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|c0
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
name|c0
operator|/
name|c1
argument_list|)
return|;
block|}
break|break;
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|WITH_RECORD_EXPR
case|:
return|return
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
name|c0
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similar, except that it is known that the expression must be a multiple    of the alignment of TYPE.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|highest_pow2_factor_for_type
parameter_list|(
name|type
parameter_list|,
name|exp
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|exp
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|type_align
decl_stmt|,
name|factor
decl_stmt|;
name|factor
operator|=
name|highest_pow2_factor
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type_align
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
return|return
name|MAX
argument_list|(
name|factor
argument_list|,
name|type_align
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an object on the placeholder list that matches EXP, a    PLACEHOLDER_EXPR.  An object "matches" if it is of the type of the    PLACEHOLDER_EXPR or a pointer type to it.  For further information, see    tree.def.  If no such object is found, return 0.  If PLIST is nonzero, it    is a location which initially points to a starting location in the    placeholder list (zero means start of the list) and where a pointer into    the placeholder list at which the object is found is placed.  */
end_comment

begin_function
name|tree
name|find_placeholder
parameter_list|(
name|exp
parameter_list|,
name|plist
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|tree
modifier|*
name|plist
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|placeholder_expr
decl_stmt|;
for|for
control|(
name|placeholder_expr
operator|=
name|plist
operator|&&
operator|*
name|plist
condition|?
name|TREE_CHAIN
argument_list|(
operator|*
name|plist
argument_list|)
else|:
name|placeholder_list
init|;
name|placeholder_expr
operator|!=
literal|0
condition|;
name|placeholder_expr
operator|=
name|TREE_CHAIN
argument_list|(
name|placeholder_expr
argument_list|)
control|)
block|{
name|tree
name|need_type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|elt
decl_stmt|;
comment|/* Find the outermost reference that is of the type we want.  If none, 	 see if any object has a type that is a pointer to the type we 	 want.  */
for|for
control|(
name|elt
operator|=
name|TREE_PURPOSE
argument_list|(
name|placeholder_expr
argument_list|)
init|;
name|elt
operator|!=
literal|0
condition|;
name|elt
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COND_EXPR
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|1
argument_list|)
else|:
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'e'
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
else|:
literal|0
operator|)
control|)
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
name|need_type
condition|)
block|{
if|if
condition|(
name|plist
condition|)
operator|*
name|plist
operator|=
name|placeholder_expr
expr_stmt|;
return|return
name|elt
return|;
block|}
for|for
control|(
name|elt
operator|=
name|TREE_PURPOSE
argument_list|(
name|placeholder_expr
argument_list|)
init|;
name|elt
operator|!=
literal|0
condition|;
name|elt
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COND_EXPR
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|1
argument_list|)
else|:
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'e'
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
else|:
literal|0
operator|)
control|)
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
operator|==
name|need_type
operator|)
condition|)
block|{
if|if
condition|(
name|plist
condition|)
operator|*
name|plist
operator|=
name|placeholder_expr
expr_stmt|;
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|need_type
argument_list|,
name|elt
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* expand_expr: generate code for computing expression EXP.    An rtx for the computed value is returned.  The value is never null.    In the case of a void EXP, const0_rtx is returned.     The value may be stored in TARGET if TARGET is nonzero.    TARGET is just a suggestion; callers must assume that    the rtx returned may not be the same as TARGET.     If TARGET is CONST0_RTX, it means that the value will be ignored.     If TMODE is not VOIDmode, it suggests generating the    result in mode TMODE.  But this is done only when convenient.    Otherwise, TMODE is ignored and the value generated in its natural mode.    TMODE is just a suggestion; callers must assume that    the rtx returned may not have mode TMODE.     Note that TARGET may have neither TMODE nor MODE.  In that case, it    probably will not be used.     If MODIFIER is EXPAND_SUM then when EXP is an addition    we can return an rtx of the form (MULT (REG ...) (CONST_INT ...))    or a nest of (PLUS ...) and (MINUS ...) where the terms are    products as above, or REG or MEM, or constant.    Ordinarily in such cases we would output mul or add instructions    and then return a pseudo reg containing the sum.     EXPAND_INITIALIZER is much like EXPAND_SUM except that    it also marks a label as absolutely required (it can't be dead).    It also makes a ZERO_EXTEND or SIGN_EXTEND instead of emitting extend insns.    This is used for outputting expressions used in initializers.     EXPAND_CONST_ADDRESS says that it is okay to return a MEM    with a constant address even if that address is not normally legitimate.    EXPAND_INITIALIZER and EXPAND_SUM also have this effect.  */
end_comment

begin_function
name|rtx
name|expand_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|temp
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|optab
name|this_optab
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|,
name|original_target
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|tree
name|context
decl_stmt|;
comment|/* Handle ERROR_MARK before anybody tries to access its type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
name|op0
operator|=
name|CONST0_RTX
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
literal|0
condition|)
return|return
name|op0
return|;
return|return
name|const0_rtx
return|;
block|}
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Use subtarget as the target for operand 0 of a binary operation.  */
name|subtarget
operator|=
name|get_subtarget
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|original_target
operator|=
name|target
expr_stmt|;
name|ignore
operator|=
operator|(
name|target
operator|==
name|const0_rtx
operator|||
operator|(
operator|(
name|code
operator|==
name|NON_LVALUE_EXPR
operator|||
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|REFERENCE_EXPR
operator|||
name|code
operator|==
name|COND_EXPR
operator|||
name|code
operator|==
name|VIEW_CONVERT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|)
operator|)
expr_stmt|;
comment|/* If we are going to ignore this result, we need only do something      if there is a side-effect somewhere in the expression.  If there      is, short-circuit the most common cases here.  Note that we must      not call expand_expr with anything but const0_rtx in case this      is an initial expansion of a size that contains a PLACEHOLDER_EXPR.  */
if|if
condition|(
name|ignore
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* Ensure we reference a volatile object even if value is ignored, but 	 don't do this if all we are doing is taking its address.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
condition|)
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
operator|||
name|code
operator|==
name|COMPONENT_REF
operator|||
name|code
operator|==
name|INDIRECT_REF
operator|||
name|code
operator|==
name|BUFFER_REF
condition|)
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|code
operator|==
name|ARRAY_REF
operator|||
name|code
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
comment|/* If the second operand has no side effects, just evaluate 	   the first.  */
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|target
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAX_INTEGER_COMPUTATION_MODE
comment|/* Only check stuff here if the mode we want is different from the mode      of the expression; if it's the same, check_max_integer_computiation_mode      will handle it.  Do we really need to check this stuff at all?  */
if|if
condition|(
name|target
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ARRAY_RANGE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|BIT_FIELD_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|RTL_EXPR
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|internal_error
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmode
operator|!=
name|mode
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ARRAY_RANGE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|BIT_FIELD_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|RTL_EXPR
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|tmode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|tmode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|internal_error
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
name|check_max_integer_computation_mode
argument_list|(
name|exp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If will do cse, generate all results into pseudo registers      since 1) that allows cse to find more things      and 2) otherwise cse could produce an insn the machine      cannot support.  And exception is a CONSTRUCTOR into a multi-word      MEM: that's much more likely to be most efficient into the MEM.  */
if|if
condition|(
operator|!
name|cse_not_expected
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|target
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|!
operator|(
name|code
operator|==
name|CONSTRUCTOR
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|)
condition|)
name|target
operator|=
name|subtarget
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_DECL
case|:
block|{
name|tree
name|function
init|=
name|decl_function_context
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Handle using a label in a containing function.  */
if|if
condition|(
name|function
operator|!=
name|current_function_decl
operator|&&
name|function
operator|!=
name|inline_function_decl
operator|&&
name|function
operator|!=
literal|0
condition|)
block|{
name|struct
name|function
modifier|*
name|p
init|=
name|find_function_data
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|p
operator|->
name|expr
operator|->
name|x_forced_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|label_rtx
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
operator|->
name|expr
operator|->
name|x_forced_labels
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
name|forced_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|label_rtx
argument_list|(
name|exp
argument_list|)
argument_list|,
name|forced_labels
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label_rtx
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|!=
name|current_function_decl
operator|&&
name|function
operator|!=
name|inline_function_decl
operator|&&
name|function
operator|!=
literal|0
condition|)
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|exp
argument_list|,
literal|"prior parameter's size depends on `%s'"
argument_list|)
expr_stmt|;
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
comment|/* ... fall through ...  */
case|case
name|VAR_DECL
case|:
comment|/* If a static var's type was incomplete when the decl was written, 	 but the type is complete now, lay out the decl now.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|value
init|=
name|DECL_RTL_IF_SET
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|layout_decl
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the RTL was already set, update its mode and memory 	     attributes.  */
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
name|PUT_MODE
argument_list|(
name|value
argument_list|,
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|value
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|exp
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ... fall through ...  */
case|case
name|FUNCTION_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ensure variable marked as used even if it doesn't go through 	 a parser.  If it hasn't be used yet, write out an external 	 definition.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Show we haven't gotten RTL for this yet.  */
name|temp
operator|=
literal|0
expr_stmt|;
comment|/* Handle variables inherited from containing functions.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* We treat inline_function_decl as an alias for the current function 	 because that is the inline function whose vars, types, etc. 	 are being merged into the current function. 	 See expand_inline_function.  */
if|if
condition|(
name|context
operator|!=
literal|0
operator|&&
name|context
operator|!=
name|current_function_decl
operator|&&
name|context
operator|!=
name|inline_function_decl
comment|/* If var is static, we don't need a static chain to access it.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|;
comment|/* Mark as non-local and addressable.  */
name|DECL_NONLOCAL
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mark_addressable
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MEM
condition|)
name|addr
operator|=
name|replace_equiv_address
argument_list|(
name|addr
argument_list|,
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|fix_lexical_addr
argument_list|(
name|addr
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|replace_equiv_address
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* This is the case of an array whose size is to be determined 	 from its initializer, while the initializer is still being parsed. 	 See expand_decl.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|temp
operator|=
name|validize_mem
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If DECL_RTL is memory, we are in the normal case and either 	 the address is not valid or it is not a register and -fforce-addr 	 is specified, get the address into a register.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
operator|)
condition|)
name|temp
operator|=
name|replace_equiv_address
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we got something, return it.  But first, set the alignment 	 if the address is a register.  */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* If the mode of DECL_RTL does not match that of the decl, it 	 must be a promoted value.  We return a SUBREG of the wanted mode, 	 but mark it so that we know that it was already extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
comment|/* Get the signedness used for this variable.  Ensure we get the 	     same mode we got when the variable was declared.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|RESULT_DECL
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|temp
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
name|temp
operator|=
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* ??? If overflow is set, fold will have done an incomplete job, 	 which can result in (plus xx (const_int 0)), which can get 	 simplified by validate_replace_rtx during virtual register 	 instantiation, which can result in unrecognizable insns. 	 Avoid this by forcing all overflows into registers.  */
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|exp
argument_list|)
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
name|temp
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
case|case
name|CONST_DECL
case|:
return|return
name|expand_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|REAL_CST
case|:
comment|/* If optimized, generate immediate CONST_DOUBLE 	 which will be turned into memory by reload if necessary.  	 We used to force a register so that loop.c could see it.  But 	 this does not allow gen_* patterns to perform optimizations with 	 the constants.  It also produces two insns in cases like "x = 1.0;". 	 On most machines, floating-point constants are not permitted in 	 many insns, so we'd end up copying it to a register in any case.  	 Now, we do the copying in expand_binop, if appropriate.  */
return|return
name|immed_real_const
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
case|case
name|STRING_CST
case|:
if|if
condition|(
operator|!
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
condition|)
name|output_constant_def
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* TREE_CST_RTL probably contains a constant address. 	 On RISC machines where a constant address isn't valid, 	 make some insns to get that address into a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
operator|)
condition|)
return|return
name|replace_equiv_address
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|EXPR_WITH_FILE_LOCATION
case|:
block|{
name|rtx
name|to_return
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_input_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|saved_lineno
init|=
name|lineno
decl_stmt|;
name|input_filename
operator|=
name|EXPR_WFL_FILENAME
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|EXPR_WFL_LINENO
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_WFL_EMIT_LINE_NOTE
argument_list|(
name|exp
argument_list|)
condition|)
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* Possibly avoid switching back and forth here.  */
name|to_return
operator|=
name|expand_expr
argument_list|(
name|EXPR_WFL_NODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|saved_input_filename
expr_stmt|;
name|lineno
operator|=
name|saved_lineno
expr_stmt|;
return|return
name|to_return
return|;
block|}
case|case
name|SAVE_EXPR
case|:
name|context
operator|=
name|decl_function_context
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If this SAVE_EXPR was at global context, assume we are an 	 initialization function and move it into our context.  */
if|if
condition|(
name|context
operator|==
literal|0
condition|)
name|SAVE_EXPR_CONTEXT
argument_list|(
name|exp
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* We treat inline_function_decl as an alias for the current function 	 because that is the inline function whose vars, types, etc. 	 are being merged into the current function. 	 See expand_inline_function.  */
if|if
condition|(
name|context
operator|==
name|current_function_decl
operator|||
name|context
operator|==
name|inline_function_decl
condition|)
name|context
operator|=
literal|0
expr_stmt|;
comment|/* If this is non-local, handle it.  */
if|if
condition|(
name|context
condition|)
block|{
comment|/* The following call just exists to abort if the context is 	     not of a containing function.  */
name|find_function_data
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|temp
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|put_var_into_stack
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|replace_equiv_address
argument_list|(
name|temp
argument_list|,
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|temp
operator|=
name|const0_rtx
expr_stmt|;
else|else
name|temp
operator|=
name|assign_temp
argument_list|(
name|build_qualified_type
argument_list|(
name|type
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
condition|)
name|save_expr_regs
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|save_expr_regs
argument_list|)
expr_stmt|;
comment|/* If the mode of TEMP does not match that of the expression, it 	     must be a promoted value.  We pass store_expr a SUBREG of the 	     wanted mode but mark it so that we know that it was already 	     extended.  Note that `unsignedp' was modified above in 	     this case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|mode
condition|)
block|{
name|temp
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|temp
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the mode of SAVE_EXPR_RTL does not match that of the expression, it 	 must be a promoted value.  We return a SUBREG of the wanted mode, 	 but mark it so that we know that it was already extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|mode
condition|)
block|{
comment|/* Compute the signedness and make the proper SUBREG.  */
name|promote_mode
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|temp
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|UNSAVE_EXPR
case|:
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|unsave_expr_now
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|PLACEHOLDER_EXPR
case|:
block|{
name|tree
name|old_list
init|=
name|placeholder_list
decl_stmt|;
name|tree
name|placeholder_expr
init|=
literal|0
decl_stmt|;
name|exp
operator|=
name|find_placeholder
argument_list|(
name|exp
argument_list|,
operator|&
name|placeholder_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|placeholder_list
operator|=
name|TREE_CHAIN
argument_list|(
name|placeholder_expr
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|placeholder_list
operator|=
name|old_list
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* We can't find the object or there was a missing WITH_RECORD_EXPR.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|WITH_RECORD_EXPR
case|:
comment|/* Put the object on the placeholder list, expand our first operand, 	 and pop the list.  */
name|placeholder_list
operator|=
name|tree_cons
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|placeholder_list
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|placeholder_list
operator|=
name|TREE_CHAIN
argument_list|(
name|placeholder_list
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|GOTO_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|expand_goto
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expand_computed_goto
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|EXIT_EXPR
case|:
name|expand_exit_loop_if_false
argument_list|(
name|NULL
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|LABELED_BLOCK_EXPR
case|:
if|if
condition|(
name|LABELED_BLOCK_BODY
argument_list|(
name|exp
argument_list|)
condition|)
name|expand_expr_stmt_value
argument_list|(
name|LABELED_BLOCK_BODY
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Should perhaps use expand_label, but this is simpler and safer.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label_rtx
argument_list|(
name|LABELED_BLOCK_LABEL
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|EXIT_BLOCK_EXPR
case|:
if|if
condition|(
name|EXIT_BLOCK_RETURN
argument_list|(
name|exp
argument_list|)
condition|)
name|sorry
argument_list|(
literal|"returned value in block_exit_expr"
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|LABELED_BLOCK_LABEL
argument_list|(
name|EXIT_BLOCK_LABELED_BLOCK
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|LOOP_EXPR
case|:
name|push_temp_slots
argument_list|()
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|expand_expr_stmt_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BIND_EXPR
case|:
block|{
name|tree
name|vars
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|vars_need_expansion
init|=
literal|0
decl_stmt|;
comment|/* Need to open a binding contour here because 	   if there are any cleanups they must be contained here.  */
name|expand_start_bindings
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Mark the corresponding BLOCK for output in its proper place.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|insert_block
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If VARS have not yet been expanded, expand them now.  */
while|while
condition|(
name|vars
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|vars
argument_list|)
condition|)
block|{
name|vars_need_expansion
operator|=
literal|1
expr_stmt|;
name|expand_decl
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
name|expand_decl_init
argument_list|(
name|vars
argument_list|)
expr_stmt|;
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|RTL_EXPR
case|:
if|if
condition|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
operator|==
name|const0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
block|}
name|preserve_rtl_expr_result
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|free_temps_for_rtl_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
comment|/* If we don't need the result, just ensure we evaluate any 	 subexpressions.  */
if|if
condition|(
name|ignore
condition|)
block|{
name|tree
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* All elts simple constants => refer to a constant in memory.  But 	 if this is a non-BLKmode mode, let it store a field at a time 	 since that should make a CONST_INT or CONST_DOUBLE when we 	 fold.  Likewise, if we have a target we can use, it is best to 	 store directly into the target unless the type is large enough 	 that memcpy will be used.  If we are making an initializer and 	 all operands are constant, put it in memory as well.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|&&
operator|!
operator|(
name|target
operator|!=
literal|0
operator|&&
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
operator|||
operator|(
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
operator|!
name|MOVE_BY_PIECES_P
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|mostly_zeros_p
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|&&
name|TREE_CONSTANT
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|constructor
init|=
name|output_constant_def
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
condition|)
name|constructor
operator|=
name|validize_mem
argument_list|(
name|constructor
argument_list|)
expr_stmt|;
return|return
name|constructor
return|;
block|}
else|else
block|{
comment|/* Handle calls that pass values in multiple non-contiguous 	     locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|PARALLEL
condition|)
name|target
operator|=
name|assign_temp
argument_list|(
name|build_qualified_type
argument_list|(
name|type
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
operator|(
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|*
name|TYPE_QUAL_CONST
operator|)
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_constructor
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|exp1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|tree
name|string
init|=
name|string_constant
argument_list|(
name|exp1
argument_list|,
operator|&
name|index
argument_list|)
decl_stmt|;
comment|/* Try to optimize reads from const strings.  */
if|if
condition|(
name|string
operator|&&
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|compare_tree_int
argument_list|(
name|index
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|string
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
operator|&&
name|modifier
operator|!=
name|EXPAND_WRITE
condition|)
return|return
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
index|]
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|exp1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|temp
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we are writing to this object and its type is a record with 	   readonly fields, we must mark it as readonly so it will 	   conflict with readonly references to those fields.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_WRITE
operator|&&
name|readonly_fields_p
argument_list|(
name|type
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|{
name|tree
name|array
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|low_bound
init|=
name|domain
condition|?
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
else|:
name|integer_zero_node
decl_stmt|;
name|tree
name|index
init|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
comment|/* Optimize the special-case of a zero lower bound.  	   We convert the low_bound to sizetype to avoid some problems 	   with constant folding.  (E.g. suppose the lower bound is 1, 	   and its mode is QI.  Without the conversion,  (ARRAY 	   +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1)) 	   +INDEX), which becomes (ARRAY+255+INDEX).  Oops!)  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|low_bound
argument_list|)
condition|)
name|index
operator|=
name|size_diffop
argument_list|(
name|index
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|low_bound
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fold an expression like: "foo"[2]. 	   This is not done in fold so it won't happen inside&. 	   Don't fold if this is for wide characters since it's too 	   difficult to do correctly and this is a very rare case.  */
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|compare_tree_int
argument_list|(
name|index
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|array
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
condition|)
return|return
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|array
argument_list|)
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
index|]
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
comment|/* If this is a constant index into a constant array, 	   just get the value from the array.  Handle both the cases when 	   we have an explicit constructor and when our operand is a variable 	   that was declared const.  */
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|index
argument_list|,
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|elem
decl_stmt|;
for|for
control|(
name|elem
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|,
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
init|;
name|elem
operator|!=
literal|0
operator|&&
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
operator|,
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|elem
condition|)
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|optimize
operator|>=
literal|1
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|tree
name|elem
decl_stmt|;
for|for
control|(
name|elem
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
init|;
operator|(
name|elem
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elem
argument_list|)
argument_list|,
name|index
argument_list|)
operator|)
condition|;
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|elem
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|STRING_CST
operator|&&
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|index
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
condition|)
return|return
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|init
argument_list|)
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
index|]
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
block|}
comment|/* Fall through.  */
case|case
name|COMPONENT_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
comment|/* If the operand is a CONSTRUCTOR, we can just extract the 	 appropriate field if it is present.  Don't do this if we have 	 already written the data since we want to refer to that copy 	 and varasm.c assumes that's what we'll do.  */
if|if
condition|(
name|code
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_CST_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
comment|/* We can normally use the value of the field in the 		   CONSTRUCTOR.  However, if this is a bitfield in 		   an integral mode that we can fit in a HOST_WIDE_INT, 		   we must mask only the number of bits in the bitfield, 		   since this is done implicitly by the constructor.  If 		   the bitfield does not meet either of those conditions, 		   we can't do this optimization.  */
operator|&&
operator|(
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|DECL_MODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|DECL_MODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
operator|)
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|bitsize
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|imode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|op1
operator|=
name|GEN_INT
argument_list|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_and
argument_list|(
name|imode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|count
init|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|imode
argument_list|)
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|imode
argument_list|,
name|op0
argument_list|,
name|count
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|imode
argument_list|,
name|op0
argument_list|,
name|count
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|op0
return|;
block|}
block|}
block|{
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
name|tree
name|tem
init|=
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode1
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|)
decl_stmt|;
name|rtx
name|orig_op0
decl_stmt|;
comment|/* If we got back the original object, something is wrong.  Perhaps 	   we are evaluating an expression too early.  In any event, don't 	   infinitely recurse.  */
if|if
condition|(
name|tem
operator|==
name|exp
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If TEM's type is a union of variable size, pass TARGET to the inner 	   computation, since it will need a temporary and TARGET is known 	   to have to do.  This occurs in unchecked conversion in Ada.  */
name|orig_op0
operator|=
name|op0
operator|=
name|expand_expr
argument_list|(
name|tem
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|?
name|target
else|:
name|NULL_RTX
operator|)
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|||
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|)
condition|?
name|modifier
else|:
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* If this is a constant, put it into a register if it is a 	   legitimate constant and OFFSET is 0 and memory if it isn't.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|offset
operator|==
literal|0
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset_rtx
init|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
decl_stmt|;
comment|/* If this object is in a register, put it into memory. 	       This case can't occur in C, but can in Ada if we have 	       unchecked conversion of an expression from a scalar type to 	       an array or record type.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONCAT
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
comment|/* If the operand is a SAVE_EXPR, we can deal with this by 		   forcing the SAVE_EXPR into memory.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
block|{
name|put_var_into_stack
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|nt
init|=
name|build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
decl_stmt|;
name|rtx
name|memloc
init|=
name|assign_temp
argument_list|(
name|nt
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|memloc
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memloc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|Pmode
condition|)
name|offset_rtx
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|ptr_mode
condition|)
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A constant address in OP0 can have VOIDmode, we must not try 	       to call force_reg for that case.  Avoid that case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|bitsize
operator|!=
literal|0
operator|&&
operator|(
name|bitpos
operator|%
name|bitsize
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bitsize
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
operator|==
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
condition|)
block|{
name|op0
operator|=
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|bitpos
operator|=
literal|0
expr_stmt|;
block|}
name|op0
operator|=
name|offset_address
argument_list|(
name|op0
argument_list|,
name|offset_rtx
argument_list|,
name|highest_pow2_factor
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If OFFSET is making OP0 more aligned than BIGGEST_ALIGNMENT, 	   record its alignment as BIGGEST_ALIGNMENT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|bitpos
operator|==
literal|0
operator|&&
name|offset
operator|!=
literal|0
operator|&&
name|is_aligning_offset
argument_list|(
name|offset
argument_list|,
name|tem
argument_list|)
condition|)
name|set_mem_align
argument_list|(
name|op0
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
comment|/* Don't forget about volatility even if this is a bitfield.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|volatilep
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
if|if
condition|(
name|op0
operator|==
name|orig_op0
condition|)
name|op0
operator|=
name|copy_rtx
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The following code doesn't handle CONCAT. 	   Assume only bitpos == 0 can be used for CONCAT, due to 	   one element arrays having the same mode as its element.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
if|if
condition|(
name|bitpos
operator|!=
literal|0
operator|||
name|bitsize
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|op0
return|;
block|}
comment|/* In cases where an aligned union has an unaligned object 	   as a field, we might be extracting a BLKmode value from 	   an integer-mode (e.g., SImode) object.  Handle this case 	   by doing the extract into an object as wide as the field 	   (which we know to be the width of a basic mode), then 	   storing into memory, and changing the mode to BLKmode.  */
if|if
condition|(
name|mode1
operator|==
name|VOIDmode
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|mode1
operator|!=
name|BLKmode
operator|&&
operator|!
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode1
index|]
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|)
comment|/* If the field isn't aligned enough to fetch as a memref, 	       fetch it as a bit field.  */
operator|||
operator|(
name|mode1
operator|!=
name|BLKmode
operator|&&
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|mode1
argument_list|,
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
comment|/* If the type and the field are a constant size and the 	       size of the type isn't the same size as the bitfield, 	       we must use bitfield operations.  */
operator|||
operator|(
name|bitsize
operator|>=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
operator|&&
literal|0
operator|!=
name|compare_tree_int
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|bitsize
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|ext_mode
init|=
name|mode
decl_stmt|;
if|if
condition|(
name|ext_mode
operator|==
name|BLKmode
operator|&&
operator|!
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
operator|)
condition|)
name|ext_mode
operator|=
name|mode_for_size
argument_list|(
name|bitsize
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* In this case, BITPOS must start at a byte boundary and 		   TARGET, if specified, must be a MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|||
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
operator|)
operator|||
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op0
operator|=
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|bitsize
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
name|op0
operator|=
name|validize_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|extract_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
name|target
argument_list|,
name|ext_mode
argument_list|,
name|ext_mode
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the result is a record type and BITSIZE is narrower than 	       the mode of OP0, an integral mode, and this is a big endian 	       machine, we must put the field into the high-order bits.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|BYTES_BIG_ENDIAN
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|bitsize
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|op0
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|-
name|bitsize
argument_list|)
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|rtx
name|new
init|=
name|assign_temp
argument_list|(
name|build_qualified_type
argument_list|(
name|type_for_mode
argument_list|(
name|ext_mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|new
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|copy_rtx
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|op0
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|op0
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|op0
return|;
block|}
comment|/* If the result is BLKmode, use that to access the object 	   now as well.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|mode1
operator|=
name|BLKmode
expr_stmt|;
comment|/* Get a reference to just this component.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|||
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
name|op0
operator|=
name|adjust_address_nv
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|orig_op0
condition|)
name|op0
operator|=
name|copy_rtx
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|op0
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
operator||=
name|volatilep
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|mode1
operator|||
name|mode1
operator|==
name|BLKmode
operator|||
name|mode1
operator|==
name|tmode
operator|||
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
return|return
name|op0
return|;
elseif|else
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|VTABLE_REF
case|:
block|{
name|rtx
name|insn
decl_stmt|,
name|before
init|=
name|get_last_insn
argument_list|()
decl_stmt|,
name|vtbl_ref
decl_stmt|;
comment|/* Evaluate the interior expression.  */
name|subtarget
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* Get or create an instruction off which to hang a note.  */
if|if
condition|(
name|REG_P
argument_list|(
name|subtarget
argument_list|)
condition|)
block|{
name|target
operator|=
name|subtarget
expr_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|before
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|subtarget
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
block|}
comment|/* Collect the data for the note.  */
name|vtbl_ref
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vtbl_ref
operator|=
name|plus_constant
argument_list|(
name|vtbl_ref
argument_list|,
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Discard the initial CONST that was added.  */
name|vtbl_ref
operator|=
name|XEXP
argument_list|(
name|vtbl_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_VTABLE_REF
argument_list|,
name|vtbl_ref
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Intended for a reference to a buffer of a file-object in Pascal. 	 But it's not certain that a special tree code will really be 	 necessary for these.  INDIRECT_REF might work for them.  */
case|case
name|BUFFER_REF
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|IN_EXPR
case|:
block|{
comment|/* Pascal set IN expression.  	   Algorithm: 	       rlo       = set_low - (set_low%bits_per_word); 	       the_word  = set [ (index - rlo)/bits_per_word ]; 	       bit_index = index % bits_per_word; 	       bitmask   = 1<< bit_index; 	       return !!(the_word& bitmask);  */
name|tree
name|set
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|iunsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|set_type
init|=
name|TREE_TYPE
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|tree
name|set_low_bound
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|set_type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|set_high_bound
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|set_type
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|index_val
init|=
name|expand_expr
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|lo_r
init|=
name|expand_expr
argument_list|(
name|set_low_bound
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|hi_r
init|=
name|expand_expr
argument_list|(
name|set_high_bound
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|setval
init|=
name|expand_expr
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|setaddr
init|=
name|XEXP
argument_list|(
name|setval
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|index_mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|rlow
decl_stmt|;
name|rtx
name|diff
decl_stmt|,
name|quo
decl_stmt|,
name|rem
decl_stmt|,
name|addr
decl_stmt|,
name|bit
decl_stmt|,
name|result
decl_stmt|;
comment|/* If domain is empty, answer is no.  Likewise if index is constant 	   and out of bounds.  */
if|if
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|set_high_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|set_low_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|set_high_bound
argument_list|,
name|set_low_bound
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|set_low_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|index
argument_list|,
name|set_low_bound
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|set_high_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|set_high_bound
argument_list|,
name|index
argument_list|)
operator|)
operator|)
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
comment|/* If we get here, we have to generate the code for both cases 	   (in range and out of range).  */
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|index_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|lo_r
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
name|emit_cmp_and_jump_insns
argument_list|(
name|index_val
argument_list|,
name|lo_r
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|index_val
argument_list|)
argument_list|,
name|iunsignedp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|index_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|hi_r
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
name|emit_cmp_and_jump_insns
argument_list|(
name|index_val
argument_list|,
name|hi_r
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|index_val
argument_list|)
argument_list|,
name|iunsignedp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Calculate the element number of bit zero in the first word 	   of the set.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|lo_r
argument_list|)
operator|==
name|CONST_INT
condition|)
name|rlow
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|lo_r
argument_list|)
operator|&
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
else|else
name|rlow
operator|=
name|expand_binop
argument_list|(
name|index_mode
argument_list|,
name|and_optab
argument_list|,
name|lo_r
argument_list|,
name|GEN_INT
argument_list|(
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|diff
operator|=
name|expand_binop
argument_list|(
name|index_mode
argument_list|,
name|sub_optab
argument_list|,
name|index_val
argument_list|,
name|rlow
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|quo
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|index_mode
argument_list|,
name|diff
argument_list|,
name|GEN_INT
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|)
expr_stmt|;
name|rem
operator|=
name|expand_divmod
argument_list|(
literal|1
argument_list|,
name|TRUNC_MOD_EXPR
argument_list|,
name|index_mode
argument_list|,
name|index_val
argument_list|,
name|GEN_INT
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|byte_mode
argument_list|,
name|expand_binop
argument_list|(
name|index_mode
argument_list|,
name|add_optab
argument_list|,
name|diff
argument_list|,
name|setaddr
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract the bit we want to examine.  */
name|bit
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|byte_mode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|byte_mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|rem
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|expand_binop
argument_list|(
name|byte_mode
argument_list|,
name|and_optab
argument_list|,
name|bit
argument_list|,
name|const1_rtx
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|byte_mode
condition|?
name|target
else|:
literal|0
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|target
condition|)
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Output the code to handle the out-of-range case.  */
name|emit_jump
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|WITH_CLEANUP_EXPR
case|:
if|if
condition|(
name|WITH_CLEANUP_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|WITH_CLEANUP_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* That's it for this cleanup.  */
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|WITH_CLEANUP_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|CLEANUP_POINT_EXPR
case|:
block|{
comment|/* Start a new binding layer that will keep track of all cleanup 	   actions to be performed.  */
name|expand_start_bindings
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|target_temp_slot_level
operator|=
name|temp_slot_level
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* If we're going to use this value, load it up now.  */
if|if
condition|(
operator|!
name|ignore
condition|)
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|op0
return|;
case|case
name|CALL_EXPR
case|:
comment|/* Check for a built-in function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BUILT_IN_FRONTEND
condition|)
return|return
call|(
modifier|*
name|lang_expand_expr
call|)
argument_list|(
name|exp
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
else|else
return|return
name|expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|tmode
argument_list|,
name|ignore
argument_list|)
return|;
block|}
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|REFERENCE_EXPR
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If both input and output are BLKmode, this conversion isn't doing 	     anything except possibly changing memory attribute.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|rtx
name|result
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
decl_stmt|;
name|result
operator|=
name|copy_rtx
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|result
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
comment|/* Store data into beginning of memory target.  */
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|adjust_address
argument_list|(
name|target
argument_list|,
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
comment|/* Store this field into a union of the proper type.  */
name|store_field
argument_list|(
name|target
argument_list|,
name|MIN
argument_list|(
operator|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Return the entire union.  */
return|return
name|target
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* If the signedness of the conversion differs and OP0 is 	     a promoted SUBREG, clear that indication since we now 	     have to do the proper extension.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|unsignedp
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op0
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|op0
return|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|op0
return|;
comment|/* If OP0 is a constant, just convert it into the proper mode.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
return|return
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|inner_mode
argument_list|,
name|subreg_lowpart_offset
argument_list|(
name|mode
argument_list|,
name|inner_mode
argument_list|)
argument_list|)
return|;
else|else
return|return
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|inner_mode
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|inner_type
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|unsignedp
condition|?
name|ZERO_EXTEND
else|:
name|SIGN_EXTEND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|VIEW_CONVERT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* If the input and output modes are both the same, we are done. 	 Otherwise, if neither mode is BLKmode and both are within a word, we 	 can use gen_lowpart.  If neither is true, make sure the operand is 	 in memory and convert the MEM to the new mode.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
condition|)
block|{
comment|/* If the operand is not a MEM, force it into memory.  Since we 	     are going to be be changing the mode of the MEM, don't call 	     force_const_mem for constants because we don't allow pool 	     constants to change mode.  */
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
condition|)
name|target
operator|=
name|assign_stack_temp_for_type
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|inner_type
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|target
expr_stmt|;
block|}
comment|/* At this point, OP0 is in the correct mode.  If the output type is such 	 that the operand is known to be aligned, indicate that it is. 	 Otherwise, we need only be concerned about alignment for non-BLKmode 	 results.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|op0
operator|=
name|copy_rtx
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_ALIGN_OK
argument_list|(
name|type
argument_list|)
condition|)
name|set_mem_align
argument_list|(
name|op0
argument_list|,
name|MAX
argument_list|(
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|STRICT_ALIGNMENT
operator|&&
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|temp_size
init|=
name|MAX
argument_list|(
name|int_size_in_bytes
argument_list|(
name|inner_type
argument_list|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|assign_stack_temp_for_type
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|temp_size
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|rtx
name|new_with_op0_mode
init|=
name|adjust_address
argument_list|(
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|new_with_op0_mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|new_with_op0_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|new
expr_stmt|;
block|}
name|op0
operator|=
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|op0
return|;
case|case
name|PLUS_EXPR
case|:
comment|/* We come here from MINUS_EXPR when the second operand is a          constant.  */
name|plus_expr
label|:
name|this_optab
operator|=
operator|!
name|unsignedp
operator|&&
name|flag_trapv
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|)
condition|?
name|addv_optab
else|:
name|add_optab
expr_stmt|;
comment|/* If we are adding a constant, an RTL_EXPR that is sp, fp, or ap, and 	 something else, make sure we add the register to the constant and 	 then to the other thing.  This case can occur during strength 	 reduction and doing it this way will produce better code if the 	 frame pointer or argument pointer is eliminated.  	 fold-const.c will ensure that the constant is always in the inner 	 PLUS_EXPR, so the only case we need to do anything about is if 	 sp, ap, or fp is our second argument, in which case we must swap 	 the innermost first argument and our second argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RTL_EXPR
operator|&&
operator|(
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|||
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* If the result is to be ptr_mode and we are adding an integer to 	 something, we might be forming a constant.  So try to use 	 plus_constant.  If it produces a sum and we can't accept it, 	 use force_operand.  This allows P =&ARR[const] to generate 	 efficient code on machines where a SYMBOL_REF is not a valid 	 address.  	 If this is an EXPAND_SUM call, always return the sum.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|||
operator|(
name|mode
operator|==
name|ptr_mode
operator|&&
operator|(
name|unsignedp
operator|||
operator|!
name|flag_trapv
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant_part
decl_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
comment|/* Use immed_double_const to ensure that the constant is 		 truncated according to the mode of OP1, then sign extended 		 to a HOST_WIDE_INT.  Using the constant directly can result 		 in non-canonical RTL in a 64x32 cross compile.  */
name|constant_part
operator|=
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|INTVAL
argument_list|(
name|constant_part
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
name|op1
operator|=
name|force_operand
argument_list|(
name|op1
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|op1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_INT
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant_part
decl_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|?
name|EXPAND_INITIALIZER
else|:
name|EXPAND_SUM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* Don't go to both_summands if modifier 		     says it's not right to return a PLUS.  */
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
goto|goto
name|binop2
goto|;
goto|goto
name|both_summands
goto|;
block|}
comment|/* Use immed_double_const to ensure that the constant is 		 truncated according to the mode of OP1, then sign extended 		 to a HOST_WIDE_INT.  Using the constant directly can result 		 in non-canonical RTL in a 64x32 cross compile.  */
name|constant_part
operator|=
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|INTVAL
argument_list|(
name|constant_part
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
block|}
comment|/* No sense saving up arithmetic to be done 	 if it's all in the wrong mode to form part of an address. 	 And force_operand won't know whether to sign-extend or 	 zero-extend.  */
if|if
condition|(
operator|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|)
operator|||
name|mode
operator|!=
name|ptr_mode
condition|)
goto|goto
name|binop
goto|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|both_summands
label|:
comment|/* Make sure any term that's a sum with a constant comes last.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|temp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If adding to a sum including a constant, 	 associate it to put the constant outside.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant_term
init|=
name|const0_rtx
decl_stmt|;
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|op0
operator|=
name|temp
expr_stmt|;
comment|/* Ensure that MULT comes first if there is one.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MULT
condition|)
name|op0
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* Let's also eliminate constants from op0 if possible.  */
name|op0
operator|=
name|eliminate_constant_term
argument_list|(
name|op0
argument_list|,
operator|&
name|constant_term
argument_list|)
expr_stmt|;
comment|/* CONSTANT_TERM and XEXP (op1, 1) are known to be constant, so 	     their sum should be a constant.  Form it into OP1, since the 	     result we want will then be OP0 + OP1.  */
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|constant_term
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|op1
operator|=
name|temp
expr_stmt|;
else|else
name|op1
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|constant_term
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Put a constant term last and put a multiplication first.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MULT
condition|)
name|temp
operator|=
name|op1
operator|,
name|op1
operator|=
name|op0
operator|,
name|op0
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
condition|?
name|temp
else|:
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
comment|/* For initializers, we are allowed to return a MINUS of two 	 symbolic constants.  Here we handle all cases when both operands 	 are constant.  */
comment|/* Handle difference of two symbolic constants, 	 for the sake of an initializer.  */
if|if
condition|(
operator|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|)
operator|&&
name|really_constant_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|really_constant_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
decl_stmt|;
comment|/* If the last operand is a CONST_INT, use plus_constant of 	     the negated constant.  Else make the MINUS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
comment|/* Convert A - const to A + (-const).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|negated
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_OVERFLOW
argument_list|(
name|negated
argument_list|)
condition|)
comment|/* If we can't negate the constant in TYPE, leave it alone and 	       expand_binop will negate it for us.  We used to try to do it 	       here in the signed version of TYPE, but that doesn't work 	       on POINTER_TYPEs.  */
empty_stmt|;
else|else
block|{
name|exp
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negated
argument_list|)
expr_stmt|;
goto|goto
name|plus_expr
goto|;
block|}
block|}
name|this_optab
operator|=
operator|!
name|unsignedp
operator|&&
name|flag_trapv
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|)
condition|?
name|subv_optab
else|:
name|sub_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|MULT_EXPR
case|:
comment|/* If first operand is constant, swap them. 	 Thus the following special case checks need only 	 check the second operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|t1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|t1
expr_stmt|;
block|}
comment|/* Attempt to return something suitable for generating an 	 indexed address, for machines that support that.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|&&
name|mode
operator|==
name|ptr_mode
operator|&&
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
comment|/* If we knew for certain that this is arithmetic for an array 	     reference, and we knew the bounds of the array, then we could 	     apply the distributive law across (PLUS X C) for constant C. 	     Without such knowledge, we risk overflowing the computation 	     when both X and C are large, but X+C isn't.  */
comment|/* ??? Could perhaps special-case EXP being unsigned and C being 	     positive.  In that case we are certain that X+C is no smaller 	     than X and so the transformed expression will overflow iff the 	     original would have.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* Check for multiplying things that have been extended 	 from a narrower type.  If this machine supports multiplying 	 in that narrower type with a result in the desired type, 	 do it that way, and avoid the explicit type-conversion.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
comment|/* Don't use a widening multiply if a shift will do.  */
operator|&&
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|||
name|exact_log2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* If both operands are extended, they must either both 		  be zero-extended or both be sign-extended.  */
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|innermode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|optab
name|other_optab
init|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|?
name|smul_widen_optab
else|:
name|umul_widen_optab
operator|)
decl_stmt|;
name|this_optab
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE_WIDER_MODE
argument_list|(
name|innermode
argument_list|)
condition|)
block|{
if|if
condition|(
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|binop2
goto|;
block|}
elseif|else
if|if
condition|(
name|other_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|innermode
operator|==
name|word_mode
condition|)
block|{
name|rtx
name|htem
decl_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|op1
operator|=
name|convert_modes
argument_list|(
name|innermode
argument_list|,
name|mode
argument_list|,
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|other_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|htem
operator|=
name|expand_mult_highpart_adjust
argument_list|(
name|innermode
argument_list|,
name|gen_highpart
argument_list|(
name|innermode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|gen_highpart
argument_list|(
name|innermode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|innermode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|htem
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* Possible optimization: compute the dividend with EXPAND_SUM 	 then if the divisor is constant can optimize the case 	 where some terms of the dividend have coeffs divisible by it.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
case|case
name|RDIV_EXPR
case|:
comment|/* Emit a/b as a*(1/b).  Later we may manage CSE the reciprocal saving          expensive divide.  If not, combine will rebuild the original          computation.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
operator|&&
name|optimize
operator|&&
operator|!
name|optimize_size
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|!
name|real_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|expand_expr
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|unsignedp
argument_list|)
return|;
name|this_optab
operator|=
name|sdiv_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_divmod
argument_list|(
literal|1
argument_list|,
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Not used for C.  */
case|case
name|FIX_TRUNC_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|expand_fix
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|FLOAT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* expand_float can't figure out what to do if FROM has VOIDmode. 	 So give it the correct mode.  With -O, cse will optimize this.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|expand_float
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|NEGATE_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
operator|!
name|unsignedp
operator|&&
name|flag_trapv
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|)
condition|?
name|negv_optab
else|:
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|ABS_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle complex values specially.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
return|return
name|expand_complex_abs
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
comment|/* Unsigned abs is simply the operand.  Testing here means we don't 	 risk generating incorrect code below.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|op0
return|;
return|return
name|expand_abs
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
name|target
operator|=
name|original_target
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* First try to do it with a special MIN or MAX instruction. 	 If that does not win, use a conditional jump to select the proper 	 value.  */
name|this_optab
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
operator|(
name|code
operator|==
name|MIN_EXPR
condition|?
name|umin_optab
else|:
name|umax_optab
operator|)
else|:
operator|(
name|code
operator|==
name|MIN_EXPR
condition|?
name|smin_optab
else|:
name|smax_optab
operator|)
operator|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* At this point, a MEM target is no longer useful; we will get better 	 code without it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|op0
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* If this mode is an integer too wide to compare properly, 	 compare word by word.  Rely on cse to optimize constant cases.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|GE
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|MAX_EXPR
condition|)
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|,
name|target
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|op0
argument_list|)
expr_stmt|;
else|else
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|NULL_RTX
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|code
operator|==
name|MAX_EXPR
condition|?
name|GE
else|:
name|LE
argument_list|,
name|unsignedp
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|BIT_NOT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|FFS_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|ffs_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
comment|/* ??? Can optimize bitwise operations with one arg constant. 	 Can optimize (a bitwise1 n) bitwise2 (a bitwise3 b) 	 and (a bitwise1 b) bitwise2 b (etc) 	 but that is probably not worth while.  */
comment|/* BIT_AND_EXPR is for bitwise anding.  TRUTH_AND_EXPR is for anding two 	 boolean values when we want in all cases to compute both of them.  In 	 general it is fastest to do TRUTH_AND_EXPR by computing both operands 	 as actual zero-or-1 values and then bitwise anding.  In cases where 	 there cannot be any side effects, better code would be made by 	 treating TRUTH_AND_EXPR like TRUTH_ANDIF_EXPR; but the question is 	 how to recognize those cases.  */
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
name|this_optab
operator|=
name|and_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
name|this_optab
operator|=
name|ior_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
name|this_optab
operator|=
name|xor_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
comment|/* Could determine the answer when only additive constants differ.  Also, 	 the addition of one can be handled by changing the condition.  */
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
name|temp
operator|=
name|do_store_flag
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* For foo != 0, load foo, and if it is nonzero load 1 instead.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|original_target
operator|&&
name|GET_CODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|original_target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If temp is constant, we can just compute the result.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|temp
argument_list|)
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|temp
operator|!=
name|original_target
condition|)
block|{
name|enum
name|machine_mode
name|mode1
init|=
name|GET_MODE
argument_list|(
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode1
operator|==
name|VOIDmode
condition|)
name|mode1
operator|=
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
expr_stmt|;
name|temp
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|temp
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|unsignedp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* If no set-flag instruction, must generate a conditional 	 store into a temporary variable.  Drop through 	 and handle this like&& and ||.  */
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
if|if
condition|(
operator|!
name|ignore
operator|&&
operator|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
comment|/* Make sure we don't have a hard reg (such as function's return 		 value) live across basic blocks, if not optimizing.  */
operator|||
operator|(
operator|!
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|emit_clr_insn
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|exp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|emit_0_to_1_insn
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|ignore
condition|?
name|const0_rtx
else|:
name|target
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The parser is careful to generate TRUTH_NOT_EXPR 	 only with operands that are always zero or one.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|COMPOUND_EXPR
case|:
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|ignore
condition|?
name|const0_rtx
else|:
name|target
operator|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* If we would have a "singleton" (see below) were it not for a 	 conversion in each arm, bring that conversion back out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|iftrue
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|iffalse
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|iftrue
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|operand_equal_p
argument_list|(
name|iffalse
argument_list|,
name|TREE_OPERAND
argument_list|(
name|iftrue
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|iffalse
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|operand_equal_p
argument_list|(
name|iftrue
argument_list|,
name|TREE_OPERAND
argument_list|(
name|iffalse
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|iftrue
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|operand_equal_p
argument_list|(
name|iffalse
argument_list|,
name|TREE_OPERAND
argument_list|(
name|iftrue
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|iffalse
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|operand_equal_p
argument_list|(
name|iftrue
argument_list|,
name|TREE_OPERAND
argument_list|(
name|iffalse
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|expand_expr
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|iftrue
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|iftrue
argument_list|,
name|iffalse
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
block|{
comment|/* Note that COND_EXPRs whose type is a structure or union 	   are required to be constructed to contain assignments of 	   a temporary variable, so that we can evaluate them here 	   for side effect only.  If type is void, we must do likewise.  */
comment|/* If an arm of the branch requires a cleanup, 	   only that cleanup is performed.  */
name|tree
name|singleton
init|=
literal|0
decl_stmt|;
name|tree
name|binary_op
init|=
literal|0
decl_stmt|,
name|unary_op
init|=
literal|0
decl_stmt|;
comment|/* If this is (A ? 1 : 0) and A is a condition, just evaluate it and 	   convert it to our mode, if necessary.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|ignore
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Check for X ? A + B : A.  If we have this, we can copy A to the 	   output and conditionally add B.  Similarly for unary operations. 	   Don't do this if X has side-effects because those side effects 	   might affect A or B and the "?" operation is a sequence point in 	   ANSI.  (operand_equal_p tests for side effects.)  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|,
name|binary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|,
name|binary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|,
name|unary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|,
name|unary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If we are not to produce a result, we have no target.  Otherwise, 	   if a target was specified use it; it will not be used as an 	   intermediate target unless it is safe.  If no target, use a 	   temporary.  */
if|if
condition|(
name|ignore
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|original_target
operator|&&
operator|(
name|safe_from_p
argument_list|(
name|original_target
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|singleton
operator|&&
name|GET_CODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|original_target
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|original_target
operator|==
name|var_rtx
argument_list|(
name|singleton
argument_list|)
operator|)
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|mode
ifdef|#
directive|ifdef
name|HAVE_conditional_move
operator|&&
operator|(
operator|!
name|can_conditionally_move_p
argument_list|(
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|REG
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|original_target
argument_list|)
operator|!=
name|MEM
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|temp
operator|=
name|original_target
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|temp
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we had X ? A + C : A, with C a constant power of 2, and we can 	   do the test of X as a store-flag operation, do this as 	   A + ((X != 0)<< log C).  Similarly for other simple binary 	   operators.  Only do for C == 1 if BRANCH_COST is low.  */
if|if
condition|(
name|temp
operator|&&
name|singleton
operator|&&
name|binary_op
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|MINUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|)
operator|&&
operator|(
name|BRANCH_COST
operator|>=
literal|3
condition|?
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|rtx
name|result
decl_stmt|;
name|optab
name|boptab
init|=
operator|(
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|PLUS_EXPR
condition|?
operator|(
name|TYPE_TRAP_SIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|binary_op
argument_list|)
argument_list|)
condition|?
name|addv_optab
else|:
name|add_optab
operator|)
else|:
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|MINUS_EXPR
condition|?
operator|(
name|TYPE_TRAP_SIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|binary_op
argument_list|)
argument_list|)
condition|?
name|subv_optab
else|:
name|sub_optab
operator|)
else|:
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|?
name|ior_optab
else|:
name|xor_optab
operator|)
decl_stmt|;
comment|/* If we had X ? A : A + 1, do this as A + (X == 0).  	       We have to invert the truth value here and then put it 	       back later if do_store_flag fails.  We cannot simply copy 	       TREE_OPERAND (exp, 0) to another variable and modify that 	       because invert_truthvalue can modify the tree pointed to 	       by its argument.  */
if|if
condition|(
name|singleton
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|do_store_flag
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|singleton
argument_list|,
literal|1
argument_list|)
condition|?
name|temp
else|:
name|NULL_RTX
operator|)
argument_list|,
name|mode
argument_list|,
name|BRANCH_COST
operator|<=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
operator|&&
operator|!
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|result
argument_list|,
name|build_int_2
argument_list|(
name|tree_log2
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|singleton
argument_list|,
literal|1
argument_list|)
condition|?
name|temp
else|:
name|NULL_RTX
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|op1
operator|=
name|expand_expr
argument_list|(
name|singleton
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|boptab
argument_list|,
name|op1
argument_list|,
name|result
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|singleton
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|singleton
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
comment|/* If the target conflicts with the other operand of the 		   binary op, we can't use it.  Also, we can't use the target 		   if it is a hard register, because evaluating the condition 		   might clobber it.  */
if|if
condition|(
operator|(
name|binary_op
operator|&&
operator|!
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|singleton
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_expr
argument_list|(
name|singleton
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|singleton
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|jumpif
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
else|else
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
if|if
condition|(
name|binary_op
operator|&&
name|temp
operator|==
literal|0
condition|)
comment|/* Just touch the other operand.  */
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|binary_op
condition|)
name|store_expr
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|temp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|store_expr
argument_list|(
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|unary_op
argument_list|)
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
block|}
comment|/* Check for A op 0 ? A : FOO and A op 0 ? FOO : A where OP is any 	   comparison operator.  If we have one of these cases, set the 	   output to A, branch on A (cse will merge these two references), 	   then set the output to FOO.  */
elseif|else
if|if
condition|(
name|temp
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SAVE_EXPR
operator|)
operator|&&
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jumpif
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|SAVE_EXPR
operator|)
operator|&&
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
comment|/* One branch of the cond can be void, if it never returns. For 	       example A ? throw : E  */
if|if
condition|(
name|temp
operator|!=
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|TARGET_EXPR
case|:
block|{
comment|/* Something needs to be initialized, but we didn't know 	   where that thing was when building the tree.  For example, 	   it could be the return value of a function, or a parameter 	   to a function which lays down in the stack, or a temporary 	   variable which must be passed by reference.  	   We guarantee that the expression will either be constructed 	   or copied into our original target.  */
name|tree
name|slot
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cleanups
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|exp1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|slot
argument_list|)
operator|!=
name|VAR_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ignore
condition|)
name|target
operator|=
name|original_target
expr_stmt|;
comment|/* Set this here so that if we get a target that refers to a 	   register variable that's already been used, put_reg_into_stack 	   knows that it should fix up those uses.  */
name|TREE_USED
argument_list|(
name|slot
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|target
operator|=
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* If we have already expanded the slot, so don't do 		   it again.  (mrs)  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|target
return|;
block|}
else|else
block|{
name|target
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* All temp slots at this level must not conflict.  */
name|preserve_temp_slots
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|slot
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|slot
argument_list|)
condition|)
name|put_var_into_stack
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* Since SLOT is not known to the called function 		   to belong to its stack frame, we must build an explicit 		   cleanup.  This case occurs when we must build up a reference 		   to pass the reference as an argument.  In this case, 		   it is very likely that such a reference need not be 		   built here.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
name|maybe_build_cleanup
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|cleanups
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This case does occur, when expanding a parameter which 	       needs to be constructed on the stack.  The target 	       is the actual stack address that we want to initialize. 	       The function we call will perform the cleanup in this case.  */
comment|/* If we have already assigned it space, use that space, 	       not target that we were passed in, as our target 	       parameter is only a hint.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|target
operator|=
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* If we have already expanded the slot, so don't do                    it again.  (mrs)  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|target
return|;
block|}
else|else
block|{
name|SET_DECL_RTL
argument_list|(
name|slot
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* If we must have an addressable slot, then make sure that 		   the RTL that we just stored in slot is OK.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|slot
argument_list|)
condition|)
name|put_var_into_stack
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
name|exp1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|3
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Mark it as expanded.  */
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|store_expr
argument_list|(
name|exp1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanups
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|INIT_EXPR
case|:
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|temp
operator|=
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
operator|!
name|ignore
argument_list|,
name|original_target
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|MODIFY_EXPR
case|:
block|{
comment|/* If lhs is complex, expand calls in rhs before computing it. 	   That's so we don't compute a pointer and save it over a 	   call.  If lhs is simple, compute it first so we can give it 	   as a target if the rhs is just a call.  This avoids an 	   extra temp and copy and that prevents a partial-subsumption 	   which makes bad code.  Actually we could treat 	   component_ref's of vars like vars.  */
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
comment|/* Check for |= or&= of a bitfield of size one into another bitfield 	   of size 1.  In this case, (unless we need the result of the 	   assignment) we can do this more efficiently with a 	   test followed by an assignment, if necessary.  	   ??? At this point, we can't get a BIT_FIELD_REF here.  But if 	   things change so we do, this code should be enhanced to 	   support it.  */
if|if
condition|(
name|ignore
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|lhs
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|integer_onep
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|?
name|label
else|:
literal|0
argument_list|,
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|?
name|label
else|:
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|temp
operator|=
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
operator|!
name|ignore
argument_list|,
name|original_target
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|RETURN_EXPR
case|:
if|if
condition|(
operator|!
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
name|expand_null_return
argument_list|()
expr_stmt|;
else|else
name|expand_return
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
return|return
name|expand_increment
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Faster to treat as pre-increment if result is not used.  */
return|return
name|expand_increment
argument_list|(
name|exp
argument_list|,
operator|!
name|ignore
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
comment|/* Are we taking the address of a nested function?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|decl_function_context
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|op0
operator|=
name|trampoline_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
comment|/* If we are taking the address of something erroneous, just 	 return a zero.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|const0_rtx
return|;
comment|/* If we are taking the address of a constant and are at the 	 top level, we have to use output_constant_def since we can't 	 call force_const_mem at top level.  */
elseif|else
if|if
condition|(
name|cfun
operator|==
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONSTRUCTOR
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|)
condition|)
name|op0
operator|=
name|XEXP
argument_list|(
name|output_constant_def
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We make sure to pass const0_rtx down if we came in with 	     ignore set, to avoid doing the cleanups twice for something.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|?
name|modifier
else|:
name|EXPAND_CONST_ADDRESS
operator|)
argument_list|)
expr_stmt|;
comment|/* If we are going to ignore the result, OP0 will have been set 	     to const0_rtx, so just return it.  Don't get confused and 	     think we are taking the address of the constant.  */
if|if
condition|(
name|ignore
condition|)
return|return
name|op0
return|;
comment|/* Pass 1 for MODIFY, so that protect_from_queue doesn't get 	     clever and returns a REG when given a MEM.  */
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We would like the object in memory.  If it is a constant, we can 	     have it be statically allocated into memory.  For a non-constant, 	     we need to allocate some memory and store the value into it.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|force_const_mem
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONCAT
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ADDRESSOF
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* If the operand is a SAVE_EXPR, we can deal with this by 		 forcing the SAVE_EXPR into memory.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
block|{
name|put_var_into_stack
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If this object is in a register, it can't be BLKmode.  */
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|memloc
init|=
name|assign_temp
argument_list|(
name|inner_type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PARALLEL
condition|)
comment|/* Handle calls that pass values in multiple 		       non-contiguous locations.  The Irix 6 ABI has examples 		       of this.  */
name|emit_group_store
argument_list|(
name|memloc
argument_list|,
name|op0
argument_list|,
name|int_size_in_bytes
argument_list|(
name|inner_type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|memloc
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memloc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mark_temp_addr_taken
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|==
name|ptr_mode
condition|)
name|op0
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|op0
return|;
block|}
comment|/* If OP0 is not aligned as least as much as the type requires, we 	     need to make a temporary, copy OP0 to it, and take the address of 	     the temporary.  We want to use the alignment of the type, not of 	     the operand.  Note that this is incorrect for FUNCTION_TYPE, but 	     the test for BLKmode means that can't happen.  The test for 	     BLKmode is because we never make mis-aligned MEMs with 	     non-BLKmode.  	     We don't need to do this at all if the machine doesn't have 	     strict alignment.  */
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|>
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
operator|)
operator|&&
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
operator|<
name|BIGGEST_ALIGNMENT
condition|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|assign_stack_temp_for_type
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|MEM_SIZE
argument_list|(
name|op0
argument_list|)
condition|?
name|INTVAL
argument_list|(
name|MEM_SIZE
argument_list|(
name|op0
argument_list|)
argument_list|)
else|:
name|int_size_in_bytes
argument_list|(
name|inner_type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|build_qualified_type
argument_list|(
name|inner_type
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|inner_type
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_ALIGN_OK
argument_list|(
name|inner_type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_block_move
argument_list|(
name|new
argument_list|,
name|op0
argument_list|,
name|expr_size
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|new
expr_stmt|;
block|}
name|op0
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|op0
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|op0
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|==
name|ptr_mode
condition|)
name|op0
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|op0
return|;
case|case
name|ENTRY_VALUE_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* COMPLEX type for Extended Pascal& Fortran  */
case|case
name|COMPLEX_EXPR
case|:
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
comment|/* Get the rtx code of the operands.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Move the real (op0) and imaginary (op1) parts to their location.  */
name|emit_move_insn
argument_list|(
name|gen_realpart
argument_list|(
name|mode
argument_list|,
name|target
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_imagpart
argument_list|(
name|mode
argument_list|,
name|target
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Complex construction should appear as a single unit.  */
comment|/* If TARGET is a CONCAT, we got insns like RD = RS, ID = IS, 	   each with a separate pseudo as destination. 	   It's not correct for flow to treat them as a unit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|CONCAT
condition|)
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|REALPART_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_realpart
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
case|case
name|IMAGPART_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_imagpart
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
case|case
name|CONJ_EXPR
case|:
block|{
name|enum
name|machine_mode
name|partmode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|imag_t
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Store the realpart and the negated imagpart to target.  */
name|emit_move_insn
argument_list|(
name|gen_realpart
argument_list|(
name|partmode
argument_list|,
name|target
argument_list|)
argument_list|,
name|gen_realpart
argument_list|(
name|partmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|imag_t
operator|=
name|gen_imagpart
argument_list|(
name|partmode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|partmode
argument_list|,
operator|!
name|unsignedp
operator|&&
name|flag_trapv
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|partmode
argument_list|)
operator|==
name|MODE_INT
operator|)
condition|?
name|negv_optab
else|:
name|neg_optab
argument_list|,
name|gen_imagpart
argument_list|(
name|partmode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|imag_t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|imag_t
condition|)
name|emit_move_insn
argument_list|(
name|imag_t
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Conjugate should appear as a single unit 	   If TARGET is a CONCAT, we got insns like RD = RS, ID = - IS, 	   each with a separate pseudo as destination. 	   It's not correct for flow to treat them as a unit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|CONCAT
condition|)
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|TRY_CATCH_EXPR
case|:
block|{
name|tree
name|handler
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_eh_region_end_cleanup
argument_list|(
name|handler
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
case|case
name|TRY_FINALLY_EXPR
case|:
block|{
name|tree
name|try_block
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|finally_block
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|finally_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|done_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|return_link
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|tree
name|cleanup
init|=
name|build
argument_list|(
name|GOTO_SUBROUTINE_EXPR
argument_list|,
name|void_type_node
argument_list|,
operator|(
name|tree
operator|)
name|finally_label
argument_list|,
operator|(
name|tree
operator|)
name|return_link
argument_list|)
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|cleanup
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Start a new binding layer that will keep track of all cleanup 	   actions to be performed.  */
name|expand_start_bindings
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|target_temp_slot_level
operator|=
name|temp_slot_level
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|try_block
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|done_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|finally_label
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|finally_block
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|return_link
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|done_label
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
case|case
name|GOTO_SUBROUTINE_EXPR
case|:
block|{
name|rtx
name|subr
init|=
operator|(
name|rtx
operator|)
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|return_link
init|=
operator|*
operator|(
name|rtx
operator|*
operator|)
operator|&
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|return_address
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_move_insn
argument_list|(
name|return_link
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|return_address
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|subr
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|return_address
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
case|case
name|VA_ARG_EXPR
case|:
return|return
name|expand_builtin_va_arg
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
case|case
name|EXC_PTR_EXPR
case|:
return|return
name|get_exception_pointer
argument_list|(
name|cfun
argument_list|)
return|;
case|case
name|FDESC_EXPR
case|:
comment|/* Function descriptors are not valid except for as 	 initialization constants, and should not be expanded.  */
name|abort
argument_list|()
expr_stmt|;
default|default:
return|return
call|(
modifier|*
name|lang_expand_expr
call|)
argument_list|(
name|exp
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
comment|/* Here to do an ordinary binary operator, generating an instruction      from the optab already placed in `this_optab'.  */
name|binop
label|:
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binop2
label|:
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of above: returns 1 if OFFSET corresponds to an offset that    when applied to the address of EXP produces an address known to be    aligned more than BIGGEST_ALIGNMENT.  */
end_comment

begin_function
specifier|static
name|int
name|is_aligning_offset
parameter_list|(
name|offset
parameter_list|,
name|exp
parameter_list|)
name|tree
name|offset
decl_stmt|;
name|tree
name|exp
decl_stmt|;
block|{
comment|/* Strip off any conversions and WITH_RECORD_EXPR nodes.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|WITH_RECORD_EXPR
condition|)
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We must now have a BIT_AND_EXPR with a constant that is one less than      power of 2 and which is larger than BIGGEST_ALIGNMENT.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|BIT_AND_EXPR
operator|||
operator|!
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|||
name|compare_tree_int
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|<=
literal|0
operator|||
operator|!
name|exact_log2
argument_list|(
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Look at the first operand of BIT_AND_EXPR and strip any conversion.      It must be NEGATE_EXPR.  Then strip any more conversions.  */
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|NEGATE_EXPR
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This must now be the address either of EXP or of a PLACEHOLDER_EXPR      whose type is the same as EXP.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
operator|==
name|exp
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the tree node if a ARG corresponds to a string constant or zero    if it doesn't.  If we return non-zero, set *PTR_OFFSET to the offset    in bytes within the string that ARG is accessing.  The type of the    offset will be `sizetype'.  */
end_comment

begin_function
name|tree
name|string_constant
parameter_list|(
name|arg
parameter_list|,
name|ptr_offset
parameter_list|)
name|tree
name|arg
decl_stmt|;
name|tree
modifier|*
name|ptr_offset
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
operator|*
name|ptr_offset
operator|=
name|size_zero_node
expr_stmt|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
operator|*
name|ptr_offset
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
operator|*
name|ptr_offset
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand code for a post- or pre- increment or decrement    and return the RTX for the result.    POST is 1 for postinc/decrements and 0 for preinc/decrements.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_increment
parameter_list|(
name|exp
parameter_list|,
name|post
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|post
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|temp
decl_stmt|,
name|value
decl_stmt|;
name|tree
name|incremented
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|optab
name|this_optab
init|=
name|add_optab
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|op0_is_copy
init|=
literal|0
decl_stmt|;
name|int
name|single_insn
init|=
literal|0
decl_stmt|;
comment|/* 1 means we can't store into OP0 directly,      because it is a subreg narrower than a word,      and we don't dare clobber the rest of the word.  */
name|int
name|bad_subreg
init|=
literal|0
decl_stmt|;
comment|/* Stabilize any component ref that might need to be      evaluated more than once below.  */
if|if
condition|(
operator|!
name|post
operator|||
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incremented
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|INDIRECT_REF
operator|||
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incremented
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|incremented
operator|=
name|stabilize_reference
argument_list|(
name|incremented
argument_list|)
expr_stmt|;
comment|/* Nested *INCREMENT_EXPRs can happen in C++.  We must force innermost      ones into save exprs so that they don't accidentally get evaluated      more than once by the code below.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|PREINCREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|PREDECREMENT_EXPR
condition|)
name|incremented
operator|=
name|save_expr
argument_list|(
name|incremented
argument_list|)
expr_stmt|;
comment|/* Compute the operands as RTX.      Note whether OP0 is the actual lvalue or a copy of it:      I believe it is a copy iff it is a register or subreg      and insns were generated in computing it.  */
name|temp
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|incremented
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If OP0 is a SUBREG made for a promoted variable, we cannot increment      in place but instead must do sign- or zero-extension during assignment,      so we copy it into a new register and let the code below use it as      a copy.       Note that we can safely modify this SUBREG since it is know not to be      shared (it was made by the expand_expr call above).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
if|if
condition|(
name|post
condition|)
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
operator|=
name|copy_to_reg
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bad_subreg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
block|{
comment|/* We cannot increment this SUBREG in place.  If we are 	 post-incrementing, get a copy of the old value.  Otherwise, 	 just mark that we cannot increment in place.  */
if|if
condition|(
name|post
condition|)
name|op0
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
else|else
name|bad_subreg
operator|=
literal|1
expr_stmt|;
block|}
name|op0_is_copy
operator|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|temp
operator|!=
name|get_last_insn
argument_list|()
operator|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Decide whether incrementing or decrementing.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PREDECREMENT_EXPR
condition|)
name|this_optab
operator|=
name|sub_optab
expr_stmt|;
comment|/* Convert decrement by a constant into a negative increment.  */
if|if
condition|(
name|this_optab
operator|==
name|sub_optab
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op1
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|this_optab
operator|=
name|add_optab
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_TRAP_SIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|this_optab
operator|=
name|this_optab
operator|==
name|add_optab
condition|?
name|addv_optab
else|:
name|subv_optab
expr_stmt|;
comment|/* For a preincrement, see if we can do this with a single instruction.  */
if|if
condition|(
operator|!
name|post
condition|)
block|{
name|icode
operator|=
operator|(
name|int
operator|)
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
operator|(
name|int
operator|)
name|CODE_FOR_nothing
comment|/* Make sure that OP0 is valid for operands 0 and 1 	     of the insn we want to queue.  */
operator|&&
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode
operator|)
operator|&&
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode
operator|)
operator|&&
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode
operator|)
condition|)
name|single_insn
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If OP0 is not the actual lvalue, but rather a copy in a register,      then we cannot just increment OP0.  We must therefore contrive to      increment the original value.  Then, for postincrement, we can return      OP0 since it is a copy of the old value.  For preincrement, expand here      unless we can do it with a single insn.       Likewise if storing directly into OP0 would clobber high bits      we need to preserve (bad_subreg).  */
if|if
condition|(
name|op0_is_copy
operator|||
operator|(
operator|!
name|post
operator|&&
operator|!
name|single_insn
operator|)
operator|||
name|bad_subreg
condition|)
block|{
comment|/* This is the easiest way to increment the value wherever it is. 	 Problems with multiple evaluation of INCREMENTED are prevented 	 because either (1) it is a component_ref or preincrement, 	 in which case it was stabilized above, or (2) it is an array_ref 	 with constant index in an array in a register, which is 	 safe to reevaluate.  */
name|tree
name|newexp
init|=
name|build
argument_list|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PREDECREMENT_EXPR
operator|)
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|incremented
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|newexp
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|incremented
argument_list|)
argument_list|,
name|newexp
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|TREE_OPERAND
argument_list|(
name|incremented
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|expand_assignment
argument_list|(
name|incremented
argument_list|,
name|newexp
argument_list|,
operator|!
name|post
operator|&&
operator|!
name|ignore
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|post
condition|?
name|op0
else|:
name|temp
return|;
block|}
if|if
condition|(
name|post
condition|)
block|{
comment|/* We have a true reference to the value in OP0. 	 If there is an insn to add or subtract in this mode, queue it. 	 Queueing the increment insn avoids the register shuffling 	 that often results if we must increment now and first save 	 the old value for subsequent use.  */
if|#
directive|if
literal|0
comment|/* Turned off to avoid making extra insn for indexed memref.  */
block|op0 = stabilize (op0);
endif|#
directive|endif
name|icode
operator|=
operator|(
name|int
operator|)
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
operator|(
name|int
operator|)
name|CODE_FOR_nothing
comment|/* Make sure that OP0 is valid for operands 0 and 1 	     of the insn we want to queue.  */
operator|&&
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode
operator|)
operator|&&
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode
operator|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|enqueue_insn
argument_list|(
name|op0
argument_list|,
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|icode
operator|!=
operator|(
name|int
operator|)
name|CODE_FOR_nothing
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|addr
init|=
operator|(
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
condition|?
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|,
name|result
decl_stmt|;
name|op0
operator|=
name|replace_equiv_address
argument_list|(
name|op0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|temp
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode
operator|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* The increment queue is LIFO, thus we have to `queue' 	     the instructions in reverse order.  */
name|enqueue_insn
argument_list|(
name|op0
argument_list|,
name|gen_move_insn
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|enqueue_insn
argument_list|(
name|temp
argument_list|,
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/* Preincrement, or we can't increment with one simple insn.  */
if|if
condition|(
name|post
condition|)
comment|/* Save a copy of the value before inc or dec, to return it later.  */
name|temp
operator|=
name|value
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
else|else
comment|/* Arrange to return the incremented value.  */
comment|/* Copy the rtx because expand_binop will protect from the queue,        and the results of that would be invalid for us to return        if our caller does emit_queue before using our result.  */
name|temp
operator|=
name|copy_rtx
argument_list|(
name|value
operator|=
name|op0
argument_list|)
expr_stmt|;
comment|/* Increment however we can.  */
name|op1
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|value
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Make sure the value is stored into OP0.  */
if|if
condition|(
name|op1
operator|!=
name|op0
condition|)
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* At the start of a function, record that we have no previously-pushed    arguments waiting to be popped.  */
end_comment

begin_function
name|void
name|init_pending_stack_adjust
parameter_list|()
block|{
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When exiting from function, if safe, clear out any pending stack adjust    so the adjustment won't get done.     Note, if the current function calls alloca, then it must have a    frame pointer regardless of the value of flag_omit_frame_pointer.  */
end_comment

begin_function
name|void
name|clear_pending_stack_adjust
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
operator|(
operator|!
name|flag_omit_frame_pointer
operator|||
name|current_function_calls_alloca
operator|)
operator|&&
name|EXIT_IGNORE_STACK
operator|&&
operator|!
operator|(
name|DECL_INLINE
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
name|flag_no_inline
operator|)
operator|&&
operator|!
name|flag_inline_functions
condition|)
block|{
name|stack_pointer_delta
operator|-=
name|pending_stack_adjust
operator|,
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Pop any previously-pushed arguments that have not been popped yet.  */
end_comment

begin_function
name|void
name|do_pending_stack_adjust
parameter_list|()
block|{
if|if
condition|(
name|inhibit_defer_pop
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pending_stack_adjust
operator|!=
literal|0
condition|)
name|adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|pending_stack_adjust
argument_list|)
argument_list|)
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand conditional expressions.  */
end_comment

begin_comment
comment|/* Generate code to evaluate EXP and jump to LABEL if the value is zero.    LABEL is an rtx of code CODE_LABEL, in this function and all the    functions here.  */
end_comment

begin_function
name|void
name|jumpifnot
parameter_list|(
name|exp
parameter_list|,
name|label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|do_jump
argument_list|(
name|exp
argument_list|,
name|label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */
end_comment

begin_function
name|void
name|jumpif
parameter_list|(
name|exp
parameter_list|,
name|label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|do_jump
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if    the result is zero, or IF_TRUE_LABEL if the result is one.    Either of IF_FALSE_LABEL and IF_TRUE_LABEL may be zero,    meaning fall through in that case.     do_jump always does any pending stack adjust except when it does not    actually perform a jump.  An example where there is no jump    is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.     This function is responsible for optimizing cases such as&&, || and comparison operators in EXP.  */
end_comment

begin_function
name|void
name|do_jump
parameter_list|(
name|exp
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Some cases need to create a label to jump to      in order to properly fall through.      These cases set DROP_THROUGH_LABEL nonzero.  */
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
ifdef|#
directive|ifdef
name|MAX_INTEGER_COMPUTATION_MODE
name|check_max_integer_computation_mode
argument_list|(
name|exp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_queue
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|INTEGER_CST
case|:
name|temp
operator|=
name|integer_zerop
argument_list|(
name|exp
argument_list|)
condition|?
name|if_false_label
else|:
name|if_true_label
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|emit_jump
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* This is not true with #pragma weak  */
block|case ADDR_EXPR:
comment|/* The address of something can never be zero.  */
block|if (if_true_label) 	emit_jump (if_true_label);       break;
endif|#
directive|endif
case|case
name|NOP_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
goto|goto
name|normal
goto|;
case|case
name|CONVERT_EXPR
case|:
comment|/* If we are narrowing the operand, we have to do the compare in the 	 narrower mode.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|normal
goto|;
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|REFERENCE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
comment|/* These cannot change zero->non-zero or vice versa.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|WITH_RECORD_EXPR
case|:
comment|/* Put the object on the placeholder list, recurse through our first 	 operand, and pop the list.  */
name|placeholder_list
operator|=
name|tree_cons
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|placeholder_list
argument_list|)
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|placeholder_list
operator|=
name|TREE_CHAIN
argument_list|(
name|placeholder_list
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* This is never less insns than evaluating the PLUS_EXPR followed by 	 a test and can be longer if the test is eliminated.  */
block|case PLUS_EXPR:
comment|/* Reduce to minus.  */
block|exp = build (MINUS_EXPR, TREE_TYPE (exp), 		   TREE_OPERAND (exp, 0), 		   fold (build1 (NEGATE_EXPR, TREE_TYPE (TREE_OPERAND (exp, 1)), 				 TREE_OPERAND (exp, 1))));
comment|/* Process as MINUS.  */
endif|#
directive|endif
case|case
name|MINUS_EXPR
case|:
comment|/* Non-zero iff operands of minus differ.  */
name|do_compare_and_jump
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
comment|/* If we are AND'ing with a small constant, do this comparison in the 	 smallest type that fits.  If the machine doesn't have comparisons 	 that small, it will be converted back to the wider comparison. 	 This helps if we are testing the sign bit of a narrower object. 	 combine can't do this for us because it can't know whether a 	 ZERO_EXTRACT or a compare in a smaller mode exists, but we do.  */
if|if
condition|(
operator|!
name|SLOW_BYTE_ACCESS
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|i
operator|=
name|tree_floor_log2
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|mode
operator|=
name|mode_for_size
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|BLKmode
operator|&&
operator|(
name|type
operator|=
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|do_jump
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|normal
goto|;
case|case
name|TRUTH_NOT_EXPR
case|:
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
if|if
condition|(
name|if_false_label
operator|==
literal|0
condition|)
name|if_false_label
operator|=
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
if|if
condition|(
name|if_true_label
operator|==
literal|0
condition|)
name|if_true_label
operator|=
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|push_temp_slots
argument_list|()
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
block|{
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
comment|/* Get description of this reference.  We don't actually care 	   about the underlying object here.  */
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|)
expr_stmt|;
name|type
operator|=
name|type_for_size
argument_list|(
name|bitsize
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLOW_BYTE_ACCESS
operator|&&
name|type
operator|!=
literal|0
operator|&&
name|bitsize
operator|>=
literal|0
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|do_jump
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|normal
goto|;
block|}
case|case
name|COND_EXPR
case|:
comment|/* Do (a ? 1 : 0) and (a ? 0 : 1) as special cases.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|label1
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
comment|/* Now the THEN-expression.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
condition|?
name|if_false_label
else|:
name|drop_through_label
argument_list|,
name|if_true_label
condition|?
name|if_true_label
else|:
name|drop_through_label
argument_list|)
expr_stmt|;
comment|/* In case the do_jump just above never jumps.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label1
argument_list|)
expr_stmt|;
comment|/* Now the ELSE-expression.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|if_false_label
condition|?
name|if_false_label
else|:
name|drop_through_label
argument_list|,
name|if_true_label
condition|?
name|if_true_label
else|:
name|drop_through_label
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
block|{
name|tree
name|exp0
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|exp1
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|do_jump
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|EQ
argument_list|,
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_equality
argument_list|(
name|exp
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|EQ
argument_list|,
name|EQ
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NE_EXPR
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
block|{
name|tree
name|exp0
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|exp1
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|do_jump
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|NE
argument_list|,
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_equality
argument_list|(
name|exp
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LT_EXPR
case|:
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|LT
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|LT
argument_list|,
name|LTU
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|LE
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|LE
argument_list|,
name|LEU
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|GT
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|GT
argument_list|,
name|GTU
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|GE
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|GE
argument_list|,
name|GEU
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
block|{
name|enum
name|rtx_code
name|cmp
decl_stmt|,
name|rcmp
decl_stmt|;
name|int
name|do_rev
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|UNORDERED_EXPR
condition|)
name|cmp
operator|=
name|UNORDERED
operator|,
name|rcmp
operator|=
name|ORDERED
expr_stmt|;
else|else
name|cmp
operator|=
name|ORDERED
operator|,
name|rcmp
operator|=
name|UNORDERED
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|do_rev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|can_compare_p
argument_list|(
name|cmp
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
operator|&&
operator|(
name|can_compare_p
argument_list|(
name|rcmp
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
comment|/* If the target doesn't provide either UNORDERED or ORDERED 		   comparisons, canonicalize on UNORDERED for the library.  */
operator|||
name|rcmp
operator|==
name|UNORDERED
operator|)
condition|)
name|do_rev
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|do_rev
condition|)
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|cmp
argument_list|,
name|cmp
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|rcmp
argument_list|,
name|rcmp
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
block|}
break|break;
block|{
name|enum
name|rtx_code
name|rcode1
decl_stmt|;
name|enum
name|tree_code
name|tcode2
decl_stmt|;
case|case
name|UNLT_EXPR
case|:
name|rcode1
operator|=
name|UNLT
expr_stmt|;
name|tcode2
operator|=
name|LT_EXPR
expr_stmt|;
goto|goto
name|unordered_bcc
goto|;
case|case
name|UNLE_EXPR
case|:
name|rcode1
operator|=
name|UNLE
expr_stmt|;
name|tcode2
operator|=
name|LE_EXPR
expr_stmt|;
goto|goto
name|unordered_bcc
goto|;
case|case
name|UNGT_EXPR
case|:
name|rcode1
operator|=
name|UNGT
expr_stmt|;
name|tcode2
operator|=
name|GT_EXPR
expr_stmt|;
goto|goto
name|unordered_bcc
goto|;
case|case
name|UNGE_EXPR
case|:
name|rcode1
operator|=
name|UNGE
expr_stmt|;
name|tcode2
operator|=
name|GE_EXPR
expr_stmt|;
goto|goto
name|unordered_bcc
goto|;
case|case
name|UNEQ_EXPR
case|:
name|rcode1
operator|=
name|UNEQ
expr_stmt|;
name|tcode2
operator|=
name|EQ_EXPR
expr_stmt|;
goto|goto
name|unordered_bcc
goto|;
name|unordered_bcc
label|:
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_compare_p
argument_list|(
name|rcode1
argument_list|,
name|mode
argument_list|,
name|ccp_jump
argument_list|)
condition|)
name|do_compare_and_jump
argument_list|(
name|exp
argument_list|,
name|rcode1
argument_list|,
name|rcode1
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|op0
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|cmp0
decl_stmt|,
name|cmp1
decl_stmt|;
comment|/* If the target doesn't support combined unordered 	       compares, decompose into UNORDERED + comparison.  */
name|cmp0
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|UNORDERED_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|cmp1
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|tcode2
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|)
expr_stmt|;
name|do_jump
argument_list|(
name|exp
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* Special case: 		__builtin_expect (<test>, 0)	and 		__builtin_expect (<test>, 1)  	 We need to do this here, so that<test> is not converted to a SCC 	 operation on machines that use condition code registers and COMPARE 	 like the PowerPC, and then the jump is done based on whether the SCC 	 operation produced a 1 or 0.  */
case|case
name|CALL_EXPR
case|:
comment|/* Check for a built-in function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_EXPECT
operator|&&
name|arglist
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|rtx
name|seq
init|=
name|expand_builtin_expect_jump
argument_list|(
name|exp
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
name|NULL_RTX
condition|)
block|{
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* fall through and generate the normal code.  */
default|default:
name|normal
label|:
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is not needed any more and causes poor code since it causes 	 comparisons and tests from non-SI objects to have different code 	 sequences.  */
comment|/* Copy to register to avoid generating bad insns by cse 	 from (set (mem ...) (arithop))  (set (cc0) (mem ...)).  */
block|if (!cse_not_expected&& GET_CODE (temp) == MEM) 	temp = copy_to_reg (temp);
endif|#
directive|endif
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Do any postincrements in the expression that was tested.  */
name|emit_queue
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|target
init|=
name|temp
operator|==
name|const0_rtx
condition|?
name|if_false_label
else|:
name|if_true_label
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|emit_jump
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|NE
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|ccp_jump
argument_list|)
condition|)
comment|/* Note swapping the labels gives us not-equal.  */
name|do_jump_by_parts_equality_rtx
argument_list|(
name|temp
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|do_compare_rtx_and_jump
argument_list|(
name|temp
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|,
name|NE
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|drop_through_label
condition|)
block|{
comment|/* If do_jump produces code that might be jumped around, 	 do any stack adjusts from that code, before the place 	 where control merges in.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a comparison expression EXP for values too wide to be compared    with one insn, test the comparison and jump to the appropriate label.    The code of EXP is ignored; we always test GT if SWAP is 0,    and LT if SWAP is 1.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_by_parts_greater
parameter_list|(
name|exp
parameter_list|,
name|swap
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|swap
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|swap
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
operator|!
name|swap
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare OP0 with OP1, word at a time, in mode MODE.    UNSIGNEDP says to do unsigned comparison.    Jump to IF_TRUE_LABEL if OP0 is greater, IF_FALSE_LABEL otherwise.  */
end_comment

begin_function
name|void
name|do_jump_by_parts_greater_rtx
parameter_list|(
name|mode
parameter_list|,
name|unsignedp
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|int
name|nwords
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|if_true_label
operator|||
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|if_true_label
condition|)
name|if_true_label
operator|=
name|drop_through_label
expr_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|if_false_label
operator|=
name|drop_through_label
expr_stmt|;
comment|/* Compare a word at a time, high order first.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|op0_word
decl_stmt|,
name|op1_word
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* All but high-order word must be compared as unsigned.  */
name|do_compare_rtx_and_jump
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
name|GT
argument_list|,
operator|(
name|unsignedp
operator|||
name|i
operator|>
literal|0
operator|)
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
comment|/* Consider lower words only if these are equal.  */
name|do_compare_rtx_and_jump
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
name|NE
argument_list|,
name|unsignedp
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an EQ_EXPR expression EXP for values too wide to be compared    with one insn, test the comparison and jump to the appropriate label.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_by_parts_equality
parameter_list|(
name|exp
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nwords
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|if_false_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
name|do_compare_rtx_and_jump
argument_list|(
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Jump according to whether OP0 is 0.    We assume that OP0 has an integer mode that is too wide    for the available compare insns.  */
end_comment

begin_function
name|void
name|do_jump_by_parts_equality_rtx
parameter_list|(
name|op0
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|int
name|nwords
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|rtx
name|part
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
comment|/* The fastest way of doing this comparison on almost any machine is to      "or" all the words and compare the result.  If all have to be loaded      from memory and this is a very wide item, it's possible this may      be slower, but that's highly unlikely.  */
name|part
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|part
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nwords
operator|&&
name|part
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|part
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|part
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|,
name|part
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|!=
literal|0
condition|)
block|{
name|do_compare_rtx_and_jump
argument_list|(
name|part
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|1
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we couldn't do the "or" simply, do this with a series of compares.  */
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|if_false_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
name|do_compare_rtx_and_jump
argument_list|(
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|1
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code for a comparison of OP0 and OP1 with rtx code CODE.    (including code to compute the values to be compared)    and set (CC0) according to the result.    The decision as to signed or unsigned comparison must be made by the caller.     We force a stack adjustment unless there are currently    things pushed on the stack that aren't yet used.     If MODE is BLKmode, SIZE is an RTX giving the size of the objects being    compared.  */
end_comment

begin_function
name|rtx
name|compare_from_rtx
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|code
parameter_list|,
name|unsignedp
parameter_list|,
name|mode
parameter_list|,
name|size
parameter_list|)
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|size
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If one operand is constant, make it the second one.  Only do this      if the other operand is not constant as well.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|tem
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
if|#
directive|if
literal|0
comment|/* There's no need to do this now that combine.c can eliminate lots of      sign extensions.  This can be less efficient in certain cases on other      machines.  */
comment|/* If this is a signed equality comparison, we can do it as an      unsigned comparison since zero-extension is cheaper than sign      extension and comparisons with zero are done as unsigned.  This is      the case even on machines that can do fast sign extension, since      zero-extension is easier to combine with other operations than      sign-extension is.  If we are comparing against a constant, we must      convert it to what it would look like unsigned.  */
block|if ((code == EQ || code == NE)&& ! unsignedp&& GET_MODE_BITSIZE (GET_MODE (op0))<= HOST_BITS_PER_WIDE_INT)     {       if (GET_CODE (op1) == CONST_INT&& (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0))) != INTVAL (op1)) 	op1 = GEN_INT (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0)));       unsignedp = 1;     }
endif|#
directive|endif
name|emit_cmp_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|cc0_rtx
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like do_compare_and_jump but expects the values to compare as two rtx's.    The decision as to signed or unsigned comparison must be made by the caller.     If MODE is BLKmode, SIZE is an RTX giving the size of the objects being    compared.  */
end_comment

begin_function
name|void
name|do_compare_rtx_and_jump
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|code
parameter_list|,
name|unsignedp
parameter_list|,
name|mode
parameter_list|,
name|size
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
name|int
name|dummy_true_label
init|=
literal|0
decl_stmt|;
comment|/* Reverse the comparison if that is safe and we want to jump if it is      false.  */
if|if
condition|(
operator|!
name|if_true_label
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|if_true_label
operator|=
name|if_false_label
expr_stmt|;
name|if_false_label
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* If one operand is constant, make it the second one.  Only do this      if the other operand is not constant as well.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|tem
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tem
operator|==
name|const_true_rtx
condition|)
block|{
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|#
directive|if
literal|0
comment|/* There's no need to do this now that combine.c can eliminate lots of      sign extensions.  This can be less efficient in certain cases on other      machines.  */
comment|/* If this is a signed equality comparison, we can do it as an      unsigned comparison since zero-extension is cheaper than sign      extension and comparisons with zero are done as unsigned.  This is      the case even on machines that can do fast sign extension, since      zero-extension is easier to combine with other operations than      sign-extension is.  If we are comparing against a constant, we must      convert it to what it would look like unsigned.  */
block|if ((code == EQ || code == NE)&& ! unsignedp&& GET_MODE_BITSIZE (GET_MODE (op0))<= HOST_BITS_PER_WIDE_INT)     {       if (GET_CODE (op1) == CONST_INT&& (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0))) != INTVAL (op1)) 	op1 = GEN_INT (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0)));       unsignedp = 1;     }
endif|#
directive|endif
if|if
condition|(
operator|!
name|if_true_label
condition|)
block|{
name|dummy_true_label
operator|=
literal|1
expr_stmt|;
name|if_true_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
name|emit_cmp_and_jump_insns
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_true_label
condition|)
name|emit_label
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code for a comparison expression EXP (including code to compute    the values to be compared) and a conditional jump to IF_FALSE_LABEL and/or    IF_TRUE_LABEL.  One of the labels can be NULL_RTX, in which case the    generated code will drop through.    SIGNED_CODE should be the rtx operation for this comparison for    signed data; UNSIGNED_CODE, likewise for use if data is unsigned.     We force a stack adjustment unless there are currently    things pushed on the stack that aren't yet used.  */
end_comment

begin_function
specifier|static
name|void
name|do_compare_and_jump
parameter_list|(
name|exp
parameter_list|,
name|signed_code
parameter_list|,
name|unsigned_code
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|enum
name|rtx_code
name|signed_code
decl_stmt|,
name|unsigned_code
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
comment|/* Don't crash if the comparison was erroneous.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* op0 might have been replaced by promoted constant, in which 	 case the type of second argument should be used.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|code
operator|=
name|unsignedp
condition|?
name|unsigned_code
else|:
name|signed_code
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_canonicalize_funcptr_for_compare
comment|/* If function pointers need to be "canonicalized" before they can      be reliably compared, then canonicalize them.  */
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|rtx
name|new_op0
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_canonicalize_funcptr_for_compare
argument_list|(
name|new_op0
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|new_op0
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|rtx
name|new_op1
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_canonicalize_funcptr_for_compare
argument_list|(
name|new_op1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|new_op1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Do any postincrements in the expression that was tested.  */
name|emit_queue
argument_list|()
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|expr_size
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|NULL_RTX
operator|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to calculate EXP using a store-flag instruction    and return an rtx for the result.  EXP is either a comparison    or a TRUTH_NOT_EXPR whose operand is a comparison.     If TARGET is nonzero, store the result there if convenient.     If ONLY_CHEAP is non-zero, only do this if it is likely to be very    cheap.     Return zero if there is no suitable set-flag instruction    available on this machine.     Once expand_expr has been called on the arguments of the comparison,    we are committed to doing the store flag, since it is not safe to    re-evaluate the expression.  We emit the store-flag insn by calling    emit_store_flag, but only expand the arguments if we have a reason    to believe that emit_store_flag will be successful.  If we think that    it will, but it isn't, we have to simulate the store-flag with a    set/jump/set sequence.  */
end_comment

begin_function
specifier|static
name|rtx
name|do_store_flag
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|,
name|only_cheap
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|only_cheap
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|enum
name|machine_mode
name|operand_mode
decl_stmt|;
name|int
name|invert
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|subtarget
init|=
name|target
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|label
decl_stmt|;
comment|/* If this is a TRUTH_NOT_EXPR, set a flag indicating we must invert the      result at the end.  We can't simply invert the test since it would      have already been inverted if it were valid.  This case occurs for      some floating-point comparisons.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|invert
operator|=
literal|1
operator|,
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't crash if the comparison was erroneous.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|operand_mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* We won't bother with BLKmode store-flag operations because it would mean      passing a lot of information to emit_store_flag.  */
if|if
condition|(
name|operand_mode
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
comment|/* We won't bother with store-flag operations involving function pointers      when function pointers must be canonicalized before comparisons.  */
ifdef|#
directive|ifdef
name|HAVE_canonicalize_funcptr_for_compare
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* Get the rtx comparison code to use.  We know that EXP is a comparison      operation of some type.  Some comparisons against 1 and -1 can be      converted to comparisons with zero.  Do so here so that the tests      below will be aware that we have a comparison with zero.   These      tests will not catch constants in the first operand, but constants      are rarely passed as the first operand.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|unsignedp
condition|?
name|LEU
else|:
name|LE
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|LTU
else|:
name|LT
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|LT
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|LEU
else|:
name|LE
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|GE
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|GTU
else|:
name|GT
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|unsignedp
condition|?
name|GTU
else|:
name|GT
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|GEU
else|:
name|GE
expr_stmt|;
break|break;
case|case
name|UNORDERED_EXPR
case|:
name|code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|ORDERED_EXPR
case|:
name|code
operator|=
name|ORDERED
expr_stmt|;
break|break;
case|case
name|UNLT_EXPR
case|:
name|code
operator|=
name|UNLT
expr_stmt|;
break|break;
case|case
name|UNLE_EXPR
case|:
name|code
operator|=
name|UNLE
expr_stmt|;
break|break;
case|case
name|UNGT_EXPR
case|:
name|code
operator|=
name|UNGT
expr_stmt|;
break|break;
case|case
name|UNGE_EXPR
case|:
name|code
operator|=
name|UNGE
expr_stmt|;
break|break;
case|case
name|UNEQ_EXPR
case|:
name|code
operator|=
name|UNEQ
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Put a constant second.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tem
operator|=
name|arg0
expr_stmt|;
name|arg0
operator|=
name|arg1
expr_stmt|;
name|arg1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* If this is an equality or inequality test of a single bit, we can      do this by shifting the bit being tested to the low-order bit and      masking the result with the constant 1.  If the condition was EQ,      we xor it with 1.  This does not require an scc insn and is faster      than an scc insn even if we have it.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|bitnum
init|=
name|tree_log2
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|ops_unsignedp
decl_stmt|;
comment|/* If INNER is a right shift of a constant and it plus BITNUM does 	 not overflow, adjust BITNUM and INNER.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|RSHIFT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|bitnum
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bitnum
operator|-
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|bitnum
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we are going to be able to omit the AND below, we must do our 	 operations as unsigned.  If we must use the AND, we have a choice. 	 Normally unsigned is faster, but for some machines signed is.  */
name|ops_unsignedp
operator|=
operator|(
name|bitnum
operator|==
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
condition|?
literal|1
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
else|:
operator|(
name|LOAD_EXTEND_OP
argument_list|(
name|operand_mode
argument_list|)
operator|==
name|SIGN_EXTEND
condition|?
literal|0
else|:
literal|1
operator|)
else|#
directive|else
else|:
literal|1
endif|#
directive|endif
block|)
function|;
end_function

begin_if
if|if
condition|(
operator|!
name|get_subtarget
argument_list|(
name|subtarget
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|subtarget
argument_list|)
operator|!=
name|operand_mode
operator|||
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|inner
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|op0
operator|=
name|expand_expr
argument_list|(
name|inner
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bitnum
operator|!=
literal|0
condition|)
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|operand_mode
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|bitnum
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|ops_unsignedp
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|ops_unsignedp
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|&&
operator|!
name|invert
operator|)
operator|||
operator|(
name|code
operator|==
name|NE
operator|&&
name|invert
operator|)
condition|)
name|op0
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|,
name|ops_unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Put the AND last so it can combine with more things.  */
end_comment

begin_if
if|if
condition|(
name|bitnum
operator|!=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
condition|)
name|op0
operator|=
name|expand_and
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|op0
return|;
end_return

begin_comment
unit|}
comment|/* Now see if we are likely to be able to do this.  Return if not.  */
end_comment

begin_expr_stmt
unit|if
operator|(
operator|!
name|can_compare_p
argument_list|(
name|code
argument_list|,
name|operand_mode
argument_list|,
name|ccp_store_flag
argument_list|)
operator|)
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_expr_stmt
name|icode
operator|=
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|||
operator|(
name|only_cheap
operator|&&
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|!=
name|mode
operator|)
condition|)
block|{
comment|/* We can only do this if it is one of the special cases that 	 can be handled without an scc insn.  */
if|if
condition|(
operator|(
name|code
operator|==
name|LT
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|only_cheap
operator|&&
name|code
operator|==
name|GE
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|BRANCH_COST
operator|>=
literal|0
operator|&&
operator|!
name|only_cheap
operator|&&
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
operator|&&
operator|(
operator|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|operand_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|operand_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|get_subtarget
argument_list|(
name|target
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|subtarget
argument_list|)
operator|!=
name|operand_mode
operator|||
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|arg1
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Pass copies of OP0 and OP1 in case they contain a QUEUED.  This is safe      because, if the emit_store_flag does anything it will succeed and      OP0 and OP1 will not be used subsequently.  */
end_comment

begin_expr_stmt
name|result
operator|=
name|emit_store_flag
argument_list|(
name|target
argument_list|,
name|code
argument_list|,
name|queued_subexp_p
argument_list|(
name|op0
argument_list|)
condition|?
name|copy_rtx
argument_list|(
name|op0
argument_list|)
else|:
name|op0
argument_list|,
name|queued_subexp_p
argument_list|(
name|op1
argument_list|)
condition|?
name|copy_rtx
argument_list|(
name|op1
argument_list|)
else|:
name|op1
argument_list|,
name|operand_mode
argument_list|,
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|result
condition|)
block|{
if|if
condition|(
name|invert
condition|)
name|result
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_if

begin_comment
comment|/* If this failed, we have to do this with set/compare/jump/set code.  */
end_comment

begin_if
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|invert
condition|?
name|const0_rtx
else|:
name|const1_rtx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|result
operator|=
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|operand_mode
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
operator|(
name|result
operator|==
name|const0_rtx
operator|&&
operator|!
name|invert
operator|)
operator|||
operator|(
name|result
operator|!=
name|const0_rtx
operator|&&
name|invert
operator|)
operator|)
condition|?
name|const0_rtx
else|:
name|const1_rtx
operator|)
return|;
end_if

begin_comment
comment|/* The code of RESULT may not match CODE if compare_from_rtx      decided to swap its operands and reverse the original code.       We know that compare_from_rtx returns either a CONST_INT or      a new comparison code, so it is safe to just extract the      code from RESULT.  */
end_comment

begin_expr_stmt
name|code
operator|=
name|GET_CODE
argument_list|(
name|result
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
call|)
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|invert
condition|?
name|const1_rtx
else|:
name|const0_rtx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|target
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* Stubs in case we haven't got a casesi insn.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_casesi
end_ifndef

begin_define
define|#
directive|define
name|HAVE_casesi
value|0
end_define

begin_define
define|#
directive|define
name|gen_casesi
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|(0)
end_define

begin_define
define|#
directive|define
name|CODE_FOR_casesi
value|CODE_FOR_nothing
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If the machine does not have a case insn that compares the bounds,    this means extra overhead for dispatch tables, which raises the    threshold for using them.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CASE_VALUES_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|CASE_VALUES_THRESHOLD
value|(HAVE_casesi ? 4 : 5)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CASE_VALUES_THRESHOLD */
end_comment

begin_function
unit|unsigned
name|int
name|case_values_threshold
parameter_list|()
block|{
return|return
name|CASE_VALUES_THRESHOLD
return|;
block|}
end_function

begin_comment
comment|/* Attempt to generate a casesi instruction.  Returns 1 if successful,    0 otherwise (i.e. if there is no casesi instruction).  */
end_comment

begin_function
name|int
name|try_casesi
parameter_list|(
name|index_type
parameter_list|,
name|index_expr
parameter_list|,
name|minval
parameter_list|,
name|range
parameter_list|,
name|table_label
parameter_list|,
name|default_label
parameter_list|)
name|tree
name|index_type
decl_stmt|,
name|index_expr
decl_stmt|,
name|minval
decl_stmt|,
name|range
decl_stmt|;
name|rtx
name|table_label
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|default_label
decl_stmt|;
block|{
name|enum
name|machine_mode
name|index_mode
init|=
name|SImode
decl_stmt|;
name|int
name|index_bits
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|index_mode
argument_list|)
decl_stmt|;
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|index
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_casesi
condition|)
return|return
literal|0
return|;
comment|/* Convert the index to SImode.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|index_mode
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|omode
init|=
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
decl_stmt|;
name|rtx
name|rangertx
init|=
name|expand_expr
argument_list|(
name|range
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We must handle the endpoints in the original mode.  */
name|index_expr
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|minval
operator|=
name|integer_zero_node
expr_stmt|;
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|rangertx
argument_list|,
name|index
argument_list|,
name|LTU
argument_list|,
name|NULL_RTX
argument_list|,
name|omode
argument_list|,
literal|1
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
comment|/* Now we can safely truncate.  */
name|index
operator|=
name|convert_to_mode
argument_list|(
name|index_mode
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
operator|!=
name|index_mode
condition|)
block|{
name|index_expr
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|index_bits
argument_list|,
literal|0
argument_list|)
argument_list|,
name|index_expr
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|op_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|index
operator|,
name|op_mode
operator|)
condition|)
name|index
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|minval
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|op1
operator|=
name|convert_modes
argument_list|(
name|op_mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|minval
argument_list|)
argument_list|)
argument_list|,
name|op1
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|minval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|op_mode
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|range
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|op2
operator|=
name|convert_modes
argument_list|(
name|op_mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|range
argument_list|)
argument_list|)
argument_list|,
name|op2
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|range
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|op_mode
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_casesi
argument_list|(
name|index
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Attempt to generate a tablejump instruction; same concept.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_tablejump
end_ifndef

begin_define
define|#
directive|define
name|HAVE_tablejump
value|0
end_define

begin_define
define|#
directive|define
name|gen_tablejump
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Subroutine of the next function.     INDEX is the value being switched on, with the lowest value    in the table already subtracted.    MODE is its expected mode (needed if INDEX is constant).    RANGE is the length of the jump table.    TABLE_LABEL is a CODE_LABEL rtx for the table itself.     DEFAULT_LABEL is a CODE_LABEL rtx to jump to if the    index value is out of range.  */
end_comment

begin_function
specifier|static
name|void
name|do_tablejump
parameter_list|(
name|index
parameter_list|,
name|mode
parameter_list|,
name|range
parameter_list|,
name|table_label
parameter_list|,
name|default_label
parameter_list|)
name|rtx
name|index
decl_stmt|,
name|range
decl_stmt|,
name|table_label
decl_stmt|,
name|default_label
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|,
name|vector
decl_stmt|;
comment|/* Do an unsigned comparison (in the proper mode) between the index      expression and the value which represents the length of the range.      Since we just finished subtracting the lower bound of the range      from the index expression, this comparison allows us to simultaneously      check that the original index expression value is both greater than      or equal to the minimum value of the range and less than or equal to      the maximum value of the range.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|range
argument_list|,
name|GTU
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
comment|/* If index is in range, it must fit in Pmode.      Convert to Pmode so we can index with it.  */
if|if
condition|(
name|mode
operator|!=
name|Pmode
condition|)
name|index
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't let a MEM slip thru, because then INDEX that comes      out of PIC_CASE_VECTOR_ADDRESS won't be a valid address,      and break_out_memory_refs will go to work on it and mess it up.  */
ifdef|#
directive|ifdef
name|PIC_CASE_VECTOR_ADDRESS
if|if
condition|(
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|REG
condition|)
name|index
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If flag_force_addr were to affect this address      it could interfere with the tricky assumptions made      about addresses that contain label-refs,      which may be valid only very near the tablejump itself.  */
comment|/* ??? The only correct use of CASE_VECTOR_MODE is the one inside the      GET_MODE_SIZE, because this indicates how large insns are.  The other      uses should all be Pmode, because they are addresses.  This code      could fail if addresses and insns are not the same size.  */
name|index
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|index
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|CASE_VECTOR_MODE
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|table_label
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC_CASE_VECTOR_ADDRESS
if|if
condition|(
name|flag_pic
condition|)
name|index
operator|=
name|PIC_CASE_VECTOR_ADDRESS
argument_list|(
name|index
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|index
operator|=
name|memory_address_noforce
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|CASE_VECTOR_MODE
argument_list|)
expr_stmt|;
name|vector
operator|=
name|gen_rtx_MEM
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|vector
argument_list|)
operator|=
literal|1
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|vector
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_tablejump
argument_list|(
name|temp
argument_list|,
name|table_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are generating PIC code or if the table is PC-relative, the      table and JUMP_INSN must be adjacent, so don't output a BARRIER.  */
if|if
condition|(
operator|!
name|CASE_VECTOR_PC_RELATIVE
operator|&&
operator|!
name|flag_pic
condition|)
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|try_tablejump
parameter_list|(
name|index_type
parameter_list|,
name|index_expr
parameter_list|,
name|minval
parameter_list|,
name|range
parameter_list|,
name|table_label
parameter_list|,
name|default_label
parameter_list|)
name|tree
name|index_type
decl_stmt|,
name|index_expr
decl_stmt|,
name|minval
decl_stmt|,
name|range
decl_stmt|;
name|rtx
name|table_label
decl_stmt|,
name|default_label
decl_stmt|;
block|{
name|rtx
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_tablejump
condition|)
return|return
literal|0
return|;
name|index_expr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|convert
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|)
argument_list|,
name|convert
argument_list|(
name|index_type
argument_list|,
name|minval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|expand_expr
argument_list|(
name|index_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|index
operator|=
name|protect_from_queue
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_tablejump
argument_list|(
name|index
argument_list|,
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
argument_list|,
name|convert_modes
argument_list|(
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|range
argument_list|)
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|range
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|range
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

