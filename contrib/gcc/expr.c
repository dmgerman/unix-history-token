begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert tree expression to rtl instructions, for GNU compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation,    Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* Include expr.h after insn-config.h so we get HAVE_conditional_move.  */
end_comment

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"typeclass.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_comment
comment|/* Decide whether a function's arguments should be processed    from first to last or from last to first.     They should if the stack and args grow in opposite directions, but    only if we have push insns.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STACK_GROWS_DOWNWARD
argument_list|)
operator|!=
name|defined
argument_list|(
name|ARGS_GROW_DOWNWARD
argument_list|)
end_if

begin_define
define|#
directive|define
name|PUSH_ARGS_REVERSED
end_define

begin_comment
comment|/* If it's last to first.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_PUSH_CODE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_DEC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_INC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If this is nonzero, we do not bother generating VOLATILE    around volatile memory references, and we are willing to    output indirect addresses.  If cse is to follow, we reject    indirect addresses so a useful potential cse is generated;    if it is used only once, instruction combination will produce    the same indirect address eventually.  */
end_comment

begin_decl_stmt
name|int
name|cse_not_expected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used by move_by_pieces to describe the move to    be performed.  */
end_comment

begin_struct
struct|struct
name|move_by_pieces
block|{
name|rtx
name|to
decl_stmt|;
name|rtx
name|to_addr
decl_stmt|;
name|int
name|autinc_to
decl_stmt|;
name|int
name|explicit_inc_to
decl_stmt|;
name|rtx
name|from
decl_stmt|;
name|rtx
name|from_addr
decl_stmt|;
name|int
name|autinc_from
decl_stmt|;
name|int
name|explicit_inc_from
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|reverse
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used by store_by_pieces to describe the clear to    be performed.  */
end_comment

begin_struct
struct|struct
name|store_by_pieces
block|{
name|rtx
name|to
decl_stmt|;
name|rtx
name|to_addr
decl_stmt|;
name|int
name|autinc_to
decl_stmt|;
name|int
name|explicit_inc_to
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|rtx
function_decl|(
modifier|*
name|constfun
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
name|void
modifier|*
name|constfundata
decl_stmt|;
name|int
name|reverse
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|move_by_pieces_ninsns
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|move_by_pieces_1
parameter_list|(
name|rtx
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
modifier|...
parameter_list|)
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|struct
name|move_by_pieces
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|block_move_libcall_safe_for_call_parm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|emit_block_move_via_movmem
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|emit_block_move_via_libcall
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|emit_block_move_libcall_fn
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_block_move_via_loop
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|clear_by_pieces_1
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_by_pieces
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_by_pieces_1
parameter_list|(
name|struct
name|store_by_pieces
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_by_pieces_2
parameter_list|(
name|rtx
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
modifier|...
parameter_list|)
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|struct
name|store_by_pieces
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|clear_storage_via_libcall
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|clear_storage_libcall_fn
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|compress_float_constant
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_subtarget
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_constructor_field
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_constructor
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|store_field
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|highest_pow2_factor_for_target
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_aligning_offset
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_operands
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|expand_modifier
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|reduce_to_bit_field_precision
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|do_store_flag
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
end_ifdef

begin_function_decl
specifier|static
name|void
name|emit_single_push_insn
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|do_tablejump
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|const_vector_from_tree
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_complex_part
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Record for each mode whether we can move a register directly to or    from an object of that mode in memory.  If we can't, we won't try    to use that mode directly when accessing a field of that mode.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|direct_load
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|direct_store
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record for each mode whether we can float-extend from memory.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|float_extend_from_mem
index|[
name|NUM_MACHINE_MODES
index|]
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This macro is used to determine whether move_by_pieces should be called    to perform a structure copy.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MOVE_BY_PIECES_P
end_ifndef

begin_define
define|#
directive|define
name|MOVE_BY_PIECES_P
parameter_list|(
name|SIZE
parameter_list|,
name|ALIGN
parameter_list|)
define|\
value|(move_by_pieces_ninsns (SIZE, ALIGN, MOVE_MAX_PIECES + 1) \< (unsigned int) MOVE_RATIO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This macro is used to determine whether clear_by_pieces should be    called to clear storage.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CLEAR_BY_PIECES_P
end_ifndef

begin_define
define|#
directive|define
name|CLEAR_BY_PIECES_P
parameter_list|(
name|SIZE
parameter_list|,
name|ALIGN
parameter_list|)
define|\
value|(move_by_pieces_ninsns (SIZE, ALIGN, STORE_MAX_PIECES + 1) \< (unsigned int) CLEAR_RATIO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This macro is used to determine whether store_by_pieces should be    called to "memset" storage with byte values other than zero, or    to "memcpy" storage when the source is a constant string.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STORE_BY_PIECES_P
end_ifndef

begin_define
define|#
directive|define
name|STORE_BY_PIECES_P
parameter_list|(
name|SIZE
parameter_list|,
name|ALIGN
parameter_list|)
define|\
value|(move_by_pieces_ninsns (SIZE, ALIGN, STORE_MAX_PIECES + 1) \< (unsigned int) MOVE_RATIO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array records the insn_code of insns to perform block moves.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|movmem_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array records the insn_code of insns to perform block sets.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|setmem_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These arrays record the insn_code of three different kinds of insns    to perform block compares.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|cmpstr_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|cmpstrn_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|cmpmem_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Synchronization primitives.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|sync_add_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_sub_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_ior_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_and_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_xor_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_nand_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_old_add_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_old_sub_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_old_ior_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_old_and_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_old_xor_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_old_nand_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_new_add_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_new_sub_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_new_ior_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_new_and_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_new_xor_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_new_nand_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_compare_and_swap
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_compare_and_swap_cc
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_lock_test_and_set
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|sync_lock_release
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SLOW_UNALIGNED_ACCESS is nonzero if unaligned accesses are very slow.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SLOW_UNALIGNED_ACCESS
end_ifndef

begin_define
define|#
directive|define
name|SLOW_UNALIGNED_ACCESS
parameter_list|(
name|MODE
parameter_list|,
name|ALIGN
parameter_list|)
value|STRICT_ALIGNMENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This is run once per compilation to set up which modes can be used    directly in memory and to initialize the block move optab.  */
end_comment

begin_function
name|void
name|init_expr_once
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|num_clobbers
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|mem1
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
comment|/* Try indexing by frame ptr and try by stack ptr.      It is known that on the Convex the stack ptr isn't a valid index.      With luck, one or the other is valid on any machine.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|mem1
operator|=
name|gen_rtx_MEM
argument_list|(
name|VOIDmode
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
comment|/* A scratch register we can modify in-place below to avoid      useless RTL allocations.  */
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|VOIDmode
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|INSN
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pat
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|mode
operator|<
name|NUM_MACHINE_MODES
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
block|{
name|int
name|regno
decl_stmt|;
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|0
expr_stmt|;
name|PUT_MODE
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|mem1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|reg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* See if there is some register that can be used in this mode and 	 directly loaded or stored from memory.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|==
literal|0
operator|||
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|==
literal|0
operator|)
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
continue|continue;
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|=
name|regno
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|mem
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|mem1
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|mem
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|mem1
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_raw_REG
argument_list|(
name|Pmode
argument_list|,
literal|10000
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|enum
name|machine_mode
name|srcmode
decl_stmt|;
for|for
control|(
name|srcmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|srcmode
operator|!=
name|mode
condition|;
name|srcmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|srcmode
argument_list|)
control|)
block|{
name|enum
name|insn_code
name|ic
decl_stmt|;
name|ic
operator|=
name|can_extend_p
argument_list|(
name|mode
argument_list|,
name|srcmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|==
name|CODE_FOR_nothing
condition|)
continue|continue;
name|PUT_MODE
argument_list|(
name|mem
argument_list|,
name|srcmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|insn_data
index|[
name|ic
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|mem
operator|,
name|srcmode
operator|)
condition|)
name|float_extend_from_mem
index|[
name|mode
index|]
index|[
name|srcmode
index|]
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This is run at the start of compiling a function.  */
end_comment

begin_function
name|void
name|init_expr
parameter_list|(
name|void
parameter_list|)
block|{
name|cfun
operator|->
name|expr
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expr_status
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy data from FROM to TO, where the machine modes are not the same.    Both modes may be integer, or both may be floating.    UNSIGNEDP should be nonzero if FROM is an unsigned type.    This causes zero-extension instead of sign-extension.  */
end_comment

begin_function
name|void
name|convert_move
parameter_list|(
name|rtx
name|to
parameter_list|,
name|rtx
name|from
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|enum
name|machine_mode
name|to_mode
init|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|from_mode
init|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|int
name|to_real
init|=
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|to_mode
argument_list|)
decl_stmt|;
name|int
name|from_real
init|=
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|from_mode
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|code
decl_stmt|;
name|rtx
name|libcall
decl_stmt|;
comment|/* rtx code for making an equivalent value.  */
name|enum
name|rtx_code
name|equiv_code
init|=
operator|(
name|unsignedp
operator|<
literal|0
condition|?
name|UNKNOWN
else|:
operator|(
name|unsignedp
condition|?
name|ZERO_EXTEND
else|:
name|SIGN_EXTEND
operator|)
operator|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|to_real
operator|==
name|from_real
argument_list|)
expr_stmt|;
comment|/* If the source and destination are already the same, then there's      nothing to do.  */
if|if
condition|(
name|to
operator|==
name|from
condition|)
return|return;
comment|/* If FROM is a SUBREG that indicates that we have already done at least      the required extension, strip it.  We don't handle such SUBREGs as      TO here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
operator|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|from
argument_list|)
operator|==
name|unsignedp
condition|)
name|from
operator|=
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
operator|,
name|from_mode
operator|=
name|to_mode
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|SUBREG
operator|||
operator|!
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_mode
operator|==
name|from_mode
operator|||
operator|(
name|from_mode
operator|==
name|VOIDmode
operator|&&
name|CONSTANT_P
argument_list|(
name|from
argument_list|)
operator|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|to_mode
argument_list|)
operator|||
name|VECTOR_MODE_P
argument_list|(
name|from_mode
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|to_mode
argument_list|)
condition|)
name|from
operator|=
name|simplify_gen_subreg
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|to
operator|=
name|simplify_gen_subreg
argument_list|(
name|from_mode
argument_list|,
name|to
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|CONCAT
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|convert_move
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|to_real
condition|)
block|{
name|rtx
name|value
decl_stmt|,
name|insns
decl_stmt|;
name|convert_optab
name|tab
decl_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|GET_MODE_PRECISION
argument_list|(
name|from_mode
argument_list|)
operator|!=
name|GET_MODE_PRECISION
argument_list|(
name|to_mode
argument_list|)
operator|)
operator|||
operator|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|from_mode
argument_list|)
operator|!=
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|to_mode
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_PRECISION
argument_list|(
name|from_mode
argument_list|)
operator|==
name|GET_MODE_PRECISION
argument_list|(
name|to_mode
argument_list|)
condition|)
comment|/* Conversion between decimal float and binary float, same size.  */
name|tab
operator|=
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|from_mode
argument_list|)
condition|?
name|trunc_optab
else|:
name|sext_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_PRECISION
argument_list|(
name|from_mode
argument_list|)
operator|<
name|GET_MODE_PRECISION
argument_list|(
name|to_mode
argument_list|)
condition|)
name|tab
operator|=
name|sext_optab
expr_stmt|;
else|else
name|tab
operator|=
name|trunc_optab
expr_stmt|;
comment|/* Try converting directly if the insn is supported.  */
name|code
operator|=
name|tab
operator|->
name|handlers
index|[
name|to_mode
index|]
index|[
name|from_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|tab
operator|==
name|sext_optab
condition|?
name|FLOAT_EXTEND
else|:
name|FLOAT_TRUNCATE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise use a libcall.  */
name|libcall
operator|=
name|tab
operator|->
name|handlers
index|[
name|to_mode
index|]
index|[
name|from_mode
index|]
operator|.
name|libfunc
expr_stmt|;
comment|/* Is this conversion implemented yet?  */
name|gcc_assert
argument_list|(
name|libcall
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|libcall
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|to_mode
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|from_mode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|to
argument_list|,
name|value
argument_list|,
name|tab
operator|==
name|trunc_optab
condition|?
name|gen_rtx_FLOAT_TRUNCATE
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
else|:
name|gen_rtx_FLOAT_EXTEND
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle pointer conversion.  */
comment|/* SPEE 900220.  */
comment|/* Targets are expected to provide conversion insns between PxImode and      xImode for all MODE_PARTIAL_INT modes they use, but no others.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|to_mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
condition|)
block|{
name|enum
name|machine_mode
name|full_mode
init|=
name|smallest_mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|MODE_INT
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|trunc_optab
operator|->
name|handlers
index|[
name|to_mode
index|]
index|[
name|full_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
argument_list|)
expr_stmt|;
if|if
condition|(
name|full_mode
operator|!=
name|from_mode
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|full_mode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|trunc_optab
operator|->
name|handlers
index|[
name|to_mode
index|]
index|[
name|full_mode
index|]
operator|.
name|insn_code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|from_mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
condition|)
block|{
name|rtx
name|new_from
decl_stmt|;
name|enum
name|machine_mode
name|full_mode
init|=
name|smallest_mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
argument_list|,
name|MODE_INT
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|sext_optab
operator|->
name|handlers
index|[
name|full_mode
index|]
index|[
name|from_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_mode
operator|==
name|full_mode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|sext_optab
operator|->
name|handlers
index|[
name|full_mode
index|]
index|[
name|from_mode
index|]
operator|.
name|insn_code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_from
operator|=
name|gen_reg_rtx
argument_list|(
name|full_mode
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|sext_optab
operator|->
name|handlers
index|[
name|full_mode
index|]
index|[
name|from_mode
index|]
operator|.
name|insn_code
argument_list|,
name|new_from
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
comment|/* else proceed to integer conversions below.  */
name|from_mode
operator|=
name|full_mode
expr_stmt|;
name|from
operator|=
name|new_from
expr_stmt|;
block|}
comment|/* Now both modes are integers.  */
comment|/* Handle expanding beyond a word.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|lowpart
decl_stmt|;
name|rtx
name|fill_value
decl_stmt|;
name|rtx
name|lowfrom
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|lowpart_mode
decl_stmt|;
name|int
name|nwords
init|=
name|CEIL
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
comment|/* Try converting directly if the insn is supported.  */
if|if
condition|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
comment|/* If FROM is a SUBREG, put it into a register.  Do this 	     so that we always generate the same set of insns for 	     better cse'ing; if an intermediate assignment occurred, 	     we won't be doing the operation directly on the SUBREG.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Next, try converting via full word.  */
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
operator|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|word_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|to
argument_list|)
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|to
argument_list|)
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* No special multiword conversion insn; do it by hand.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Since we will turn this into a no conflict block, we must ensure 	 that the source does not overlap the target.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
comment|/* Get a copy of FROM widened to a word, if necessary.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
name|lowpart_mode
operator|=
name|word_mode
expr_stmt|;
else|else
name|lowpart_mode
operator|=
name|from_mode
expr_stmt|;
name|lowfrom
operator|=
name|convert_to_mode
argument_list|(
name|lowpart_mode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|lowpart
operator|=
name|gen_lowpart
argument_list|(
name|lowpart_mode
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|lowpart
argument_list|,
name|lowfrom
argument_list|)
expr_stmt|;
comment|/* Compute the value to put in each remaining word.  */
if|if
condition|(
name|unsignedp
condition|)
name|fill_value
operator|=
name|const0_rtx
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_slt
if|if
condition|(
name|HAVE_slt
operator|&&
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_slt
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|==
name|word_mode
operator|&&
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|lowfrom
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|lowpart_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fill_value
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_slt
argument_list|(
name|fill_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|fill_value
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|lowpart_mode
argument_list|,
name|lowfrom
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|lowpart_mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fill_value
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|fill_value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fill the remaining words.  */
for|for
control|(
name|i
operator|=
name|GET_MODE_SIZE
argument_list|(
name|lowpart_mode
argument_list|)
operator|/
name|UNITS_PER_WORD
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|nwords
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
decl_stmt|;
name|rtx
name|subword
init|=
name|operand_subword
argument_list|(
name|to
argument_list|,
name|index
argument_list|,
literal|1
argument_list|,
name|to_mode
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|subword
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill_value
operator|!=
name|subword
condition|)
name|emit_move_insn
argument_list|(
name|subword
argument_list|,
name|fill_value
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|equiv_code
argument_list|,
name|to_mode
argument_list|,
name|copy_rtx
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Truncating multi-word to a word or less.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|>
name|BITS_PER_WORD
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<=
name|BITS_PER_WORD
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|MEM_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|from
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|to_mode
index|]
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|REG_P
argument_list|(
name|from
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|from
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now follow all the conversions between integers      no more than a word long.  */
comment|/* For truncation, usually we can just refer to FROM in a narrower mode.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|MEM_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|from
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|to_mode
index|]
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|REG_P
argument_list|(
name|from
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|from
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|from
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|from
argument_list|)
argument_list|,
name|to_mode
argument_list|)
condition|)
name|from
operator|=
name|copy_to_reg
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle extension.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
condition|)
block|{
comment|/* Convert directly if that works.  */
if|if
condition|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|enum
name|machine_mode
name|intermediate
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|tree
name|shift_amount
decl_stmt|;
comment|/* Search for a mode to convert via.  */
for|for
control|(
name|intermediate
operator|=
name|from_mode
init|;
name|intermediate
operator|!=
name|VOIDmode
condition|;
name|intermediate
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|intermediate
argument_list|)
control|)
if|if
condition|(
operator|(
operator|(
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|intermediate
argument_list|,
name|unsignedp
argument_list|)
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|intermediate
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|intermediate
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|can_extend_p
argument_list|(
name|intermediate
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|convert_move
argument_list|(
name|to
argument_list|,
name|convert_to_mode
argument_list|(
name|intermediate
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* No suitable intermediate mode. 	     Generate what we need with	shifts.  */
name|shift_amount
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|to_mode
argument_list|,
name|from
argument_list|,
name|shift_amount
argument_list|,
name|to
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|to_mode
argument_list|,
name|tmp
argument_list|,
name|shift_amount
argument_list|,
name|to
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|to
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Support special truncate insns for certain modes.  */
if|if
condition|(
name|trunc_optab
operator|->
name|handlers
index|[
name|to_mode
index|]
index|[
name|from_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|trunc_optab
operator|->
name|handlers
index|[
name|to_mode
index|]
index|[
name|from_mode
index|]
operator|.
name|insn_code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle truncation of volatile memrefs, and so on;      the things that couldn't be truncated directly,      and for which there was no special instruction.       ??? Code above formerly short-circuited this, for most integer      mode pairs, with a force_reg in from_mode followed by a recursive      call to this routine.  Appears always to have been wrong.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|force_reg
argument_list|(
name|to_mode
argument_list|,
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Mode combination is not recognized.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an rtx for a value that would result    from converting X to mode MODE.    Both X and MODE may be floating, or both integer.    UNSIGNEDP is nonzero if X is an unsigned value.    This can be done by referring to a part of X in place    or by copying to a new temporary with conversion.  */
end_comment

begin_function
name|rtx
name|convert_to_mode
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
return|return
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx for a value that would result    from converting X from mode OLDMODE to mode MODE.    Both modes may be floating, or both integer.    UNSIGNEDP is nonzero if X is an unsigned value.     This can be done by referring to a part of X in place    or by copying to a new temporary with conversion.     You can give VOIDmode for OLDMODE, if you are sure X has a nonvoid mode.  */
end_comment

begin_function
name|rtx
name|convert_modes
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|oldmode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* If FROM is a SUBREG that indicates that we have already done at least      the required extension, strip it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|x
argument_list|)
operator|==
name|unsignedp
condition|)
name|x
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|oldmode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|oldmode
condition|)
return|return
name|x
return|;
comment|/* There is one case that we must handle specially: If we are converting      a CONST_INT into a mode whose size is twice HOST_BITS_PER_WIDE_INT and      we are to interpret the constant as unsigned, gen_lowpart will do      the wrong if the constant appears negative.  What we want to do is      make the high-order word of the constant zero, not all ones.  */
if|if
condition|(
name|unsignedp
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldmode
operator|!=
name|VOIDmode
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|oldmode
argument_list|)
condition|)
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|oldmode
argument_list|)
decl_stmt|;
comment|/* We need to zero extend VAL.  */
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|val
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* We can do this with a gen_lowpart if both desired and current modes      are integer, and this is either a constant integer, a register, or a      non-volatile MEM.  Except for the constant case where MODE is no      wider than HOST_BITS_PER_WIDE_INT, we must be narrowing the operand.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|oldmode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|oldmode
argument_list|)
operator|&&
operator|(
operator|(
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
operator|!
name|HARD_REGISTER_P
argument_list|(
name|x
argument_list|)
operator|||
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* ?? If we don't know OLDMODE, we have to assume here that 	 X does not need sign- or zero-extension.   This may not be 	 the case, but it's the best we can do.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|oldmode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|oldmode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|oldmode
argument_list|)
decl_stmt|;
comment|/* We must sign or zero-extend in this case.  Start by 	     zero-extending, then sign extend if we need to.  */
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|unsignedp
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
expr_stmt|;
return|return
name|gen_int_mode
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
return|;
block|}
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
comment|/* Converting from integer constant into mode is always equivalent to an      subreg operation.  */
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|oldmode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|oldmode
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* STORE_MAX_PIECES is the number of bytes at a time that we can    store efficiently.  Due to internal GCC limitations, this is    MOVE_MAX_PIECES limited by the number of bytes GCC can represent    for an immediate constant.  */
end_comment

begin_define
define|#
directive|define
name|STORE_MAX_PIECES
value|MIN (MOVE_MAX_PIECES, 2 * sizeof (HOST_WIDE_INT))
end_define

begin_comment
comment|/* Determine whether the LEN bytes can be moved by using several move    instructions.  Return nonzero if a call to move_by_pieces should    succeed.  */
end_comment

begin_function
name|int
name|can_move_by_pieces
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|len
parameter_list|,
name|unsigned
name|int
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|MOVE_BY_PIECES_P
argument_list|(
name|len
argument_list|,
name|align
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate several move instructions to copy LEN bytes from block FROM to    block TO.  (These are MEM rtx's with BLKmode).     If PUSH_ROUNDING is defined and TO is NULL, emit_single_push_insn is    used to push FROM to the stack.     ALIGN is maximum stack alignment we can assume.     If ENDP is 0 return to, if ENDP is 1 return memory at the end ala    mempcpy, and if ENDP is 2 return memory the end minus one byte ala    stpcpy.  */
end_comment

begin_function
name|rtx
name|move_by_pieces
parameter_list|(
name|rtx
name|to
parameter_list|,
name|rtx
name|from
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|len
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|,
name|int
name|endp
parameter_list|)
block|{
name|struct
name|move_by_pieces
name|data
decl_stmt|;
name|rtx
name|to_addr
decl_stmt|,
name|from_addr
init|=
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|max_size
init|=
name|MOVE_MAX_PIECES
operator|+
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|to
condition|?
name|MEM_ALIGN
argument_list|(
name|to
argument_list|)
else|:
name|align
argument_list|,
name|MEM_ALIGN
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|from_addr
operator|=
name|from_addr
expr_stmt|;
if|if
condition|(
name|to
condition|)
block|{
name|to_addr
operator|=
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|.
name|reverse
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
block|}
else|else
block|{
name|to_addr
operator|=
name|NULL_RTX
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|NULL_RTX
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|data
operator|.
name|reverse
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|data
operator|.
name|reverse
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|data
operator|.
name|to_addr
operator|=
name|to_addr
expr_stmt|;
name|data
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
operator|(
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|reverse
condition|)
name|data
operator|.
name|offset
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
comment|/* If copying requires more than two move insns,      copy addresses to registers (to make displacements shorter)      and use post-increment if available.  */
if|if
condition|(
operator|!
operator|(
name|data
operator|.
name|autinc_from
operator|&&
name|data
operator|.
name|autinc_to
operator|)
operator|&&
name|move_by_pieces_ninsns
argument_list|(
name|len
argument_list|,
name|align
argument_list|,
name|max_size
argument_list|)
operator|>
literal|2
condition|)
block|{
comment|/* Find the mode of the largest move...  */
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|USE_LOAD_PRE_DECREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_from
condition|)
block|{
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|from_addr
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|USE_LOAD_POST_INCREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|data
operator|.
name|autinc_from
condition|)
block|{
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_from
operator|&&
name|CONSTANT_P
argument_list|(
name|from_addr
argument_list|)
condition|)
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|USE_STORE_PRE_DECREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|to_addr
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|USE_STORE_POST_INCREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_to
operator|&&
name|CONSTANT_P
argument_list|(
name|to_addr
argument_list|)
condition|)
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
block|}
name|tmode
operator|=
name|mode_for_size
argument_list|(
name|MOVE_MAX_PIECES
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|tmode
argument_list|)
condition|)
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
else|else
block|{
name|enum
name|machine_mode
name|xmode
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
operator|,
name|xmode
operator|=
name|tmode
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|xmode
operator|=
name|tmode
operator|,
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|>
name|MOVE_MAX_PIECES
operator|||
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|tmode
argument_list|,
name|align
argument_list|)
condition|)
break|break;
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|xmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* First move what we can in the largest integer mode, then go to      successively smaller modes.  */
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
condition|)
name|move_by_pieces_1
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|,
name|mode
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The code above should have handled everything.  */
name|gcc_assert
argument_list|(
operator|!
name|data
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
condition|)
block|{
name|rtx
name|to1
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|data
operator|.
name|reverse
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|autinc_to
condition|)
block|{
if|if
condition|(
name|endp
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|data
operator|.
name|explicit_inc_to
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|.
name|to_addr
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|data
operator|.
name|to_addr
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|to1
operator|=
name|adjust_automodify_address
argument_list|(
name|data
operator|.
name|to
argument_list|,
name|QImode
argument_list|,
name|data
operator|.
name|to_addr
argument_list|,
name|data
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|endp
operator|==
literal|2
condition|)
operator|--
name|data
operator|.
name|offset
expr_stmt|;
name|to1
operator|=
name|adjust_address
argument_list|(
name|data
operator|.
name|to
argument_list|,
name|QImode
argument_list|,
name|data
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|to1
return|;
block|}
else|else
return|return
name|data
operator|.
name|to
return|;
block|}
end_function

begin_comment
comment|/* Return number of insns required to move L bytes by pieces.    ALIGN (in bits) is maximum alignment we can assume.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|move_by_pieces_ninsns
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|l
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|,
name|unsigned
name|int
name|max_size
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|n_insns
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|tmode
operator|=
name|mode_for_size
argument_list|(
name|MOVE_MAX_PIECES
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|tmode
argument_list|)
condition|)
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
else|else
block|{
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|xmode
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
operator|,
name|xmode
operator|=
name|tmode
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|xmode
operator|=
name|tmode
operator|,
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|>
name|MOVE_MAX_PIECES
operator|||
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|tmode
argument_list|,
name|align
argument_list|)
condition|)
break|break;
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|xmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
condition|)
name|n_insns
operator|+=
name|l
operator|/
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|,
name|l
operator|%=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
operator|!
name|l
argument_list|)
expr_stmt|;
return|return
name|n_insns
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of move_by_pieces.  Move as many bytes as appropriate    with move instructions for mode MODE.  GENFUN is the gen_... function    to make a move insn for that mode.  DATA has all the other info.  */
end_comment

begin_function
specifier|static
name|void
name|move_by_pieces_1
parameter_list|(
name|rtx
function_decl|(
modifier|*
name|genfun
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
modifier|...
parameter_list|)
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|struct
name|move_by_pieces
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|to1
init|=
name|NULL_RTX
decl_stmt|,
name|from1
decl_stmt|;
while|while
condition|(
name|data
operator|->
name|len
operator|>=
name|size
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|to
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|autinc_to
condition|)
name|to1
operator|=
name|adjust_automodify_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|to_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|to1
operator|=
name|adjust_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|autinc_from
condition|)
name|from1
operator|=
name|adjust_automodify_address
argument_list|(
name|data
operator|->
name|from
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|from_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|from1
operator|=
name|adjust_address
argument_list|(
name|data
operator|->
name|from
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|data
operator|->
name|explicit_inc_from
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|to
condition|)
name|emit_insn
argument_list|(
call|(
modifier|*
name|genfun
call|)
argument_list|(
name|to1
argument_list|,
name|from1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|emit_single_push_insn
argument_list|(
name|mode
argument_list|,
name|from1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|data
operator|->
name|explicit_inc_from
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
name|data
operator|->
name|len
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to move a block Y to a block X.  This may be done with    string-move instructions, with multiple scalar move instructions,    or with a library call.     Both X and Y must be MEM rtx's (perhaps inside VOLATILE) with mode BLKmode.    SIZE is an rtx that says how long they are.    ALIGN is the maximum alignment we can assume they have.    METHOD describes what kind of copy this is, and what mechanisms may be used.     Return the address of the new block, if memcpy is called and returns it,    0 otherwise.  */
end_comment

begin_function
name|rtx
name|emit_block_move
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|rtx
name|size
parameter_list|,
name|enum
name|block_op_methods
name|method
parameter_list|)
block|{
name|bool
name|may_use_call
decl_stmt|;
name|rtx
name|retval
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|BLOCK_OP_NORMAL
case|:
case|case
name|BLOCK_OP_TAILCALL
case|:
name|may_use_call
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|BLOCK_OP_CALL_PARM
case|:
name|may_use_call
operator|=
name|block_move_libcall_safe_for_call_parm
argument_list|()
expr_stmt|;
comment|/* Make inhibit_defer_pop nonzero around the library call 	 to force it to pop the arguments right away.  */
name|NO_DEFER_POP
expr_stmt|;
break|break;
case|case
name|BLOCK_OP_NO_LIBCALL
case|:
name|may_use_call
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|align
operator|=
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Make sure we've got BLKmode addresses; store_one_arg can decide that      block copy is more efficient for other large modes, e.g. DCmode.  */
name|x
operator|=
name|adjust_address
argument_list|(
name|x
argument_list|,
name|BLKmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|adjust_address
argument_list|(
name|y
argument_list|,
name|BLKmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set MEM_SIZE as appropriate for this block copy.  The main place this      can be incorrect is coming from __builtin_memcpy.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|shallow_copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|shallow_copy_rtx
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|x
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|y
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|MOVE_BY_PIECES_P
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
condition|)
name|move_by_pieces
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|emit_block_move_via_movmem
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|may_use_call
condition|)
name|retval
operator|=
name|emit_block_move_via_libcall
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|method
operator|==
name|BLOCK_OP_TAILCALL
argument_list|)
expr_stmt|;
else|else
name|emit_block_move_via_loop
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|==
name|BLOCK_OP_CALL_PARM
condition|)
name|OK_DEFER_POP
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_block_move.  Returns true if calling the    block move libcall will not clobber any parameters which may have    already been placed on the stack.  */
end_comment

begin_function
specifier|static
name|bool
name|block_move_libcall_safe_for_call_parm
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If arguments are pushed on the stack, then they're safe.  */
if|if
condition|(
name|PUSH_ARGS
condition|)
return|return
name|true
return|;
comment|/* If registers go on the stack anyway, any argument is sure to clobber      an outgoing argument.  */
if|#
directive|if
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
operator|&&
name|defined
argument_list|(
name|OUTGOING_REG_PARM_STACK_SPACE
argument_list|)
block|{
name|tree
name|fn
init|=
name|emit_block_move_libcall_fn
argument_list|(
name|false
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|fn
expr_stmt|;
if|if
condition|(
name|REG_PARM_STACK_SPACE
argument_list|(
name|fn
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
endif|#
directive|endif
comment|/* If any argument goes in memory, then it might clobber an outgoing      argument.  */
block|{
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|arg
decl_stmt|;
name|fn
operator|=
name|emit_block_move_libcall_fn
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|arg
operator|!=
name|void_list_node
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tmp
init|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|||
operator|!
name|REG_P
argument_list|(
name|tmp
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|arg_partial_bytes
argument_list|(
operator|&
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|mode
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_block_move.  Expand a movmem pattern;    return true if successful.  */
end_comment

begin_function
specifier|static
name|bool
name|emit_block_move_via_movmem
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|rtx
name|size
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|rtx
name|opalign
init|=
name|GEN_INT
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
name|int
name|save_volatile_ok
init|=
name|volatile_ok
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Since this is a move insn, we don't care about volatility.  */
name|volatile_ok
operator|=
literal|1
expr_stmt|;
comment|/* Try the most limited insn first, because there's no point      including more than one in the machine description unless      the more limited one has some advantage.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|enum
name|insn_code
name|code
init|=
name|movmem_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
name|insn_operand_predicate_fn
name|pred
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
comment|/* We don't need MODE to be narrower than BITS_PER_HOST_WIDE_INT 	     here because if SIZE is less than the mode mask, as it is 	     returned by the macro, it will definitely be less than the 	     actual mode mask.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|)
operator|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|BITS_PER_WORD
operator|)
operator|&&
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|==
literal|0
operator|||
call|(
modifier|*
name|pred
call|)
argument_list|(
name|x
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|==
literal|0
operator|||
call|(
modifier|*
name|pred
call|)
argument_list|(
name|y
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|==
literal|0
operator|||
call|(
modifier|*
name|pred
call|)
argument_list|(
name|opalign
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|op2
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|op2
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
expr_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|pred
call|)
argument_list|(
name|op2
argument_list|,
name|mode
argument_list|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
comment|/* ??? When called via emit_block_move_for_call, it'd be 	     nice if there were some way to inform the backend, so 	     that it doesn't fail the expansion because it thinks 	     emitting the libcall would be more efficient.  */
name|pat
operator|=
name|GEN_FCN
argument_list|(
operator|(
name|int
operator|)
name|code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|op2
argument_list|,
name|opalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|volatile_ok
operator|=
name|save_volatile_ok
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
name|volatile_ok
operator|=
name|save_volatile_ok
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_block_move.  Expand a call to memcpy.    Return the return value from memcpy, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_block_move_via_libcall
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|size
parameter_list|,
name|bool
name|tailcall
parameter_list|)
block|{
name|rtx
name|dst_addr
decl_stmt|,
name|src_addr
decl_stmt|;
name|tree
name|call_expr
decl_stmt|,
name|arg_list
decl_stmt|,
name|fn
decl_stmt|,
name|src_tree
decl_stmt|,
name|dst_tree
decl_stmt|,
name|size_tree
decl_stmt|;
name|enum
name|machine_mode
name|size_mode
decl_stmt|;
name|rtx
name|retval
decl_stmt|;
comment|/* Emit code to copy the addresses of DST and SRC and SIZE into new      pseudos.  We can then place those new pseudos into a VAR_DECL and      use them later.  */
name|dst_addr
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dst_addr
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|dst_addr
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|dst_tree
operator|=
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|dst_addr
argument_list|)
expr_stmt|;
name|src_tree
operator|=
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|size_mode
operator|=
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|size
operator|=
name|convert_to_mode
argument_list|(
name|size_mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|size_mode
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* It is incorrect to use the libcall calling conventions to call      memcpy in this context.  This could be a user call to memcpy and      the user may wish to examine the return value from memcpy.  For      targets where libcalls and normal calls have different conventions      for returning pointers, we could end up generating incorrect code.  */
name|size_tree
operator|=
name|make_tree
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fn
operator|=
name|emit_block_move_libcall_fn
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|arg_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_tree
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|arg_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|src_tree
argument_list|,
name|arg_list
argument_list|)
expr_stmt|;
name|arg_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dst_tree
argument_list|,
name|arg_list
argument_list|)
expr_stmt|;
comment|/* Now we have to build up the CALL_EXPR itself.  */
name|call_expr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|call_expr
operator|=
name|build3
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|call_expr
argument_list|,
name|arg_list
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|CALL_EXPR_TAILCALL
argument_list|(
name|call_expr
argument_list|)
operator|=
name|tailcall
expr_stmt|;
name|retval
operator|=
name|expand_normal
argument_list|(
name|call_expr
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_block_move_via_libcall.  Create the tree node    for the function we use for block copies.  The first time FOR_CALL    is true, we call assemble_external.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|block_move_fn
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|init_block_move_fn
parameter_list|(
specifier|const
name|char
modifier|*
name|asmspec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|block_move_fn
condition|)
block|{
name|tree
name|args
decl_stmt|,
name|fn
decl_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"memcpy"
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_function_type_list
argument_list|(
name|ptr_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|const_ptr_type_node
argument_list|,
name|sizetype
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_VISIBILITY
argument_list|(
name|fn
argument_list|)
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|block_move_fn
operator|=
name|fn
expr_stmt|;
block|}
if|if
condition|(
name|asmspec
condition|)
name|set_user_assembler_name
argument_list|(
name|block_move_fn
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|emit_block_move_libcall_fn
parameter_list|(
name|int
name|for_call
parameter_list|)
block|{
specifier|static
name|bool
name|emitted_extern
decl_stmt|;
if|if
condition|(
operator|!
name|block_move_fn
condition|)
name|init_block_move_fn
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_call
operator|&&
operator|!
name|emitted_extern
condition|)
block|{
name|emitted_extern
operator|=
name|true
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|block_move_fn
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|block_move_fn
argument_list|)
expr_stmt|;
block|}
return|return
name|block_move_fn
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_block_move.  Copy the data via an explicit    loop.  This is used only when libcalls are forbidden.  */
end_comment

begin_comment
comment|/* ??? It'd be nice to copy in hunks larger than QImode.  */
end_comment

begin_function
specifier|static
name|void
name|emit_block_move_via_loop
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|rtx
name|size
parameter_list|,
name|unsigned
name|int
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|cmp_label
decl_stmt|,
name|top_label
decl_stmt|,
name|iter
decl_stmt|,
name|x_addr
decl_stmt|,
name|y_addr
decl_stmt|,
name|tmp
decl_stmt|;
name|enum
name|machine_mode
name|iter_mode
decl_stmt|;
name|iter_mode
operator|=
name|GET_MODE
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter_mode
operator|==
name|VOIDmode
condition|)
name|iter_mode
operator|=
name|word_mode
expr_stmt|;
name|top_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|cmp_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|iter
operator|=
name|gen_reg_rtx
argument_list|(
name|iter_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|iter
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|x_addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|y_addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|cmp_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|top_label
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|convert_modes
argument_list|(
name|Pmode
argument_list|,
name|iter_mode
argument_list|,
name|iter
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|x_addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|x_addr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|y_addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|y_addr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|QImode
argument_list|,
name|x_addr
argument_list|)
expr_stmt|;
name|y
operator|=
name|change_address
argument_list|(
name|y
argument_list|,
name|QImode
argument_list|,
name|y_addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|iter_mode
argument_list|,
name|PLUS
argument_list|,
name|iter
argument_list|,
name|const1_rtx
argument_list|,
name|iter
argument_list|,
name|true
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|iter
condition|)
name|emit_move_insn
argument_list|(
name|iter
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cmp_label
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|iter
argument_list|,
name|size
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|iter_mode
argument_list|,
name|true
argument_list|,
name|top_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy all or part of a value X into registers starting at REGNO.    The number of registers to be filled is NREGS.  */
end_comment

begin_function
name|void
name|move_block_to_reg
parameter_list|(
name|int
name|regno
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|nregs
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_load_multiple
name|rtx
name|pat
decl_stmt|;
name|rtx
name|last
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if the machine can do this with a load multiple insn.  */
ifdef|#
directive|ifdef
name|HAVE_load_multiple
if|if
condition|(
name|HAVE_load_multiple
condition|)
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pat
operator|=
name|gen_load_multiple
argument_list|(
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|nregs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|operand_subword_force
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy all or part of a BLKmode value X out of registers starting at REGNO.    The number of registers to be filled is NREGS.  */
end_comment

begin_function
name|void
name|move_block_from_reg
parameter_list|(
name|int
name|regno
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|nregs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
return|return;
comment|/* See if the machine can do this with a store multiple insn.  */
ifdef|#
directive|ifdef
name|HAVE_store_multiple
if|if
condition|(
name|HAVE_store_multiple
condition|)
block|{
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
init|=
name|gen_store_multiple
argument_list|(
name|x
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|nregs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|BLKmode
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a PARALLEL rtx for a new non-consecutive group of registers from    ORIG, where ORIG is a non-consecutive group of registers represented by    a PARALLEL.  The clone is identical to the original except in that the    original set of registers is replaced by a new set of pseudo registers.    The new set has the same modes as the original set.  */
end_comment

begin_function
name|rtx
name|gen_group_rtx
parameter_list|(
name|rtx
name|orig
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
name|rtx
modifier|*
name|tmps
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|PARALLEL
argument_list|)
expr_stmt|;
name|length
operator|=
name|XVECLEN
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|length
argument_list|)
expr_stmt|;
comment|/* Skip a NULL entry in first slot.  */
name|i
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|tmps
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|offset
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tmps
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|gen_rtvec_v
argument_list|(
name|length
argument_list|,
name|tmps
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_group_load.  Arguments as for emit_group_load,    except that values are placed in TMPS[i], and must later be moved    into corresponding XEXP (XVECEXP (DST, 0, i), 0) element.  */
end_comment

begin_function
specifier|static
name|void
name|emit_group_load_1
parameter_list|(
name|rtx
modifier|*
name|tmps
parameter_list|,
name|rtx
name|dst
parameter_list|,
name|rtx
name|orig_src
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|ssize
parameter_list|)
block|{
name|rtx
name|src
decl_stmt|;
name|int
name|start
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|machine_mode
name|m
init|=
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|PARALLEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|VOIDmode
operator|&&
operator|!
name|SCALAR_INT_MODE_P
argument_list|(
name|m
argument_list|)
operator|&&
operator|!
name|MEM_P
argument_list|(
name|orig_src
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|orig_src
argument_list|)
operator|!=
name|CONCAT
condition|)
block|{
name|enum
name|machine_mode
name|imode
init|=
name|int_mode_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|imode
operator|==
name|BLKmode
condition|)
name|src
operator|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
argument_list|,
name|ssize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|src
operator|=
name|gen_reg_rtx
argument_list|(
name|imode
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|!=
name|BLKmode
condition|)
name|src
operator|=
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|src
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
comment|/* ...and back again.  */
if|if
condition|(
name|imode
operator|!=
name|BLKmode
condition|)
name|src
operator|=
name|gen_lowpart
argument_list|(
name|imode
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|emit_group_load_1
argument_list|(
name|tmps
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|type
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for a NULL entry, used to indicate that the parameter goes      both on the stack and in registers.  */
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
name|start
operator|=
literal|1
expr_stmt|;
comment|/* Process the pieces.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bytepos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bytelen
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
comment|/* Handle trailing fragments that run over the size of the struct.  */
if|if
condition|(
name|ssize
operator|>=
literal|0
operator|&&
name|bytepos
operator|+
operator|(
name|HOST_WIDE_INT
operator|)
name|bytelen
operator|>
name|ssize
condition|)
block|{
comment|/* Arrange to shift the fragment to where it belongs. 	     extract_bit_field loads to the lsb of the reg.  */
if|if
condition|(
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
name|BLOCK_REG_PADDING
argument_list|(
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
argument_list|,
name|type
argument_list|,
name|i
operator|==
name|start
argument_list|)
operator|==
operator|(
name|BYTES_BIG_ENDIAN
condition|?
name|upward
else|:
name|downward
operator|)
else|#
directive|else
name|BYTES_BIG_ENDIAN
endif|#
directive|endif
condition|)
name|shift
operator|=
operator|(
name|bytelen
operator|-
operator|(
name|ssize
operator|-
name|bytepos
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|bytelen
operator|=
name|ssize
operator|-
name|bytepos
expr_stmt|;
name|gcc_assert
argument_list|(
name|bytelen
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we won't be loading directly from memory, protect the real source 	 from strange tricks we might play; but make sure that the source can 	 be loaded directly into the destination.  */
name|src
operator|=
name|orig_src
expr_stmt|;
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|orig_src
argument_list|)
operator|&&
operator|(
operator|!
name|CONSTANT_P
argument_list|(
name|orig_src
argument_list|)
operator|||
operator|(
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
operator|!=
name|VOIDmode
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
operator|==
name|VOIDmode
condition|)
name|src
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|src
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|src
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
block|}
comment|/* Optimize the access just a bit.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|src
argument_list|)
operator|&&
operator|(
operator|!
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|mode
argument_list|,
name|MEM_ALIGN
argument_list|(
name|src
argument_list|)
argument_list|)
operator|||
name|MEM_ALIGN
argument_list|(
name|src
argument_list|)
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|&&
name|bytepos
operator|*
name|BITS_PER_UNIT
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|==
literal|0
operator|&&
name|bytelen
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|,
name|adjust_address
argument_list|(
name|src
argument_list|,
name|mode
argument_list|,
name|bytepos
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|COMPLEX_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|mode
operator|&&
name|bytelen
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
comment|/* Let emit_move_complex do the bulk of the work.  */
name|tmps
index|[
name|i
index|]
operator|=
name|src
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|unsigned
name|int
name|slen
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|slen0
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|bytepos
operator|==
literal|0
operator|&&
name|bytelen
operator|==
name|slen0
operator|)
operator|||
operator|(
name|bytepos
operator|!=
literal|0
operator|&&
name|bytepos
operator|+
name|bytelen
operator|<=
name|slen
operator|)
condition|)
block|{
comment|/* The following assumes that the concatenated objects all 		 have the same size.  In this case, a simple calculation 		 can be used to determine the object and the bit field 		 to be extracted.  */
name|tmps
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
name|bytepos
operator|/
name|slen0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|)
operator|!=
name|mode
operator|)
condition|)
name|tmps
index|[
name|i
index|]
operator|=
name|extract_bit_field
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|,
name|bytelen
operator|*
name|BITS_PER_UNIT
argument_list|,
operator|(
name|bytepos
operator|%
name|slen0
operator|)
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|mem
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|bytepos
argument_list|)
expr_stmt|;
name|mem
operator|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|slen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|tmps
index|[
name|i
index|]
operator|=
name|extract_bit_field
argument_list|(
name|mem
argument_list|,
name|bytelen
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* FIXME: A SIMD parallel will eventually lead to a subreg of a 	 SIMD register, which is currently broken.  While we get GCC 	 to emit proper RTL for these cases, let's dump to memory.  */
elseif|else
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|int
name|slen
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|mem
operator|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|slen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|tmps
index|[
name|i
index|]
operator|=
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
operator|(
name|int
operator|)
name|bytepos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
operator|>
literal|1
condition|)
name|tmps
index|[
name|i
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|bytepos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|||
operator|(
name|REG_P
argument_list|(
name|src
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|mode
operator|)
condition|)
name|tmps
index|[
name|i
index|]
operator|=
name|src
expr_stmt|;
else|else
name|tmps
index|[
name|i
index|]
operator|=
name|extract_bit_field
argument_list|(
name|src
argument_list|,
name|bytelen
operator|*
name|BITS_PER_UNIT
argument_list|,
name|bytepos
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
condition|)
name|tmps
index|[
name|i
index|]
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|shift
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to move a block SRC of type TYPE to a block DST,    where DST is non-consecutive registers represented by a PARALLEL.    SSIZE represents the total size of block ORIG_SRC in bytes, or -1    if not known.  */
end_comment

begin_function
name|void
name|emit_group_load
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|ssize
parameter_list|)
block|{
name|rtx
modifier|*
name|tmps
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tmps
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_group_load_1
argument_list|(
name|tmps
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|type
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
comment|/* Copy the extracted pieces into the proper (probable) hard regs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|d
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
continue|continue;
name|emit_move_insn
argument_list|(
name|d
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar, but load SRC into new pseudos in a format that looks like    PARALLEL.  This can later be fed to emit_group_move to get things    in the right place.  */
end_comment

begin_function
name|rtx
name|emit_group_load_into_temps
parameter_list|(
name|rtx
name|parallel
parameter_list|,
name|rtx
name|src
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|ssize
parameter_list|)
block|{
name|rtvec
name|vec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vec
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|parallel
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_group_load_1
argument_list|(
operator|&
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|parallel
argument_list|,
name|src
argument_list|,
name|type
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
comment|/* Convert the vector to look just like the original PARALLEL, except      with the computed values.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|parallel
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|e
init|=
name|XVECEXP
argument_list|(
name|parallel
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|d
init|=
name|XEXP
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|d
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|d
argument_list|)
argument_list|,
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|e
argument_list|)
argument_list|,
name|d
argument_list|,
name|XEXP
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|e
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|GET_MODE
argument_list|(
name|parallel
argument_list|)
argument_list|,
name|vec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit code to move a block SRC to block DST, where SRC and DST are    non-consecutive groups of registers, each represented by a PARALLEL.  */
end_comment

begin_function
name|void
name|emit_group_move
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip first entry if NULL.  */
for|for
control|(
name|i
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|?
literal|0
else|:
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move a group of registers represented by a PARALLEL into pseudos.  */
end_comment

begin_function
name|rtx
name|emit_group_move_into_temps
parameter_list|(
name|rtx
name|src
parameter_list|)
block|{
name|rtvec
name|vec
init|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|e
init|=
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|d
init|=
name|XEXP
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
condition|)
name|e
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|e
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|d
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|e
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|vec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit code to move a block SRC to a block ORIG_DST of type TYPE,    where SRC is non-consecutive registers represented by a PARALLEL.    SSIZE represents the total size of block ORIG_DST, or -1 if not    known.  */
end_comment

begin_function
name|void
name|emit_group_store
parameter_list|(
name|rtx
name|orig_dst
parameter_list|,
name|rtx
name|src
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ssize
parameter_list|)
block|{
name|rtx
modifier|*
name|tmps
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|start
decl_stmt|,
name|finish
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|machine_mode
name|m
init|=
name|GET_MODE
argument_list|(
name|orig_dst
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PARALLEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SCALAR_INT_MODE_P
argument_list|(
name|m
argument_list|)
operator|&&
operator|!
name|MEM_P
argument_list|(
name|orig_dst
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|orig_dst
argument_list|)
operator|!=
name|CONCAT
condition|)
block|{
name|enum
name|machine_mode
name|imode
init|=
name|int_mode_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|orig_dst
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|imode
operator|==
name|BLKmode
condition|)
name|dst
operator|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|orig_dst
argument_list|)
argument_list|,
name|ssize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|imode
argument_list|)
expr_stmt|;
name|emit_group_store
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|type
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|!=
name|BLKmode
condition|)
name|dst
operator|=
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|orig_dst
argument_list|)
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|orig_dst
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for a NULL entry, used to indicate that the parameter goes      both on the stack and in registers.  */
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
name|start
operator|=
literal|1
expr_stmt|;
name|finish
operator|=
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|finish
argument_list|)
expr_stmt|;
comment|/* Copy the (probable) hard regs into pseudos.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|finish
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
operator|||
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|tmps
index|[
name|i
index|]
operator|=
name|reg
expr_stmt|;
block|}
comment|/* If we won't be storing directly into memory, protect the real destination      from strange tricks we might play.  */
name|dst
operator|=
name|orig_dst
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* We can get a PARALLEL dst if there is a conditional expression in 	 a return statement.  In that case, the dst and src are the same, 	 so no action is necessary.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
condition|)
return|return;
comment|/* It is unclear if we can ever reach here, but we may as well handle 	 it.  Allocate a temporary, and split this into a store/load to/from 	 the temporary.  */
name|temp
operator|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|ssize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_group_store
argument_list|(
name|temp
argument_list|,
name|src
argument_list|,
name|type
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
name|emit_group_load
argument_list|(
name|dst
argument_list|,
name|temp
argument_list|,
name|type
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|dst
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|CONCAT
condition|)
block|{
name|enum
name|machine_mode
name|outer
init|=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner
decl_stmt|;
name|HOST_WIDE_INT
name|bytepos
decl_stmt|;
name|bool
name|done
init|=
name|false
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|dst
argument_list|)
operator|||
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|outer
argument_list|)
expr_stmt|;
comment|/* Make life a bit easier for combine.  */
comment|/* If the first element of the vector is the low part 	 of the destination mode, use a paradoxical subreg to 	 initialize the destination.  */
if|if
condition|(
name|start
operator|<
name|finish
condition|)
block|{
name|inner
operator|=
name|GET_MODE
argument_list|(
name|tmps
index|[
name|start
index|]
argument_list|)
expr_stmt|;
name|bytepos
operator|=
name|subreg_lowpart_offset
argument_list|(
name|inner
argument_list|,
name|outer
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|start
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|bytepos
condition|)
block|{
name|temp
operator|=
name|simplify_gen_subreg
argument_list|(
name|outer
argument_list|,
name|tmps
index|[
name|start
index|]
argument_list|,
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|emit_move_insn
argument_list|(
name|dst
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* If the first element wasn't the low part, try the last.  */
if|if
condition|(
operator|!
name|done
operator|&&
name|start
operator|<
name|finish
operator|-
literal|1
condition|)
block|{
name|inner
operator|=
name|GET_MODE
argument_list|(
name|tmps
index|[
name|finish
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|bytepos
operator|=
name|subreg_lowpart_offset
argument_list|(
name|inner
argument_list|,
name|outer
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|finish
operator|-
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|bytepos
condition|)
block|{
name|temp
operator|=
name|simplify_gen_subreg
argument_list|(
name|outer
argument_list|,
name|tmps
index|[
name|finish
operator|-
literal|1
index|]
argument_list|,
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|emit_move_insn
argument_list|(
name|dst
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
name|finish
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* Otherwise, simply initialize the result to zero.  */
if|if
condition|(
operator|!
name|done
condition|)
name|emit_move_insn
argument_list|(
name|dst
argument_list|,
name|CONST0_RTX
argument_list|(
name|outer
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Process the pieces.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|finish
condition|;
name|i
operator|++
control|)
block|{
name|HOST_WIDE_INT
name|bytepos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bytelen
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|dst
decl_stmt|;
comment|/* Handle trailing fragments that run over the size of the struct.  */
if|if
condition|(
name|ssize
operator|>=
literal|0
operator|&&
name|bytepos
operator|+
operator|(
name|HOST_WIDE_INT
operator|)
name|bytelen
operator|>
name|ssize
condition|)
block|{
comment|/* store_bit_field always takes its value from the lsb. 	     Move the fragment to the lsb if it's not already there.  */
if|if
condition|(
ifdef|#
directive|ifdef
name|BLOCK_REG_PADDING
name|BLOCK_REG_PADDING
argument_list|(
name|GET_MODE
argument_list|(
name|orig_dst
argument_list|)
argument_list|,
name|type
argument_list|,
name|i
operator|==
name|start
argument_list|)
operator|==
operator|(
name|BYTES_BIG_ENDIAN
condition|?
name|upward
else|:
name|downward
operator|)
else|#
directive|else
name|BYTES_BIG_ENDIAN
endif|#
directive|endif
condition|)
block|{
name|int
name|shift
init|=
operator|(
name|bytelen
operator|-
operator|(
name|ssize
operator|-
name|bytepos
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|tmps
index|[
name|i
index|]
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|shift
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bytelen
operator|=
name|ssize
operator|-
name|bytepos
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
if|if
condition|(
name|bytepos
operator|+
name|bytelen
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bytepos
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|bytepos
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|bytepos
operator|==
literal|0
operator|&&
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|)
argument_list|,
name|bytepos
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dst
operator|=
name|dest
expr_stmt|;
break|break;
block|}
block|}
comment|/* Optimize the access just a bit.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|dest
argument_list|)
operator|&&
operator|(
operator|!
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|mode
argument_list|,
name|MEM_ALIGN
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|||
name|MEM_ALIGN
argument_list|(
name|dest
argument_list|)
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|&&
name|bytepos
operator|*
name|BITS_PER_UNIT
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|==
literal|0
operator|&&
name|bytelen
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|,
name|bytepos
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|store_bit_field
argument_list|(
name|dest
argument_list|,
name|bytelen
operator|*
name|BITS_PER_UNIT
argument_list|,
name|bytepos
operator|*
name|BITS_PER_UNIT
argument_list|,
name|mode
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Copy from the pseudo into the (probable) hard reg.  */
if|if
condition|(
name|orig_dst
operator|!=
name|dst
condition|)
name|emit_move_insn
argument_list|(
name|orig_dst
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to copy a BLKmode object of TYPE out of a    set of registers starting with SRCREG into TGTBLK.  If TGTBLK    is null, a stack temporary is created.  TGTBLK is returned.     The purpose of this routine is to handle functions that return    BLKmode structures in registers.  Some machines (the PA for example)    want to return all small structures in registers regardless of the    structure's alignment.  */
end_comment

begin_function
name|rtx
name|copy_blkmode_from_reg
parameter_list|(
name|rtx
name|tgtblk
parameter_list|,
name|rtx
name|srcreg
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|NULL
decl_stmt|,
name|dst
init|=
name|NULL
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bitsize
init|=
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|,
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bitpos
decl_stmt|,
name|xbitpos
decl_stmt|,
name|padding_correction
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tgtblk
operator|==
literal|0
condition|)
block|{
name|tgtblk
operator|=
name|assign_temp
argument_list|(
name|build_qualified_type
argument_list|(
name|type
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|tgtblk
argument_list|)
expr_stmt|;
block|}
comment|/* This code assumes srcreg is at least a full word.  If it isn't, copy it      into a new pseudo which is a full word.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|srcreg
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|srcreg
argument_list|)
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
name|srcreg
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|srcreg
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the structure doesn't take up a whole number of words, see whether      SRCREG is padded on the left or on the right.  If it's on the left,      set PADDING_CORRECTION to the number of bits to skip.       In most ABIs, the structure will be returned at the least end of      the register, which translates to right padding on little-endian      targets and left padding on big-endian targets.  The opposite      holds if the structure is returned at the most significant      end of the register.  */
if|if
condition|(
name|bytes
operator|%
name|UNITS_PER_WORD
operator|!=
literal|0
operator|&&
operator|(
name|targetm
operator|.
name|calls
operator|.
name|return_in_msb
argument_list|(
name|type
argument_list|)
condition|?
operator|!
name|BYTES_BIG_ENDIAN
else|:
name|BYTES_BIG_ENDIAN
operator|)
condition|)
name|padding_correction
operator|=
operator|(
name|BITS_PER_WORD
operator|-
operator|(
operator|(
name|bytes
operator|%
name|UNITS_PER_WORD
operator|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* Copy the structure BITSIZE bites at a time.       We could probably emit more efficient code for machines which do not use      strict alignment, but it doesn't seem worth the effort at the current      time.  */
for|for
control|(
name|bitpos
operator|=
literal|0
operator|,
name|xbitpos
operator|=
name|padding_correction
init|;
name|bitpos
operator|<
name|bytes
operator|*
name|BITS_PER_UNIT
condition|;
name|bitpos
operator|+=
name|bitsize
operator|,
name|xbitpos
operator|+=
name|bitsize
control|)
block|{
comment|/* We need a new source operand each time xbitpos is on a 	 word boundary and when xbitpos == padding_correction 	 (the first time through).  */
if|if
condition|(
name|xbitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|||
name|xbitpos
operator|==
name|padding_correction
condition|)
name|src
operator|=
name|operand_subword_force
argument_list|(
name|srcreg
argument_list|,
name|xbitpos
operator|/
name|BITS_PER_WORD
argument_list|,
name|GET_MODE
argument_list|(
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need a new destination operand each time bitpos is on 	 a word boundary.  */
if|if
condition|(
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
condition|)
name|dst
operator|=
name|operand_subword
argument_list|(
name|tgtblk
argument_list|,
name|bitpos
operator|/
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
comment|/* Use xbitpos for the source extraction (right justified) and 	 xbitpos for the destination store (left justified).  */
name|store_bit_field
argument_list|(
name|dst
argument_list|,
name|bitsize
argument_list|,
name|bitpos
operator|%
name|BITS_PER_WORD
argument_list|,
name|word_mode
argument_list|,
name|extract_bit_field
argument_list|(
name|src
argument_list|,
name|bitsize
argument_list|,
name|xbitpos
operator|%
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|tgtblk
return|;
block|}
end_function

begin_comment
comment|/* Add a USE expression for REG to the (possibly empty) list pointed    to by CALL_FUSAGE.  REG must denote a hard register.  */
end_comment

begin_function
name|void
name|use_reg
parameter_list|(
name|rtx
modifier|*
name|call_fusage
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|reg
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
operator|*
name|call_fusage
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|,
operator|*
name|call_fusage
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add USE expressions to *CALL_FUSAGE for each of NREGS consecutive regs,    starting at REGNO.  All of these registers must be hard registers.  */
end_comment

begin_function
name|void
name|use_regs
parameter_list|(
name|rtx
modifier|*
name|call_fusage
parameter_list|,
name|int
name|regno
parameter_list|,
name|int
name|nregs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|regno
operator|+
name|nregs
operator|<=
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|regno_reg_rtx
index|[
name|regno
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add USE expressions to *CALL_FUSAGE for each REG contained in the    PARALLEL REGS.  This is for calls that pass values in multiple    non-contiguous locations.  The Irix 6 ABI has examples of this.  */
end_comment

begin_function
name|void
name|use_group_regs
parameter_list|(
name|rtx
modifier|*
name|call_fusage
parameter_list|,
name|rtx
name|regs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* A NULL entry means the parameter goes both on the stack and in 	 registers.  This can also be a MEM for targets that pass values 	 partially on the stack and partially in registers.  */
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine whether the LEN bytes generated by CONSTFUN can be    stored to memory using several move instructions.  CONSTFUNDATA is    a pointer which will be passed as argument in every CONSTFUN call.    ALIGN is maximum alignment we can assume.  Return nonzero if a    call to store_by_pieces should succeed.  */
end_comment

begin_function
name|int
name|can_store_by_pieces
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|len
parameter_list|,
name|rtx
function_decl|(
modifier|*
name|constfun
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
parameter_list|,
name|void
modifier|*
name|constfundata
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|unsigned
name|int
name|max_size
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|rtx
name|cst
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|STORE_BY_PIECES_P
argument_list|(
name|len
argument_list|,
name|align
argument_list|)
condition|)
return|return
literal|0
return|;
name|tmode
operator|=
name|mode_for_size
argument_list|(
name|STORE_MAX_PIECES
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|tmode
argument_list|)
condition|)
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
else|else
block|{
name|enum
name|machine_mode
name|xmode
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
operator|,
name|xmode
operator|=
name|tmode
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|xmode
operator|=
name|tmode
operator|,
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|>
name|STORE_MAX_PIECES
operator|||
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|tmode
argument_list|,
name|align
argument_list|)
condition|)
break|break;
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|xmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We would first store what we can in the largest integer mode, then go to      successively smaller modes.  */
for|for
control|(
name|reverse
operator|=
literal|0
init|;
name|reverse
operator|<=
operator|(
name|HAVE_PRE_DECREMENT
operator|||
name|HAVE_POST_DECREMENT
operator|)
condition|;
name|reverse
operator|++
control|)
block|{
name|l
operator|=
name|len
expr_stmt|;
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|max_size
operator|=
name|STORE_MAX_PIECES
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
while|while
condition|(
name|l
operator|>=
name|size
condition|)
block|{
if|if
condition|(
name|reverse
condition|)
name|offset
operator|-=
name|size
expr_stmt|;
name|cst
operator|=
call|(
modifier|*
name|constfun
call|)
argument_list|(
name|constfundata
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|cst
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|reverse
condition|)
name|offset
operator|+=
name|size
expr_stmt|;
name|l
operator|-=
name|size
expr_stmt|;
block|}
block|}
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The code above should have handled everything.  */
name|gcc_assert
argument_list|(
operator|!
name|l
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate several move instructions to store LEN bytes generated by    CONSTFUN to block TO.  (A MEM rtx with BLKmode).  CONSTFUNDATA is a    pointer which will be passed as argument in every CONSTFUN call.    ALIGN is maximum alignment we can assume.    If ENDP is 0 return to, if ENDP is 1 return memory at the end ala    mempcpy, and if ENDP is 2 return memory the end minus one byte ala    stpcpy.  */
end_comment

begin_function
name|rtx
name|store_by_pieces
parameter_list|(
name|rtx
name|to
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|len
parameter_list|,
name|rtx
function_decl|(
modifier|*
name|constfun
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
parameter_list|,
name|void
modifier|*
name|constfundata
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|,
name|int
name|endp
parameter_list|)
block|{
name|struct
name|store_by_pieces
name|data
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
name|endp
operator|!=
literal|2
argument_list|)
expr_stmt|;
return|return
name|to
return|;
block|}
name|gcc_assert
argument_list|(
name|STORE_BY_PIECES_P
argument_list|(
name|len
argument_list|,
name|align
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|constfun
operator|=
name|constfun
expr_stmt|;
name|data
operator|.
name|constfundata
operator|=
name|constfundata
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|store_by_pieces_1
argument_list|(
operator|&
name|data
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
condition|)
block|{
name|rtx
name|to1
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|data
operator|.
name|reverse
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|autinc_to
condition|)
block|{
if|if
condition|(
name|endp
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|data
operator|.
name|explicit_inc_to
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|.
name|to_addr
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|data
operator|.
name|to_addr
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|to1
operator|=
name|adjust_automodify_address
argument_list|(
name|data
operator|.
name|to
argument_list|,
name|QImode
argument_list|,
name|data
operator|.
name|to_addr
argument_list|,
name|data
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|endp
operator|==
literal|2
condition|)
operator|--
name|data
operator|.
name|offset
expr_stmt|;
name|to1
operator|=
name|adjust_address
argument_list|(
name|data
operator|.
name|to
argument_list|,
name|QImode
argument_list|,
name|data
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|to1
return|;
block|}
else|else
return|return
name|data
operator|.
name|to
return|;
block|}
end_function

begin_comment
comment|/* Generate several move instructions to clear LEN bytes of block TO.  (A MEM    rtx with BLKmode).  ALIGN is maximum alignment we can assume.  */
end_comment

begin_function
specifier|static
name|void
name|clear_by_pieces
parameter_list|(
name|rtx
name|to
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|len
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|struct
name|store_by_pieces
name|data
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
name|data
operator|.
name|constfun
operator|=
name|clear_by_pieces_1
expr_stmt|;
name|data
operator|.
name|constfundata
operator|=
name|NULL
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|store_by_pieces_1
argument_list|(
operator|&
name|data
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback routine for clear_by_pieces.    Return const0_rtx unconditionally.  */
end_comment

begin_function
specifier|static
name|rtx
name|clear_by_pieces_1
parameter_list|(
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of clear_by_pieces and store_by_pieces.    Generate several move instructions to store LEN bytes of block TO.  (A MEM    rtx with BLKmode).  ALIGN is maximum alignment we can assume.  */
end_comment

begin_function
specifier|static
name|void
name|store_by_pieces_1
parameter_list|(
name|struct
name|store_by_pieces
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|to_addr
init|=
name|XEXP
argument_list|(
name|data
operator|->
name|to
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|max_size
init|=
name|STORE_MAX_PIECES
operator|+
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|data
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|to_addr
operator|=
name|to_addr
expr_stmt|;
name|data
operator|->
name|autinc_to
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|->
name|explicit_inc_to
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|reverse
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|=
name|data
operator|->
name|len
expr_stmt|;
comment|/* If storing requires more than two move insns,      copy addresses to registers (to make displacements shorter)      and use post-increment if available.  */
if|if
condition|(
operator|!
name|data
operator|->
name|autinc_to
operator|&&
name|move_by_pieces_ninsns
argument_list|(
name|data
operator|->
name|len
argument_list|,
name|align
argument_list|,
name|max_size
argument_list|)
operator|>
literal|2
condition|)
block|{
comment|/* Determine the main mode we'll be using.  */
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|USE_STORE_PRE_DECREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|data
operator|->
name|reverse
operator|&&
operator|!
name|data
operator|->
name|autinc_to
condition|)
block|{
name|data
operator|->
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|to_addr
argument_list|,
name|data
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|->
name|explicit_inc_to
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|USE_STORE_POST_INCREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|data
operator|->
name|reverse
operator|&&
operator|!
name|data
operator|->
name|autinc_to
condition|)
block|{
name|data
operator|->
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
name|data
operator|->
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|->
name|explicit_inc_to
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
operator|->
name|autinc_to
operator|&&
name|CONSTANT_P
argument_list|(
name|to_addr
argument_list|)
condition|)
name|data
operator|->
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
block|}
name|tmode
operator|=
name|mode_for_size
argument_list|(
name|STORE_MAX_PIECES
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|tmode
argument_list|)
condition|)
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
else|else
block|{
name|enum
name|machine_mode
name|xmode
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
operator|,
name|xmode
operator|=
name|tmode
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|xmode
operator|=
name|tmode
operator|,
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|>
name|STORE_MAX_PIECES
operator|||
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|tmode
argument_list|,
name|align
argument_list|)
condition|)
break|break;
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|xmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* First store what we can in the largest integer mode, then go to      successively smaller modes.  */
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
condition|)
name|store_by_pieces_2
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|,
name|mode
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The code above should have handled everything.  */
name|gcc_assert
argument_list|(
operator|!
name|data
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of store_by_pieces_1.  Store as many bytes as appropriate    with move instructions for mode MODE.  GENFUN is the gen_... function    to make a move insn for that mode.  DATA has all the other info.  */
end_comment

begin_function
specifier|static
name|void
name|store_by_pieces_2
parameter_list|(
name|rtx
function_decl|(
modifier|*
name|genfun
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
modifier|...
parameter_list|)
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|struct
name|store_by_pieces
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|to1
decl_stmt|,
name|cst
decl_stmt|;
while|while
condition|(
name|data
operator|->
name|len
operator|>=
name|size
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|autinc_to
condition|)
name|to1
operator|=
name|adjust_automodify_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|to_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|to1
operator|=
name|adjust_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cst
operator|=
call|(
modifier|*
name|data
operator|->
name|constfun
call|)
argument_list|(
name|data
operator|->
name|constfundata
argument_list|,
name|data
operator|->
name|offset
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|genfun
call|)
argument_list|(
name|to1
argument_list|,
name|cst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
name|data
operator|->
name|len
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write zeros through the storage of OBJECT.  If OBJECT has BLKmode, SIZE is    its length in bytes.  */
end_comment

begin_function
name|rtx
name|clear_storage
parameter_list|(
name|rtx
name|object
parameter_list|,
name|rtx
name|size
parameter_list|,
name|enum
name|block_op_methods
name|method
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
name|gcc_assert
argument_list|(
name|method
operator|==
name|BLOCK_OP_NORMAL
operator|||
name|method
operator|==
name|BLOCK_OP_TAILCALL
argument_list|)
expr_stmt|;
comment|/* If OBJECT is not BLKmode and SIZE is the same size as its mode,      just move a zero.  Otherwise, do this a piece at a time.  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|zero
init|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|zero
operator|!=
name|NULL
condition|)
block|{
name|emit_move_insn
argument_list|(
name|object
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|COMPLEX_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|zero
operator|=
name|CONST0_RTX
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero
operator|!=
name|NULL
condition|)
block|{
name|write_complex_part
argument_list|(
name|object
argument_list|,
name|zero
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_complex_part
argument_list|(
name|object
argument_list|,
name|zero
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
if|if
condition|(
name|size
operator|==
name|const0_rtx
condition|)
return|return
name|NULL
return|;
name|align
operator|=
name|MEM_ALIGN
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CLEAR_BY_PIECES_P
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
condition|)
name|clear_by_pieces
argument_list|(
name|object
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|set_storage_via_setmem
argument_list|(
name|object
argument_list|,
name|size
argument_list|,
name|const0_rtx
argument_list|,
name|align
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
name|clear_storage_via_libcall
argument_list|(
name|object
argument_list|,
name|size
argument_list|,
name|method
operator|==
name|BLOCK_OP_TAILCALL
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of clear_storage.  Expand a call to memset.    Return the return value of memset, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|rtx
name|clear_storage_via_libcall
parameter_list|(
name|rtx
name|object
parameter_list|,
name|rtx
name|size
parameter_list|,
name|bool
name|tailcall
parameter_list|)
block|{
name|tree
name|call_expr
decl_stmt|,
name|arg_list
decl_stmt|,
name|fn
decl_stmt|,
name|object_tree
decl_stmt|,
name|size_tree
decl_stmt|;
name|enum
name|machine_mode
name|size_mode
decl_stmt|;
name|rtx
name|retval
decl_stmt|;
comment|/* Emit code to copy OBJECT and SIZE into new pseudos.  We can then      place those into new pseudos into a VAR_DECL and use them later.  */
name|object
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|size_mode
operator|=
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|size
operator|=
name|convert_to_mode
argument_list|(
name|size_mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|size_mode
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* It is incorrect to use the libcall calling conventions to call      memset in this context.  This could be a user call to memset and      the user may wish to examine the return value from memset.  For      targets where libcalls and normal calls have different conventions      for returning pointers, we could end up generating incorrect code.  */
name|object_tree
operator|=
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|size_tree
operator|=
name|make_tree
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fn
operator|=
name|clear_storage_libcall_fn
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|arg_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_tree
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|arg_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|arg_list
argument_list|)
expr_stmt|;
name|arg_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|object_tree
argument_list|,
name|arg_list
argument_list|)
expr_stmt|;
comment|/* Now we have to build up the CALL_EXPR itself.  */
name|call_expr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|call_expr
operator|=
name|build3
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|call_expr
argument_list|,
name|arg_list
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|CALL_EXPR_TAILCALL
argument_list|(
name|call_expr
argument_list|)
operator|=
name|tailcall
expr_stmt|;
name|retval
operator|=
name|expand_normal
argument_list|(
name|call_expr
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of clear_storage_via_libcall.  Create the tree node    for the function we use for block clears.  The first time FOR_CALL    is true, we call assemble_external.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|block_clear_fn
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|init_block_clear_fn
parameter_list|(
specifier|const
name|char
modifier|*
name|asmspec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|block_clear_fn
condition|)
block|{
name|tree
name|fn
decl_stmt|,
name|args
decl_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"memset"
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_function_type_list
argument_list|(
name|ptr_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|sizetype
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_VISIBILITY
argument_list|(
name|fn
argument_list|)
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|block_clear_fn
operator|=
name|fn
expr_stmt|;
block|}
if|if
condition|(
name|asmspec
condition|)
name|set_user_assembler_name
argument_list|(
name|block_clear_fn
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|clear_storage_libcall_fn
parameter_list|(
name|int
name|for_call
parameter_list|)
block|{
specifier|static
name|bool
name|emitted_extern
decl_stmt|;
if|if
condition|(
operator|!
name|block_clear_fn
condition|)
name|init_block_clear_fn
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_call
operator|&&
operator|!
name|emitted_extern
condition|)
block|{
name|emitted_extern
operator|=
name|true
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|block_clear_fn
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|block_clear_fn
argument_list|)
expr_stmt|;
block|}
return|return
name|block_clear_fn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a setmem pattern; return true if successful.  */
end_comment

begin_function
name|bool
name|set_storage_via_setmem
parameter_list|(
name|rtx
name|object
parameter_list|,
name|rtx
name|size
parameter_list|,
name|rtx
name|val
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
comment|/* Try the most limited insn first, because there's no point      including more than one in the machine description unless      the more limited one has some advantage.  */
name|rtx
name|opalign
init|=
name|GEN_INT
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|enum
name|insn_code
name|code
init|=
name|setmem_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
name|insn_operand_predicate_fn
name|pred
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
comment|/* We don't need MODE to be narrower than 	     BITS_PER_HOST_WIDE_INT here because if SIZE is less than 	     the mode mask, as it is returned by the macro, it will 	     definitely be less than the actual mode mask.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|)
operator|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|BITS_PER_WORD
operator|)
operator|&&
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|==
literal|0
operator|||
call|(
modifier|*
name|pred
call|)
argument_list|(
name|object
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|==
literal|0
operator|||
call|(
modifier|*
name|pred
call|)
argument_list|(
name|opalign
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|opsize
decl_stmt|,
name|opchar
decl_stmt|;
name|enum
name|machine_mode
name|char_mode
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|opsize
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
expr_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|pred
call|)
argument_list|(
name|opsize
argument_list|,
name|mode
argument_list|)
condition|)
name|opsize
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|opsize
argument_list|)
expr_stmt|;
name|opchar
operator|=
name|val
expr_stmt|;
name|char_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|char_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|opchar
operator|=
name|convert_to_mode
argument_list|(
name|char_mode
argument_list|,
name|opchar
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
expr_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|pred
call|)
argument_list|(
name|opchar
argument_list|,
name|char_mode
argument_list|)
condition|)
name|opchar
operator|=
name|copy_to_mode_reg
argument_list|(
name|char_mode
argument_list|,
name|opchar
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
operator|(
name|int
operator|)
name|code
argument_list|)
argument_list|(
name|object
argument_list|,
name|opsize
argument_list|,
name|opchar
argument_list|,
name|opalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write to one of the components of the complex value CPLX.  Write VAL to    the real part if IMAG_P is false, and the imaginary part if its true.  */
end_comment

begin_function
specifier|static
name|void
name|write_complex_part
parameter_list|(
name|rtx
name|cplx
parameter_list|,
name|rtx
name|val
parameter_list|,
name|bool
name|imag_p
parameter_list|)
block|{
name|enum
name|machine_mode
name|cmode
decl_stmt|;
name|enum
name|machine_mode
name|imode
decl_stmt|;
name|unsigned
name|ibitsize
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cplx
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|emit_move_insn
argument_list|(
name|XEXP
argument_list|(
name|cplx
argument_list|,
name|imag_p
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
name|cmode
operator|=
name|GET_MODE
argument_list|(
name|cplx
argument_list|)
expr_stmt|;
name|imode
operator|=
name|GET_MODE_INNER
argument_list|(
name|cmode
argument_list|)
expr_stmt|;
name|ibitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|imode
argument_list|)
expr_stmt|;
comment|/* For MEMs simplify_gen_subreg may generate an invalid new address      because, e.g., the original address is considered mode-dependent      by the target, which restricts simplify_subreg from invoking      adjust_address_nv.  Instead of preparing fallback support for an      invalid address, we call adjust_address_nv directly.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|cplx
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address_nv
argument_list|(
name|cplx
argument_list|,
name|imode
argument_list|,
name|imag_p
condition|?
name|GET_MODE_SIZE
argument_list|(
name|imode
argument_list|)
else|:
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the sub-object is at least word sized, then we know that subregging      will work.  This special case is important, since store_bit_field      wants to operate on integer modes, and there's rarely an OImode to      correspond to TCmode.  */
if|if
condition|(
name|ibitsize
operator|>=
name|BITS_PER_WORD
comment|/* For hard regs we have exact predicates.  Assume we can split 	 the original object if it spans an even number of hard regs. 	 This special case is important for SCmode on 64-bit platforms 	 where the natural size of floating-point regs is 32-bit.  */
operator|||
operator|(
name|REG_P
argument_list|(
name|cplx
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|cplx
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|hard_regno_nregs
index|[
name|REGNO
argument_list|(
name|cplx
argument_list|)
index|]
index|[
name|cmode
index|]
operator|%
literal|2
operator|==
literal|0
operator|)
condition|)
block|{
name|rtx
name|part
init|=
name|simplify_gen_subreg
argument_list|(
name|imode
argument_list|,
name|cplx
argument_list|,
name|cmode
argument_list|,
name|imag_p
condition|?
name|GET_MODE_SIZE
argument_list|(
name|imode
argument_list|)
else|:
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
condition|)
block|{
name|emit_move_insn
argument_list|(
name|part
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
comment|/* simplify_gen_subreg may fail for sub-word MEMs.  */
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|cplx
argument_list|)
operator|&&
name|ibitsize
operator|<
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
name|store_bit_field
argument_list|(
name|cplx
argument_list|,
name|ibitsize
argument_list|,
name|imag_p
condition|?
name|ibitsize
else|:
literal|0
argument_list|,
name|imode
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract one of the components of the complex value CPLX.  Extract the    real part if IMAG_P is false, and the imaginary part if it's true.  */
end_comment

begin_function
specifier|static
name|rtx
name|read_complex_part
parameter_list|(
name|rtx
name|cplx
parameter_list|,
name|bool
name|imag_p
parameter_list|)
block|{
name|enum
name|machine_mode
name|cmode
decl_stmt|,
name|imode
decl_stmt|;
name|unsigned
name|ibitsize
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cplx
argument_list|)
operator|==
name|CONCAT
condition|)
return|return
name|XEXP
argument_list|(
name|cplx
argument_list|,
name|imag_p
argument_list|)
return|;
name|cmode
operator|=
name|GET_MODE
argument_list|(
name|cplx
argument_list|)
expr_stmt|;
name|imode
operator|=
name|GET_MODE_INNER
argument_list|(
name|cmode
argument_list|)
expr_stmt|;
name|ibitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|imode
argument_list|)
expr_stmt|;
comment|/* Special case reads from complex constants that got spilled to memory.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|cplx
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cplx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|tree
name|decl
init|=
name|SYMBOL_REF_DECL
argument_list|(
name|XEXP
argument_list|(
name|cplx
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
block|{
name|tree
name|part
init|=
name|imag_p
condition|?
name|TREE_IMAGPART
argument_list|(
name|decl
argument_list|)
else|:
name|TREE_REALPART
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|part
argument_list|)
condition|)
return|return
name|expand_expr
argument_list|(
name|part
argument_list|,
name|NULL_RTX
argument_list|,
name|imode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
block|}
comment|/* For MEMs simplify_gen_subreg may generate an invalid new address      because, e.g., the original address is considered mode-dependent      by the target, which restricts simplify_subreg from invoking      adjust_address_nv.  Instead of preparing fallback support for an      invalid address, we call adjust_address_nv directly.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|cplx
argument_list|)
condition|)
return|return
name|adjust_address_nv
argument_list|(
name|cplx
argument_list|,
name|imode
argument_list|,
name|imag_p
condition|?
name|GET_MODE_SIZE
argument_list|(
name|imode
argument_list|)
else|:
literal|0
argument_list|)
return|;
comment|/* If the sub-object is at least word sized, then we know that subregging      will work.  This special case is important, since extract_bit_field      wants to operate on integer modes, and there's rarely an OImode to      correspond to TCmode.  */
if|if
condition|(
name|ibitsize
operator|>=
name|BITS_PER_WORD
comment|/* For hard regs we have exact predicates.  Assume we can split 	 the original object if it spans an even number of hard regs. 	 This special case is important for SCmode on 64-bit platforms 	 where the natural size of floating-point regs is 32-bit.  */
operator|||
operator|(
name|REG_P
argument_list|(
name|cplx
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|cplx
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|hard_regno_nregs
index|[
name|REGNO
argument_list|(
name|cplx
argument_list|)
index|]
index|[
name|cmode
index|]
operator|%
literal|2
operator|==
literal|0
operator|)
condition|)
block|{
name|rtx
name|ret
init|=
name|simplify_gen_subreg
argument_list|(
name|imode
argument_list|,
name|cplx
argument_list|,
name|cmode
argument_list|,
name|imag_p
condition|?
name|GET_MODE_SIZE
argument_list|(
name|imode
argument_list|)
else|:
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
else|else
comment|/* simplify_gen_subreg may fail for sub-word MEMs.  */
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|cplx
argument_list|)
operator|&&
name|ibitsize
operator|<
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
return|return
name|extract_bit_field
argument_list|(
name|cplx
argument_list|,
name|ibitsize
argument_list|,
name|imag_p
condition|?
name|ibitsize
else|:
literal|0
argument_list|,
name|true
argument_list|,
name|NULL_RTX
argument_list|,
name|imode
argument_list|,
name|imode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A subroutine of emit_move_insn_1.  Yet another lowpart generator.    NEW_MODE and OLD_MODE are the same size.  Return NULL if X cannot be    represented in NEW_MODE.  If FORCE is true, this will never happen, as    we'll force-create a SUBREG if needed.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_move_change_mode
parameter_list|(
name|enum
name|machine_mode
name|new_mode
parameter_list|,
name|enum
name|machine_mode
name|old_mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|rtx
name|ret
decl_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* We don't have to worry about changing the address since the 	 size in bytes is supposed to be the same.  */
if|if
condition|(
name|reload_in_progress
condition|)
block|{
comment|/* Copy the MEM to change the mode and move any 	     substitutions from the old MEM to the new one.  */
name|ret
operator|=
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|new_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_replacements
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|adjust_address
argument_list|(
name|x
argument_list|,
name|new_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Note that we do want simplify_subreg's behavior of validating 	 that the new mode is ok for a hard register.  If we were to use 	 simplify_gen_subreg, we would create the subreg, but would 	 probably run into the target not being able to implement it.  */
comment|/* Except, of course, when FORCE is true, when this is exactly what 	 we want.  Which is needed for CCmodes on some targets.  */
if|if
condition|(
name|force
condition|)
name|ret
operator|=
name|simplify_gen_subreg
argument_list|(
name|new_mode
argument_list|,
name|x
argument_list|,
name|old_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|simplify_subreg
argument_list|(
name|new_mode
argument_list|,
name|x
argument_list|,
name|old_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_move_insn_1.  Generate a move from Y into X using    an integer mode of the same size as MODE.  Returns the instruction    emitted, or NULL if such a move could not be generated.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_move_via_integer
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|enum
name|machine_mode
name|imode
decl_stmt|;
name|enum
name|insn_code
name|code
decl_stmt|;
comment|/* There must exist a mode of the exact size we require.  */
name|imode
operator|=
name|int_mode_for_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|==
name|BLKmode
condition|)
return|return
name|NULL_RTX
return|;
comment|/* The target must support moves in this mode.  */
name|code
operator|=
name|mov_optab
operator|->
name|handlers
index|[
name|imode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_FOR_nothing
condition|)
return|return
name|NULL_RTX
return|;
name|x
operator|=
name|emit_move_change_mode
argument_list|(
name|imode
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
name|y
operator|=
name|emit_move_change_mode
argument_list|(
name|imode
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_move_insn_1.  X is a push_operand in MODE.    Return an equivalent MEM that does not use an auto-increment.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_move_resolve_push
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|adjust
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|adjust
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|adjust
operator|=
name|PUSH_ROUNDING
argument_list|(
name|adjust
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
name|PRE_DEC
operator|||
name|code
operator|==
name|POST_DEC
condition|)
name|adjust
operator|=
operator|-
name|adjust
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PRE_MODIFY
operator|||
name|code
operator|==
name|POST_MODIFY
condition|)
block|{
name|rtx
name|expr
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|MINUS
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|val
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|MINUS
condition|)
name|val
operator|=
operator|-
name|val
expr_stmt|;
name|gcc_assert
argument_list|(
name|adjust
operator|==
name|val
operator|||
name|adjust
operator|==
operator|-
name|val
argument_list|)
expr_stmt|;
name|adjust
operator|=
name|val
expr_stmt|;
block|}
comment|/* Do not use anti_adjust_stack, since we don't want to update      stack_pointer_delta.  */
name|temp
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|adjust
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|stack_pointer_rtx
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|PRE_MODIFY
case|:
name|temp
operator|=
name|stack_pointer_rtx
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_MODIFY
case|:
name|temp
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
operator|-
name|adjust
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|replace_equiv_address
argument_list|(
name|x
argument_list|,
name|temp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_move_complex.  Generate a move from Y into X.    X is known to satisfy push_operand, and MODE is known to be complex.    Returns the last instruction emitted.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_move_complex_push
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|enum
name|machine_mode
name|submode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|bool
name|imag_first
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|unsigned
name|int
name|submodesize
init|=
name|GET_MODE_SIZE
argument_list|(
name|submode
argument_list|)
decl_stmt|;
comment|/* In case we output to the stack, but the size is smaller than the      machine can push exactly, we need to use move instructions.  */
if|if
condition|(
name|PUSH_ROUNDING
argument_list|(
name|submodesize
argument_list|)
operator|!=
name|submodesize
condition|)
block|{
name|x
operator|=
name|emit_move_resolve_push
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* Note that the real part always precedes the imag part in memory      regardless of machine's endianness.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
name|imag_first
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
name|imag_first
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|submode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|read_complex_part
argument_list|(
name|y
argument_list|,
name|imag_first
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|submode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|read_complex_part
argument_list|(
name|y
argument_list|,
operator|!
name|imag_first
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_move_insn_1.  Generate a move from Y into X.    MODE is known to be complex.  Returns the last instruction emitted.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_move_complex
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|bool
name|try_int
decl_stmt|;
comment|/* Need to take special care for pushes, to maintain proper ordering      of the data, and possibly extra padding.  */
if|if
condition|(
name|push_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|emit_move_complex_push
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
comment|/* See if we can coerce the target into moving both values at once.  */
comment|/* Move floating point as parts.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|&&
name|mov_optab
operator|->
name|handlers
index|[
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
name|try_int
operator|=
name|false
expr_stmt|;
comment|/* Not possible if the values are inherently not adjacent.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONCAT
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONCAT
condition|)
name|try_int
operator|=
name|false
expr_stmt|;
comment|/* Is possible if both are registers (or subregs of registers).  */
elseif|else
if|if
condition|(
name|register_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|&&
name|register_operand
argument_list|(
name|y
argument_list|,
name|mode
argument_list|)
condition|)
name|try_int
operator|=
name|true
expr_stmt|;
comment|/* If one of the operands is a memory, and alignment constraints      are friendly enough, we may be able to do combined memory operations.      We do not attempt this if Y is a constant because that combination is      usually better with the by-parts thing below.  */
elseif|else
if|if
condition|(
operator|(
name|MEM_P
argument_list|(
name|x
argument_list|)
condition|?
operator|!
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
else|:
name|MEM_P
argument_list|(
name|y
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|STRICT_ALIGNMENT
operator|||
name|get_mode_alignment
argument_list|(
name|mode
argument_list|)
operator|==
name|BIGGEST_ALIGNMENT
operator|)
condition|)
name|try_int
operator|=
name|true
expr_stmt|;
else|else
name|try_int
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|try_int
condition|)
block|{
name|rtx
name|ret
decl_stmt|;
comment|/* For memory to memory moves, optimal behavior can be had with the 	 existing block move logic.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|emit_block_move
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
name|BLOCK_OP_NO_LIBCALL
argument_list|)
expr_stmt|;
return|return
name|get_last_insn
argument_list|()
return|;
block|}
name|ret
operator|=
name|emit_move_via_integer
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
comment|/* Show the output dies here.  This is necessary for SUBREGs      of pseudos since we cannot track their lifetimes correctly;      hard regs shouldn't appear here except as return values.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
operator|!
name|reload_in_progress
operator|&&
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|write_complex_part
argument_list|(
name|x
argument_list|,
name|read_complex_part
argument_list|(
name|y
argument_list|,
name|false
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|write_complex_part
argument_list|(
name|x
argument_list|,
name|read_complex_part
argument_list|(
name|y
argument_list|,
name|true
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|get_last_insn
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_move_insn_1.  Generate a move from Y into X.    MODE is known to be MODE_CC.  Returns the last instruction emitted.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_move_ccmode
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|rtx
name|ret
decl_stmt|;
comment|/* Assume all MODE_CC modes are equivalent; if we have movcc, use it.  */
if|if
condition|(
name|mode
operator|!=
name|CCmode
condition|)
block|{
name|enum
name|insn_code
name|code
init|=
name|mov_optab
operator|->
name|handlers
index|[
name|CCmode
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|x
operator|=
name|emit_move_change_mode
argument_list|(
name|CCmode
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|y
operator|=
name|emit_move_change_mode
argument_list|(
name|CCmode
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Otherwise, find the MODE_INT mode of the same width.  */
name|ret
operator|=
name|emit_move_via_integer
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return true if word I of OP lies entirely in the    undefined bits of a paradoxical subreg.  */
end_comment

begin_function
specifier|static
name|bool
name|undefined_operand_subword_p
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|enum
name|machine_mode
name|innermode
decl_stmt|,
name|innermostmode
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SUBREG
condition|)
return|return
name|false
return|;
name|innermode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|innermostmode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|i
operator|*
name|UNITS_PER_WORD
operator|+
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* The SUBREG_BYTE represents offset, as if the value were stored in      memory, except for a paradoxical subreg where we define      SUBREG_BYTE to be 0; undo this exception as in      simplify_subreg.  */
if|if
condition|(
name|SUBREG_BYTE
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
condition|)
block|{
name|int
name|difference
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|innermode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|innermostmode
argument_list|)
operator|||
name|offset
operator|<=
operator|-
name|GET_MODE_SIZE
argument_list|(
name|word_mode
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of emit_move_insn_1.  Generate a move from Y into X.    MODE is any multi-word or full-word mode that lacks a move_insn    pattern.  Note that you will get better code if you define such    patterns, even if they must turn into multiple assembler instructions.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_move_multi_word
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|rtx
name|last_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|seq
decl_stmt|,
name|inner
decl_stmt|;
name|bool
name|need_clobber
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
comment|/* If X is a push on the stack, do the push now and replace      X with a reference to the stack pointer.  */
if|if
condition|(
name|push_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
name|x
operator|=
name|emit_move_resolve_push
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If we are in reload, see if either operand is a MEM whose address      is scheduled for replacement.  */
if|if
condition|(
name|reload_in_progress
operator|&&
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|inner
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
name|x
operator|=
name|replace_equiv_address_nv
argument_list|(
name|x
argument_list|,
name|inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|&&
name|MEM_P
argument_list|(
name|y
argument_list|)
operator|&&
operator|(
name|inner
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
condition|)
name|y
operator|=
name|replace_equiv_address_nv
argument_list|(
name|y
argument_list|,
name|inner
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|need_clobber
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|xpart
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|ypart
decl_stmt|;
comment|/* Do not generate code for a move if it would come entirely 	 from the undefined bits of a paradoxical subreg.  */
if|if
condition|(
name|undefined_operand_subword_p
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
name|ypart
operator|=
name|operand_subword
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* If we can't get a part of Y, put Y into memory if it is a 	 constant.  Otherwise, force it into a register.  Then we must 	 be able to get a part of Y.  */
if|if
condition|(
name|ypart
operator|==
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|y
operator|=
name|use_anchored_address
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|ypart
operator|=
name|operand_subword
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ypart
operator|==
literal|0
condition|)
name|ypart
operator|=
name|operand_subword_force
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|xpart
operator|&&
name|ypart
argument_list|)
expr_stmt|;
name|need_clobber
operator||=
operator|(
name|GET_CODE
argument_list|(
name|xpart
argument_list|)
operator|==
name|SUBREG
operator|)
expr_stmt|;
name|last_insn
operator|=
name|emit_move_insn
argument_list|(
name|xpart
argument_list|,
name|ypart
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Show the output dies here.  This is necessary for SUBREGs      of pseudos since we cannot track their lifetimes correctly;      hard regs shouldn't appear here except as return values.      We never want to emit such a clobber after reload.  */
if|if
condition|(
name|x
operator|!=
name|y
operator|&&
operator|!
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
operator|&&
name|need_clobber
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
return|return
name|last_insn
return|;
block|}
end_function

begin_comment
comment|/* Low level part of emit_move_insn.    Called just like emit_move_insn, but assumes X and Y    are basically valid.  */
end_comment

begin_function
name|rtx
name|emit_move_insn_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|code
decl_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|mode
operator|<
operator|(
name|unsigned
name|int
operator|)
name|MAX_MACHINE_MODE
argument_list|)
expr_stmt|;
name|code
operator|=
name|mov_optab
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
comment|/* Expand complex moves by moving real part and imag part.  */
if|if
condition|(
name|COMPLEX_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|emit_move_complex
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_DECIMAL_FLOAT
condition|)
block|{
name|rtx
name|result
init|=
name|emit_move_via_integer
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|true
argument_list|)
decl_stmt|;
comment|/* If we can't find an integer mode, use multi words.  */
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
else|else
return|return
name|emit_move_multi_word
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
condition|)
return|return
name|emit_move_ccmode
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
comment|/* Try using a move pattern for the corresponding integer mode.  This is      only safe when simplify_subreg can convert MODE constants into integer      constants.  At present, it can only do this reliably if the value      fits within a HOST_WIDE_INT.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|rtx
name|ret
init|=
name|emit_move_via_integer
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
name|emit_move_multi_word
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate code to copy Y into X.    Both Y and X must have the same mode, except that    Y can be a constant with VOIDmode.    This mode cannot be BLKmode; use emit_block_move for that.     Return the last instruction emitted.  */
end_comment

begin_function
name|rtx
name|emit_move_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|y_cst
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|,
name|set
decl_stmt|;
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|==
name|VOIDmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|optimize
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|(
name|last_insn
operator|=
name|compress_float_constant
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
condition|)
return|return
name|last_insn
return|;
name|y_cst
operator|=
name|y
expr_stmt|;
if|if
condition|(
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|y
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* If the target's cannot_force_const_mem prevented the spill, 	     assume that the target's move expanders will also take care 	     of the non-legitimate constant.  */
if|if
condition|(
operator|!
name|y
condition|)
name|y
operator|=
name|y_cst
expr_stmt|;
else|else
name|y
operator|=
name|use_anchored_address
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If X or Y are memory references, verify that their addresses are valid      for the machine.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
operator|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|x
operator|=
name|validize_mem
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|y
argument_list|)
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|y
operator|=
name|validize_mem
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|BLKmode
argument_list|)
expr_stmt|;
name|last_insn
operator|=
name|emit_move_insn_1
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y_cst
operator|&&
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|last_insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|x
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|y_cst
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|set_unique_reg_note
argument_list|(
name|last_insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|y_cst
argument_list|)
expr_stmt|;
return|return
name|last_insn
return|;
block|}
end_function

begin_comment
comment|/* If Y is representable exactly in a narrower mode, and the target can    perform the extension directly from constant or memory, then emit the    move as an extension.  */
end_comment

begin_function
specifier|static
name|rtx
name|compress_float_constant
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|enum
name|machine_mode
name|dstmode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|orig_srcmode
init|=
name|GET_MODE
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|srcmode
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|oldcost
decl_stmt|,
name|newcost
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
name|oldcost
operator|=
name|rtx_cost
argument_list|(
name|y
argument_list|,
name|SET
argument_list|)
expr_stmt|;
else|else
name|oldcost
operator|=
name|rtx_cost
argument_list|(
name|force_const_mem
argument_list|(
name|dstmode
argument_list|,
name|y
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
for|for
control|(
name|srcmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|GET_MODE_CLASS
argument_list|(
name|orig_srcmode
argument_list|)
argument_list|)
init|;
name|srcmode
operator|!=
name|orig_srcmode
condition|;
name|srcmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|srcmode
argument_list|)
control|)
block|{
name|enum
name|insn_code
name|ic
decl_stmt|;
name|rtx
name|trunc_y
decl_stmt|,
name|last_insn
decl_stmt|;
comment|/* Skip if the target can't extend this way.  */
name|ic
operator|=
name|can_extend_p
argument_list|(
name|dstmode
argument_list|,
name|srcmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|==
name|CODE_FOR_nothing
condition|)
continue|continue;
comment|/* Skip if the narrowed value isn't exact.  */
if|if
condition|(
operator|!
name|exact_real_truncate
argument_list|(
name|srcmode
argument_list|,
operator|&
name|r
argument_list|)
condition|)
continue|continue;
name|trunc_y
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|r
argument_list|,
name|srcmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|trunc_y
argument_list|)
condition|)
block|{
comment|/* Skip if the target needs extra instructions to perform 	     the extension.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|ic
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|trunc_y
operator|,
name|srcmode
operator|)
condition|)
continue|continue;
comment|/* This is valid, but may not be cheaper than the original. */
name|newcost
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx_FLOAT_EXTEND
argument_list|(
name|dstmode
argument_list|,
name|trunc_y
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldcost
operator|<
name|newcost
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|float_extend_from_mem
index|[
name|dstmode
index|]
index|[
name|srcmode
index|]
condition|)
block|{
name|trunc_y
operator|=
name|force_const_mem
argument_list|(
name|srcmode
argument_list|,
name|trunc_y
argument_list|)
expr_stmt|;
comment|/* This is valid, but may not be cheaper than the original. */
name|newcost
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx_FLOAT_EXTEND
argument_list|(
name|dstmode
argument_list|,
name|trunc_y
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldcost
operator|<
name|newcost
condition|)
continue|continue;
name|trunc_y
operator|=
name|validize_mem
argument_list|(
name|trunc_y
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* For CSE's benefit, force the compressed constant pool entry 	 into a new pseudo.  This constant may be used in different modes, 	 and if not, combine will put things back together for us.  */
name|trunc_y
operator|=
name|force_reg
argument_list|(
name|srcmode
argument_list|,
name|trunc_y
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|ic
argument_list|,
name|x
argument_list|,
name|trunc_y
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
name|last_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|set_unique_reg_note
argument_list|(
name|last_insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
name|last_insn
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pushing data onto the stack.  */
end_comment

begin_comment
comment|/* Push a block of length SIZE (perhaps variable)    and return an rtx to address the beginning of the block.    The value may be virtual_outgoing_args_rtx.     EXTRA is the number of bytes of padding to push in addition to SIZE.    BELOW nonzero means this padding comes at low addresses;    otherwise, the padding comes at high addresses.  */
end_comment

begin_function
name|rtx
name|push_block
parameter_list|(
name|rtx
name|size
parameter_list|,
name|int
name|extra
parameter_list|,
name|int
name|below
parameter_list|)
block|{
name|rtx
name|temp
decl_stmt|;
name|size
operator|=
name|convert_modes
argument_list|(
name|Pmode
argument_list|,
name|ptr_mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|size
argument_list|)
condition|)
name|anti_adjust_stack
argument_list|(
name|plus_constant
argument_list|(
name|size
argument_list|,
name|extra
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|size
argument_list|)
operator|&&
name|extra
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|anti_adjust_stack
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
if|if
condition|(
literal|0
condition|)
else|#
directive|else
if|if
condition|(
literal|1
condition|)
endif|#
directive|endif
block|{
name|temp
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
operator|&&
name|below
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
operator|(
name|below
condition|?
literal|0
else|:
name|extra
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra
operator|!=
literal|0
operator|&&
operator|!
name|below
condition|)
name|temp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|virtual_outgoing_args_rtx
argument_list|,
name|negate_rtx
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|size
argument_list|,
name|extra
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|virtual_outgoing_args_rtx
argument_list|,
name|negate_rtx
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|memory_address
argument_list|(
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
end_ifdef

begin_comment
comment|/* Emit single push insn.  */
end_comment

begin_function
specifier|static
name|void
name|emit_single_push_insn
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|rtx
name|dest_addr
decl_stmt|;
name|unsigned
name|rounded_size
init|=
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|insn_operand_predicate_fn
name|pred
decl_stmt|;
name|stack_pointer_delta
operator|+=
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is push pattern, use it.  Otherwise try old way of throwing      MEM representing push operation to move expander.  */
name|icode
operator|=
name|push_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|&&
operator|!
operator|(
call|(
modifier|*
name|pred
call|)
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|rounded_size
condition|)
name|dest_addr
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|STACK_PUSH_CODE
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
comment|/* If we are to pad downward, adjust the stack pointer first and      then store X into the stack location using an offset.  This is      because emit_move_insn does not know how to pad; it does not have      access to type.  */
elseif|else
if|if
condition|(
name|FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|==
name|downward
condition|)
block|{
name|unsigned
name|padding_size
init|=
name|rounded_size
operator|-
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|sub_optab
argument_list|,
else|#
directive|else
name|add_optab
argument_list|,
endif|#
directive|endif
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|rounded_size
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|padding_size
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
if|if
condition|(
name|STACK_PUSH_CODE
operator|==
name|POST_DEC
condition|)
comment|/* We have already decremented the stack pointer, so get the 	   previous value.  */
name|offset
operator|+=
operator|(
name|HOST_WIDE_INT
operator|)
name|rounded_size
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|STACK_PUSH_CODE
operator|==
name|POST_INC
condition|)
comment|/* We have already incremented the stack pointer, so get the 	   previous value.  */
name|offset
operator|-=
operator|(
name|HOST_WIDE_INT
operator|)
name|rounded_size
expr_stmt|;
endif|#
directive|endif
name|dest_addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
comment|/* ??? This seems wrong if STACK_PUSH_CODE == POST_DEC.  */
name|dest_addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|rounded_size
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ??? This seems wrong if STACK_PUSH_CODE == POST_INC.  */
name|dest_addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|rounded_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dest_addr
operator|=
name|gen_rtx_PRE_MODIFY
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|dest_addr
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|dest_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
name|set_mem_attributes
argument_list|(
name|dest
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_optimize_sibling_calls
condition|)
comment|/* Function incoming arguments may overlap with sibling call 	   outgoing arguments and we cannot allow reordering of reads 	   from function arguments with stores to outgoing arguments 	   of sibling calls.  */
name|set_mem_alias_set
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate code to push X onto the stack, assuming it has mode MODE and    type TYPE.    MODE is redundant except when X is a CONST_INT (since they don't    carry mode info).    SIZE is an rtx for the size of data to be copied (in bytes),    needed only if X is BLKmode.     ALIGN (in bits) is maximum alignment we can assume.     If PARTIAL and REG are both nonzero, then copy that many of the first    bytes of X into registers starting with REG, and push the rest of X.    The amount of space pushed is decreased by PARTIAL bytes.    REG must be a hard register in this case.    If REG is zero but PARTIAL is not, take any all others actions for an    argument partially in registers, but do not actually load any    registers.     EXTRA is the amount in bytes of extra space to leave next to this arg.    This is ignored if an argument block has already been allocated.     On a machine that lacks real push insns, ARGS_ADDR is the address of    the bottom of the argument block for this call.  We use indexing off there    to store the arg.  On machines with push insns, ARGS_ADDR is 0 when a    argument block has not been preallocated.     ARGS_SO_FAR is the size of args previously pushed for this call.     REG_PARM_STACK_SPACE is nonzero if functions require stack space    for arguments passed in registers.  If nonzero, it will be the number    of bytes required.  */
end_comment

begin_function
name|void
name|emit_push_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|rtx
name|size
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|,
name|int
name|partial
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|int
name|extra
parameter_list|,
name|rtx
name|args_addr
parameter_list|,
name|rtx
name|args_so_far
parameter_list|,
name|int
name|reg_parm_stack_space
parameter_list|,
name|rtx
name|alignment_pad
parameter_list|)
block|{
name|rtx
name|xinner
decl_stmt|;
name|enum
name|direction
name|stack_direction
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
init|=
name|downward
decl_stmt|;
else|#
directive|else
operator|=
name|upward
expr_stmt|;
endif|#
directive|endif
comment|/* Decide where to pad the argument: `downward' for below,      `upward' for above, or `none' for don't pad it.      Default is below for small data on big-endian machines; else above.  */
name|enum
name|direction
name|where_pad
init|=
name|FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* Invert direction if stack is post-decrement.      FIXME: why?  */
if|if
condition|(
name|STACK_PUSH_CODE
operator|==
name|POST_DEC
condition|)
if|if
condition|(
name|where_pad
operator|!=
name|none
condition|)
name|where_pad
operator|=
operator|(
name|where_pad
operator|==
name|downward
condition|?
name|upward
else|:
name|downward
operator|)
expr_stmt|;
name|xinner
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* Copy a block into the stack, entirely or partially.  */
name|rtx
name|temp
decl_stmt|;
name|int
name|used
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|offset
operator|=
name|partial
operator|%
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|used
operator|=
name|partial
operator|-
name|offset
expr_stmt|;
name|gcc_assert
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* USED is now the # of bytes we need not copy to the stack 	 because registers will take care of them.  */
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
name|xinner
operator|=
name|adjust_address
argument_list|(
name|xinner
argument_list|,
name|BLKmode
argument_list|,
name|used
argument_list|)
expr_stmt|;
comment|/* If the partial register-part of the arg counts in its stack size, 	 skip the part of stack space corresponding to the registers. 	 Otherwise, start copying to the beginning of the stack space, 	 by setting SKIP to 0.  */
name|skip
operator|=
operator|(
name|reg_parm_stack_space
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|used
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* Do it with several push insns if that doesn't take lots of insns 	 and if there is no difficulty with push insns that skip bytes 	 on the stack for alignment purposes.  */
if|if
condition|(
name|args_addr
operator|==
literal|0
operator|&&
name|PUSH_ARGS
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|skip
operator|==
literal|0
operator|&&
name|MEM_ALIGN
argument_list|(
name|xinner
argument_list|)
operator|>=
name|align
operator|&&
operator|(
name|MOVE_BY_PIECES_P
argument_list|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|,
name|align
argument_list|)
operator|)
comment|/* Here we avoid the case of a structure whose weak alignment 	     forces many pushes of a small amount of data, 	     and such small pushes do rounding that causes trouble.  */
operator|&&
operator|(
operator|(
operator|!
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|word_mode
argument_list|,
name|align
argument_list|)
operator|)
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
operator|||
operator|(
name|PUSH_ROUNDING
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
operator|==
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|)
operator|&&
name|PUSH_ROUNDING
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|size
argument_list|)
condition|)
block|{
comment|/* Push padding now if padding above and stack grows down, 	     or if padding below and stack grows up. 	     But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
name|move_by_pieces
argument_list|(
name|NULL
argument_list|,
name|xinner
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* PUSH_ROUNDING  */
block|{
name|rtx
name|target
decl_stmt|;
comment|/* Otherwise make space on the stack and copy the data 	     to the address of that space.  */
comment|/* Deduct words put into registers from the size we must copy.  */
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
name|size
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|size
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|used
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* Get the address of the stack space. 	     In this case, we do not deal with EXTRA separately. 	     A single stack adjust will do.  */
if|if
condition|(
operator|!
name|args_addr
condition|)
block|{
name|temp
operator|=
name|push_block
argument_list|(
name|size
argument_list|,
name|extra
argument_list|,
name|where_pad
operator|==
name|downward
argument_list|)
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|args_so_far
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|args_addr
argument_list|,
name|skip
operator|+
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|args_addr
argument_list|,
name|args_so_far
argument_list|)
argument_list|,
name|skip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
comment|/* If the source is referenced relative to the stack pointer, 		 copy it to another register to stabilize it.  We do not need 		 to do this if we know that we won't be changing sp.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|temp
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|temp
argument_list|)
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|target
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* We do *not* set_mem_attributes here, because incoming arguments 	     may overlap with sibling call outgoing arguments and we cannot 	     allow reordering of reads from function arguments with stores 	     to outgoing arguments of sibling calls.  We do, however, want 	     to record the alignment of the stack slot.  */
comment|/* ALIGN may well be better aligned than TYPE, e.g. due to 	     PARM_BOUNDARY.  Assume the caller isn't lying.  */
name|set_mem_align
argument_list|(
name|target
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|xinner
argument_list|,
name|size
argument_list|,
name|BLOCK_OP_CALL_PARM
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|partial
operator|>
literal|0
condition|)
block|{
comment|/* Scalar partly in registers.  */
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|not_stack
decl_stmt|;
comment|/* # bytes of start of argument 	 that we must make space for but need not store.  */
name|int
name|offset
init|=
name|partial
operator|%
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|int
name|args_offset
init|=
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
decl_stmt|;
name|int
name|skip
decl_stmt|;
comment|/* Push padding now if padding above and stack grows down, 	 or if padding below and stack grows up. 	 But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we make space by pushing it, we might as well push 	 the real data.  Otherwise, we can leave OFFSET nonzero 	 and leave the space uninitialized.  */
if|if
condition|(
name|args_addr
operator|==
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Now NOT_STACK gets the number of words that we don't need to 	 allocate on the stack.  Convert OFFSET to words too.  */
name|not_stack
operator|=
operator|(
name|partial
operator|-
name|offset
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|offset
operator|/=
name|UNITS_PER_WORD
expr_stmt|;
comment|/* If the partial register-part of the arg counts in its stack size, 	 skip the part of stack space corresponding to the registers. 	 Otherwise, start copying to the beginning of the stack space, 	 by setting SKIP to 0.  */
name|skip
operator|=
operator|(
name|reg_parm_stack_space
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|not_stack
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If X is a hard register in a non-integer mode, copy it into a pseudo; 	 SUBREGs of such registers are not allowed.  */
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
operator|)
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Loop over all the words allocated on the stack for this arg.  */
comment|/* We can do it by words, because any scalar bigger than a word 	 has a size a multiple of a word.  */
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
for|for
control|(
name|i
operator|=
name|not_stack
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
name|not_stack
condition|;
name|i
operator|--
control|)
endif|#
directive|endif
if|if
condition|(
name|i
operator|>=
name|not_stack
operator|+
name|offset
condition|)
name|emit_push_insn
argument_list|(
name|operand_subword_force
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_RTX
argument_list|,
name|align
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|args_addr
argument_list|,
name|GEN_INT
argument_list|(
name|args_offset
operator|+
operator|(
operator|(
name|i
operator|-
name|not_stack
operator|+
name|skip
operator|)
operator|*
name|UNITS_PER_WORD
operator|)
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|,
name|alignment_pad
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|addr
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
comment|/* Push padding now if padding above and stack grows down, 	 or if padding below and stack grows up. 	 But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|args_addr
operator|==
literal|0
operator|&&
name|PUSH_ARGS
condition|)
name|emit_single_push_insn
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|args_so_far
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|args_addr
argument_list|,
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|args_addr
argument_list|,
name|args_so_far
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* We do *not* set_mem_attributes here, because incoming arguments 	     may overlap with sibling call outgoing arguments and we cannot 	     allow reordering of reads from function arguments with stores 	     to outgoing arguments of sibling calls.  We do, however, want 	     to record the alignment of the stack slot.  */
comment|/* ALIGN may well be better aligned than TYPE, e.g. due to 	     PARM_BOUNDARY.  Assume the caller isn't lying.  */
name|set_mem_align
argument_list|(
name|dest
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If part should go in registers, copy that part      into the appropriate registers.  Do this now, at the end,      since mem-to-mem copies above may do function calls.  */
if|if
condition|(
name|partial
operator|>
literal|0
operator|&&
name|reg
operator|!=
literal|0
condition|)
block|{
comment|/* Handle calls that pass values in multiple non-contiguous locations. 	 The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|reg
argument_list|,
name|x
argument_list|,
name|type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|partial
operator|%
name|UNITS_PER_WORD
operator|==
literal|0
argument_list|)
expr_stmt|;
name|move_block_to_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|x
argument_list|,
name|partial
operator|/
name|UNITS_PER_WORD
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|==
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment_pad
operator|&&
name|args_addr
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|alignment_pad
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return X if X can be used as a subtarget in a sequence of arithmetic    operations.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_subtarget
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
operator|(
name|optimize
operator|||
name|x
operator|==
literal|0
comment|/* Only registers can be subtargets.  */
operator|||
operator|!
name|REG_P
argument_list|(
name|x
argument_list|)
comment|/* Don't use hard regs to avoid extending their life.  */
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
literal|0
else|:
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_assignment.  Optimize FIELD op= VAL, where    FIELD is a bitfield.  Returns true if the optimization was successful,    and there's nothing else to do.  */
end_comment

begin_function
specifier|static
name|bool
name|optimize_bitfield_assignment_op
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|bitsize
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|bitpos
parameter_list|,
name|enum
name|machine_mode
name|mode1
parameter_list|,
name|rtx
name|str_rtx
parameter_list|,
name|tree
name|to
parameter_list|,
name|tree
name|src
parameter_list|)
block|{
name|enum
name|machine_mode
name|str_mode
init|=
name|GET_MODE
argument_list|(
name|str_rtx
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|str_bitsize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|str_mode
argument_list|)
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|value
decl_stmt|,
name|result
decl_stmt|;
name|optab
name|binop
decl_stmt|;
if|if
condition|(
name|mode1
operator|!=
name|VOIDmode
operator|||
name|bitsize
operator|>=
name|BITS_PER_WORD
operator|||
name|str_bitsize
operator|>
name|BITS_PER_WORD
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|to
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|to
argument_list|)
condition|)
return|return
name|false
return|;
name|STRIP_NOPS
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINARY_CLASS_P
argument_list|(
name|src
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
name|false
return|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|to
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|MEM_P
argument_list|(
name|str_rtx
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|offset1
decl_stmt|;
if|if
condition|(
name|str_bitsize
operator|==
literal|0
operator|||
name|str_bitsize
operator|>
name|BITS_PER_WORD
condition|)
name|str_mode
operator|=
name|word_mode
expr_stmt|;
name|str_mode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|MEM_ALIGN
argument_list|(
name|str_rtx
argument_list|)
argument_list|,
name|str_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_mode
operator|==
name|VOIDmode
condition|)
return|return
name|false
return|;
name|str_bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|str_mode
argument_list|)
expr_stmt|;
name|offset1
operator|=
name|bitpos
expr_stmt|;
name|bitpos
operator|%=
name|str_bitsize
expr_stmt|;
name|offset1
operator|=
operator|(
name|offset1
operator|-
name|bitpos
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|str_rtx
operator|=
name|adjust_address
argument_list|(
name|str_rtx
argument_list|,
name|str_mode
argument_list|,
name|offset1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|str_rtx
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|str_rtx
argument_list|)
operator|!=
name|SUBREG
condition|)
return|return
name|false
return|;
comment|/* If the bit field covers the whole REG/MEM, store_field      will likely generate better code.  */
if|if
condition|(
name|bitsize
operator|>=
name|str_bitsize
condition|)
return|return
name|false
return|;
comment|/* We can't handle fields split across multiple entities.  */
if|if
condition|(
name|bitpos
operator|+
name|bitsize
operator|>
name|str_bitsize
condition|)
return|return
name|false
return|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|bitpos
operator|=
name|str_bitsize
operator|-
name|bitpos
operator|-
name|bitsize
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
comment|/* For now, just optimize the case of the topmost bitfield 	 where we don't need to do any masking and also 	 1 bit bitfields where xor can be used. 	 We might win by one instruction for the other bitfields 	 too if insv/extv instructions aren't used, so that 	 can be added later.  */
if|if
condition|(
name|bitpos
operator|+
name|bitsize
operator|!=
name|str_bitsize
operator|&&
operator|(
name|bitsize
operator|!=
literal|1
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
break|break;
name|value
operator|=
name|expand_expr
argument_list|(
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|str_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|convert_modes
argument_list|(
name|str_mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|,
name|value
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We may be accessing data outside the field, which means 	 we can alias adjacent data.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|str_rtx
argument_list|)
condition|)
block|{
name|str_rtx
operator|=
name|shallow_copy_rtx
argument_list|(
name|str_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|str_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_expr
argument_list|(
name|str_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|binop
operator|=
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS_EXPR
condition|?
name|add_optab
else|:
name|sub_optab
expr_stmt|;
if|if
condition|(
name|bitsize
operator|==
literal|1
operator|&&
name|bitpos
operator|+
name|bitsize
operator|!=
name|str_bitsize
condition|)
block|{
name|value
operator|=
name|expand_and
argument_list|(
name|str_mode
argument_list|,
name|value
argument_list|,
name|const1_rtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|binop
operator|=
name|xor_optab
expr_stmt|;
block|}
name|value
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|str_mode
argument_list|,
name|value
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|bitpos
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|expand_binop
argument_list|(
name|str_mode
argument_list|,
name|binop
argument_list|,
name|str_rtx
argument_list|,
name|value
argument_list|,
name|str_rtx
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|str_rtx
condition|)
name|emit_move_insn
argument_list|(
name|str_rtx
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
name|value
operator|=
name|expand_expr
argument_list|(
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|str_rtx
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|str_rtx
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|,
name|value
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We may be accessing data outside the field, which means 	 we can alias adjacent data.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|str_rtx
argument_list|)
condition|)
block|{
name|str_rtx
operator|=
name|shallow_copy_rtx
argument_list|(
name|str_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|str_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_expr
argument_list|(
name|str_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|binop
operator|=
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|?
name|ior_optab
else|:
name|xor_optab
expr_stmt|;
if|if
condition|(
name|bitpos
operator|+
name|bitsize
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|str_rtx
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|mask
init|=
name|GEN_INT
argument_list|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|value
operator|=
name|expand_and
argument_list|(
name|GET_MODE
argument_list|(
name|str_rtx
argument_list|)
argument_list|,
name|value
argument_list|,
name|mask
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|str_rtx
argument_list|)
argument_list|,
name|value
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|bitpos
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|str_rtx
argument_list|)
argument_list|,
name|binop
argument_list|,
name|str_rtx
argument_list|,
name|value
argument_list|,
name|str_rtx
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|str_rtx
condition|)
name|emit_move_insn
argument_list|(
name|str_rtx
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Expand an assignment that stores the value of FROM into TO.  */
end_comment

begin_function
name|void
name|expand_assignment
parameter_list|(
name|tree
name|to
parameter_list|,
name|tree
name|from
parameter_list|)
block|{
name|rtx
name|to_rtx
init|=
literal|0
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* Don't crash if the lhs of the assignment was erroneous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
name|result
operator|=
name|expand_normal
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Optimize away no-op moves without side-effects.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* Assignment of a structure component needs special treatment      if the structure component's rtx is not simply a MEM.      Assignment of an array element at a constant index, and assignment of      an array element in an unaligned packed structure field, has the same      problem.  */
if|if
condition|(
name|handled_component_p
argument_list|(
name|to
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|tem
operator|=
name|get_inner_reference
argument_list|(
name|to
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode1
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* If we are going to use store_bit_field and extract_bit_field, 	 make sure to_rtx will be safe for multiple use.  */
name|to_rtx
operator|=
name|expand_normal
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset_rtx
decl_stmt|;
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|to_rtx
argument_list|)
condition|)
block|{
comment|/* We can get constant negative offsets into arrays with broken 		 user code.  Translate this to a trap instead of ICEing.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|expand_builtin_trap
argument_list|()
expr_stmt|;
name|to_rtx
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
name|offset_rtx
operator|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|Pmode
condition|)
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|ptr_mode
condition|)
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A constant address in TO_RTX can have VOIDmode, we must not try 	     to call force_reg for that case.  Avoid that case.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|to_rtx
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|bitsize
operator|>
literal|0
operator|&&
operator|(
name|bitpos
operator|%
name|bitsize
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bitsize
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|MEM_ALIGN
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
condition|)
block|{
name|to_rtx
operator|=
name|adjust_address
argument_list|(
name|to_rtx
argument_list|,
name|mode1
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|bitpos
operator|=
literal|0
expr_stmt|;
block|}
name|to_rtx
operator|=
name|offset_address
argument_list|(
name|to_rtx
argument_list|,
name|offset_rtx
argument_list|,
name|highest_pow2_factor_for_target
argument_list|(
name|to
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Handle expand_expr of a complex value returning a CONCAT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|gcc_assert
argument_list|(
name|bitpos
operator|==
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|store_expr
argument_list|(
name|from
argument_list|,
name|to_rtx
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|bitpos
operator|==
literal|0
operator|||
name|bitpos
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode1
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|store_expr
argument_list|(
name|from
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
name|bitpos
operator|!=
literal|0
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|MEM_P
argument_list|(
name|to_rtx
argument_list|)
condition|)
block|{
comment|/* If the field is at offset zero, we could have been given the 		 DECL_RTX of the parent struct.  Don't munge it.  */
name|to_rtx
operator|=
name|shallow_copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|set_mem_attributes_minus_bitpos
argument_list|(
name|to_rtx
argument_list|,
name|to
argument_list|,
literal|0
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
comment|/* Deal with volatile and readonly fields.  The former is only 		 done for MEM.  Also set MEM_KEEP_ALIAS_SET_P if needed.  */
if|if
condition|(
name|volatilep
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|component_uses_parent_alias_set
argument_list|(
name|to
argument_list|)
condition|)
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|optimize_bitfield_assignment_op
argument_list|(
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode1
argument_list|,
name|to_rtx
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
condition|)
name|result
operator|=
name|NULL
expr_stmt|;
else|else
name|result
operator|=
name|store_field
argument_list|(
name|to_rtx
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode1
argument_list|,
name|from
argument_list|,
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|get_alias_set
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
condition|)
name|preserve_temp_slots
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* If the rhs is a function call and its value is not an aggregate,      call the function before we start to compute the lhs.      This is needed for correct code for cases such as      val = setjmp (buf) on machines where reference to val      requires loading up part of an address in a separate insn.       Don't do this if TO is a VAR_DECL or PARM_DECL whose DECL_RTL is REG      since it might be a promoted variable where the zero- or sign- extension      needs to be done.  Handling this in the normal way is safe because no      computation is done before the call.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|!
name|aggregate_value_p
argument_list|(
name|from
argument_list|,
name|from
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|to
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|value
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|value
operator|=
name|expand_normal
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_rtx
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|to
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_WRITE
argument_list|)
expr_stmt|;
comment|/* Handle calls that return values in multiple non-contiguous locations. 	 The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|to_rtx
argument_list|,
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|to_rtx
argument_list|,
name|value
argument_list|,
name|expr_size
argument_list|(
name|from
argument_list|)
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|convert_memory_address
argument_list|(
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to_rtx
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Ordinary treatment.  Expand TO to get a REG or MEM rtx.      Don't re-expand if it was expanded already (in COMPONENT_REF case).  */
if|if
condition|(
name|to_rtx
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|to
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_WRITE
argument_list|)
expr_stmt|;
comment|/* Don't move directly into a return register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|RESULT_DECL
operator|&&
operator|(
name|REG_P
argument_list|(
name|to_rtx
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|PARALLEL
operator|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|to_rtx
argument_list|,
name|temp
argument_list|,
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|to_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* In case we are returning the contents of an object which overlaps      the place the value is being stored, use a safe function when copying      a value through a pointer into a structure value return block.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|RESULT_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|current_function_returns_struct
operator|&&
operator|!
name|current_function_returns_pcc_struct
condition|)
block|{
name|rtx
name|from_rtx
decl_stmt|,
name|size
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|size
operator|=
name|expr_size
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|from_rtx
operator|=
name|expand_normal
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|emit_library_call
argument_list|(
name|memmove_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|from_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Compute FROM and store the value in the rtx we got.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
name|result
operator|=
name|store_expr
argument_list|(
name|from
argument_list|,
name|to_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Generate code for computing expression EXP,    and storing the value into TARGET.     If the mode is BLKmode then we may return TARGET itself.    It turns out that in BLKmode it doesn't cause a problem.    because C has no operators that could combine two different    assignments into the same BLKmode object with different values    with no sequence point.  Will other languages need this to    be more thorough?     If CALL_PARAM_P is nonzero, this is a store into a call param on the    stack, and block moves may need to be treated specially.  */
end_comment

begin_function
name|rtx
name|store_expr
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|call_param_p
parameter_list|)
block|{
name|rtx
name|temp
decl_stmt|;
name|rtx
name|alt_rtl
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|dont_return_target
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
comment|/* C++ can generate ?: expressions with a throw expression in one 	 branch and an rvalue in the other. Here, we resolve attempts to 	 store the throw expression's nonexistent result.  */
name|gcc_assert
argument_list|(
operator|!
name|call_param_p
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
comment|/* Perform first part of compound expression, then assign from second 	 part.  */
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|call_param_p
condition|?
name|EXPAND_STACK_PARM
else|:
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
return|return
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|call_param_p
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COND_EXPR
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
comment|/* For conditional expression, get safe form of the target.  Then 	 test the condition, doing the appropriate assignment on either 	 side.  This avoids the creation of unnecessary temporaries. 	 For non-BLKmode, it is more efficient not to do this.  */
name|rtx
name|lab1
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|,
name|lab2
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|call_param_p
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|target
argument_list|,
name|call_param_p
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab2
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|target
argument_list|)
condition|)
comment|/* If this is a scalar in a register that is stored in a wider mode        than the declared mode, compute the result into its declared mode        and then convert to the wider mode.  Our value is the computed        expression.  */
block|{
name|rtx
name|inner_target
init|=
literal|0
decl_stmt|;
comment|/* We can do the conversion inside EXP, which will often result 	 in some optimizations.  Do the conversion in two steps: first 	 change the signedness, if needed, then the extend.  But don't 	 do this if the type of EXP is a subtype of something else 	 since then the conversion might involve more than just 	 converting modes.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|lang_hooks
operator|.
name|reduce_bit_field_operations
operator|||
operator|(
name|GET_MODE_PRECISION
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
condition|)
name|exp
operator|=
name|fold_convert
argument_list|(
name|lang_hooks
operator|.
name|types
operator|.
name|signed_or_unsigned_type
argument_list|(
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|fold_convert
argument_list|(
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|inner_target
operator|=
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|inner_target
argument_list|,
name|VOIDmode
argument_list|,
name|call_param_p
condition|?
name|EXPAND_STACK_PARM
else|:
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* If TEMP is a VOIDmode constant, use convert_modes to make 	 sure that we properly convert it.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|temp
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|convert_move
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
else|else
block|{
name|temp
operator|=
name|expand_expr_real
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
operator|(
name|call_param_p
condition|?
name|EXPAND_STACK_PARM
else|:
name|EXPAND_NORMAL
operator|)
argument_list|,
operator|&
name|alt_rtl
argument_list|)
expr_stmt|;
comment|/* Return TARGET if it's a specified hardware register. 	 If TARGET is a volatile mem ref, either return TARGET 	 or return a reg copied *from* TARGET; ANSI requires this.  	 Otherwise, if TEMP is not TARGET, return TEMP 	 if it is constant (for efficiency), 	 or if we really want the correct value.  */
if|if
condition|(
operator|!
operator|(
name|target
operator|&&
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|!
operator|(
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
condition|)
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If TEMP is a VOIDmode constant and the mode of the type of EXP is not      the same as that of TARGET, adjust the constant.  This is needed, for      example, in case it is a CONST_DOUBLE and we want only a word-sized      value.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If value was not generated in the target, store it there.      Convert the value to TARGET's type first if necessary and emit the      pending incrementations that have been queued when expanding EXP.      Note that we cannot emit the whole queue blindly because this will      effectively disable the POST_INC optimization later.       If TEMP and TARGET compare equal according to rtx_equal_p, but      one or both of them are volatile memory refs, we have to distinguish      two cases:      - expand_expr has used TARGET.  In this case, we must not generate        another copy.  This can be detected by TARGET being equal according        to == .      - expand_expr has not used TARGET - that means that the source just        happens to have the same RTX form.  Since temp will have been created        by expand_expr, it will compare unequal according to == .        We must generate a copy in this case, to reach the correct number        of volatile memory references.  */
if|if
condition|(
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
operator|||
operator|(
name|temp
operator|!=
name|target
operator|&&
operator|(
name|side_effects_p
argument_list|(
name|temp
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|target
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ERROR_MARK
comment|/* If store_expr stores a DECL whose DECL_RTL(exp) == TARGET, 	 but TARGET is not valid memory reference, TEMP will differ 	 from TARGET although it is really the same location.  */
operator|&&
operator|!
operator|(
name|alt_rtl
operator|&&
name|rtx_equal_p
argument_list|(
name|alt_rtl
argument_list|,
name|target
argument_list|)
operator|)
comment|/* If there's nothing to copy, don't bother.  Don't call 	 expr_size unless necessary, because some front-ends (C++) 	 expr_size-hook must not be given objects that are not 	 supposed to be bit-copied or bit-initialized.  */
operator|&&
name|expr_size
argument_list|(
name|exp
argument_list|)
operator|!=
name|const0_rtx
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dont_return_target
condition|)
block|{
comment|/* In this case, we will return TEMP, 		 so make sure it has the proper mode. 		 But don't forget to store the value into TARGET.  */
name|temp
operator|=
name|convert_to_mode
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* Handle copying a string constant into an array.  The string 	     constant may be shorter than the array.  So copy just the string's 	     actual length, and clear the rest.  First get the size of the data 	     type of the string, which is actually the size of the target.  */
name|rtx
name|size
init|=
name|expr_size
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
condition|)
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|size
argument_list|,
operator|(
name|call_param_p
condition|?
name|BLOCK_OP_CALL_PARM
else|:
name|BLOCK_OP_NORMAL
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Compute the size of the data to copy from the string.  */
name|tree
name|copy_size
init|=
name|size_binop
argument_list|(
name|MIN_EXPR
argument_list|,
name|make_tree
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|copy_size_rtx
init|=
name|expand_expr
argument_list|(
name|copy_size
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|call_param_p
condition|?
name|EXPAND_STACK_PARM
else|:
name|EXPAND_NORMAL
operator|)
argument_list|)
decl_stmt|;
name|rtx
name|label
init|=
literal|0
decl_stmt|;
comment|/* Copy that much.  */
name|copy_size_rtx
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|copy_size_rtx
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|copy_size_rtx
argument_list|,
operator|(
name|call_param_p
condition|?
name|BLOCK_OP_CALL_PARM
else|:
name|BLOCK_OP_NORMAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Figure out how much is left in TARGET that we have to clear. 		 Do all calculations in ptr_mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy_size_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|size
operator|=
name|plus_constant
argument_list|(
name|size
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|copy_size_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|adjust_address
argument_list|(
name|target
argument_list|,
name|BLKmode
argument_list|,
name|INTVAL
argument_list|(
name|copy_size_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|expand_binop
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|size
argument_list|,
name|copy_size_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|copy_size_rtx
argument_list|)
operator|!=
name|Pmode
condition|)
name|copy_size_rtx
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|copy_size_rtx
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|target
operator|=
name|offset_address
argument_list|(
name|target
argument_list|,
name|copy_size_rtx
argument_list|,
name|highest_pow2_factor
argument_list|(
name|copy_size
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|size
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|size
argument_list|)
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|!=
name|const0_rtx
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|size
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle calls that return values in multiple non-contiguous locations. 	 The Irix 6 ABI has examples of this.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
operator|(
name|call_param_p
condition|?
name|BLOCK_OP_CALL_PARM
else|:
name|BLOCK_OP_NORMAL
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|force_operand
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper for categorize_ctor_elements.  Identical interface.  */
end_comment

begin_function
specifier|static
name|bool
name|categorize_ctor_elements_1
parameter_list|(
name|tree
name|ctor
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|p_nz_elts
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|p_elt_count
parameter_list|,
name|bool
modifier|*
name|p_must_clear
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|HOST_WIDE_INT
name|nz_elts
decl_stmt|,
name|elt_count
decl_stmt|;
name|tree
name|value
decl_stmt|,
name|purpose
decl_stmt|;
comment|/* Whether CTOR is a valid constant initializer, in accordance with what      initializer_constant_valid_p does.  If inferred from the constructor      elements, true until proven otherwise.  */
name|bool
name|const_from_elts_p
init|=
name|constructor_static_from_elts_p
argument_list|(
name|ctor
argument_list|)
decl_stmt|;
name|bool
name|const_p
init|=
name|const_from_elts_p
condition|?
name|true
else|:
name|TREE_STATIC
argument_list|(
name|ctor
argument_list|)
decl_stmt|;
name|nz_elts
operator|=
literal|0
expr_stmt|;
name|elt_count
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (ctor)
argument_list|,
argument|idx
argument_list|,
argument|purpose
argument_list|,
argument|value
argument_list|)
block|{
name|HOST_WIDE_INT
name|mult
decl_stmt|;
name|mult
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|purpose
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|tree
name|lo_index
init|=
name|TREE_OPERAND
argument_list|(
name|purpose
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|hi_index
init|=
name|TREE_OPERAND
argument_list|(
name|purpose
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|lo_index
argument_list|,
literal|1
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|hi_index
argument_list|,
literal|1
argument_list|)
condition|)
name|mult
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|hi_index
argument_list|,
literal|1
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|lo_index
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
block|{
name|HOST_WIDE_INT
name|nz
init|=
literal|0
decl_stmt|,
name|ic
init|=
literal|0
decl_stmt|;
name|bool
name|const_elt_p
init|=
name|categorize_ctor_elements_1
argument_list|(
name|value
argument_list|,
operator|&
name|nz
argument_list|,
operator|&
name|ic
argument_list|,
name|p_must_clear
argument_list|)
decl_stmt|;
name|nz_elts
operator|+=
name|mult
operator|*
name|nz
expr_stmt|;
name|elt_count
operator|+=
name|mult
operator|*
name|ic
expr_stmt|;
if|if
condition|(
name|const_from_elts_p
operator|&&
name|const_p
condition|)
name|const_p
operator|=
name|const_elt_p
expr_stmt|;
block|}
break|break;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
if|if
condition|(
operator|!
name|initializer_zerop
argument_list|(
name|value
argument_list|)
condition|)
name|nz_elts
operator|+=
name|mult
expr_stmt|;
name|elt_count
operator|+=
name|mult
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
name|nz_elts
operator|+=
name|mult
operator|*
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|elt_count
operator|+=
name|mult
operator|*
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_CST
case|:
if|if
condition|(
operator|!
name|initializer_zerop
argument_list|(
name|TREE_REALPART
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|nz_elts
operator|+=
name|mult
expr_stmt|;
if|if
condition|(
operator|!
name|initializer_zerop
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|nz_elts
operator|+=
name|mult
expr_stmt|;
name|elt_count
operator|+=
name|mult
expr_stmt|;
break|break;
case|case
name|VECTOR_CST
case|:
block|{
name|tree
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|value
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|initializer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
name|nz_elts
operator|+=
name|mult
expr_stmt|;
name|elt_count
operator|+=
name|mult
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|nz_elts
operator|+=
name|mult
expr_stmt|;
name|elt_count
operator|+=
name|mult
expr_stmt|;
if|if
condition|(
name|const_from_elts_p
operator|&&
name|const_p
condition|)
name|const_p
operator|=
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|p_must_clear
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctor
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctor
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
condition|)
block|{
name|tree
name|init_sub_type
decl_stmt|;
name|bool
name|clear_this
init|=
name|true
decl_stmt|;
if|if
condition|(
operator|!
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|ctor
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We don't expect more than one element of the union to be 	     initialized.  Not sure what we should do otherwise... */
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|ctor
argument_list|)
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|init_sub_type
operator|=
name|TREE_TYPE
argument_list|(
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|ctor
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* ??? We could look at each element of the union, and find the 	     largest element.  Which would avoid comparing the size of the 	     initialized element against any tail padding in the union. 	     Doesn't seem worth the effort...  */
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctor
argument_list|)
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|init_sub_type
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* And now we have to find out if the element itself is fully 		 constructed.  E.g. for union { struct { int a, b; } s; } u 		 = { .s = { .a = 1 } }.  */
if|if
condition|(
name|elt_count
operator|==
name|count_type_elements
argument_list|(
name|init_sub_type
argument_list|,
name|false
argument_list|)
condition|)
name|clear_this
operator|=
name|false
expr_stmt|;
block|}
block|}
operator|*
name|p_must_clear
operator|=
name|clear_this
expr_stmt|;
block|}
operator|*
name|p_nz_elts
operator|+=
name|nz_elts
expr_stmt|;
operator|*
name|p_elt_count
operator|+=
name|elt_count
expr_stmt|;
return|return
name|const_p
return|;
block|}
end_function

begin_comment
comment|/* Examine CTOR to discover:    * how many scalar fields are set to nonzero values,      and place it in *P_NZ_ELTS;    * how many scalar fields in total are in CTOR,      and place it in *P_ELT_COUNT.    * if a type is a union, and the initializer from the constructor      is not the largest element in the union, then set *p_must_clear.     Return whether or not CTOR is a valid static constant initializer, the same    as "initializer_constant_valid_p (CTOR, TREE_TYPE (CTOR)) != 0".  */
end_comment

begin_function
name|bool
name|categorize_ctor_elements
parameter_list|(
name|tree
name|ctor
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|p_nz_elts
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|p_elt_count
parameter_list|,
name|bool
modifier|*
name|p_must_clear
parameter_list|)
block|{
operator|*
name|p_nz_elts
operator|=
literal|0
expr_stmt|;
operator|*
name|p_elt_count
operator|=
literal|0
expr_stmt|;
operator|*
name|p_must_clear
operator|=
name|false
expr_stmt|;
return|return
name|categorize_ctor_elements_1
argument_list|(
name|ctor
argument_list|,
name|p_nz_elts
argument_list|,
name|p_elt_count
argument_list|,
name|p_must_clear
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Count the number of scalars in TYPE.  Return -1 on overflow or    variable-sized.  If ALLOW_FLEXARR is true, don't count flexible    array member at the end of the structure.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|count_type_elements
parameter_list|(
name|tree
name|type
parameter_list|,
name|bool
name|allow_flexarr
parameter_list|)
block|{
specifier|const
name|HOST_WIDE_INT
name|max
init|=
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|telts
init|=
name|array_type_nelts
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|telts
operator|&&
name|host_integerp
argument_list|(
name|telts
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|n
init|=
name|tree_low_cst
argument_list|(
name|telts
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
decl_stmt|;
name|HOST_WIDE_INT
name|m
init|=
name|count_type_elements
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|max
operator|/
name|n
operator|>
name|m
condition|)
return|return
name|n
operator|*
name|m
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
case|case
name|RECORD_TYPE
case|:
block|{
name|HOST_WIDE_INT
name|n
init|=
literal|0
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|t
operator|=
name|count_type_elements
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
block|{
comment|/* Check for structures with flexible array member.  */
name|tree
name|tf
init|=
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|allow_flexarr
operator|&&
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
operator|==
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|tf
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|tf
argument_list|)
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|tf
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|tf
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|tf
argument_list|)
argument_list|)
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>=
literal|0
condition|)
break|break;
return|return
operator|-
literal|1
return|;
block|}
name|n
operator|+=
name|t
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
comment|/* Ho hum.  How in the world do we guess here?  Clearly it isn't 	   right to count the fields.  Guess based on the number of words.  */
name|HOST_WIDE_INT
name|n
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|n
operator|/
name|UNITS_PER_WORD
return|;
block|}
case|case
name|COMPLEX_TYPE
case|:
return|return
literal|2
return|;
case|case
name|VECTOR_TYPE
case|:
return|return
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|type
argument_list|)
return|;
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
literal|1
return|;
case|case
name|VOID_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|LANG_TYPE
case|:
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if EXP contains mostly (3/4)  zeros.  */
end_comment

begin_function
specifier|static
name|int
name|mostly_zeros_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|HOST_WIDE_INT
name|nz_elts
decl_stmt|,
name|count
decl_stmt|,
name|elts
decl_stmt|;
name|bool
name|must_clear
decl_stmt|;
name|categorize_ctor_elements
argument_list|(
name|exp
argument_list|,
operator|&
name|nz_elts
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|must_clear
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_clear
condition|)
return|return
literal|1
return|;
name|elts
operator|=
name|count_type_elements
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|nz_elts
operator|<
name|elts
operator|/
literal|4
return|;
block|}
return|return
name|initializer_zerop
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXP contains all zeros.  */
end_comment

begin_function
specifier|static
name|int
name|all_zeros_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|HOST_WIDE_INT
name|nz_elts
decl_stmt|,
name|count
decl_stmt|;
name|bool
name|must_clear
decl_stmt|;
name|categorize_ctor_elements
argument_list|(
name|exp
argument_list|,
operator|&
name|nz_elts
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|must_clear
argument_list|)
expr_stmt|;
return|return
name|nz_elts
operator|==
literal|0
return|;
block|}
return|return
name|initializer_zerop
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for store_constructor.    TARGET, BITSIZE, BITPOS, MODE, EXP are as for store_field.    TYPE is the type of the CONSTRUCTOR, not the element type.    CLEARED is as for store_constructor.    ALIAS_SET is the alias set to use for any stores.     This provides a recursive shortcut back to store_constructor when it isn't    necessary to go through store_field.  This is so that we can pass through    the cleared field to let store_constructor know that we may not have to    clear a substructure if the outer structure has already been cleared.  */
end_comment

begin_function
specifier|static
name|void
name|store_constructor_field
parameter_list|(
name|rtx
name|target
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|bitsize
parameter_list|,
name|HOST_WIDE_INT
name|bitpos
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|exp
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|cleared
parameter_list|,
name|int
name|alias_set
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
comment|/* We can only call store_constructor recursively if the size and 	 bit position are on a byte boundary.  */
operator|&&
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
operator|&&
operator|(
name|bitsize
operator|>
literal|0
operator|&&
name|bitsize
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
operator|)
comment|/* If we have a nonzero bitpos for a register target, then we just 	 let store_field do the bitfield handling.  This is unlikely to 	 generate unnecessary clear instructions anyways.  */
operator|&&
operator|(
name|bitpos
operator|==
literal|0
operator|||
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|MEM_P
argument_list|(
name|target
argument_list|)
condition|)
name|target
operator|=
name|adjust_address
argument_list|(
name|target
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|BLKmode
operator|||
literal|0
operator|!=
operator|(
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|)
condition|?
name|BLKmode
else|:
name|VOIDmode
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Update the alias set, if required.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|&&
operator|!
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|target
argument_list|)
operator|&&
name|MEM_ALIAS_SET
argument_list|(
name|target
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|target
operator|=
name|copy_rtx
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|target
argument_list|,
name|alias_set
argument_list|)
expr_stmt|;
block|}
name|store_constructor
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|cleared
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
name|store_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|type
argument_list|,
name|alias_set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the value of constructor EXP into the rtx TARGET.    TARGET is either a REG or a MEM; we know it cannot conflict, since    safe_from_p has been called.    CLEARED is true if TARGET is known to have been zero'd.    SIZE is the number of bytes of TARGET we are allowed to modify: this    may not be the same as the size of EXP if we are assigning to a field    which has been packed to exclude padding bits.  */
end_comment

begin_function
specifier|static
name|void
name|store_constructor
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|cleared
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
name|HOST_WIDE_INT
name|exp_size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|value
decl_stmt|;
comment|/* If size is zero or the target is already cleared, do nothing.  */
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|cleared
condition|)
name|cleared
operator|=
literal|1
expr_stmt|;
comment|/* We either clear the aggregate or indicate the value is dead.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
operator|!
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
condition|)
comment|/* If the constructor is empty, clear the union.  */
block|{
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we are building a static constructor into a register, 	   set the initial value as zero so we can fold the value into 	   a constant.  But if more than one register is involved, 	   this probably loses.  */
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the constructor has fewer fields than the structure or 	   if we are initializing the structure to mostly zeros, clear 	   the whole structure first.  Don't do this if TARGET is a 	   register whose mode size isn't equal to SIZE since 	   clear_storage can't handle this case.  */
elseif|else
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
operator|(
operator|(
operator|(
name|int
operator|)
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|fields_length
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|mostly_zeros_p
argument_list|(
name|exp
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|target
argument_list|)
operator|||
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|==
name|size
operator|)
operator|)
condition|)
block|{
name|clear_storage
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cleared
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store each element of the constructor into the 	   corresponding field of TARGET.  */
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (exp)
argument_list|,
argument|idx
argument_list|,
argument|field
argument_list|,
argument|value
argument_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
init|=
literal|0
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|rtx
name|to_rtx
init|=
name|target
decl_stmt|;
comment|/* Just ignore missing fields.  We cleared the whole 	       structure, above, if any fields are missing.  */
if|if
condition|(
name|field
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cleared
operator|&&
name|initializer_zerop
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|bitsize
operator|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|bitsize
operator|=
operator|-
literal|1
expr_stmt|;
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|offset
operator|=
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|bitpos
operator|=
name|int_bit_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|bitpos
operator|=
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|rtx
name|offset_rtx
decl_stmt|;
name|offset
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|offset
argument_list|,
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|offset_rtx
operator|=
name|expand_normal
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|to_rtx
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|Pmode
condition|)
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|ptr_mode
condition|)
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|to_rtx
operator|=
name|offset_address
argument_list|(
name|to_rtx
argument_list|,
name|offset_rtx
argument_list|,
name|highest_pow2_factor
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
comment|/* If this initializes a field that is smaller than a 	       word, at the start of a word, try to widen it to a full 	       word.  This special case allows us to output C++ member 	       function initializations in a form that the optimizers 	       can understand.  */
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|bitsize
operator|<
name|BITS_PER_WORD
operator|&&
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|exp_size
operator|>=
literal|0
operator|&&
name|bitpos
operator|+
name|BITS_PER_WORD
operator|<=
name|exp_size
operator|*
name|BITS_PER_UNIT
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
block|{
name|type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|BITS_PER_WORD
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|value
operator|=
name|fold_build2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|BITS_PER_WORD
operator|-
name|bitsize
argument_list|)
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|BITS_PER_WORD
expr_stmt|;
name|mode
operator|=
name|word_mode
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|MEM_P
argument_list|(
name|to_rtx
argument_list|)
operator|&&
operator|!
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|to_rtx
argument_list|)
operator|&&
name|DECL_NONADDRESSABLE_P
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|store_constructor_field
argument_list|(
name|to_rtx
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|type
argument_list|,
name|cleared
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|value
decl_stmt|,
name|index
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|int
name|need_to_clear
decl_stmt|;
name|tree
name|domain
decl_stmt|;
name|tree
name|elttype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|const_bounds_p
decl_stmt|;
name|HOST_WIDE_INT
name|minelt
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|maxelt
init|=
literal|0
decl_stmt|;
name|domain
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|const_bounds_p
operator|=
operator|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
comment|/* If we have constant bounds for the range of the type, get them.  */
if|if
condition|(
name|const_bounds_p
condition|)
block|{
name|minelt
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|maxelt
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the constructor has fewer elements than the array, clear            the whole array first.  Similarly if this is static            constructor of a non-BLKmode object.  */
if|if
condition|(
name|cleared
condition|)
name|need_to_clear
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
condition|)
name|need_to_clear
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|index
decl_stmt|,
name|value
decl_stmt|;
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|,
name|zero_count
init|=
literal|0
decl_stmt|;
name|need_to_clear
operator|=
operator|!
name|const_bounds_p
expr_stmt|;
comment|/* This loop is a more accurate version of the loop in 	       mostly_zeros_p (it handles RANGE_EXPR in an index).  It 	       is also needed to check for missing elements.  */
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (exp)
argument_list|,
argument|idx
argument_list|,
argument|index
argument_list|,
argument|value
argument_list|)
block|{
name|HOST_WIDE_INT
name|this_node_count
decl_stmt|;
if|if
condition|(
name|need_to_clear
condition|)
break|break;
if|if
condition|(
name|index
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|tree
name|lo_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|hi_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|lo_index
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|hi_index
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|need_to_clear
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|this_node_count
operator|=
operator|(
name|tree_low_cst
argument_list|(
name|hi_index
argument_list|,
literal|1
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|lo_index
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
name|this_node_count
operator|=
literal|1
expr_stmt|;
name|count
operator|+=
name|this_node_count
expr_stmt|;
if|if
condition|(
name|mostly_zeros_p
argument_list|(
name|value
argument_list|)
condition|)
name|zero_count
operator|+=
name|this_node_count
expr_stmt|;
block|}
comment|/* Clear the entire array first if there are any missing 	       elements, or if the incidence of zero elements is>= 	       75%.  */
if|if
condition|(
operator|!
name|need_to_clear
operator|&&
operator|(
name|count
operator|<
name|maxelt
operator|-
name|minelt
operator|+
literal|1
operator|||
literal|4
operator|*
name|zero_count
operator|>=
literal|3
operator|*
name|count
operator|)
condition|)
name|need_to_clear
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_to_clear
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|clear_storage
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cleared
operator|&&
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
comment|/* Inform later passes that the old value is dead.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store each element of the constructor into the 	   corresponding element of TARGET, determined by counting the 	   elements.  */
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (exp)
argument_list|,
argument|i
argument_list|,
argument|index
argument_list|,
argument|value
argument_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|xtarget
init|=
name|target
decl_stmt|;
if|if
condition|(
name|cleared
operator|&&
name|initializer_zerop
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
name|unsignedp
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|bitsize
operator|=
operator|(
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|?
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
else|:
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|tree
name|lo_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|hi_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|index_r
decl_stmt|,
name|pos_rtx
decl_stmt|;
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|count
decl_stmt|;
name|tree
name|position
decl_stmt|;
comment|/* If the range is constant and "small", unroll the loop.  */
if|if
condition|(
name|const_bounds_p
operator|&&
name|host_integerp
argument_list|(
name|lo_index
argument_list|,
literal|0
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|hi_index
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|lo
operator|=
name|tree_low_cst
argument_list|(
name|lo_index
argument_list|,
literal|0
argument_list|)
operator|,
name|hi
operator|=
name|tree_low_cst
argument_list|(
name|hi_index
argument_list|,
literal|0
argument_list|)
operator|,
name|count
operator|=
name|hi
operator|-
name|lo
operator|+
literal|1
operator|,
operator|(
operator|!
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|||
name|count
operator|<=
literal|2
operator|||
operator|(
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
name|count
operator|<=
literal|40
operator|*
literal|8
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|lo
operator|-=
name|minelt
expr_stmt|;
name|hi
operator|-=
name|minelt
expr_stmt|;
for|for
control|(
init|;
name|lo
operator|<=
name|hi
condition|;
name|lo
operator|++
control|)
block|{
name|bitpos
operator|=
name|lo
operator|*
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|&&
operator|!
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|target
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_NONALIASED_COMPONENT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|target
operator|=
name|copy_rtx
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|store_constructor_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|type
argument_list|,
name|cleared
argument_list|,
name|get_alias_set
argument_list|(
name|elttype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rtx
name|loop_start
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|loop_end
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|tree
name|exit_cond
decl_stmt|;
name|expand_normal
argument_list|(
name|hi_index
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|index
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|index_r
operator|=
name|gen_reg_rtx
argument_list|(
name|promote_mode
argument_list|(
name|domain
argument_list|,
name|DECL_MODE
argument_list|(
name|index
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|index
argument_list|,
name|index_r
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|lo_index
argument_list|,
name|index_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Build the head of the loop.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Assign value to element index.  */
name|position
operator|=
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|position
argument_list|,
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|elttype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pos_rtx
operator|=
name|expand_normal
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|offset_address
argument_list|(
name|target
argument_list|,
name|pos_rtx
argument_list|,
name|highest_pow2_factor
argument_list|(
name|position
argument_list|)
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|adjust_address
argument_list|(
name|xtarget
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|store_constructor
argument_list|(
name|value
argument_list|,
name|xtarget
argument_list|,
name|cleared
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|store_expr
argument_list|(
name|value
argument_list|,
name|xtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Generate a conditional jump to exit the loop.  */
name|exit_cond
operator|=
name|build2
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|index
argument_list|,
name|hi_index
argument_list|)
expr_stmt|;
name|jumpif
argument_list|(
name|exit_cond
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Update the loop counter, and jump to the head of 		       the loop.  */
name|expand_assignment
argument_list|(
name|index
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Build the end of the loop.  */
name|emit_label
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|index
operator|!=
literal|0
operator|&&
operator|!
name|host_integerp
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|position
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|index
operator|=
name|ssize_int
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|minelt
condition|)
name|index
operator|=
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|index
argument_list|,
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|elttype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|offset_address
argument_list|(
name|target
argument_list|,
name|expand_normal
argument_list|(
name|position
argument_list|)
argument_list|,
name|highest_pow2_factor
argument_list|(
name|position
argument_list|)
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|adjust_address
argument_list|(
name|xtarget
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|value
argument_list|,
name|xtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
name|bitpos
operator|=
operator|(
operator|(
name|tree_low_cst
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
operator|-
name|minelt
operator|)
operator|*
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
else|else
name|bitpos
operator|=
operator|(
name|i
operator|*
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|&&
operator|!
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|target
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_NONALIASED_COMPONENT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|target
operator|=
name|copy_rtx
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|store_constructor_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|type
argument_list|,
name|cleared
argument_list|,
name|get_alias_set
argument_list|(
name|elttype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|VECTOR_TYPE
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|need_to_clear
decl_stmt|;
name|int
name|icode
init|=
literal|0
decl_stmt|;
name|tree
name|elttype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|elt_size
init|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|eltmode
init|=
name|TYPE_MODE
argument_list|(
name|elttype
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|rtvec
name|vector
init|=
name|NULL
decl_stmt|;
name|unsigned
name|n_elts
decl_stmt|;
name|gcc_assert
argument_list|(
name|eltmode
operator|!=
name|BLKmode
argument_list|)
expr_stmt|;
name|n_elts
operator|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|VECTOR_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|icode
operator|=
operator|(
name|int
operator|)
name|vec_init_optab
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|vector
operator|=
name|rtvec_alloc
argument_list|(
name|n_elts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
name|RTVEC_ELT
argument_list|(
name|vector
argument_list|,
name|i
argument_list|)
operator|=
name|CONST0_RTX
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the constructor has fewer elements than the vector, 	   clear the whole array first.  Similarly if this is static 	   constructor of a non-BLKmode object.  */
if|if
condition|(
name|cleared
condition|)
name|need_to_clear
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
condition|)
name|need_to_clear
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|,
name|zero_count
init|=
literal|0
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|CONSTRUCTOR_ELTS (exp)
argument_list|,
argument|idx
argument_list|,
argument|value
argument_list|)
block|{
name|int
name|n_elts_here
init|=
name|tree_low_cst
argument_list|(
name|int_const_binop
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|count
operator|+=
name|n_elts_here
expr_stmt|;
if|if
condition|(
name|mostly_zeros_p
argument_list|(
name|value
argument_list|)
condition|)
name|zero_count
operator|+=
name|n_elts_here
expr_stmt|;
block|}
comment|/* Clear the entire vector first if there are any missing elements, 	       or if the incidence of zero elements is>= 75%.  */
name|need_to_clear
operator|=
operator|(
name|count
operator|<
name|n_elts
operator|||
literal|4
operator|*
name|zero_count
operator|>=
literal|3
operator|*
name|count
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|need_to_clear
operator|&&
name|size
operator|>
literal|0
operator|&&
operator|!
name|vector
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|clear_storage
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Inform later passes that the old value is dead.  */
if|if
condition|(
operator|!
name|cleared
operator|&&
operator|!
name|vector
operator|&&
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store each element of the constructor into the corresponding 	   element of TARGET, determined by counting the elements.  */
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|,
name|idx
argument_list|,
name|ce
argument_list|)
condition|;
name|idx
operator|++
operator|,
name|i
operator|+=
name|bitsize
operator|/
name|elt_size
control|)
block|{
name|HOST_WIDE_INT
name|eltpos
decl_stmt|;
name|tree
name|value
init|=
name|ce
operator|->
name|value
decl_stmt|;
name|bitsize
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleared
operator|&&
name|initializer_zerop
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ce
operator|->
name|index
condition|)
name|eltpos
operator|=
name|tree_low_cst
argument_list|(
name|ce
operator|->
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|eltpos
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|vector
condition|)
block|{
comment|/* Vector CONSTRUCTORs should only be built from smaller 		   vectors in the case of BLKmode vectors.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|VECTOR_TYPE
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vector
argument_list|,
name|eltpos
argument_list|)
operator|=
name|expand_normal
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|machine_mode
name|value_mode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
condition|?
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
else|:
name|eltmode
decl_stmt|;
name|bitpos
operator|=
name|eltpos
operator|*
name|elt_size
expr_stmt|;
name|store_constructor_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|value_mode
argument_list|,
name|value
argument_list|,
name|type
argument_list|,
name|cleared
argument_list|,
name|get_alias_set
argument_list|(
name|elttype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vector
condition|)
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|gen_rtx_PARALLEL
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|vector
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store the value of EXP (an expression tree)    into a subfield of TARGET which has mode MODE and occupies    BITSIZE bits, starting BITPOS bits from the start of TARGET.    If MODE is VOIDmode, it means that we are storing into a bit-field.     Always return const0_rtx unless we have something particular to    return.     TYPE is the type of the underlying object,     ALIAS_SET is the alias set for the destination.  This value will    (in general) be different from that for TARGET, since TARGET is a    reference to the containing structure.  */
end_comment

begin_function
specifier|static
name|rtx
name|store_field
parameter_list|(
name|rtx
name|target
parameter_list|,
name|HOST_WIDE_INT
name|bitsize
parameter_list|,
name|HOST_WIDE_INT
name|bitpos
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|exp
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|alias_set
parameter_list|)
block|{
name|HOST_WIDE_INT
name|width_mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|const0_rtx
return|;
comment|/* If we have nothing to store, do nothing unless the expression has      side-effects.  */
if|if
condition|(
name|bitsize
operator|==
literal|0
condition|)
return|return
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|bitsize
operator|>=
literal|0
operator|&&
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|width_mask
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If we are storing into an unaligned field of an aligned union that is      in a register, we may have the mode of TARGET being an integer mode but      MODE == BLKmode.  In that case, get an aligned object whose size and      alignment are the same as TARGET and store TARGET into it (we can avoid      the store if the field being stored is the entire width of TARGET).  Then      call ourselves recursively to store the field into a BLKmode version of      that object.  Finally, load from the object into TARGET.  This is not      very efficient in general, but should only be slightly more expensive      than the otherwise-required unaligned accesses.  Perhaps this can be      cleaned up later.  It's tempting to make OBJECT readonly, but it's set      twice, once with emit_move_insn and once via store_field.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
operator|(
name|REG_P
argument_list|(
name|target
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
block|{
name|rtx
name|object
init|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|blk_object
init|=
name|adjust_address
argument_list|(
name|object
argument_list|,
name|BLKmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitsize
operator|!=
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|object
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|store_field
argument_list|(
name|blk_object
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|type
argument_list|,
name|alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|object
argument_list|)
expr_stmt|;
comment|/* We want to return the BLKmode version of the data.  */
return|return
name|blk_object
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
comment|/* We're storing into a struct containing a single __complex.  */
name|gcc_assert
argument_list|(
operator|!
name|bitpos
argument_list|)
expr_stmt|;
return|return
name|store_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* If the structure is in a register or if the component      is a bit field, we cannot use addressing to access it.      Use bit-field techniques or SUBREG to store in it.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
operator|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|!
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
operator|)
operator|||
name|REG_P
argument_list|(
name|target
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
comment|/* If the field isn't aligned enough to store as an ordinary memref, 	 store it as a bit field.  */
operator|||
operator|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|(
operator|(
operator|(
operator|(
name|MEM_ALIGN
argument_list|(
name|target
argument_list|)
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|&&
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|mode
argument_list|,
name|MEM_ALIGN
argument_list|(
name|target
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
operator|)
operator|)
operator|)
comment|/* If the RHS and field are a constant size and the size of the 	 RHS isn't the same size as the bitfield, we must use bitfield 	 operations.  */
operator|||
operator|(
name|bitsize
operator|>=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|compare_tree_int
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|bitsize
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* If EXP is a NOP_EXPR of precision less than its mode, then that 	 implies a mask operation.  If the precision is the same size as 	 the field we're storing into, that mask is redundant.  This is 	 particularly common with bit field assignments generated by the 	 C front end.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|bitsize
operator|==
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|bitsize
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|temp
operator|=
name|expand_normal
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If BITSIZE is narrower than the size of the type of EXP 	 we will be narrowing TEMP.  Normally, what's wanted are the 	 low-order bits.  However, if EXP's type is a record and this is 	 big-endian machine, we want the upper BITSIZE bits.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|bitsize
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|temp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|-
name|bitsize
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Unless MODE is VOIDmode or BLKmode, convert TEMP to 	 MODE.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the modes of TARGET and TEMP are both BLKmode, both 	 must be in memory and BITPOS must be aligned on a byte 	 boundary.  If so, we simply do a block copy.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|temp
argument_list|)
operator|&&
operator|!
operator|(
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|adjust_address
argument_list|(
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|bitsize
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* Store the value in the bitfield.  */
name|store_bit_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
else|else
block|{
comment|/* Now build a reference to just the desired component.  */
name|rtx
name|to_rtx
init|=
name|adjust_address
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|to_rtx
operator|==
name|target
condition|)
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|to_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MEM_KEEP_ALIAS_SET_P
argument_list|(
name|to_rtx
argument_list|)
operator|&&
name|MEM_ALIAS_SET
argument_list|(
name|to_rtx
argument_list|)
operator|!=
literal|0
condition|)
name|set_mem_alias_set
argument_list|(
name|to_rtx
argument_list|,
name|alias_set
argument_list|)
expr_stmt|;
return|return
name|store_expr
argument_list|(
name|exp
argument_list|,
name|to_rtx
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression EXP that may be a COMPONENT_REF, a BIT_FIELD_REF,    an ARRAY_REF, or an ARRAY_RANGE_REF, look for nested operations of these    codes and find the ultimate containing object, which we return.     We set *PBITSIZE to the size in bits that we want, *PBITPOS to the    bit position, and *PUNSIGNEDP to the signedness of the field.    If the position of the field is variable, we store a tree    giving the variable offset (in units) in *POFFSET.    This offset is in addition to the bit position.    If the position is not variable, we store 0 in *POFFSET.     If any of the extraction expressions is volatile,    we store 1 in *PVOLATILEP.  Otherwise we don't change that.     If the field is a bit-field, *PMODE is set to VOIDmode.  Otherwise, it    is a mode that can be used to access the field.  In that case, *PBITSIZE    is redundant.     If the field describes a variable-sized object, *PMODE is set to    VOIDmode and *PBITSIZE is set to -1.  An access cannot be made in    this case, but the address of the object can be found.     If KEEP_ALIGNING is true and the target is STRICT_ALIGNMENT, we don't    look through nodes that serve as markers of a greater alignment than    the one that can be deduced from the expression.  These nodes make it    possible for front-ends to prevent temporaries from being created by    the middle-end on alignment considerations.  For that purpose, the    normal operating mode at high-level is to always pass FALSE so that    the ultimate containing object is really returned; moreover, the    associated predicate handled_component_p will always return TRUE    on these nodes, thus indicating that they are essentially handled    by get_inner_reference.  TRUE should only be passed when the caller    is scanning the expression in order to build another representation    and specifically knows how to handle these nodes; as such, this is    the normal operating mode in the RTL expanders.  */
end_comment

begin_function
name|tree
name|get_inner_reference
parameter_list|(
name|tree
name|exp
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|pbitsize
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|pbitpos
parameter_list|,
name|tree
modifier|*
name|poffset
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|pmode
parameter_list|,
name|int
modifier|*
name|punsignedp
parameter_list|,
name|int
modifier|*
name|pvolatilep
parameter_list|,
name|bool
name|keep_aligning
parameter_list|)
block|{
name|tree
name|size_tree
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|tree
name|offset
init|=
name|size_zero_node
decl_stmt|;
name|tree
name|bit_offset
init|=
name|bitsize_zero_node
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* First get the mode, signedness, and size.  We do this from just the      outermost expression.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|size_tree
operator|=
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|DECL_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|size_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|BIT_FIELD_REF_UNSIGNED
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|size_tree
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|pbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size_tree
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size_tree
argument_list|,
literal|1
argument_list|)
condition|)
name|mode
operator|=
name|BLKmode
operator|,
operator|*
name|pbitsize
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|pbitsize
operator|=
name|tree_low_cst
argument_list|(
name|size_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Compute cumulative bit-offset for nested component-refs and array-refs,      and find the ultimate containing object.  */
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|BIT_FIELD_REF
case|:
name|bit_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_offset
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|this_offset
init|=
name|component_ref_field_offset
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* If this field hasn't been filled in yet, don't go past it. 	       This should only happen when folding expressions made during 	       type construction.  */
if|if
condition|(
name|this_offset
operator|==
literal|0
condition|)
break|break;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|this_offset
argument_list|)
expr_stmt|;
name|bit_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_offset
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Right now we don't do anything with DECL_OFFSET_ALIGN.  */
block|}
break|break;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
block|{
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|low_bound
init|=
name|array_ref_low_bound
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|unit_size
init|=
name|array_ref_element_size
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* We assume all arrays have sizes that are a multiple of a byte. 	       First subtract the lower bound, if any, in the type of the 	       index, then convert to sizetype and multiply by the size of 	       the array element.  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|low_bound
argument_list|)
condition|)
name|index
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|low_bound
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|index
argument_list|)
argument_list|,
name|unit_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REALPART_EXPR
case|:
break|break;
case|case
name|IMAGPART_EXPR
case|:
name|bit_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_offset
argument_list|,
name|bitsize_int
argument_list|(
operator|*
name|pbitsize
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIEW_CONVERT_EXPR
case|:
if|if
condition|(
name|keep_aligning
operator|&&
name|STRICT_ALIGNMENT
operator|&&
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|>
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|BIGGEST_ALIGNMENT
operator|)
operator|&&
operator|(
name|TYPE_ALIGN_OK
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
name|TYPE_ALIGN_OK
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
comment|/* If any reference in the chain is volatile, the effect is volatile.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
operator|*
name|pvolatilep
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* If OFFSET is constant, see if we can return the whole thing as a      constant bit position.  Otherwise, split it up.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|bitsizetype
argument_list|,
name|offset
argument_list|)
argument_list|,
name|bitsize_unit_node
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|tem
argument_list|,
name|bit_offset
argument_list|)
operator|)
operator|&&
name|host_integerp
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
condition|)
operator|*
name|pbitpos
operator|=
name|tree_low_cst
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|,
operator|*
name|poffset
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|pbitpos
operator|=
name|tree_low_cst
argument_list|(
name|bit_offset
argument_list|,
literal|0
argument_list|)
operator|,
operator|*
name|poffset
operator|=
name|offset
expr_stmt|;
operator|*
name|pmode
operator|=
name|mode
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Return a tree of sizetype representing the size, in bytes, of the element    of EXP, an ARRAY_REF.  */
end_comment

begin_function
name|tree
name|array_ref_element_size
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|aligned_size
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|tree
name|elmt_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If a size was specified in the ARRAY_REF, it's the size measured      in alignment units of the element type.  So multiply by that value.  */
if|if
condition|(
name|aligned_size
condition|)
block|{
comment|/* ??? tree_ssa_useless_type_conversion will eliminate casts to 	 sizetype from another type of the same width and signedness.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|aligned_size
argument_list|)
operator|!=
name|sizetype
condition|)
name|aligned_size
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|aligned_size
argument_list|)
expr_stmt|;
return|return
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|aligned_size
argument_list|,
name|size_int
argument_list|(
name|TYPE_ALIGN_UNIT
argument_list|(
name|elmt_type
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Otherwise, take the size from that of the element type.  Substitute      any PLACEHOLDER_EXPR that we have.  */
else|else
return|return
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|elmt_type
argument_list|)
argument_list|,
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a tree representing the lower bound of the array mentioned in    EXP, an ARRAY_REF.  */
end_comment

begin_function
name|tree
name|array_ref_low_bound
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|domain_type
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If a lower bound is specified in EXP, use it.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
return|;
comment|/* Otherwise, if there is a domain type and it has a lower bound, use it,      substituting for a PLACEHOLDER_EXPR as needed.  */
if|if
condition|(
name|domain_type
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|domain_type
argument_list|)
condition|)
return|return
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain_type
argument_list|)
argument_list|,
name|exp
argument_list|)
return|;
comment|/* Otherwise, return a zero of the appropriate type.  */
return|return
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a tree representing the upper bound of the array mentioned in    EXP, an ARRAY_REF.  */
end_comment

begin_function
name|tree
name|array_ref_up_bound
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|domain_type
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If there is a domain type and it has an upper bound, use it, substituting      for a PLACEHOLDER_EXPR as needed.  */
if|if
condition|(
name|domain_type
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|domain_type
argument_list|)
condition|)
return|return
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain_type
argument_list|)
argument_list|,
name|exp
argument_list|)
return|;
comment|/* Otherwise fail.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return a tree representing the offset, in bytes, of the field referenced    by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */
end_comment

begin_function
name|tree
name|component_ref_field_offset
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|aligned_offset
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If an offset was specified in the COMPONENT_REF, it's the offset measured      in units of DECL_OFFSET_ALIGN / BITS_PER_UNIT.  So multiply by that      value.  */
if|if
condition|(
name|aligned_offset
condition|)
block|{
comment|/* ??? tree_ssa_useless_type_conversion will eliminate casts to 	 sizetype from another type of the same width and signedness.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|aligned_offset
argument_list|)
operator|!=
name|sizetype
condition|)
name|aligned_offset
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|aligned_offset
argument_list|)
expr_stmt|;
return|return
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|aligned_offset
argument_list|,
name|size_int
argument_list|(
name|DECL_OFFSET_ALIGN
argument_list|(
name|field
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
return|;
block|}
comment|/* Otherwise, take the offset from that of the field.  Substitute      any PLACEHOLDER_EXPR that we have.  */
else|else
return|return
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if T is an expression that get_inner_reference handles.  */
end_comment

begin_function
name|int
name|handled_component_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|BIT_FIELD_REF
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an rtx VALUE that may contain additions and multiplications, return    an equivalent value that just refers to a register, memory, or constant.    This is done by generating instructions to perform the arithmetic and    returning a pseudo-register containing the value.     The returned value may be a REG, SUBREG, MEM or constant.  */
end_comment

begin_function
name|rtx
name|force_operand
parameter_list|(
name|rtx
name|value
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|;
comment|/* Use subtarget as the target for operand 0 of a binary operation.  */
name|rtx
name|subtarget
init|=
name|get_subtarget
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|value
argument_list|)
decl_stmt|;
comment|/* Check for subreg applied to an expression produced by loop optimizer.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
operator|!
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
block|{
name|value
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Check for a PIC address load.  */
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|&&
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|subtarget
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|subtarget
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|subtarget
return|;
block|}
if|if
condition|(
name|ARITHMETIC_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|op2
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
operator|(
name|REG_P
argument_list|(
name|op2
argument_list|)
operator|&&
name|op2
operator|!=
name|subtarget
operator|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|code
operator|=
name|PLUS
expr_stmt|;
name|op2
operator|=
name|negate_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
comment|/* Check for an addition with OP2 a constant integer and our first          operand a PLUS of a virtual register and something else.  In that          case, we want to emit the sum of the virtual register and the          constant first and then add the other value.  This allows virtual          register instantiation to simply modify the constant rather than          creating another one around this addition.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|rtx
name|temp
init|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|code
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op2
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
return|return
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|code
argument_list|,
name|temp
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
block|}
name|op1
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
name|op2
operator|=
name|force_operand
argument_list|(
name|op2
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT
case|:
return|return
name|expand_mult
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|DIV
case|:
if|if
condition|(
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
return|return
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|code
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
else|else
return|return
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|?
name|RDIV_EXPR
else|:
name|TRUNC_DIV_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|MOD
case|:
return|return
name|expand_divmod
argument_list|(
literal|1
argument_list|,
name|TRUNC_MOD_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|UDIV
case|:
return|return
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
break|break;
case|case
name|UMOD
case|:
return|return
name|expand_divmod
argument_list|(
literal|1
argument_list|,
name|TRUNC_MOD_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
break|break;
case|case
name|ASHIFTRT
case|:
return|return
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|code
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
break|break;
default|default:
return|return
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|code
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|UNARY_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
name|convert_move
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|code
operator|==
name|ZERO_EXTEND
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FIX
case|:
name|expand_fix
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|code
operator|==
name|UNSIGNED_FIX
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|FLOAT
case|:
case|case
name|UNSIGNED_FLOAT
case|:
name|expand_float
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|code
operator|==
name|UNSIGNED_FLOAT
argument_list|)
expr_stmt|;
return|return
name|target
return|;
default|default:
return|return
name|expand_simple_unop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|code
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* On machines that have insn scheduling, we want all memory reference to be      explicit, so we need to deal with such paradoxical SUBREGs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
operator|&&
name|MEM_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|value
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of expand_expr: return nonzero iff there is no way that    EXP can reference X, which is being modified.  TOP_P is nonzero if this    call is going to be used to determine whether we need a temporary    for EXP, as opposed to a recursive call to this function.     It is always safe for this routine to return zero since it merely    searches for optimization opportunities.  */
end_comment

begin_function
name|int
name|safe_from_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|tree
name|exp
parameter_list|,
name|int
name|top_p
parameter_list|)
block|{
name|rtx
name|exp_rtl
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nops
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
comment|/* If EXP has varying size, we MUST use a target since we currently 	 have no way of allocating temporaries of variable size 	 (except for arrays that have TYPE_ARRAY_MAX_SIZE set). 	 So we assume here that something at a higher level has prevented a 	 clash.  This is somewhat bogus, but the best we can do.  Only 	 do this when X is BLKmode and when we are at the top level.  */
operator|||
operator|(
name|top_p
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|||
name|TYPE_ARRAY_MAX_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_ARRAY_MAX_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|)
comment|/* If X is in the outgoing argument area, it is always safe.  */
operator|||
operator|(
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If this is a subreg of a hard register, declare it unsafe, otherwise,      find the underlying pseudo.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
comment|/* Now look at our tree code and possibly recurse.  */
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_declaration
case|:
name|exp_rtl
operator|=
name|DECL_RTL_IF_SET
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_constant
case|:
return|return
literal|1
return|;
case|case
name|tcc_exceptional
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|exp
operator|=
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|,
name|idx
argument_list|,
name|ce
argument_list|)
condition|;
name|idx
operator|++
control|)
if|if
condition|(
operator|(
name|ce
operator|->
name|index
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|ce
operator|->
name|index
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|!
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|ce
operator|->
name|value
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
comment|/* An already-visited SAVE_EXPR? */
else|else
return|return
literal|0
return|;
case|case
name|tcc_statement
case|:
comment|/* The only case we look at here is the DECL_INITIAL inside a 	 DECL_EXPR.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|DECL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|DECL_EXPR_DECL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|!
name|DECL_INITIAL
argument_list|(
name|DECL_EXPR_DECL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|DECL_INITIAL
argument_list|(
name|DECL_EXPR_DECL
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Fall through.  */
case|case
name|tcc_unary
case|:
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|tcc_expression
case|:
case|case
name|tcc_reference
case|:
comment|/* Now do code-specific tests.  EXP_RTL is set to any rtx we find in 	 the expression.  If it is set, we conflict iff we are that rtx or 	 both are in memory.  Otherwise, we check all operands of the 	 expression recursively.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
comment|/* If the operand is static or we are static, we can't conflict. 	     Likewise if we don't conflict with the operand at all.  */
if|if
condition|(
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|||
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, the only way this can conflict is if we are taking 	     the address of a DECL a that address if part of X, which is 	     very rare.  */
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|exp
argument_list|)
operator|||
operator|!
name|MEM_P
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
name|exp_rtl
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|&&
name|alias_sets_conflict_p
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|x
argument_list|)
argument_list|,
name|get_alias_set
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* Assume that the call will clobber all hard registers and 	     all of memory.  */
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|MEM_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
comment|/* Lowered by gimplify.c.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|SAVE_EXPR
case|:
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* If we have an rtx, we do not need to scan our operands.  */
if|if
condition|(
name|exp_rtl
condition|)
break|break;
name|nops
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is a language-specific tree code, it may require 	 special handling.  */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|&&
operator|!
name|lang_hooks
operator|.
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|tcc_type
case|:
comment|/* Should never get a type here.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* If we have an rtl, find any enclosed object.  Then see if we conflict      with it.  */
if|if
condition|(
name|exp_rtl
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp_rtl
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|exp_rtl
operator|=
name|SUBREG_REG
argument_list|(
name|exp_rtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|exp_rtl
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|exp_rtl
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
comment|/* If the rtl is X, then it is not safe.  Otherwise, it is unless both 	 are memory and they conflict.  */
return|return
operator|!
operator|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|exp_rtl
argument_list|)
operator|||
operator|(
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|exp_rtl
argument_list|)
operator|&&
name|true_dependence
argument_list|(
name|exp_rtl
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|rtx_addr_varies_p
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/* If we reach here, it is safe.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the highest power of two that EXP is known to be a multiple of.    This is used in updating alignment of MEMs in array references.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|highest_pow2_factor
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|c0
decl_stmt|,
name|c1
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
comment|/* We can find the lowest bit that's a one.  If the low 	 HOST_BITS_PER_WIDE_INT bits are zero, return BIGGEST_ALIGNMENT. 	 We need to handle this case since we can find it in a COND_EXPR, 	 a MIN_EXPR, or a MAX_EXPR.  If the constant overflows, we have an 	 erroneous program, so return BIGGEST_ALIGNMENT to avoid any 	 later ICE.  */
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|BIGGEST_ALIGNMENT
return|;
else|else
block|{
comment|/* Note: tree_low_cst is intentionally not used here, 	     we don't care about the upper bits.  */
name|c0
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|c0
operator|&=
operator|-
name|c0
expr_stmt|;
return|return
name|c0
condition|?
name|c0
else|:
name|BIGGEST_ALIGNMENT
return|;
block|}
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
name|c0
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
return|;
case|case
name|MULT_EXPR
case|:
name|c0
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c0
operator|*
name|c1
return|;
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
if|if
condition|(
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|c0
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|=
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
literal|1
argument_list|,
name|c0
operator|/
name|c1
argument_list|)
return|;
block|}
break|break;
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
return|return
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
name|c0
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|=
name|highest_pow2_factor
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similar, except that the alignment requirements of TARGET are    taken into account.  Assume it is at least as aligned as its    type, unless it is a COMPONENT_REF in which case the layout of    the structure gives the alignment.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|highest_pow2_factor_for_target
parameter_list|(
name|tree
name|target
parameter_list|,
name|tree
name|exp
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|target_align
decl_stmt|,
name|factor
decl_stmt|;
name|factor
operator|=
name|highest_pow2_factor
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|target_align
operator|=
name|DECL_ALIGN_UNIT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|target_align
operator|=
name|TYPE_ALIGN_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MAX
argument_list|(
name|factor
argument_list|,
name|target_align
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expands variable VAR.  */
end_comment

begin_function
name|void
name|expand_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|var
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
condition|)
comment|/* If this is an inlined copy of a static local variable,        look up the original decl.  */
name|var
operator|=
name|DECL_ORIGIN
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
condition|?
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|var
argument_list|)
else|:
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|var
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|var
argument_list|)
condition|)
comment|/* Should be ignored.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|lang_hooks
operator|.
name|expand_decl
argument_list|(
name|var
argument_list|)
condition|)
comment|/* OK.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
condition|)
name|expand_decl
argument_list|(
name|var
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
condition|)
name|rest_of_decl_compilation
argument_list|(
name|var
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* No expansion needed.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|LABEL_DECL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of expand_expr.  Expand the two operands of a binary    expression EXP0 and EXP1 placing the results in OP0 and OP1.    The value may be stored in TARGET if TARGET is nonzero.  The    MODIFIER argument is as documented by expand_expr.  */
end_comment

begin_function
specifier|static
name|void
name|expand_operands
parameter_list|(
name|tree
name|exp0
parameter_list|,
name|tree
name|exp1
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
modifier|*
name|op0
parameter_list|,
name|rtx
modifier|*
name|op1
parameter_list|,
name|enum
name|expand_modifier
name|modifier
parameter_list|)
block|{
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp1
argument_list|,
literal|1
argument_list|)
condition|)
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|exp0
argument_list|,
name|exp1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|op0
operator|=
name|expand_expr
argument_list|(
name|exp0
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
operator|*
name|op1
operator|=
name|copy_rtx
argument_list|(
operator|*
name|op0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we need to preserve evaluation order, copy exp0 into its own 	 temporary variable so that it can't be clobbered by exp1.  */
if|if
condition|(
name|flag_evaluation_order
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp1
argument_list|)
condition|)
name|exp0
operator|=
name|save_expr
argument_list|(
name|exp0
argument_list|)
expr_stmt|;
operator|*
name|op0
operator|=
name|expand_expr
argument_list|(
name|exp0
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
operator|*
name|op1
operator|=
name|expand_expr
argument_list|(
name|exp1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a MEM that contains constant EXP.  DEFER is as for    output_constant_def and MODIFIER is as for expand_expr.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_expr_constant
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
name|defer
parameter_list|,
name|enum
name|expand_modifier
name|modifier
parameter_list|)
block|{
name|rtx
name|mem
decl_stmt|;
name|mem
operator|=
name|output_constant_def
argument_list|(
name|exp
argument_list|,
name|defer
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
name|mem
operator|=
name|use_anchored_address
argument_list|(
name|mem
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_expr_addr_expr.  Evaluate the address of EXP.    The TARGET, TMODE and MODIFIER arguments are as for expand_expr.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_expr_addr_expr_1
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|tmode
parameter_list|,
name|enum
name|expand_modifier
name|modifier
parameter_list|)
block|{
name|rtx
name|result
decl_stmt|,
name|subtarget
decl_stmt|;
name|tree
name|inner
decl_stmt|,
name|offset
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|int
name|volatilep
decl_stmt|,
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode1
decl_stmt|;
comment|/* If we are taking the address of a constant and are at the top level,      we have to use output_constant_def since we can't call force_const_mem      at top level.  */
comment|/* ??? This should be considered a front-end bug.  We should not be      generating ADDR_EXPR of something that isn't an LVALUE.  The only      exception here is STRING_CST.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|||
name|CONSTANT_CLASS_P
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|expand_expr_constant
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|modifier
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Everything must be something allowed by is_gimple_addressable.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
comment|/* This case will happen via recursion for&a->b.  */
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
comment|/* Recurse and make the output_constant_def clause above handle this.  */
return|return
name|expand_expr_addr_expr_1
argument_list|(
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
case|case
name|REALPART_EXPR
case|:
comment|/* The real part of the complex number is always first, therefore 	 the address is the same as the address of the parent object.  */
name|offset
operator|=
literal|0
expr_stmt|;
name|bitpos
operator|=
literal|0
expr_stmt|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMAGPART_EXPR
case|:
comment|/* The imaginary part of the complex number is always second. 	 The expression is therefore always offset by the size of the 	 scalar type.  */
name|offset
operator|=
literal|0
expr_stmt|;
name|bitpos
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* If the object is a DECL, then expand it for its rtl.  Don't bypass 	 expand_expr, as that can have various side effects; LABEL_DECLs for 	 example, may not have their DECL_RTL set yet.  Assume language 	 specific tree nodes can be expanded in some interesting way.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|>=
name|LAST_AND_UNUSED_TREE_CODE
condition|)
block|{
name|result
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|?
name|EXPAND_INITIALIZER
else|:
name|EXPAND_CONST_ADDRESS
argument_list|)
expr_stmt|;
comment|/* If the DECL isn't in memory, then the DECL wasn't properly 	     marked TREE_ADDRESSABLE, which will be either a front-end 	     or a tree optimizer bug.  */
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? Is this needed anymore?  */
if|if
condition|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|assemble_external
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
condition|)
name|result
operator|=
name|force_operand
argument_list|(
name|result
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Pass FALSE as the last argument to get_inner_reference although 	 we are expanding to RTL.  The rationale is that we know how to 	 handle "aligning nodes" here: we can just bypass them because 	 they won't change the final object whose address will be returned 	 (they actually exist only for that purpose).  */
name|inner
operator|=
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode1
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We must have made progress.  */
name|gcc_assert
argument_list|(
name|inner
operator|!=
name|exp
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|offset
operator|||
name|bitpos
condition|?
name|NULL_RTX
else|:
name|target
expr_stmt|;
name|result
operator|=
name|expand_expr_addr_expr_1
argument_list|(
name|inner
argument_list|,
name|subtarget
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_NORMAL
condition|)
name|result
operator|=
name|force_operand
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL
argument_list|,
name|tmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|result
operator|=
name|convert_memory_address
argument_list|(
name|tmode
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|convert_memory_address
argument_list|(
name|tmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
name|result
operator|=
name|gen_rtx_PLUS
argument_list|(
name|tmode
argument_list|,
name|result
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
else|else
block|{
name|subtarget
operator|=
name|bitpos
condition|?
name|NULL_RTX
else|:
name|target
expr_stmt|;
name|result
operator|=
name|expand_simple_binop
argument_list|(
name|tmode
argument_list|,
name|PLUS
argument_list|,
name|result
argument_list|,
name|tmp
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bitpos
condition|)
block|{
comment|/* Someone beforehand should have rejected taking the address 	 of such an object.  */
name|gcc_assert
argument_list|(
operator|(
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|plus_constant
argument_list|(
name|result
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|<
name|EXPAND_SUM
condition|)
name|result
operator|=
name|force_operand
argument_list|(
name|result
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_expr.  Evaluate EXP, which is an ADDR_EXPR.    The TARGET, TMODE and MODIFIER arguments are as for expand_expr.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_expr_addr_expr
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|tmode
parameter_list|,
name|enum
name|expand_modifier
name|modifier
parameter_list|)
block|{
name|enum
name|machine_mode
name|rmode
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* Target mode of VOIDmode says "whatever's natural".  */
if|if
condition|(
name|tmode
operator|==
name|VOIDmode
condition|)
name|tmode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can get called with some Weird Things if the user does silliness      like "(short)&a".  In that case, convert_memory_address won't do      the right thing, so ignore the given target mode.  */
if|if
condition|(
name|tmode
operator|!=
name|Pmode
operator|&&
name|tmode
operator|!=
name|ptr_mode
condition|)
name|tmode
operator|=
name|Pmode
expr_stmt|;
name|result
operator|=
name|expand_expr_addr_expr_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* Despite expand_expr claims concerning ignoring TMODE when not      strictly convenient, stuff breaks if we don't honor it.  Note      that combined with the above, we only do this for pointer modes.  */
name|rmode
operator|=
name|GET_MODE
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmode
operator|==
name|VOIDmode
condition|)
name|rmode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|rmode
operator|!=
name|tmode
condition|)
name|result
operator|=
name|convert_memory_address
argument_list|(
name|tmode
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* expand_expr: generate code for computing expression EXP.    An rtx for the computed value is returned.  The value is never null.    In the case of a void EXP, const0_rtx is returned.     The value may be stored in TARGET if TARGET is nonzero.    TARGET is just a suggestion; callers must assume that    the rtx returned may not be the same as TARGET.     If TARGET is CONST0_RTX, it means that the value will be ignored.     If TMODE is not VOIDmode, it suggests generating the    result in mode TMODE.  But this is done only when convenient.    Otherwise, TMODE is ignored and the value generated in its natural mode.    TMODE is just a suggestion; callers must assume that    the rtx returned may not have mode TMODE.     Note that TARGET may have neither TMODE nor MODE.  In that case, it    probably will not be used.     If MODIFIER is EXPAND_SUM then when EXP is an addition    we can return an rtx of the form (MULT (REG ...) (CONST_INT ...))    or a nest of (PLUS ...) and (MINUS ...) where the terms are    products as above, or REG or MEM, or constant.    Ordinarily in such cases we would output mul or add instructions    and then return a pseudo reg containing the sum.     EXPAND_INITIALIZER is much like EXPAND_SUM except that    it also marks a label as absolutely required (it can't be dead).    It also makes a ZERO_EXTEND or SIGN_EXTEND instead of emitting extend insns.    This is used for outputting expressions used in initializers.     EXPAND_CONST_ADDRESS says that it is okay to return a MEM    with a constant address even if that address is not normally legitimate.    EXPAND_INITIALIZER and EXPAND_SUM also have this effect.     EXPAND_STACK_PARM is used when expanding to a TARGET on the stack for    a call parameter.  Such targets require special care as we haven't yet    marked TARGET so that it's safe from being trashed by libcalls.  We    don't want to use TARGET for anything but the final result;    Intermediate values must go elsewhere.   Additionally, calls to    emit_block_move will be flagged with BLOCK_OP_CALL_PARM.     If EXP is a VAR_DECL whose DECL_RTL was a MEM with an invalid    address, and ALT_RTL is non-NULL, then *ALT_RTL is set to the    DECL_RTL of the VAR_DECL.  *ALT_RTL is also set if EXP is a    COMPOUND_EXPR whose second argument is such a VAR_DECL, and so on    recursively.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|expand_expr_real_1
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|enum
name|expand_modifier
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|rtx
name|expand_expr_real
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|tmode
parameter_list|,
name|enum
name|expand_modifier
name|modifier
parameter_list|,
name|rtx
modifier|*
name|alt_rtl
parameter_list|)
block|{
name|int
name|rn
init|=
operator|-
literal|1
decl_stmt|;
name|rtx
name|ret
decl_stmt|,
name|last
init|=
name|NULL
decl_stmt|;
comment|/* Handle ERROR_MARK before anybody tries to access its type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
name|ret
operator|=
name|CONST0_RTX
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
return|return
name|ret
condition|?
name|ret
else|:
name|const0_rtx
return|;
block|}
if|if
condition|(
name|flag_non_call_exceptions
condition|)
block|{
name|rn
operator|=
name|lookup_stmt_eh_region
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If rn< 0, then either (1) tree-ssa not used or (2) doesn't throw.  */
if|if
condition|(
name|rn
operator|>=
literal|0
condition|)
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
comment|/* If this is an expression of some kind and it has an associated line      number, then emit the line number before expanding the expression.       We need to save and restore the file and line information so that      errors discovered during expansion are emitted with the right      information.  It would be better of the diagnostic routines      used the file/line information embedded in the tree nodes rather      than globals.  */
if|if
condition|(
name|cfun
operator|&&
name|cfun
operator|->
name|ib_boundaries_block
operator|&&
name|EXPR_HAS_LOCATION
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|location_t
name|saved_location
init|=
name|input_location
decl_stmt|;
name|input_location
operator|=
name|EXPR_LOCATION
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
comment|/* Record where the insns produced belong.  */
name|record_block_change
argument_list|(
name|TREE_BLOCK
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|expand_expr_real_1
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|alt_rtl
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|saved_location
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|expand_expr_real_1
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|alt_rtl
argument_list|)
expr_stmt|;
block|}
comment|/* If using non-call exceptions, mark all insns that may trap.      expand_call() will mark CALL_INSNs before we get to this code,      but it doesn't handle libcalls, and these may trap.  */
if|if
condition|(
name|rn
operator|>=
literal|0
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|next_real_insn
argument_list|(
name|last
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
comment|/* If we want exceptions for non-call insns, any 		 may_trap_p instruction may throw.  */
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
operator|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|GEN_INT
argument_list|(
name|rn
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|expand_expr_real_1
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|tmode
parameter_list|,
name|enum
name|expand_modifier
name|modifier
parameter_list|,
name|rtx
modifier|*
name|alt_rtl
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|temp
decl_stmt|,
name|decl_rtl
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|optab
name|this_optab
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|,
name|original_target
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|tree
name|context
decl_stmt|,
name|subexp0
decl_stmt|,
name|subexp1
decl_stmt|;
name|bool
name|reduce_bit_field
init|=
name|false
decl_stmt|;
define|#
directive|define
name|REDUCE_BIT_FIELD
parameter_list|(
name|expr
parameter_list|)
value|(reduce_bit_field&& !ignore		  \ 				 ? reduce_to_bit_field_precision ((expr), \ 								  target, \ 								  type)	  \ 				 : (expr))
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang_hooks
operator|.
name|reduce_bit_field_operations
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|GET_MODE_PRECISION
argument_list|(
name|mode
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* An operation in what may be a bit-field type needs the 	 result to be reduced to the precision of the bit-field type, 	 which is narrower than that of the type's mode.  */
name|reduce_bit_field
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Use subtarget as the target for operand 0 of a binary operation.  */
name|subtarget
operator|=
name|get_subtarget
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|original_target
operator|=
name|target
expr_stmt|;
name|ignore
operator|=
operator|(
name|target
operator|==
name|const0_rtx
operator|||
operator|(
operator|(
name|code
operator|==
name|NON_LVALUE_EXPR
operator|||
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|COND_EXPR
operator|||
name|code
operator|==
name|VIEW_CONVERT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|)
operator|)
expr_stmt|;
comment|/* If we are going to ignore this result, we need only do something      if there is a side-effect somewhere in the expression.  If there      is, short-circuit the most common cases here.  Note that we must      not call expand_expr with anything but const0_rtx in case this      is an initial expansion of a size that contains a PLACEHOLDER_EXPR.  */
if|if
condition|(
name|ignore
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* Ensure we reference a volatile object even if value is ignored, but 	 don't do this if all we are doing is taking its address.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
condition|)
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|temp
argument_list|)
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
operator|||
name|code
operator|==
name|COMPONENT_REF
operator|||
name|code
operator|==
name|INDIRECT_REF
condition|)
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_binary
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|code
operator|==
name|ARRAY_REF
operator|||
name|code
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|target
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_DECL
case|:
block|{
name|tree
name|function
init|=
name|decl_function_context
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|temp
operator|=
name|label_rtx
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|!=
name|current_function_decl
operator|&&
name|function
operator|!=
literal|0
condition|)
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|SSA_NAME
case|:
return|return
name|expand_expr_real_1
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|PARM_DECL
case|:
case|case
name|VAR_DECL
case|:
comment|/* If a static var's type was incomplete when the decl was written, 	 but the type is complete now, lay out the decl now.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|&&
name|COMPLETE_OR_UNBOUND_ARRAY_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
name|layout_decl
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|FUNCTION_DECL
case|:
case|case
name|RESULT_DECL
case|:
name|decl_rtl
operator|=
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|decl_rtl
argument_list|)
expr_stmt|;
comment|/* Ensure variable marked as used even if it doesn't go through 	 a parser.  If it hasn't be used yet, write out an external 	 definition.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Show we haven't gotten RTL for this yet.  */
name|temp
operator|=
literal|0
expr_stmt|;
comment|/* Variables inherited from containing functions should have 	 been lowered by this point.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|context
operator|||
name|context
operator|==
name|current_function_decl
operator|||
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
comment|/* ??? C++ creates functions that are not TREE_STATIC.  */
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
comment|/* This is the case of an array whose size is to be determined 	 from its initializer, while the initializer is still being parsed. 	 See expand_decl.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|decl_rtl
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|validize_mem
argument_list|(
name|decl_rtl
argument_list|)
expr_stmt|;
comment|/* If DECL_RTL is memory, we are in the normal case and either 	 the address is not valid or it is not a register and -fforce-addr 	 is specified, get the address into a register.  */
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|decl_rtl
argument_list|)
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
block|{
if|if
condition|(
name|alt_rtl
condition|)
operator|*
name|alt_rtl
operator|=
name|decl_rtl
expr_stmt|;
name|decl_rtl
operator|=
name|use_anchored_address
argument_list|(
name|decl_rtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|temp
operator|=
name|replace_equiv_address
argument_list|(
name|decl_rtl
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we got something, return it.  But first, set the alignment 	 if the address is a register.  */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|MEM_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* If the mode of DECL_RTL does not match that of the decl, it 	 must be a promoted value.  We return a SUBREG of the wanted mode, 	 but mark it so that we know that it was already extended.  */
if|if
condition|(
name|REG_P
argument_list|(
name|decl_rtl
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|pmode
decl_stmt|;
comment|/* Get the signedness used for this variable.  Ensure we get the 	     same mode we got when the variable was declared.  */
name|pmode
operator|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
operator|==
name|pmode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|decl_rtl
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_SET
argument_list|(
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|decl_rtl
return|;
case|case
name|INTEGER_CST
case|:
name|temp
operator|=
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* ??? If overflow is set, fold will have done an incomplete job, 	 which can result in (plus xx (const_int 0)), which can get 	 simplified by validate_replace_rtx during virtual register 	 instantiation, which can result in unrecognizable insns. 	 Avoid this by forcing all overflows into registers.  */
if|if
condition|(
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|exp
argument_list|)
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
name|temp
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
case|case
name|VECTOR_CST
case|:
block|{
name|tree
name|tmp
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
condition|)
return|return
name|const_vector_from_tree
argument_list|(
name|exp
argument_list|)
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
name|tree
name|type_for_mode
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|type_for_mode
condition|)
name|tmp
operator|=
name|fold_unary
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|type_for_mode
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmp
condition|)
name|tmp
operator|=
name|build_constructor_from_list
argument_list|(
name|type
argument_list|,
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|tmp
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
case|case
name|CONST_DECL
case|:
return|return
name|expand_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
return|;
case|case
name|REAL_CST
case|:
comment|/* If optimized, generate immediate CONST_DOUBLE 	 which will be turned into memory by reload if necessary.  	 We used to force a register so that loop.c could see it.  But 	 this does not allow gen_* patterns to perform optimizations with 	 the constants.  It also produces two insns in cases like "x = 1.0;". 	 On most machines, floating-point constants are not permitted in 	 many insns, so we'd end up copying it to a register in any case.  	 Now, we do the copying in expand_binop, if appropriate.  */
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
comment|/* Handle evaluating a complex constant in a CONCAT target.  */
if|if
condition|(
name|original_target
operator|&&
name|GET_CODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|rtarg
decl_stmt|,
name|itarg
decl_stmt|;
name|rtarg
operator|=
name|XEXP
argument_list|(
name|original_target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|itarg
operator|=
name|XEXP
argument_list|(
name|original_target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Move the real and imaginary parts separately.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|rtarg
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|itarg
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|rtarg
condition|)
name|emit_move_insn
argument_list|(
name|rtarg
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|!=
name|itarg
condition|)
name|emit_move_insn
argument_list|(
name|itarg
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|original_target
return|;
block|}
comment|/* ... fall through ...  */
case|case
name|STRING_CST
case|:
name|temp
operator|=
name|expand_expr_constant
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* temp contains a constant address. 	 On RISC machines where a constant address isn't valid, 	 make some insns to get that address into a register.  */
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|flag_force_addr
operator|)
condition|)
return|return
name|replace_equiv_address
argument_list|(
name|temp
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|temp
return|;
case|case
name|SAVE_EXPR
case|:
block|{
name|tree
name|val
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|ret
init|=
name|expand_expr_real_1
argument_list|(
name|val
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|alt_rtl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SAVE_EXPR_RESOLVED_P
argument_list|(
name|exp
argument_list|)
condition|)
block|{
comment|/* We can indeed still hit this case, typically via builtin 	       expanders calling save_expr immediately before expanding 	       something.  Assume this means that we only have to deal 	       with non-BLKmode values.  */
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|ret
argument_list|)
operator|!=
name|BLKmode
argument_list|)
expr_stmt|;
name|val
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|val
expr_stmt|;
name|SAVE_EXPR_RESOLVED_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|ret
argument_list|)
condition|)
name|ret
operator|=
name|copy_to_reg
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|val
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
case|case
name|GOTO_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|expand_goto
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expand_computed_goto
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|CONSTRUCTOR
case|:
comment|/* If we don't need the result, just ensure we evaluate any 	 subexpressions.  */
if|if
condition|(
name|ignore
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|CONSTRUCTOR_ELTS (exp)
argument_list|,
argument|idx
argument_list|,
argument|value
argument_list|)
name|expand_expr
argument_list|(
name|value
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* Try to avoid creating a temporary at all.  This is possible 	 if all of the initializer is zero. 	 FIXME: try to handle all [0..255] initializers we can handle 	 with memset.  */
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
operator|&&
name|target
operator|!=
literal|0
operator|&&
name|mode
operator|==
name|BLKmode
operator|&&
name|all_zeros_p
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|BLOCK_OP_NORMAL
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* All elts simple constants => refer to a constant in memory.  But 	 if this is a non-BLKmode mode, let it store a field at a time 	 since that should make a CONST_INT or CONST_DOUBLE when we 	 fold.  Likewise, if we have a target we can use, it is best to 	 store directly into the target unless the type is large enough 	 that memcpy will be used.  If we are making an initializer and 	 all operands are constant, put it in memory as well.  	FIXME: Avoid trying to fill vector constructors piece-meal. 	Output them with output_constant_def below unless we're sure 	they're zeros.  This should go away when vector initializers 	are treated like VECTOR_CST instead of arrays.       */
elseif|else
if|if
condition|(
operator|(
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|&&
operator|!
operator|(
name|target
operator|!=
literal|0
operator|&&
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
operator|||
operator|(
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
operator|!
name|MOVE_BY_PIECES_P
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|mostly_zeros_p
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|||
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|constructor
init|=
name|expand_expr_constant
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|modifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
condition|)
name|constructor
operator|=
name|validize_mem
argument_list|(
name|constructor
argument_list|)
expr_stmt|;
return|return
name|constructor
return|;
block|}
else|else
block|{
comment|/* Handle calls that pass values in multiple non-contiguous 	     locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|PARALLEL
operator|||
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
name|assign_temp
argument_list|(
name|build_qualified_type
argument_list|(
name|type
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
operator|(
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|*
name|TYPE_QUAL_CONST
operator|)
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_constructor
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|int_expr_size
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|exp1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_WRITE
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|fold_read_from_constant_string
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|expand_expr
argument_list|(
name|t
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|exp1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ALIGN_INDIRECT_REF
condition|)
block|{
name|int
name|align
init|=
name|TYPE_ALIGN_UNIT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|op0
operator|=
name|gen_rtx_AND
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|align
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|temp
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Resolve the misalignment now, so that we don't have to remember 	   to resolve it later.  Of course, this only works for reads.  */
comment|/* ??? When we get around to supporting writes, we'll have to handle 	   this in store_expr directly.  The vectorizer isn't generating 	   those yet, however.  */
if|if
condition|(
name|code
operator|==
name|MISALIGNED_INDIRECT_REF
condition|)
block|{
name|int
name|icode
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
name|gcc_assert
argument_list|(
name|modifier
operator|==
name|EXPAND_NORMAL
operator|||
name|modifier
operator|==
name|EXPAND_STACK_PARM
argument_list|)
expr_stmt|;
comment|/* The vectorizer should have already checked the mode.  */
name|icode
operator|=
name|movmisalign_optab
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
name|gcc_assert
argument_list|(
name|icode
operator|!=
name|CODE_FOR_nothing
argument_list|)
expr_stmt|;
comment|/* We've already validated the memory, and we're creating a 	       new pseudo destination.  The predicates really can't fail.  */
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Nor can the insn generator.  */
name|insn
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
return|return
name|temp
return|;
block|}
case|case
name|TARGET_MEM_REF
case|:
block|{
name|struct
name|mem_address
name|addr
decl_stmt|;
name|get_address_description
argument_list|(
name|exp
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
name|op0
operator|=
name|addr_for_mem_ref
argument_list|(
operator|&
name|addr
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|temp
argument_list|,
name|TMR_ORIGINAL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
case|case
name|ARRAY_REF
case|:
block|{
name|tree
name|array
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Fold an expression like: "foo"[2]. 	   This is not done in fold so it won't happen inside&. 	   Don't fold if this is for wide characters since it's too 	   difficult to do correctly and this is a very rare case.  */
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_MEMORY
condition|)
block|{
name|tree
name|t
init|=
name|fold_read_from_constant_string
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|expand_expr
argument_list|(
name|t
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
comment|/* If this is a constant index into a constant array, 	   just get the value from the array.  Handle both the cases when 	   we have an explicit constructor and when our operand is a variable 	   that was declared const.  */
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_MEMORY
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|ix
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|value
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (array)
argument_list|,
argument|ix
argument_list|,
argument|field
argument_list|,
argument|value
argument_list|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|field
argument_list|,
name|index
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|value
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|optimize
operator|>=
literal|1
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_MEMORY
operator|&&
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|array
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|ix
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|value
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (init)
argument_list|,
argument|ix
argument_list|,
argument|field
argument_list|,
argument|value
argument_list|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|field
argument_list|,
name|index
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|value
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|tree
name|index1
init|=
name|index
decl_stmt|;
name|tree
name|low_bound
init|=
name|array_ref_low_bound
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|index1
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Optimize the special-case of a zero lower bound. 		     		       We convert the low_bound to sizetype to avoid some problems 		       with constant folding.  (E.g. suppose the lower bound is 1, 		       and its mode is QI.  Without the conversion,l (ARRAY 		       +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1)) 		       +INDEX), which becomes (ARRAY+255+INDEX).  Opps!)  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|low_bound
argument_list|)
condition|)
name|index1
operator|=
name|size_diffop
argument_list|(
name|index1
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|low_bound
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|compare_tree_int
argument_list|(
name|index1
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
condition|)
return|return
name|gen_int_mode
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|init
argument_list|)
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|index1
argument_list|)
index|]
argument_list|,
name|mode
argument_list|)
return|;
block|}
block|}
block|}
block|}
block|}
goto|goto
name|normal_inner_ref
goto|;
case|case
name|COMPONENT_REF
case|:
comment|/* If the operand is a CONSTRUCTOR, we can just extract the 	 appropriate field if it is present.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|value
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (TREE_OPERAND (exp,
literal|0
argument|))
argument_list|,
argument|idx
argument_list|,
argument|field
argument_list|,
argument|value
argument_list|)
if|if
condition|(
name|field
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
comment|/* We can normally use the value of the field in the 		   CONSTRUCTOR.  However, if this is a bitfield in 		   an integral mode that we can fit in a HOST_WIDE_INT, 		   we must mask only the number of bits in the bitfield, 		   since this is done implicitly by the constructor.  If 		   the bitfield does not meet either of those conditions, 		   we can't do this optimization.  */
operator|&&
operator|(
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|||
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|DECL_MODE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|DECL_MODE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|&&
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|value
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|bitsize
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|imode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|op1
operator|=
name|GEN_INT
argument_list|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_and
argument_list|(
name|imode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|count
init|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|imode
argument_list|)
operator|-
name|bitsize
argument_list|)
decl_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|imode
argument_list|,
name|op0
argument_list|,
name|count
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|imode
argument_list|,
name|op0
argument_list|,
name|count
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|op0
return|;
block|}
block|}
goto|goto
name|normal_inner_ref
goto|;
case|case
name|BIT_FIELD_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
name|normal_inner_ref
label|:
block|{
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
name|tree
name|tem
init|=
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode1
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|rtx
name|orig_op0
decl_stmt|;
comment|/* If we got back the original object, something is wrong.  Perhaps 	   we are evaluating an expression too early.  In any event, don't 	   infinitely recurse.  */
name|gcc_assert
argument_list|(
name|tem
operator|!=
name|exp
argument_list|)
expr_stmt|;
comment|/* If TEM's type is a union of variable size, pass TARGET to the inner 	   computation, since it will need a temporary and TARGET is known 	   to have to do.  This occurs in unchecked conversion in Ada.  */
name|orig_op0
operator|=
name|op0
operator|=
name|expand_expr
argument_list|(
name|tem
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|&&
name|modifier
operator|!=
name|EXPAND_STACK_PARM
condition|?
name|target
else|:
name|NULL_RTX
operator|)
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|||
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|||
name|modifier
operator|==
name|EXPAND_STACK_PARM
operator|)
condition|?
name|modifier
else|:
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* If this is a constant, put it into a register if it is a legitimate 	   constant, OFFSET is 0, and we won't try to extract outside the 	   register (in case we were passed a partially uninitialized object 	   or a view_conversion to a larger size).  Force the constant to 	   memory otherwise.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|offset
operator|==
literal|0
operator|&&
name|bitpos
operator|+
name|bitsize
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, if this object not in memory and we either have an 	   offset, a BLKmode result, or a reference outside the object, put it 	   there.  Such cases can occur in Ada if we have unchecked conversion 	   of an expression from a scalar type to an array or record type or 	   for an ARRAY_RANGE_REF whose type is BLKmode.  */
elseif|else
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|offset
operator|!=
literal|0
operator|||
operator|(
name|bitpos
operator|+
name|bitsize
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|code
operator|==
name|ARRAY_RANGE_REF
operator|&&
name|mode
operator|==
name|BLKmode
operator|)
operator|)
condition|)
block|{
name|tree
name|nt
init|=
name|build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
operator|(
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator||
name|TYPE_QUAL_CONST
operator|)
argument_list|)
decl_stmt|;
name|rtx
name|memloc
init|=
name|assign_temp
argument_list|(
name|nt
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|memloc
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memloc
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset_rtx
init|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|Pmode
condition|)
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|ptr_mode
condition|)
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BLKmode
comment|/* A constant address in OP0 can have VOIDmode, we must 		   not try to call force_reg in that case.  */
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|bitsize
operator|!=
literal|0
operator|&&
operator|(
name|bitpos
operator|%
name|bitsize
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bitsize
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
operator|==
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
condition|)
block|{
name|op0
operator|=
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|bitpos
operator|=
literal|0
expr_stmt|;
block|}
name|op0
operator|=
name|offset_address
argument_list|(
name|op0
argument_list|,
name|offset_rtx
argument_list|,
name|highest_pow2_factor
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If OFFSET is making OP0 more aligned than BIGGEST_ALIGNMENT, 	   record its alignment as BIGGEST_ALIGNMENT.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|bitpos
operator|==
literal|0
operator|&&
name|offset
operator|!=
literal|0
operator|&&
name|is_aligning_offset
argument_list|(
name|offset
argument_list|,
name|tem
argument_list|)
condition|)
name|set_mem_align
argument_list|(
name|op0
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
comment|/* Don't forget about volatility even if this is a bitfield.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|volatilep
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
if|if
condition|(
name|op0
operator|==
name|orig_op0
condition|)
name|op0
operator|=
name|copy_rtx
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The following code doesn't handle CONCAT. 	   Assume only bitpos == 0 can be used for CONCAT, due to 	   one element arrays having the same mode as its element.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|gcc_assert
argument_list|(
name|bitpos
operator|==
literal|0
operator|&&
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
comment|/* In cases where an aligned union has an unaligned object 	   as a field, we might be extracting a BLKmode value from 	   an integer-mode (e.g., SImode) object.  Handle this case 	   by doing the extract into an object as wide as the field 	   (which we know to be the width of a basic mode), then 	   storing into memory, and changing the mode to BLKmode.  */
if|if
condition|(
name|mode1
operator|==
name|VOIDmode
operator|||
name|REG_P
argument_list|(
name|op0
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|mode1
operator|!=
name|BLKmode
operator|&&
operator|!
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode1
index|]
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|)
comment|/* If the field isn't aligned enough to fetch as a memref, 	       fetch it as a bit field.  */
operator|||
operator|(
name|mode1
operator|!=
name|BLKmode
operator|&&
operator|(
operator|(
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|MEM_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
operator|||
operator|(
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|)
condition|?
name|STRICT_ALIGNMENT
else|:
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|mode1
argument_list|,
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
operator|)
operator|)
operator|)
comment|/* If the type and the field are a constant size and the 	       size of the type isn't the same size as the bitfield, 	       we must use bitfield operations.  */
operator|||
operator|(
name|bitsize
operator|>=
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|!=
name|compare_tree_int
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|bitsize
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|ext_mode
init|=
name|mode
decl_stmt|;
if|if
condition|(
name|ext_mode
operator|==
name|BLKmode
operator|&&
operator|!
operator|(
name|target
operator|!=
literal|0
operator|&&
name|MEM_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|&&
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
operator|)
condition|)
name|ext_mode
operator|=
name|mode_for_size
argument_list|(
name|bitsize
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_mode
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitsize
operator|==
literal|0
condition|)
return|return
name|target
return|;
comment|/* In this case, BITPOS must start at a byte boundary and 		   TARGET, if specified, must be a MEM.  */
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
operator|!
name|target
operator|||
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|bitsize
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
operator|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|?
name|BLOCK_OP_CALL_PARM
else|:
name|BLOCK_OP_NORMAL
operator|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
name|op0
operator|=
name|validize_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|extract_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
operator|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|?
name|NULL_RTX
else|:
name|target
operator|)
argument_list|,
name|ext_mode
argument_list|,
name|ext_mode
argument_list|)
expr_stmt|;
comment|/* If the result is a record type and BITSIZE is narrower than 	       the mode of OP0, an integral mode, and this is a big endian 	       machine, we must put the field into the high-order bits.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|BYTES_BIG_ENDIAN
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|bitsize
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|op0
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|-
name|bitsize
argument_list|)
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the result type is BLKmode, store the data into a temporary 	       of the appropriate type, but with the mode corresponding to the 	       mode for the data we have (op0's mode).  It's tempting to make 	       this a constant type, since we know it's only being stored once, 	       but that can cause problems if we are taking the address of this 	       COMPONENT_REF because the MEM of any reference via that address 	       will have flags corresponding to the type, which will not 	       necessarily be constant.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|rtx
name|new
init|=
name|assign_stack_temp_for_type
argument_list|(
name|ext_mode
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|ext_mode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|new
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|copy_rtx
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|op0
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|op0
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|op0
return|;
block|}
comment|/* If the result is BLKmode, use that to access the object 	   now as well.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|mode1
operator|=
name|BLKmode
expr_stmt|;
comment|/* Get a reference to just this component.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|||
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
name|op0
operator|=
name|adjust_address_nv
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|orig_op0
condition|)
name|op0
operator|=
name|copy_rtx
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|op0
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
operator||=
name|volatilep
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|mode1
operator|||
name|mode1
operator|==
name|BLKmode
operator|||
name|mode1
operator|==
name|tmode
operator|||
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
return|return
name|op0
return|;
elseif|else
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|OBJ_TYPE_REF
case|:
return|return
name|expand_expr
argument_list|(
name|OBJ_TYPE_REF_EXPR
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
comment|/* Check for a built-in function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BUILT_IN_FRONTEND
condition|)
return|return
name|lang_hooks
operator|.
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|alt_rtl
argument_list|)
return|;
else|else
return|return
name|expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|tmode
argument_list|,
name|ignore
argument_list|)
return|;
block|}
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If both input and output are BLKmode, this conversion isn't doing 	     anything except possibly changing memory attribute.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|rtx
name|result
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
decl_stmt|;
name|result
operator|=
name|copy_rtx
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|result
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MEM_P
argument_list|(
name|target
argument_list|)
condition|)
comment|/* Store data into beginning of memory target.  */
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|adjust_address
argument_list|(
name|target
argument_list|,
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modifier
operator|==
name|EXPAND_STACK_PARM
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store this field into a union of the proper type.  */
name|store_field
argument_list|(
name|target
argument_list|,
name|MIN
argument_list|(
operator|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Return the entire union.  */
return|return
name|target
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* If the signedness of the conversion differs and OP0 is 	     a promoted SUBREG, clear that indication since we now 	     have to do the proper extension.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|unsignedp
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op0
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|op0
argument_list|)
return|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|modifier
operator|==
name|EXPAND_SUM
condition|?
name|EXPAND_NORMAL
else|:
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
empty_stmt|;
comment|/* If OP0 is a constant, just convert it into the proper mode.  */
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
name|op0
operator|=
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|inner_mode
argument_list|,
name|subreg_lowpart_offset
argument_list|(
name|mode
argument_list|,
name|inner_mode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|inner_mode
argument_list|,
name|op0
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|inner_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
name|op0
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|unsignedp
condition|?
name|ZERO_EXTEND
else|:
name|SIGN_EXTEND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|target
expr_stmt|;
block|}
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|op0
argument_list|)
return|;
case|case
name|VIEW_CONVERT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* If the input and output modes are both the same, we are done.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|op0
argument_list|)
condition|)
empty_stmt|;
comment|/* If neither mode is BLKmode, and both modes are the same size 	 then we can use gen_lowpart.  */
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
comment|/* If both modes are integral, then we can convert from one to the 	 other.  */
elseif|else
if|if
condition|(
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|op0
operator|=
name|convert_modes
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* As a last resort, spill op0 to memory, and reload it in a  	 different mode.  */
elseif|else
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
comment|/* If the operand is not a MEM, force it into memory.  Since we 	     are going to be changing the mode of the MEM, don't call 	     force_const_mem for constants because we don't allow pool 	     constants to change mode.  */
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
condition|)
name|target
operator|=
name|assign_stack_temp_for_type
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|inner_type
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|target
expr_stmt|;
block|}
comment|/* At this point, OP0 is in the correct mode.  If the output type is such 	 that the operand is known to be aligned, indicate that it is. 	 Otherwise, we need only be concerned about alignment for non-BLKmode 	 results.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|copy_rtx
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_ALIGN_OK
argument_list|(
name|type
argument_list|)
condition|)
name|set_mem_align
argument_list|(
name|op0
argument_list|,
name|MAX
argument_list|(
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|STRICT_ALIGNMENT
operator|&&
name|MEM_ALIGN
argument_list|(
name|op0
argument_list|)
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|temp_size
init|=
name|MAX
argument_list|(
name|int_size_in_bytes
argument_list|(
name|inner_type
argument_list|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|assign_stack_temp_for_type
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|temp_size
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|rtx
name|new_with_op0_mode
init|=
name|adjust_address
argument_list|(
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|new_with_op0_mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|,
operator|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|?
name|BLOCK_OP_CALL_PARM
else|:
name|BLOCK_OP_NORMAL
operator|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|new_with_op0_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|new
expr_stmt|;
block|}
name|op0
operator|=
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|op0
return|;
case|case
name|PLUS_EXPR
case|:
comment|/* If we are adding a constant, a VAR_DECL that is sp, fp, or ap, and 	 something else, make sure we add the register to the constant and 	 then to the other thing.  This case can occur during strength 	 reduction and doing it this way will produce better code if the 	 frame pointer or argument pointer is eliminated.  	 fold-const.c will ensure that the constant is always in the inner 	 PLUS_EXPR, so the only case we need to do anything about is if 	 sp, ap, or fp is our second argument, in which case we must swap 	 the innermost first argument and our second argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|||
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* If the result is to be ptr_mode and we are adding an integer to 	 something, we might be forming a constant.  So try to use 	 plus_constant.  If it produces a sum and we can't accept it, 	 use force_operand.  This allows P =&ARR[const] to generate 	 efficient code on machines where a SYMBOL_REF is not a valid 	 address.  	 If this is an EXPAND_SUM call, always return the sum.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|||
operator|(
name|mode
operator|==
name|ptr_mode
operator|&&
operator|(
name|unsignedp
operator|||
operator|!
name|flag_trapv
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant_part
decl_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
comment|/* Use immed_double_const to ensure that the constant is 		 truncated according to the mode of OP1, then sign extended 		 to a HOST_WIDE_INT.  Using the constant directly can result 		 in non-canonical RTL in a 64x32 cross compile.  */
name|constant_part
operator|=
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|INTVAL
argument_list|(
name|constant_part
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
name|op1
operator|=
name|force_operand
argument_list|(
name|op1
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|op1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant_part
decl_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|?
name|EXPAND_INITIALIZER
else|:
name|EXPAND_SUM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* Return a PLUS if modifier says it's OK.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
return|return
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
goto|goto
name|binop2
goto|;
block|}
comment|/* Use immed_double_const to ensure that the constant is 		 truncated according to the mode of OP1, then sign extended 		 to a HOST_WIDE_INT.  Using the constant directly can result 		 in non-canonical RTL in a 64x32 cross compile.  */
name|constant_part
operator|=
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|INTVAL
argument_list|(
name|constant_part
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|op0
argument_list|)
return|;
block|}
block|}
comment|/* No sense saving up arithmetic to be done 	 if it's all in the wrong mode to form part of an address. 	 And force_operand won't know whether to sign-extend or 	 zero-extend.  */
if|if
condition|(
operator|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|)
operator|||
name|mode
operator|!=
name|ptr_mode
condition|)
block|{
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|const0_rtx
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
goto|goto
name|binop2
goto|;
block|}
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
comment|/* For initializers, we are allowed to return a MINUS of two 	 symbolic constants.  Here we handle all cases when both operands 	 are constant.  */
comment|/* Handle difference of two symbolic constants, 	 for the sake of an initializer.  */
if|if
condition|(
operator|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|)
operator|&&
name|really_constant_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|really_constant_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* If the last operand is a CONST_INT, use plus_constant of 	     the negated constant.  Else make the MINUS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|plus_constant
argument_list|(
name|op0
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
block|}
comment|/* No sense saving up arithmetic to be done 	 if it's all in the wrong mode to form part of an address. 	 And force_operand won't know whether to sign-extend or 	 zero-extend.  */
if|if
condition|(
operator|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|)
operator|||
name|mode
operator|!=
name|ptr_mode
condition|)
goto|goto
name|binop
goto|;
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* Convert A - const to A + (-const).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op1
operator|=
name|negate_rtx
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
block|}
goto|goto
name|binop2
goto|;
case|case
name|MULT_EXPR
case|:
comment|/* If first operand is constant, swap them. 	 Thus the following special case checks need only 	 check the second operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|t1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|t1
expr_stmt|;
block|}
comment|/* Attempt to return something suitable for generating an 	 indexed address, for machines that support that.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|&&
name|mode
operator|==
name|ptr_mode
operator|&&
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|exp1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|gen_int_mode
argument_list|(
name|tree_low_cst
argument_list|(
name|exp1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* Check for multiplying things that have been extended 	 from a narrower type.  If this machine supports multiplying 	 in that narrower type with a result in the desired type, 	 do it that way, and avoid the explicit type-conversion.  */
name|subexp0
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subexp1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* First, check if we have a multiplication of one signed and one 	 unsigned operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|subexp0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|subexp1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|subexp0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|subexp0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|subexp1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|subexp0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|subexp1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|innermode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|subexp0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|this_optab
operator|=
name|usmul_widen_optab
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE_WIDER_MODE
argument_list|(
name|innermode
argument_list|)
condition|)
block|{
if|if
condition|(
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|subexp0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|subexp0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|subexp1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|subexp0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|subexp1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|op1
argument_list|,
operator|&
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|binop3
goto|;
block|}
block|}
block|}
comment|/* Check for a multiplication with matching signedness.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
comment|/* Don't use a widening multiply if a shift will do.  */
operator|&&
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|||
name|exact_log2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* If both operands are extended, they must either both 		  be zero-extended or both be sign-extended.  */
operator|&&
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|op0type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|innermode
init|=
name|TYPE_MODE
argument_list|(
name|op0type
argument_list|)
decl_stmt|;
name|bool
name|zextend_p
init|=
name|TYPE_UNSIGNED
argument_list|(
name|op0type
argument_list|)
decl_stmt|;
name|optab
name|other_optab
init|=
name|zextend_p
condition|?
name|smul_widen_optab
else|:
name|umul_widen_optab
decl_stmt|;
name|this_optab
operator|=
name|zextend_p
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE_2XWIDER_MODE
argument_list|(
name|innermode
argument_list|)
condition|)
block|{
if|if
condition|(
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
else|else
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
goto|goto
name|binop3
goto|;
block|}
elseif|else
if|if
condition|(
name|other_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|innermode
operator|==
name|word_mode
condition|)
block|{
name|rtx
name|htem
decl_stmt|,
name|hipart
decl_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|op1
operator|=
name|convert_modes
argument_list|(
name|innermode
argument_list|,
name|mode
argument_list|,
name|expand_normal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|expand_normal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|other_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|hipart
operator|=
name|gen_highpart
argument_list|(
name|innermode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|htem
operator|=
name|expand_mult_highpart_adjust
argument_list|(
name|innermode
argument_list|,
name|hipart
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|hipart
argument_list|,
name|zextend_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|htem
operator|!=
name|hipart
condition|)
name|emit_move_insn
argument_list|(
name|hipart
argument_list|,
name|htem
argument_list|)
expr_stmt|;
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|temp
argument_list|)
return|;
block|}
block|}
block|}
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
argument_list|)
return|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* Possible optimization: compute the dividend with EXPAND_SUM 	 then if the divisor is constant can optimize the case 	 where some terms of the dividend have coeffs divisible by it.  */
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
case|case
name|RDIV_EXPR
case|:
goto|goto
name|binop
goto|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
if|if
condition|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_divmod
argument_list|(
literal|1
argument_list|,
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* Not used for C.  */
case|case
name|FIX_TRUNC_EXPR
case|:
name|op0
operator|=
name|expand_normal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|expand_fix
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|FLOAT_EXPR
case|:
name|op0
operator|=
name|expand_normal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* expand_float can't figure out what to do if FROM has VOIDmode. 	 So give it the correct mode.  With -O, cse will optimize this.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|expand_float
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|NEGATE_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|optab_for_tree_code
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|)
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|temp
argument_list|)
return|;
case|case
name|ABS_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* ABS_EXPR is not valid for complex arguments.  */
name|gcc_assert
argument_list|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
argument_list|)
expr_stmt|;
comment|/* Unsigned abs is simply the operand.  Testing here means we don't 	 risk generating incorrect code below.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|op0
return|;
return|return
name|expand_abs
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
name|target
operator|=
name|original_target
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|modifier
operator|==
name|EXPAND_STACK_PARM
operator|||
operator|(
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
operator|||
operator|(
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* First try to do it with a special MIN or MAX instruction. 	 If that does not win, use a conditional jump to select the proper 	 value.  */
name|this_optab
operator|=
name|optab_for_tree_code
argument_list|(
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* At this point, a MEM target is no longer useful; we will get better 	 code without it.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* If op1 was placed in target, swap op0 and op1.  */
if|if
condition|(
name|target
operator|!=
name|op0
operator|&&
name|target
operator|==
name|op1
condition|)
block|{
name|temp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|temp
expr_stmt|;
block|}
comment|/* We generate better code and avoid problems with op1 mentioning 	 target by forcing op1 into a pseudo if it isn't a constant.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|{
name|enum
name|rtx_code
name|comparison_code
decl_stmt|;
name|rtx
name|cmpop1
init|=
name|op1
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MAX_EXPR
condition|)
name|comparison_code
operator|=
name|unsignedp
condition|?
name|GEU
else|:
name|GE
expr_stmt|;
else|else
name|comparison_code
operator|=
name|unsignedp
condition|?
name|LEU
else|:
name|LE
expr_stmt|;
comment|/* Canonicalize to comparisons against 0.  */
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
block|{
comment|/* Converting (a>= 1 ? a : 1) into (a> 0 ? a : 1) 	       or (a != 0 ? a : 1) for unsigned. 	       For MIN we are safe converting (a<= 1 ? a : 1) 	       into (a<= 0 ? a : 1)  */
name|cmpop1
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MAX_EXPR
condition|)
name|comparison_code
operator|=
name|unsignedp
condition|?
name|NE
else|:
name|GT
expr_stmt|;
block|}
if|if
condition|(
name|op1
operator|==
name|constm1_rtx
operator|&&
operator|!
name|unsignedp
condition|)
block|{
comment|/* Converting (a>= -1 ? a : -1) into (a>= 0 ? a : -1) 	       and (a<= -1 ? a : -1) into (a< 0 ? a : -1) */
name|cmpop1
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MIN_EXPR
condition|)
name|comparison_code
operator|=
name|LT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_conditional_move
comment|/* Use a conditional move if possible.  */
if|if
condition|(
name|can_conditionally_move_p
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* ??? Same problem as in expmed.c: emit_conditional_move 	       forces a stack adjustment via compare_from_rtx, and we 	       lose the stack adjustment if the sequence we are about 	       to create is discarded.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Try to emit the conditional move.  */
name|insn
operator|=
name|emit_conditional_move
argument_list|(
name|target
argument_list|,
name|comparison_code
argument_list|,
name|op0
argument_list|,
name|cmpop1
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* If we could do the conditional move, emit the sequence, 	       and return.  */
if|if
condition|(
name|insn
condition|)
block|{
name|rtx
name|seq
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Otherwise discard the sequence and fall back to code with 	       branches.  */
name|end_sequence
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|target
operator|!=
name|op0
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|target
argument_list|,
name|cmpop1
argument_list|,
name|comparison_code
argument_list|,
name|unsignedp
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|BIT_NOT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
comment|/* ??? Can optimize bitwise operations with one arg constant. 	 Can optimize (a bitwise1 n) bitwise2 (a bitwise3 b) 	 and (a bitwise1 b) bitwise2 b (etc) 	 but that is probably not worth while.  */
comment|/* BIT_AND_EXPR is for bitwise anding.  TRUTH_AND_EXPR is for anding two 	 boolean values when we want in all cases to compute both of them.  In 	 general it is fastest to do TRUTH_AND_EXPR by computing both operands 	 as actual zero-or-1 values and then bitwise anding.  In cases where 	 there cannot be any side effects, better code would be made by 	 treating TRUTH_AND_EXPR like TRUTH_ANDIF_EXPR; but the question is 	 how to recognize those cases.  */
case|case
name|TRUTH_AND_EXPR
case|:
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
case|case
name|BIT_AND_EXPR
case|:
goto|goto
name|binop
goto|;
case|case
name|TRUTH_OR_EXPR
case|:
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
case|case
name|BIT_IOR_EXPR
case|:
goto|goto
name|binop
goto|;
case|case
name|TRUTH_XOR_EXPR
case|:
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
case|case
name|BIT_XOR_EXPR
case|:
goto|goto
name|binop
goto|;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
comment|/* Could determine the answer when only additive constants differ.  Also, 	 the addition of one can be handled by changing the condition.  */
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
name|temp
operator|=
name|do_store_flag
argument_list|(
name|exp
argument_list|,
name|modifier
operator|!=
name|EXPAND_STACK_PARM
condition|?
name|target
else|:
name|NULL_RTX
argument_list|,
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* For foo != 0, load foo, and if it is nonzero load 1 instead.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|original_target
operator|&&
name|REG_P
argument_list|(
name|original_target
argument_list|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|original_target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If temp is constant, we can just compute the result.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|temp
argument_list|)
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|temp
operator|!=
name|original_target
condition|)
block|{
name|enum
name|machine_mode
name|mode1
init|=
name|GET_MODE
argument_list|(
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode1
operator|==
name|VOIDmode
condition|)
name|mode1
operator|=
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
expr_stmt|;
name|temp
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|temp
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|unsignedp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* If no set-flag instruction, must generate a conditional store 	 into a temporary variable.  Drop through and handle this 	 like&& and ||.  */
if|if
condition|(
operator|!
name|ignore
operator|&&
operator|(
name|target
operator|==
literal|0
operator|||
name|modifier
operator|==
name|EXPAND_STACK_PARM
operator|||
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
comment|/* Make sure we don't have a hard reg (such as function's return 		 value) live across basic blocks, if not optimizing.  */
operator|||
operator|(
operator|!
name|optimize
operator|&&
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|exp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|ignore
condition|?
name|const0_rtx
else|:
name|target
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The parser is careful to generate TRUTH_NOT_EXPR 	 only with operands that are always zero or one.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
case|case
name|STATEMENT_LIST
case|:
block|{
name|tree_stmt_iterator
name|iter
decl_stmt|;
name|gcc_assert
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|tsi_start
argument_list|(
name|exp
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|iter
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|iter
argument_list|)
control|)
name|expand_expr
argument_list|(
name|tsi_stmt
argument_list|(
name|iter
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
block|}
return|return
name|const0_rtx
return|;
case|case
name|COND_EXPR
case|:
comment|/* A COND_EXPR with its type being VOID_TYPE represents a 	 conditional jump and is handled in 	 expand_gimple_cond_expr.  */
name|gcc_assert
argument_list|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that COND_EXPRs whose type is a structure or union   	 are required to be constructed to contain assignments of   	 a temporary variable, so that we can evaluate them here   	 for side effect only.  If type is void, we must do likewise.  */
name|gcc_assert
argument_list|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|ignore
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|!=
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* If we are not to produce a result, we have no target.  Otherwise,  	 if a target was specified use it; it will not be used as an  	 intermediate target unless it is safe.  If no target, use a  	 temporary.  */
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_STACK_PARM
operator|&&
name|original_target
operator|&&
name|safe_from_p
argument_list|(
name|original_target
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|mode
ifdef|#
directive|ifdef
name|HAVE_conditional_move
operator|&&
operator|(
operator|!
name|can_conditionally_move_p
argument_list|(
name|mode
argument_list|)
operator|||
name|REG_P
argument_list|(
name|original_target
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|!
name|MEM_P
argument_list|(
name|original_target
argument_list|)
condition|)
name|temp
operator|=
name|original_target
expr_stmt|;
else|else
name|temp
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
name|modifier
operator|==
name|EXPAND_STACK_PARM
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|temp
argument_list|,
name|modifier
operator|==
name|EXPAND_STACK_PARM
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
return|return
name|temp
return|;
case|case
name|VEC_COND_EXPR
case|:
name|target
operator|=
name|expand_vec_cond_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|MODIFY_EXPR
case|:
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
comment|/* Check for |= or&= of a bitfield of size one into another bitfield 	   of size 1.  In this case, (unless we need the result of the 	   assignment) we can do this more efficiently with a 	   test followed by an assignment, if necessary.  	   ??? At this point, we can't get a BIT_FIELD_REF here.  But if 	   things change so we do, this code should be enhanced to 	   support it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|lhs
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|integer_onep
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|int
name|value
init|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_IOR_EXPR
decl_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|value
condition|?
name|label
else|:
literal|0
argument_list|,
name|value
condition|?
literal|0
else|:
name|label
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
case|case
name|RETURN_EXPR
case|:
if|if
condition|(
operator|!
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
name|expand_null_return
argument_list|()
expr_stmt|;
else|else
name|expand_return
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|expand_expr_addr_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
case|case
name|COMPLEX_EXPR
case|:
comment|/* Get the rtx code of the operands.  */
name|op0
operator|=
name|expand_normal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the real (op0) and imaginary (op1) parts to their location.  */
name|write_complex_part
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|write_complex_part
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|REALPART_EXPR
case|:
name|op0
operator|=
name|expand_normal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|read_complex_part
argument_list|(
name|op0
argument_list|,
name|false
argument_list|)
return|;
case|case
name|IMAGPART_EXPR
case|:
name|op0
operator|=
name|expand_normal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|read_complex_part
argument_list|(
name|op0
argument_list|,
name|true
argument_list|)
return|;
case|case
name|RESX_EXPR
case|:
name|expand_resx_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|CATCH_EXPR
case|:
case|case
name|EH_FILTER_EXPR
case|:
case|case
name|TRY_FINALLY_EXPR
case|:
comment|/* Lowered by tree-eh.c.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
case|case
name|CASE_LABEL_EXPR
case|:
case|case
name|VA_ARG_EXPR
case|:
case|case
name|BIND_EXPR
case|:
case|case
name|INIT_EXPR
case|:
case|case
name|CONJ_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|LOOP_EXPR
case|:
case|case
name|EXIT_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
comment|/* Lowered by gimplify.c.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|EXC_PTR_EXPR
case|:
return|return
name|get_exception_pointer
argument_list|(
name|cfun
argument_list|)
return|;
case|case
name|FILTER_EXPR
case|:
return|return
name|get_exception_filter
argument_list|(
name|cfun
argument_list|)
return|;
case|case
name|FDESC_EXPR
case|:
comment|/* Function descriptors are not valid except for as 	 initialization constants, and should not be expanded.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|SWITCH_EXPR
case|:
name|expand_case
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|LABEL_EXPR
case|:
name|expand_label
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|ASM_EXPR
case|:
name|expand_asm_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|WITH_SIZE_EXPR
case|:
comment|/* WITH_SIZE_EXPR expands to its first argument.  The caller should 	 have pulled out the size to use in whatever context it needed.  */
return|return
name|expand_expr_real
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|alt_rtl
argument_list|)
return|;
case|case
name|REALIGN_LOAD_EXPR
case|:
block|{
name|tree
name|oprnd0
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|oprnd1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|oprnd2
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|this_optab
operator|=
name|optab_for_tree_code
argument_list|(
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|expand_operands
argument_list|(
name|oprnd0
argument_list|,
name|oprnd1
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_normal
argument_list|(
name|oprnd2
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_ternary_op
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|DOT_PROD_EXPR
case|:
block|{
name|tree
name|oprnd0
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|oprnd1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|oprnd2
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|expand_operands
argument_list|(
name|oprnd0
argument_list|,
name|oprnd1
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_normal
argument_list|(
name|oprnd2
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_widen_pattern_expr
argument_list|(
name|exp
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|WIDEN_SUM_EXPR
case|:
block|{
name|tree
name|oprnd0
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|oprnd1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|expand_operands
argument_list|(
name|oprnd0
argument_list|,
name|oprnd1
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_widen_pattern_expr
argument_list|(
name|exp
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|REDUC_MAX_EXPR
case|:
case|case
name|REDUC_MIN_EXPR
case|:
case|case
name|REDUC_PLUS_EXPR
case|:
block|{
name|op0
operator|=
name|expand_normal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|this_optab
operator|=
name|optab_for_tree_code
argument_list|(
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|VEC_LSHIFT_EXPR
case|:
case|case
name|VEC_RSHIFT_EXPR
case|:
block|{
name|target
operator|=
name|expand_vec_shift_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
default|default:
return|return
name|lang_hooks
operator|.
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|alt_rtl
argument_list|)
return|;
block|}
comment|/* Here to do an ordinary binary operator.  */
name|binop
label|:
name|expand_operands
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binop2
label|:
name|this_optab
operator|=
name|optab_for_tree_code
argument_list|(
name|code
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|binop3
label|:
if|if
condition|(
name|modifier
operator|==
name|EXPAND_STACK_PARM
condition|)
name|target
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|REDUCE_BIT_FIELD
argument_list|(
name|temp
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|REDUCE_BIT_FIELD
end_undef

begin_escape
end_escape

begin_comment
comment|/* Subroutine of above: reduce EXP to the precision of TYPE (in the    signedness of TYPE), possibly returning the result in TARGET.  */
end_comment

begin_function
specifier|static
name|rtx
name|reduce_to_bit_field_precision
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|HOST_WIDE_INT
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|exp
argument_list|)
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* For constant values, reduce using build_int_cst_type. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|t
init|=
name|build_int_cst_type
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|t
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|rtx
name|mask
decl_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|mask
operator|=
name|immed_double_const
argument_list|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mask
operator|=
name|immed_double_const
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
operator|-
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expand_and
argument_list|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|,
name|mask
argument_list|,
name|target
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|count
init|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|-
name|prec
argument_list|)
decl_stmt|;
name|exp
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|,
name|count
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|,
name|count
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of above: returns 1 if OFFSET corresponds to an offset that    when applied to the address of EXP produces an address known to be    aligned more than BIGGEST_ALIGNMENT.  */
end_comment

begin_function
specifier|static
name|int
name|is_aligning_offset
parameter_list|(
name|tree
name|offset
parameter_list|,
name|tree
name|exp
parameter_list|)
block|{
comment|/* Strip off any conversions.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We must now have a BIT_AND_EXPR with a constant that is one less than      power of 2 and which is larger than BIGGEST_ALIGNMENT.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|BIT_AND_EXPR
operator|||
operator|!
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|||
name|compare_tree_int
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
operator|<=
literal|0
operator|||
operator|!
name|exact_log2
argument_list|(
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Look at the first operand of BIT_AND_EXPR and strip any conversion.      It must be NEGATE_EXPR.  Then strip any more conversions.  */
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|NEGATE_EXPR
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This must now be the address of EXP.  */
return|return
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
operator|==
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the tree node if an ARG corresponds to a string constant or zero    if it doesn't.  If we return nonzero, set *PTR_OFFSET to the offset    in bytes within the string that ARG is accessing.  The type of the    offset will be `sizetype'.  */
end_comment

begin_function
name|tree
name|string_constant
parameter_list|(
name|tree
name|arg
parameter_list|,
name|tree
modifier|*
name|ptr_offset
parameter_list|)
block|{
name|tree
name|array
decl_stmt|,
name|offset
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
operator|*
name|ptr_offset
operator|=
name|size_zero_node
expr_stmt|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|array
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|array
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|!=
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
block|{
name|array
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|arg1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
block|{
name|array
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|arg0
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
operator|*
name|ptr_offset
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|int
name|length
decl_stmt|;
comment|/* Variables initialized to string literals can be handled too.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return
literal|0
return|;
comment|/* If they are read-only, non-volatile and bind locally.  */
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|||
operator|!
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|array
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Avoid const char foo[4] = "abcde";  */
if|if
condition|(
name|DECL_SIZE_UNIT
argument_list|(
name|array
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|array
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|compare_tree_int
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|array
argument_list|)
argument_list|,
name|length
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If variable is bigger than the string literal, OFFSET must be constant 	 and inside of the bounds of the string literal.  */
name|offset
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_tree_int
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|array
argument_list|)
argument_list|,
name|length
argument_list|)
operator|>
literal|0
operator|&&
operator|(
operator|!
name|host_integerp
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
operator|||
name|compare_tree_int
argument_list|(
name|offset
argument_list|,
name|length
argument_list|)
operator|>=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
operator|*
name|ptr_offset
operator|=
name|offset
expr_stmt|;
return|return
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to calculate EXP using a store-flag instruction    and return an rtx for the result.  EXP is either a comparison    or a TRUTH_NOT_EXPR whose operand is a comparison.     If TARGET is nonzero, store the result there if convenient.     If ONLY_CHEAP is nonzero, only do this if it is likely to be very    cheap.     Return zero if there is no suitable set-flag instruction    available on this machine.     Once expand_expr has been called on the arguments of the comparison,    we are committed to doing the store flag, since it is not safe to    re-evaluate the expression.  We emit the store-flag insn by calling    emit_store_flag, but only expand the arguments if we have a reason    to believe that emit_store_flag will be successful.  If we think that    it will, but it isn't, we have to simulate the store-flag with a    set/jump/set sequence.  */
end_comment

begin_function
specifier|static
name|rtx
name|do_store_flag
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|only_cheap
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|enum
name|machine_mode
name|operand_mode
decl_stmt|;
name|int
name|invert
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|subtarget
init|=
name|target
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|label
decl_stmt|;
comment|/* If this is a TRUTH_NOT_EXPR, set a flag indicating we must invert the      result at the end.  We can't simply invert the test since it would      have already been inverted if it were valid.  This case occurs for      some floating-point comparisons.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|invert
operator|=
literal|1
operator|,
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't crash if the comparison was erroneous.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|operand_mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* We won't bother with BLKmode store-flag operations because it would mean      passing a lot of information to emit_store_flag.  */
if|if
condition|(
name|operand_mode
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
comment|/* We won't bother with store-flag operations involving function pointers      when function pointers must be canonicalized before comparisons.  */
ifdef|#
directive|ifdef
name|HAVE_canonicalize_funcptr_for_compare
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* Get the rtx comparison code to use.  We know that EXP is a comparison      operation of some type.  Some comparisons against 1 and -1 can be      converted to comparisons with zero.  Do so here so that the tests      below will be aware that we have a comparison with zero.   These      tests will not catch constants in the first operand, but constants      are rarely passed as the first operand.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|unsignedp
condition|?
name|LEU
else|:
name|LE
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|LTU
else|:
name|LT
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|LT
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|LEU
else|:
name|LE
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|GE
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|GTU
else|:
name|GT
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|unsignedp
condition|?
name|GTU
else|:
name|GT
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|GEU
else|:
name|GE
expr_stmt|;
break|break;
case|case
name|UNORDERED_EXPR
case|:
name|code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|ORDERED_EXPR
case|:
name|code
operator|=
name|ORDERED
expr_stmt|;
break|break;
case|case
name|UNLT_EXPR
case|:
name|code
operator|=
name|UNLT
expr_stmt|;
break|break;
case|case
name|UNLE_EXPR
case|:
name|code
operator|=
name|UNLE
expr_stmt|;
break|break;
case|case
name|UNGT_EXPR
case|:
name|code
operator|=
name|UNGT
expr_stmt|;
break|break;
case|case
name|UNGE_EXPR
case|:
name|code
operator|=
name|UNGE
expr_stmt|;
break|break;
case|case
name|UNEQ_EXPR
case|:
name|code
operator|=
name|UNEQ
expr_stmt|;
break|break;
case|case
name|LTGT_EXPR
case|:
name|code
operator|=
name|LTGT
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Put a constant second.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tem
operator|=
name|arg0
expr_stmt|;
name|arg0
operator|=
name|arg1
expr_stmt|;
name|arg1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* If this is an equality or inequality test of a single bit, we can      do this by shifting the bit being tested to the low-order bit and      masking the result with the constant 1.  If the condition was EQ,      we xor it with 1.  This does not require an scc insn and is faster      than an scc insn even if we have it.       The code to make this transformation was moved into fold_single_bit_test,      so we just call into the folder and expand its result.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|fold_single_bit_test
argument_list|(
name|code
operator|==
name|NE
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|type
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
comment|/* Now see if we are likely to be able to do this.  Return if not.  */
if|if
condition|(
operator|!
name|can_compare_p
argument_list|(
name|code
argument_list|,
name|operand_mode
argument_list|,
name|ccp_store_flag
argument_list|)
condition|)
return|return
literal|0
return|;
name|icode
operator|=
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|||
operator|(
name|only_cheap
operator|&&
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|!=
name|mode
operator|)
condition|)
block|{
comment|/* We can only do this if it is one of the special cases that 	 can be handled without an scc insn.  */
if|if
condition|(
operator|(
name|code
operator|==
name|LT
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|only_cheap
operator|&&
name|code
operator|==
name|GE
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|only_cheap
operator|&&
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
operator|&&
operator|(
operator|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|operand_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|operand_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|get_subtarget
argument_list|(
name|target
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|subtarget
argument_list|)
operator|!=
name|operand_mode
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|expand_operands
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
name|subtarget
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|result
operator|=
name|emit_store_flag
argument_list|(
name|target
argument_list|,
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|operand_mode
argument_list|,
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
if|if
condition|(
name|invert
condition|)
name|result
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* If this failed, we have to do this with set/compare/jump/set code.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|target
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|invert
condition|?
name|const0_rtx
else|:
name|const1_rtx
argument_list|)
expr_stmt|;
name|result
operator|=
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|operand_mode
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
operator|(
name|result
operator|==
name|const0_rtx
operator|&&
operator|!
name|invert
operator|)
operator|||
operator|(
name|result
operator|!=
name|const0_rtx
operator|&&
name|invert
operator|)
operator|)
condition|?
name|const0_rtx
else|:
name|const1_rtx
operator|)
return|;
comment|/* The code of RESULT may not match CODE if compare_from_rtx      decided to swap its operands and reverse the original code.       We know that compare_from_rtx returns either a CONST_INT or      a new comparison code, so it is safe to just extract the      code from RESULT.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|gcc_assert
argument_list|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
call|)
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|invert
condition|?
name|const1_rtx
else|:
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stubs in case we haven't got a casesi insn.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_casesi
end_ifndef

begin_define
define|#
directive|define
name|HAVE_casesi
value|0
end_define

begin_define
define|#
directive|define
name|gen_casesi
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|(0)
end_define

begin_define
define|#
directive|define
name|CODE_FOR_casesi
value|CODE_FOR_nothing
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If the machine does not have a case insn that compares the bounds,    this means extra overhead for dispatch tables, which raises the    threshold for using them.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CASE_VALUES_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|CASE_VALUES_THRESHOLD
value|(HAVE_casesi ? 4 : 5)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CASE_VALUES_THRESHOLD */
end_comment

begin_function
name|unsigned
name|int
name|case_values_threshold
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|CASE_VALUES_THRESHOLD
return|;
block|}
end_function

begin_comment
comment|/* Attempt to generate a casesi instruction.  Returns 1 if successful,    0 otherwise (i.e. if there is no casesi instruction).  */
end_comment

begin_function
name|int
name|try_casesi
parameter_list|(
name|tree
name|index_type
parameter_list|,
name|tree
name|index_expr
parameter_list|,
name|tree
name|minval
parameter_list|,
name|tree
name|range
parameter_list|,
name|rtx
name|table_label
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|default_label
parameter_list|)
block|{
name|enum
name|machine_mode
name|index_mode
init|=
name|SImode
decl_stmt|;
name|int
name|index_bits
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|index_mode
argument_list|)
decl_stmt|;
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|index
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_casesi
condition|)
return|return
literal|0
return|;
comment|/* Convert the index to SImode.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|index_mode
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|omode
init|=
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
decl_stmt|;
name|rtx
name|rangertx
init|=
name|expand_normal
argument_list|(
name|range
argument_list|)
decl_stmt|;
comment|/* We must handle the endpoints in the original mode.  */
name|index_expr
operator|=
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|index_expr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|minval
operator|=
name|integer_zero_node
expr_stmt|;
name|index
operator|=
name|expand_normal
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|rangertx
argument_list|,
name|index
argument_list|,
name|LTU
argument_list|,
name|NULL_RTX
argument_list|,
name|omode
argument_list|,
literal|1
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
comment|/* Now we can safely truncate.  */
name|index
operator|=
name|convert_to_mode
argument_list|(
name|index_mode
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
operator|!=
name|index_mode
condition|)
block|{
name|index_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|index_bits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|index_expr
operator|=
name|fold_convert
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|expand_normal
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|op_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|index
operator|,
name|op_mode
operator|)
condition|)
name|index
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|minval
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|op1
operator|=
name|convert_modes
argument_list|(
name|op_mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|minval
argument_list|)
argument_list|)
argument_list|,
name|op1
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|minval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|op_mode
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_normal
argument_list|(
name|range
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|op2
operator|=
name|convert_modes
argument_list|(
name|op_mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|range
argument_list|)
argument_list|)
argument_list|,
name|op2
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|range
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_casesi
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|op_mode
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|op_mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_casesi
argument_list|(
name|index
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Attempt to generate a tablejump instruction; same concept.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_tablejump
end_ifndef

begin_define
define|#
directive|define
name|HAVE_tablejump
value|0
end_define

begin_define
define|#
directive|define
name|gen_tablejump
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Subroutine of the next function.     INDEX is the value being switched on, with the lowest value    in the table already subtracted.    MODE is its expected mode (needed if INDEX is constant).    RANGE is the length of the jump table.    TABLE_LABEL is a CODE_LABEL rtx for the table itself.     DEFAULT_LABEL is a CODE_LABEL rtx to jump to if the    index value is out of range.  */
end_comment

begin_function
specifier|static
name|void
name|do_tablejump
parameter_list|(
name|rtx
name|index
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|range
parameter_list|,
name|rtx
name|table_label
parameter_list|,
name|rtx
name|default_label
parameter_list|)
block|{
name|rtx
name|temp
decl_stmt|,
name|vector
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|range
argument_list|)
operator|>
name|cfun
operator|->
name|max_jumptable_ents
condition|)
name|cfun
operator|->
name|max_jumptable_ents
operator|=
name|INTVAL
argument_list|(
name|range
argument_list|)
expr_stmt|;
comment|/* Do an unsigned comparison (in the proper mode) between the index      expression and the value which represents the length of the range.      Since we just finished subtracting the lower bound of the range      from the index expression, this comparison allows us to simultaneously      check that the original index expression value is both greater than      or equal to the minimum value of the range and less than or equal to      the maximum value of the range.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|range
argument_list|,
name|GTU
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
comment|/* If index is in range, it must fit in Pmode.      Convert to Pmode so we can index with it.  */
if|if
condition|(
name|mode
operator|!=
name|Pmode
condition|)
name|index
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't let a MEM slip through, because then INDEX that comes      out of PIC_CASE_VECTOR_ADDRESS won't be a valid address,      and break_out_memory_refs will go to work on it and mess it up.  */
ifdef|#
directive|ifdef
name|PIC_CASE_VECTOR_ADDRESS
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|REG_P
argument_list|(
name|index
argument_list|)
condition|)
name|index
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If flag_force_addr were to affect this address      it could interfere with the tricky assumptions made      about addresses that contain label-refs,      which may be valid only very near the tablejump itself.  */
comment|/* ??? The only correct use of CASE_VECTOR_MODE is the one inside the      GET_MODE_SIZE, because this indicates how large insns are.  The other      uses should all be Pmode, because they are addresses.  This code      could fail if addresses and insns are not the same size.  */
name|index
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|index
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|CASE_VECTOR_MODE
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|table_label
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC_CASE_VECTOR_ADDRESS
if|if
condition|(
name|flag_pic
condition|)
name|index
operator|=
name|PIC_CASE_VECTOR_ADDRESS
argument_list|(
name|index
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|index
operator|=
name|memory_address_noforce
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|CASE_VECTOR_MODE
argument_list|)
expr_stmt|;
name|vector
operator|=
name|gen_const_mem
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|vector
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_tablejump
argument_list|(
name|temp
argument_list|,
name|table_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are generating PIC code or if the table is PC-relative, the      table and JUMP_INSN must be adjacent, so don't output a BARRIER.  */
if|if
condition|(
operator|!
name|CASE_VECTOR_PC_RELATIVE
operator|&&
operator|!
name|flag_pic
condition|)
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|try_tablejump
parameter_list|(
name|tree
name|index_type
parameter_list|,
name|tree
name|index_expr
parameter_list|,
name|tree
name|minval
parameter_list|,
name|tree
name|range
parameter_list|,
name|rtx
name|table_label
parameter_list|,
name|rtx
name|default_label
parameter_list|)
block|{
name|rtx
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_tablejump
condition|)
return|return
literal|0
return|;
name|index_expr
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|fold_convert
argument_list|(
name|index_type
argument_list|,
name|index_expr
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|index_type
argument_list|,
name|minval
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|expand_normal
argument_list|(
name|index_expr
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_tablejump
argument_list|(
name|index
argument_list|,
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
argument_list|,
name|convert_modes
argument_list|(
name|TYPE_MODE
argument_list|(
name|index_type
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|range
argument_list|)
argument_list|)
argument_list|,
name|expand_normal
argument_list|(
name|range
argument_list|)
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|range
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|table_label
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if the mode is a valid vector mode for this architecture.    This returns nonzero even if there is no hardware support for the    vector mode, but we can emulate with narrower modes.  */
end_comment

begin_function
name|int
name|vector_mode_valid_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|innermode
decl_stmt|;
comment|/* Doh!  What's going on?  */
if|if
condition|(
name|class
operator|!=
name|MODE_VECTOR_INT
operator|&&
name|class
operator|!=
name|MODE_VECTOR_FLOAT
condition|)
return|return
literal|0
return|;
comment|/* Hardware support.  Woo hoo!  */
if|if
condition|(
name|targetm
operator|.
name|vector_mode_supported_p
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
name|innermode
operator|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* We should probably return 1 if requesting V4DI and we have no DI,      but we have V2DI, but this is probably very unlikely.  */
comment|/* If we have support for the inner mode, we can safely emulate it.      We may not have V2DI, but me can emulate with a pair of DIs.  */
return|return
name|targetm
operator|.
name|scalar_mode_supported_p
argument_list|(
name|innermode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_VECTOR rtx for a VECTOR_CST tree.  */
end_comment

begin_function
specifier|static
name|rtx
name|const_vector_from_tree
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|rtvec
name|v
decl_stmt|;
name|int
name|units
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|link
decl_stmt|,
name|elt
decl_stmt|;
name|enum
name|machine_mode
name|inner
decl_stmt|,
name|mode
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initializer_zerop
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
name|units
operator|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|inner
operator|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|v
operator|=
name|rtvec_alloc
argument_list|(
name|units
argument_list|)
expr_stmt|;
name|link
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|elt
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|REAL_CST
condition|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|elt
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
else|else
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|elt
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|elt
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize remaining elements to 0.  */
for|for
control|(
init|;
name|i
operator|<
name|units
condition|;
operator|++
name|i
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|CONST0_RTX
argument_list|(
name|inner
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|v
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-expr.h"
end_include

end_unit

