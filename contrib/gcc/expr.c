begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert tree expression to rtl instructions, for GNU compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"typeclass.h"
end_include

begin_include
include|#
directive|include
file|"bytecode.h"
end_include

begin_include
include|#
directive|include
file|"bc-opcode.h"
end_include

begin_include
include|#
directive|include
file|"bc-typecd.h"
end_include

begin_include
include|#
directive|include
file|"bc-optab.h"
end_include

begin_include
include|#
directive|include
file|"bc-emit.h"
end_include

begin_define
define|#
directive|define
name|CEIL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + (y) - 1) / (y))
end_define

begin_comment
comment|/* Decide whether a function's arguments should be processed    from first to last or from last to first.     They should if the stack and args grow in opposite directions, but    only if we have push insns.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STACK_GROWS_DOWNWARD
argument_list|)
operator|!=
name|defined
argument_list|(
name|ARGS_GROW_DOWNWARD
argument_list|)
end_if

begin_define
define|#
directive|define
name|PUSH_ARGS_REVERSED
end_define

begin_comment
comment|/* If it's last to first */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_PUSH_CODE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_DEC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_INC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Like STACK_BOUNDARY but in units of bytes, not bits.  */
end_comment

begin_define
define|#
directive|define
name|STACK_BYTES
value|(STACK_BOUNDARY / BITS_PER_UNIT)
end_define

begin_comment
comment|/* If this is nonzero, we do not bother generating VOLATILE    around volatile memory references, and we are willing to    output indirect addresses.  If cse is to follow, we reject    indirect addresses so a useful potential cse is generated;    if it is used only once, instruction combination will produce    the same indirect address eventually.  */
end_comment

begin_decl_stmt
name|int
name|cse_not_expected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to generate code for all the subroutines within an    expression before generating the upper levels of the expression.    Nowadays this is never zero.  */
end_comment

begin_decl_stmt
name|int
name|do_preexpand_calls
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of units that we should eventually pop off the stack.    These are the arguments to function calls that have already returned.  */
end_comment

begin_decl_stmt
name|int
name|pending_stack_adjust
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means stack pops must not be deferred, and deferred stack    pops must not be output.  It is nonzero inside a function call,    inside a conditional expression, inside a statement expression,    and in other cases as well.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_defer_pop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of all cleanups which belong to the arguments of    function calls being expanded by expand_call.  */
end_comment

begin_decl_stmt
name|tree
name|cleanups_this_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When temporaries are created by TARGET_EXPRs, they are created at    this level of temp_slot_level, so that they can remain allocated    until no longer needed.  CLEANUP_POINT_EXPRs define the lifetime    of TARGET_EXPRs.  */
end_comment

begin_decl_stmt
name|int
name|target_temp_slot_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means __builtin_saveregs has already been done in this function.    The value is the pseudoreg containing the value __builtin_saveregs    returned.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|saveregs_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similarly for __builtin_apply_args.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|apply_args_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used by move_by_pieces to describe the move to    be performed.  */
end_comment

begin_struct
struct|struct
name|move_by_pieces
block|{
name|rtx
name|to
decl_stmt|;
name|rtx
name|to_addr
decl_stmt|;
name|int
name|autinc_to
decl_stmt|;
name|int
name|explicit_inc_to
decl_stmt|;
name|int
name|to_struct
decl_stmt|;
name|rtx
name|from
decl_stmt|;
name|rtx
name|from_addr
decl_stmt|;
name|int
name|autinc_from
decl_stmt|;
name|int
name|explicit_inc_from
decl_stmt|;
name|int
name|from_struct
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|reverse
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used to generate bytecodes: keep track of size of local variables,    as well as depth of arithmetic stack. (Notice that variables are    stored on the machine's stack, not the arithmetic stack.) */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|local_vars_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|stack_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|max_stack_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|enqueue_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|queued_subexp_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_queue
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move_by_pieces
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|move_by_pieces_ninsns
name|PROTO
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move_by_pieces_1
name|PROTO
argument_list|(
operator|(
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|,
expr|enum
name|machine_mode
operator|,
expr|struct
name|move_by_pieces
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_constructor
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|store_field
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_inner_unaligned_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|save_noncopied_parts
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|init_noncopied_parts
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|safe_from_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fixed_type_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_pointer_alignment
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|string_constant
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|c_strlen
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|apply_args_size
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|apply_result_size
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|result_vector
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_apply_args
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_apply
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_builtin_return
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_increment
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|bc_expand_increment
name|PROTO
argument_list|(
operator|(
expr|struct
name|increment_operator
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|bc_runtime_type_code
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|bc_allocate_local
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bc_store_memory
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|bc_expand_component_address
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|bc_expand_address
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bc_expand_constructor
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bc_adjust_stack
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|bc_canonicalize_array_ref
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bc_load_memory
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bc_load_externaddr
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bc_load_externaddr_id
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bc_load_localaddr
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bc_load_parmaddr
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|preexpand_calls
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_by_parts_greater
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|do_jump_by_parts_greater_rtx
name|PROTO
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_by_parts_equality
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_by_parts_equality_rtx
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_for_compare
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|compare
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|rtx_code
operator|,
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|do_store_flag
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|defer_cleanups_to
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern void (*interim_eh_hook
end_extern

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|tree
name|truthvalue_conversion
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record for each mode whether we can move a register directly to or    from an object of that mode in memory.  If we can't, we won't try    to use that mode directly when accessing a field of that mode.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|direct_load
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|direct_store
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MOVE_RATIO is the number of move instructions that is better than    a block move.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MOVE_RATIO
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_movstrqi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrhi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrsi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrdi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrti
argument_list|)
end_if

begin_define
define|#
directive|define
name|MOVE_RATIO
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* A value of around 6 would minimize code size; infinity would minimize    execution time.  */
end_comment

begin_define
define|#
directive|define
name|MOVE_RATIO
value|15
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array records the insn_code of insns to perform block moves.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|movstr_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SLOW_UNALIGNED_ACCESS is non-zero if unaligned accesses are very slow. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SLOW_UNALIGNED_ACCESS
end_ifndef

begin_define
define|#
directive|define
name|SLOW_UNALIGNED_ACCESS
value|STRICT_ALIGNMENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Register mappings for target machines without register windows.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INCOMING_REGNO
end_ifndef

begin_define
define|#
directive|define
name|INCOMING_REGNO
parameter_list|(
name|OUT
parameter_list|)
value|(OUT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OUTGOING_REGNO
end_ifndef

begin_define
define|#
directive|define
name|OUTGOING_REGNO
parameter_list|(
name|IN
parameter_list|)
value|(IN)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Maps used to convert modes to const, load, and store bytecodes. */
end_comment

begin_decl_stmt
name|enum
name|bytecode_opcode
name|mode_to_const_map
index|[
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|bytecode_opcode
name|mode_to_load_map
index|[
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|bytecode_opcode
name|mode_to_store_map
index|[
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize maps used to convert modes to const, load, and store    bytecodes. */
end_comment

begin_function
name|void
name|bc_init_mode_to_opcode_maps
parameter_list|()
block|{
name|int
name|mode
decl_stmt|;
for|for
control|(
name|mode
operator|=
literal|0
init|;
name|mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|mode
operator|++
control|)
name|mode_to_const_map
index|[
name|mode
index|]
operator|=
name|mode_to_load_map
index|[
name|mode
index|]
operator|=
name|mode_to_store_map
index|[
name|mode
index|]
operator|=
name|neverneverland
expr_stmt|;
define|#
directive|define
name|DEF_MODEMAP
parameter_list|(
name|SYM
parameter_list|,
name|CODE
parameter_list|,
name|UCODE
parameter_list|,
name|CONST
parameter_list|,
name|LOAD
parameter_list|,
name|STORE
parameter_list|)
define|\
value|mode_to_const_map[(int) SYM] = CONST; \   mode_to_load_map[(int) SYM] = LOAD; \   mode_to_store_map[(int) SYM] = STORE;
include|#
directive|include
file|"modemap.def"
undef|#
directive|undef
name|DEF_MODEMAP
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is run once per compilation to set up which modes can be used    directly in memory and to initialize the block move optab.  */
end_comment

begin_function
name|void
name|init_expr_once
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Try indexing by frame ptr and try by stack ptr.      It is known that on the Convex the stack ptr isn't a valid index.      With luck, one or the other is valid on any machine.  */
name|rtx
name|mem
init|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
decl_stmt|;
name|rtx
name|mem1
init|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|VOIDmode
argument_list|,
name|frame_pointer_rtx
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|mode
operator|<
name|NUM_MACHINE_MODES
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|num_clobbers
decl_stmt|;
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|0
expr_stmt|;
name|PUT_MODE
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|mem1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* See if there is some register that can be used in this mode and 	 directly loaded or stored from memory.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|==
literal|0
operator|||
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|==
literal|0
operator|)
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
continue|continue;
name|reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|mem
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|mem1
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|mem
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|mem1
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is run at the start of compiling a function.  */
end_comment

begin_function
name|void
name|init_expr
parameter_list|()
block|{
name|init_queue
argument_list|()
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
name|inhibit_defer_pop
operator|=
literal|0
expr_stmt|;
name|cleanups_this_call
operator|=
literal|0
expr_stmt|;
name|saveregs_value
operator|=
literal|0
expr_stmt|;
name|apply_args_value
operator|=
literal|0
expr_stmt|;
name|forced_labels
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save all variables describing the current status into the structure *P.    This is used before starting a nested function.  */
end_comment

begin_function
name|void
name|save_expr_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
comment|/* Instead of saving the postincrement queue, empty it.  */
name|emit_queue
argument_list|()
expr_stmt|;
name|p
operator|->
name|pending_stack_adjust
operator|=
name|pending_stack_adjust
expr_stmt|;
name|p
operator|->
name|inhibit_defer_pop
operator|=
name|inhibit_defer_pop
expr_stmt|;
name|p
operator|->
name|cleanups_this_call
operator|=
name|cleanups_this_call
expr_stmt|;
name|p
operator|->
name|saveregs_value
operator|=
name|saveregs_value
expr_stmt|;
name|p
operator|->
name|apply_args_value
operator|=
name|apply_args_value
expr_stmt|;
name|p
operator|->
name|forced_labels
operator|=
name|forced_labels
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
name|inhibit_defer_pop
operator|=
literal|0
expr_stmt|;
name|cleanups_this_call
operator|=
literal|0
expr_stmt|;
name|saveregs_value
operator|=
literal|0
expr_stmt|;
name|apply_args_value
operator|=
literal|0
expr_stmt|;
name|forced_labels
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore all variables describing the current status from the structure *P.    This is used after a nested function.  */
end_comment

begin_function
name|void
name|restore_expr_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|pending_stack_adjust
operator|=
name|p
operator|->
name|pending_stack_adjust
expr_stmt|;
name|inhibit_defer_pop
operator|=
name|p
operator|->
name|inhibit_defer_pop
expr_stmt|;
name|cleanups_this_call
operator|=
name|p
operator|->
name|cleanups_this_call
expr_stmt|;
name|saveregs_value
operator|=
name|p
operator|->
name|saveregs_value
expr_stmt|;
name|apply_args_value
operator|=
name|p
operator|->
name|apply_args_value
expr_stmt|;
name|forced_labels
operator|=
name|p
operator|->
name|forced_labels
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Manage the queue of increment instructions to be output    for POSTINCREMENT_EXPR expressions, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue up to increment (or change) VAR later.  BODY says how:    BODY should be the same thing you would pass to emit_insn    to increment right away.  It will go to emit_insn later on.     The value is a QUEUED expression to be used in place of VAR    where you want to guarantee the pre-incrementation value of VAR.  */
end_comment

begin_function
specifier|static
name|rtx
name|enqueue_insn
parameter_list|(
name|var
parameter_list|,
name|body
parameter_list|)
name|rtx
name|var
decl_stmt|,
name|body
decl_stmt|;
block|{
name|pending_chain
operator|=
name|gen_rtx
argument_list|(
name|QUEUED
argument_list|,
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|var
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|body
argument_list|,
name|pending_chain
argument_list|)
expr_stmt|;
return|return
name|pending_chain
return|;
block|}
end_function

begin_comment
comment|/* Use protect_from_queue to convert a QUEUED expression    into something that you can put immediately into an instruction.    If the queued incrementation has not happened yet,    protect_from_queue returns the variable itself.    If the incrementation has happened, protect_from_queue returns a temp    that contains a copy of the old value of the variable.     Any time an rtx which might possibly be a QUEUED is to be put    into an instruction, it must be passed through protect_from_queue first.    QUEUED expressions are not meaningful in instructions.     Do not pass a value through protect_from_queue and then hold    on to it for a while before putting it in an instruction!    If the queue is flushed in between, incorrect code will result.  */
end_comment

begin_function
name|rtx
name|protect_from_queue
parameter_list|(
name|x
parameter_list|,
name|modify
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* A QUEUED can hang around after the queue is forced out.  */
comment|/* Shortcut for most common case.  */
block|if (pending_chain == 0)     return x;
endif|#
directive|endif
if|if
condition|(
name|code
operator|!=
name|QUEUED
condition|)
block|{
comment|/* A special hack for read access to (MEM (QUEUED ...)) to facilitate 	 use of autoincrement.  Make a copy of the contents of the memory 	 location rather than a copy of the address, but not if the value is 	 of mode BLKmode.  Don't modify X in place since it might be 	 shared.  */
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|QUEUED
operator|&&
operator|!
name|modify
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|new
init|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|QUEUED_VAR
argument_list|(
name|y
argument_list|)
argument_list|)
decl_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|QUEUED_INSN
argument_list|(
name|y
argument_list|)
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
argument_list|,
name|QUEUED_INSN
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|new
return|;
block|}
comment|/* Otherwise, recursively protect the subexpressions of all 	 the kinds of rtx's that can contain a QUEUED.  */
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|rtx
name|tem
init|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|tem
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MULT
condition|)
block|{
name|rtx
name|new0
init|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|new1
init|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|new0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|new1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|new0
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|new1
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
comment|/* If the increment has not happened, use the variable itself.  */
if|if
condition|(
name|QUEUED_INSN
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
return|;
comment|/* If the increment has happened and a pre-increment copy exists,      use that copy.  */
if|if
condition|(
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
return|;
comment|/* The increment has happened but we haven't set up a pre-increment copy.      Set one up now, and use it.  */
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
argument_list|,
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|QUEUED_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X contains a QUEUED expression:    if it contains anything that will be altered by a queued increment.    We handle only combinations of MEM, PLUS, MINUS and MULT operators    since memory addresses generally contain only those.  */
end_comment

begin_function
specifier|static
name|int
name|queued_subexp_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|QUEUED
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Perform all the pending incrementations.  */
end_comment

begin_function
name|void
name|emit_queue
parameter_list|()
block|{
specifier|register
name|rtx
name|p
decl_stmt|;
while|while
condition|(
name|p
operator|=
name|pending_chain
condition|)
block|{
name|QUEUED_INSN
argument_list|(
name|p
argument_list|)
operator|=
name|emit_insn
argument_list|(
name|QUEUED_BODY
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|pending_chain
operator|=
name|QUEUED_NEXT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_queue
parameter_list|()
block|{
if|if
condition|(
name|pending_chain
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy data from FROM to TO, where the machine modes are not the same.    Both modes may be integer, or both may be floating.    UNSIGNEDP should be nonzero if FROM is an unsigned type.    This causes zero-extension instead of sign-extension.  */
end_comment

begin_function
name|void
name|convert_move
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|unsignedp
parameter_list|)
specifier|register
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|machine_mode
name|to_mode
init|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|from_mode
init|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|int
name|to_real
init|=
name|GET_MODE_CLASS
argument_list|(
name|to_mode
argument_list|)
operator|==
name|MODE_FLOAT
decl_stmt|;
name|int
name|from_real
init|=
name|GET_MODE_CLASS
argument_list|(
name|from_mode
argument_list|)
operator|==
name|MODE_FLOAT
decl_stmt|;
name|enum
name|insn_code
name|code
decl_stmt|;
name|rtx
name|libcall
decl_stmt|;
comment|/* rtx code for making an equivalent value.  */
name|enum
name|rtx_code
name|equiv_code
init|=
operator|(
name|unsignedp
condition|?
name|ZERO_EXTEND
else|:
name|SIGN_EXTEND
operator|)
decl_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_real
operator|!=
name|from_real
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If FROM is a SUBREG that indicates that we have already done at least      the required extension, strip it.  We don't handle such SUBREGs as      TO here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
operator|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|from
argument_list|)
operator|==
name|unsignedp
condition|)
name|from
operator|=
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
operator|,
name|from_mode
operator|=
name|to_mode
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|to
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|to_mode
operator|==
name|from_mode
operator|||
operator|(
name|from_mode
operator|==
name|VOIDmode
operator|&&
name|CONSTANT_P
argument_list|(
name|from
argument_list|)
operator|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|to_real
condition|)
block|{
name|rtx
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_extendqfhf2
if|if
condition|(
name|HAVE_extendqfsf2
operator|&&
name|from_mode
operator|==
name|QFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendqfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendqfsf2
if|if
condition|(
name|HAVE_extendqfsf2
operator|&&
name|from_mode
operator|==
name|QFmode
operator|&&
name|to_mode
operator|==
name|SFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendqfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendqfdf2
if|if
condition|(
name|HAVE_extendqfdf2
operator|&&
name|from_mode
operator|==
name|QFmode
operator|&&
name|to_mode
operator|==
name|DFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendqfdf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendqfxf2
if|if
condition|(
name|HAVE_extendqfxf2
operator|&&
name|from_mode
operator|==
name|QFmode
operator|&&
name|to_mode
operator|==
name|XFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendqfxf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendqftf2
if|if
condition|(
name|HAVE_extendqftf2
operator|&&
name|from_mode
operator|==
name|QFmode
operator|&&
name|to_mode
operator|==
name|TFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendqftf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendhftqf2
if|if
condition|(
name|HAVE_extendhftqf2
operator|&&
name|from_mode
operator|==
name|HFmode
operator|&&
name|to_mode
operator|==
name|TQFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendhftqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendhfsf2
if|if
condition|(
name|HAVE_extendhfsf2
operator|&&
name|from_mode
operator|==
name|HFmode
operator|&&
name|to_mode
operator|==
name|SFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendhfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendhfdf2
if|if
condition|(
name|HAVE_extendhfdf2
operator|&&
name|from_mode
operator|==
name|HFmode
operator|&&
name|to_mode
operator|==
name|DFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendhfdf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendhfxf2
if|if
condition|(
name|HAVE_extendhfxf2
operator|&&
name|from_mode
operator|==
name|HFmode
operator|&&
name|to_mode
operator|==
name|XFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendhfxf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendhftf2
if|if
condition|(
name|HAVE_extendhftf2
operator|&&
name|from_mode
operator|==
name|HFmode
operator|&&
name|to_mode
operator|==
name|TFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendhftf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendsfdf2
if|if
condition|(
name|HAVE_extendsfdf2
operator|&&
name|from_mode
operator|==
name|SFmode
operator|&&
name|to_mode
operator|==
name|DFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendsfdf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendsfxf2
if|if
condition|(
name|HAVE_extendsfxf2
operator|&&
name|from_mode
operator|==
name|SFmode
operator|&&
name|to_mode
operator|==
name|XFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendsfxf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extendsftf2
if|if
condition|(
name|HAVE_extendsftf2
operator|&&
name|from_mode
operator|==
name|SFmode
operator|&&
name|to_mode
operator|==
name|TFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendsftf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extenddfxf2
if|if
condition|(
name|HAVE_extenddfxf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|XFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extenddfxf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extenddftf2
if|if
condition|(
name|HAVE_extenddftf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|TFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extenddftf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunchfqf2
if|if
condition|(
name|HAVE_trunchfqf2
operator|&&
name|from_mode
operator|==
name|HFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunchfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncsfqf2
if|if
condition|(
name|HAVE_truncsfqf2
operator|&&
name|from_mode
operator|==
name|SFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdfqf2
if|if
condition|(
name|HAVE_truncdfqf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfqf2
if|if
condition|(
name|HAVE_truncxfqf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfqf2
if|if
condition|(
name|HAVE_trunctfqf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctqfhf2
if|if
condition|(
name|HAVE_trunctqfhf2
operator|&&
name|from_mode
operator|==
name|TQFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctqfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncsfhf2
if|if
condition|(
name|HAVE_truncsfhf2
operator|&&
name|from_mode
operator|==
name|SFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdfhf2
if|if
condition|(
name|HAVE_truncdfhf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfhf2
if|if
condition|(
name|HAVE_truncxfhf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfhf2
if|if
condition|(
name|HAVE_trunctfhf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdfsf2
if|if
condition|(
name|HAVE_truncdfsf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|SFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfsf2
if|if
condition|(
name|HAVE_truncxfsf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|SFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfsf2
if|if
condition|(
name|HAVE_trunctfsf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|SFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfdf2
if|if
condition|(
name|HAVE_truncxfdf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|DFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfdf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfdf2
if|if
condition|(
name|HAVE_trunctfdf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|DFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfdf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|libcall
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
switch|switch
condition|(
name|from_mode
condition|)
block|{
case|case
name|SFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|DFmode
case|:
name|libcall
operator|=
name|extendsfdf2_libfunc
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|libcall
operator|=
name|extendsfxf2_libfunc
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
name|libcall
operator|=
name|extendsftf2_libfunc
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|libcall
operator|=
name|truncdfsf2_libfunc
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|libcall
operator|=
name|extenddfxf2_libfunc
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
name|libcall
operator|=
name|extenddftf2_libfunc
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|XFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|libcall
operator|=
name|truncxfsf2_libfunc
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|libcall
operator|=
name|truncxfdf2_libfunc
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|libcall
operator|=
name|trunctfsf2_libfunc
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|libcall
operator|=
name|trunctfdf2_libfunc
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|libcall
operator|==
operator|(
name|rtx
operator|)
literal|0
condition|)
comment|/* This conversion is not implemented yet.  */
name|abort
argument_list|()
expr_stmt|;
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|libcall
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|to_mode
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|from_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now both modes are integers.  */
comment|/* Handle expanding beyond a word.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|lowpart
decl_stmt|;
name|rtx
name|fill_value
decl_stmt|;
name|rtx
name|lowfrom
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|lowpart_mode
decl_stmt|;
name|int
name|nwords
init|=
name|CEIL
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
comment|/* Try converting directly if the insn is supported.  */
if|if
condition|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
comment|/* If FROM is a SUBREG, put it into a register.  Do this 	     so that we always generate the same set of insns for 	     better cse'ing; if an intermediate assignment occurred, 	     we won't be doing the operation directly on the SUBREG.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Next, try converting via full word.  */
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
operator|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|word_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REG
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|to
argument_list|)
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|to
argument_list|)
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* No special multiword conversion insn; do it by hand.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Since we will turn this into a no conflict block, we must ensure 	 that the source does not overlap the target.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
comment|/* Get a copy of FROM widened to a word, if necessary.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
name|lowpart_mode
operator|=
name|word_mode
expr_stmt|;
else|else
name|lowpart_mode
operator|=
name|from_mode
expr_stmt|;
name|lowfrom
operator|=
name|convert_to_mode
argument_list|(
name|lowpart_mode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|lowpart
operator|=
name|gen_lowpart
argument_list|(
name|lowpart_mode
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|lowpart
argument_list|,
name|lowfrom
argument_list|)
expr_stmt|;
comment|/* Compute the value to put in each remaining word.  */
if|if
condition|(
name|unsignedp
condition|)
name|fill_value
operator|=
name|const0_rtx
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_slt
if|if
condition|(
name|HAVE_slt
operator|&&
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_slt
index|]
index|[
literal|0
index|]
operator|==
name|word_mode
operator|&&
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|lowfrom
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|lowpart_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fill_value
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_slt
argument_list|(
name|fill_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|fill_value
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|lowpart_mode
argument_list|,
name|lowfrom
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|lowpart_mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fill_value
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|fill_value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fill the remaining words.  */
for|for
control|(
name|i
operator|=
name|GET_MODE_SIZE
argument_list|(
name|lowpart_mode
argument_list|)
operator|/
name|UNITS_PER_WORD
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|nwords
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
decl_stmt|;
name|rtx
name|subword
init|=
name|operand_subword
argument_list|(
name|to
argument_list|,
name|index
argument_list|,
literal|1
argument_list|,
name|to_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|subword
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fill_value
operator|!=
name|subword
condition|)
name|emit_move_insn
argument_list|(
name|subword
argument_list|,
name|fill_value
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|gen_rtx
argument_list|(
name|equiv_code
argument_list|,
name|to_mode
argument_list|,
name|copy_rtx
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Truncating multi-word to a word or less.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|>
name|BITS_PER_WORD
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<=
name|BITS_PER_WORD
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|from
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|to_mode
index|]
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|from
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle pointer conversion */
comment|/* SPEE 900220 */
if|if
condition|(
name|to_mode
operator|==
name|PSImode
condition|)
block|{
if|if
condition|(
name|from_mode
operator|!=
name|SImode
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_truncsipsi2
if|if
condition|(
name|HAVE_truncsipsi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsipsi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_truncsipsi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|from_mode
operator|==
name|PSImode
condition|)
block|{
if|if
condition|(
name|to_mode
operator|!=
name|SImode
condition|)
block|{
name|from
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|from_mode
operator|=
name|SImode
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extendpsisi2
if|if
condition|(
name|HAVE_extendpsisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendpsisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_extendpsisi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|to_mode
operator|==
name|PDImode
condition|)
block|{
if|if
condition|(
name|from_mode
operator|!=
name|DImode
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|DImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_truncdipdi2
if|if
condition|(
name|HAVE_truncdipdi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdipdi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_truncdipdi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|from_mode
operator|==
name|PDImode
condition|)
block|{
if|if
condition|(
name|to_mode
operator|!=
name|DImode
condition|)
block|{
name|from
operator|=
name|convert_to_mode
argument_list|(
name|DImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|from_mode
operator|=
name|DImode
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extendpdidi2
if|if
condition|(
name|HAVE_extendpdidi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendpdidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_extendpdidi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now follow all the conversions between integers      no more than a word long.  */
comment|/* For truncation, usually we can just refer to FROM in a narrower mode.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|from
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|to_mode
index|]
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|from
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|from
argument_list|)
argument_list|,
name|to_mode
argument_list|)
condition|)
name|from
operator|=
name|copy_to_reg
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle extension.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
condition|)
block|{
comment|/* Convert directly if that works.  */
if|if
condition|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|enum
name|machine_mode
name|intermediate
decl_stmt|;
comment|/* Search for a mode to convert via.  */
for|for
control|(
name|intermediate
operator|=
name|from_mode
init|;
name|intermediate
operator|!=
name|VOIDmode
condition|;
name|intermediate
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|intermediate
argument_list|)
control|)
if|if
condition|(
operator|(
operator|(
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|intermediate
argument_list|,
name|unsignedp
argument_list|)
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|intermediate
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|to_mode
argument_list|,
name|intermediate
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|can_extend_p
argument_list|(
name|intermediate
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|convert_move
argument_list|(
name|to
argument_list|,
name|convert_to_mode
argument_list|(
name|intermediate
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* No suitable intermediate mode.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Support special truncate insns for certain modes.  */
if|if
condition|(
name|from_mode
operator|==
name|DImode
operator|&&
name|to_mode
operator|==
name|SImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncdisi2
if|if
condition|(
name|HAVE_truncdisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|DImode
operator|&&
name|to_mode
operator|==
name|HImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncdihi2
if|if
condition|(
name|HAVE_truncdihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|DImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncdiqi2
if|if
condition|(
name|HAVE_truncdiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|SImode
operator|&&
name|to_mode
operator|==
name|HImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncsihi2
if|if
condition|(
name|HAVE_truncsihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|SImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncsiqi2
if|if
condition|(
name|HAVE_truncsiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|HImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunchiqi2
if|if
condition|(
name|HAVE_trunchiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunchiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|DImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctidi2
if|if
condition|(
name|HAVE_trunctidi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|SImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctisi2
if|if
condition|(
name|HAVE_trunctisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|HImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctihi2
if|if
condition|(
name|HAVE_trunctihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctiqi2
if|if
condition|(
name|HAVE_trunctiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle truncation of volatile memrefs, and so on;      the things that couldn't be truncated directly,      and for which there was no special instruction.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|force_reg
argument_list|(
name|to_mode
argument_list|,
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Mode combination is not recognized.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an rtx for a value that would result    from converting X to mode MODE.    Both X and MODE may be floating, or both integer.    UNSIGNEDP is nonzero if X is an unsigned value.    This can be done by referring to a part of X in place    or by copying to a new temporary with conversion.     This function *must not* call protect_from_queue    except when putting X into an insn (in which case convert_move does it).  */
end_comment

begin_function
name|rtx
name|convert_to_mode
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
return|return
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx for a value that would result    from converting X from mode OLDMODE to mode MODE.    Both modes may be floating, or both integer.    UNSIGNEDP is nonzero if X is an unsigned value.     This can be done by referring to a part of X in place    or by copying to a new temporary with conversion.     You can give VOIDmode for OLDMODE, if you are sure X has a nonvoid mode.     This function *must not* call protect_from_queue    except when putting X into an insn (in which case convert_move does it).  */
end_comment

begin_function
name|rtx
name|convert_modes
parameter_list|(
name|mode
parameter_list|,
name|oldmode
parameter_list|,
name|x
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|oldmode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
comment|/* If FROM is a SUBREG that indicates that we have already done at least      the required extension, strip it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|x
argument_list|)
operator|==
name|unsignedp
condition|)
name|x
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|oldmode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|oldmode
condition|)
return|return
name|x
return|;
comment|/* There is one case that we must handle specially: If we are converting      a CONST_INT into a mode whose size is twice HOST_BITS_PER_WIDE_INT and      we are to interpret the constant as unsigned, gen_lowpart will do      the wrong if the constant appears negative.  What we want to do is      make the high-order word of the constant zero, not all ones.  */
if|if
condition|(
name|unsignedp
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
return|return
name|immed_double_const
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|mode
argument_list|)
return|;
comment|/* We can do this with a gen_lowpart if both desired and current modes      are integer, and this is either a constant integer, a register, or a      non-volatile MEM.  Except for the constant case where MODE is no      wider than HOST_BITS_PER_WIDE_INT, we must be narrowing the operand.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|oldmode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|oldmode
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* ?? If we don't know OLDMODE, we have to assume here that 	 X does not need sign- or zero-extension.   This may not be 	 the case, but it's the best we can do.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|oldmode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|oldmode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|oldmode
argument_list|)
decl_stmt|;
comment|/* We must sign or zero-extend in this case.  Start by 	     zero-extending, then sign extend if we need to.  */
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|unsignedp
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate several move instructions to copy LEN bytes    from block FROM to block TO.  (These are MEM rtx's with BLKmode).    The caller must pass FROM and TO     through protect_from_queue before calling.    ALIGN (in bytes) is maximum alignment we can assume.  */
end_comment

begin_function
specifier|static
name|void
name|move_by_pieces
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|len
parameter_list|,
name|align
parameter_list|)
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|len
decl_stmt|,
name|align
decl_stmt|;
block|{
name|struct
name|move_by_pieces
name|data
decl_stmt|;
name|rtx
name|to_addr
init|=
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|from_addr
init|=
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|max_size
init|=
name|MOVE_MAX
operator|+
literal|1
decl_stmt|;
name|data
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|to_addr
operator|=
name|to_addr
expr_stmt|;
name|data
operator|.
name|from_addr
operator|=
name|from_addr
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|data
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
operator|(
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|reverse
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|reverse
condition|)
name|data
operator|.
name|offset
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|to_struct
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|data
operator|.
name|from_struct
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* If copying requires more than two move insns,      copy addresses to registers (to make displacements shorter)      and use post-increment if available.  */
if|if
condition|(
operator|!
operator|(
name|data
operator|.
name|autinc_from
operator|&&
name|data
operator|.
name|autinc_to
operator|)
operator|&&
name|move_by_pieces_ninsns
argument_list|(
name|len
argument_list|,
name|align
argument_list|)
operator|>
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
if|if
condition|(
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_from
condition|)
block|{
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|from_addr
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_from
condition|)
block|{
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_from
operator|&&
name|CONSTANT_P
argument_list|(
name|from_addr
argument_list|)
condition|)
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
if|if
condition|(
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|to_addr
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
if|if
condition|(
operator|!
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_to
operator|&&
name|CONSTANT_P
argument_list|(
name|to_addr
argument_list|)
condition|)
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SLOW_UNALIGNED_ACCESS
operator|||
name|align
operator|>
name|MOVE_MAX
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|MOVE_MAX
expr_stmt|;
comment|/* First move what we can in the largest integer mode, then go to      successively smaller modes.  */
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
condition|)
name|move_by_pieces_1
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|,
name|mode
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The code above should have handled everything.  */
if|if
condition|(
name|data
operator|.
name|len
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return number of insns required to move L bytes by pieces.    ALIGN (in bytes) is maximum alignment we can assume.  */
end_comment

begin_function
specifier|static
name|int
name|move_by_pieces_ninsns
parameter_list|(
name|l
parameter_list|,
name|align
parameter_list|)
name|unsigned
name|int
name|l
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
specifier|register
name|int
name|n_insns
init|=
literal|0
decl_stmt|;
name|int
name|max_size
init|=
name|MOVE_MAX
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|SLOW_UNALIGNED_ACCESS
operator|||
name|align
operator|>
name|MOVE_MAX
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|MOVE_MAX
expr_stmt|;
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
condition|)
name|n_insns
operator|+=
name|l
operator|/
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|,
name|l
operator|%=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|n_insns
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of move_by_pieces.  Move as many bytes as appropriate    with move instructions for mode MODE.  GENFUN is the gen_... function    to make a move insn for that mode.  DATA has all the other info.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|move_by_pieces_1
argument_list|(
name|genfun
argument_list|,
name|mode
argument_list|,
name|data
argument_list|)
name|rtx
argument_list|(
operator|*
name|genfun
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|move_by_pieces
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|to1
decl_stmt|,
name|from1
decl_stmt|;
while|while
condition|(
name|data
operator|->
name|len
operator|>=
name|size
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|-=
name|size
expr_stmt|;
name|to1
operator|=
operator|(
name|data
operator|->
name|autinc_to
condition|?
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|to_addr
argument_list|)
else|:
name|change_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|to1
argument_list|)
operator|=
name|data
operator|->
name|to_struct
expr_stmt|;
name|from1
operator|=
operator|(
name|data
operator|->
name|autinc_from
condition|?
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|data
operator|->
name|from_addr
argument_list|)
else|:
name|change_address
argument_list|(
name|data
operator|->
name|from
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|from1
argument_list|)
operator|=
name|data
operator|->
name|from_struct
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
if|if
condition|(
name|data
operator|->
name|explicit_inc_to
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|explicit_inc_from
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_insn
argument_list|(
call|(
modifier|*
name|genfun
call|)
argument_list|(
name|to1
argument_list|,
name|from1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
if|if
condition|(
name|data
operator|->
name|explicit_inc_to
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|explicit_inc_from
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
name|data
operator|->
name|len
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Emit code to move a block Y to a block X.    This may be done with string-move instructions,    with multiple scalar move instructions, or with a library call.     Both X and Y must be MEM rtx's (perhaps inside VOLATILE)    with mode BLKmode.    SIZE is an rtx that says how long they are.    ALIGN is the maximum alignment we can assume they have,    measured in bytes.  */
end_comment

begin_function
name|void
name|emit_block_move
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|!=
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
name|protect_from_queue
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|move_by_pieces_ninsns
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
operator|<
name|MOVE_RATIO
operator|)
condition|)
name|move_by_pieces
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Try the most limited insn first, because there's no point 	 including more than one in the machine description unless 	 the more limited one has some advantage.  */
name|rtx
name|opalign
init|=
name|GEN_INT
argument_list|(
name|align
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|enum
name|insn_code
name|code
init|=
name|movstr_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
comment|/* We don't need MODE to be narrower than BITS_PER_HOST_WIDE_INT 		 here because if SIZE is less than the mode mask, as it is 		 returned by the macro, it will definitely be less than the 		 actual mode mask.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|BITS_PER_WORD
operator|)
operator|&&
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|0
index|]
operator|==
literal|0
operator|||
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|x
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|&&
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|||
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|y
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|&&
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|3
index|]
operator|==
literal|0
operator|||
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|3
index|]
call|)
argument_list|(
name|opalign
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|op2
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|op2
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|2
index|]
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op2
argument_list|,
name|mode
argument_list|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
operator|(
name|int
operator|)
name|code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|op2
argument_list|,
name|opalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memcpy_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bcopy_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy all or part of a value X into registers starting at REGNO.    The number of registers to be filled is NREGS.  */
end_comment

begin_function
name|void
name|move_block_to_reg
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|,
name|nregs
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if the machine can do this with a load multiple insn.  */
ifdef|#
directive|ifdef
name|HAVE_load_multiple
if|if
condition|(
name|HAVE_load_multiple
condition|)
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pat
operator|=
name|gen_load_multiple
argument_list|(
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|nregs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|word_mode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|operand_subword_force
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy all or part of a BLKmode value X out of registers starting at REGNO.    The number of registers to be filled is NREGS.  SIZE indicates the number    of bytes in the object X.  */
end_comment

begin_function
name|void
name|move_block_from_reg
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|,
name|nregs
parameter_list|,
name|size
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|last
decl_stmt|;
comment|/* Blocks smaller than a word on a BYTES_BIG_ENDIAN machine must be aligned      to the left before storing to memory.  */
if|if
condition|(
name|size
operator|<
name|UNITS_PER_WORD
operator|&&
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|rtx
name|tem
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BLKmode
argument_list|)
decl_stmt|;
name|rtx
name|shift
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|shift
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
operator|(
name|UNITS_PER_WORD
operator|-
name|size
operator|)
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|shift
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* See if the machine can do this with a store multiple insn.  */
ifdef|#
directive|ifdef
name|HAVE_store_multiple
if|if
condition|(
name|HAVE_store_multiple
condition|)
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pat
operator|=
name|gen_store_multiple
argument_list|(
name|x
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|nregs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|BLKmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|word_mode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a USE expression for REG to the (possibly empty) list pointed    to by CALL_FUSAGE.  REG must denote a hard register.  */
end_comment

begin_function
name|void
name|use_reg
parameter_list|(
name|call_fusage
parameter_list|,
name|reg
parameter_list|)
name|rtx
modifier|*
name|call_fusage
decl_stmt|,
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|call_fusage
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|,
operator|*
name|call_fusage
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add USE expressions to *CALL_FUSAGE for each of NREGS consecutive regs,    starting at REGNO.  All of these registers must be hard registers.  */
end_comment

begin_function
name|void
name|use_regs
parameter_list|(
name|call_fusage
parameter_list|,
name|regno
parameter_list|,
name|nregs
parameter_list|)
name|rtx
modifier|*
name|call_fusage
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regno
operator|+
name|nregs
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|reg_raw_mode
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write zeros through the storage of OBJECT.    If OBJECT has BLKmode, SIZE is its length in bytes.  */
end_comment

begin_function
name|void
name|clear_storage
parameter_list|(
name|object
parameter_list|,
name|size
parameter_list|)
name|rtx
name|object
decl_stmt|;
name|rtx
name|size
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memset_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|const0_rtx
argument_list|,
name|ptr_mode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bzero_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|2
argument_list|,
name|XEXP
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|emit_move_insn
argument_list|(
name|object
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to copy Y into X.    Both Y and X must have the same mode, except that    Y can be a constant with VOIDmode.    This mode cannot be BLKmode; use emit_block_move for that.     Return the last instruction emitted.  */
end_comment

begin_function
name|rtx
name|emit_move_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
operator|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
name|y
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* If X or Y are memory references, verify that their addresses are valid      for the machine.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|y
operator|=
name|change_address
argument_list|(
name|y
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|emit_move_insn_1
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Low level part of emit_move_insn.    Called just like emit_move_insn, but assumes X and Y    are basically valid.  */
end_comment

begin_function
name|rtx
name|emit_move_insn_1
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|submode
decl_stmt|;
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
comment|/* Expand complex moves by moving real part and imag part, if possible.  */
elseif|else
if|if
condition|(
operator|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_INT
operator|)
operator|&&
name|BLKmode
operator|!=
operator|(
name|submode
operator|=
name|mode_for_size
argument_list|(
operator|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
argument_list|,
operator|(
name|class
operator|==
name|MODE_COMPLEX_INT
condition|?
name|MODE_INT
else|:
name|MODE_FLOAT
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
comment|/* Don't split destination if it is a stack push.  */
name|int
name|stack
init|=
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
comment|/* If this is a stack, push the highpart first, so it 	 will be in the argument order.  	 In that case, change_address is used only to convert 	 the mode, not to change the address.  */
if|if
condition|(
name|stack
condition|)
block|{
comment|/* Note that the real part always precedes the imag part in memory 	     regardless of machine's endianness.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|submode
argument_list|,
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
argument_list|,
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|submode
argument_list|,
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
argument_list|,
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|submode
argument_list|,
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
argument_list|,
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|submode
argument_list|,
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
argument_list|,
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|x
argument_list|)
argument_list|,
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|x
argument_list|)
argument_list|,
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|get_last_insn
argument_list|()
return|;
block|}
comment|/* This will handle any multi-word mode that lacks a move_insn pattern.      However, you will get better code if you define such patterns,      even if they must turn into multiple assembler instructions.  */
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
block|{
name|rtx
name|last_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* If X is a push on the stack, do the push now and replace 	 X with a reference to the stack pointer.  */
if|if
condition|(
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Show the output dies here.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|xpart
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|ypart
init|=
name|operand_subword
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
comment|/* If we can't get a part of Y, put Y into memory if it is a 	     constant.  Otherwise, force it into a register.  If we still 	     can't get a part of Y, abort.  */
if|if
condition|(
name|ypart
operator|==
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|y
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|ypart
operator|=
name|operand_subword
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ypart
operator|==
literal|0
condition|)
name|ypart
operator|=
name|operand_subword_force
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpart
operator|==
literal|0
operator|||
name|ypart
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|last_insn
operator|=
name|emit_move_insn
argument_list|(
name|xpart
argument_list|,
name|ypart
argument_list|)
expr_stmt|;
block|}
return|return
name|last_insn
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pushing data onto the stack.  */
end_comment

begin_comment
comment|/* Push a block of length SIZE (perhaps variable)    and return an rtx to address the beginning of the block.    Note that it is not possible for the value returned to be a QUEUED.    The value may be virtual_outgoing_args_rtx.     EXTRA is the number of bytes of padding to push in addition to SIZE.    BELOW nonzero means this padding comes at low addresses;    otherwise, the padding comes at high addresses.  */
end_comment

begin_function
name|rtx
name|push_block
parameter_list|(
name|size
parameter_list|,
name|extra
parameter_list|,
name|below
parameter_list|)
name|rtx
name|size
decl_stmt|;
name|int
name|extra
decl_stmt|,
name|below
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
name|size
operator|=
name|convert_modes
argument_list|(
name|Pmode
argument_list|,
name|ptr_mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|size
argument_list|)
condition|)
name|anti_adjust_stack
argument_list|(
name|plus_constant
argument_list|(
name|size
argument_list|,
name|extra
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|REG
operator|&&
name|extra
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|temp
init|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|anti_adjust_stack
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|temp
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
operator|&&
name|below
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|extra
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
operator|(
name|below
condition|?
literal|0
else|:
name|extra
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra
operator|!=
literal|0
operator|&&
operator|!
name|below
condition|)
name|temp
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|virtual_outgoing_args_rtx
argument_list|,
name|negate_rtx
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|size
argument_list|,
name|extra
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|virtual_outgoing_args_rtx
argument_list|,
name|negate_rtx
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|memory_address
argument_list|(
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|gen_push_operand
parameter_list|()
block|{
return|return
name|gen_rtx
argument_list|(
name|STACK_PUSH_CODE
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate code to push X onto the stack, assuming it has mode MODE and    type TYPE.    MODE is redundant except when X is a CONST_INT (since they don't    carry mode info).    SIZE is an rtx for the size of data to be copied (in bytes),    needed only if X is BLKmode.     ALIGN (in bytes) is maximum alignment we can assume.     If PARTIAL and REG are both nonzero, then copy that many of the first    words of X into registers starting with REG, and push the rest of X.    The amount of space pushed is decreased by PARTIAL words,    rounded *down* to a multiple of PARM_BOUNDARY.    REG must be a hard register in this case.    If REG is zero but PARTIAL is not, take any all others actions for an    argument partially in registers, but do not actually load any    registers.     EXTRA is the amount in bytes of extra space to leave next to this arg.    This is ignored if an argument block has already been allocated.     On a machine that lacks real push insns, ARGS_ADDR is the address of    the bottom of the argument block for this call.  We use indexing off there    to store the arg.  On machines with push insns, ARGS_ADDR is 0 when a    argument block has not been preallocated.     ARGS_SO_FAR is the size of args previously pushed for this call.  */
end_comment

begin_function
name|void
name|emit_push_insn
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|,
name|partial
parameter_list|,
name|reg
parameter_list|,
name|extra
parameter_list|,
name|args_addr
parameter_list|,
name|args_so_far
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|partial
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|rtx
name|args_addr
decl_stmt|;
name|rtx
name|args_so_far
decl_stmt|;
block|{
name|rtx
name|xinner
decl_stmt|;
name|enum
name|direction
name|stack_direction
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
init|=
name|downward
decl_stmt|;
else|#
directive|else
operator|=
name|upward
expr_stmt|;
endif|#
directive|endif
comment|/* Decide where to pad the argument: `downward' for below,      `upward' for above, or `none' for don't pad it.      Default is below for small data on big-endian machines; else above.  */
name|enum
name|direction
name|where_pad
init|=
name|FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* Invert direction if stack is post-update.  */
if|if
condition|(
name|STACK_PUSH_CODE
operator|==
name|POST_INC
operator|||
name|STACK_PUSH_CODE
operator|==
name|POST_DEC
condition|)
if|if
condition|(
name|where_pad
operator|!=
name|none
condition|)
name|where_pad
operator|=
operator|(
name|where_pad
operator|==
name|downward
condition|?
name|upward
else|:
name|downward
operator|)
expr_stmt|;
name|xinner
operator|=
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* Copy a block into the stack, entirely or partially.  */
specifier|register
name|rtx
name|temp
decl_stmt|;
name|int
name|used
init|=
name|partial
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|offset
init|=
name|used
operator|%
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|int
name|skip
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|used
operator|-=
name|offset
expr_stmt|;
comment|/* USED is now the # of bytes we need not copy to the stack 	 because registers will take care of them.  */
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
name|xinner
operator|=
name|change_address
argument_list|(
name|xinner
argument_list|,
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|used
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the partial register-part of the arg counts in its stack size, 	 skip the part of stack space corresponding to the registers. 	 Otherwise, start copying to the beginning of the stack space, 	 by setting SKIP to 0.  */
ifndef|#
directive|ifndef
name|REG_PARM_STACK_SPACE
name|skip
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|skip
operator|=
name|used
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* Do it with several push insns if that doesn't take lots of insns 	 and if there is no difficulty with push insns that skip bytes 	 on the stack for alignment purposes.  */
if|if
condition|(
name|args_addr
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|skip
operator|==
literal|0
operator|&&
operator|(
name|move_by_pieces_ninsns
argument_list|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|,
name|align
argument_list|)
operator|<
name|MOVE_RATIO
operator|)
comment|/* Here we avoid the case of a structure whose weak alignment 	     forces many pushes of a small amount of data, 	     and such small pushes do rounding that causes trouble.  */
operator|&&
operator|(
operator|(
operator|!
name|SLOW_UNALIGNED_ACCESS
operator|)
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|||
name|PUSH_ROUNDING
argument_list|(
name|align
argument_list|)
operator|==
name|align
operator|)
operator|&&
name|PUSH_ROUNDING
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|size
argument_list|)
condition|)
block|{
comment|/* Push padding now if padding above and stack grows down, 	     or if padding below and stack grows up. 	     But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
name|move_by_pieces
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|gen_push_operand
argument_list|()
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* PUSH_ROUNDING */
block|{
comment|/* Otherwise make space on the stack and copy the data 	     to the address of that space.  */
comment|/* Deduct words put into registers from the size we must copy.  */
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
name|size
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|size
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|used
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* Get the address of the stack space. 	     In this case, we do not deal with EXTRA separately. 	     A single stack adjust will do.  */
if|if
condition|(
operator|!
name|args_addr
condition|)
block|{
name|temp
operator|=
name|push_block
argument_list|(
name|size
argument_list|,
name|extra
argument_list|,
name|where_pad
operator|==
name|downward
argument_list|)
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|args_so_far
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|args_addr
argument_list|,
name|skip
operator|+
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|args_addr
argument_list|,
name|args_so_far
argument_list|)
argument_list|,
name|skip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TEMP is the address of the block.  Copy the data there.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|move_by_pieces_ninsns
argument_list|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
operator|<
name|MOVE_RATIO
operator|)
condition|)
block|{
name|move_by_pieces
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* Try the most limited insn first, because there's no point 	     including more than one in the machine description unless 	     the more limited one has some advantage.  */
ifdef|#
directive|ifdef
name|HAVE_movstrqi
if|if
condition|(
name|HAVE_movstrqi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|pat
init|=
name|gen_movstrqi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pat
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrhi
if|if
condition|(
name|HAVE_movstrhi
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|pat
init|=
name|gen_movstrhi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pat
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrsi
if|if
condition|(
name|HAVE_movstrsi
condition|)
block|{
name|rtx
name|pat
init|=
name|gen_movstrsi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pat
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_movstrdi
if|if
condition|(
name|HAVE_movstrdi
condition|)
block|{
name|rtx
name|pat
init|=
name|gen_movstrdi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pat
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* If the source is referenced relative to the stack pointer, 	     copy it to another register to stabilize it.  We do not need 	     to do this if we know that we won't be changing sp.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|temp
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|temp
argument_list|)
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make inhibit_defer_pop nonzero around the library call 	     to force it to pop the bcopy-arguments right away.  */
name|NO_DEFER_POP
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memcpy_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|temp
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bcopy_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|temp
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OK_DEFER_POP
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|partial
operator|>
literal|0
condition|)
block|{
comment|/* Scalar partly in registers.  */
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|not_stack
decl_stmt|;
comment|/* # words of start of argument 	 that we must make space for but need not store.  */
name|int
name|offset
init|=
name|partial
operator|%
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_WORD
operator|)
decl_stmt|;
name|int
name|args_offset
init|=
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
decl_stmt|;
name|int
name|skip
decl_stmt|;
comment|/* Push padding now if padding above and stack grows down, 	 or if padding below and stack grows up. 	 But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we make space by pushing it, we might as well push 	 the real data.  Otherwise, we can leave OFFSET nonzero 	 and leave the space uninitialized.  */
if|if
condition|(
name|args_addr
operator|==
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Now NOT_STACK gets the number of words that we don't need to 	 allocate on the stack.  */
name|not_stack
operator|=
name|partial
operator|-
name|offset
expr_stmt|;
comment|/* If the partial register-part of the arg counts in its stack size, 	 skip the part of stack space corresponding to the registers. 	 Otherwise, start copying to the beginning of the stack space, 	 by setting SKIP to 0.  */
ifndef|#
directive|ifndef
name|REG_PARM_STACK_SPACE
name|skip
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|skip
operator|=
name|not_stack
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If X is a hard register in a non-integer mode, copy it into a pseudo; 	 SUBREGs of such registers are not allowed.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
operator|)
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Loop over all the words allocated on the stack for this arg.  */
comment|/* We can do it by words, because any scalar bigger than a word 	 has a size a multiple of a word.  */
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
for|for
control|(
name|i
operator|=
name|not_stack
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
name|not_stack
condition|;
name|i
operator|--
control|)
endif|#
directive|endif
if|if
condition|(
name|i
operator|>=
name|not_stack
operator|+
name|offset
condition|)
name|emit_push_insn
argument_list|(
name|operand_subword_force
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_RTX
argument_list|,
name|align
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|args_addr
argument_list|,
name|GEN_INT
argument_list|(
name|args_offset
operator|+
operator|(
operator|(
name|i
operator|-
name|not_stack
operator|+
name|skip
operator|)
operator|*
name|UNITS_PER_WORD
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|addr
decl_stmt|;
comment|/* Push padding now if padding above and stack grows down, 	 or if padding below and stack grows up. 	 But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|args_addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|gen_push_operand
argument_list|()
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|args_so_far
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|args_addr
argument_list|,
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|args_addr
argument_list|,
name|args_so_far
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|ret
label|:
comment|/* If part should go in registers, copy that part      into the appropriate registers.  Do this now, at the end,      since mem-to-mem copies above may do function calls.  */
if|if
condition|(
name|partial
operator|>
literal|0
operator|&&
name|reg
operator|!=
literal|0
condition|)
name|move_block_to_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|x
argument_list|,
name|partial
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|==
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an assignment that stores the value of FROM into TO.    If WANT_VALUE is nonzero, return an rtx for the value of TO.    (This may contain a QUEUED rtx;    if the value is constant, this rtx is a constant.)    Otherwise, the returned value is NULL_RTX.     SUGGEST_REG is no longer actually used.    It used to mean, copy the value through a register    and return that register, if that is possible.    We now use WANT_VALUE to decide whether to do this.  */
end_comment

begin_function
name|rtx
name|expand_assignment
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|want_value
parameter_list|,
name|suggest_reg
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|want_value
decl_stmt|;
name|int
name|suggest_reg
decl_stmt|;
block|{
specifier|register
name|rtx
name|to_rtx
init|=
literal|0
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* Don't crash if the lhs of the assignment was erroneous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
name|result
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|want_value
condition|?
name|result
else|:
name|NULL_RTX
return|;
block|}
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|tree
name|dest_innermost
decl_stmt|;
name|bc_expand_expr
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|duplicate
argument_list|)
expr_stmt|;
name|dest_innermost
operator|=
name|bc_expand_address
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Can't deduce from TYPE that we're dealing with a bitfield, so 	 take care of it here. */
name|bc_store_memory
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|dest_innermost
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Assignment of a structure component needs special treatment      if the structure component's rtx is not simply a MEM.      Assignment of an array element at a constant index, and assignment of      an array element in an unaligned packed structure field, has the same      problem.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
operator|||
operator|(
name|SLOW_UNALIGNED_ACCESS
operator|&&
name|get_inner_unaligned_p
argument_list|(
name|to
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|tem
operator|=
name|get_inner_reference
argument_list|(
name|to
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode1
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|)
expr_stmt|;
comment|/* If we are going to use store_bit_field and extract_bit_field, 	 make sure to_rtx will be safe for multiple use.  */
if|if
condition|(
name|mode1
operator|==
name|VOIDmode
operator|&&
name|want_value
condition|)
name|tem
operator|=
name|stabilize_reference
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|alignment
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|tem
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset_rtx
init|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|to_rtx
operator|=
name|change_address
argument_list|(
name|to_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|ptr_mode
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a variable offset, the known alignment 	     is only that of the innermost structure containing the field. 	     (Actually, we could sometimes do better by using the 	     align of an element of the innermost array, but no need.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
name|alignment
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
if|if
condition|(
name|volatilep
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* When the offset is zero, to_rtx is the address of the 		 structure we are storing into, and hence may be shared. 		 We must make a new MEM before setting the volatile bit.  */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|change_address
argument_list|(
name|to_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This was turned off because, when a field is volatile 	  in an object which is not volatile, the object may be in a register, 	  and then we would abort over here.  */
block|else 	    abort ();
endif|#
directive|endif
block|}
name|result
operator|=
name|store_field
argument_list|(
name|to_rtx
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode1
argument_list|,
name|from
argument_list|,
operator|(
name|want_value
comment|/* Spurious cast makes HPUX compiler happy.  */
operator|?
operator|(
expr|enum
name|machine_mode
operator|)
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|:
name|VOIDmode
operator|)
argument_list|,
name|unsignedp
argument_list|,
comment|/* Required alignment of containing datum.  */
name|alignment
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* If the value is meaningful, convert RESULT to the proper mode. 	 Otherwise, return nothing.  */
return|return
operator|(
name|want_value
condition|?
name|convert_modes
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
else|:
name|NULL_RTX
operator|)
return|;
block|}
comment|/* If the rhs is a function call and its value is not an aggregate,      call the function before we start to compute the lhs.      This is needed for correct code for cases such as      val = setjmp (buf) on machines where reference to val      requires loading up part of an address in a separate insn.       Don't do this if TO is a VAR_DECL whose DECL_RTL is REG since it might be      a promoted variable where the zero- or sign- extension needs to be done.      Handling this in the normal way is safe because no computation is done      before the call.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|!
name|aggregate_value_p
argument_list|(
name|from
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|to
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
condition|)
block|{
name|rtx
name|value
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|value
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_rtx
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|to
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|int
name|align
init|=
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|,
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
name|emit_block_move
argument_list|(
name|to_rtx
argument_list|,
name|value
argument_list|,
name|expr_size
argument_list|(
name|from
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|to_rtx
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|to_rtx
else|:
name|NULL_RTX
return|;
block|}
comment|/* Ordinary treatment.  Expand TO to get a REG or MEM rtx.      Don't re-expand if it was expanded already (in COMPONENT_REF case).  */
if|if
condition|(
name|to_rtx
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|to
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't move directly into a return register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|RESULT_DECL
operator|&&
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|to_rtx
else|:
name|NULL_RTX
return|;
block|}
comment|/* In case we are returning the contents of an object which overlaps      the place the value is being stored, use a safe function when copying      a value through a pointer into a structure value return block.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|RESULT_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|current_function_returns_struct
operator|&&
operator|!
name|current_function_returns_pcc_struct
condition|)
block|{
name|rtx
name|from_rtx
decl_stmt|,
name|size
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|size
operator|=
name|expr_size
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|from_rtx
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memcpy_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|from_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bcopy_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|from_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|to_rtx
else|:
name|NULL_RTX
return|;
block|}
comment|/* Compute FROM and store the value in the rtx we got.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
name|result
operator|=
name|store_expr
argument_list|(
name|from
argument_list|,
name|to_rtx
argument_list|,
name|want_value
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|result
else|:
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Generate code for computing expression EXP,    and storing the value into TARGET.    TARGET may contain a QUEUED rtx.     If WANT_VALUE is nonzero, return a copy of the value    not in TARGET, so that we can be sure to use the proper    value in a containing expression even if TARGET has something    else stored in it.  If possible, we copy the value through a pseudo    and return that pseudo.  Or, if the value is constant, we try to    return the constant.  In some cases, we return a pseudo    copied *from* TARGET.     If the mode is BLKmode then we may return TARGET itself.    It turns out that in BLKmode it doesn't cause a problem.    because C has no operators that could combine two different    assignments into the same BLKmode object with different values    with no sequence point.  Will other languages need this to    be more thorough?     If WANT_VALUE is 0, we return NULL, to make sure    to catch quickly any cases where the caller uses the value    and fails to set WANT_VALUE.  */
end_comment

begin_function
name|rtx
name|store_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|want_value
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
specifier|register
name|rtx
name|target
decl_stmt|;
name|int
name|want_value
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
name|int
name|dont_return_target
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
comment|/* Perform first part of compound expression, then assign from second 	 part.  */
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
return|return
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|want_value
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COND_EXPR
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
comment|/* For conditional expression, get safe form of the target.  Then 	 test the condition, doing the appropriate assignment on either 	 side.  This avoids the creation of unnecessary temporaries. 	 For non-BLKmode, it is more efficient not to do this.  */
name|rtx
name|lab1
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|,
name|lab2
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab2
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
return|return
name|want_value
condition|?
name|target
else|:
name|NULL_RTX
return|;
block|}
elseif|else
if|if
condition|(
name|want_value
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
condition|)
comment|/* If target is in memory and caller wants value in a register instead,        arrange that.  Pass TARGET as target for expand_expr so that,        if EXP is another assignment, WANT_VALUE will be nonzero for it.        We know expand_expr will not use the target in that case.        Don't do this if TARGET is volatile because we are supposed        to write it and then read it.  */
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|cse_not_expected
condition|?
name|NULL_RTX
else|:
name|target
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queued_subexp_p
argument_list|(
name|target
argument_list|)
condition|)
comment|/* If target contains a postincrement, let's not risk        using it as the place to generate the rhs.  */
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* Expand EXP into a new pseudo.  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|temp
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If target is volatile, ANSI requires accessing the value 	 *from* the target, if it is accessed.  So make that happen. 	 In no case return the target itself.  */
if|if
condition|(
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|&&
name|want_value
condition|)
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|target
argument_list|)
condition|)
comment|/* If this is an scalar in a register that is stored in a wider mode        than the declared mode, compute the result into its declared mode        and then convert to the wider mode.  Our value is the computed        expression.  */
block|{
comment|/* If we don't want a value, we can do the conversion inside EXP, 	 which will often result in some optimizations.  Do the conversion 	 in two steps: first change the signedness, if needed, then 	 the extend.  */
if|if
condition|(
operator|!
name|want_value
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
condition|)
name|exp
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|convert
argument_list|(
name|type_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If TEMP is a volatile MEM and we want a result value, make 	 the access now so it gets done only once.  Likewise if 	 it contains TARGET.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
operator|&&
name|want_value
operator|&&
operator|(
name|MEM_VOLATILE_P
argument_list|(
name|temp
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* If TEMP is a VOIDmode constant, use convert_modes to make 	 sure that we properly convert it.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|VOIDmode
condition|)
name|temp
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|want_value
condition|?
name|temp
else|:
name|NULL_RTX
return|;
block|}
else|else
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Return TARGET if it's a specified hardware register. 	 If TARGET is a volatile mem ref, either return TARGET 	 or return a reg copied *from* TARGET; ANSI requires this.  	 Otherwise, if TEMP is not TARGET, return TEMP 	 if it is constant (for efficiency), 	 or if we really want the correct value.  */
if|if
condition|(
operator|!
operator|(
name|target
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
operator|&&
name|temp
operator|!=
name|target
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|||
name|want_value
operator|)
condition|)
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If TEMP is a VOIDmode constant and the mode of the type of EXP is not      the same as that of TARGET, adjust the constant.  This is needed, for      example, in case it is a CONST_DOUBLE and we want only a word-sized      value.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If value was not generated in the target, store it there.      Convert the value to TARGET's type first if nec.  */
if|if
condition|(
name|temp
operator|!=
name|target
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dont_return_target
condition|)
block|{
comment|/* In this case, we will return TEMP, 		 so make sure it has the proper mode. 		 But don't forget to store the value into TARGET.  */
name|temp
operator|=
name|convert_to_mode
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* Handle copying a string constant into an array. 	     The string constant may be shorter than the array. 	     So copy just the string's actual length, and clear the rest.  */
name|rtx
name|size
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* Get the size of the data type of the string, 	     which is actually the size of the target.  */
name|size
operator|=
name|expr_size
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
condition|)
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|size
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Compute the size of the data to copy from the string.  */
name|tree
name|copy_size
init|=
name|size_binop
argument_list|(
name|MIN_EXPR
argument_list|,
name|make_tree
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|build_int_2
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|copy_size_rtx
init|=
name|expand_expr
argument_list|(
name|copy_size
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|label
init|=
literal|0
decl_stmt|;
comment|/* Copy that much.  */
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|copy_size_rtx
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Figure out how much is left in TARGET that we have to clear. 		 Do all calculations in ptr_mode.  */
name|addr
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_modes
argument_list|(
name|ptr_mode
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy_size_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|plus_constant
argument_list|(
name|size
argument_list|,
operator|-
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expand_binop
argument_list|(
name|ptr_mode
argument_list|,
name|add_optab
argument_list|,
name|addr
argument_list|,
name|copy_size_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|size
operator|=
name|expand_binop
argument_list|(
name|ptr_mode
argument_list|,
name|sub_optab
argument_list|,
name|size
argument_list|,
name|copy_size_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|size
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_blt
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|!=
name|const0_rtx
condition|)
block|{
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memset_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|addr
argument_list|,
name|Pmode
argument_list|,
name|const0_rtx
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|ptr_mode
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bzero_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|2
argument_list|,
name|addr
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|ptr_mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|label
condition|)
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't want a value, return NULL_RTX.  */
if|if
condition|(
operator|!
name|want_value
condition|)
return|return
name|NULL_RTX
return|;
comment|/* If we are supposed to return TEMP, do so as long as it isn't a MEM.      ??? The latter test doesn't seem to make sense.  */
elseif|else
if|if
condition|(
name|dont_return_target
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|temp
return|;
comment|/* Return TARGET itself if it is a hard register.  */
elseif|else
if|if
condition|(
name|want_value
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
return|return
name|copy_to_reg
argument_list|(
name|target
argument_list|)
return|;
else|else
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store the value of constructor EXP into the rtx TARGET.    TARGET is either a REG or a MEM.  */
end_comment

begin_function
specifier|static
name|void
name|store_constructor
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* We know our target cannot conflict, since safe_from_p has been called.  */
if|#
directive|if
literal|0
comment|/* Don't try copying piece by piece into a hard register      since that is vulnerable to being clobbered by EXP.      Instead, construct in a pseudo register and then copy it all.  */
block|if (GET_CODE (target) == REG&& REGNO (target)< FIRST_PSEUDO_REGISTER)     {       rtx temp = gen_reg_rtx (GET_MODE (target));       store_constructor (exp, temp);       emit_move_insn (target, temp);       return;     }
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
block|{
specifier|register
name|tree
name|elt
decl_stmt|;
comment|/* Inform later passes that the whole union value is dead.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are building a static constructor into a register, 	 set the initial value as zero so we can fold the value into 	 a constant.  But if more than one register is involved, 	 this probably loses.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* If the constructor has fewer fields than the structure, 	 clear the whole structure first.  */
elseif|else
if|if
condition|(
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|list_length
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Inform later passes that the old value is dead.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store each element of the constructor into 	 the corresponding field of TARGET.  */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
specifier|register
name|tree
name|field
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|tree
name|pos
decl_stmt|,
name|constant
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|to_rtx
init|=
name|target
decl_stmt|;
comment|/* Just ignore missing fields. 	     We cleared the whole structure, above, 	     if any fields are missing.  */
if|if
condition|(
name|field
operator|==
literal|0
condition|)
continue|continue;
name|bitsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|pos
operator|=
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pos
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant
operator|=
name|pos
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pos
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant
operator|=
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
operator|,
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|constant
condition|)
name|bitpos
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|constant
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|rtx
name|offset_rtx
decl_stmt|;
if|if
condition|(
name|contains_placeholder_p
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|offset
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|offset
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|offset_rtx
operator|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|to_rtx
operator|=
name|change_address
argument_list|(
name|to_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|ptr_mode
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|store_field
argument_list|(
name|to_rtx
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
comment|/* The alignment of TARGET is 			  at least what its type requires.  */
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
specifier|register
name|tree
name|elt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|minelt
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|maxelt
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|elttype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* If the constructor has fewer fields than the structure, 	 clear the whole structure first.  Similarly if this this is 	 static constructor of a non-BLKmode object.  */
if|if
condition|(
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|<
name|maxelt
operator|-
name|minelt
operator|+
literal|1
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Inform later passes that the old value is dead.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store each element of the constructor into 	 the corresponding element of TARGET, determined 	 by counting the elements.  */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|tree
name|index
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|rtx
name|xtarget
init|=
name|target
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|rtx
name|pos_rtx
decl_stmt|,
name|addr
decl_stmt|,
name|xtarget
decl_stmt|;
name|tree
name|position
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|index
operator|=
name|size_int
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|position
operator|=
name|size_binop
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|index
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|pos_rtx
operator|=
name|expand_expr
argument_list|(
name|position
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pos_rtx
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|change_address
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|xtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
name|bitpos
operator|=
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
operator|-
name|minelt
operator|)
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|)
expr_stmt|;
else|else
name|bitpos
operator|=
operator|(
name|i
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|store_field
argument_list|(
name|xtarget
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
comment|/* The alignment of TARGET is 			      at least what its type requires.  */
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* set constructor assignments */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
name|tree
name|elt
decl_stmt|;
name|rtx
name|xtarget
init|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|set_word_size
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|nbytes
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|non_const_elements
decl_stmt|;
name|int
name|need_to_clear_first
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|domain_min
decl_stmt|,
name|domain_max
decl_stmt|,
name|bitlength
decl_stmt|;
comment|/* The default implementation strategy is to extract the constant 	 parts of the constructor, use that to initialize the target, 	 and then "or" in whatever non-constant ranges we need in addition.  	 If a large set is all zero or all ones, it is 	 probably better to set it using memset (if available) or bzero. 	 Also, if a large set has just a single range, it may also be 	 better to first clear all the first clear the set (using 	 bzero/memset), and set the bits we want. */
comment|/* Check for all zeros. */
if|if
condition|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|domain_min
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
name|domain_max
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
name|bitlength
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|domain_max
argument_list|,
name|domain_min
argument_list|)
argument_list|,
name|size_one_node
argument_list|)
expr_stmt|;
comment|/* Check for range all ones, or at most a single range.        (This optimization is only a win for big sets.) */
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|BLKmode
operator|&&
name|nbytes
operator|>
literal|16
operator|&&
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|need_to_clear_first
operator|=
literal|1
expr_stmt|;
name|non_const_elements
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|nbits
init|=
name|nbytes
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|set_word_size
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|set_word_size
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|bit_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nbits
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|word
init|=
literal|0
decl_stmt|;
name|int
name|bit_pos
init|=
literal|0
decl_stmt|;
name|int
name|ibit
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* In bytes from beginning of set. */
name|non_const_elements
operator|=
name|get_set_constructor_bits
argument_list|(
name|exp
argument_list|,
name|bit_buffer
argument_list|,
name|nbits
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|bit_buffer
index|[
name|ibit
index|]
condition|)
block|{
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|word
operator||=
operator|(
literal|1
operator|<<
operator|(
name|set_word_size
operator|-
literal|1
operator|-
name|bit_pos
operator|)
operator|)
expr_stmt|;
else|else
name|word
operator||=
literal|1
operator|<<
name|bit_pos
expr_stmt|;
block|}
name|bit_pos
operator|++
expr_stmt|;
name|ibit
operator|++
expr_stmt|;
if|if
condition|(
name|bit_pos
operator|>=
name|set_word_size
operator|||
name|ibit
operator|==
name|nbits
condition|)
block|{
name|rtx
name|datum
init|=
name|GEN_INT
argument_list|(
name|word
argument_list|)
decl_stmt|;
name|rtx
name|to_rtx
decl_stmt|;
comment|/* The assumption here is that it is safe to use XEXP if 		     the set is multi-word, but not if it's single-word. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|to_rtx
operator|=
name|change_address
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|target
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to_rtx
argument_list|,
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibit
operator|==
name|nbits
condition|)
break|break;
name|word
operator|=
literal|0
expr_stmt|;
name|bit_pos
operator|=
literal|0
expr_stmt|;
name|offset
operator|+=
name|set_word_size
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
block|}
name|need_to_clear_first
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|elt
operator|=
name|non_const_elements
init|;
name|elt
operator|!=
name|NULL_TREE
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
comment|/* start of range of element or NULL */
name|tree
name|startbit
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
comment|/* end of range of element, or element value */
name|tree
name|endbit
init|=
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|startb
decl_stmt|,
name|endb
decl_stmt|;
name|rtx
name|bitlength_rtx
decl_stmt|,
name|startbit_rtx
decl_stmt|,
name|endbit_rtx
decl_stmt|,
name|targetx
decl_stmt|;
name|bitlength_rtx
operator|=
name|expand_expr
argument_list|(
name|bitlength
argument_list|,
name|NULL_RTX
argument_list|,
name|MEM
argument_list|,
name|EXPAND_CONST_ADDRESS
argument_list|)
expr_stmt|;
comment|/* handle non-range tuple element like [ expr ]  */
if|if
condition|(
name|startbit
operator|==
name|NULL_TREE
condition|)
block|{
name|startbit
operator|=
name|save_expr
argument_list|(
name|endbit
argument_list|)
expr_stmt|;
name|endbit
operator|=
name|startbit
expr_stmt|;
block|}
name|startbit
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|startbit
argument_list|)
expr_stmt|;
name|endbit
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|endbit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|domain_min
argument_list|)
condition|)
block|{
name|startbit
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|startbit
argument_list|,
name|domain_min
argument_list|)
expr_stmt|;
name|endbit
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|endbit
argument_list|,
name|domain_min
argument_list|)
expr_stmt|;
block|}
name|startbit_rtx
operator|=
name|expand_expr
argument_list|(
name|startbit
argument_list|,
name|NULL_RTX
argument_list|,
name|MEM
argument_list|,
name|EXPAND_CONST_ADDRESS
argument_list|)
expr_stmt|;
name|endbit_rtx
operator|=
name|expand_expr
argument_list|(
name|endbit
argument_list|,
name|NULL_RTX
argument_list|,
name|MEM
argument_list|,
name|EXPAND_CONST_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|targetx
operator|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|targetx
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|targetx
operator|=
name|target
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
comment|/* Optimization:  If startbit and endbit are 	     constants divisible by BITS_PER_UNIT, 	     call memset instead. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|startbit
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|endbit
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|startb
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|startbit
argument_list|)
operator|)
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
operator|&&
operator|(
name|endb
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|endbit
argument_list|)
operator|)
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|need_to_clear_first
operator|&&
name|endb
operator|-
name|startb
operator|!=
name|nbytes
operator|*
name|BITS_PER_UNIT
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|need_to_clear_first
operator|=
literal|0
expr_stmt|;
name|emit_library_call
argument_list|(
name|memset_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|targetx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|startb
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|constm1_rtx
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|endb
operator|-
name|startb
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|need_to_clear_first
condition|)
block|{
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|need_to_clear_first
operator|=
literal|0
expr_stmt|;
block|}
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__setbits"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|,
name|XEXP
argument_list|(
name|targetx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|bitlength_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|startbit_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|endbit_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|targetx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the value of EXP (an expression tree)    into a subfield of TARGET which has mode MODE and occupies    BITSIZE bits, starting BITPOS bits from the start of TARGET.    If MODE is VOIDmode, it means that we are storing into a bit-field.     If VALUE_MODE is VOIDmode, return nothing in particular.    UNSIGNEDP is not used in this case.     Otherwise, return an rtx for the value stored.  This rtx    has mode VALUE_MODE if that is convenient to do.    In this case, UNSIGNEDP must be nonzero if the value is an unsigned type.     ALIGN is the alignment that TARGET is known to have, measured in bytes.    TOTAL_SIZE is the size in bytes of the structure, or -1 if varying.  */
end_comment

begin_function
specifier|static
name|rtx
name|store_field
parameter_list|(
name|target
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|mode
parameter_list|,
name|exp
parameter_list|,
name|value_mode
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|,
name|total_size
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|enum
name|machine_mode
name|value_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|total_size
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|width_mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|width_mask
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If we are storing into an unaligned field of an aligned union that is      in a register, we may have the mode of TARGET being an integer mode but      MODE == BLKmode.  In that case, get an aligned object whose size and      alignment are the same as TARGET and store TARGET into it (we can avoid      the store if the field being stored is the entire width of TARGET).  Then      call ourselves recursively to store the field into a BLKmode version of      that object.  Finally, load from the object into TARGET.  This is not      very efficient in general, but should only be slightly more expensive      than the otherwise-required unaligned accesses.  Perhaps this can be      cleaned up later.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
block|{
name|rtx
name|object
init|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|blk_object
init|=
name|copy_rtx
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|object
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|blk_object
argument_list|)
operator|=
literal|1
expr_stmt|;
name|PUT_MODE
argument_list|(
name|blk_object
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitsize
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|object
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|store_field
argument_list|(
name|blk_object
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
comment|/* Even though we aren't returning target, we need to 	 give it the updated value.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
name|blk_object
return|;
block|}
comment|/* If the structure is in a register or if the component      is a bit field, we cannot use addressing to access it.      Use bit-field techniques or SUBREG to store in it.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
operator|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|!
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|)
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
comment|/* If the field isn't aligned enough to store as an ordinary memref, 	 store it as a bit field.  */
operator|||
operator|(
name|SLOW_UNALIGNED_ACCESS
operator|&&
name|align
operator|*
name|BITS_PER_UNIT
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|SLOW_UNALIGNED_ACCESS
operator|&&
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Unless MODE is VOIDmode or BLKmode, convert TEMP to 	 MODE.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Store the value in the bitfield.  */
name|store_bit_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_mode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* The caller wants an rtx for the value.  */
comment|/* If possible, avoid refetching from the bitfield itself.  */
if|if
condition|(
name|width_mask
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
condition|)
block|{
name|tree
name|count
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
if|if
condition|(
name|unsignedp
condition|)
return|return
name|expand_and
argument_list|(
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|width_mask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
return|;
name|tmode
operator|=
name|GET_MODE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmode
operator|==
name|VOIDmode
condition|)
name|tmode
operator|=
name|value_mode
expr_stmt|;
name|count
operator|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tmode
argument_list|,
name|temp
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|tmode
argument_list|,
name|temp
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|extract_bit_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
name|NULL_RTX
argument_list|,
name|value_mode
argument_list|,
literal|0
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
return|;
block|}
return|return
name|const0_rtx
return|;
block|}
else|else
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|to_rtx
decl_stmt|;
comment|/* If a value is wanted, it must be the lhs; 	 so make the address stable for multiple use.  */
if|if
condition|(
name|value_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|addr
argument_list|)
comment|/* A frame-pointer reference is already stable.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
operator|||
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|)
operator|)
condition|)
name|addr
operator|=
name|copy_to_reg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Now build a reference to just the desired component.  */
name|to_rtx
operator|=
name|change_address
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|store_expr
argument_list|(
name|exp
argument_list|,
name|to_rtx
argument_list|,
name|value_mode
operator|!=
name|VOIDmode
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if any object containing the innermost array is an unaligned    packed structure field.  */
end_comment

begin_function
specifier|static
name|int
name|get_inner_unaligned_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|needed_alignment
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|needed_alignment
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|NON_LVALUE_EXPR
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
break|break;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an expression EXP that may be a COMPONENT_REF, a BIT_FIELD_REF,    or an ARRAY_REF, look for nested COMPONENT_REFs, BIT_FIELD_REFs, or    ARRAY_REFs and find the ultimate containing object, which we return.     We set *PBITSIZE to the size in bits that we want, *PBITPOS to the    bit position, and *PUNSIGNEDP to the signedness of the field.    If the position of the field is variable, we store a tree    giving the variable offset (in units) in *POFFSET.    This offset is in addition to the bit position.    If the position is not variable, we store 0 in *POFFSET.     If any of the extraction expressions is volatile,    we store 1 in *PVOLATILEP.  Otherwise we don't change that.     If the field is a bit-field, *PMODE is set to VOIDmode.  Otherwise, it    is a mode that can be used to access the field.  In that case, *PBITSIZE    is redundant.     If the field describes a variable-sized object, *PMODE is set to    VOIDmode and *PBITSIZE is set to -1.  An access cannot be made in    this case, but the address of the object can be found.  */
end_comment

begin_function
name|tree
name|get_inner_reference
parameter_list|(
name|exp
parameter_list|,
name|pbitsize
parameter_list|,
name|pbitpos
parameter_list|,
name|poffset
parameter_list|,
name|pmode
parameter_list|,
name|punsignedp
parameter_list|,
name|pvolatilep
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
modifier|*
name|pbitsize
decl_stmt|;
name|int
modifier|*
name|pbitpos
decl_stmt|;
name|tree
modifier|*
name|poffset
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|pmode
decl_stmt|;
name|int
modifier|*
name|punsignedp
decl_stmt|;
name|int
modifier|*
name|pvolatilep
decl_stmt|;
block|{
name|tree
name|orig_exp
init|=
name|exp
decl_stmt|;
name|tree
name|size_tree
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|tree
name|offset
init|=
name|integer_zero_node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|size_tree
operator|=
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|size_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size_tree
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size_tree
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|mode
operator|=
name|BLKmode
operator|,
operator|*
name|pbitsize
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|pbitsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|size_tree
argument_list|)
expr_stmt|;
block|}
comment|/* Compute cumulative bit-offset for nested component-refs and array-refs,      and find the ultimate containing object.  */
operator|*
name|pbitpos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|tree
name|pos
init|=
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|?
name|DECL_FIELD_BITPOS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|)
decl_stmt|;
name|tree
name|constant
init|=
name|integer_zero_node
decl_stmt|,
name|var
init|=
name|pos
decl_stmt|;
comment|/* If this field hasn't been filled in yet, don't go 	     past it.  This should only happen when folding expressions 	     made during type construction.  */
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
break|break;
comment|/* Assume here that the offset is a multiple of a unit. 	     If not, there should be an explicitly added constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pos
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant
operator|=
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
operator|,
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pos
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant
operator|=
name|pos
operator|,
name|var
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|pbitpos
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|constant
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
condition|)
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|size_binop
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|var
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
comment|/* This code is based on the code in case ARRAY_REF in expand_expr 	     below.  We assume here that the size of an array element is 	     always an integral multiple of BITS_PER_UNIT.  */
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|low_bound
init|=
name|domain
condition|?
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
else|:
name|integer_zero_node
decl_stmt|;
name|tree
name|index_type
init|=
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|low_bound
argument_list|)
condition|)
name|index
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|index
argument_list|,
name|low_bound
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|index_type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
condition|)
block|{
name|index
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|index_type
argument_list|,
name|index
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|index
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|pbitpos
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|index
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|NON_LVALUE_EXPR
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
operator|)
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
break|break;
comment|/* If any reference in the chain is volatile, the effect is volatile.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
operator|*
name|pvolatilep
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this was a bit-field, see if there is a mode that allows direct      access in case EXP is in memory.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|&&
operator|*
name|pbitsize
operator|!=
literal|0
operator|&&
operator|*
name|pbitpos
operator|%
operator|*
name|pbitsize
operator|==
literal|0
condition|)
block|{
name|mode
operator|=
name|mode_for_size
argument_list|(
operator|*
name|pbitsize
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|mode
operator|=
name|VOIDmode
expr_stmt|;
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
operator|&&
name|contains_placeholder_p
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|offset
argument_list|,
name|orig_exp
argument_list|)
expr_stmt|;
operator|*
name|pmode
operator|=
name|mode
expr_stmt|;
operator|*
name|poffset
operator|=
name|offset
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an rtx VALUE that may contain additions and multiplications,    return an equivalent value that just refers to a register or memory.    This is done by generating instructions to perform the arithmetic    and returning a pseudo-register containing the value.     The returned value may be a REG, SUBREG, MEM or constant.  */
end_comment

begin_function
name|rtx
name|force_operand
parameter_list|(
name|value
parameter_list|,
name|target
parameter_list|)
name|rtx
name|value
decl_stmt|,
name|target
decl_stmt|;
block|{
specifier|register
name|optab
name|binoptab
init|=
literal|0
decl_stmt|;
comment|/* Use a temporary to force order of execution of calls to      `force_operand'.  */
name|rtx
name|tmp
decl_stmt|;
specifier|register
name|rtx
name|op2
decl_stmt|;
comment|/* Use subtarget as the target for operand 0 of a binary operation.  */
specifier|register
name|rtx
name|subtarget
init|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PLUS
condition|)
name|binoptab
operator|=
name|add_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MINUS
condition|)
name|binoptab
operator|=
name|sub_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|op2
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|op2
operator|!=
name|subtarget
operator|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
return|return
name|expand_mult
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|force_operand
argument_list|(
name|op2
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|binoptab
condition|)
block|{
name|op2
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|op2
operator|!=
name|subtarget
operator|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|binoptab
operator|==
name|sub_optab
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|binoptab
operator|=
name|add_optab
expr_stmt|;
name|op2
operator|=
name|negate_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
comment|/* Check for an addition with OP2 a constant integer and our first 	 operand a PLUS of a virtual register and something else.  In that 	 case, we want to emit the sum of the virtual register and the 	 constant first and then add the other value.  This allows virtual 	 register instantiation to simply modify the constant rather than 	 creating another one around this addition.  */
if|if
condition|(
name|binoptab
operator|==
name|add_optab
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|rtx
name|temp
init|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|binoptab
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op2
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
return|return
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|binoptab
argument_list|,
name|temp
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
block|}
name|tmp
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|binoptab
argument_list|,
name|tmp
argument_list|,
name|force_operand
argument_list|(
name|op2
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
comment|/* We give UNSIGNEDP = 0 to expand_binop 	 because the only operations we are expanding here are signed ones.  */
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of expand_expr:    save the non-copied parts (LIST) of an expr (LHS), and return a list    which can restore these values to their previous values,    should something modify their storage.  */
end_comment

begin_function
specifier|static
name|tree
name|save_noncopied_parts
parameter_list|(
name|lhs
parameter_list|,
name|list
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
name|tree
name|parts
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|parts
operator|=
name|chainon
argument_list|(
name|parts
argument_list|,
name|save_noncopied_parts
argument_list|(
name|lhs
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|part
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|part_type
init|=
name|TREE_TYPE
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|tree
name|to_be_saved
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|part_type
argument_list|,
name|lhs
argument_list|,
name|part
argument_list|)
decl_stmt|;
name|rtx
name|target
init|=
name|assign_stack_temp
argument_list|(
name|TYPE_MODE
argument_list|(
name|part_type
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|part_type
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|target
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|part_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|part_type
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|target
operator|=
name|change_address
argument_list|(
name|target
argument_list|,
name|TYPE_MODE
argument_list|(
name|part_type
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|parts
operator|=
name|tree_cons
argument_list|(
name|to_be_saved
argument_list|,
name|build
argument_list|(
name|RTL_EXPR
argument_list|,
name|part_type
argument_list|,
name|NULL_TREE
argument_list|,
operator|(
name|tree
operator|)
name|target
argument_list|)
argument_list|,
name|parts
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parts
argument_list|)
argument_list|,
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|parts
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|parts
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of expand_expr:    record the non-copied parts (LIST) of an expr (LHS), and return a list    which specifies the initial values of these parts.  */
end_comment

begin_function
specifier|static
name|tree
name|init_noncopied_parts
parameter_list|(
name|lhs
parameter_list|,
name|list
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
name|tree
name|parts
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|parts
operator|=
name|chainon
argument_list|(
name|parts
argument_list|,
name|init_noncopied_parts
argument_list|(
name|lhs
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|part
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|part_type
init|=
name|TREE_TYPE
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|tree
name|to_be_initialized
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|part_type
argument_list|,
name|lhs
argument_list|,
name|part
argument_list|)
decl_stmt|;
name|parts
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|to_be_initialized
argument_list|,
name|parts
argument_list|)
expr_stmt|;
block|}
return|return
name|parts
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of expand_expr: return nonzero iff there is no way that    EXP can reference X, which is being modified.  */
end_comment

begin_function
specifier|static
name|int
name|safe_from_p
parameter_list|(
name|x
parameter_list|,
name|exp
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|tree
name|exp
decl_stmt|;
block|{
name|rtx
name|exp_rtl
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nops
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
comment|/* If EXP has varying size, we MUST use a target since we currently 	 have no way of allocating temporaries of variable size.  So we 	 assume here that something at a higher level has prevented a 	 clash.  This is somewhat bogus, but the best we can do.  Only 	 do this when X is BLKmode.  */
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If this is a subreg of a hard register, declare it unsafe, otherwise,      find the underlying pseudo.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
comment|/* If X is a location in the outgoing argument area, it is always safe.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
operator|)
operator|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
name|exp_rtl
operator|=
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
return|return
literal|1
return|;
case|case
literal|'x'
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
condition|)
return|return
operator|(
operator|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|||
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|||
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
operator|)
return|;
else|else
return|return
literal|0
return|;
case|case
literal|'1'
case|:
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
literal|'2'
case|:
case|case
literal|'<'
case|:
return|return
operator|(
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'e'
case|:
case|case
literal|'r'
case|:
comment|/* Now do code-specific tests.  EXP_RTL is set to any rtx we find in 	 the expression.  If it is set, we conflict iff we are that rtx or 	 both are in memory.  Otherwise, we check all operands of the 	 expression recursively.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
return|return
operator|(
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CALL_EXPR
case|:
name|exp_rtl
operator|=
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp_rtl
operator|==
literal|0
condition|)
block|{
comment|/* Assume that the call will clobber all hard registers and 		 all of memory.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
name|RTL_EXPR
case|:
comment|/* If a sequence exists, we would have to scan every instruction 	     in the sequence to see if it was safe.  This is probably not 	     worthwhile.  */
if|if
condition|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
name|exp_rtl
operator|=
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|exp_rtl
operator|=
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEANUP_POINT_EXPR
case|:
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
name|exp_rtl
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIND_EXPR
case|:
comment|/* The only operand we look at is operand 1.  The rest aren't 	     part of the expression.  */
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|METHOD_CALL_EXPR
case|:
comment|/* This takes a rtx argument, but shouldn't appear here. */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If we have an rtx, we do not need to scan our operands.  */
if|if
condition|(
name|exp_rtl
condition|)
break|break;
name|nops
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* If we have an rtl, find any enclosed object.  Then see if we conflict      with it.  */
if|if
condition|(
name|exp_rtl
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp_rtl
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|exp_rtl
operator|=
name|SUBREG_REG
argument_list|(
name|exp_rtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp_rtl
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|exp_rtl
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
comment|/* If the rtl is X, then it is not safe.  Otherwise, it is unless both 	 are memory and EXP is not readonly.  */
return|return
operator|!
operator|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|exp_rtl
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|exp_rtl
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/* If we reach here, it is safe.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of expand_expr: return nonzero iff EXP is an    expression whose type is statically determinable.  */
end_comment

begin_function
specifier|static
name|int
name|fixed_type_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CALL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TARGET_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ARRAY_REF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* expand_expr: generate code for computing expression EXP.    An rtx for the computed value is returned.  The value is never null.    In the case of a void EXP, const0_rtx is returned.     The value may be stored in TARGET if TARGET is nonzero.    TARGET is just a suggestion; callers must assume that    the rtx returned may not be the same as TARGET.     If TARGET is CONST0_RTX, it means that the value will be ignored.     If TMODE is not VOIDmode, it suggests generating the    result in mode TMODE.  But this is done only when convenient.    Otherwise, TMODE is ignored and the value generated in its natural mode.    TMODE is just a suggestion; callers must assume that    the rtx returned may not have mode TMODE.     Note that TARGET may have neither TMODE nor MODE.  In that case, it    probably will not be used.     If MODIFIER is EXPAND_SUM then when EXP is an addition    we can return an rtx of the form (MULT (REG ...) (CONST_INT ...))    or a nest of (PLUS ...) and (MINUS ...) where the terms are    products as above, or REG or MEM, or constant.    Ordinarily in such cases we would output mul or add instructions    and then return a pseudo reg containing the sum.     EXPAND_INITIALIZER is much like EXPAND_SUM except that    it also marks a label as absolutely required (it can't be dead).    It also makes a ZERO_EXTEND or SIGN_EXTEND instead of emitting extend insns.    This is used for outputting expressions used in initializers.     EXPAND_CONST_ADDRESS says that it is okay to return a MEM    with a constant address even if that address is not normally legitimate.    EXPAND_INITIALIZER and EXPAND_SUM also have this effect.  */
end_comment

begin_function
name|rtx
name|expand_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
comment|/* Chain of pending expressions for PLACEHOLDER_EXPR to replace.      This is static so it will be accessible to our recursive callees.  */
specifier|static
name|tree
name|placeholder_list
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|temp
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|optab
name|this_optab
decl_stmt|;
comment|/* Use subtarget as the target for operand 0 of a binary operation.  */
name|rtx
name|subtarget
init|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
literal|0
operator|)
decl_stmt|;
name|rtx
name|original_target
init|=
name|target
decl_stmt|;
comment|/* Maybe defer this until sure not doing bytecode?  */
name|int
name|ignore
init|=
operator|(
name|target
operator|==
name|const0_rtx
operator|||
operator|(
operator|(
name|code
operator|==
name|NON_LVALUE_EXPR
operator|||
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|REFERENCE_EXPR
operator|||
name|code
operator|==
name|COND_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|)
operator|)
decl_stmt|;
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|output_bytecode
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
block|{
name|bc_expand_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Don't use hard regs as subtargets, because the combiner      can only handle pseudo regs.  */
if|if
condition|(
name|subtarget
operator|&&
name|REGNO
argument_list|(
name|subtarget
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* Avoid subtargets inside loops,      since they hide some invariant expressions.  */
if|if
condition|(
name|preserve_subexpressions_p
argument_list|()
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* If we are going to ignore this result, we need only do something      if there is a side-effect somewhere in the expression.  If there      is, short-circuit the most common cases here.  Note that we must      not call expand_expr with anything but const0_rtx in case this      is an initial expansion of a size that contains a PLACEHOLDER_EXPR.  */
if|if
condition|(
name|ignore
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* Ensure we reference a volatile object even if value is ignored.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
comment|/* If the second operand has no side effects, just evaluate 	   the first. */
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
return|;
name|target
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If will do cse, generate all results into pseudo registers      since 1) that allows cse to find more things      and 2) otherwise cse could produce an insn the machine      cannot support.  */
if|if
condition|(
operator|!
name|cse_not_expected
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|target
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|target
operator|=
name|subtarget
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_DECL
case|:
block|{
name|tree
name|function
init|=
name|decl_function_context
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Handle using a label in a containing function.  */
if|if
condition|(
name|function
operator|!=
name|current_function_decl
operator|&&
name|function
operator|!=
literal|0
condition|)
block|{
name|struct
name|function
modifier|*
name|p
init|=
name|find_function_data
argument_list|(
name|function
argument_list|)
decl_stmt|;
comment|/* Allocate in the memory associated with the function 	       that the label is in.  */
name|push_obstacks
argument_list|(
name|p
operator|->
name|function_obstack
argument_list|,
name|p
operator|->
name|function_maybepermanent_obstack
argument_list|)
expr_stmt|;
name|p
operator|->
name|forced_labels
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|label_rtx
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
operator|->
name|forced_labels
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
name|forced_labels
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|label_rtx
argument_list|(
name|exp
argument_list|)
argument_list|,
name|forced_labels
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|FUNCTION_MODE
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|label_rtx
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|!=
name|current_function_decl
operator|&&
name|function
operator|!=
literal|0
condition|)
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|exp
argument_list|,
literal|"prior parameter's size depends on `%s'"
argument_list|)
expr_stmt|;
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
comment|/* ... fall through ... */
case|case
name|VAR_DECL
case|:
comment|/* If a static var's type was incomplete when the decl was written, 	 but the type is complete now, lay out the decl now.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|layout_decl
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* ... fall through ... */
case|case
name|FUNCTION_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ensure variable marked as used even if it doesn't go through 	 a parser.  If it hasn't be used yet, write out an external 	 definition.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Handle variables inherited from containing functions.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* We treat inline_function_decl as an alias for the current function 	 because that is the inline function whose vars, types, etc. 	 are being merged into the current function. 	 See expand_inline_function.  */
if|if
condition|(
name|context
operator|!=
literal|0
operator|&&
name|context
operator|!=
name|current_function_decl
operator|&&
name|context
operator|!=
name|inline_function_decl
comment|/* If var is static, we don't need a static chain to access it.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|;
comment|/* Mark as non-local and addressable.  */
name|DECL_NONLOCAL
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_addressable
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MEM
condition|)
name|addr
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|fix_lexical_addr
argument_list|(
name|addr
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|change_address
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
return|;
block|}
comment|/* This is the case of an array whose size is to be determined 	 from its initializer, while the initializer is still being parsed. 	 See expand_decl.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
name|change_address
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* If DECL_RTL is memory, we are in the normal case and either 	 the address is not valid or it is not a register and -fforce-addr 	 is specified, get the address into a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
operator|)
condition|)
return|return
name|change_address
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If the mode of DECL_RTL does not match that of the decl, it 	 must be a promoted value.  We return a SUBREG of the wanted mode, 	 but mark it so that we know that it was already extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|mode
condition|)
block|{
comment|/* Get the signedness used for this variable.  Ensure we get the 	     same mode we got when the variable was declared.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|temp
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
return|return
name|expand_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|REAL_CST
case|:
comment|/* If optimized, generate immediate CONST_DOUBLE 	 which will be turned into memory by reload if necessary.        	 We used to force a register so that loop.c could see it.  But 	 this does not allow gen_* patterns to perform optimizations with 	 the constants.  It also produces two insns in cases like "x = 1.0;". 	 On most machines, floating-point constants are not permitted in 	 many insns, so we'd end up copying it to a register in any case.  	 Now, we do the copying in expand_binop, if appropriate.  */
return|return
name|immed_real_const
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
case|case
name|STRING_CST
case|:
if|if
condition|(
operator|!
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
condition|)
name|output_constant_def
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* TREE_CST_RTL probably contains a constant address. 	 On RISC machines where a constant address isn't valid, 	 make some insns to get that address into a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
operator|)
condition|)
return|return
name|change_address
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
name|context
operator|=
name|decl_function_context
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* We treat inline_function_decl as an alias for the current function 	 because that is the inline function whose vars, types, etc. 	 are being merged into the current function. 	 See expand_inline_function.  */
if|if
condition|(
name|context
operator|==
name|current_function_decl
operator|||
name|context
operator|==
name|inline_function_decl
condition|)
name|context
operator|=
literal|0
expr_stmt|;
comment|/* If this is non-local, handle it.  */
if|if
condition|(
name|context
condition|)
block|{
name|temp
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|put_var_into_stack
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|change_address
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|,
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|temp
operator|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|temp
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|temp
operator|=
name|const0_rtx
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|promote_mode
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
condition|)
name|save_expr_regs
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|save_expr_regs
argument_list|)
expr_stmt|;
comment|/* If the mode of TEMP does not match that of the expression, it 	     must be a promoted value.  We pass store_expr a SUBREG of the 	     wanted mode but mark it so that we know that it was already 	     extended.  Note that `unsignedp' was modified above in 	     this case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|mode
condition|)
block|{
name|temp
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|temp
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the mode of SAVE_EXPR_RTL does not match that of the expression, it 	 must be a promoted value.  We return a SUBREG of the wanted mode, 	 but mark it so that we know that it was already extended. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|mode
condition|)
block|{
comment|/* Compute the signedness and make the proper SUBREG.  */
name|promote_mode
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|temp
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|PLACEHOLDER_EXPR
case|:
comment|/* If there is an object on the head of the placeholder list, 	 see if some object in it's references is of type TYPE.  For 	 further information, see tree.def.  */
if|if
condition|(
name|placeholder_list
condition|)
block|{
name|tree
name|object
decl_stmt|;
name|tree
name|old_list
init|=
name|placeholder_list
decl_stmt|;
for|for
control|(
name|object
operator|=
name|TREE_PURPOSE
argument_list|(
name|placeholder_list
argument_list|)
init|;
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|==
literal|'e'
operator|)
condition|;
name|object
operator|=
name|TREE_OPERAND
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|object
operator|!=
literal|0
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
comment|/* Expand this object skipping the list entries before 		 it was found in case it is also a PLACEHOLDER_EXPR. 		 In that case, we want to translate it using subsequent 		 entries.  */
name|placeholder_list
operator|=
name|TREE_CHAIN
argument_list|(
name|placeholder_list
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|object
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|placeholder_list
operator|=
name|old_list
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
comment|/* We can't find the object or there was a missing WITH_RECORD_EXPR.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|WITH_RECORD_EXPR
case|:
comment|/* Put the object on the placeholder list, expand our first operand, 	 and pop the list.  */
name|placeholder_list
operator|=
name|tree_cons
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|placeholder_list
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|placeholder_list
operator|=
name|TREE_CHAIN
argument_list|(
name|placeholder_list
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|EXIT_EXPR
case|:
name|expand_exit_loop_if_false
argument_list|(
name|NULL_PTR
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|LOOP_EXPR
case|:
name|push_temp_slots
argument_list|()
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BIND_EXPR
case|:
block|{
name|tree
name|vars
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|vars_need_expansion
init|=
literal|0
decl_stmt|;
comment|/* Need to open a binding contour here because 	   if there are any cleanups they most be contained here.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark the corresponding BLOCK for output in its proper place.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|insert_block
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If VARS have not yet been expanded, expand them now.  */
while|while
condition|(
name|vars
condition|)
block|{
if|if
condition|(
name|DECL_RTL
argument_list|(
name|vars
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vars_need_expansion
operator|=
literal|1
expr_stmt|;
name|expand_decl
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
name|expand_decl_init
argument_list|(
name|vars
argument_list|)
expr_stmt|;
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|RTL_EXPR
case|:
if|if
condition|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
operator|==
name|const0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|preserve_rtl_expr_result
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|free_temps_for_rtl_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
comment|/* If we don't need the result, just ensure we evaluate any 	 subexpressions.  */
if|if
condition|(
name|ignore
condition|)
block|{
name|tree
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* All elts simple constants => refer to a constant in memory.  But 	 if this is a non-BLKmode mode, let it store a field at a time 	 since that should make a CONST_INT or CONST_DOUBLE when we 	 fold.  Likewise, if we have a target we can use, it is best to 	 store directly into the target unless the type is large enough 	 that memcpy will be used.  If we are making an initializer and 	 all operands are constant, put it in memory as well.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|&&
operator|!
operator|(
name|target
operator|!=
literal|0
operator|&&
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|)
operator|)
operator|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|move_by_pieces_ninsns
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
operator|>
name|MOVE_RATIO
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|&&
name|TREE_CONSTANT
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|constructor
init|=
name|output_constant_def
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|constructor
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|constructor
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|constructor
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
operator|)
condition|)
name|constructor
operator|=
name|change_address
argument_list|(
name|constructor
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|constructor
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|constructor
return|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
else|else
block|{
name|target
operator|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|MEM_IN_STRUCT_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|store_constructor
argument_list|(
name|exp
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|exp1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|exp2
decl_stmt|;
comment|/* A SAVE_EXPR as the address in an INDIRECT_EXPR is generated 	   for  *PTR += ANYTHING  where PTR is put inside the SAVE_EXPR. 	   This code has the same general effect as simply doing 	   expand_expr on the save expr, except that the expression PTR 	   is computed for use as a memory address.  This means different 	   code, suitable for indexing, may be generated.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp1
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|SAVE_EXPR_RTL
argument_list|(
name|exp1
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp1
argument_list|)
argument_list|)
operator|==
name|ptr_mode
condition|)
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|op0
operator|=
name|copy_all_regs
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|SAVE_EXPR_RTL
argument_list|(
name|exp1
argument_list|)
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|exp1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* If address was computed by addition, 	   mark this as an element of an aggregate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
operator|)
operator|||
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|exp1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|exp2
operator|=
name|TREE_OPERAND
argument_list|(
name|exp1
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp2
argument_list|)
argument_list|)
operator|)
condition|)
name|MEM_IN_STRUCT_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|temp
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator||
name|flag_volatile
expr_stmt|;
comment|/* It is incorrect to set RTX_UNCHANGING_P from TREE_READONLY 	   here, because, in C and C++, the fact that a location is accessed 	   through a pointer to const does not mean that the value there can 	   never change.  Languages where it can never change should 	   also set TREE_STATIC.  */
name|RTX_UNCHANGING_P
argument_list|(
name|temp
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|{
name|tree
name|array
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|low_bound
init|=
name|domain
condition|?
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
else|:
name|integer_zero_node
decl_stmt|;
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|index_type
init|=
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|low_bound
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|contains_placeholder_p
argument_list|(
name|low_bound
argument_list|)
condition|)
name|low_bound
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|low_bound
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* Optimize the special-case of a zero lower bound.  	   We convert the low_bound to sizetype to avoid some problems 	   with constant folding.  (E.g. suppose the lower bound is 1, 	   and its mode is QI.  Without the conversion,  (ARRAY 	   +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1)) 	   +INDEX), which becomes (ARRAY+255+INDEX).  Oops!)  	   But sizetype isn't quite right either (especially if 	   the lowbound is negative).  FIXME */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|low_bound
argument_list|)
condition|)
name|index
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|index
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|low_bound
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|&&
operator|(
operator|!
name|SLOW_UNALIGNED_ACCESS
operator|||
operator|!
name|get_inner_unaligned_p
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
comment|/* Nonconstant array index or nonconstant element size, and 	       not an array in an unaligned (packed) structure field. 	       Generate the tree for *(&array+index) and expand that, 	       except do it in a language-independent way 	       and don't complain about non-lvalue arrays. 	       `mark_addressable' should already have been called 	       for any array for which this case will be reached.  */
comment|/* Don't forget the const or volatile flag from the array 	       element. */
name|tree
name|variant_type
init|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|array_adr
init|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|variant_type
argument_list|)
argument_list|,
name|array
argument_list|)
decl_stmt|;
name|tree
name|elt
decl_stmt|;
name|tree
name|size
init|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Convert the integer argument to a type the same size as sizetype 	       so the multiply won't overflow spuriously.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|index_type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
condition|)
name|index
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|contains_placeholder_p
argument_list|(
name|size
argument_list|)
condition|)
name|size
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|size
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* Don't think the address has side effects 	       just because the array does. 	       (In some cases the address might have side effects, 	       and we fail to record that fact here.  However, it should not 	       matter, since expand_expr should not care.)  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|array_adr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|elt
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|variant_type
argument_list|)
argument_list|,
name|array_adr
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|variant_type
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
comment|/* Volatility, etc., of new expression is same as old 	       expression.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|elt
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|elt
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|elt
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|elt
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
comment|/* Fold an expression like: "foo"[2]. 	   This is not done in fold so it won't happen inside&. 	   Don't fold if this is for wide characters since it's too 	   difficult to do correctly and this is a very rare case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_INT_CST_HIGH
argument_list|(
name|index
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
operator|)
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|array
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
condition|)
return|return
name|GEN_INT
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|array
argument_list|)
index|[
name|i
index|]
argument_list|)
return|;
comment|/* If this is a constant index into a constant array, 	   just get the value from the array.  Handle both the cases when 	   we have an explicit constructor and when our operand is a variable 	   that was declared const.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|index
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|elem
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
name|i
operator|--
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|optimize
operator|>=
literal|1
operator|&&
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|index
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|tree
name|elem
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
decl_stmt|;
while|while
condition|(
name|elem
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elem
argument_list|)
argument_list|,
name|index
argument_list|)
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|i
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|init
argument_list|)
condition|)
return|return
name|GEN_INT
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|init
argument_list|)
index|[
name|i
index|]
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Treat array-ref with constant index as a component-ref.  */
case|case
name|COMPONENT_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
comment|/* If the operand is a CONSTRUCTOR, we can just extract the 	 appropriate field if it is present.  Don't do this if we have 	 already written the data since we want to refer to that copy 	 and varasm.c assumes that's what we'll do.  */
if|if
condition|(
name|code
operator|!=
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_CST_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
block|{
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
name|tree
name|tem
init|=
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode1
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|)
decl_stmt|;
name|int
name|alignment
decl_stmt|;
comment|/* If we got back the original object, something is wrong.  Perhaps 	   we are evaluating an expression too early.  In any event, don't 	   infinitely recurse.  */
if|if
condition|(
name|tem
operator|==
name|exp
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* In some cases, we will be offsetting OP0's address by a constant. 	   So get it as a sum, if possible.  If we will be using it 	   directly in an insn, we validate it.   	   If TEM's type is a union of variable size, pass TARGET to the inner 	   computation, since it will need a temporary and TARGET is known 	   to have to do.  This occurs in unchecked conversion in Ada.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|tem
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|?
name|target
else|:
name|NULL_RTX
operator|)
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
comment|/* If this is a constant, put it into a register if it is a 	   legitimate constant and memory if it isn't.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|alignment
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset_rtx
init|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|ptr_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a variable offset, the known alignment 	     is only that of the innermost structure containing the field. 	     (Actually, we could sometimes do better by using the 	     size of an element of the innermost array, but no need.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
name|alignment
operator|=
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
block|}
comment|/* Don't forget about volatility even if this is a bitfield.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|volatilep
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|copy_rtx
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* In cases where an aligned union has an unaligned object 	   as a field, we might be extracting a BLKmode value from 	   an integer-mode (e.g., SImode) object.  Handle this case 	   by doing the extract into an object as wide as the field 	   (which we know to be the width of a basic mode), then 	   storing into memory, and changing the mode to BLKmode.  */
if|if
condition|(
name|mode1
operator|==
name|VOIDmode
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
operator|(
operator|(
name|mode1
operator|!=
name|BLKmode
operator|&&
operator|!
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode1
index|]
operator|)
comment|/* If the field isn't aligned enough to fetch as a memref, 		       fetch it as a bit field.  */
operator|||
operator|(
name|SLOW_UNALIGNED_ACCESS
operator|&&
operator|(
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|ext_mode
init|=
name|mode
decl_stmt|;
if|if
condition|(
name|ext_mode
operator|==
name|BLKmode
condition|)
name|ext_mode
operator|=
name|mode_for_size
argument_list|(
name|bitsize
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_mode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op0
operator|=
name|extract_bit_field
argument_list|(
name|validize_mem
argument_list|(
name|op0
argument_list|)
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
name|target
argument_list|,
name|ext_mode
argument_list|,
name|ext_mode
argument_list|,
name|alignment
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|rtx
name|new
init|=
name|assign_stack_temp
argument_list|(
name|ext_mode
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|new
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|copy_rtx
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|op0
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|op0
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|op0
return|;
block|}
comment|/* Get a reference to just this component.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|||
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
name|op0
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode1
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|op0
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
operator||=
name|volatilep
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|mode1
operator|||
name|mode1
operator|==
name|BLKmode
operator|||
name|mode1
operator|==
name|tmode
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|OFFSET_REF
case|:
block|{
name|tree
name|base
init|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|addr
init|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|base
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|addr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|memory_address
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|temp
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* It is incorrect to set RTX_UNCHANGING_P here, because the fact that 	 a location is accessed through a pointer to const does not mean 	 that the value there can never change.  */
block|RTX_UNCHANGING_P (temp) = TREE_READONLY (exp);
endif|#
directive|endif
return|return
name|temp
return|;
block|}
comment|/* Intended for a reference to a buffer of a file-object in Pascal. 	 But it's not certain that a special tree code will really be 	 necessary for these.  INDIRECT_REF might work for them.  */
case|case
name|BUFFER_REF
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|IN_EXPR
case|:
block|{
comment|/* Pascal set IN expression.  	   Algorithm: 	       rlo       = set_low - (set_low%bits_per_word); 	       the_word  = set [ (index - rlo)/bits_per_word ]; 	       bit_index = index % bits_per_word; 	       bitmask   = 1<< bit_index; 	       return !!(the_word& bitmask);  */
name|tree
name|set
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|iunsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|set_type
init|=
name|TREE_TYPE
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|tree
name|set_low_bound
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|set_type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|set_high_bound
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|set_type
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|index_val
init|=
name|expand_expr
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|lo_r
init|=
name|expand_expr
argument_list|(
name|set_low_bound
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|hi_r
init|=
name|expand_expr
argument_list|(
name|set_high_bound
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|setval
init|=
name|expand_expr
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|setaddr
init|=
name|XEXP
argument_list|(
name|setval
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|index_mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|rlow
decl_stmt|;
name|rtx
name|diff
decl_stmt|,
name|quo
decl_stmt|,
name|rem
decl_stmt|,
name|addr
decl_stmt|,
name|bit
decl_stmt|,
name|result
decl_stmt|;
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If domain is empty, answer is no.  Likewise if index is constant 	   and out of bounds.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|set_high_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|set_low_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|set_high_bound
argument_list|,
name|set_low_bound
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|set_low_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|index
argument_list|,
name|set_low_bound
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|set_high_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|set_high_bound
argument_list|,
name|index
argument_list|)
operator|)
operator|)
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
comment|/* If we get here, we have to generate the code for both cases 	   (in range and out of range).  */
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|index_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|lo_r
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index_val
argument_list|,
name|lo_r
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|index_val
argument_list|)
argument_list|,
name|iunsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_blt
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|index_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|hi_r
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|index_val
argument_list|,
name|hi_r
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|index_val
argument_list|)
argument_list|,
name|iunsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bgt
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate the element number of bit zero in the first word 	   of the set.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|lo_r
argument_list|)
operator|==
name|CONST_INT
condition|)
name|rlow
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|lo_r
argument_list|)
operator|&
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
else|else
name|rlow
operator|=
name|expand_binop
argument_list|(
name|index_mode
argument_list|,
name|and_optab
argument_list|,
name|lo_r
argument_list|,
name|GEN_INT
argument_list|(
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|diff
operator|=
name|expand_binop
argument_list|(
name|index_mode
argument_list|,
name|sub_optab
argument_list|,
name|index_val
argument_list|,
name|rlow
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|quo
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|index_mode
argument_list|,
name|diff
argument_list|,
name|GEN_INT
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|)
expr_stmt|;
name|rem
operator|=
name|expand_divmod
argument_list|(
literal|1
argument_list|,
name|TRUNC_MOD_EXPR
argument_list|,
name|index_mode
argument_list|,
name|index_val
argument_list|,
name|GEN_INT
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|byte_mode
argument_list|,
name|expand_binop
argument_list|(
name|index_mode
argument_list|,
name|add_optab
argument_list|,
name|diff
argument_list|,
name|setaddr
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract the bit we want to examine */
name|bit
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|byte_mode
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|byte_mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|rem
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|expand_binop
argument_list|(
name|byte_mode
argument_list|,
name|and_optab
argument_list|,
name|bit
argument_list|,
name|const1_rtx
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|byte_mode
condition|?
name|target
else|:
literal|0
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|target
condition|)
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Output the code to handle the out-of-range case.  */
name|emit_jump
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|WITH_CLEANUP_EXPR
case|:
if|if
condition|(
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|cleanups_this_call
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|cleanups_this_call
argument_list|)
expr_stmt|;
comment|/* That's it for this cleanup.  */
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|interim_eh_hook
call|)
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|CLEANUP_POINT_EXPR
case|:
block|{
specifier|extern
name|int
name|temp_slot_level
decl_stmt|;
name|tree
name|old_cleanups
init|=
name|cleanups_this_call
decl_stmt|;
name|int
name|old_temp_level
init|=
name|target_temp_slot_level
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|target_temp_slot_level
operator|=
name|temp_slot_level
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* If we're going to use this value, load it up now.  */
if|if
condition|(
operator|!
name|ignore
condition|)
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|expand_cleanups_to
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
name|target_temp_slot_level
operator|=
name|old_temp_level
expr_stmt|;
block|}
return|return
name|op0
return|;
case|case
name|CALL_EXPR
case|:
comment|/* Check for a built-in function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|tmode
argument_list|,
name|ignore
argument_list|)
return|;
comment|/* If this call was expanded already by preexpand_calls, 	 just return the result we got.  */
if|if
condition|(
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|REFERENCE_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|target
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|target
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
comment|/* Store data into beginning of memory target.  */
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|change_address
argument_list|(
name|target
argument_list|,
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
comment|/* Store this field into a union of the proper type.  */
name|store_field
argument_list|(
name|target
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Return the entire union.  */
return|return
name|target
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* If the signedness of the conversion differs and OP0 is 	     a promoted SUBREG, clear that indication since we now 	     have to do the proper extension.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|unsignedp
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op0
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|op0
return|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|op0
return|;
comment|/* If OP0 is a constant, just convert it into the proper mode.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
return|return
name|gen_rtx
argument_list|(
name|unsignedp
condition|?
name|ZERO_EXTEND
else|:
name|SIGN_EXTEND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
return|;
if|if
condition|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|op0
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|PLUS_EXPR
case|:
comment|/* We come here from MINUS_EXPR when the second operand is a constant. */
name|plus_expr
label|:
name|this_optab
operator|=
name|add_optab
expr_stmt|;
comment|/* If we are adding a constant, an RTL_EXPR that is sp, fp, or ap, and 	 something else, make sure we add the register to the constant and 	 then to the other thing.  This case can occur during strength 	 reduction and doing it this way will produce better code if the 	 frame pointer or argument pointer is eliminated.  	 fold-const.c will ensure that the constant is always in the inner 	 PLUS_EXPR, so the only case we need to do anything about is if 	 sp, ap, or fp is our second argument, in which case we must swap 	 the innermost first argument and our second argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RTL_EXPR
operator|&&
operator|(
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|||
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* If the result is to be ptr_mode and we are adding an integer to 	 something, we might be forming a constant.  So try to use 	 plus_constant.  If it produces a sum and we can't accept it, 	 use force_operand.  This allows P =&ARR[const] to generate 	 efficient code on machines where a SYMBOL_REF is not a valid 	 address.  	 If this is an EXPAND_SUM call, always return the sum.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|||
name|mode
operator|==
name|ptr_mode
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op1
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
name|op1
operator|=
name|force_operand
argument_list|(
name|op1
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|op1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_INT
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* Don't go to both_summands if modifier 		     says it's not right to return a PLUS.  */
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
goto|goto
name|binop2
goto|;
goto|goto
name|both_summands
goto|;
block|}
name|op0
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
block|}
comment|/* No sense saving up arithmetic to be done 	 if it's all in the wrong mode to form part of an address. 	 And force_operand won't know whether to sign-extend or 	 zero-extend.  */
if|if
condition|(
operator|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|)
operator|||
name|mode
operator|!=
name|ptr_mode
condition|)
goto|goto
name|binop
goto|;
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|both_summands
label|:
comment|/* Make sure any term that's a sum with a constant comes last.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|temp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If adding to a sum including a constant, 	 associate it to put the constant outside.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant_term
init|=
name|const0_rtx
decl_stmt|;
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|op0
operator|=
name|temp
expr_stmt|;
comment|/* Ensure that MULT comes first if there is one.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MULT
condition|)
name|op0
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* Let's also eliminate constants from op0 if possible.  */
name|op0
operator|=
name|eliminate_constant_term
argument_list|(
name|op0
argument_list|,
operator|&
name|constant_term
argument_list|)
expr_stmt|;
comment|/* CONSTANT_TERM and XEXP (op1, 1) are known to be constant, so 	     their sum should be a constant.  Form it into OP1, since the  	     result we want will then be OP0 + OP1.  */
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|constant_term
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|op1
operator|=
name|temp
expr_stmt|;
else|else
name|op1
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|constant_term
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Put a constant term last and put a multiplication first.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MULT
condition|)
name|temp
operator|=
name|op1
operator|,
name|op1
operator|=
name|op0
operator|,
name|op0
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
condition|?
name|temp
else|:
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
comment|/* For initializers, we are allowed to return a MINUS of two 	 symbolic constants.  Here we handle all cases when both operands 	 are constant.  */
comment|/* Handle difference of two symbolic constants, 	 for the sake of an initializer.  */
if|if
condition|(
operator|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|)
operator|&&
name|really_constant_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|really_constant_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
decl_stmt|;
comment|/* If the last operand is a CONST_INT, use plus_constant of 	     the negated constant.  Else make the MINUS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
comment|/* Convert A - const to A + (-const).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|negated
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Deal with the case where we can't negate the constant 	     in TYPE.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_OVERFLOW
argument_list|(
name|negated
argument_list|)
condition|)
block|{
name|tree
name|newtype
init|=
name|signed_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|newop0
init|=
name|convert
argument_list|(
name|newtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newop1
init|=
name|convert
argument_list|(
name|newtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newneg
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|newtype
argument_list|,
name|newop1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_OVERFLOW
argument_list|(
name|newneg
argument_list|)
condition|)
return|return
name|expand_expr
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|newtype
argument_list|,
name|newop0
argument_list|,
name|newneg
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
else|else
block|{
name|exp
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negated
argument_list|)
expr_stmt|;
goto|goto
name|plus_expr
goto|;
block|}
block|}
name|this_optab
operator|=
name|sub_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|MULT_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If first operand is constant, swap them. 	 Thus the following special case checks need only 	 check the second operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
specifier|register
name|tree
name|t1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|t1
expr_stmt|;
block|}
comment|/* Attempt to return something suitable for generating an 	 indexed address, for machines that support that.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|&&
name|mode
operator|==
name|ptr_mode
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
comment|/* Apply distributive law if OP0 is x+c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* Check for multiplying things that have been extended 	 from a narrower type.  If this machine supports multiplying 	 in that narrower type with a result in the desired type, 	 do it that way, and avoid the explicit type-conversion.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
comment|/* Don't use a widening multiply if a shift will do.  */
operator|&&
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|||
name|exact_log2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* If both operands are extended, they must either both 		  be zero-extended or both be sign-extended.  */
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|innermode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|this_optab
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE_WIDER_MODE
argument_list|(
name|innermode
argument_list|)
operator|&&
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|binop2
goto|;
block|}
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* Possible optimization: compute the dividend with EXPAND_SUM 	 then if the divisor is constant can optimize the case 	 where some terms of the dividend have coeffs divisible by it.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
case|case
name|RDIV_EXPR
case|:
name|this_optab
operator|=
name|flodiv_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_divmod
argument_list|(
literal|1
argument_list|,
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Not used for C.  */
case|case
name|FIX_TRUNC_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|expand_fix
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|FLOAT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* expand_float can't figure out what to do if FROM has VOIDmode. 	 So give it the correct mode.  With -O, cse will optimize this.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|expand_float
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|NEGATE_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|ABS_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle complex values specially.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
return|return
name|expand_complex_abs
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
comment|/* Unsigned abs is simply the operand.  Testing here means we don't 	 risk generating incorrect code below.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|op0
return|;
return|return
name|expand_abs
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
name|target
operator|=
name|original_target
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* First try to do it with a special MIN or MAX instruction. 	 If that does not win, use a conditional jump to select the proper 	 value.  */
name|this_optab
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
operator|(
name|code
operator|==
name|MIN_EXPR
condition|?
name|umin_optab
else|:
name|umax_optab
operator|)
else|:
operator|(
name|code
operator|==
name|MIN_EXPR
condition|?
name|smin_optab
else|:
name|smax_optab
operator|)
operator|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* At this point, a MEM target is no longer useful; we will get better 	 code without it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|op0
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* If this mode is an integer too wide to compare properly, 	 compare word by word.  Rely on cse to optimize constant cases.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|MAX_EXPR
condition|)
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|,
name|target
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|op0
argument_list|)
expr_stmt|;
else|else
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|NULL_RTX
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|MAX_EXPR
condition|)
name|temp
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|?
name|compare_from_rtx
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|GEU
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
else|:
name|compare_from_rtx
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|GE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|?
name|compare_from_rtx
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|LEU
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
else|:
name|compare_from_rtx
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|LE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|!=
name|const_true_rtx
condition|)
block|{
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|temp
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|temp
argument_list|)
index|]
call|)
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|BIT_NOT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|FFS_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|ffs_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
comment|/* ??? Can optimize bitwise operations with one arg constant. 	 Can optimize (a bitwise1 n) bitwise2 (a bitwise3 b) 	 and (a bitwise1 b) bitwise2 b (etc) 	 but that is probably not worth while.  */
comment|/* BIT_AND_EXPR is for bitwise anding.  TRUTH_AND_EXPR is for anding two 	 boolean values when we want in all cases to compute both of them.  In 	 general it is fastest to do TRUTH_AND_EXPR by computing both operands 	 as actual zero-or-1 values and then bitwise anding.  In cases where 	 there cannot be any side effects, better code would be made by 	 treating TRUTH_AND_EXPR like TRUTH_ANDIF_EXPR; but the question is 	 how to recognize those cases.  */
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
name|this_optab
operator|=
name|and_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
name|this_optab
operator|=
name|ior_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
name|this_optab
operator|=
name|xor_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
comment|/* Could determine the answer when only additive constants differ.  Also, 	 the addition of one can be handled by changing the condition.  */
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|do_store_flag
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* For foo != 0, load foo, and if it is nonzero load 1 instead. */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|original_target
operator|&&
name|GET_CODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|original_target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|original_target
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|temp
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_beq
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* If no set-flag instruction, must generate a conditional 	 store into a temporary variable.  Drop through 	 and handle this like&& and ||.  */
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
if|if
condition|(
operator|!
name|ignore
operator|&&
operator|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|)
comment|/* Make sure we don't have a hard reg (such as function's return 		 value) live across basic blocks, if not optimizing.  */
operator|||
operator|(
operator|!
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|emit_clr_insn
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|exp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|emit_0_to_1_insn
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|ignore
condition|?
name|const0_rtx
else|:
name|target
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The parser is careful to generate TRUTH_NOT_EXPR 	 only with operands that are always zero or one.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|COMPOUND_EXPR
case|:
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|ignore
condition|?
name|const0_rtx
else|:
name|target
operator|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
block|{
name|rtx
name|flag
init|=
name|NULL_RTX
decl_stmt|;
name|tree
name|left_cleanups
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|right_cleanups
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Used to save a pointer to the place to put the setting of 	   the flag that indicates if this side of the conditional was 	   taken.  We backpatch the code, if we find out later that we 	   have any conditional cleanups that need to be performed. */
name|rtx
name|dest_right_flag
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|dest_left_flag
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Note that COND_EXPRs whose type is a structure or union 	   are required to be constructed to contain assignments of 	   a temporary variable, so that we can evaluate them here 	   for side effect only.  If type is void, we must do likewise.  */
comment|/* If an arm of the branch requires a cleanup, 	   only that cleanup is performed.  */
name|tree
name|singleton
init|=
literal|0
decl_stmt|;
name|tree
name|binary_op
init|=
literal|0
decl_stmt|,
name|unary_op
init|=
literal|0
decl_stmt|;
name|tree
name|old_cleanups
init|=
name|cleanups_this_call
decl_stmt|;
comment|/* If this is (A ? 1 : 0) and A is a condition, just evaluate it and 	   convert it to our mode, if necessary.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|ignore
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* If we are not to produce a result, we have no target.  Otherwise, 	   if a target was specified use it; it will not be used as an 	   intermediate target unless it is safe.  If no target, use a  	   temporary.  */
if|if
condition|(
name|ignore
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|original_target
operator|&&
name|safe_from_p
argument_list|(
name|original_target
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|mode
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|original_target
argument_list|)
operator|)
condition|)
name|temp
operator|=
name|original_target
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|temp
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Check for X ? A + B : A.  If we have this, we can copy 	   A to the output and conditionally add B.  Similarly for unary 	   operations.  Don't do this if X has side-effects because 	   those side effects might affect A or B and the "?" operation is 	   a sequence point in ANSI.  (We test for side effects later.)  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|,
name|binary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|,
name|binary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|,
name|unary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|,
name|unary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If we had X ? A + 1 : A and we can do the test of X as a store-flag 	   operation, do this as A + (X != 0).  Similarly for other simple 	   binary operators.  */
if|if
condition|(
name|temp
operator|&&
name|singleton
operator|&&
name|binary_op
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|MINUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|)
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|rtx
name|result
decl_stmt|;
name|optab
name|boptab
init|=
operator|(
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|PLUS_EXPR
condition|?
name|add_optab
else|:
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|MINUS_EXPR
condition|?
name|sub_optab
else|:
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|?
name|ior_optab
else|:
name|xor_optab
operator|)
decl_stmt|;
comment|/* If we had X ? A : A + 1, do this as A + (X == 0).  	       We have to invert the truth value here and then put it 	       back later if do_store_flag fails.  We cannot simply copy 	       TREE_OPERAND (exp, 0) to another variable and modify that 	       because invert_truthvalue can modify the tree pointed to 	       by its argument.  */
if|if
condition|(
name|singleton
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|do_store_flag
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|singleton
argument_list|)
condition|?
name|temp
else|:
name|NULL_RTX
operator|)
argument_list|,
name|mode
argument_list|,
name|BRANCH_COST
operator|<=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|op1
operator|=
name|expand_expr
argument_list|(
name|singleton
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|boptab
argument_list|,
name|op1
argument_list|,
name|result
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|singleton
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|flag
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|singleton
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
comment|/* If the target conflicts with the other operand of the 		   binary op, we can't use it.  Also, we can't use the target 		   if it is a hard register, because evaluating the condition 		   might clobber it.  */
if|if
condition|(
operator|(
name|binary_op
operator|&&
operator|!
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|singleton
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_expr
argument_list|(
name|singleton
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_left_flag
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|singleton
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|jumpif
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
else|else
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* Allows cleanups up to here. */
name|old_cleanups
operator|=
name|cleanups_this_call
expr_stmt|;
if|if
condition|(
name|binary_op
operator|&&
name|temp
operator|==
literal|0
condition|)
comment|/* Just touch the other operand.  */
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|binary_op
condition|)
name|store_expr
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|temp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|store_expr
argument_list|(
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|unary_op
argument_list|)
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|dest_right_flag
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This is now done in jump.c and is better done there because it 	   produces shorter register lifetimes.  */
comment|/* Check for both possibilities either constants or variables 	   in registers (but not the same as the target!).  If so, can 	   save branches by assigning one, branching, and assigning the 	   other.  */
if|else if (temp&& GET_MODE (temp) != BLKmode&& (TREE_CONSTANT (TREE_OPERAND (exp, 1)) 		     || ((TREE_CODE (TREE_OPERAND (exp, 1)) == PARM_DECL 			  || TREE_CODE (TREE_OPERAND (exp, 1)) == VAR_DECL)&& DECL_RTL (TREE_OPERAND (exp, 1))&& GET_CODE (DECL_RTL (TREE_OPERAND (exp, 1))) == REG&& DECL_RTL (TREE_OPERAND (exp, 1)) != temp))&& (TREE_CONSTANT (TREE_OPERAND (exp, 2)) 		     || ((TREE_CODE (TREE_OPERAND (exp, 2)) == PARM_DECL 			  || TREE_CODE (TREE_OPERAND (exp, 2)) == VAR_DECL)&& DECL_RTL (TREE_OPERAND (exp, 2))&& GET_CODE (DECL_RTL (TREE_OPERAND (exp, 2))) == REG&& DECL_RTL (TREE_OPERAND (exp, 2)) != temp))) 	  { 	    if (GET_CODE (temp) == REG&& REGNO (temp)< FIRST_PSEUDO_REGISTER) 	      temp = gen_reg_rtx (mode); 	    store_expr (TREE_OPERAND (exp, 2), temp, 0); 	    dest_left_flag = get_last_insn (); 	    jumpifnot (TREE_OPERAND (exp, 0), op0);
comment|/* Allows cleanups up to here. */
if|old_cleanups = cleanups_this_call; 	    store_expr (TREE_OPERAND (exp, 1), temp, 0); 	    op1 = op0; 	    dest_right_flag = get_last_insn (); 	  }
endif|#
directive|endif
comment|/* Check for A op 0 ? A : FOO and A op 0 ? FOO : A where OP is any 	   comparison operator.  If we have one of these cases, set the 	   output to A, branch on A (cse will merge these two references), 	   then set the output to FOO.  */
elseif|else
if|if
condition|(
name|temp
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_left_flag
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|jumpif
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* Allows cleanups up to here. */
name|old_cleanups
operator|=
name|cleanups_this_call
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|dest_right_flag
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_left_flag
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* Allows cleanups up to here. */
name|old_cleanups
operator|=
name|cleanups_this_call
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|dest_right_flag
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* Allows cleanups up to here. */
name|old_cleanups
operator|=
name|cleanups_this_call
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_left_flag
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Handle conditional cleanups, if any. */
name|left_cleanups
operator|=
name|defer_cleanups_to
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_right_flag
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
block|}
comment|/* Handle conditional cleanups, if any. */
name|right_cleanups
operator|=
name|defer_cleanups_to
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
comment|/* Add back in, any conditional cleanups. */
if|if
condition|(
name|left_cleanups
operator|||
name|right_cleanups
condition|)
block|{
name|tree
name|new_cleanups
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|rtx
name|last
decl_stmt|;
comment|/* Now that we know that a flag is needed, go back and add in the 	       setting of the flag. */
comment|/* Do the left side flag. */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Flag left cleanups as needed. */
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
comment|/* ??? deprecated, use sequences instead.  */
name|reorder_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|dest_left_flag
argument_list|)
expr_stmt|;
comment|/* Do the right side flag. */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Flag left cleanups as needed. */
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* ??? deprecated, use sequences instead.  */
name|reorder_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|dest_right_flag
argument_list|)
expr_stmt|;
comment|/* convert flag, which is an rtx, into a tree. */
name|cond
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|cond
argument_list|)
operator|=
name|flag
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|cond
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|cond
operator|=
name|save_expr
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|left_cleanups
condition|)
name|left_cleanups
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
operator|!
name|right_cleanups
condition|)
name|right_cleanups
operator|=
name|integer_zero_node
expr_stmt|;
name|new_cleanups
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|truthvalue_conversion
argument_list|(
name|cond
argument_list|)
argument_list|,
name|left_cleanups
argument_list|,
name|right_cleanups
argument_list|)
expr_stmt|;
name|new_cleanups
operator|=
name|fold
argument_list|(
name|new_cleanups
argument_list|)
expr_stmt|;
comment|/* Now add in the conditionalized cleanups. */
name|cleanups_this_call
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|new_cleanups
argument_list|,
name|cleanups_this_call
argument_list|)
expr_stmt|;
call|(
modifier|*
name|interim_eh_hook
call|)
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
case|case
name|TARGET_EXPR
case|:
block|{
name|int
name|need_exception_region
init|=
literal|0
decl_stmt|;
comment|/* Something needs to be initialized, but we didn't know 	   where that thing was when building the tree.  For example, 	   it could be the return value of a function, or a parameter 	   to a function which lays down in the stack, or a temporary 	   variable which must be passed by reference.  	   We guarantee that the expression will either be constructed 	   or copied into our original target.  */
name|tree
name|slot
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|exp1
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|slot
argument_list|)
operator|!=
name|VAR_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ignore
condition|)
name|target
operator|=
name|original_target
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|target
operator|=
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* If we have already expanded the slot, so don't do 		   it again.  (mrs)  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|target
return|;
block|}
else|else
block|{
name|target
operator|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|target
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* All temp slots at this level must not conflict.  */
name|preserve_temp_slots
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|=
name|target
expr_stmt|;
comment|/* Since SLOT is not known to the called function 		   to belong to its stack frame, we must build an explicit 		   cleanup.  This case occurs when we must build up a reference 		   to pass the reference as an argument.  In this case, 		   it is very likely that such a reference need not be 		   built here.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
name|maybe_build_cleanup
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|cleanups_this_call
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|cleanups_this_call
argument_list|)
expr_stmt|;
name|need_exception_region
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* This case does occur, when expanding a parameter which 	       needs to be constructed on the stack.  The target 	       is the actual stack address that we want to initialize. 	       The function we call will perform the cleanup in this case.  */
comment|/* If we have already assigned it space, use that space, 	       not target that we were passed in, as our target 	       parameter is only a hint.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|target
operator|=
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* If we have already expanded the slot, so don't do                    it again.  (mrs)  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|target
return|;
block|}
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|=
name|target
expr_stmt|;
block|}
name|exp1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Mark it as expanded.  */
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp1
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_exception_region
condition|)
call|(
modifier|*
name|interim_eh_hook
call|)
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|INIT_EXPR
case|:
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|noncopied_parts
init|=
literal|0
decl_stmt|;
name|tree
name|lhs_type
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|temp
operator|=
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
operator|!
name|ignore
argument_list|,
name|original_target
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|lhs_type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|fixed_type_p
argument_list|(
name|rhs
argument_list|)
condition|)
name|noncopied_parts
operator|=
name|init_noncopied_parts
argument_list|(
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|lhs_type
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|noncopied_parts
operator|!=
literal|0
condition|)
block|{
name|expand_assignment
argument_list|(
name|TREE_VALUE
argument_list|(
name|noncopied_parts
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|noncopied_parts
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|noncopied_parts
operator|=
name|TREE_CHAIN
argument_list|(
name|noncopied_parts
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
case|case
name|MODIFY_EXPR
case|:
block|{
comment|/* If lhs is complex, expand calls in rhs before computing it. 	   That's so we don't compute a pointer and save it over a call. 	   If lhs is simple, compute it first so we can give it as a 	   target if the rhs is just a call.  This avoids an extra temp and copy 	   and that prevents a partial-subsumption which makes bad code. 	   Actually we could treat component_ref's of vars like vars.  */
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|noncopied_parts
init|=
literal|0
decl_stmt|;
name|tree
name|lhs_type
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|RESULT_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Check for |= or&= of a bitfield of size one into another bitfield 	   of size 1.  In this case, (unless we need the result of the 	   assignment) we can do this more efficiently with a 	   test followed by an assignment, if necessary.  	   ??? At this point, we can't get a BIT_FIELD_REF here.  But if 	   things change so we do, this code should be enhanced to 	   support it.  */
if|if
condition|(
name|ignore
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|lhs
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|?
name|label
else|:
literal|0
argument_list|,
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|?
name|label
else|:
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|lhs_type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|fixed_type_p
argument_list|(
name|lhs
argument_list|)
operator|&&
name|fixed_type_p
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
name|noncopied_parts
operator|=
name|save_noncopied_parts
argument_list|(
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|lhs_type
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
operator|!
name|ignore
argument_list|,
name|original_target
operator|!=
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|noncopied_parts
operator|!=
literal|0
condition|)
block|{
name|expand_assignment
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|noncopied_parts
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|noncopied_parts
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|noncopied_parts
operator|=
name|TREE_CHAIN
argument_list|(
name|noncopied_parts
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
return|return
name|expand_increment
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Faster to treat as pre-increment if result is not used.  */
return|return
name|expand_increment
argument_list|(
name|exp
argument_list|,
operator|!
name|ignore
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
comment|/* If nonzero, TEMP will be set to the address of something that might 	 be a MEM corresponding to a stack slot. */
name|temp
operator|=
literal|0
expr_stmt|;
comment|/* Are we taking the address of a nested function?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|decl_function_context
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|op0
operator|=
name|trampoline_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
comment|/* If we are taking the address of something erroneous, just 	 return a zero.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|const0_rtx
return|;
else|else
block|{
comment|/* We make sure to pass const0_rtx down if we came in with 	     ignore set, to avoid doing the cleanups twice for something.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|?
name|modifier
else|:
name|EXPAND_CONST_ADDRESS
operator|)
argument_list|)
expr_stmt|;
comment|/* If we are going to ignore the result, OP0 will have been set 	     to const0_rtx, so just return it.  Don't get confused and 	     think we are taking the address of the constant.  */
if|if
condition|(
name|ignore
condition|)
return|return
name|op0
return|;
comment|/* We would like the object in memory.  If it is a constant, 	     we can have it be statically allocated into memory.  For 	     a non-constant (REG, SUBREG or CONCAT), we need to allocate some 	     memory and store the value into it.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|force_const_mem
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|mark_temp_addr_taken
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
comment|/* If this object is in a register, it must be not 		 be BLKmode. */
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
decl_stmt|;
name|rtx
name|memloc
init|=
name|assign_stack_temp
argument_list|(
name|inner_mode
argument_list|,
name|int_size_in_bytes
argument_list|(
name|inner_type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|memloc
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|inner_type
argument_list|)
expr_stmt|;
name|mark_temp_addr_taken
argument_list|(
name|memloc
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|memloc
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memloc
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|==
name|ptr_mode
condition|)
name|temp
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|temp
return|;
block|}
name|op0
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
name|mark_reg_pointer
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* If we might have had a temp slot, add an equivalent address 	 for it.  */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|update_temp_slot_address
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|==
name|ptr_mode
condition|)
name|op0
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|op0
return|;
case|case
name|ENTRY_VALUE_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* COMPLEX type for Extended Pascal& Fortran  */
case|case
name|COMPLEX_EXPR
case|:
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
comment|/* Get the rtx code of the operands.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Move the real (op0) and imaginary (op1) parts to their location.  */
name|emit_move_insn
argument_list|(
name|gen_realpart
argument_list|(
name|mode
argument_list|,
name|target
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_imagpart
argument_list|(
name|mode
argument_list|,
name|target
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Complex construction should appear as a single unit.  */
comment|/* If TARGET is a CONCAT, we got insns like RD = RS, ID = IS, 	   each with a separate pseudo as destination. 	   It's not correct for flow to treat them as a unit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|CONCAT
condition|)
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|REALPART_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_realpart
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
case|case
name|IMAGPART_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_imagpart
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
case|case
name|CONJ_EXPR
case|:
block|{
name|enum
name|machine_mode
name|partmode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|imag_t
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Store the realpart and the negated imagpart to target.  */
name|emit_move_insn
argument_list|(
name|gen_realpart
argument_list|(
name|partmode
argument_list|,
name|target
argument_list|)
argument_list|,
name|gen_realpart
argument_list|(
name|partmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|imag_t
operator|=
name|gen_imagpart
argument_list|(
name|partmode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|partmode
argument_list|,
name|neg_optab
argument_list|,
name|gen_imagpart
argument_list|(
name|partmode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|imag_t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|imag_t
condition|)
name|emit_move_insn
argument_list|(
name|imag_t
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Conjugate should appear as a single unit  	   If TARGET is a CONCAT, we got insns like RD = RS, ID = - IS, 	   each with a separate pseudo as destination. 	   It's not correct for flow to treat them as a unit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|CONCAT
condition|)
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|ERROR_MARK
case|:
name|op0
operator|=
name|CONST0_RTX
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
literal|0
condition|)
return|return
name|op0
return|;
return|return
name|const0_rtx
return|;
default|default:
return|return
call|(
modifier|*
name|lang_expand_expr
call|)
argument_list|(
name|exp
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
comment|/* Here to do an ordinary binary operator, generating an instruction      from the optab already placed in `this_optab'.  */
name|binop
label|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binop2
label|:
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Emit bytecode to evaluate the given expression EXP to the stack. */
end_comment

begin_function
name|void
name|bc_expand_expr
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|arg0
decl_stmt|;
name|rtx
name|r
decl_stmt|;
name|struct
name|binary_operator
modifier|*
name|binoptab
decl_stmt|;
name|struct
name|unary_operator
modifier|*
name|unoptab
decl_stmt|;
name|struct
name|increment_operator
modifier|*
name|incroptab
decl_stmt|;
name|struct
name|bc_label
modifier|*
name|lab
decl_stmt|,
modifier|*
name|lab1
decl_stmt|;
name|enum
name|bytecode_opcode
name|opcode
decl_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|exp
argument_list|,
literal|"prior parameter's size depends on `%s'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bc_load_parmaddr
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|bc_load_memory
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|if (BYTECODE_LABEL (DECL_RTL (exp))) 	bc_load_externaddr (DECL_RTL (exp));       else 	bc_load_localaddr (DECL_RTL (exp));
endif|#
directive|endif
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|exp
argument_list|)
condition|)
name|bc_load_externaddr_id
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|exp
argument_list|)
argument_list|,
name|BYTECODE_BC_LABEL
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|bc_load_localaddr
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|bc_load_memory
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return;
case|case
name|INTEGER_CST
case|:
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" [%x]\n"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bc_emit_instruction
argument_list|(
name|mode_to_const_map
index|[
call|(
name|int
call|)
argument_list|(
name|DECL_BIT_FIELD
argument_list|(
name|exp
argument_list|)
condition|?
name|SImode
else|:
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
index|]
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|REAL_CST
case|:
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
block|fprintf (stderr, " [%g]\n", (double) TREE_INT_CST_LOW (exp));
endif|#
directive|endif
comment|/* FIX THIS: find a better way to pass real_cst's. -bson */
block|bc_emit_instruction (mode_to_const_map[TYPE_MODE (TREE_TYPE (exp))], 			   (double) TREE_REAL_CST (exp));
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
case|case
name|CALL_EXPR
case|:
comment|/* We build a call description vector describing the type of 	 the return value and of the arguments; this call vector, 	 together with a pointer to a location for the return value 	 and the base of the argument list, is passed to the low 	 level machine dependent call subroutine, which is responsible 	 for putting the arguments wherever real functions expect 	 them, as well as getting the return value back.  */
block|{
name|tree
name|calldesc
init|=
literal|0
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|retval
decl_stmt|;
comment|/* Push the evaluated args on the evaluation stack in reverse 	   order.  Also make an entry for each arg in the calldesc 	   vector while we're at it.  */
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
operator|++
name|nargs
expr_stmt|;
name|bc_expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|calldesc
operator|=
name|tree_cons
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
name|calldesc
operator|=
name|tree_cons
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|bc_runtime_type_code
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
block|}
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate a location for the return value and push its 	   address on the evaluation stack.  Also make an entry 	   at the front of the calldesc for the return value type. */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|bc_allocate_local
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bc_load_localaddr
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|calldesc
operator|=
name|tree_cons
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
name|calldesc
operator|=
name|tree_cons
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|bc_runtime_type_code
argument_list|(
name|type
argument_list|)
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
comment|/* Prepend the argument count.  */
name|calldesc
operator|=
name|tree_cons
argument_list|(
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|build_int_2
argument_list|(
name|nargs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
comment|/* Push the address of the call description vector on the stack.  */
name|calldesc
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
operator|(
name|tree
operator|)
literal|0
argument_list|,
name|calldesc
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|calldesc
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nargs
operator|*
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|output_constant_def
argument_list|(
name|calldesc
argument_list|)
expr_stmt|;
name|bc_load_externaddr
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Push the address of the function to be called. */
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the function, popping its address and the calldesc vector 	   address off the evaluation stack in the process.  */
name|bc_emit_instruction
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|/* Pop the arguments off the stack.  */
name|bc_adjust_stack
argument_list|(
name|nargs
argument_list|)
expr_stmt|;
comment|/* Load the return value onto the stack.  */
name|bc_load_localaddr
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|bc_load_memory
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
operator|!
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
condition|)
block|{
comment|/* First time around: copy to local variable */
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|bc_allocate_local
argument_list|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|duplicate
argument_list|)
expr_stmt|;
name|bc_load_localaddr
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|bc_store_memory
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Consecutive reference: use saved copy */
name|bc_load_localaddr
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|bc_load_memory
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
if|#
directive|if
literal|0
comment|/* FIXME: the XXXX_STMT codes have been removed in GCC2, but 	 how are they handled instead? */
block|case LET_STMT:              TREE_USED (exp) = 1;       bc_expand_expr (STMT_BODY (exp));       return;
endif|#
directive|endif
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bc_expand_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|MODIFY_EXPR
case|:
name|expand_assignment
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_EXPR
case|:
name|bc_expand_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|INDIRECT_REF
case|:
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bc_load_memory
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_REF
case|:
name|bc_expand_expr
argument_list|(
name|bc_canonicalize_array_ref
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPONENT_REF
case|:
name|bc_expand_component_address
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If we have a bitfield, generate a proper load */
name|bc_load_memory
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPOUND_EXPR
case|:
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|drop
argument_list|)
expr_stmt|;
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|COND_EXPR
case|:
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bc_expand_truth_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lab
operator|=
name|bc_get_bytecode_label
argument_list|()
expr_stmt|;
name|bc_emit_bytecode
argument_list|(
name|xjumpifnot
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|lab
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lab1
operator|=
name|bc_get_bytecode_label
argument_list|()
expr_stmt|;
name|bc_emit_bytecode
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bc_emit_bytecode_labeldef
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labeldef
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
return|return;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|opcode
operator|=
name|xjumpifnot
expr_stmt|;
goto|goto
name|andorif
goto|;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|opcode
operator|=
name|xjumpif
expr_stmt|;
goto|goto
name|andorif
goto|;
case|case
name|PLUS_EXPR
case|:
name|binoptab
operator|=
name|optab_plus_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|MINUS_EXPR
case|:
name|binoptab
operator|=
name|optab_minus_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|MULT_EXPR
case|:
name|binoptab
operator|=
name|optab_mult_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
name|binoptab
operator|=
name|optab_trunc_div_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
name|binoptab
operator|=
name|optab_trunc_mod_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Not used for C.  */
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|FFS_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
case|case
name|RDIV_EXPR
case|:
name|binoptab
operator|=
name|optab_rdiv_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|BIT_AND_EXPR
case|:
name|binoptab
operator|=
name|optab_bit_and_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|BIT_IOR_EXPR
case|:
name|binoptab
operator|=
name|optab_bit_ior_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|BIT_XOR_EXPR
case|:
name|binoptab
operator|=
name|optab_bit_xor_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|LSHIFT_EXPR
case|:
name|binoptab
operator|=
name|optab_lshift_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|RSHIFT_EXPR
case|:
name|binoptab
operator|=
name|optab_rshift_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUTH_AND_EXPR
case|:
name|binoptab
operator|=
name|optab_truth_and_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUTH_OR_EXPR
case|:
name|binoptab
operator|=
name|optab_truth_or_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|LT_EXPR
case|:
name|binoptab
operator|=
name|optab_lt_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|LE_EXPR
case|:
name|binoptab
operator|=
name|optab_le_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|GE_EXPR
case|:
name|binoptab
operator|=
name|optab_ge_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|GT_EXPR
case|:
name|binoptab
operator|=
name|optab_gt_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|EQ_EXPR
case|:
name|binoptab
operator|=
name|optab_eq_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|NE_EXPR
case|:
name|binoptab
operator|=
name|optab_ne_expr
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|NEGATE_EXPR
case|:
name|unoptab
operator|=
name|optab_negate_expr
expr_stmt|;
goto|goto
name|unop
goto|;
case|case
name|BIT_NOT_EXPR
case|:
name|unoptab
operator|=
name|optab_bit_not_expr
expr_stmt|;
goto|goto
name|unop
goto|;
case|case
name|TRUTH_NOT_EXPR
case|:
name|unoptab
operator|=
name|optab_truth_not_expr
expr_stmt|;
goto|goto
name|unop
goto|;
case|case
name|PREDECREMENT_EXPR
case|:
name|incroptab
operator|=
name|optab_predecrement_expr
expr_stmt|;
goto|goto
name|increment
goto|;
case|case
name|PREINCREMENT_EXPR
case|:
name|incroptab
operator|=
name|optab_preincrement_expr
expr_stmt|;
goto|goto
name|increment
goto|;
case|case
name|POSTDECREMENT_EXPR
case|:
name|incroptab
operator|=
name|optab_postdecrement_expr
expr_stmt|;
goto|goto
name|increment
goto|;
case|case
name|POSTINCREMENT_EXPR
case|:
name|incroptab
operator|=
name|optab_postincrement_expr
expr_stmt|;
goto|goto
name|increment
goto|;
case|case
name|CONSTRUCTOR
case|:
name|bc_expand_constructor
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return;
case|case
name|ERROR_MARK
case|:
case|case
name|RTL_EXPR
case|:
return|return;
case|case
name|BIND_EXPR
case|:
block|{
name|tree
name|vars
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|vars_need_expansion
init|=
literal|0
decl_stmt|;
comment|/* Need to open a binding contour here because 	   if there are any cleanups they most be contained here.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark the corresponding BLOCK for output.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If VARS have not yet been expanded, expand them now.  */
while|while
condition|(
name|vars
condition|)
block|{
if|if
condition|(
name|DECL_RTL
argument_list|(
name|vars
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vars_need_expansion
operator|=
literal|1
expr_stmt|;
name|expand_decl
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
name|expand_decl_init
argument_list|(
name|vars
argument_list|)
expr_stmt|;
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
name|binop
label|:
name|bc_expand_binary_operation
argument_list|(
name|binoptab
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|unop
label|:
name|bc_expand_unary_operation
argument_list|(
name|unoptab
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|andorif
label|:
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bc_expand_truth_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lab
operator|=
name|bc_get_bytecode_label
argument_list|()
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|duplicate
argument_list|)
expr_stmt|;
name|bc_emit_bytecode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labelref
argument_list|(
name|lab
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bc_emit_instruction
argument_list|(
name|drop
argument_list|)
expr_stmt|;
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bc_expand_truth_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bc_emit_bytecode_labeldef
argument_list|(
name|lab
argument_list|)
expr_stmt|;
return|return;
name|increment
label|:
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Push the quantum.  */
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert it to the lvalue's type.  */
name|bc_expand_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Push the address of the lvalue */
name|bc_expand_expr
argument_list|(
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Perform actual increment */
name|bc_expand_increment
argument_list|(
name|incroptab
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the alignment in bits of EXP, a pointer valued expression.    But don't return more than MAX_ALIGN no matter what.    The alignment returned is, by default, the alignment of the thing that    EXP points to (if it is not a POINTER_TYPE, 0 is returned).     Otherwise, look at the expression to see if we can do better, i.e., if the    expression is actually pointing at an object whose alignment is tighter.  */
end_comment

begin_function
specifier|static
name|int
name|get_pointer_alignment
parameter_list|(
name|exp
parameter_list|,
name|max_align
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|unsigned
name|max_align
decl_stmt|;
block|{
name|unsigned
name|align
decl_stmt|,
name|inner
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|max_align
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|align
return|;
name|inner
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|inner
argument_list|,
name|max_align
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
comment|/* If sum of pointer + int, restrict our maximum alignment to that 	     imposed by the integer.  If not, we can't do any better than 	     ALIGN.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|align
return|;
while|while
condition|(
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|&
operator|(
name|max_align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|max_align
operator|>>=
literal|1
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* See what we are pointing at and look at its alignment.  */
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|align
operator|=
name|FUNCTION_BOUNDARY
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|exp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'c'
condition|)
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|MIN
argument_list|(
name|align
argument_list|,
name|max_align
argument_list|)
return|;
default|default:
return|return
name|align
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the tree node and offset if a given argument corresponds to    a string constant.  */
end_comment

begin_function
specifier|static
name|tree
name|string_constant
parameter_list|(
name|arg
parameter_list|,
name|ptr_offset
parameter_list|)
name|tree
name|arg
decl_stmt|;
name|tree
modifier|*
name|ptr_offset
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
operator|*
name|ptr_offset
operator|=
name|integer_zero_node
expr_stmt|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
operator|*
name|ptr_offset
operator|=
name|arg1
expr_stmt|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
operator|*
name|ptr_offset
operator|=
name|arg0
expr_stmt|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the length of a C string.  TREE_STRING_LENGTH is not the right    way, because it could contain a zero byte in the middle.    TREE_STRING_LENGTH is the size of the character array, not the string.     Unfortunately, string_constant can't access the values of const char    arrays with initializers, so neither can we do so here.  */
end_comment

begin_function
specifier|static
name|tree
name|c_strlen
parameter_list|(
name|src
parameter_list|)
name|tree
name|src
decl_stmt|;
block|{
name|tree
name|offset_node
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|max
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|src
operator|=
name|string_constant
argument_list|(
name|src
argument_list|,
operator|&
name|offset_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|max
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_node
operator|&&
name|TREE_CODE
argument_list|(
name|offset_node
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* If the string has an internal zero byte (e.g., "foo\0bar"), we can't 	 compute the offset to the following null if we don't know where to 	 start searching for it.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We don't know the starting offset, but we do know that the string 	 has no internal zero bytes.  We can assume that the offset falls 	 within the bounds of the string; otherwise, the programmer deserves 	 what he gets.  Subtract the offset from the length of the string, 	 and return that.  */
comment|/* This would perhaps not be valid if we were dealing with named          arrays in addition to literal string constants.  */
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size_int
argument_list|(
name|max
argument_list|)
argument_list|,
name|offset_node
argument_list|)
return|;
block|}
comment|/* We have a known offset into the string.  Start searching there for      a null character.  */
if|if
condition|(
name|offset_node
operator|==
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Did we get a long long offset?  If so, punt.  */
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|offset_node
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|offset_node
argument_list|)
expr_stmt|;
block|}
comment|/* If the offset is known to be out of bounds, warn, and call strlen at      runtime.  */
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>
name|max
condition|)
block|{
name|warning
argument_list|(
literal|"offset outside bounds of constant string"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Use strlen to search for the first zero byte.  Since any strings      constructed with build_string will have nulls appended, we win even      if we get handed something like (char[4])"abcd".       Since OFFSET is our starting index into the string, no further      calculation is needed.  */
return|return
name|size_int
argument_list|(
name|strlen
argument_list|(
name|ptr
operator|+
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|expand_builtin_return_addr
parameter_list|(
name|fndecl_code
parameter_list|,
name|count
parameter_list|,
name|tem
parameter_list|)
name|enum
name|built_in_function
name|fndecl_code
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Some machines need special handling before we can access      arbitrary frames.  For example, on the sparc, we must first flush      all register windows to the stack.  */
ifdef|#
directive|ifdef
name|SETUP_FRAME_ADDRESSES
name|SETUP_FRAME_ADDRESSES
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* On the sparc, the return address is not in the frame, it is in a      register.  There is no way to access it off of the current frame      pointer, but it can be accessed off the previous frame pointer by      reading the value from the register window save area.  */
ifdef|#
directive|ifdef
name|RETURN_ADDR_IN_PREVIOUS_FRAME
if|if
condition|(
name|fndecl_code
operator|==
name|BUILT_IN_RETURN_ADDRESS
condition|)
name|count
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* Scan back COUNT frames to the specified frame.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Assume the dynamic chain pointer is in the word that the 	 frame address points to, unless otherwise specified.  */
ifdef|#
directive|ifdef
name|DYNAMIC_CHAIN_ADDRESS
name|tem
operator|=
name|DYNAMIC_CHAIN_ADDRESS
argument_list|(
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tem
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|copy_to_reg
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For __builtin_frame_address, return what we've got.  */
if|if
condition|(
name|fndecl_code
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
return|return
name|tem
return|;
comment|/* For __builtin_return_address, Get the return address from that      frame.  */
ifdef|#
directive|ifdef
name|RETURN_ADDR_RTX
name|tem
operator|=
name|RETURN_ADDR_RTX
argument_list|(
name|count
argument_list|,
name|tem
argument_list|)
expr_stmt|;
else|#
directive|else
name|tem
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|tem
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tem
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_define
define|#
directive|define
name|CALLED_AS_BUILT_IN
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), "__builtin_", 10))
end_define

begin_function
specifier|static
name|rtx
name|expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|,
name|mode
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|ignore
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|lab1
decl_stmt|,
name|insns
decl_stmt|;
name|enum
name|machine_mode
name|value_mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|optab
name|builtin_optab
decl_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_FABS
case|:
comment|/* build_function_call changes these into ABS_EXPR.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|BUILT_IN_SIN
case|:
case|case
name|BUILT_IN_COS
case|:
comment|/* Treat these like sqrt, but only if the user asks for them. */
if|if
condition|(
operator|!
name|flag_fast_math
condition|)
break|break;
case|case
name|BUILT_IN_FSQRT
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be wrong type if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
break|break;
comment|/* Stabilize and compute the argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
name|exp
operator|=
name|copy_node
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|copy_node
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|arglist
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
operator|=
name|save_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a suitable register to place result in.  */
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_SIN
case|:
name|builtin_optab
operator|=
name|sin_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_COS
case|:
name|builtin_optab
operator|=
name|cos_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_FSQRT
case|:
name|builtin_optab
operator|=
name|sqrt_optab
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Compute into TARGET. 	 Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builtin_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we were unable to expand via the builtin, stop the 	 sequence (without outputting the insns) and break, causing 	 a call the the library function.  */
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Check the results by default.  But if flag_fast_math is turned on, 	 then assume sqrt will always be called with valid arguments.  */
if|if
condition|(
operator|!
name|flag_fast_math
condition|)
block|{
comment|/* Don't define the builtin FP instructions 	     if your machine is not IEEE.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|lab1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Test the result; if it is NaN, set errno=EDOM because 	     the argument was not in the domain.  */
name|emit_cmp_insn
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_beq
argument_list|(
name|lab1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_EDOM
block|{
ifdef|#
directive|ifdef
name|GEN_ERRNO_RTX
name|rtx
name|errno_rtx
init|=
name|GEN_ERRNO_RTX
decl_stmt|;
else|#
directive|else
name|rtx
name|errno_rtx
init|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|word_mode
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"errno"
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|errno_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_EDOM
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* We can't set errno=EDOM directly; let the library call do it. 	     Pop the arguments right away in case the call gets deleted. */
name|NO_DEFER_POP
expr_stmt|;
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
endif|#
directive|endif
name|emit_label
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
block|}
comment|/* Output the entire sequence. */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
comment|/* __builtin_apply_args returns block of memory allocated on 	 the stack into which is stored the arg pointer, structure 	 value address, static chain, and all the registers that might 	 possibly be used in performing a function call.  The code is 	 moved to the start of the function so the incoming values are 	 saved.  */
case|case
name|BUILT_IN_APPLY_ARGS
case|:
comment|/* Don't do __builtin_apply_args more than once in a function. 	 Save the result of the first call and reuse it.  */
if|if
condition|(
name|apply_args_value
operator|!=
literal|0
condition|)
return|return
name|apply_args_value
return|;
block|{
comment|/* When this function is called, it means that registers must be 	   saved on entry to this function.  So we migrate the 	   call to the first insn of this function.  */
name|rtx
name|temp
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|expand_builtin_apply_args
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|apply_args_value
operator|=
name|temp
expr_stmt|;
comment|/* Put the sequence after the NOTE that starts the function. 	   If this is inside a SEQUENCE, make the outer-level insn 	   chain current, so the code is placed at the start of the 	   function.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|NEXT_INSN
argument_list|(
name|get_insns
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* __builtin_apply (FUNCTION, ARGUMENTS, ARGSIZE) invokes 	 FUNCTION with a copy of the parameters described by 	 ARGUMENTS, and ARGSIZE.  It returns a block of memory 	 allocated on the stack into which is stored all the registers 	 that might possibly be used for returning the result of a 	 function.  ARGUMENTS is the value returned by 	 __builtin_apply_args.  ARGSIZE is the number of bytes of 	 arguments that must be copied.  ??? How should this value be 	 computed?  We'll also need a safe worst case value for varargs 	 functions.  */
case|case
name|BUILT_IN_APPLY
case|:
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
name|const0_rtx
return|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|t
operator|=
name|arglist
operator|,
name|i
operator|=
literal|0
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|i
operator|++
control|)
name|ops
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_builtin_apply
argument_list|(
name|ops
index|[
literal|0
index|]
argument_list|,
name|ops
index|[
literal|1
index|]
argument_list|,
name|ops
index|[
literal|2
index|]
argument_list|)
return|;
block|}
comment|/* __builtin_return (RESULT) causes the function to return the 	 value described by RESULT.  RESULT is address of the block of 	 memory returned by __builtin_apply.  */
case|case
name|BUILT_IN_RETURN
case|:
if|if
condition|(
name|arglist
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|expand_builtin_return
argument_list|(
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_SAVEREGS
case|:
comment|/* Don't do __builtin_saveregs more than once in a function. 	 Save the result of the first call and reuse it.  */
if|if
condition|(
name|saveregs_value
operator|!=
literal|0
condition|)
return|return
name|saveregs_value
return|;
block|{
comment|/* When this function is called, it means that registers must be 	   saved on entry to this function.  So we migrate the 	   call to the first insn of this function.  */
name|rtx
name|temp
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* Now really call the function.  `expand_call' does not call 	   expand_builtin, so there is no danger of infinite recursion here.  */
name|start_sequence
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPAND_BUILTIN_SAVEREGS
comment|/* Do whatever the machine needs done in this case.  */
name|temp
operator|=
name|EXPAND_BUILTIN_SAVEREGS
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* The register where the function returns its value 	   is likely to have something else in it, such as an argument. 	   So preserve that register around the call.  */
if|if
condition|(
name|value_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|rtx
name|valreg
init|=
name|hard_libcall_value
argument_list|(
name|value_mode
argument_list|)
decl_stmt|;
name|rtx
name|saved_valreg
init|=
name|gen_reg_rtx
argument_list|(
name|value_mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|saved_valreg
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|valreg
argument_list|,
name|saved_valreg
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Generate the call, putting the value in a pseudo.  */
name|temp
operator|=
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|saveregs_value
operator|=
name|temp
expr_stmt|;
comment|/* Put the sequence after the NOTE that starts the function. 	   If this is inside a SEQUENCE, make the outer-level insn 	   chain current, so the code is placed at the start of the 	   function.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|NEXT_INSN
argument_list|(
name|get_insns
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* __builtin_args_info (N) returns word N of the arg space info 	 for the current function.  The number and meanings of words 	 is controlled by the definition of CUMULATIVE_ARGS.  */
case|case
name|BUILT_IN_ARGS_INFO
case|:
block|{
name|int
name|nwords
init|=
sizeof|sizeof
argument_list|(
name|CUMULATIVE_ARGS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|word_ptr
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|current_function_args_info
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|elts
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|CUMULATIVE_ARGS
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"CUMULATIVE_ARGS type defined badly; see %s, line %d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|!=
literal|0
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"argument of `__builtin_args_info' must be constant"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|wordnum
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|wordnum
operator|<
literal|0
operator|||
name|wordnum
operator|>=
name|nwords
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"argument of `__builtin_args_info' out of range"
argument_list|)
expr_stmt|;
else|else
return|return
name|GEN_INT
argument_list|(
name|word_ptr
index|[
name|wordnum
index|]
argument_list|)
return|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"missing argument in `__builtin_args_info'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
if|#
directive|if
literal|0
block|for (i = 0; i< nwords; i++) 	  elts = tree_cons (NULL_TREE, build_int_2 (word_ptr[i], 0));  	type = build_array_type (integer_type_node, 				 build_index_type (build_int_2 (nwords, 0))); 	result = build (CONSTRUCTOR, type, NULL_TREE, nreverse (elts)); 	TREE_CONSTANT (result) = 1; 	TREE_STATIC (result) = 1; 	result = build (INDIRECT_REF, build_pointer_type (type), result); 	TREE_CONSTANT (result) = 1; 	return expand_expr (result, NULL_RTX, VOIDmode, 0);
endif|#
directive|endif
block|}
comment|/* Return the address of the first anonymous stack arg.  */
case|case
name|BUILT_IN_NEXT_ARG
case|:
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
operator|)
operator|&&
operator|!
name|current_function_varargs
condition|)
block|{
name|error
argument_list|(
literal|"`va_start' used in function with fixed args"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|arglist
condition|)
block|{
name|tree
name|last_parm
init|=
name|tree_last
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Strip off all nops for the sake of the comparison.  This 	       is not quite the same as STRIP_NOPS.  It does more.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|last_parm
condition|)
name|warning
argument_list|(
literal|"second parameter of `va_start' not last named argument"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|current_function_varargs
condition|)
comment|/* Evidently an out of date version of<stdarg.h>; can't validate 	     va_start's second argument, but can still work as intended.  */
name|warning
argument_list|(
literal|"`__builtin_next_arg' called without an argument"
argument_list|)
expr_stmt|;
block|}
return|return
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|current_function_internal_arg_pointer
argument_list|,
name|current_function_arg_offset_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
case|case
name|BUILT_IN_CLASSIFY_TYPE
case|:
if|if
condition|(
name|arglist
operator|!=
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|void_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|integer_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|CHAR_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|char_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|enumeral_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|boolean_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|pointer_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|reference_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|OFFSET_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|offset_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|real_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|complex_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|function_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|METHOD_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|method_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|record_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|QUAL_UNION_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|union_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|GEN_INT
argument_list|(
name|string_type_class
argument_list|)
return|;
else|else
return|return
name|GEN_INT
argument_list|(
name|array_type_class
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|SET_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|set_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|FILE_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|file_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|LANG_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|lang_type_class
argument_list|)
return|;
block|}
return|return
name|GEN_INT
argument_list|(
name|no_type_class
argument_list|)
return|;
case|case
name|BUILT_IN_CONSTANT_P
case|:
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
return|return
name|const0_rtx
return|;
else|else
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
operator|)
condition|?
name|const1_rtx
else|:
name|const0_rtx
operator|)
return|;
block|}
case|case
name|BUILT_IN_FRAME_ADDRESS
case|:
comment|/* The argument must be a nonnegative integer constant. 	 It counts the number of frames to scan up the stack. 	 The value is the address of that frame.  */
case|case
name|BUILT_IN_RETURN_ADDRESS
case|:
comment|/* The argument must be a nonnegative integer constant. 	 It counts the number of frames to scan up the stack. 	 The value is the return address saved in that frame.  */
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
comment|/* Warning about missing arg was already issued.  */
return|return
name|const0_rtx
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid arg to `__builtin_return_address'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid arg to `__builtin_return_address'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
else|else
block|{
name|rtx
name|tem
init|=
name|expand_builtin_return_addr
argument_list|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
decl_stmt|;
comment|/* For __builtin_frame_address, return what we've got.  */
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
return|return
name|tem
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|REG
condition|)
name|tem
operator|=
name|copy_to_reg
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
case|case
name|BUILT_IN_ALLOCA
case|:
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-integer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
break|break;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate the desired space.  */
return|return
name|allocate_dynamic_stack_space
argument_list|(
name|op0
argument_list|,
name|target
argument_list|,
name|BITS_PER_UNIT
argument_list|)
return|;
case|case
name|BUILT_IN_FFS
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-integer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
break|break;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute ffs, into TARGET if possible. 	 Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ffs_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|target
return|;
case|case
name|BUILT_IN_STRLEN
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
break|break;
else|else
block|{
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|c_strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|src_rtx
decl_stmt|,
name|char_rtx
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|value_mode
decl_stmt|,
name|char_mode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
comment|/* If the length is known, just return it. */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
return|return
name|expand_expr
argument_list|(
name|len
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
return|;
comment|/* If SRC is not a pointer type, don't do this operation inline. */
if|if
condition|(
name|align
operator|==
literal|0
condition|)
break|break;
comment|/* Call a function if we can't compute strlen in the right mode. */
while|while
condition|(
name|insn_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|icode
operator|=
name|strlen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|insn_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
break|break;
name|insn_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn_mode
operator|==
name|VOIDmode
condition|)
break|break;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
comment|/* Make sure the operands are acceptable to the predicates.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|result
argument_list|,
name|insn_mode
argument_list|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
name|src_rtx
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|expand_expr
argument_list|(
name|src
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|src_rtx
argument_list|,
name|Pmode
argument_list|)
condition|)
name|src_rtx
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|src_rtx
argument_list|)
expr_stmt|;
name|char_rtx
operator|=
name|const0_rtx
expr_stmt|;
name|char_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|char_rtx
argument_list|,
name|char_mode
argument_list|)
condition|)
name|char_rtx
operator|=
name|copy_to_mode_reg
argument_list|(
name|char_mode
argument_list|,
name|char_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|result
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|src_rtx
argument_list|)
argument_list|,
name|char_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|value_mode
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|convert_to_mode
argument_list|(
name|value_mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
return|;
block|}
case|case
name|BUILT_IN_STRCPY
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
break|break;
else|else
block|{
name|tree
name|len
init|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|len
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Drops in.  */
case|case
name|BUILT_IN_MEMCPY
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
break|break;
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|src_align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|dest_rtx
decl_stmt|,
name|dest_mem
decl_stmt|,
name|src_mem
decl_stmt|;
comment|/* If either SRC or DEST is not a pointer type, don't do 	     this operation in-line.  */
if|if
condition|(
name|src_align
operator|==
literal|0
operator|||
name|dest_align
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_STRCPY
condition|)
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|dest_rtx
operator|=
name|expand_expr
argument_list|(
name|dest
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|dest_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There could be a void* cast on top of the object.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|dest
operator|=
name|TREE_OPERAND
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|dest_mem
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|src_mem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|expand_expr
argument_list|(
name|src
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_SUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There could be a void* cast on top of the object.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|src
operator|=
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|src_mem
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Copy word part most expediently.  */
name|emit_block_move
argument_list|(
name|dest_mem
argument_list|,
name|src_mem
argument_list|,
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|src_align
argument_list|,
name|dest_align
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|force_operand
argument_list|(
name|dest_rtx
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
comment|/* These comparison functions need an instruction that returns an actual    index.  An ordinary compare that just sets the condition codes    is not enough.  */
ifdef|#
directive|ifdef
name|HAVE_cmpstrsi
case|case
name|BUILT_IN_STRCMP
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|HAVE_cmpstrsi
condition|)
break|break;
block|{
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|len
decl_stmt|,
name|len2
decl_stmt|;
name|len
operator|=
name|c_strlen
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|len
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_one_node
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len2
operator|=
name|c_strlen
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
condition|)
name|len2
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_one_node
argument_list|,
name|len2
argument_list|)
expr_stmt|;
comment|/* If we don't have a constant length for the first, use the length 	   of the second, if we know it.  We don't require a constant for 	   this case; some cost analysis could be done if both are available 	   but neither is constant.  For now, assume they're equally cheap.  	   If both strings have constant lengths, use the smaller.  This 	   could arise if optimization results in strcpy being called with 	   two fixed strings, or if the code was machine-generated.  We should 	   add some code to the `memcmp' handler below to deal with such 	   situations, someday.  */
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|len2
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|len2
operator|&&
name|TREE_CODE
argument_list|(
name|len2
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|len2
argument_list|,
name|len
argument_list|)
condition|)
name|len
operator|=
name|len2
expr_stmt|;
block|}
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Drops in.  */
case|case
name|BUILT_IN_MEMCMP
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|HAVE_cmpstrsi
condition|)
break|break;
block|{
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|int
name|arg1_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg1
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|arg2_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg2
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrsi
index|]
index|[
literal|0
index|]
decl_stmt|;
comment|/* If we don't have POINTER_TYPE, call the function.  */
if|if
condition|(
name|arg1_align
operator|==
literal|0
operator|||
name|arg2_align
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_STRCMP
condition|)
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpstrsi
argument_list|(
name|result
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|mode
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|#
directive|else
case|case
name|BUILT_IN_STRCMP
case|:
case|case
name|BUILT_IN_MEMCMP
case|:
break|break;
endif|#
directive|endif
default|default:
comment|/* just do library call, if unknown builtin */
name|error
argument_list|(
literal|"built-in function `%s' not currently supported"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The switch statement above can drop through to cause the function      to be called normally.  */
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Built-in functions to perform an untyped call and return.  */
end_comment

begin_comment
comment|/* For each register that may be used for calling a function, this    gives a mode used to copy the register's value.  VOIDmode indicates    the register is not used for calling a function.  If the machine    has register windows, this gives only the outbound registers.    INCOMING_REGNO gives the corresponding inbound register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|apply_args_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register that may be used for returning values, this gives    a mode used to copy the register's value.  VOIDmode indicates the    register is not used for returning values.  If the machine has    register windows, this gives only the outbound registers.    INCOMING_REGNO gives the corresponding inbound register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|apply_result_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register that may be used for calling a function, this    gives the offset of that register into the block returned by    __builtin_apply_args.  0 indicates that the register is not    used for calling a function. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apply_args_reg_offset
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the offset of register REGNO into the block returned by     __builtin_apply_args.  This is not declared static, since it is    needed in objc-act.c. */
end_comment

begin_function
name|int
name|apply_args_register_offset
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|apply_args_size
argument_list|()
expr_stmt|;
comment|/* Arguments are always put in outgoing registers (in the argument      block) if such make sense. */
ifdef|#
directive|ifdef
name|OUTGOING_REGNO
name|regno
operator|=
name|OUTGOING_REGNO
argument_list|(
name|regno
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|apply_args_reg_offset
index|[
name|regno
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the size required for the block returned by __builtin_apply_args,    and initialize apply_args_mode.  */
end_comment

begin_function
specifier|static
name|int
name|apply_args_size
parameter_list|()
block|{
specifier|static
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The values computed by this function never change.  */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
comment|/* The first value is the incoming arg-pointer.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* The second value is the structure value address unless this is 	 passed as an "invisible" first argument.  */
if|if
condition|(
name|struct_value_rtx
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* Search for the proper mode for copying this register's 	       value.  I'm not sure this is right, but it works so far.  */
name|enum
name|machine_mode
name|best_mode
init|=
name|VOIDmode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
name|mode
operator|=
name|best_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|apply_args_reg_offset
index|[
name|regno
index|]
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|apply_args_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
name|apply_args_mode
index|[
name|regno
index|]
operator|=
name|VOIDmode
expr_stmt|;
name|apply_args_reg_offset
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size required for the block returned by __builtin_apply,    and initialize apply_result_mode.  */
end_comment

begin_function
specifier|static
name|int
name|apply_result_size
parameter_list|()
block|{
specifier|static
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The values computed by this function never change.  */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* Search for the proper mode for copying this register's 	       value.  I'm not sure this is right, but it works so far.  */
name|enum
name|machine_mode
name|best_mode
init|=
name|VOIDmode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|TImode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
name|mode
operator|=
name|best_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|apply_result_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
name|apply_result_mode
index|[
name|regno
index|]
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Allow targets that use untyped_call and untyped_return to override 	 the size so that machine-specific information can be stored here.  */
ifdef|#
directive|ifdef
name|APPLY_RESULT_SIZE
name|size
operator|=
name|APPLY_RESULT_SIZE
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|size
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_untyped_call
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_untyped_return
argument_list|)
end_if

begin_comment
comment|/* Create a vector describing the result block RESULT.  If SAVEP is true,    the result block is used to save the values; otherwise it is used to    restore the values.  */
end_comment

begin_function
specifier|static
name|rtx
name|result_vector
parameter_list|(
name|savep
parameter_list|,
name|result
parameter_list|)
name|int
name|savep
decl_stmt|;
name|rtx
name|result
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|size
decl_stmt|,
name|align
decl_stmt|,
name|nelts
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
modifier|*
name|savevec
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|size
operator|=
name|nelts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|savep
condition|?
name|regno
else|:
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|change_address
argument_list|(
name|result
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|savevec
index|[
name|nelts
operator|++
index|]
operator|=
operator|(
name|savep
condition|?
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
else|:
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
operator|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|nelts
argument_list|,
name|savevec
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_untyped_call or HAVE_untyped_return */
end_comment

begin_comment
comment|/* Save the state required to perform an untyped call with the same    arguments as were passed to the current function.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply_args
parameter_list|()
block|{
name|rtx
name|registers
decl_stmt|;
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Create a block where the arg-pointer, structure value address,      and argument registers can be saved.  */
name|registers
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|apply_args_size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Walk past the arg-pointer and structure value address.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value_rtx
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save each register used in calling a function to the block.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_args_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|tem
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* For reg-stack.c's stack register household. 	   Compare with a similar piece of code in function.c.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|registers
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|registers
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Save the arg pointer to the block.  */
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|registers
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|registers
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save the structure value address unless this is passed as an      "invisible" first argument.  */
if|if
condition|(
name|struct_value_incoming_rtx
condition|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|registers
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|registers
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|struct_value_incoming_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* Return the address of the block.  */
return|return
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|registers
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform an untyped call and save the state required to perform an    untyped return of whatever value was returned by the given function.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply
parameter_list|(
name|function
parameter_list|,
name|arguments
parameter_list|,
name|argsize
parameter_list|)
name|rtx
name|function
decl_stmt|,
name|arguments
decl_stmt|,
name|argsize
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|incoming_args
decl_stmt|,
name|result
decl_stmt|,
name|reg
decl_stmt|,
name|dest
decl_stmt|,
name|call_insn
decl_stmt|;
name|rtx
name|old_stack_level
init|=
literal|0
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
comment|/* Create a block where the return registers can be saved.  */
name|result
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|apply_result_size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* ??? The argsize value should be adjusted here.  */
comment|/* Fetch the arg pointer from the ARGUMENTS block.  */
name|incoming_args
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|incoming_args
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|incoming_args
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|sub_optab
argument_list|,
name|incoming_args
argument_list|,
name|argsize
argument_list|,
name|incoming_args
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Perform postincrements before actually calling the function.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Push a new argument block and copy the arguments.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Push a block of memory onto the stack to store the memory arguments.      Save the address in a register, and copy the memory arguments.  ??? I      haven't figured out how the calling convention macros effect this,      but it's likely that the source and/or destination addresses in      the block copy will need updating in machine specific ways.  */
name|dest
operator|=
name|copy_addr_to_reg
argument_list|(
name|push_block
argument_list|(
name|argsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|dest
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|incoming_args
argument_list|)
argument_list|,
name|argsize
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Refer to the argument block.  */
name|apply_args_size
argument_list|()
expr_stmt|;
name|arguments
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
comment|/* Walk past the arg-pointer and structure value address.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value_rtx
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Restore each of the registers previously saved.  Make USE insns      for each of these registers for use in making the call.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_args_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|change_address
argument_list|(
name|arguments
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|arguments
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the structure value address unless this is passed as an      "invisible" first argument.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value_rtx
condition|)
block|{
name|rtx
name|value
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|value
argument_list|,
name|change_address
argument_list|(
name|arguments
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|arguments
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|struct_value_rtx
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|struct_value_rtx
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|struct_value_rtx
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* All arguments and registers used for the call are set up by now!  */
name|function
operator|=
name|prepare_call_address
argument_list|(
name|function
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|call_fusage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ensure address is valid.  SYMBOL_REF is already valid, so no need,      and we don't want to load it into a register as an optimization,      because prepare_call_address already did it if it should be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|function
operator|=
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* Generate the actual call instruction and save the return value.  */
ifdef|#
directive|ifdef
name|HAVE_untyped_call
if|if
condition|(
name|HAVE_untyped_call
condition|)
name|emit_call_insn
argument_list|(
name|gen_untyped_call
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
argument_list|,
name|result
argument_list|,
name|result_vector
argument_list|(
literal|1
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_call_value
if|if
condition|(
name|HAVE_call_value
condition|)
block|{
name|rtx
name|valreg
init|=
literal|0
decl_stmt|;
comment|/* Locate the unique return register.  It is not possible to 	 express a call that sets more than one return register using 	 call_value; use untyped_call for that.  In fact, untyped_call 	 only needs to save the return registers in the given block.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|valreg
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* HAVE_untyped_call required.  */
name|valreg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|emit_call_insn
argument_list|(
name|gen_call_value
argument_list|(
name|valreg
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|result
argument_list|,
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the CALL insn we just emitted.  */
for|for
control|(
name|call_insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|call_insn
operator|&&
name|GET_CODE
argument_list|(
name|call_insn
argument_list|)
operator|!=
name|CALL_INSN
condition|;
name|call_insn
operator|=
name|PREV_INSN
argument_list|(
name|call_insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|call_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Put the register usage information on the CALL.  If there is already      some usage information, put ours at the end.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
init|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
empty_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
block|}
else|else
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
comment|/* Restore the stack.  */
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Return the address of the result block.  */
return|return
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform an untyped return.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_return
parameter_list|(
name|result
parameter_list|)
name|rtx
name|result
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
name|apply_result_size
argument_list|()
expr_stmt|;
name|result
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|result
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_untyped_return
if|if
condition|(
name|HAVE_untyped_return
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_untyped_return
argument_list|(
name|result
argument_list|,
name|result_vector
argument_list|(
literal|0
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Restore the return value and note that each value is used.  */
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|change_address
argument_list|(
name|result
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|call_fusage
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|call_fusage
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Put the USE insns before the return.  */
name|emit_insns
argument_list|(
name|call_fusage
argument_list|)
expr_stmt|;
comment|/* Return whatever values was restored by jumping directly to the end      of the function.  */
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand code for a post- or pre- increment or decrement    and return the RTX for the result.    POST is 1 for postinc/decrements and 0 for preinc/decrements.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_increment
parameter_list|(
name|exp
parameter_list|,
name|post
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
name|int
name|post
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
specifier|register
name|rtx
name|temp
decl_stmt|,
name|value
decl_stmt|;
specifier|register
name|tree
name|incremented
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|optab
name|this_optab
init|=
name|add_optab
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|op0_is_copy
init|=
literal|0
decl_stmt|;
name|int
name|single_insn
init|=
literal|0
decl_stmt|;
comment|/* 1 means we can't store into OP0 directly,      because it is a subreg narrower than a word,      and we don't dare clobber the rest of the word.  */
name|int
name|bad_subreg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_expand_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
comment|/* Stabilize any component ref that might need to be      evaluated more than once below.  */
if|if
condition|(
operator|!
name|post
operator|||
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incremented
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|INDIRECT_REF
operator|||
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incremented
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|incremented
operator|=
name|stabilize_reference
argument_list|(
name|incremented
argument_list|)
expr_stmt|;
comment|/* Nested *INCREMENT_EXPRs can happen in C++.  We must force innermost      ones into save exprs so that they don't accidentally get evaluated      more than once by the code below.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|PREINCREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|PREDECREMENT_EXPR
condition|)
name|incremented
operator|=
name|save_expr
argument_list|(
name|incremented
argument_list|)
expr_stmt|;
comment|/* Compute the operands as RTX.      Note whether OP0 is the actual lvalue or a copy of it:      I believe it is a copy iff it is a register or subreg      and insns were generated in computing it.   */
name|temp
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|incremented
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If OP0 is a SUBREG made for a promoted variable, we cannot increment      in place but instead must do sign- or zero-extension during assignment,      so we copy it into a new register and let the code below use it as      a copy.       Note that we can safely modify this SUBREG since it is know not to be      shared (it was made by the expand_expr call above).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
if|if
condition|(
name|post
condition|)
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
operator|=
name|copy_to_reg
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bad_subreg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
block|{
comment|/* We cannot increment this SUBREG in place.  If we are 	 post-incrementing, get a copy of the old value.  Otherwise, 	 just mark that we cannot increment in place.  */
if|if
condition|(
name|post
condition|)
name|op0
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
else|else
name|bad_subreg
operator|=
literal|1
expr_stmt|;
block|}
name|op0_is_copy
operator|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|temp
operator|!=
name|get_last_insn
argument_list|()
operator|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Decide whether incrementing or decrementing.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PREDECREMENT_EXPR
condition|)
name|this_optab
operator|=
name|sub_optab
expr_stmt|;
comment|/* Convert decrement by a constant into a negative increment.  */
if|if
condition|(
name|this_optab
operator|==
name|sub_optab
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op1
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|this_optab
operator|=
name|add_optab
expr_stmt|;
block|}
comment|/* For a preincrement, see if we can do this with a single instruction.  */
if|if
condition|(
operator|!
name|post
condition|)
block|{
name|icode
operator|=
operator|(
name|int
operator|)
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
operator|(
name|int
operator|)
name|CODE_FOR_nothing
comment|/* Make sure that OP0 is valid for operands 0 and 1 	     of the insn we want to queue.  */
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|single_insn
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If OP0 is not the actual lvalue, but rather a copy in a register,      then we cannot just increment OP0.  We must therefore contrive to      increment the original value.  Then, for postincrement, we can return      OP0 since it is a copy of the old value.  For preincrement, expand here      unless we can do it with a single insn.       Likewise if storing directly into OP0 would clobber high bits      we need to preserve (bad_subreg).  */
if|if
condition|(
name|op0_is_copy
operator|||
operator|(
operator|!
name|post
operator|&&
operator|!
name|single_insn
operator|)
operator|||
name|bad_subreg
condition|)
block|{
comment|/* This is the easiest way to increment the value wherever it is. 	 Problems with multiple evaluation of INCREMENTED are prevented 	 because either (1) it is a component_ref or preincrement, 	 in which case it was stabilized above, or (2) it is an array_ref 	 with constant index in an array in a register, which is 	 safe to reevaluate.  */
name|tree
name|newexp
init|=
name|build
argument_list|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PREDECREMENT_EXPR
operator|)
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|incremented
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|newexp
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|incremented
argument_list|)
argument_list|,
name|newexp
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|TREE_OPERAND
argument_list|(
name|incremented
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|expand_assignment
argument_list|(
name|incremented
argument_list|,
name|newexp
argument_list|,
operator|!
name|post
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|post
condition|?
name|op0
else|:
name|temp
return|;
block|}
if|if
condition|(
name|post
condition|)
block|{
comment|/* We have a true reference to the value in OP0. 	 If there is an insn to add or subtract in this mode, queue it. 	 Queueing the increment insn avoids the register shuffling 	 that often results if we must increment now and first save 	 the old value for subsequent use.  */
if|#
directive|if
literal|0
comment|/* Turned off to avoid making extra insn for indexed memref.  */
block|op0 = stabilize (op0);
endif|#
directive|endif
name|icode
operator|=
operator|(
name|int
operator|)
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
operator|(
name|int
operator|)
name|CODE_FOR_nothing
comment|/* Make sure that OP0 is valid for operands 0 and 1 	     of the insn we want to queue.  */
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|enqueue_insn
argument_list|(
name|op0
argument_list|,
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Preincrement, or we can't increment with one simple insn.  */
if|if
condition|(
name|post
condition|)
comment|/* Save a copy of the value before inc or dec, to return it later.  */
name|temp
operator|=
name|value
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
else|else
comment|/* Arrange to return the incremented value.  */
comment|/* Copy the rtx because expand_binop will protect from the queue,        and the results of that would be invalid for us to return        if our caller does emit_queue before using our result.  */
name|temp
operator|=
name|copy_rtx
argument_list|(
name|value
operator|=
name|op0
argument_list|)
expr_stmt|;
comment|/* Increment however we can.  */
name|op1
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|value
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Make sure the value is stored into OP0.  */
if|if
condition|(
name|op1
operator|!=
name|op0
condition|)
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand all function calls contained within EXP, innermost ones first.    But don't look within expressions that have sequence points.    For each CALL_EXPR, record the rtx for its value    in the CALL_EXPR_RTL field.  */
end_comment

begin_function
specifier|static
name|void
name|preexpand_calls
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|int
name|nops
decl_stmt|,
name|i
decl_stmt|;
name|int
name|type
init|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|do_preexpand_calls
condition|)
return|return;
comment|/* Only expressions and references can contain calls.  */
if|if
condition|(
name|type
operator|!=
literal|'e'
operator|&&
name|type
operator|!=
literal|'<'
operator|&&
name|type
operator|!=
literal|'1'
operator|&&
name|type
operator|!=
literal|'2'
operator|&&
name|type
operator|!=
literal|'r'
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
comment|/* Do nothing if already expanded.  */
if|if
condition|(
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Do nothing to built-in functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ADDR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* Do nothing if the call returns a variable-sized object.  */
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|expand_call
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|COND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
comment|/* If we find one of these, then we can be sure 	 the adjust will be done for it (since it makes jumps). 	 Do it now, so that if this is inside an argument 	 of a function, we don't get the stack adjustment 	 after some other args have already been pushed.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
return|return;
case|case
name|BLOCK
case|:
case|case
name|RTL_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
return|return;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
name|nops
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|type
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|'e'
operator|||
name|type
operator|==
literal|'<'
operator|||
name|type
operator|==
literal|'1'
operator|||
name|type
operator|==
literal|'2'
operator|||
name|type
operator|==
literal|'r'
condition|)
name|preexpand_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* At the start of a function, record that we have no previously-pushed    arguments waiting to be popped.  */
end_comment

begin_function
name|void
name|init_pending_stack_adjust
parameter_list|()
block|{
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When exiting from function, if safe, clear out any pending stack adjust    so the adjustment won't get done.  */
end_comment

begin_function
name|void
name|clear_pending_stack_adjust
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|flag_omit_frame_pointer
operator|&&
name|EXIT_IGNORE_STACK
operator|&&
operator|!
operator|(
name|DECL_INLINE
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
name|flag_no_inline
operator|)
operator|&&
operator|!
name|flag_inline_functions
condition|)
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Pop any previously-pushed arguments that have not been popped yet.  */
end_comment

begin_function
name|void
name|do_pending_stack_adjust
parameter_list|()
block|{
if|if
condition|(
name|inhibit_defer_pop
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pending_stack_adjust
operator|!=
literal|0
condition|)
name|adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|pending_stack_adjust
argument_list|)
argument_list|)
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Defer the expansion all cleanups up to OLD_CLEANUPS.    Returns the cleanups to be performed.  */
end_comment

begin_function
specifier|static
name|tree
name|defer_cleanups_to
parameter_list|(
name|old_cleanups
parameter_list|)
name|tree
name|old_cleanups
decl_stmt|;
block|{
name|tree
name|new_cleanups
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|cleanups
init|=
name|cleanups_this_call
decl_stmt|;
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|cleanups_this_call
operator|!=
name|old_cleanups
condition|)
block|{
call|(
modifier|*
name|interim_eh_hook
call|)
argument_list|(
name|TREE_VALUE
argument_list|(
name|cleanups_this_call
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|cleanups_this_call
expr_stmt|;
name|cleanups_this_call
operator|=
name|TREE_CHAIN
argument_list|(
name|cleanups_this_call
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
comment|/* Remove the list from the chain of cleanups.  */
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* reverse them so that we can build them in the right order.  */
name|cleanups
operator|=
name|nreverse
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
while|while
condition|(
name|cleanups
condition|)
block|{
if|if
condition|(
name|new_cleanups
condition|)
name|new_cleanups
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|new_cleanups
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|cleanups
argument_list|)
argument_list|,
name|new_cleanups
argument_list|)
expr_stmt|;
else|else
name|new_cleanups
operator|=
name|TREE_VALUE
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
name|cleanups
operator|=
name|TREE_CHAIN
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|new_cleanups
return|;
block|}
end_function

begin_comment
comment|/* Expand all cleanups up to OLD_CLEANUPS.    Needed here, and also for language-dependent calls.  */
end_comment

begin_function
name|void
name|expand_cleanups_to
parameter_list|(
name|old_cleanups
parameter_list|)
name|tree
name|old_cleanups
decl_stmt|;
block|{
while|while
condition|(
name|cleanups_this_call
operator|!=
name|old_cleanups
condition|)
block|{
call|(
modifier|*
name|interim_eh_hook
call|)
argument_list|(
name|TREE_VALUE
argument_list|(
name|cleanups_this_call
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|cleanups_this_call
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanups_this_call
operator|=
name|TREE_CHAIN
argument_list|(
name|cleanups_this_call
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand conditional expressions.  */
end_comment

begin_comment
comment|/* Generate code to evaluate EXP and jump to LABEL if the value is zero.    LABEL is an rtx of code CODE_LABEL, in this function and all the    functions here.  */
end_comment

begin_function
name|void
name|jumpifnot
parameter_list|(
name|exp
parameter_list|,
name|label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|do_jump
argument_list|(
name|exp
argument_list|,
name|label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */
end_comment

begin_function
name|void
name|jumpif
parameter_list|(
name|exp
parameter_list|,
name|label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|do_jump
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if    the result is zero, or IF_TRUE_LABEL if the result is one.    Either of IF_FALSE_LABEL and IF_TRUE_LABEL may be zero,    meaning fall through in that case.     do_jump always does any pending stack adjust except when it does not    actually perform a jump.  An example where there is no jump    is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.     This function is responsible for optimizing cases such as&&, || and comparison operators in EXP.  */
end_comment

begin_function
name|void
name|do_jump
parameter_list|(
name|exp
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Some cases need to create a label to jump to      in order to properly fall through.      These cases set DROP_THROUGH_LABEL nonzero.  */
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|comparison
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|INTEGER_CST
case|:
name|temp
operator|=
name|integer_zerop
argument_list|(
name|exp
argument_list|)
condition|?
name|if_false_label
else|:
name|if_true_label
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|emit_jump
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* This is not true with #pragma weak  */
block|case ADDR_EXPR:
comment|/* The address of something can never be zero.  */
block|if (if_true_label) 	emit_jump (if_true_label);       break;
endif|#
directive|endif
case|case
name|NOP_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
condition|)
goto|goto
name|normal
goto|;
case|case
name|CONVERT_EXPR
case|:
comment|/* If we are narrowing the operand, we have to do the compare in the 	 narrower mode.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|normal
goto|;
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|REFERENCE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
comment|/* These cannot change zero->non-zero or vice versa.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* This is never less insns than evaluating the PLUS_EXPR followed by 	 a test and can be longer if the test is eliminated.  */
block|case PLUS_EXPR:
comment|/* Reduce to minus.  */
block|exp = build (MINUS_EXPR, TREE_TYPE (exp), 		   TREE_OPERAND (exp, 0), 		   fold (build1 (NEGATE_EXPR, TREE_TYPE (TREE_OPERAND (exp, 1)), 				 TREE_OPERAND (exp, 1))));
comment|/* Process as MINUS.  */
endif|#
directive|endif
case|case
name|MINUS_EXPR
case|:
comment|/* Non-zero iff operands of minus differ.  */
name|comparison
operator|=
name|compare
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
comment|/* If we are AND'ing with a small constant, do this comparison in the 	 smallest type that fits.  If the machine doesn't have comparisons 	 that small, it will be converted back to the wider comparison. 	 This helps if we are testing the sign bit of a narrower object. 	 combine can't do this for us because it can't know whether a 	 ZERO_EXTRACT or a compare in a smaller mode exists, but we do.  */
if|if
condition|(
operator|!
name|SLOW_BYTE_ACCESS
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|i
operator|=
name|floor_log2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|mode
operator|=
name|mode_for_size
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|BLKmode
operator|&&
operator|(
name|type
operator|=
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|do_jump
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|normal
goto|;
case|case
name|TRUTH_NOT_EXPR
case|:
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
block|{
name|rtx
name|seq1
decl_stmt|,
name|seq2
decl_stmt|;
name|tree
name|cleanups
decl_stmt|,
name|old_cleanups
decl_stmt|;
if|if
condition|(
name|if_false_label
operator|==
literal|0
condition|)
name|if_false_label
operator|=
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|seq1
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|old_cleanups
operator|=
name|cleanups_this_call
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|seq2
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|cleanups
operator|=
name|defer_cleanups_to
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanups
condition|)
block|{
name|rtx
name|flag
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|tree
name|new_cleanups
decl_stmt|;
name|tree
name|cond
decl_stmt|;
comment|/* Flag cleanups as not needed. */
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|seq1
argument_list|)
expr_stmt|;
comment|/* Flag cleanups as needed. */
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|seq2
argument_list|)
expr_stmt|;
comment|/* convert flag, which is an rtx, into a tree. */
name|cond
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|cond
argument_list|)
operator|=
name|flag
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|cond
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|cond
operator|=
name|save_expr
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|new_cleanups
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|truthvalue_conversion
argument_list|(
name|cond
argument_list|)
argument_list|,
name|cleanups
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|new_cleanups
operator|=
name|fold
argument_list|(
name|new_cleanups
argument_list|)
expr_stmt|;
comment|/* Now add in the conditionalized cleanups. */
name|cleanups_this_call
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|new_cleanups
argument_list|,
name|cleanups_this_call
argument_list|)
expr_stmt|;
call|(
modifier|*
name|interim_eh_hook
call|)
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insns
argument_list|(
name|seq1
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|seq2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
block|{
name|rtx
name|seq1
decl_stmt|,
name|seq2
decl_stmt|;
name|tree
name|cleanups
decl_stmt|,
name|old_cleanups
decl_stmt|;
if|if
condition|(
name|if_true_label
operator|==
literal|0
condition|)
name|if_true_label
operator|=
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|seq1
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|old_cleanups
operator|=
name|cleanups_this_call
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|seq2
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|cleanups
operator|=
name|defer_cleanups_to
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanups
condition|)
block|{
name|rtx
name|flag
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|tree
name|new_cleanups
decl_stmt|;
name|tree
name|cond
decl_stmt|;
comment|/* Flag cleanups as not needed. */
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|seq1
argument_list|)
expr_stmt|;
comment|/* Flag cleanups as needed. */
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|seq2
argument_list|)
expr_stmt|;
comment|/* convert flag, which is an rtx, into a tree. */
name|cond
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|cond
argument_list|)
operator|=
name|flag
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|cond
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|cond
operator|=
name|save_expr
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|new_cleanups
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|truthvalue_conversion
argument_list|(
name|cond
argument_list|)
argument_list|,
name|cleanups
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|new_cleanups
operator|=
name|fold
argument_list|(
name|new_cleanups
argument_list|)
expr_stmt|;
comment|/* Now add in the conditionalized cleanups. */
name|cleanups_this_call
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|new_cleanups
argument_list|,
name|cleanups_this_call
argument_list|)
expr_stmt|;
call|(
modifier|*
name|interim_eh_hook
call|)
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insns
argument_list|(
name|seq1
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|seq2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|push_temp_slots
argument_list|()
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
case|case
name|ARRAY_REF
case|:
block|{
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|,
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
comment|/* Get description of this reference.  We don't actually care 	   about the underlying object here.  */
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|)
expr_stmt|;
name|type
operator|=
name|type_for_size
argument_list|(
name|bitsize
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLOW_BYTE_ACCESS
operator|&&
name|type
operator|!=
literal|0
operator|&&
name|bitsize
operator|>=
literal|0
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|do_jump
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|normal
goto|;
block|}
case|case
name|COND_EXPR
case|:
comment|/* Do (a ? 1 : 0) and (a ? 0 : 1) as special cases.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|rtx
name|label1
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Now the THEN-expression.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
condition|?
name|if_false_label
else|:
name|drop_through_label
argument_list|,
name|if_true_label
condition|?
name|if_true_label
else|:
name|drop_through_label
argument_list|)
expr_stmt|;
comment|/* In case the do_jump just above never jumps.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label1
argument_list|)
expr_stmt|;
comment|/* Now the ELSE-expression.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|if_false_label
condition|?
name|if_false_label
else|:
name|drop_through_label
argument_list|,
name|if_true_label
condition|?
name|if_true_label
else|:
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
name|do_jump
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_equality
argument_list|(
name|exp
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|EQ
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NE_EXPR
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
name|do_jump
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_equality
argument_list|(
name|exp
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LT_EXPR
case|:
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|LT
argument_list|,
name|LTU
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|LE
argument_list|,
name|LEU
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|GT
argument_list|,
name|GTU
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|GE
argument_list|,
name|GEU
argument_list|)
expr_stmt|;
break|break;
default|default:
name|normal
label|:
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is not needed any more and causes poor code since it causes 	 comparisons and tests from non-SI objects to have different code 	 sequences.  */
comment|/* Copy to register to avoid generating bad insns by cse 	 from (set (mem ...) (arithop))  (set (cc0) (mem ...)).  */
block|if (!cse_not_expected&& GET_CODE (temp) == MEM) 	temp = copy_to_reg (temp);
endif|#
directive|endif
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|comparison
operator|=
operator|(
name|temp
operator|==
name|const0_rtx
condition|?
name|const0_rtx
else|:
name|const_true_rtx
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|comparison
operator|=
name|const_true_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
condition|)
comment|/* Note swapping the labels gives us not-equal.  */
name|do_jump_by_parts_equality_rtx
argument_list|(
name|temp
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|comparison
operator|=
name|compare_from_rtx
argument_list|(
name|temp
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|,
name|NE
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Do any postincrements in the expression that was tested.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* If COMPARISON is nonzero here, it is an rtx that can be substituted      straight into a conditional jump instruction as the jump condition.      Otherwise, all the work has been done already.  */
if|if
condition|(
name|comparison
operator|==
name|const_true_rtx
condition|)
block|{
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comparison
operator|==
name|const0_rtx
condition|)
block|{
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comparison
condition|)
name|do_jump_for_compare
argument_list|(
name|comparison
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
block|{
comment|/* If do_jump produces code that might be jumped around, 	 do any stack adjusts from that code, before the place 	 where control merges in.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a comparison expression EXP for values too wide to be compared    with one insn, test the comparison and jump to the appropriate label.    The code of EXP is ignored; we always test GT if SWAP is 0,    and LT if SWAP is 1.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_by_parts_greater
parameter_list|(
name|exp
parameter_list|,
name|swap
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|swap
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|swap
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
operator|!
name|swap
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nwords
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|if_true_label
operator|||
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|if_true_label
condition|)
name|if_true_label
operator|=
name|drop_through_label
expr_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|if_false_label
operator|=
name|drop_through_label
expr_stmt|;
comment|/* Compare a word at a time, high order first.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|comp
decl_stmt|;
name|rtx
name|op0_word
decl_stmt|,
name|op1_word
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* All but high-order word must be compared as unsigned.  */
name|comp
operator|=
name|compare_from_rtx
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
operator|(
name|unsignedp
operator|||
name|i
operator|>
literal|0
operator|)
condition|?
name|GTU
else|:
name|GT
argument_list|,
name|unsignedp
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|NULL_RTX
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
comment|/* Consider lower words only if these are equal.  */
name|comp
operator|=
name|compare_from_rtx
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
name|NE
argument_list|,
name|unsignedp
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare OP0 with OP1, word at a time, in mode MODE.    UNSIGNEDP says to do unsigned comparison.    Jump to IF_TRUE_LABEL if OP0 is greater, IF_FALSE_LABEL otherwise.  */
end_comment

begin_function
name|void
name|do_jump_by_parts_greater_rtx
parameter_list|(
name|mode
parameter_list|,
name|unsignedp
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|int
name|nwords
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|if_true_label
operator|||
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|if_true_label
condition|)
name|if_true_label
operator|=
name|drop_through_label
expr_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|if_false_label
operator|=
name|drop_through_label
expr_stmt|;
comment|/* Compare a word at a time, high order first.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|comp
decl_stmt|;
name|rtx
name|op0_word
decl_stmt|,
name|op1_word
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* All but high-order word must be compared as unsigned.  */
name|comp
operator|=
name|compare_from_rtx
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
operator|(
name|unsignedp
operator|||
name|i
operator|>
literal|0
operator|)
condition|?
name|GTU
else|:
name|GT
argument_list|,
name|unsignedp
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|NULL_RTX
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
comment|/* Consider lower words only if these are equal.  */
name|comp
operator|=
name|compare_from_rtx
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
name|NE
argument_list|,
name|unsignedp
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an EQ_EXPR expression EXP for values too wide to be compared    with one insn, test the comparison and jump to the appropriate label.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_by_parts_equality
parameter_list|(
name|exp
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nwords
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|if_false_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|comp
init|=
name|compare_from_rtx
argument_list|(
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Jump according to whether OP0 is 0.    We assume that OP0 has an integer mode that is too wide    for the available compare insns.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_by_parts_equality_rtx
parameter_list|(
name|op0
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|int
name|nwords
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|if_false_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|comp
init|=
name|compare_from_rtx
argument_list|(
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|1
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a comparison expression in rtl form, output conditional branches to    IF_TRUE_LABEL, IF_FALSE_LABEL, or both.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_for_compare
parameter_list|(
name|comparison
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|rtx
name|comparison
decl_stmt|,
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
if|if
condition|(
name|if_true_label
condition|)
block|{
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
call|)
argument_list|(
name|if_true_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|if_false_label
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|prev
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|branch
init|=
literal|0
decl_stmt|;
comment|/* Output the branch with the opposite condition.  Then try to invert 	 what is generated.  If more than one insn is a branch, or if the 	 branch is not the last insn written, abort. If we can't invert 	 the branch, emit make a true label, redirect this jump to that, 	 emit a jump to the false label and define the true label.  */
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
call|)
argument_list|(
name|if_false_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Here we get the first insn that was just emitted.  It used to be  the 	 case that, on some machines, emitting the branch would discard 	 the previous compare insn and emit a replacement.  This isn't 	 done anymore, but abort if we see that PREV is deleted.  */
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|prev
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|branch
condition|)
name|abort
argument_list|()
expr_stmt|;
name|branch
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|branch
operator|!=
name|get_last_insn
argument_list|()
condition|)
name|abort
argument_list|()
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|branch
argument_list|)
operator|=
name|if_false_label
expr_stmt|;
if|if
condition|(
operator|!
name|invert_jump
argument_list|(
name|branch
argument_list|,
name|if_false_label
argument_list|)
condition|)
block|{
name|if_true_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|redirect_jump
argument_list|(
name|branch
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code for a comparison expression EXP    (including code to compute the values to be compared)    and set (CC0) according to the result.    SIGNED_CODE should be the rtx operation for this comparison for    signed data; UNSIGNED_CODE, likewise for use if data is unsigned.     We force a stack adjustment unless there are currently    things pushed on the stack that aren't yet used.  */
end_comment

begin_function
specifier|static
name|rtx
name|compare
parameter_list|(
name|exp
parameter_list|,
name|signed_code
parameter_list|,
name|unsigned_code
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
name|enum
name|rtx_code
name|signed_code
decl_stmt|,
name|unsigned_code
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|unsignedp
condition|?
name|unsigned_code
else|:
name|signed_code
decl_stmt|;
return|return
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|expr_size
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|NULL_RTX
operator|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like compare but expects the values to compare as two rtx's.    The decision as to signed or unsigned comparison must be made by the caller.     If MODE is BLKmode, SIZE is an RTX giving the size of the objects being    compared.     If ALIGN is non-zero, it is the alignment of this type; if zero, the    size of MODE should be used.  */
end_comment

begin_function
name|rtx
name|compare_from_rtx
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|code
parameter_list|,
name|unsignedp
parameter_list|,
name|mode
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If one operand is constant, make it the second one.  Only do this      if the other operand is not constant as well.  */
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|tem
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
if|#
directive|if
literal|0
comment|/* There's no need to do this now that combine.c can eliminate lots of      sign extensions.  This can be less efficient in certain cases on other      machines. */
comment|/* If this is a signed equality comparison, we can do it as an      unsigned comparison since zero-extension is cheaper than sign      extension and comparisons with zero are done as unsigned.  This is      the case even on machines that can do fast sign extension, since      zero-extension is easier to combine with other operations than      sign-extension is.  If we are comparing against a constant, we must      convert it to what it would look like unsigned.  */
block|if ((code == EQ || code == NE)&& ! unsignedp&& GET_MODE_BITSIZE (GET_MODE (op0))<= HOST_BITS_PER_WIDE_INT)     {       if (GET_CODE (op1) == CONST_INT&& (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0))) != INTVAL (op1)) 	op1 = GEN_INT (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0)));       unsignedp = 1;     }
endif|#
directive|endif
name|emit_cmp_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|cc0_rtx
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to calculate EXP using a store-flag instruction    and return an rtx for the result.  EXP is either a comparison    or a TRUTH_NOT_EXPR whose operand is a comparison.     If TARGET is nonzero, store the result there if convenient.     If ONLY_CHEAP is non-zero, only do this if it is likely to be very    cheap.     Return zero if there is no suitable set-flag instruction    available on this machine.     Once expand_expr has been called on the arguments of the comparison,    we are committed to doing the store flag, since it is not safe to    re-evaluate the expression.  We emit the store-flag insn by calling    emit_store_flag, but only expand the arguments if we have a reason    to believe that emit_store_flag will be successful.  If we think that    it will, but it isn't, we have to simulate the store-flag with a    set/jump/set sequence.  */
end_comment

begin_function
specifier|static
name|rtx
name|do_store_flag
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|,
name|only_cheap
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|only_cheap
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|enum
name|machine_mode
name|operand_mode
decl_stmt|;
name|int
name|invert
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|subtarget
init|=
name|target
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|label
decl_stmt|,
name|pattern
decl_stmt|,
name|jump_pat
decl_stmt|;
comment|/* If this is a TRUTH_NOT_EXPR, set a flag indicating we must invert the      result at the end.  We can't simply invert the test since it would      have already been inverted if it were valid.  This case occurs for      some floating-point comparisons.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|invert
operator|=
literal|1
operator|,
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|operand_mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* We won't bother with BLKmode store-flag operations because it would mean      passing a lot of information to emit_store_flag.  */
if|if
condition|(
name|operand_mode
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* Get the rtx comparison code to use.  We know that EXP is a comparison      operation of some type.  Some comparisons against 1 and -1 can be      converted to comparisons with zero.  Do so here so that the tests      below will be aware that we have a comparison with zero.   These      tests will not catch constants in the first operand, but constants      are rarely passed as the first operand.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|unsignedp
condition|?
name|LEU
else|:
name|LE
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|LTU
else|:
name|LT
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|LT
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|LEU
else|:
name|LE
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|GE
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|GTU
else|:
name|GT
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|unsignedp
condition|?
name|GTU
else|:
name|GT
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|GEU
else|:
name|GE
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Put a constant second.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tem
operator|=
name|arg0
expr_stmt|;
name|arg0
operator|=
name|arg1
expr_stmt|;
name|arg1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* If this is an equality or inequality test of a single bit, we can      do this by shifting the bit being tested to the low-order bit and      masking the result with the constant 1.  If the condition was EQ,      we xor it with 1.  This does not require an scc insn and is faster      than an scc insn even if we have it.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|bitnum
init|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|ops_unsignedp
decl_stmt|;
comment|/* If INNER is a right shift of a constant and it plus BITNUM does 	 not overflow, adjust BITNUM and INNER.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|RSHIFT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|bitnum
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|bitnum
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we are going to be able to omit the AND below, we must do our 	 operations as unsigned.  If we must use the AND, we have a choice. 	 Normally unsigned is faster, but for some machines signed is.  */
name|ops_unsignedp
operator|=
operator|(
name|bitnum
operator|==
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
condition|?
literal|1
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
else|:
operator|(
name|LOAD_EXTEND_OP
argument_list|(
name|operand_mode
argument_list|)
operator|==
name|SIGN_EXTEND
condition|?
literal|0
else|:
literal|1
operator|)
else|#
directive|else
else|:
literal|1
endif|#
directive|endif
block|)
function|;
end_function

begin_if
if|if
condition|(
name|subtarget
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|subtarget
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|subtarget
argument_list|)
operator|!=
name|operand_mode
operator|||
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|inner
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|op0
operator|=
name|expand_expr
argument_list|(
name|inner
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bitnum
operator|!=
literal|0
condition|)
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|bitnum
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|ops_unsignedp
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|ops_unsignedp
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|&&
operator|!
name|invert
operator|)
operator|||
operator|(
name|code
operator|==
name|NE
operator|&&
name|invert
operator|)
condition|)
name|op0
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|,
name|ops_unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Put the AND last so it can combine with more things.  */
end_comment

begin_if
if|if
condition|(
name|bitnum
operator|!=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
condition|)
name|op0
operator|=
name|expand_and
argument_list|(
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|op0
return|;
end_return

begin_comment
unit|}
comment|/* Now see if we are likely to be able to do this.  Return if not.  */
end_comment

begin_expr_stmt
unit|if
operator|(
operator|!
name|can_compare_p
argument_list|(
name|operand_mode
argument_list|)
operator|)
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_expr_stmt
name|icode
operator|=
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|||
operator|(
name|only_cheap
operator|&&
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|0
index|]
operator|!=
name|mode
operator|)
condition|)
block|{
comment|/* We can only do this if it is one of the special cases that 	 can be handled without an scc insn.  */
if|if
condition|(
operator|(
name|code
operator|==
name|LT
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|only_cheap
operator|&&
name|code
operator|==
name|GE
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|BRANCH_COST
operator|>=
literal|0
operator|&&
operator|!
name|only_cheap
operator|&&
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
operator|&&
operator|(
operator|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|operand_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|operand_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
block|}
end_if

begin_expr_stmt
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|subtarget
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|subtarget
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|subtarget
argument_list|)
operator|!=
name|operand_mode
operator|||
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|arg1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Pass copies of OP0 and OP1 in case they contain a QUEUED.  This is safe      because, if the emit_store_flag does anything it will succeed and      OP0 and OP1 will not be used subsequently.  */
end_comment

begin_expr_stmt
name|result
operator|=
name|emit_store_flag
argument_list|(
name|target
argument_list|,
name|code
argument_list|,
name|queued_subexp_p
argument_list|(
name|op0
argument_list|)
condition|?
name|copy_rtx
argument_list|(
name|op0
argument_list|)
else|:
name|op0
argument_list|,
name|queued_subexp_p
argument_list|(
name|op1
argument_list|)
condition|?
name|copy_rtx
argument_list|(
name|op1
argument_list|)
else|:
name|op1
argument_list|,
name|operand_mode
argument_list|,
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|result
condition|)
block|{
if|if
condition|(
name|invert
condition|)
name|result
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_if

begin_comment
comment|/* If this failed, we have to do this with set/compare/jump/set code.  */
end_comment

begin_if
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|invert
condition|?
name|const0_rtx
else|:
name|const1_rtx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|result
operator|=
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|operand_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
operator|(
name|result
operator|==
name|const0_rtx
operator|&&
operator|!
name|invert
operator|)
operator|||
operator|(
name|result
operator|!=
name|const0_rtx
operator|&&
name|invert
operator|)
operator|)
condition|?
name|const0_rtx
else|:
name|const1_rtx
operator|)
return|;
end_if

begin_expr_stmt
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
call|)
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|invert
condition|?
name|const1_rtx
else|:
name|const0_rtx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|target
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* Generate a tablejump instruction (used for switch statements).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_tablejump
end_ifdef

begin_comment
comment|/* INDEX is the value being switched on, with the lowest value    in the table already subtracted.    MODE is its expected mode (needed if INDEX is constant).    RANGE is the length of the jump table.    TABLE_LABEL is a CODE_LABEL rtx for the table itself.     DEFAULT_LABEL is a CODE_LABEL rtx to jump to if the    index value is out of range.  */
end_comment

begin_macro
unit|void
name|do_tablejump
argument_list|(
argument|index
argument_list|,
argument|mode
argument_list|,
argument|range
argument_list|,
argument|table_label
argument_list|,
argument|default_label
argument_list|)
end_macro

begin_decl_stmt
name|rtx
name|index
decl_stmt|,
name|range
decl_stmt|,
name|table_label
decl_stmt|,
name|default_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|rtx
name|temp
decl_stmt|,
name|vector
decl_stmt|;
comment|/* Do an unsigned comparison (in the proper mode) between the index      expression and the value which represents the length of the range.      Since we just finished subtracting the lower bound of the range      from the index expression, this comparison allows us to simultaneously      check that the original index expression value is both greater than      or equal to the minimum value of the range and less than or equal to      the maximum value of the range.  */
name|emit_cmp_insn
argument_list|(
name|index
argument_list|,
name|range
argument_list|,
name|GTU
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bgtu
argument_list|(
name|default_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If index is in range, it must fit in Pmode.      Convert to Pmode so we can index with it.  */
if|if
condition|(
name|mode
operator|!=
name|Pmode
condition|)
name|index
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't let a MEM slip thru, because then INDEX that comes      out of PIC_CASE_VECTOR_ADDRESS won't be a valid address,      and break_out_memory_refs will go to work on it and mess it up.  */
ifdef|#
directive|ifdef
name|PIC_CASE_VECTOR_ADDRESS
if|if
condition|(
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|REG
condition|)
name|index
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If flag_force_addr were to affect this address      it could interfere with the tricky assumptions made      about addresses that contain label-refs,      which may be valid only very near the tablejump itself.  */
comment|/* ??? The only correct use of CASE_VECTOR_MODE is the one inside the      GET_MODE_SIZE, because this indicates how large insns are.  The other      uses should all be Pmode, because they are addresses.  This code      could fail if addresses and insns are not the same size.  */
name|index
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|Pmode
argument_list|,
name|index
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|CASE_VECTOR_MODE
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|table_label
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC_CASE_VECTOR_ADDRESS
if|if
condition|(
name|flag_pic
condition|)
name|index
operator|=
name|PIC_CASE_VECTOR_ADDRESS
argument_list|(
name|index
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|index
operator|=
name|memory_address_noforce
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|CASE_VECTOR_MODE
argument_list|)
expr_stmt|;
name|vector
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|CASE_VECTOR_MODE
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|vector
argument_list|)
operator|=
literal|1
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|vector
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_tablejump
argument_list|(
name|temp
argument_list|,
name|table_label
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CASE_VECTOR_PC_RELATIVE
comment|/* If we are generating PIC code or if the table is PC-relative, the      table and JUMP_INSN must be adjacent, so don't output a BARRIER.  */
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|emit_barrier
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_tablejump */
end_comment

begin_comment
comment|/* Emit a suitable bytecode to load a value from memory, assuming a pointer    to that value is on the top of the stack. The resulting type is TYPE, and    the source declaration is DECL. */
end_comment

begin_function
name|void
name|bc_load_memory
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|enum
name|bytecode_opcode
name|opcode
decl_stmt|;
comment|/* Bit fields are special.  We only know about signed and      unsigned ints, and enums.  The latter are treated as      signed integers. */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|decl
argument_list|)
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
name|opcode
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|zxloadBI
else|:
name|sxloadBI
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
elseif|else
comment|/* See corresponding comment in bc_store_memory(). */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return;
else|else
name|opcode
operator|=
name|mode_to_load_map
index|[
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|neverneverland
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bc_emit_bytecode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Store the contents of the second stack slot to the address in the    top stack slot.  DECL is the declaration of the destination and is used    to determine whether we're dealing with a bitfield. */
end_comment

begin_function
name|void
name|bc_store_memory
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|enum
name|bytecode_opcode
name|opcode
decl_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
name|opcode
operator|=
name|sstoreBI
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
comment|/* Copy structure.  This expands to a block copy instruction, storeBLK. 	   In addition to the arguments expected by the other store instructions, 	   it also expects a type size (SImode) on top of the stack, which is the 	   structure size in size units (usually bytes).  The two first arguments 	   are already on the stack; so we just put the size on level 1.  For some 	   other languages, the size may be variable, this is why we don't encode 	   it as a storeBLK literal, but rather treat it as a full-fledged expression. */
name|bc_expand_expr
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|storeBLK
expr_stmt|;
block|}
else|else
name|opcode
operator|=
name|mode_to_store_map
index|[
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|neverneverland
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bc_emit_bytecode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Allocate local stack space sufficient to hold a value of the given    SIZE at alignment boundary ALIGNMENT bits.  ALIGNMENT must be an    integral power of 2.  A special case is locals of type VOID, which    have size 0 and alignment 1 - any "voidish" SIZE or ALIGNMENT is    remapped into the corresponding attribute of SI.  */
end_comment

begin_function
name|rtx
name|bc_allocate_local
parameter_list|(
name|size
parameter_list|,
name|alignment
parameter_list|)
name|int
name|size
decl_stmt|,
name|alignment
decl_stmt|;
block|{
name|rtx
name|retval
decl_stmt|;
name|int
name|byte_alignment
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Normalize size and alignment  */
if|if
condition|(
operator|!
name|size
condition|)
name|size
operator|=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|alignment
operator|<
name|BITS_PER_UNIT
condition|)
name|byte_alignment
operator|=
literal|1
operator|<<
operator|(
name|INT_ALIGN
operator|-
literal|1
operator|)
expr_stmt|;
else|else
comment|/* Align */
name|byte_alignment
operator|=
name|alignment
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|local_vars_size
operator|&
operator|(
name|byte_alignment
operator|-
literal|1
operator|)
condition|)
name|local_vars_size
operator|+=
name|byte_alignment
operator|-
operator|(
name|local_vars_size
operator|&
operator|(
name|byte_alignment
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|retval
operator|=
name|bc_gen_rtx
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|local_vars_size
argument_list|,
operator|(
expr|struct
name|bc_label
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|local_vars_size
operator|+=
name|size
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Allocate variable-sized local array. Variable-sized arrays are    actually pointers to the address in memory where they are stored. */
end_comment

begin_function
name|rtx
name|bc_allocate_variable_array
parameter_list|(
name|size
parameter_list|)
name|tree
name|size
decl_stmt|;
block|{
name|rtx
name|retval
decl_stmt|;
specifier|const
name|int
name|ptralign
init|=
operator|(
literal|1
operator|<<
operator|(
name|PTR_ALIGN
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
comment|/* Align pointer */
if|if
condition|(
name|local_vars_size
operator|&
name|ptralign
condition|)
name|local_vars_size
operator|+=
name|ptralign
operator|-
operator|(
name|local_vars_size
operator|&
name|ptralign
operator|)
expr_stmt|;
comment|/* Note down local space needed: pointer to block; also return      dummy rtx */
name|retval
operator|=
name|bc_gen_rtx
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|local_vars_size
argument_list|,
operator|(
expr|struct
name|bc_label
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|local_vars_size
operator|+=
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Push the machine address for the given external variable offset.  */
end_comment

begin_function
name|void
name|bc_load_externaddr
parameter_list|(
name|externaddr
parameter_list|)
name|rtx
name|externaddr
decl_stmt|;
block|{
name|bc_emit_bytecode
argument_list|(
name|constP
argument_list|)
expr_stmt|;
name|bc_emit_code_labelref
argument_list|(
name|BYTECODE_LABEL
argument_list|(
name|externaddr
argument_list|)
argument_list|,
name|BYTECODE_BC_LABEL
argument_list|(
name|externaddr
argument_list|)
operator|->
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|bc_strdup
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|s
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Like above, but expects an IDENTIFIER.  */
end_comment

begin_function
name|void
name|bc_load_externaddr_id
parameter_list|(
name|id
parameter_list|,
name|offset
parameter_list|)
name|tree
name|id
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bc_emit_bytecode
argument_list|(
name|constP
argument_list|)
expr_stmt|;
name|bc_emit_code_labelref
argument_list|(
name|bc_xstrdup
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Push the machine address for the given local variable offset.  */
end_comment

begin_function
name|void
name|bc_load_localaddr
parameter_list|(
name|localaddr
parameter_list|)
name|rtx
name|localaddr
decl_stmt|;
block|{
name|bc_emit_instruction
argument_list|(
name|localP
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|BYTECODE_BC_LABEL
argument_list|(
name|localaddr
argument_list|)
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push the machine address for the given parameter offset.    NOTE: offset is in bits. */
end_comment

begin_function
name|void
name|bc_load_parmaddr
parameter_list|(
name|parmaddr
parameter_list|)
name|rtx
name|parmaddr
decl_stmt|;
block|{
name|bc_emit_instruction
argument_list|(
name|argP
argument_list|,
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|BYTECODE_BC_LABEL
argument_list|(
name|parmaddr
argument_list|)
operator|->
name|offset
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a[i] into *(a + i).  */
end_comment

begin_function
name|tree
name|bc_canonicalize_array_ref
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|array_adr
init|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Convert the integer argument to a type the same size as a pointer      so the multiply won't overflow spuriously.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|POINTER_SIZE
condition|)
name|index
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* The array address isn't volatile even if the array is.      (Of course this isn't terribly relevant since the bytecode      translator treats nearly everything as volatile anyway.)  */
name|TREE_THIS_VOLATILE
argument_list|(
name|array_adr
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|array_adr
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|,
name|size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Load the address of the component referenced by the given    COMPONENT_REF expression.     Returns innermost lvalue. */
end_comment

begin_function
name|tree
name|bc_expand_component_address
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|tem
decl_stmt|,
name|chain
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bitpos
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|SIval
decl_stmt|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* Compute cumulative bit offset for nested component refs      and array refs, and find the ultimate containing object.  */
for|for
control|(
name|tem
operator|=
name|exp
init|;
condition|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|bitpos
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|bitpos
operator|+=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
comment|/* * TYPE_SIZE_UNIT (TREE_TYPE (tem)) */
operator|)
expr_stmt|;
else|else
break|break;
block|}
name|bc_expand_expr
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* For bitfields also push their offset and size */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|bc_push_offset_and_size
argument_list|(
name|bitpos
argument_list|,
comment|/* DECL_SIZE_UNIT */
operator|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SIval
operator|=
name|bitpos
operator|/
name|BITS_PER_UNIT
condition|)
name|bc_emit_instruction
argument_list|(
name|addconstPSI
argument_list|,
name|SIval
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Emit code to push two SI constants */
end_comment

begin_function
name|void
name|bc_push_offset_and_size
parameter_list|(
name|offset
parameter_list|,
name|size
parameter_list|)
name|HOST_WIDE_INT
name|offset
decl_stmt|,
name|size
decl_stmt|;
block|{
name|bc_emit_instruction
argument_list|(
name|constSI
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|constSI
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit byte code to push the address of the given lvalue expression to    the stack.  If it's a bit field, we also push offset and size info.     Returns innermost component, which allows us to determine not only    its type, but also whether it's a bitfield. */
end_comment

begin_function
name|tree
name|bc_expand_address
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
comment|/* Safeguard */
if|if
condition|(
operator|!
name|exp
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
operator|(
name|exp
operator|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ARRAY_REF
case|:
return|return
operator|(
name|bc_expand_address
argument_list|(
name|bc_canonicalize_array_ref
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|COMPONENT_REF
case|:
return|return
operator|(
name|bc_expand_component_address
argument_list|(
name|exp
argument_list|)
operator|)
return|;
case|case
name|INDIRECT_REF
case|:
name|bc_expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For variable-sized types: retrieve pointer.  Sometimes the 	 TYPE_SIZE tree is NULL.  Is this a bug or a feature?  Let's 	 also make sure we have an operand, just in case... */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|bc_emit_instruction
argument_list|(
name|loadP
argument_list|)
expr_stmt|;
comment|/* If packed, also return offset and size */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|bc_push_offset_and_size
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|FUNCTION_DECL
case|:
name|bc_load_externaddr_id
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|exp
argument_list|)
argument_list|,
name|BYTECODE_BC_LABEL
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
name|bc_load_parmaddr
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For variable-sized types: retrieve pointer */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|bc_emit_instruction
argument_list|(
name|loadP
argument_list|)
expr_stmt|;
comment|/* If packed, also return offset and size */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|exp
argument_list|)
condition|)
name|bc_push_offset_and_size
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESULT_DECL
case|:
name|bc_emit_instruction
argument_list|(
name|returnP
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
if|#
directive|if
literal|0
block|if (BYTECODE_LABEL (DECL_RTL (exp))) 	bc_load_externaddr (DECL_RTL (exp));
endif|#
directive|endif
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|exp
argument_list|)
condition|)
name|bc_load_externaddr_id
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|exp
argument_list|)
argument_list|,
operator|(
name|BYTECODE_BC_LABEL
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|bc_load_localaddr
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For variable-sized types: retrieve pointer */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|bc_emit_instruction
argument_list|(
name|loadP
argument_list|)
expr_stmt|;
comment|/* If packed, also return offset and size */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|exp
argument_list|)
condition|)
name|bc_push_offset_and_size
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
block|{
name|rtx
name|r
decl_stmt|;
name|bc_emit_bytecode
argument_list|(
name|constP
argument_list|)
expr_stmt|;
name|r
operator|=
name|output_constant_def
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|bc_emit_code_labelref
argument_list|(
name|BYTECODE_LABEL
argument_list|(
name|r
argument_list|)
argument_list|,
name|BYTECODE_BC_LABEL
argument_list|(
name|r
argument_list|)
operator|->
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Most lvalues don't have components. */
return|return
operator|(
name|exp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Emit a type code to be used by the runtime support in handling    parameter passing.   The type code consists of the machine mode    plus the minimal alignment shifted left 8 bits.  */
end_comment

begin_function
name|tree
name|bc_runtime_type_code
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
name|val
operator|=
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|<<
literal|8
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
name|val
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|build_int_2
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate constructor label */
end_comment

begin_function
name|char
modifier|*
name|bc_gen_constr_label
parameter_list|()
block|{
specifier|static
name|int
name|label_counter
decl_stmt|;
specifier|static
name|char
name|label
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
literal|"*LR%d"
argument_list|,
name|label_counter
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Evaluate constructor CONSTR and return pointer to it on level one.  We    expand the constructor data as static data, and push a pointer to it.    The pointer is put in the pointer table and is retrieved by a constP    bytecode instruction.  We then loop and store each constructor member in    the corresponding component.  Finally, we return the original pointer on    the stack. */
end_comment

begin_function
name|void
name|bc_expand_constructor
parameter_list|(
name|constr
parameter_list|)
name|tree
name|constr
decl_stmt|;
block|{
name|char
modifier|*
name|l
decl_stmt|;
name|HOST_WIDE_INT
name|ptroffs
decl_stmt|;
name|rtx
name|constr_rtx
decl_stmt|;
comment|/* Literal constructors are handled as constants, whereas      non-literals are evaluated and stored element by element      into the data segment. */
comment|/* Allocate space in proper segment and push pointer to space on stack.    */
name|l
operator|=
name|bc_gen_constr_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|constr
argument_list|)
condition|)
block|{
name|text_section
argument_list|()
expr_stmt|;
name|bc_emit_const_labeldef
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|bc_output_constructor
argument_list|(
name|constr
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data_section
argument_list|()
expr_stmt|;
name|bc_emit_data_labeldef
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|bc_output_data_constructor
argument_list|(
name|constr
argument_list|)
expr_stmt|;
block|}
comment|/* Add reference to pointer table and recall pointer to stack;      this code is common for both types of constructors: literals      and non-literals. */
name|ptroffs
operator|=
name|bc_define_pointer
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|constP
argument_list|,
name|ptroffs
argument_list|)
expr_stmt|;
comment|/* This is all that has to be done if it's a literal. */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|constr
argument_list|)
condition|)
return|return;
comment|/* At this point, we have the pointer to the structure on top of the stack.      Generate sequences of store_memory calls for the constructor. */
comment|/* constructor type is structure */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
specifier|register
name|tree
name|elt
decl_stmt|;
comment|/* If the constructor has fewer fields than the structure, 	 clear the whole structure first.  */
if|if
condition|(
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|constr
argument_list|)
argument_list|)
operator|!=
name|list_length
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|bc_emit_instruction
argument_list|(
name|duplicate
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|constSI
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|clearBLK
argument_list|)
expr_stmt|;
block|}
comment|/* Store each element of the constructor into the corresponding 	 field of TARGET.  */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|constr
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
specifier|register
name|tree
name|field
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|bitsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
comment|/* * DECL_SIZE_UNIT (field) */
expr_stmt|;
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|bc_store_field
argument_list|(
name|elt
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|,
comment|/* The alignment of TARGET is 			     at least what its type requires.  */
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
comment|/* Constructor type is array */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
specifier|register
name|tree
name|elt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|minelt
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|maxelt
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|elttype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the constructor has fewer fields than the structure, 	   clear the whole structure first.  */
if|if
condition|(
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|constr
argument_list|)
argument_list|)
operator|<
name|maxelt
operator|-
name|minelt
operator|+
literal|1
condition|)
block|{
name|bc_emit_instruction
argument_list|(
name|duplicate
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|constSI
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|clearBLK
argument_list|)
expr_stmt|;
block|}
comment|/* Store each element of the constructor into the corresponding 	   element of TARGET, determined by counting the elements. */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|constr
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|bitpos
operator|=
operator|(
name|i
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|)
comment|/* * TYPE_SIZE_UNIT (elttype) */
operator|)
expr_stmt|;
name|bc_store_field
argument_list|(
name|elt
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|,
comment|/* The alignment of TARGET is 			       at least what its type requires.  */
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store the value of EXP (an expression tree) into member FIELD of    structure at address on stack, which has type TYPE, mode MODE and    occupies BITSIZE bits, starting BITPOS bits from the beginning of the    structure.     ALIGN is the alignment that TARGET is known to have, measured in bytes.    TOTAL_SIZE is its size in bytes, or -1 if variable.  */
end_comment

begin_function
name|void
name|bc_store_field
parameter_list|(
name|field
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|mode
parameter_list|,
name|exp
parameter_list|,
name|type
parameter_list|,
name|value_mode
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|,
name|total_size
parameter_list|)
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|exp
decl_stmt|,
name|type
decl_stmt|;
name|enum
name|machine_mode
name|value_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|total_size
decl_stmt|;
block|{
comment|/* Expand expression and copy pointer */
name|bc_expand_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|bc_emit_instruction
argument_list|(
name|over
argument_list|)
expr_stmt|;
comment|/* If the component is a bit field, we cannot use addressing to access      it.  Use bit-field techniques to store in it.  */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|bc_store_bit_field
argument_list|(
name|bitpos
argument_list|,
name|bitsize
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
comment|/* Not bit field */
block|{
name|HOST_WIDE_INT
name|offset
init|=
name|bitpos
operator|/
name|BITS_PER_UNIT
decl_stmt|;
comment|/* Advance pointer to the desired member */
if|if
condition|(
name|offset
condition|)
name|bc_emit_instruction
argument_list|(
name|addconstPSI
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Store */
name|bc_store_memory
argument_list|(
name|type
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store SI/SU in bitfield */
end_comment

begin_function
name|void
name|bc_store_bit_field
parameter_list|(
name|offset
parameter_list|,
name|size
parameter_list|,
name|unsignedp
parameter_list|)
name|int
name|offset
decl_stmt|,
name|size
decl_stmt|,
name|unsignedp
decl_stmt|;
block|{
comment|/* Push bitfield offset and size */
name|bc_push_offset_and_size
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Store */
name|bc_emit_instruction
argument_list|(
name|sstoreBI
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load SI/SU from bitfield */
end_comment

begin_function
name|void
name|bc_load_bit_field
parameter_list|(
name|offset
parameter_list|,
name|size
parameter_list|,
name|unsignedp
parameter_list|)
name|int
name|offset
decl_stmt|,
name|size
decl_stmt|,
name|unsignedp
decl_stmt|;
block|{
comment|/* Push bitfield offset and size */
name|bc_push_offset_and_size
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Load: sign-extend if signed, else zero-extend */
name|bc_emit_instruction
argument_list|(
name|unsignedp
condition|?
name|zxloadBI
else|:
name|sxloadBI
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust interpreter stack by NLEVELS.  Positive means drop NLEVELS    (adjust stack pointer upwards), negative means add that number of    levels (adjust the stack pointer downwards).  Only positive values    normally make sense. */
end_comment

begin_function
name|void
name|bc_adjust_stack
parameter_list|(
name|nlevels
parameter_list|)
name|int
name|nlevels
decl_stmt|;
block|{
switch|switch
condition|(
name|nlevels
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|2
case|:
name|bc_emit_instruction
argument_list|(
name|drop
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|bc_emit_instruction
argument_list|(
name|drop
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bc_emit_instruction
argument_list|(
name|adjstackSI
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|nlevels
argument_list|)
expr_stmt|;
name|stack_depth
operator|-=
name|nlevels
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VALIDATE_STACK_FOR_BC
argument_list|)
name|VALIDATE_STACK_FOR_BC
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

