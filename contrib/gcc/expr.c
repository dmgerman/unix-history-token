begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert tree expression to rtl instructions, for GNU compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_comment
comment|/* Include expr.h after insn-config.h so we get HAVE_conditional_move. */
end_comment

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"typeclass.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_define
define|#
directive|define
name|CEIL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + (y) - 1) / (y))
end_define

begin_comment
comment|/* Decide whether a function's arguments should be processed    from first to last or from last to first.     They should if the stack and args grow in opposite directions, but    only if we have push insns.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STACK_GROWS_DOWNWARD
argument_list|)
operator|!=
name|defined
argument_list|(
name|ARGS_GROW_DOWNWARD
argument_list|)
end_if

begin_define
define|#
directive|define
name|PUSH_ARGS_REVERSED
end_define

begin_comment
comment|/* If it's last to first */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_PUSH_CODE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_DEC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_INC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Assume that case vectors are not pc-relative.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CASE_VECTOR_PC_RELATIVE
end_ifndef

begin_define
define|#
directive|define
name|CASE_VECTOR_PC_RELATIVE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If this is nonzero, we do not bother generating VOLATILE    around volatile memory references, and we are willing to    output indirect addresses.  If cse is to follow, we reject    indirect addresses so a useful potential cse is generated;    if it is used only once, instruction combination will produce    the same indirect address eventually.  */
end_comment

begin_decl_stmt
name|int
name|cse_not_expected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to generate code for all the subroutines within an    expression before generating the upper levels of the expression.    Nowadays this is never zero.  */
end_comment

begin_decl_stmt
name|int
name|do_preexpand_calls
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of units that we should eventually pop off the stack.    These are the arguments to function calls that have already returned.  */
end_comment

begin_decl_stmt
name|int
name|pending_stack_adjust
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Under some ABIs, it is the caller's responsibility to pop arguments    pushed for function calls.  A naive implementation would simply pop    the arguments immediately after each call.  However, if several    function calls are made in a row, it is typically cheaper to pop    all the arguments after all of the calls are complete since a    single pop instruction can be used.  Therefore, GCC attempts to    defer popping the arguments until absolutely necessary.  (For    example, at the end of a conditional, the arguments must be popped,    since code outside the conditional won't know whether or not the    arguments need to be popped.)     When INHIBIT_DEFER_POP is non-zero, however, the compiler does not    attempt to defer pops.  Instead, the stack is popped immediately    after each call.  Rather then setting this variable directly, use    NO_DEFER_POP and OK_DEFER_POP.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_defer_pop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means __builtin_saveregs has already been done in this function.    The value is the pseudoreg containing the value __builtin_saveregs    returned.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|saveregs_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similarly for __builtin_apply_args.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|apply_args_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't check memory usage, since code is being emitted to check a memory    usage.  Used when current_function_check_memory_usage is true, to avoid    infinite recursion.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_check_memory_usage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Postincrements that still need to be expanded.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used by move_by_pieces to describe the move to    be performed.  */
end_comment

begin_struct
struct|struct
name|move_by_pieces
block|{
name|rtx
name|to
decl_stmt|;
name|rtx
name|to_addr
decl_stmt|;
name|int
name|autinc_to
decl_stmt|;
name|int
name|explicit_inc_to
decl_stmt|;
name|int
name|to_struct
decl_stmt|;
name|rtx
name|from
decl_stmt|;
name|rtx
name|from_addr
decl_stmt|;
name|int
name|autinc_from
decl_stmt|;
name|int
name|explicit_inc_from
decl_stmt|;
name|int
name|from_struct
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|reverse
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used by clear_by_pieces to describe the clear to    be performed.  */
end_comment

begin_struct
struct|struct
name|clear_by_pieces
block|{
name|rtx
name|to
decl_stmt|;
name|rtx
name|to_addr
decl_stmt|;
name|int
name|autinc_to
decl_stmt|;
name|int
name|explicit_inc_to
decl_stmt|;
name|int
name|to_struct
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|reverse
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
name|arg_pointer_save_area
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|get_push_address
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|enqueue_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_queue
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|move_by_pieces_ninsns
name|PROTO
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move_by_pieces_1
name|PROTO
argument_list|(
operator|(
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
operator|...
argument_list|)
operator|,
expr|enum
name|machine_mode
operator|,
expr|struct
name|move_by_pieces
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_by_pieces
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_by_pieces_1
name|PROTO
argument_list|(
operator|(
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
operator|...
argument_list|)
operator|,
expr|enum
name|machine_mode
operator|,
expr|struct
name|clear_by_pieces
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_zeros_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mostly_zeros_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_constructor_field
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_constructor
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|store_field
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|memory_use_mode
name|get_memory_usage_from_modifier
name|PROTO
argument_list|(
operator|(
expr|enum
name|expand_modifier
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|save_noncopied_parts
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|init_noncopied_parts
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|safe_from_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fixed_type_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|var_rtx
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_pointer_alignment
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|string_constant
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|c_strlen
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|get_memory_rtx
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|apply_args_size
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|apply_result_size
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|result_vector
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_setjmp
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_apply_args
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_builtin_apply
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_builtin_return
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_increment
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|preexpand_calls
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_by_parts_greater
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_by_parts_equality
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_jump_for_compare
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|compare
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|rtx_code
operator|,
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|do_store_flag
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record for each mode whether we can move a register directly to or    from an object of that mode in memory.  If we can't, we won't try    to use that mode directly when accessing a field of that mode.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|direct_load
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|direct_store
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If a memory-to-memory move would take MOVE_RATIO or more simple    move-instruction sequences, we will do a movstr or libcall instead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MOVE_RATIO
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_movstrqi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrhi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrsi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrdi
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_movstrti
argument_list|)
end_if

begin_define
define|#
directive|define
name|MOVE_RATIO
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* If we are optimizing for space (-Os), cut down the default move ratio */
end_comment

begin_define
define|#
directive|define
name|MOVE_RATIO
value|(optimize_size ? 3 : 15)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This macro is used to determine whether move_by_pieces should be called    to perform a structure copy. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MOVE_BY_PIECES_P
end_ifndef

begin_define
define|#
directive|define
name|MOVE_BY_PIECES_P
parameter_list|(
name|SIZE
parameter_list|,
name|ALIGN
parameter_list|)
value|(move_by_pieces_ninsns        \                                        (SIZE, ALIGN)< MOVE_RATIO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array records the insn_code of insns to perform block moves.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|movstr_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array records the insn_code of insns to perform block clears.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|clrstr_optab
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SLOW_UNALIGNED_ACCESS is non-zero if unaligned accesses are very slow.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SLOW_UNALIGNED_ACCESS
end_ifndef

begin_define
define|#
directive|define
name|SLOW_UNALIGNED_ACCESS
value|STRICT_ALIGNMENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Register mappings for target machines without register windows.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INCOMING_REGNO
end_ifndef

begin_define
define|#
directive|define
name|INCOMING_REGNO
parameter_list|(
name|OUT
parameter_list|)
value|(OUT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OUTGOING_REGNO
end_ifndef

begin_define
define|#
directive|define
name|OUTGOING_REGNO
parameter_list|(
name|IN
parameter_list|)
value|(IN)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This is run once per compilation to set up which modes can be used    directly in memory and to initialize the block move optab.  */
end_comment

begin_function
name|void
name|init_expr_once
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|num_clobbers
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|mem1
decl_stmt|;
name|char
modifier|*
name|free_point
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Since we are on the permanent obstack, we must be sure we save this      spot AFTER we call start_sequence, since it will reuse the rtl it      makes.  */
name|free_point
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Try indexing by frame ptr and try by stack ptr.      It is known that on the Convex the stack ptr isn't a valid index.      With luck, one or the other is valid on any machine.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|mem1
operator|=
name|gen_rtx_MEM
argument_list|(
name|VOIDmode
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|mode
operator|<
name|NUM_MACHINE_MODES
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|0
expr_stmt|;
name|PUT_MODE
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|mem1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* See if there is some register that can be used in this mode and 	 directly loaded or stored from memory.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|==
literal|0
operator|||
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|==
literal|0
operator|)
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
continue|continue;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|mem
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|mem1
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|mem
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|=
name|mem1
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|>=
literal|0
condition|)
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|end_sequence
argument_list|()
expr_stmt|;
name|obfree
argument_list|(
name|free_point
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is run at the start of compiling a function.  */
end_comment

begin_function
name|void
name|init_expr
parameter_list|()
block|{
name|init_queue
argument_list|()
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
name|inhibit_defer_pop
operator|=
literal|0
expr_stmt|;
name|saveregs_value
operator|=
literal|0
expr_stmt|;
name|apply_args_value
operator|=
literal|0
expr_stmt|;
name|forced_labels
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save all variables describing the current status into the structure *P.    This is used before starting a nested function.  */
end_comment

begin_function
name|void
name|save_expr_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|pending_chain
operator|=
name|pending_chain
expr_stmt|;
name|p
operator|->
name|pending_stack_adjust
operator|=
name|pending_stack_adjust
expr_stmt|;
name|p
operator|->
name|inhibit_defer_pop
operator|=
name|inhibit_defer_pop
expr_stmt|;
name|p
operator|->
name|saveregs_value
operator|=
name|saveregs_value
expr_stmt|;
name|p
operator|->
name|apply_args_value
operator|=
name|apply_args_value
expr_stmt|;
name|p
operator|->
name|forced_labels
operator|=
name|forced_labels
expr_stmt|;
name|pending_chain
operator|=
name|NULL_RTX
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
name|inhibit_defer_pop
operator|=
literal|0
expr_stmt|;
name|saveregs_value
operator|=
literal|0
expr_stmt|;
name|apply_args_value
operator|=
literal|0
expr_stmt|;
name|forced_labels
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore all variables describing the current status from the structure *P.    This is used after a nested function.  */
end_comment

begin_function
name|void
name|restore_expr_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|pending_chain
operator|=
name|p
operator|->
name|pending_chain
expr_stmt|;
name|pending_stack_adjust
operator|=
name|p
operator|->
name|pending_stack_adjust
expr_stmt|;
name|inhibit_defer_pop
operator|=
name|p
operator|->
name|inhibit_defer_pop
expr_stmt|;
name|saveregs_value
operator|=
name|p
operator|->
name|saveregs_value
expr_stmt|;
name|apply_args_value
operator|=
name|p
operator|->
name|apply_args_value
expr_stmt|;
name|forced_labels
operator|=
name|p
operator|->
name|forced_labels
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Manage the queue of increment instructions to be output    for POSTINCREMENT_EXPR expressions, etc.  */
end_comment

begin_comment
comment|/* Queue up to increment (or change) VAR later.  BODY says how:    BODY should be the same thing you would pass to emit_insn    to increment right away.  It will go to emit_insn later on.     The value is a QUEUED expression to be used in place of VAR    where you want to guarantee the pre-incrementation value of VAR.  */
end_comment

begin_function
specifier|static
name|rtx
name|enqueue_insn
parameter_list|(
name|var
parameter_list|,
name|body
parameter_list|)
name|rtx
name|var
decl_stmt|,
name|body
decl_stmt|;
block|{
name|pending_chain
operator|=
name|gen_rtx_QUEUED
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|var
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|body
argument_list|,
name|pending_chain
argument_list|)
expr_stmt|;
return|return
name|pending_chain
return|;
block|}
end_function

begin_comment
comment|/* Use protect_from_queue to convert a QUEUED expression    into something that you can put immediately into an instruction.    If the queued incrementation has not happened yet,    protect_from_queue returns the variable itself.    If the incrementation has happened, protect_from_queue returns a temp    that contains a copy of the old value of the variable.     Any time an rtx which might possibly be a QUEUED is to be put    into an instruction, it must be passed through protect_from_queue first.    QUEUED expressions are not meaningful in instructions.     Do not pass a value through protect_from_queue and then hold    on to it for a while before putting it in an instruction!    If the queue is flushed in between, incorrect code will result.  */
end_comment

begin_function
name|rtx
name|protect_from_queue
parameter_list|(
name|x
parameter_list|,
name|modify
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* A QUEUED can hang around after the queue is forced out.  */
comment|/* Shortcut for most common case.  */
block|if (pending_chain == 0)     return x;
endif|#
directive|endif
if|if
condition|(
name|code
operator|!=
name|QUEUED
condition|)
block|{
comment|/* A special hack for read access to (MEM (QUEUED ...)) to facilitate 	 use of autoincrement.  Make a copy of the contents of the memory 	 location rather than a copy of the address, but not if the value is 	 of mode BLKmode.  Don't modify X in place since it might be 	 shared.  */
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|QUEUED
operator|&&
operator|!
name|modify
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|new
init|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|QUEUED_VAR
argument_list|(
name|y
argument_list|)
argument_list|)
decl_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|new
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_ALIAS_SET
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|QUEUED_INSN
argument_list|(
name|y
argument_list|)
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
argument_list|,
name|QUEUED_INSN
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|new
return|;
block|}
comment|/* Otherwise, recursively protect the subexpressions of all 	 the kinds of rtx's that can contain a QUEUED.  */
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|rtx
name|tem
init|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|tem
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MULT
condition|)
block|{
name|rtx
name|new0
init|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|new1
init|=
name|protect_from_queue
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|new0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|new1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|new0
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|new1
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
comment|/* If the increment has not happened, use the variable itself.  */
if|if
condition|(
name|QUEUED_INSN
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
return|;
comment|/* If the increment has happened and a pre-increment copy exists,      use that copy.  */
if|if
condition|(
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
return|;
comment|/* The increment has happened but we haven't set up a pre-increment copy.      Set one up now, and use it.  */
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
argument_list|,
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|QUEUED_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QUEUED_COPY
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X contains a QUEUED expression:    if it contains anything that will be altered by a queued increment.    We handle only combinations of MEM, PLUS, MINUS and MULT operators    since memory addresses generally contain only those.  */
end_comment

begin_function
name|int
name|queued_subexp_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|QUEUED
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
operator|(
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|queued_subexp_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Perform all the pending incrementations.  */
end_comment

begin_function
name|void
name|emit_queue
parameter_list|()
block|{
specifier|register
name|rtx
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|pending_chain
operator|)
condition|)
block|{
name|rtx
name|body
init|=
name|QUEUED_BODY
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|QUEUED_INSN
argument_list|(
name|p
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|QUEUED_BODY
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|QUEUED_BODY
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|QUEUED_INSN
argument_list|(
name|p
argument_list|)
operator|=
name|emit_insn
argument_list|(
name|QUEUED_BODY
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|pending_chain
operator|=
name|QUEUED_NEXT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_queue
parameter_list|()
block|{
if|if
condition|(
name|pending_chain
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy data from FROM to TO, where the machine modes are not the same.    Both modes may be integer, or both may be floating.    UNSIGNEDP should be nonzero if FROM is an unsigned type.    This causes zero-extension instead of sign-extension.  */
end_comment

begin_function
name|void
name|convert_move
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|unsignedp
parameter_list|)
specifier|register
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|machine_mode
name|to_mode
init|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|from_mode
init|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|int
name|to_real
init|=
name|GET_MODE_CLASS
argument_list|(
name|to_mode
argument_list|)
operator|==
name|MODE_FLOAT
decl_stmt|;
name|int
name|from_real
init|=
name|GET_MODE_CLASS
argument_list|(
name|from_mode
argument_list|)
operator|==
name|MODE_FLOAT
decl_stmt|;
name|enum
name|insn_code
name|code
decl_stmt|;
name|rtx
name|libcall
decl_stmt|;
comment|/* rtx code for making an equivalent value.  */
name|enum
name|rtx_code
name|equiv_code
init|=
operator|(
name|unsignedp
condition|?
name|ZERO_EXTEND
else|:
name|SIGN_EXTEND
operator|)
decl_stmt|;
name|to
operator|=
name|protect_from_queue
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|protect_from_queue
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_real
operator|!=
name|from_real
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If FROM is a SUBREG that indicates that we have already done at least      the required extension, strip it.  We don't handle such SUBREGs as      TO here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
operator|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|from
argument_list|)
operator|==
name|unsignedp
condition|)
name|from
operator|=
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
operator|,
name|from_mode
operator|=
name|to_mode
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|to
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|to_mode
operator|==
name|from_mode
operator|||
operator|(
name|from_mode
operator|==
name|VOIDmode
operator|&&
name|CONSTANT_P
argument_list|(
name|from
argument_list|)
operator|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|to_real
condition|)
block|{
name|rtx
name|value
decl_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
condition|)
block|{
comment|/* Try converting directly if the insn is supported.  */
if|if
condition|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|from_mode
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_trunchfqf2
if|if
condition|(
name|HAVE_trunchfqf2
operator|&&
name|from_mode
operator|==
name|HFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunchfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctqfqf2
if|if
condition|(
name|HAVE_trunctqfqf2
operator|&&
name|from_mode
operator|==
name|TQFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctqfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncsfqf2
if|if
condition|(
name|HAVE_truncsfqf2
operator|&&
name|from_mode
operator|==
name|SFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdfqf2
if|if
condition|(
name|HAVE_truncdfqf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfqf2
if|if
condition|(
name|HAVE_truncxfqf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfqf2
if|if
condition|(
name|HAVE_trunctfqf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|QFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctqfhf2
if|if
condition|(
name|HAVE_trunctqfhf2
operator|&&
name|from_mode
operator|==
name|TQFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctqfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncsfhf2
if|if
condition|(
name|HAVE_truncsfhf2
operator|&&
name|from_mode
operator|==
name|SFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdfhf2
if|if
condition|(
name|HAVE_truncdfhf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfhf2
if|if
condition|(
name|HAVE_truncxfhf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfhf2
if|if
condition|(
name|HAVE_trunctfhf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|HFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfhf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncsftqf2
if|if
condition|(
name|HAVE_truncsftqf2
operator|&&
name|from_mode
operator|==
name|SFmode
operator|&&
name|to_mode
operator|==
name|TQFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsftqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdftqf2
if|if
condition|(
name|HAVE_truncdftqf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|TQFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdftqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxftqf2
if|if
condition|(
name|HAVE_truncxftqf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|TQFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxftqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctftqf2
if|if
condition|(
name|HAVE_trunctftqf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|TQFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctftqf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncdfsf2
if|if
condition|(
name|HAVE_truncdfsf2
operator|&&
name|from_mode
operator|==
name|DFmode
operator|&&
name|to_mode
operator|==
name|SFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfsf2
if|if
condition|(
name|HAVE_truncxfsf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|SFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfsf2
if|if
condition|(
name|HAVE_trunctfsf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|SFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfsf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_truncxfdf2
if|if
condition|(
name|HAVE_truncxfdf2
operator|&&
name|from_mode
operator|==
name|XFmode
operator|&&
name|to_mode
operator|==
name|DFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncxfdf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_trunctfdf2
if|if
condition|(
name|HAVE_trunctfdf2
operator|&&
name|from_mode
operator|==
name|TFmode
operator|&&
name|to_mode
operator|==
name|DFmode
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctfdf2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|libcall
operator|=
operator|(
name|rtx
operator|)
literal|0
expr_stmt|;
switch|switch
condition|(
name|from_mode
condition|)
block|{
case|case
name|SFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|DFmode
case|:
name|libcall
operator|=
name|extendsfdf2_libfunc
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|libcall
operator|=
name|extendsfxf2_libfunc
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
name|libcall
operator|=
name|extendsftf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|DFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|libcall
operator|=
name|truncdfsf2_libfunc
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|libcall
operator|=
name|extenddfxf2_libfunc
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
name|libcall
operator|=
name|extenddftf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|XFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|libcall
operator|=
name|truncxfsf2_libfunc
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|libcall
operator|=
name|truncxfdf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|TFmode
case|:
switch|switch
condition|(
name|to_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|libcall
operator|=
name|trunctfsf2_libfunc
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|libcall
operator|=
name|trunctfdf2_libfunc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|libcall
operator|==
operator|(
name|rtx
operator|)
literal|0
condition|)
comment|/* This conversion is not implemented yet.  */
name|abort
argument_list|()
expr_stmt|;
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|libcall
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|to_mode
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|from_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now both modes are integers.  */
comment|/* Handle expanding beyond a word.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|lowpart
decl_stmt|;
name|rtx
name|fill_value
decl_stmt|;
name|rtx
name|lowfrom
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|lowpart_mode
decl_stmt|;
name|int
name|nwords
init|=
name|CEIL
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
comment|/* Try converting directly if the insn is supported.  */
if|if
condition|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
comment|/* If FROM is a SUBREG, put it into a register.  Do this 	     so that we always generate the same set of insns for 	     better cse'ing; if an intermediate assignment occurred, 	     we won't be doing the operation directly on the SUBREG.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Next, try converting via full word.  */
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
operator|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|word_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REG
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|to
argument_list|)
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|to
argument_list|)
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* No special multiword conversion insn; do it by hand.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Since we will turn this into a no conflict block, we must ensure 	 that the source does not overlap the target.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
comment|/* Get a copy of FROM widened to a word, if necessary.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
name|lowpart_mode
operator|=
name|word_mode
expr_stmt|;
else|else
name|lowpart_mode
operator|=
name|from_mode
expr_stmt|;
name|lowfrom
operator|=
name|convert_to_mode
argument_list|(
name|lowpart_mode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|lowpart
operator|=
name|gen_lowpart
argument_list|(
name|lowpart_mode
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|lowpart
argument_list|,
name|lowfrom
argument_list|)
expr_stmt|;
comment|/* Compute the value to put in each remaining word.  */
if|if
condition|(
name|unsignedp
condition|)
name|fill_value
operator|=
name|const0_rtx
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_slt
if|if
condition|(
name|HAVE_slt
operator|&&
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_slt
index|]
index|[
literal|0
index|]
operator|==
name|word_mode
operator|&&
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
condition|)
block|{
name|emit_cmp_insn
argument_list|(
name|lowfrom
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|lowpart_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fill_value
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_slt
argument_list|(
name|fill_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|fill_value
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|lowpart_mode
argument_list|,
name|lowfrom
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|lowpart_mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fill_value
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|fill_value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fill the remaining words.  */
for|for
control|(
name|i
operator|=
name|GET_MODE_SIZE
argument_list|(
name|lowpart_mode
argument_list|)
operator|/
name|UNITS_PER_WORD
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|nwords
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
decl_stmt|;
name|rtx
name|subword
init|=
name|operand_subword
argument_list|(
name|to
argument_list|,
name|index
argument_list|,
literal|1
argument_list|,
name|to_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|subword
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fill_value
operator|!=
name|subword
condition|)
name|emit_move_insn
argument_list|(
name|subword
argument_list|,
name|fill_value
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|equiv_code
argument_list|,
name|to_mode
argument_list|,
name|copy_rtx
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Truncating multi-word to a word or less.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|>
name|BITS_PER_WORD
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<=
name|BITS_PER_WORD
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|from
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|to_mode
index|]
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|from
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle pointer conversion */
comment|/* SPEE 900220 */
if|if
condition|(
name|to_mode
operator|==
name|PQImode
condition|)
block|{
if|if
condition|(
name|from_mode
operator|!=
name|QImode
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|QImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_truncqipqi2
if|if
condition|(
name|HAVE_truncqipqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncqipqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_truncqipqi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|from_mode
operator|==
name|PQImode
condition|)
block|{
if|if
condition|(
name|to_mode
operator|!=
name|QImode
condition|)
block|{
name|from
operator|=
name|convert_to_mode
argument_list|(
name|QImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|from_mode
operator|=
name|QImode
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extendpqiqi2
if|if
condition|(
name|HAVE_extendpqiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendpqiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_extendpqiqi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|to_mode
operator|==
name|PSImode
condition|)
block|{
if|if
condition|(
name|from_mode
operator|!=
name|SImode
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_truncsipsi2
if|if
condition|(
name|HAVE_truncsipsi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsipsi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_truncsipsi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|from_mode
operator|==
name|PSImode
condition|)
block|{
if|if
condition|(
name|to_mode
operator|!=
name|SImode
condition|)
block|{
name|from
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|from_mode
operator|=
name|SImode
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extendpsisi2
if|if
condition|(
name|HAVE_extendpsisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendpsisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_extendpsisi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|to_mode
operator|==
name|PDImode
condition|)
block|{
if|if
condition|(
name|from_mode
operator|!=
name|DImode
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|DImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_truncdipdi2
if|if
condition|(
name|HAVE_truncdipdi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdipdi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_truncdipdi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|from_mode
operator|==
name|PDImode
condition|)
block|{
if|if
condition|(
name|to_mode
operator|!=
name|DImode
condition|)
block|{
name|from
operator|=
name|convert_to_mode
argument_list|(
name|DImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|from_mode
operator|=
name|DImode
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extendpdidi2
if|if
condition|(
name|HAVE_extendpdidi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_extendpdidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_extendpdidi2 */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now follow all the conversions between integers      no more than a word long.  */
comment|/* For truncation, usually we can just refer to FROM in a narrower mode.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|from
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|to_mode
index|]
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|from
operator|=
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|from
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|from
argument_list|)
argument_list|,
name|to_mode
argument_list|)
condition|)
name|from
operator|=
name|copy_to_reg
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle extension.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
condition|)
block|{
comment|/* Convert directly if that works.  */
if|if
condition|(
operator|(
name|code
operator|=
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|)
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|code
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|equiv_code
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|enum
name|machine_mode
name|intermediate
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|tree
name|shift_amount
decl_stmt|;
comment|/* Search for a mode to convert via.  */
for|for
control|(
name|intermediate
operator|=
name|from_mode
init|;
name|intermediate
operator|!=
name|VOIDmode
condition|;
name|intermediate
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|intermediate
argument_list|)
control|)
if|if
condition|(
operator|(
operator|(
name|can_extend_p
argument_list|(
name|to_mode
argument_list|,
name|intermediate
argument_list|,
name|unsignedp
argument_list|)
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|intermediate
argument_list|)
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|to_mode
argument_list|,
name|intermediate
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|can_extend_p
argument_list|(
name|intermediate
argument_list|,
name|from_mode
argument_list|,
name|unsignedp
argument_list|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|convert_move
argument_list|(
name|to
argument_list|,
name|convert_to_mode
argument_list|(
name|intermediate
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* No suitable intermediate mode. 	     Generate what we need with	shifts. */
name|shift_amount
operator|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|from
operator|=
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|to_mode
argument_list|,
name|from
argument_list|,
name|shift_amount
argument_list|,
name|to
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|to_mode
argument_list|,
name|tmp
argument_list|,
name|shift_amount
argument_list|,
name|to
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|to
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Support special truncate insns for certain modes.  */
if|if
condition|(
name|from_mode
operator|==
name|DImode
operator|&&
name|to_mode
operator|==
name|SImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncdisi2
if|if
condition|(
name|HAVE_truncdisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|DImode
operator|&&
name|to_mode
operator|==
name|HImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncdihi2
if|if
condition|(
name|HAVE_truncdihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|DImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncdiqi2
if|if
condition|(
name|HAVE_truncdiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncdiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|SImode
operator|&&
name|to_mode
operator|==
name|HImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncsihi2
if|if
condition|(
name|HAVE_truncsihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|SImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_truncsiqi2
if|if
condition|(
name|HAVE_truncsiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_truncsiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|HImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunchiqi2
if|if
condition|(
name|HAVE_trunchiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunchiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|DImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctidi2
if|if
condition|(
name|HAVE_trunctidi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctidi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|SImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctisi2
if|if
condition|(
name|HAVE_trunctisi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctisi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|HImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctihi2
if|if
condition|(
name|HAVE_trunctihi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctihi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from_mode
operator|==
name|TImode
operator|&&
name|to_mode
operator|==
name|QImode
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_trunctiqi2
if|if
condition|(
name|HAVE_trunctiqi2
condition|)
block|{
name|emit_unop_insn
argument_list|(
name|CODE_FOR_trunctiqi2
argument_list|,
name|to
argument_list|,
name|from
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|convert_move
argument_list|(
name|to
argument_list|,
name|force_reg
argument_list|(
name|from_mode
argument_list|,
name|from
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle truncation of volatile memrefs, and so on;      the things that couldn't be truncated directly,      and for which there was no special instruction.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|from_mode
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|force_reg
argument_list|(
name|to_mode
argument_list|,
name|gen_lowpart
argument_list|(
name|to_mode
argument_list|,
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Mode combination is not recognized.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an rtx for a value that would result    from converting X to mode MODE.    Both X and MODE may be floating, or both integer.    UNSIGNEDP is nonzero if X is an unsigned value.    This can be done by referring to a part of X in place    or by copying to a new temporary with conversion.     This function *must not* call protect_from_queue    except when putting X into an insn (in which case convert_move does it).  */
end_comment

begin_function
name|rtx
name|convert_to_mode
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
return|return
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx for a value that would result    from converting X from mode OLDMODE to mode MODE.    Both modes may be floating, or both integer.    UNSIGNEDP is nonzero if X is an unsigned value.     This can be done by referring to a part of X in place    or by copying to a new temporary with conversion.     You can give VOIDmode for OLDMODE, if you are sure X has a nonvoid mode.     This function *must not* call protect_from_queue    except when putting X into an insn (in which case convert_move does it).  */
end_comment

begin_function
name|rtx
name|convert_modes
parameter_list|(
name|mode
parameter_list|,
name|oldmode
parameter_list|,
name|x
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|oldmode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
comment|/* If FROM is a SUBREG that indicates that we have already done at least      the required extension, strip it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|x
argument_list|)
operator|==
name|unsignedp
condition|)
name|x
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|oldmode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|oldmode
condition|)
return|return
name|x
return|;
comment|/* There is one case that we must handle specially: If we are converting      a CONST_INT into a mode whose size is twice HOST_BITS_PER_WIDE_INT and      we are to interpret the constant as unsigned, gen_lowpart will do      the wrong if the constant appears negative.  What we want to do is      make the high-order word of the constant zero, not all ones.  */
if|if
condition|(
name|unsignedp
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldmode
operator|!=
name|VOIDmode
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|oldmode
argument_list|)
condition|)
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|oldmode
argument_list|)
decl_stmt|;
comment|/* We need to zero extend VAL.  */
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|val
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* We can do this with a gen_lowpart if both desired and current modes      are integer, and this is either a constant integer, a register, or a      non-volatile MEM.  Except for the constant case where MODE is no      wider than HOST_BITS_PER_WIDE_INT, we must be narrowing the operand.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|oldmode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|oldmode
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* ?? If we don't know OLDMODE, we have to assume here that 	 X does not need sign- or zero-extension.   This may not be 	 the case, but it's the best we can do.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|oldmode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|oldmode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|oldmode
argument_list|)
decl_stmt|;
comment|/* We must sign or zero-extend in this case.  Start by 	     zero-extending, then sign extend if we need to.  */
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|unsignedp
operator|&&
operator|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|val
operator||=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This macro is used to determine what the largest unit size that    move_by_pieces can use is. */
end_comment

begin_comment
comment|/* MOVE_MAX_PIECES is the number of bytes at a time which we can    move efficiently, as opposed to  MOVE_MAX which is the maximum    number of bhytes we can move with a single instruction. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MOVE_MAX_PIECES
end_ifndef

begin_define
define|#
directive|define
name|MOVE_MAX_PIECES
value|MOVE_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate several move instructions to copy LEN bytes    from block FROM to block TO.  (These are MEM rtx's with BLKmode).    The caller must pass FROM and TO     through protect_from_queue before calling.    ALIGN (in bytes) is maximum alignment we can assume.  */
end_comment

begin_function
name|void
name|move_by_pieces
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|len
parameter_list|,
name|align
parameter_list|)
name|rtx
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|len
decl_stmt|,
name|align
decl_stmt|;
block|{
name|struct
name|move_by_pieces
name|data
decl_stmt|;
name|rtx
name|to_addr
init|=
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|from_addr
init|=
name|XEXP
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|max_size
init|=
name|MOVE_MAX_PIECES
operator|+
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|data
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|to_addr
operator|=
name|to_addr
expr_stmt|;
name|data
operator|.
name|from_addr
operator|=
name|from_addr
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|data
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
operator|(
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|from_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|reverse
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|reverse
condition|)
name|data
operator|.
name|offset
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|to_struct
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|data
operator|.
name|from_struct
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* If copying requires more than two move insns,      copy addresses to registers (to make displacements shorter)      and use post-increment if available.  */
if|if
condition|(
operator|!
operator|(
name|data
operator|.
name|autinc_from
operator|&&
name|data
operator|.
name|autinc_to
operator|)
operator|&&
name|move_by_pieces_ninsns
argument_list|(
name|len
argument_list|,
name|align
argument_list|)
operator|>
literal|2
condition|)
block|{
comment|/* Find the mode of the largest move... */
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|USE_LOAD_PRE_DECREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_from
condition|)
block|{
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|from_addr
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|USE_LOAD_POST_INCREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|data
operator|.
name|autinc_from
condition|)
block|{
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_from
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_from
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_from
operator|&&
name|CONSTANT_P
argument_list|(
name|from_addr
argument_list|)
condition|)
name|data
operator|.
name|from_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|USE_STORE_PRE_DECREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|to_addr
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|USE_STORE_POST_INCREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_to
operator|&&
name|CONSTANT_P
argument_list|(
name|to_addr
argument_list|)
condition|)
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SLOW_UNALIGNED_ACCESS
operator|||
name|align
operator|>
name|MOVE_MAX
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|MOVE_MAX
expr_stmt|;
comment|/* First move what we can in the largest integer mode, then go to      successively smaller modes.  */
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
condition|)
name|move_by_pieces_1
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|,
name|mode
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The code above should have handled everything.  */
if|if
condition|(
name|data
operator|.
name|len
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return number of insns required to move L bytes by pieces.    ALIGN (in bytes) is maximum alignment we can assume.  */
end_comment

begin_function
specifier|static
name|int
name|move_by_pieces_ninsns
parameter_list|(
name|l
parameter_list|,
name|align
parameter_list|)
name|unsigned
name|int
name|l
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
specifier|register
name|int
name|n_insns
init|=
literal|0
decl_stmt|;
name|int
name|max_size
init|=
name|MOVE_MAX
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|SLOW_UNALIGNED_ACCESS
operator|||
name|align
operator|>
name|MOVE_MAX
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|MOVE_MAX
expr_stmt|;
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
condition|)
name|n_insns
operator|+=
name|l
operator|/
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|,
name|l
operator|%=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|n_insns
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of move_by_pieces.  Move as many bytes as appropriate    with move instructions for mode MODE.  GENFUN is the gen_... function    to make a move insn for that mode.  DATA has all the other info.  */
end_comment

begin_function_decl
specifier|static
name|void
name|move_by_pieces_1
parameter_list|(
name|genfun
parameter_list|,
name|mode
parameter_list|,
name|data
parameter_list|)
function_decl|rtx
parameter_list|(
function_decl|*genfun
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|move_by_pieces
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|to1
decl_stmt|,
name|from1
decl_stmt|;
while|while
condition|(
name|data
operator|->
name|len
operator|>=
name|size
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|-=
name|size
expr_stmt|;
name|to1
operator|=
operator|(
name|data
operator|->
name|autinc_to
condition|?
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|data
operator|->
name|to_addr
argument_list|)
else|:
name|copy_rtx
argument_list|(
name|change_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|to1
argument_list|)
operator|=
name|data
operator|->
name|to_struct
expr_stmt|;
name|from1
operator|=
operator|(
name|data
operator|->
name|autinc_from
condition|?
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|data
operator|->
name|from_addr
argument_list|)
else|:
name|copy_rtx
argument_list|(
name|change_address
argument_list|(
name|data
operator|->
name|from
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|from1
argument_list|)
operator|=
name|data
operator|->
name|from_struct
expr_stmt|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|data
operator|->
name|explicit_inc_from
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|genfun
call|)
argument_list|(
name|to1
argument_list|,
name|from1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|data
operator|->
name|explicit_inc_from
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|from_addr
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
name|data
operator|->
name|len
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Emit code to move a block Y to a block X.    This may be done with string-move instructions,    with multiple scalar move instructions, or with a library call.     Both X and Y must be MEM rtx's (perhaps inside VOLATILE)    with mode BLKmode.    SIZE is an rtx that says how long they are.    ALIGN is the maximum alignment we can assume they have,    measured in bytes.      Return the address of the new block, if memcpy is called and returns it,    0 otherwise.  */
end_comment

begin_function
name|rtx
name|emit_block_move
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|rtx
name|retval
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
specifier|static
name|tree
name|fn
decl_stmt|;
name|tree
name|call_expr
decl_stmt|,
name|arg_list
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|!=
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
name|protect_from_queue
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|MOVE_BY_PIECES_P
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
condition|)
name|move_by_pieces
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Try the most limited insn first, because there's no point 	 including more than one in the machine description unless 	 the more limited one has some advantage.  */
name|rtx
name|opalign
init|=
name|GEN_INT
argument_list|(
name|align
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|enum
name|insn_code
name|code
init|=
name|movstr_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
comment|/* We don't need MODE to be narrower than BITS_PER_HOST_WIDE_INT 		 here because if SIZE is less than the mode mask, as it is 		 returned by the macro, it will definitely be less than the 		 actual mode mask.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|)
operator|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|BITS_PER_WORD
operator|)
operator|&&
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|0
index|]
operator|==
literal|0
operator|||
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|x
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|&&
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|||
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|y
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|&&
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|3
index|]
operator|==
literal|0
operator|||
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|3
index|]
call|)
argument_list|(
name|opalign
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|op2
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|op2
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|2
index|]
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op2
argument_list|,
name|mode
argument_list|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
operator|(
name|int
operator|)
name|code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|op2
argument_list|,
name|opalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* X, Y, or SIZE may have been passed through protect_from_queue.  	 It is unsafe to save the value generated by protect_from_queue 	 and reuse it later.  Consider what happens if emit_queue is 	 called before the return value from protect_from_queue is used.  	 Expansion of the CALL_EXPR below will call emit_queue before 	 we are finished emitting RTL for argument setup.  So if we are 	 not careful we could get the wrong value for an argument.  	 To avoid this problem we go ahead and emit code to copy X, Y& 	 SIZE into new pseudos.  We can then place those new pseudos 	 into an RTL_EXPR and use them later, even after a call to 	 emit_queue.   	 Note this is not strictly needed for library calls since they 	 do not call emit_queue before loading their arguments.  However, 	 we may need to have library calls call emit_queue in the future 	 since failing to do so could cause problems for targets which 	 define SMALL_REGISTER_CLASSES and pass arguments in registers.  */
name|x
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
name|size
operator|=
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
comment|/* It is incorrect to use the libcall calling conventions to call 	 memcpy in this context.  	 This could be a user call to memcpy and the user may wish to 	 examine the return value from memcpy.  	 For targets where libcalls and normal calls have different conventions 	 for returning pointers, we could end up generating incorrect code.   	 So instead of using a libcall sequence we build up a suitable 	 CALL_EXPR and expand the call in the normal fashion.  */
if|if
condition|(
name|fn
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|fntype
decl_stmt|;
comment|/* This was copied from except.c, I don't know if all this is 	     necessary in this context or not.  */
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"memcpy"
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|fntype
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_function_type
argument_list|(
name|fntype
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|fntype
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|fn
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* We need to make an argument list for the function call.   	 memcpy has three arguments, the first two are void * addresses and 	 the last is a size_t byte count for the copy.  */
name|arg_list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now we have to build up the CALL_EXPR itself.  */
name|call_expr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|call_expr
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|call_expr
argument_list|,
name|arg_list
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|call_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|expand_expr
argument_list|(
name|call_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bcopy_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|y
argument_list|,
name|Pmode
argument_list|,
name|x
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy all or part of a value X into registers starting at REGNO.    The number of registers to be filled is NREGS.  */
end_comment

begin_function
name|void
name|move_block_to_reg
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|,
name|nregs
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_load_multiple
name|rtx
name|pat
decl_stmt|;
name|rtx
name|last
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if the machine can do this with a load multiple insn.  */
ifdef|#
directive|ifdef
name|HAVE_load_multiple
if|if
condition|(
name|HAVE_load_multiple
condition|)
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pat
operator|=
name|gen_load_multiple
argument_list|(
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|nregs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|operand_subword_force
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy all or part of a BLKmode value X out of registers starting at REGNO.    The number of registers to be filled is NREGS.  SIZE indicates the number    of bytes in the object X.  */
end_comment

begin_function
name|void
name|move_block_from_reg
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|,
name|nregs
parameter_list|,
name|size
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_store_multiple
name|rtx
name|pat
decl_stmt|;
name|rtx
name|last
decl_stmt|;
endif|#
directive|endif
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* If SIZE is that of a mode no bigger than a word, just use that      mode's store operation.  */
if|if
condition|(
name|size
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|mode
operator|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|BLKmode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Blocks smaller than a word on a BYTES_BIG_ENDIAN machine must be aligned      to the left before storing to memory.  Note that the previous test      doesn't handle all cases (e.g. SIZE == 3).  */
if|if
condition|(
name|size
operator|<
name|UNITS_PER_WORD
operator|&&
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|rtx
name|tem
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BLKmode
argument_list|)
decl_stmt|;
name|rtx
name|shift
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|shift
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
operator|(
name|UNITS_PER_WORD
operator|-
name|size
operator|)
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|shift
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* See if the machine can do this with a store multiple insn.  */
ifdef|#
directive|ifdef
name|HAVE_store_multiple
if|if
condition|(
name|HAVE_store_multiple
condition|)
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pat
operator|=
name|gen_store_multiple
argument_list|(
name|x
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|nregs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|BLKmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to move a block SRC to a block DST, where DST is non-consecutive    registers represented by a PARALLEL.  SSIZE represents the total size of    block SRC in bytes, or -1 if not known.  ALIGN is the known alignment of    SRC in bits.  */
end_comment

begin_comment
comment|/* ??? If SSIZE % UNITS_PER_WORD != 0, we make the blatent assumption that    the balance will be in what would be the low-order memory addresses, i.e.    left justified for big endian, right justified for little endian.  This    happens to be true for the targets currently using this support.  If this    ever changes, a new target macro along the lines of FUNCTION_ARG_PADDING    would be needed.  */
end_comment

begin_function
name|void
name|emit_group_load
parameter_list|(
name|dst
parameter_list|,
name|orig_src
parameter_list|,
name|ssize
parameter_list|,
name|align
parameter_list|)
name|rtx
name|dst
decl_stmt|,
name|orig_src
decl_stmt|;
name|int
name|align
decl_stmt|,
name|ssize
decl_stmt|;
block|{
name|rtx
modifier|*
name|tmps
decl_stmt|,
name|src
decl_stmt|;
name|int
name|start
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check for a NULL entry, used to indicate that the parameter goes      both on the stack and in registers.  */
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
name|start
operator|=
literal|1
expr_stmt|;
name|tmps
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we won't be loading directly from memory, protect the real source      from strange tricks we might play.  */
name|src
operator|=
name|orig_src
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MEM
condition|)
block|{
name|src
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|src
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
block|}
comment|/* Process the pieces.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|bytepos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|bytelen
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
comment|/* Handle trailing fragments that run over the size of the struct.  */
if|if
condition|(
name|ssize
operator|>=
literal|0
operator|&&
name|bytepos
operator|+
name|bytelen
operator|>
name|ssize
condition|)
block|{
name|shift
operator|=
operator|(
name|bytelen
operator|-
operator|(
name|ssize
operator|-
name|bytepos
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|bytelen
operator|=
name|ssize
operator|-
name|bytepos
expr_stmt|;
if|if
condition|(
name|bytelen
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Optimize the access just a bit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|align
operator|*
name|BITS_PER_UNIT
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|bytepos
operator|*
name|BITS_PER_UNIT
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|==
literal|0
operator|&&
name|bytelen
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|,
name|change_address
argument_list|(
name|src
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bytepos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmps
index|[
name|i
index|]
operator|=
name|extract_bit_field
argument_list|(
name|src
argument_list|,
name|bytelen
operator|*
name|BITS_PER_UNIT
argument_list|,
name|bytepos
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|,
name|align
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|shift
condition|)
block|{
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashl_optab
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|shift
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Copy the extracted pieces into the proper (probable) hard regs.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to move a block SRC to a block DST, where SRC is non-consecutive    registers represented by a PARALLEL.  SSIZE represents the total size of    block DST, or -1 if not known.  ALIGN is the known alignment of DST.  */
end_comment

begin_function
name|void
name|emit_group_store
parameter_list|(
name|orig_dst
parameter_list|,
name|src
parameter_list|,
name|ssize
parameter_list|,
name|align
parameter_list|)
name|rtx
name|orig_dst
decl_stmt|,
name|src
decl_stmt|;
name|int
name|ssize
decl_stmt|,
name|align
decl_stmt|;
block|{
name|rtx
modifier|*
name|tmps
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|start
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check for a NULL entry, used to indicate that the parameter goes      both on the stack and in registers.  */
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
name|start
operator|=
literal|1
expr_stmt|;
name|tmps
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the (probable) hard regs into pseudos.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* If we won't be storing directly into memory, protect the real destination      from strange tricks we might play.  */
name|dst
operator|=
name|orig_dst
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* We can get a PARALLEL dst if there is a conditional expression in 	 a return statement.  In that case, the dst and src are the same, 	 so no action is necessary.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
condition|)
return|return;
comment|/* It is unclear if we can ever reach here, but we may as well handle 	 it.  Allocate a temporary, and split this into a store/load to/from 	 the temporary.  */
name|temp
operator|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|ssize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_group_store
argument_list|(
name|temp
argument_list|,
name|src
argument_list|,
name|ssize
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|emit_group_load
argument_list|(
name|dst
argument_list|,
name|temp
argument_list|,
name|ssize
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|MEM
condition|)
block|{
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|orig_dst
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make life a bit easier for combine.  */
name|emit_move_insn
argument_list|(
name|dst
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|dst
argument_list|)
condition|)
block|{
comment|/* store_bit_field requires that memory operations have 	 mem_in_struct_p set; we might not.  */
name|dst
operator|=
name|copy_rtx
argument_list|(
name|orig_dst
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Process the pieces.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bytepos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|tmps
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|bytelen
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* Handle trailing fragments that run over the size of the struct.  */
if|if
condition|(
name|ssize
operator|>=
literal|0
operator|&&
name|bytepos
operator|+
name|bytelen
operator|>
name|ssize
condition|)
block|{
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|int
name|shift
init|=
operator|(
name|bytelen
operator|-
operator|(
name|ssize
operator|-
name|bytepos
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashr_optab
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|shift
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
name|bytelen
operator|=
name|ssize
operator|-
name|bytepos
expr_stmt|;
block|}
comment|/* Optimize the access just a bit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
operator|&&
name|align
operator|*
name|BITS_PER_UNIT
operator|>=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|bytepos
operator|*
name|BITS_PER_UNIT
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|==
literal|0
operator|&&
name|bytelen
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|dst
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bytepos
argument_list|)
argument_list|)
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|store_bit_field
argument_list|(
name|dst
argument_list|,
name|bytelen
operator|*
name|BITS_PER_UNIT
argument_list|,
name|bytepos
operator|*
name|BITS_PER_UNIT
argument_list|,
name|mode
argument_list|,
name|tmps
index|[
name|i
index|]
argument_list|,
name|align
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Copy from the pseudo into the (probable) hard reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|REG
condition|)
name|emit_move_insn
argument_list|(
name|orig_dst
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to copy a BLKmode object of TYPE out of a    set of registers starting with SRCREG into TGTBLK.  If TGTBLK    is null, a stack temporary is created.  TGTBLK is returned.     The primary purpose of this routine is to handle functions    that return BLKmode structures in registers.  Some machines    (the PA for example) want to return all small structures    in registers regardless of the structure's alignment.   */
end_comment

begin_function
name|rtx
name|copy_blkmode_from_reg
parameter_list|(
name|tgtblk
parameter_list|,
name|srcreg
parameter_list|,
name|type
parameter_list|)
name|rtx
name|tgtblk
decl_stmt|;
name|rtx
name|srcreg
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|NULL
decl_stmt|,
name|dst
init|=
name|NULL
decl_stmt|;
name|int
name|bitsize
init|=
name|MIN
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|xbitpos
decl_stmt|,
name|big_endian_correction
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tgtblk
operator|==
literal|0
condition|)
block|{
name|tgtblk
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|tgtblk
argument_list|,
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|tgtblk
argument_list|)
expr_stmt|;
block|}
comment|/* This code assumes srcreg is at least a full word.  If it isn't, 	 copy it into a new pseudo which is a full word.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|srcreg
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|srcreg
argument_list|)
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
name|srcreg
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|srcreg
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Structures whose size is not a multiple of a word are aligned 	 to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN 	 machine, this means we must skip the empty high order bytes when 	 calculating the bit offset.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|bytes
operator|%
name|UNITS_PER_WORD
condition|)
name|big_endian_correction
operator|=
operator|(
name|BITS_PER_WORD
operator|-
operator|(
operator|(
name|bytes
operator|%
name|UNITS_PER_WORD
operator|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* Copy the structure BITSIZE bites at a time.  	 We could probably emit more efficient code for machines 	 which do not use strict alignment, but it doesn't seem 	 worth the effort at the current time.  */
for|for
control|(
name|bitpos
operator|=
literal|0
operator|,
name|xbitpos
operator|=
name|big_endian_correction
init|;
name|bitpos
operator|<
name|bytes
operator|*
name|BITS_PER_UNIT
condition|;
name|bitpos
operator|+=
name|bitsize
operator|,
name|xbitpos
operator|+=
name|bitsize
control|)
block|{
comment|/* We need a new source operand each time xbitpos is on a  	     word boundary and when xbitpos == big_endian_correction 	     (the first time through).  */
if|if
condition|(
name|xbitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|||
name|xbitpos
operator|==
name|big_endian_correction
condition|)
name|src
operator|=
name|operand_subword_force
argument_list|(
name|srcreg
argument_list|,
name|xbitpos
operator|/
name|BITS_PER_WORD
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
comment|/* We need a new destination operand each time bitpos is on 	     a word boundary.  */
if|if
condition|(
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
condition|)
name|dst
operator|=
name|operand_subword
argument_list|(
name|tgtblk
argument_list|,
name|bitpos
operator|/
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
comment|/* Use xbitpos for the source extraction (right justified) and 	     xbitpos for the destination store (left justified).  */
name|store_bit_field
argument_list|(
name|dst
argument_list|,
name|bitsize
argument_list|,
name|bitpos
operator|%
name|BITS_PER_WORD
argument_list|,
name|word_mode
argument_list|,
name|extract_bit_field
argument_list|(
name|src
argument_list|,
name|bitsize
argument_list|,
name|xbitpos
operator|%
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
return|return
name|tgtblk
return|;
block|}
end_function

begin_comment
comment|/* Add a USE expression for REG to the (possibly empty) list pointed    to by CALL_FUSAGE.  REG must denote a hard register.  */
end_comment

begin_function
name|void
name|use_reg
parameter_list|(
name|call_fusage
parameter_list|,
name|reg
parameter_list|)
name|rtx
modifier|*
name|call_fusage
decl_stmt|,
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|call_fusage
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|,
operator|*
name|call_fusage
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add USE expressions to *CALL_FUSAGE for each of NREGS consecutive regs,    starting at REGNO.  All of these registers must be hard registers.  */
end_comment

begin_function
name|void
name|use_regs
parameter_list|(
name|call_fusage
parameter_list|,
name|regno
parameter_list|,
name|nregs
parameter_list|)
name|rtx
modifier|*
name|call_fusage
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regno
operator|+
name|nregs
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add USE expressions to *CALL_FUSAGE for each REG contained in the    PARALLEL REGS.  This is for calls that pass values in multiple    non-contiguous locations.  The Irix 6 ABI has examples of this.  */
end_comment

begin_function
name|void
name|use_group_regs
parameter_list|(
name|call_fusage
parameter_list|,
name|regs
parameter_list|)
name|rtx
modifier|*
name|call_fusage
decl_stmt|;
name|rtx
name|regs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* A NULL entry means the parameter goes both on the stack and in 	 registers.  This can also be a MEM for targets that pass values 	 partially on the stack and partially in registers.  */
if|if
condition|(
name|reg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate several move instructions to clear LEN bytes of block TO.    (A MEM rtx with BLKmode).   The caller must pass TO through    protect_from_queue before calling. ALIGN (in bytes) is maximum alignment    we can assume.  */
end_comment

begin_function
specifier|static
name|void
name|clear_by_pieces
parameter_list|(
name|to
parameter_list|,
name|len
parameter_list|,
name|align
parameter_list|)
name|rtx
name|to
decl_stmt|;
name|int
name|len
decl_stmt|,
name|align
decl_stmt|;
block|{
name|struct
name|clear_by_pieces
name|data
decl_stmt|;
name|rtx
name|to_addr
init|=
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|max_size
init|=
name|MOVE_MAX_PIECES
operator|+
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|data
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|to_addr
operator|=
name|to_addr
expr_stmt|;
name|data
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|reverse
operator|=
operator|(
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|to_addr
argument_list|)
operator|==
name|POST_DEC
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|reverse
condition|)
name|data
operator|.
name|offset
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|data
operator|.
name|to_struct
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* If copying requires more than two move insns,      copy addresses to registers (to make displacements shorter)      and use post-increment if available.  */
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_to
operator|&&
name|move_by_pieces_ninsns
argument_list|(
name|len
argument_list|,
name|align
argument_list|)
operator|>
literal|2
condition|)
block|{
comment|/* Determine the main mode we'll be using */
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|USE_STORE_PRE_DECREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|to_addr
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|USE_STORE_POST_INCREMENT
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|data
operator|.
name|reverse
operator|&&
operator|!
name|data
operator|.
name|autinc_to
condition|)
block|{
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
name|data
operator|.
name|autinc_to
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|explicit_inc_to
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
operator|.
name|autinc_to
operator|&&
name|CONSTANT_P
argument_list|(
name|to_addr
argument_list|)
condition|)
name|data
operator|.
name|to_addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|to_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SLOW_UNALIGNED_ACCESS
operator|||
name|align
operator|>
name|MOVE_MAX
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|MOVE_MAX
expr_stmt|;
comment|/* First move what we can in the largest integer mode, then go to      successively smaller modes.  */
while|while
condition|(
name|max_size
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmode
argument_list|)
operator|<
name|max_size
condition|)
name|mode
operator|=
name|tmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
break|break;
name|icode
operator|=
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|align
operator|>=
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
condition|)
name|clear_by_pieces_1
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|,
name|mode
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The code above should have handled everything.  */
if|if
condition|(
name|data
operator|.
name|len
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of clear_by_pieces.  Clear as many bytes as appropriate    with move instructions for mode MODE.  GENFUN is the gen_... function    to make a move insn for that mode.  DATA has all the other info.  */
end_comment

begin_function_decl
specifier|static
name|void
name|clear_by_pieces_1
parameter_list|(
name|genfun
parameter_list|,
name|mode
parameter_list|,
name|data
parameter_list|)
function_decl|rtx
parameter_list|(
function_decl|*genfun
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|clear_by_pieces
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|to1
decl_stmt|;
while|while
condition|(
name|data
operator|->
name|len
operator|>=
name|size
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|-=
name|size
expr_stmt|;
name|to1
operator|=
operator|(
name|data
operator|->
name|autinc_to
condition|?
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|data
operator|->
name|to_addr
argument_list|)
else|:
name|copy_rtx
argument_list|(
name|change_address
argument_list|(
name|data
operator|->
name|to
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|data
operator|->
name|offset
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|to1
argument_list|)
operator|=
name|data
operator|->
name|to_struct
expr_stmt|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|genfun
call|)
argument_list|(
name|to1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|data
operator|->
name|explicit_inc_to
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|data
operator|->
name|to_addr
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|reverse
condition|)
name|data
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
name|data
operator|->
name|len
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Write zeros through the storage of OBJECT.    If OBJECT has BLKmode, SIZE is its length in bytes and ALIGN is    the maximum alignment we can is has, measured in bytes.     If we call a function that returns the length of the block, return it.  */
end_comment

begin_function
name|rtx
name|clear_storage
parameter_list|(
name|object
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|rtx
name|object
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
specifier|static
name|tree
name|fn
decl_stmt|;
name|tree
name|call_expr
decl_stmt|,
name|arg_list
decl_stmt|;
endif|#
directive|endif
name|rtx
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|object
operator|=
name|protect_from_queue
argument_list|(
name|object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|protect_from_queue
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|MOVE_BY_PIECES_P
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
condition|)
name|clear_by_pieces
argument_list|(
name|object
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Try the most limited insn first, because there's no point 	     including more than one in the machine description unless 	     the more limited one has some advantage.  */
name|rtx
name|opalign
init|=
name|GEN_INT
argument_list|(
name|align
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|enum
name|insn_code
name|code
init|=
name|clrstr_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
comment|/* We don't need MODE to be narrower than 		     BITS_PER_HOST_WIDE_INT here because if SIZE is less than 		     the mode mask, as it is returned by the macro, it will 		     definitely be less than the actual mode mask.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|)
operator|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|BITS_PER_WORD
operator|)
operator|&&
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|0
index|]
operator|==
literal|0
operator|||
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|object
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|&&
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|2
index|]
operator|==
literal|0
operator|||
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|opalign
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|op1
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|op1
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
operator|(
name|int
operator|)
name|code
argument_list|)
argument_list|(
name|object
argument_list|,
name|op1
argument_list|,
name|opalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* OBJECT or SIZE may have been passed through protect_from_queue.  	     It is unsafe to save the value generated by protect_from_queue 	     and reuse it later.  Consider what happens if emit_queue is 	     called before the return value from protect_from_queue is used.  	     Expansion of the CALL_EXPR below will call emit_queue before 	     we are finished emitting RTL for argument setup.  So if we are 	     not careful we could get the wrong value for an argument.  	     To avoid this problem we go ahead and emit code to copy OBJECT 	     and SIZE into new pseudos.  We can then place those new pseudos 	     into an RTL_EXPR and use them later, even after a call to 	     emit_queue.  	     Note this is not strictly needed for library calls since they 	     do not call emit_queue before loading their arguments.  However, 	     we may need to have library calls call emit_queue in the future 	     since failing to do so could cause problems for targets which 	     define SMALL_REGISTER_CLASSES and pass arguments in registers.  */
name|object
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
name|size
operator|=
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
comment|/* It is incorrect to use the libcall calling conventions to call 	     memset in this context.  	     This could be a user call to memset and the user may wish to 	     examine the return value from memset.  	     For targets where libcalls and normal calls have different 	     conventions for returning pointers, we could end up generating 	      incorrect code.   	     So instead of using a libcall sequence we build up a suitable 	     CALL_EXPR and expand the call in the normal fashion.  */
if|if
condition|(
name|fn
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|fntype
decl_stmt|;
comment|/* This was copied from except.c, I don't know if all this is 		 necessary in this context or not.  */
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"memset"
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|fntype
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_function_type
argument_list|(
name|fntype
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|fntype
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|fn
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* We need to make an argument list for the function call.   	     memset has three arguments, the first is a void * addresses, the 	     second a integer with the initialization value, the last is a 	     size_t byte count for the copy.  */
name|arg_list
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|object
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|integer_type_node
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_list
argument_list|)
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now we have to build up the CALL_EXPR itself.  */
name|call_expr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|call_expr
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|call_expr
argument_list|,
name|arg_list
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|call_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|expand_expr
argument_list|(
name|call_expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bzero_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|2
argument_list|,
name|object
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
name|emit_move_insn
argument_list|(
name|object
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Generate code to copy Y into X.    Both Y and X must have the same mode, except that    Y can be a constant with VOIDmode.    This mode cannot be BLKmode; use emit_block_move for that.     Return the last instruction emitted.  */
end_comment

begin_function
name|rtx
name|emit_move_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|protect_from_queue
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
operator|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Never force constant_p_rtx to memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
name|y
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* If X or Y are memory references, verify that their addresses are valid      for the machine.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|y
operator|=
name|change_address
argument_list|(
name|y
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|emit_move_insn_1
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Low level part of emit_move_insn.    Called just like emit_move_insn, but assumes X and Y    are basically valid.  */
end_comment

begin_function
name|rtx
name|emit_move_insn_1
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|submode
decl_stmt|;
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mode
operator|>=
name|MAX_MACHINE_MODE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
comment|/* Expand complex moves by moving real part and imag part, if possible.  */
elseif|else
if|if
condition|(
operator|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_INT
operator|)
operator|&&
name|BLKmode
operator|!=
operator|(
name|submode
operator|=
name|mode_for_size
argument_list|(
operator|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
argument_list|,
operator|(
name|class
operator|==
name|MODE_COMPLEX_INT
condition|?
name|MODE_INT
else|:
name|MODE_FLOAT
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
comment|/* Don't split destination if it is a stack push.  */
name|int
name|stack
init|=
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If this is a stack, push the highpart first, so it 	 will be in the argument order.  	 In that case, change_address is used only to convert 	 the mode, not to change the address.  */
if|if
condition|(
name|stack
condition|)
block|{
comment|/* Note that the real part always precedes the imag part in memory 	     regardless of machine's endianness.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|submode
argument_list|,
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
argument_list|,
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|submode
argument_list|,
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
argument_list|,
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|submode
argument_list|,
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
argument_list|,
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|submode
argument_list|,
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
argument_list|,
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|rtx
name|realpart_x
decl_stmt|,
name|realpart_y
decl_stmt|;
name|rtx
name|imagpart_x
decl_stmt|,
name|imagpart_y
decl_stmt|;
comment|/* If this is a complex value with each part being smaller than a 	     word, the usual calling sequence will likely pack the pieces into 	     a single register.  Unfortunately, SUBREG of hard registers only 	     deals in terms of words, so we have a problem converting input 	     arguments to the CONCAT of two registers that is used elsewhere 	     for complex values.  If this is before reload, we can copy it into 	     memory and reload.  FIXME, we should see about using extract and 	     insert on integer registers, but complex short and complex char 	     variables should be rarely used.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
literal|2
operator|*
name|BITS_PER_WORD
operator|&&
operator|(
name|reload_in_progress
operator||
name|reload_completed
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|packed_dest_p
init|=
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
decl_stmt|;
name|int
name|packed_src_p
init|=
operator|(
name|REG_P
argument_list|(
name|y
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|y
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
decl_stmt|;
if|if
condition|(
name|packed_dest_p
operator|||
name|packed_src_p
condition|)
block|{
name|enum
name|mode_class
name|reg_class
init|=
operator|(
operator|(
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|)
condition|?
name|MODE_FLOAT
else|:
name|MODE_INT
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|reg_class
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_mode
operator|!=
name|BLKmode
condition|)
block|{
name|rtx
name|mem
init|=
name|assign_stack_temp
argument_list|(
name|reg_mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|cmem
init|=
name|change_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|current_function_cannot_inline
operator|=
literal|"function using short complex types cannot be inline"
expr_stmt|;
if|if
condition|(
name|packed_dest_p
condition|)
block|{
name|rtx
name|sreg
init|=
name|gen_rtx_SUBREG
argument_list|(
name|reg_mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn_1
argument_list|(
name|cmem
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn_1
argument_list|(
name|sreg
argument_list|,
name|mem
argument_list|)
return|;
block|}
else|else
block|{
name|rtx
name|sreg
init|=
name|gen_rtx_SUBREG
argument_list|(
name|reg_mode
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn_1
argument_list|(
name|mem
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn_1
argument_list|(
name|x
argument_list|,
name|cmem
argument_list|)
return|;
block|}
block|}
block|}
block|}
name|realpart_x
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|realpart_y
operator|=
name|gen_realpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|imagpart_x
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|imagpart_y
operator|=
name|gen_imagpart
argument_list|(
name|submode
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Show the output dies here.  This is necessary for SUBREGs 	     of pseudos since we cannot track their lifetimes correctly; 	     hard regs shouldn't appear here except as return values. 	     We never want to emit such a clobber after reload.  */
if|if
condition|(
name|x
operator|!=
name|y
operator|&&
operator|!
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|realpart_x
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|imagpart_x
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|realpart_x
argument_list|,
name|realpart_y
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|submode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|imagpart_x
argument_list|,
name|imagpart_y
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|get_last_insn
argument_list|()
return|;
block|}
comment|/* This will handle any multi-word mode that lacks a move_insn pattern.      However, you will get better code if you define such patterns,      even if they must turn into multiple assembler instructions.  */
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
block|{
name|rtx
name|last_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|int
name|need_clobber
decl_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* If X is a push on the stack, do the push now and replace 	 X with a reference to the stack pointer.  */
if|if
condition|(
name|push_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|start_sequence
argument_list|()
expr_stmt|;
name|need_clobber
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|xpart
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|ypart
init|=
name|operand_subword
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
comment|/* If we can't get a part of Y, put Y into memory if it is a 	     constant.  Otherwise, force it into a register.  If we still 	     can't get a part of Y, abort.  */
if|if
condition|(
name|ypart
operator|==
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|y
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|ypart
operator|=
name|operand_subword
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ypart
operator|==
literal|0
condition|)
name|ypart
operator|=
name|operand_subword_force
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpart
operator|==
literal|0
operator|||
name|ypart
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|need_clobber
operator||=
operator|(
name|GET_CODE
argument_list|(
name|xpart
argument_list|)
operator|==
name|SUBREG
operator|)
expr_stmt|;
name|last_insn
operator|=
name|emit_move_insn
argument_list|(
name|xpart
argument_list|,
name|ypart
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Show the output dies here.  This is necessary for SUBREGs 	 of pseudos since we cannot track their lifetimes correctly; 	 hard regs shouldn't appear here except as return values. 	 We never want to emit such a clobber after reload.  */
if|if
condition|(
name|x
operator|!=
name|y
operator|&&
operator|!
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
operator|&&
name|need_clobber
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
return|return
name|last_insn
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pushing data onto the stack.  */
end_comment

begin_comment
comment|/* Push a block of length SIZE (perhaps variable)    and return an rtx to address the beginning of the block.    Note that it is not possible for the value returned to be a QUEUED.    The value may be virtual_outgoing_args_rtx.     EXTRA is the number of bytes of padding to push in addition to SIZE.    BELOW nonzero means this padding comes at low addresses;    otherwise, the padding comes at high addresses.  */
end_comment

begin_function
name|rtx
name|push_block
parameter_list|(
name|size
parameter_list|,
name|extra
parameter_list|,
name|below
parameter_list|)
name|rtx
name|size
decl_stmt|;
name|int
name|extra
decl_stmt|,
name|below
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
name|size
operator|=
name|convert_modes
argument_list|(
name|Pmode
argument_list|,
name|ptr_mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|size
argument_list|)
condition|)
name|anti_adjust_stack
argument_list|(
name|plus_constant
argument_list|(
name|size
argument_list|,
name|extra
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|REG
operator|&&
name|extra
operator|==
literal|0
condition|)
name|anti_adjust_stack
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|temp
init|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|anti_adjust_stack
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|STACK_GROWS_DOWNWARD
argument_list|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|ARGS_GROW_DOWNWARD
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
operator|)
comment|/* Return the lowest stack address when STACK or ARGS grow downward and      we are not aaccumulating outgoing arguments (the c4x port uses such      conventions).  */
name|temp
operator|=
name|virtual_outgoing_args_rtx
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
operator|&&
name|below
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|extra
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|plus_constant
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
operator|(
name|below
condition|?
literal|0
else|:
name|extra
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra
operator|!=
literal|0
operator|&&
operator|!
name|below
condition|)
name|temp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|virtual_outgoing_args_rtx
argument_list|,
name|negate_rtx
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|size
argument_list|,
name|extra
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|virtual_outgoing_args_rtx
argument_list|,
name|negate_rtx
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|memory_address
argument_list|(
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
argument_list|,
name|temp
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|gen_push_operand
parameter_list|()
block|{
return|return
name|gen_rtx_fmt_e
argument_list|(
name|STACK_PUSH_CODE
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx for the address of the beginning of a as-if-it-was-pushed    block of SIZE bytes.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_push_address
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|STACK_PUSH_CODE
operator|==
name|POST_DEC
condition|)
name|temp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STACK_PUSH_CODE
operator|==
name|POST_INC
condition|)
name|temp
operator|=
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|stack_pointer_rtx
expr_stmt|;
return|return
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate code to push X onto the stack, assuming it has mode MODE and    type TYPE.    MODE is redundant except when X is a CONST_INT (since they don't    carry mode info).    SIZE is an rtx for the size of data to be copied (in bytes),    needed only if X is BLKmode.     ALIGN (in bytes) is maximum alignment we can assume.     If PARTIAL and REG are both nonzero, then copy that many of the first    words of X into registers starting with REG, and push the rest of X.    The amount of space pushed is decreased by PARTIAL words,    rounded *down* to a multiple of PARM_BOUNDARY.    REG must be a hard register in this case.    If REG is zero but PARTIAL is not, take any all others actions for an    argument partially in registers, but do not actually load any    registers.     EXTRA is the amount in bytes of extra space to leave next to this arg.    This is ignored if an argument block has already been allocated.     On a machine that lacks real push insns, ARGS_ADDR is the address of    the bottom of the argument block for this call.  We use indexing off there    to store the arg.  On machines with push insns, ARGS_ADDR is 0 when a    argument block has not been preallocated.     ARGS_SO_FAR is the size of args previously pushed for this call.     REG_PARM_STACK_SPACE is nonzero if functions require stack space    for arguments passed in registers.  If nonzero, it will be the number    of bytes required.  */
end_comment

begin_function
name|void
name|emit_push_insn
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|,
name|partial
parameter_list|,
name|reg
parameter_list|,
name|extra
parameter_list|,
name|args_addr
parameter_list|,
name|args_so_far
parameter_list|,
name|reg_parm_stack_space
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|partial
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|rtx
name|args_addr
decl_stmt|;
name|rtx
name|args_so_far
decl_stmt|;
name|int
name|reg_parm_stack_space
decl_stmt|;
block|{
name|rtx
name|xinner
decl_stmt|;
name|enum
name|direction
name|stack_direction
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
init|=
name|downward
decl_stmt|;
else|#
directive|else
operator|=
name|upward
expr_stmt|;
endif|#
directive|endif
comment|/* Decide where to pad the argument: `downward' for below,      `upward' for above, or `none' for don't pad it.      Default is below for small data on big-endian machines; else above.  */
name|enum
name|direction
name|where_pad
init|=
name|FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* Invert direction if stack is post-update.  */
if|if
condition|(
name|STACK_PUSH_CODE
operator|==
name|POST_INC
operator|||
name|STACK_PUSH_CODE
operator|==
name|POST_DEC
condition|)
if|if
condition|(
name|where_pad
operator|!=
name|none
condition|)
name|where_pad
operator|=
operator|(
name|where_pad
operator|==
name|downward
condition|?
name|upward
else|:
name|downward
operator|)
expr_stmt|;
name|xinner
operator|=
name|x
operator|=
name|protect_from_queue
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* Copy a block into the stack, entirely or partially.  */
specifier|register
name|rtx
name|temp
decl_stmt|;
name|int
name|used
init|=
name|partial
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|offset
init|=
name|used
operator|%
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|int
name|skip
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|used
operator|-=
name|offset
expr_stmt|;
comment|/* USED is now the # of bytes we need not copy to the stack 	 because registers will take care of them.  */
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
name|xinner
operator|=
name|change_address
argument_list|(
name|xinner
argument_list|,
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|used
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the partial register-part of the arg counts in its stack size, 	 skip the part of stack space corresponding to the registers. 	 Otherwise, start copying to the beginning of the stack space, 	 by setting SKIP to 0.  */
name|skip
operator|=
operator|(
name|reg_parm_stack_space
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|used
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
comment|/* Do it with several push insns if that doesn't take lots of insns 	 and if there is no difficulty with push insns that skip bytes 	 on the stack for alignment purposes.  */
if|if
condition|(
name|args_addr
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|skip
operator|==
literal|0
operator|&&
operator|(
name|MOVE_BY_PIECES_P
argument_list|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|,
name|align
argument_list|)
operator|)
comment|/* Here we avoid the case of a structure whose weak alignment 	     forces many pushes of a small amount of data, 	     and such small pushes do rounding that causes trouble.  */
operator|&&
operator|(
operator|(
operator|!
name|SLOW_UNALIGNED_ACCESS
operator|)
operator|||
name|align
operator|>=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|||
name|PUSH_ROUNDING
argument_list|(
name|align
argument_list|)
operator|==
name|align
operator|)
operator|&&
name|PUSH_ROUNDING
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|size
argument_list|)
condition|)
block|{
comment|/* Push padding now if padding above and stack grows down, 	     or if padding below and stack grows up. 	     But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
name|move_by_pieces
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_push_operand
argument_list|()
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_check_memory_usage
operator|&&
operator|!
name|in_check_memory_usage
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|in_check_memory_usage
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|get_push_address
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|emit_library_call
argument_list|(
name|chkr_copy_bitmap_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|temp
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_library_call
argument_list|(
name|chkr_set_right_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|temp
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_RW
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|in_check_memory_usage
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* PUSH_ROUNDING */
block|{
comment|/* Otherwise make space on the stack and copy the data 	     to the address of that space.  */
comment|/* Deduct words put into registers from the size we must copy.  */
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
name|size
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|used
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|size
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|used
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* Get the address of the stack space. 	     In this case, we do not deal with EXTRA separately. 	     A single stack adjust will do.  */
if|if
condition|(
operator|!
name|args_addr
condition|)
block|{
name|temp
operator|=
name|push_block
argument_list|(
name|size
argument_list|,
name|extra
argument_list|,
name|where_pad
operator|==
name|downward
argument_list|)
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|args_so_far
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|args_addr
argument_list|,
name|skip
operator|+
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|args_addr
argument_list|,
name|args_so_far
argument_list|)
argument_list|,
name|skip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_check_memory_usage
operator|&&
operator|!
name|in_check_memory_usage
condition|)
block|{
name|rtx
name|target
decl_stmt|;
name|in_check_memory_usage
operator|=
literal|1
expr_stmt|;
name|target
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|emit_library_call
argument_list|(
name|chkr_copy_bitmap_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|target
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_library_call
argument_list|(
name|chkr_set_right_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|target
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_RW
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|in_check_memory_usage
operator|=
literal|0
expr_stmt|;
block|}
comment|/* TEMP is the address of the block.  Copy the data there.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|MOVE_BY_PIECES_P
argument_list|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
operator|)
condition|)
block|{
name|move_by_pieces
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|xinner
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
name|rtx
name|opalign
init|=
name|GEN_INT
argument_list|(
name|align
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|target
init|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|temp
argument_list|)
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|enum
name|insn_code
name|code
init|=
name|movstr_optab
index|[
operator|(
name|int
operator|)
name|mode
index|]
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
operator|)
operator|)
operator|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|BITS_PER_WORD
operator|)
operator|&&
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|target
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|||
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xinner
argument_list|,
name|BLKmode
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|3
index|]
operator|==
literal|0
operator|||
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|3
index|]
call|)
argument_list|(
name|opalign
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|op2
init|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|2
index|]
operator|!=
literal|0
operator|&&
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|code
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op2
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
operator|(
name|int
operator|)
name|code
argument_list|)
argument_list|(
name|target
argument_list|,
name|xinner
argument_list|,
name|op2
argument_list|,
name|opalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|ACCUMULATE_OUTGOING_ARGS
comment|/* If the source is referenced relative to the stack pointer, 	     copy it to another register to stabilize it.  We do not need 	     to do this if we know that we won't be changing sp.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|temp
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|temp
argument_list|)
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make inhibit_defer_pop nonzero around the library call 	     to force it to pop the bcopy-arguments right away.  */
name|NO_DEFER_POP
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memcpy_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|temp
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bcopy_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|xinner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|temp
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OK_DEFER_POP
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|partial
operator|>
literal|0
condition|)
block|{
comment|/* Scalar partly in registers.  */
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|not_stack
decl_stmt|;
comment|/* # words of start of argument 	 that we must make space for but need not store.  */
name|int
name|offset
init|=
name|partial
operator|%
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_WORD
operator|)
decl_stmt|;
name|int
name|args_offset
init|=
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
decl_stmt|;
name|int
name|skip
decl_stmt|;
comment|/* Push padding now if padding above and stack grows down, 	 or if padding below and stack grows up. 	 But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we make space by pushing it, we might as well push 	 the real data.  Otherwise, we can leave OFFSET nonzero 	 and leave the space uninitialized.  */
if|if
condition|(
name|args_addr
operator|==
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Now NOT_STACK gets the number of words that we don't need to 	 allocate on the stack.  */
name|not_stack
operator|=
name|partial
operator|-
name|offset
expr_stmt|;
comment|/* If the partial register-part of the arg counts in its stack size, 	 skip the part of stack space corresponding to the registers. 	 Otherwise, start copying to the beginning of the stack space, 	 by setting SKIP to 0.  */
name|skip
operator|=
operator|(
name|reg_parm_stack_space
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|not_stack
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If X is a hard register in a non-integer mode, copy it into a pseudo; 	 SUBREGs of such registers are not allowed.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
operator|)
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Loop over all the words allocated on the stack for this arg.  */
comment|/* We can do it by words, because any scalar bigger than a word 	 has a size a multiple of a word.  */
ifndef|#
directive|ifndef
name|PUSH_ARGS_REVERSED
for|for
control|(
name|i
operator|=
name|not_stack
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
name|not_stack
condition|;
name|i
operator|--
control|)
endif|#
directive|endif
if|if
condition|(
name|i
operator|>=
name|not_stack
operator|+
name|offset
condition|)
name|emit_push_insn
argument_list|(
name|operand_subword_force
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_RTX
argument_list|,
name|align
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|args_addr
argument_list|,
name|GEN_INT
argument_list|(
name|args_offset
operator|+
operator|(
operator|(
name|i
operator|-
name|not_stack
operator|+
name|skip
operator|)
operator|*
name|UNITS_PER_WORD
operator|)
argument_list|)
argument_list|,
name|reg_parm_stack_space
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|addr
decl_stmt|;
name|rtx
name|target
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Push padding now if padding above and stack grows down, 	 or if padding below and stack grows up. 	 But if space already allocated, this has already been done.  */
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|!=
name|none
operator|&&
name|where_pad
operator|!=
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|args_addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|gen_push_operand
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|args_so_far
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|args_addr
argument_list|,
name|INTVAL
argument_list|(
name|args_so_far
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|args_addr
argument_list|,
name|args_so_far
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|addr
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_check_memory_usage
operator|&&
operator|!
name|in_check_memory_usage
condition|)
block|{
name|in_check_memory_usage
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|get_push_address
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|emit_library_call
argument_list|(
name|chkr_copy_bitmap_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|target
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_library_call
argument_list|(
name|chkr_set_right_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|target
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_RW
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|in_check_memory_usage
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ret
label|:
comment|/* If part should go in registers, copy that part      into the appropriate registers.  Do this now, at the end,      since mem-to-mem copies above may do function calls.  */
if|if
condition|(
name|partial
operator|>
literal|0
operator|&&
name|reg
operator|!=
literal|0
condition|)
block|{
comment|/* Handle calls that pass values in multiple non-contiguous locations. 	 The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|reg
argument_list|,
name|x
argument_list|,
operator|-
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* ??? size? */
else|else
name|move_block_to_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|x
argument_list|,
name|partial
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extra
operator|&&
name|args_addr
operator|==
literal|0
operator|&&
name|where_pad
operator|==
name|stack_direction
condition|)
name|anti_adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an assignment that stores the value of FROM into TO.    If WANT_VALUE is nonzero, return an rtx for the value of TO.    (This may contain a QUEUED rtx;    if the value is constant, this rtx is a constant.)    Otherwise, the returned value is NULL_RTX.     SUGGEST_REG is no longer actually used.    It used to mean, copy the value through a register    and return that register, if that is possible.    We now use WANT_VALUE to decide whether to do this.  */
end_comment

begin_function
name|rtx
name|expand_assignment
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|want_value
parameter_list|,
name|suggest_reg
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|want_value
decl_stmt|;
name|int
name|suggest_reg
decl_stmt|;
block|{
specifier|register
name|rtx
name|to_rtx
init|=
literal|0
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* Don't crash if the lhs of the assignment was erroneous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
name|result
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|want_value
condition|?
name|result
else|:
name|NULL_RTX
return|;
block|}
comment|/* Assignment of a structure component needs special treatment      if the structure component's rtx is not simply a MEM.      Assignment of an array element at a constant index, and assignment of      an array element in an unaligned packed structure field, has the same      problem.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|||
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|tem
operator|=
name|get_inner_reference
argument_list|(
name|to
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode1
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|alignment
argument_list|)
expr_stmt|;
comment|/* If we are going to use store_bit_field and extract_bit_field, 	 make sure to_rtx will be safe for multiple use.  */
if|if
condition|(
name|mode1
operator|==
name|VOIDmode
operator|&&
name|want_value
condition|)
name|tem
operator|=
name|stabilize_reference
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|tem
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_MEMORY_USE_DONT
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset_rtx
init|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|ptr_mode
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|offset_rtx
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
else|#
directive|else
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* A constant address in TO_RTX can have VOIDmode, we must not try 	     to call force_reg for that case.  Avoid that case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|bitsize
operator|&&
operator|(
name|bitpos
operator|%
name|bitsize
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bitsize
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|alignment
operator|*
name|BITS_PER_UNIT
operator|)
operator|==
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|change_address
argument_list|(
name|to_rtx
argument_list|,
name|mode1
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|to_rtx
operator|=
name|temp
expr_stmt|;
else|else
name|to_rtx
operator|=
name|change_address
argument_list|(
name|to_rtx
argument_list|,
name|mode1
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bitpos
operator|=
literal|0
expr_stmt|;
block|}
name|to_rtx
operator|=
name|change_address
argument_list|(
name|to_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|ptr_mode
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|volatilep
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* When the offset is zero, to_rtx is the address of the 		 structure we are storing into, and hence may be shared. 		 We must make a new MEM before setting the volatile bit.  */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This was turned off because, when a field is volatile 	  in an object which is not volatile, the object may be in a register, 	  and then we would abort over here.  */
block|else 	    abort ();
endif|#
directive|endif
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_READONLY
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check the access.  */
if|if
condition|(
name|current_function_check_memory_usage
operator|&&
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|to_addr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|best_mode_size
decl_stmt|;
name|enum
name|machine_mode
name|best_mode
decl_stmt|;
name|best_mode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|mode1
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
name|best_mode
operator|=
name|QImode
expr_stmt|;
name|best_mode_size
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|best_mode
argument_list|)
expr_stmt|;
name|to_addr
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|CEIL
argument_list|(
operator|(
name|bitpos
operator|%
name|best_mode_size
operator|)
operator|+
name|bitsize
argument_list|,
name|best_mode_size
argument_list|)
expr_stmt|;
name|size
operator|*=
name|GET_MODE_SIZE
argument_list|(
name|best_mode
argument_list|)
expr_stmt|;
comment|/* Check the access right of the pointer.  */
if|if
condition|(
name|size
condition|)
name|emit_library_call
argument_list|(
name|chkr_check_addr_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|to_addr
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_WO
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|store_field
argument_list|(
name|to_rtx
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode1
argument_list|,
name|from
argument_list|,
operator|(
name|want_value
comment|/* Spurious cast makes HPUX compiler happy.  */
condition|?
operator|(
expr|enum
name|machine_mode
operator|)
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
else|:
name|VOIDmode
operator|)
argument_list|,
name|unsignedp
argument_list|,
comment|/* Required alignment of containing datum.  */
name|alignment
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|get_alias_set
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
comment|/* If the value is meaningful, convert RESULT to the proper mode. 	 Otherwise, return nothing.  */
return|return
operator|(
name|want_value
condition|?
name|convert_modes
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
else|:
name|NULL_RTX
operator|)
return|;
block|}
comment|/* If the rhs is a function call and its value is not an aggregate,      call the function before we start to compute the lhs.      This is needed for correct code for cases such as      val = setjmp (buf) on machines where reference to val      requires loading up part of an address in a separate insn.       Don't do this if TO is a VAR_DECL whose DECL_RTL is REG since it might be      a promoted variable where the zero- or sign- extension needs to be done.      Handling this in the normal way is safe because no computation is done      before the call.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|!
name|aggregate_value_p
argument_list|(
name|from
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|to
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
condition|)
block|{
name|rtx
name|value
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|value
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_rtx
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|to
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_MEMORY_USE_WO
argument_list|)
expr_stmt|;
comment|/* Handle calls that return values in multiple non-contiguous locations. 	 The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|to_rtx
argument_list|,
name|value
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|to_rtx
argument_list|,
name|value
argument_list|,
name|expr_size
argument_list|(
name|from
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|value
operator|=
name|convert_memory_address
argument_list|(
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|to_rtx
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|to_rtx
else|:
name|NULL_RTX
return|;
block|}
comment|/* Ordinary treatment.  Expand TO to get a REG or MEM rtx.      Don't re-expand if it was expanded already (in COMPONENT_REF case).  */
if|if
condition|(
name|to_rtx
operator|==
literal|0
condition|)
block|{
name|to_rtx
operator|=
name|expand_expr
argument_list|(
name|to
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_MEMORY_USE_WO
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
condition|)
name|MEM_ALIAS_SET
argument_list|(
name|to_rtx
argument_list|)
operator|=
name|get_alias_set
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
comment|/* Don't move directly into a return register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|RESULT_DECL
operator|&&
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|to_rtx
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|to_rtx
else|:
name|NULL_RTX
return|;
block|}
comment|/* In case we are returning the contents of an object which overlaps      the place the value is being stored, use a safe function when copying      a value through a pointer into a structure value return block.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|RESULT_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|current_function_returns_struct
operator|&&
operator|!
name|current_function_returns_pcc_struct
condition|)
block|{
name|rtx
name|from_rtx
decl_stmt|,
name|size
decl_stmt|;
name|push_temp_slots
argument_list|()
expr_stmt|;
name|size
operator|=
name|expr_size
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|from_rtx
operator|=
name|expand_expr
argument_list|(
name|from
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_MEMORY_USE_DONT
argument_list|)
expr_stmt|;
comment|/* Copy the rights of the bitmap.  */
if|if
condition|(
name|current_function_check_memory_usage
condition|)
name|emit_library_call
argument_list|(
name|chkr_copy_bitmap_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|from_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memcpy_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|from_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bcopy_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|from_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|preserve_temp_slots
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|to_rtx
else|:
name|NULL_RTX
return|;
block|}
comment|/* Compute FROM and store the value in the rtx we got.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
name|result
operator|=
name|store_expr
argument_list|(
name|from
argument_list|,
name|to_rtx
argument_list|,
name|want_value
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|want_value
condition|?
name|result
else|:
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Generate code for computing expression EXP,    and storing the value into TARGET.    TARGET may contain a QUEUED rtx.     If WANT_VALUE is nonzero, return a copy of the value    not in TARGET, so that we can be sure to use the proper    value in a containing expression even if TARGET has something    else stored in it.  If possible, we copy the value through a pseudo    and return that pseudo.  Or, if the value is constant, we try to    return the constant.  In some cases, we return a pseudo    copied *from* TARGET.     If the mode is BLKmode then we may return TARGET itself.    It turns out that in BLKmode it doesn't cause a problem.    because C has no operators that could combine two different    assignments into the same BLKmode object with different values    with no sequence point.  Will other languages need this to    be more thorough?     If WANT_VALUE is 0, we return NULL, to make sure    to catch quickly any cases where the caller uses the value    and fails to set WANT_VALUE.  */
end_comment

begin_function
name|rtx
name|store_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|want_value
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
specifier|register
name|rtx
name|target
decl_stmt|;
name|int
name|want_value
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
name|int
name|dont_return_target
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
comment|/* Perform first part of compound expression, then assign from second 	 part.  */
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
return|return
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|want_value
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COND_EXPR
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
comment|/* For conditional expression, get safe form of the target.  Then 	 test the condition, doing the appropriate assignment on either 	 side.  This avoids the creation of unnecessary temporaries. 	 For non-BLKmode, it is more efficient not to do this.  */
name|rtx
name|lab1
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|,
name|lab2
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab2
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
return|return
name|want_value
condition|?
name|target
else|:
name|NULL_RTX
return|;
block|}
elseif|else
if|if
condition|(
name|queued_subexp_p
argument_list|(
name|target
argument_list|)
condition|)
comment|/* If target contains a postincrement, let's not risk        using it as the place to generate the rhs.  */
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* Expand EXP into a new pseudo.  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|temp
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If target is volatile, ANSI requires accessing the value 	 *from* the target, if it is accessed.  So make that happen. 	 In no case return the target itself.  */
if|if
condition|(
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|&&
name|want_value
condition|)
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|want_value
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
condition|)
comment|/* If target is in memory and caller wants value in a register instead,        arrange that.  Pass TARGET as target for expand_expr so that,        if EXP is another assignment, WANT_VALUE will be nonzero for it.        We know expand_expr will not use the target in that case.        Don't do this if TARGET is volatile because we are supposed        to write it and then read it.  */
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|cse_not_expected
condition|?
name|NULL_RTX
else|:
name|target
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|target
argument_list|)
condition|)
comment|/* If this is an scalar in a register that is stored in a wider mode        than the declared mode, compute the result into its declared mode        and then convert to the wider mode.  Our value is the computed        expression.  */
block|{
comment|/* If we don't want a value, we can do the conversion inside EXP, 	 which will often result in some optimizations.  Do the conversion 	 in two steps: first change the signedness, if needed, then 	 the extend.  But don't do this if the type of EXP is a subtype 	 of something else since then the conversion might involve 	 more than just converting modes.  */
if|if
condition|(
operator|!
name|want_value
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
condition|)
name|exp
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|convert
argument_list|(
name|type_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If TEMP is a volatile MEM and we want a result value, make 	 the access now so it gets done only once.  Likewise if 	 it contains TARGET.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
operator|&&
name|want_value
operator|&&
operator|(
name|MEM_VOLATILE_P
argument_list|(
name|temp
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* If TEMP is a VOIDmode constant, use convert_modes to make 	 sure that we properly convert it.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|VOIDmode
condition|)
name|temp
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|,
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|want_value
condition|?
name|temp
else|:
name|NULL_RTX
return|;
block|}
else|else
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Return TARGET if it's a specified hardware register. 	 If TARGET is a volatile mem ref, either return TARGET 	 or return a reg copied *from* TARGET; ANSI requires this.  	 Otherwise, if TEMP is not TARGET, return TEMP 	 if it is constant (for efficiency), 	 or if we really want the correct value.  */
if|if
condition|(
operator|!
operator|(
name|target
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|||
name|want_value
operator|)
condition|)
name|dont_return_target
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If TEMP is a VOIDmode constant and the mode of the type of EXP is not      the same as that of TARGET, adjust the constant.  This is needed, for      example, in case it is a CONST_DOUBLE and we want only a word-sized      value.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_check_memory_usage
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
condition|)
name|emit_library_call
argument_list|(
name|chkr_copy_bitmap_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_library_call
argument_list|(
name|chkr_check_addr_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_WO
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If value was not generated in the target, store it there.      Convert the value to TARGET's type first if nec.  */
comment|/* If TEMP and TARGET compare equal according to rtx_equal_p, but      one or both of them are volatile memory refs, we have to distinguish      two cases:      - expand_expr has used TARGET.  In this case, we must not generate        another copy.  This can be detected by TARGET being equal according        to == .      - expand_expr has not used TARGET - that means that the source just        happens to have the same RTX form.  Since temp will have been created        by expand_expr, it will compare unequal according to == .        We must generate a copy in this case, to reach the correct number        of volatile memory references.  */
if|if
condition|(
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
operator|||
operator|(
name|temp
operator|!=
name|target
operator|&&
operator|(
name|side_effects_p
argument_list|(
name|temp
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|target
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
name|target
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dont_return_target
condition|)
block|{
comment|/* In this case, we will return TEMP, 		 so make sure it has the proper mode. 		 But don't forget to store the value into TARGET.  */
name|temp
operator|=
name|convert_to_mode
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* Handle copying a string constant into an array. 	     The string constant may be shorter than the array. 	     So copy just the string's actual length, and clear the rest.  */
name|rtx
name|size
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* Get the size of the data type of the string, 	     which is actually the size of the target.  */
name|size
operator|=
name|expr_size
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
condition|)
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|size
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Compute the size of the data to copy from the string.  */
name|tree
name|copy_size
init|=
name|size_binop
argument_list|(
name|MIN_EXPR
argument_list|,
name|make_tree
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|)
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|build_int_2
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|copy_size_rtx
init|=
name|expand_expr
argument_list|(
name|copy_size
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|label
init|=
literal|0
decl_stmt|;
comment|/* Copy that much.  */
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|copy_size_rtx
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Figure out how much is left in TARGET that we have to clear. 		 Do all calculations in ptr_mode.  */
name|addr
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_modes
argument_list|(
name|ptr_mode
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy_size_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|plus_constant
argument_list|(
name|size
argument_list|,
operator|-
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expand_binop
argument_list|(
name|ptr_mode
argument_list|,
name|add_optab
argument_list|,
name|addr
argument_list|,
name|copy_size_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|size
operator|=
name|expand_binop
argument_list|(
name|ptr_mode
argument_list|,
name|sub_optab
argument_list|,
name|size
argument_list|,
name|copy_size_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|size
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|!=
name|const0_rtx
condition|)
block|{
comment|/* Be sure we can write on ADDR.  */
if|if
condition|(
name|current_function_check_memory_usage
condition|)
name|emit_library_call
argument_list|(
name|chkr_check_addr_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|addr
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_WO
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|memset_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|addr
argument_list|,
name|ptr_mode
argument_list|,
name|const0_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|bzero_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|2
argument_list|,
name|addr
argument_list|,
name|ptr_mode
argument_list|,
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|size
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|label
condition|)
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle calls that return values in multiple non-contiguous locations. 	 The Irix 6 ABI has examples of this.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|PARALLEL
condition|)
name|emit_group_load
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't want a value, return NULL_RTX.  */
if|if
condition|(
operator|!
name|want_value
condition|)
return|return
name|NULL_RTX
return|;
comment|/* If we are supposed to return TEMP, do so as long as it isn't a MEM.      ??? The latter test doesn't seem to make sense.  */
elseif|else
if|if
condition|(
name|dont_return_target
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|temp
return|;
comment|/* Return TARGET itself if it is a hard register.  */
elseif|else
if|if
condition|(
name|want_value
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
return|return
name|copy_to_reg
argument_list|(
name|target
argument_list|)
return|;
else|else
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if EXP just contains zeros.  */
end_comment

begin_function
specifier|static
name|int
name|is_zeros_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|elt
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|is_zeros_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|is_zeros_p
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|is_zeros_p
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
case|case
name|REAL_CST
case|:
return|return
name|REAL_VALUES_IDENTICAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|dconst0
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
return|return
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
operator|==
name|NULL_TREE
return|;
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
if|if
condition|(
operator|!
name|is_zeros_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if EXP contains mostly (3/4)  zeros.  */
end_comment

begin_function
specifier|static
name|int
name|mostly_zeros_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|int
name|elts
init|=
literal|0
decl_stmt|,
name|zeros
init|=
literal|0
decl_stmt|;
name|tree
name|elt
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
comment|/* If there are no ranges of true bits, it is all zero.  */
return|return
name|elt
operator|==
name|NULL_TREE
return|;
block|}
for|for
control|(
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
comment|/* We do not handle the case where the index is a RANGE_EXPR, 	     so the statistic will be somewhat inaccurate. 	     We do make a more accurate count in store_constructor itself, 	     so since this function is only used for nested array elements, 	     this should be close enough.  */
if|if
condition|(
name|mostly_zeros_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
name|zeros
operator|++
expr_stmt|;
name|elts
operator|++
expr_stmt|;
block|}
return|return
literal|4
operator|*
name|zeros
operator|>=
literal|3
operator|*
name|elts
return|;
block|}
return|return
name|is_zeros_p
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for store_constructor.    TARGET, BITSIZE, BITPOS, MODE, EXP are as for store_field.    TYPE is the type of the CONSTRUCTOR, not the element type.    CLEARED is as for store_constructor.     This provides a recursive shortcut back to store_constructor when it isn't    necessary to go through store_field.  This is so that we can pass through    the cleared field to let store_constructor know that we may not have to    clear a substructure if the outer structure has already been cleared.  */
end_comment

begin_function
specifier|static
name|void
name|store_constructor_field
parameter_list|(
name|target
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|mode
parameter_list|,
name|exp
parameter_list|,
name|type
parameter_list|,
name|cleared
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|exp
decl_stmt|,
name|type
decl_stmt|;
name|int
name|cleared
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
comment|/* If we have a non-zero bitpos for a register target, then we just 	 let store_field do the bitfield handling.  This is unlikely to 	 generate unnecessary clear instructions anyways.  */
operator|&&
operator|(
name|bitpos
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|)
condition|)
block|{
if|if
condition|(
name|bitpos
operator|!=
literal|0
condition|)
name|target
operator|=
name|change_address
argument_list|(
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|store_constructor
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|cleared
argument_list|)
expr_stmt|;
block|}
else|else
name|store_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the value of constructor EXP into the rtx TARGET.    TARGET is either a REG or a MEM.    CLEARED is true if TARGET is known to have been zero'd.  */
end_comment

begin_function
specifier|static
name|void
name|store_constructor
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|cleared
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|cleared
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|rtx
name|exp_size
init|=
name|expr_size
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* We know our target cannot conflict, since safe_from_p has been called.  */
if|#
directive|if
literal|0
comment|/* Don't try copying piece by piece into a hard register      since that is vulnerable to being clobbered by EXP.      Instead, construct in a pseudo register and then copy it all.  */
block|if (GET_CODE (target) == REG&& REGNO (target)< FIRST_PSEUDO_REGISTER)     {       rtx temp = gen_reg_rtx (GET_MODE (target));       store_constructor (exp, temp, 0);       emit_move_insn (target, temp);       return;     }
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
block|{
specifier|register
name|tree
name|elt
decl_stmt|;
comment|/* Inform later passes that the whole union value is dead.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are building a static constructor into a register, 	 set the initial value as zero so we can fold the value into 	 a constant.  But if more than one register is involved, 	 this probably loses.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
block|{
if|if
condition|(
operator|!
name|cleared
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the constructor has fewer fields than the structure 	 or if we are initializing the structure to mostly zeros, 	 clear the whole structure first.  */
elseif|else
if|if
condition|(
operator|(
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|list_length
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|||
name|mostly_zeros_p
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cleared
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Inform later passes that the old value is dead.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store each element of the constructor into 	 the corresponding field of TARGET.  */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
specifier|register
name|tree
name|field
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|tree
name|pos
decl_stmt|,
name|constant
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|to_rtx
init|=
name|target
decl_stmt|;
comment|/* Just ignore missing fields. 	     We cleared the whole structure, above, 	     if any fields are missing.  */
if|if
condition|(
name|field
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cleared
operator|&&
name|is_zeros_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
continue|continue;
name|bitsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
name|mode
operator|=
name|VOIDmode
expr_stmt|;
name|pos
operator|=
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pos
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant
operator|=
name|pos
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pos
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant
operator|=
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
operator|,
name|offset
operator|=
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|constant
condition|)
name|bitpos
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|constant
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|rtx
name|offset_rtx
decl_stmt|;
if|if
condition|(
name|contains_placeholder_p
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|offset
argument_list|,
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|offset
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|offset_rtx
operator|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|ptr_mode
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|offset_rtx
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
else|#
directive|else
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|to_rtx
operator|=
name|change_address
argument_list|(
name|to_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|ptr_mode
argument_list|,
name|XEXP
argument_list|(
name|to_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|to_rtx
argument_list|)
operator|==
name|MEM
condition|)
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|to_rtx
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|to_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
comment|/* If this initializes a field that is smaller than a word, at the 	     start of a word, try to widen it to a full word. 	     This special case allows us to output C++ member function 	     initializations in a form that the optimizers can understand.  */
if|if
condition|(
name|constant
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|bitsize
operator|<
name|BITS_PER_WORD
operator|&&
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_CODE
argument_list|(
name|exp_size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|bitpos
operator|+
name|BITS_PER_WORD
operator|<=
name|INTVAL
argument_list|(
name|exp_size
argument_list|)
operator|*
name|BITS_PER_UNIT
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
block|{
name|type
operator|=
name|type_for_size
argument_list|(
name|BITS_PER_WORD
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|value
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|build_int_2
argument_list|(
name|BITS_PER_WORD
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|BITS_PER_WORD
expr_stmt|;
name|mode
operator|=
name|word_mode
expr_stmt|;
block|}
endif|#
directive|endif
name|store_constructor_field
argument_list|(
name|to_rtx
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|type
argument_list|,
name|cleared
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
specifier|register
name|tree
name|elt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|need_to_clear
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|minelt
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|maxelt
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|elttype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* If the constructor has fewer elements than the array,          clear the whole array first.  Similarly if this is          static constructor of a non-BLKmode object.  */
if|if
condition|(
name|cleared
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
name|need_to_clear
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|,
name|zero_count
init|=
literal|0
decl_stmt|;
name|need_to_clear
operator|=
literal|0
expr_stmt|;
comment|/* This loop is a more accurate version of the loop in 	     mostly_zeros_p (it handles RANGE_EXPR in an index). 	     It is also needed to check for missing elements.  */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
operator|!=
name|NULL_TREE
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
name|tree
name|index
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|this_node_count
decl_stmt|;
if|if
condition|(
name|index
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|tree
name|lo_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|hi_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lo_index
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|hi_index
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|need_to_clear
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|this_node_count
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|hi_index
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|lo_index
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|this_node_count
operator|=
literal|1
expr_stmt|;
name|count
operator|+=
name|this_node_count
expr_stmt|;
if|if
condition|(
name|mostly_zeros_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
name|zero_count
operator|+=
name|this_node_count
expr_stmt|;
block|}
comment|/* Clear the entire array first if there are any missing elements, 	     or if the incidence of zero elements is>= 75%.  */
if|if
condition|(
name|count
operator|<
name|maxelt
operator|-
name|minelt
operator|+
literal|1
operator|||
literal|4
operator|*
name|zero_count
operator|>=
literal|3
operator|*
name|count
condition|)
name|need_to_clear
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_to_clear
condition|)
block|{
if|if
condition|(
operator|!
name|cleared
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Inform later passes that the old value is dead.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store each element of the constructor into 	 the corresponding element of TARGET, determined 	 by counting the elements.  */
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|rtx
name|xtarget
init|=
name|target
decl_stmt|;
if|if
condition|(
name|cleared
operator|&&
name|is_zeros_p
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|tree
name|lo_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|hi_index
init|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|index_r
decl_stmt|,
name|pos_rtx
decl_stmt|,
name|addr
decl_stmt|,
name|hi_r
decl_stmt|,
name|loop_top
decl_stmt|,
name|loop_end
decl_stmt|;
name|struct
name|nesting
modifier|*
name|loop
decl_stmt|;
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|count
decl_stmt|;
name|tree
name|position
decl_stmt|;
comment|/* If the range is constant and "small", unroll the loop.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lo_index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|hi_index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|lo
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|lo_index
argument_list|)
operator|,
name|hi
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|hi_index
argument_list|)
operator|,
name|count
operator|=
name|hi
operator|-
name|lo
operator|+
literal|1
operator|,
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
operator|||
name|count
operator|<=
literal|2
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|*
name|count
operator|<=
literal|40
operator|*
literal|8
operator|)
operator|)
operator|)
condition|)
block|{
name|lo
operator|-=
name|minelt
expr_stmt|;
name|hi
operator|-=
name|minelt
expr_stmt|;
for|for
control|(
init|;
name|lo
operator|<=
name|hi
condition|;
name|lo
operator|++
control|)
block|{
name|bitpos
operator|=
name|lo
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|)
expr_stmt|;
name|store_constructor_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|type
argument_list|,
name|cleared
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hi_r
operator|=
name|expand_expr
argument_list|(
name|hi_index
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop_top
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|loop_end
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|index
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|index
argument_list|)
operator|=
name|index_r
operator|=
name|gen_reg_rtx
argument_list|(
name|promote_mode
argument_list|(
name|domain
argument_list|,
name|DECL_MODE
argument_list|(
name|index
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|SAVE_EXPR_RTL
argument_list|(
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Make sure value gets expanded once before the                          loop.  */
name|expand_expr
argument_list|(
name|value
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
block|}
name|store_expr
argument_list|(
name|lo_index
argument_list|,
name|index_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop
operator|=
name|expand_start_loop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Assign value to element index.  */
name|position
operator|=
name|size_binop
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|pos_rtx
operator|=
name|expand_expr
argument_list|(
name|position
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pos_rtx
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|change_address
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|store_constructor
argument_list|(
name|value
argument_list|,
name|xtarget
argument_list|,
name|cleared
argument_list|)
expr_stmt|;
else|else
name|store_expr
argument_list|(
name|value
argument_list|,
name|xtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
name|loop
argument_list|,
name|build
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|index
argument_list|,
name|hi_index
argument_list|)
argument_list|)
expr_stmt|;
name|expand_increment
argument_list|(
name|build
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Needed by stupid register allocation. to extend the 		     lifetime of pseudo-regs used by target past the end 		     of the loop.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|index
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|rtx
name|pos_rtx
decl_stmt|,
name|addr
decl_stmt|;
name|tree
name|position
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|index
operator|=
name|size_int
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|minelt
condition|)
name|index
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|=
name|size_binop
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|index
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|pos_rtx
operator|=
name|expand_expr
argument_list|(
name|position
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pos_rtx
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|change_address
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|value
argument_list|,
name|xtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
name|bitpos
operator|=
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
operator|-
name|minelt
operator|)
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|)
expr_stmt|;
else|else
name|bitpos
operator|=
operator|(
name|i
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|elttype
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|store_constructor_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|type
argument_list|,
name|cleared
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* set constructor assignments */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
name|tree
name|elt
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|nbytes
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|,
name|nbits
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|domain_min
decl_stmt|,
name|domain_max
decl_stmt|,
name|bitlength
decl_stmt|;
comment|/* The default implementation strategy is to extract the constant 	 parts of the constructor, use that to initialize the target, 	 and then "or" in whatever non-constant ranges we need in addition.  	 If a large set is all zero or all ones, it is 	 probably better to set it using memset (if available) or bzero. 	 Also, if a large set has just a single range, it may also be 	 better to first clear all the first clear the set (using 	 bzero/memset), and set the bits we want.  */
comment|/* Check for all zeros.  */
if|if
condition|(
name|elt
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|cleared
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
return|return;
block|}
name|domain_min
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
name|domain_max
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
name|bitlength
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|domain_max
argument_list|,
name|domain_min
argument_list|)
argument_list|,
name|size_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|bitlength
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nbits
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|bitlength
argument_list|)
expr_stmt|;
comment|/* For "small" sets, or "medium-sized" (up to 32 bytes) sets that 	 are "complicated" (more than one range), initialize (the 	 constant parts) by copying from a constant.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|BLKmode
operator|||
name|nbits
operator|<=
literal|2
operator|*
name|BITS_PER_WORD
operator|||
operator|(
name|nbytes
operator|<=
literal|32
operator|&&
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|!=
name|NULL_TREE
operator|)
condition|)
block|{
name|int
name|set_word_size
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|set_word_size
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|bit_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nbits
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|word
init|=
literal|0
decl_stmt|;
name|int
name|bit_pos
init|=
literal|0
decl_stmt|;
name|int
name|ibit
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* In bytes from beginning of set.  */
name|elt
operator|=
name|get_set_constructor_bits
argument_list|(
name|exp
argument_list|,
name|bit_buffer
argument_list|,
name|nbits
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|bit_buffer
index|[
name|ibit
index|]
condition|)
block|{
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|word
operator||=
operator|(
literal|1
operator|<<
operator|(
name|set_word_size
operator|-
literal|1
operator|-
name|bit_pos
operator|)
operator|)
expr_stmt|;
else|else
name|word
operator||=
literal|1
operator|<<
name|bit_pos
expr_stmt|;
block|}
name|bit_pos
operator|++
expr_stmt|;
name|ibit
operator|++
expr_stmt|;
if|if
condition|(
name|bit_pos
operator|>=
name|set_word_size
operator|||
name|ibit
operator|==
name|nbits
condition|)
block|{
if|if
condition|(
name|word
operator|!=
literal|0
operator|||
operator|!
name|cleared
condition|)
block|{
name|rtx
name|datum
init|=
name|GEN_INT
argument_list|(
name|word
argument_list|)
decl_stmt|;
name|rtx
name|to_rtx
decl_stmt|;
comment|/* The assumption here is that it is safe to use 			 XEXP if the set is multi-word, but not if 			 it's single-word.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|to_rtx
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|to_rtx
operator|=
name|change_address
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|to_rtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|to_rtx
operator|=
name|target
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|to_rtx
argument_list|,
name|datum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ibit
operator|==
name|nbits
condition|)
break|break;
name|word
operator|=
literal|0
expr_stmt|;
name|bit_pos
operator|=
literal|0
expr_stmt|;
name|offset
operator|+=
name|set_word_size
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|cleared
condition|)
block|{
comment|/* Don't bother clearing storage if the set is all ones.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|!=
name|NULL_TREE
operator|||
operator|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
operator|==
name|NULL_TREE
condition|?
name|nbits
operator|!=
literal|1
else|:
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|+
literal|1
operator|!=
name|nbits
operator|)
operator|)
operator|)
condition|)
name|clear_storage
argument_list|(
name|target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|elt
operator|!=
name|NULL_TREE
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
comment|/* start of range of element or NULL */
name|tree
name|startbit
init|=
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
comment|/* end of range of element, or element value */
name|tree
name|endbit
init|=
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|HOST_WIDE_INT
name|startb
decl_stmt|,
name|endb
decl_stmt|;
endif|#
directive|endif
name|rtx
name|bitlength_rtx
decl_stmt|,
name|startbit_rtx
decl_stmt|,
name|endbit_rtx
decl_stmt|,
name|targetx
decl_stmt|;
name|bitlength_rtx
operator|=
name|expand_expr
argument_list|(
name|bitlength
argument_list|,
name|NULL_RTX
argument_list|,
name|MEM
argument_list|,
name|EXPAND_CONST_ADDRESS
argument_list|)
expr_stmt|;
comment|/* handle non-range tuple element like [ expr ]  */
if|if
condition|(
name|startbit
operator|==
name|NULL_TREE
condition|)
block|{
name|startbit
operator|=
name|save_expr
argument_list|(
name|endbit
argument_list|)
expr_stmt|;
name|endbit
operator|=
name|startbit
expr_stmt|;
block|}
name|startbit
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|startbit
argument_list|)
expr_stmt|;
name|endbit
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|endbit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|domain_min
argument_list|)
condition|)
block|{
name|startbit
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|startbit
argument_list|,
name|domain_min
argument_list|)
expr_stmt|;
name|endbit
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|endbit
argument_list|,
name|domain_min
argument_list|)
expr_stmt|;
block|}
name|startbit_rtx
operator|=
name|expand_expr
argument_list|(
name|startbit
argument_list|,
name|NULL_RTX
argument_list|,
name|MEM
argument_list|,
name|EXPAND_CONST_ADDRESS
argument_list|)
expr_stmt|;
name|endbit_rtx
operator|=
name|expand_expr
argument_list|(
name|endbit
argument_list|,
name|NULL_RTX
argument_list|,
name|MEM
argument_list|,
name|EXPAND_CONST_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|targetx
operator|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|targetx
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|targetx
operator|=
name|target
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
comment|/* Optimization:  If startbit and endbit are 	     constants divisible by BITS_PER_UNIT, 	     call memset instead.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|startbit
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|endbit
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|startb
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|startbit
argument_list|)
operator|)
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
operator|&&
operator|(
name|endb
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|endbit
argument_list|)
operator|+
literal|1
operator|)
operator|%
name|BITS_PER_UNIT
operator|==
literal|0
condition|)
block|{
name|emit_library_call
argument_list|(
name|memset_libfunc
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|targetx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|startb
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|constm1_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|endb
operator|-
name|startb
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__setbits"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|,
name|XEXP
argument_list|(
name|targetx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|bitlength_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|startbit_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|endbit_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|targetx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the value of EXP (an expression tree)    into a subfield of TARGET which has mode MODE and occupies    BITSIZE bits, starting BITPOS bits from the start of TARGET.    If MODE is VOIDmode, it means that we are storing into a bit-field.     If VALUE_MODE is VOIDmode, return nothing in particular.    UNSIGNEDP is not used in this case.     Otherwise, return an rtx for the value stored.  This rtx    has mode VALUE_MODE if that is convenient to do.    In this case, UNSIGNEDP must be nonzero if the value is an unsigned type.     ALIGN is the alignment that TARGET is known to have, measured in bytes.    TOTAL_SIZE is the size in bytes of the structure, or -1 if varying.       ALIAS_SET is the alias set for the destination.  This value will    (in general) be different from that for TARGET, since TARGET is a    reference to the containing structure.  */
end_comment

begin_function
specifier|static
name|rtx
name|store_field
parameter_list|(
name|target
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|mode
parameter_list|,
name|exp
parameter_list|,
name|value_mode
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|,
name|total_size
parameter_list|,
name|alias_set
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|enum
name|machine_mode
name|value_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|total_size
decl_stmt|;
name|int
name|alias_set
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|width_mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|width_mask
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If we are storing into an unaligned field of an aligned union that is      in a register, we may have the mode of TARGET being an integer mode but      MODE == BLKmode.  In that case, get an aligned object whose size and      alignment are the same as TARGET and store TARGET into it (we can avoid      the store if the field being stored is the entire width of TARGET).  Then      call ourselves recursively to store the field into a BLKmode version of      that object.  Finally, load from the object into TARGET.  This is not      very efficient in general, but should only be slightly more expensive      than the otherwise-required unaligned accesses.  Perhaps this can be      cleaned up later.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
block|{
name|rtx
name|object
init|=
name|assign_stack_temp
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|blk_object
init|=
name|copy_rtx
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|blk_object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|blk_object
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitsize
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|object
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|store_field
argument_list|(
name|blk_object
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|exp
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|,
name|alias_set
argument_list|)
expr_stmt|;
comment|/* Even though we aren't returning target, we need to 	 give it the updated value.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
name|blk_object
return|;
block|}
comment|/* If the structure is in a register or if the component      is a bit field, we cannot use addressing to access it.      Use bit-field techniques or SUBREG to store in it.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
operator|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|!
name|direct_store
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
operator|)
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
comment|/* If the field isn't aligned enough to store as an ordinary memref, 	 store it as a bit field.  */
operator|||
operator|(
name|SLOW_UNALIGNED_ACCESS
operator|&&
name|align
operator|*
name|BITS_PER_UNIT
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|SLOW_UNALIGNED_ACCESS
operator|&&
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If BITSIZE is narrower than the size of the type of EXP 	 we will be narrowing TEMP.  Normally, what's wanted are the 	 low-order bits.  However, if EXP's type is a record and this is 	 big-endian machine, we want the upper BITSIZE bits.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|bitsize
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|temp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|temp
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|-
name|bitsize
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Unless MODE is VOIDmode or BLKmode, convert TEMP to 	 MODE.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the modes of TARGET and TEMP are both BLKmode, both 	 must be in memory and BITPOS must be aligned on a byte 	 boundary.  If so, we simply do a block copy.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|MEM
operator|||
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|target
operator|=
name|change_address
argument_list|(
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|bitsize
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|value_mode
operator|==
name|VOIDmode
condition|?
name|const0_rtx
else|:
name|target
return|;
block|}
comment|/* Store the value in the bitfield.  */
name|store_bit_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_mode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* The caller wants an rtx for the value.  */
comment|/* If possible, avoid refetching from the bitfield itself.  */
if|if
condition|(
name|width_mask
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
condition|)
block|{
name|tree
name|count
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
if|if
condition|(
name|unsignedp
condition|)
return|return
name|expand_and
argument_list|(
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|width_mask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
return|;
name|tmode
operator|=
name|GET_MODE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmode
operator|==
name|VOIDmode
condition|)
name|tmode
operator|=
name|value_mode
expr_stmt|;
name|count
operator|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|tmode
argument_list|,
name|temp
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|tmode
argument_list|,
name|temp
argument_list|,
name|count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|extract_bit_field
argument_list|(
name|target
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
name|NULL_RTX
argument_list|,
name|value_mode
argument_list|,
literal|0
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
return|;
block|}
return|return
name|const0_rtx
return|;
block|}
else|else
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|to_rtx
decl_stmt|;
comment|/* If a value is wanted, it must be the lhs; 	 so make the address stable for multiple use.  */
if|if
condition|(
name|value_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|addr
argument_list|)
comment|/* A frame-pointer reference is already stable.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
operator|||
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|)
operator|)
condition|)
name|addr
operator|=
name|copy_to_reg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Now build a reference to just the desired component.  */
name|to_rtx
operator|=
name|copy_rtx
argument_list|(
name|change_address
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|to_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|to_rtx
argument_list|)
operator|=
name|alias_set
expr_stmt|;
return|return
name|store_expr
argument_list|(
name|exp
argument_list|,
name|to_rtx
argument_list|,
name|value_mode
operator|!=
name|VOIDmode
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression EXP that may be a COMPONENT_REF, a BIT_FIELD_REF,    or an ARRAY_REF, look for nested COMPONENT_REFs, BIT_FIELD_REFs, or    ARRAY_REFs and find the ultimate containing object, which we return.     We set *PBITSIZE to the size in bits that we want, *PBITPOS to the    bit position, and *PUNSIGNEDP to the signedness of the field.    If the position of the field is variable, we store a tree    giving the variable offset (in units) in *POFFSET.    This offset is in addition to the bit position.    If the position is not variable, we store 0 in *POFFSET.    We set *PALIGNMENT to the alignment in bytes of the address that will be    computed.  This is the alignment of the thing we return if *POFFSET    is zero, but can be more less strictly aligned if *POFFSET is nonzero.     If any of the extraction expressions is volatile,    we store 1 in *PVOLATILEP.  Otherwise we don't change that.     If the field is a bit-field, *PMODE is set to VOIDmode.  Otherwise, it    is a mode that can be used to access the field.  In that case, *PBITSIZE    is redundant.     If the field describes a variable-sized object, *PMODE is set to    VOIDmode and *PBITSIZE is set to -1.  An access cannot be made in    this case, but the address of the object can be found.   */
end_comment

begin_function
name|tree
name|get_inner_reference
parameter_list|(
name|exp
parameter_list|,
name|pbitsize
parameter_list|,
name|pbitpos
parameter_list|,
name|poffset
parameter_list|,
name|pmode
parameter_list|,
name|punsignedp
parameter_list|,
name|pvolatilep
parameter_list|,
name|palignment
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
modifier|*
name|pbitsize
decl_stmt|;
name|int
modifier|*
name|pbitpos
decl_stmt|;
name|tree
modifier|*
name|poffset
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|pmode
decl_stmt|;
name|int
modifier|*
name|punsignedp
decl_stmt|;
name|int
modifier|*
name|pvolatilep
decl_stmt|;
name|int
modifier|*
name|palignment
decl_stmt|;
block|{
name|tree
name|orig_exp
init|=
name|exp
decl_stmt|;
name|tree
name|size_tree
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|tree
name|offset
init|=
name|integer_zero_node
decl_stmt|;
name|unsigned
name|int
name|alignment
init|=
name|BIGGEST_ALIGNMENT
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|size_tree
operator|=
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|size_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|size_tree
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size_tree
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size_tree
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|mode
operator|=
name|BLKmode
operator|,
operator|*
name|pbitsize
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|pbitsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|size_tree
argument_list|)
expr_stmt|;
block|}
comment|/* Compute cumulative bit-offset for nested component-refs and array-refs,      and find the ultimate containing object.  */
operator|*
name|pbitpos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|tree
name|pos
init|=
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|?
name|DECL_FIELD_BITPOS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|)
decl_stmt|;
name|tree
name|constant
init|=
name|integer_zero_node
decl_stmt|,
name|var
init|=
name|pos
decl_stmt|;
comment|/* If this field hasn't been filled in yet, don't go 	     past it.  This should only happen when folding expressions 	     made during type construction.  */
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
break|break;
comment|/* Assume here that the offset is a multiple of a unit. 	     If not, there should be an explicitly added constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pos
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant
operator|=
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
operator|,
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pos
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant
operator|=
name|pos
operator|,
name|var
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|pbitpos
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|constant
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|size_binop
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|var
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
comment|/* This code is based on the code in case ARRAY_REF in expand_expr 	     below.  We assume here that the size of an array element is 	     always an integral multiple of BITS_PER_UNIT.  */
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|low_bound
init|=
name|domain
condition|?
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
else|:
name|integer_zero_node
decl_stmt|;
name|tree
name|index_type
init|=
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|tree
name|xindex
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|index_type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
condition|)
block|{
name|index
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Optimize the special-case of a zero lower bound. 	      	     We convert the low_bound to sizetype to avoid some problems 	     with constant folding.  (E.g. suppose the lower bound is 1, 	     and its mode is QI.  Without the conversion,  (ARRAY 	     +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1)) 	     +INDEX), which becomes (ARRAY+255+INDEX).  Oops!) 	      	     But sizetype isn't quite right either (especially if 	     the lowbound is negative).  FIXME */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|low_bound
argument_list|)
condition|)
name|index
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|index
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|low_bound
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|index
operator|=
name|convert
argument_list|(
name|sbitsizetype
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
name|xindex
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|sbitsizetype
argument_list|,
name|index
argument_list|,
name|convert
argument_list|(
name|sbitsizetype
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xindex
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|xindex
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|pbitpos
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|xindex
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Either the bit offset calculated above is not constant, or 		 it overflowed.  In either case, redo the multiplication 		 against the size in units.  This is especially important 		 in the non-constant case to avoid a division at runtime.  */
name|xindex
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|ssizetype
argument_list|,
name|index
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|contains_placeholder_p
argument_list|(
name|xindex
argument_list|)
condition|)
name|xindex
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|xindex
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|xindex
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|NON_LVALUE_EXPR
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
operator|)
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
break|break;
comment|/* If any reference in the chain is volatile, the effect is volatile.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
condition|)
operator|*
name|pvolatilep
operator|=
literal|1
expr_stmt|;
comment|/* If the offset is non-constant already, then we can't assume any 	 alignment more than the alignment here.  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|alignment
operator|=
name|MIN
argument_list|(
name|alignment
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
name|alignment
operator|=
name|MIN
argument_list|(
name|alignment
argument_list|,
name|DECL_ALIGN
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
name|alignment
operator|=
name|MIN
argument_list|(
name|alignment
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
operator|&&
name|contains_placeholder_p
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|offset
argument_list|,
name|orig_exp
argument_list|)
expr_stmt|;
operator|*
name|pmode
operator|=
name|mode
expr_stmt|;
operator|*
name|poffset
operator|=
name|offset
expr_stmt|;
operator|*
name|palignment
operator|=
name|alignment
operator|/
name|BITS_PER_UNIT
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of expand_exp: compute memory_usage from modifier.  */
end_comment

begin_function
specifier|static
name|enum
name|memory_use_mode
name|get_memory_usage_from_modifier
parameter_list|(
name|modifier
parameter_list|)
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
switch|switch
condition|(
name|modifier
condition|)
block|{
case|case
name|EXPAND_NORMAL
case|:
case|case
name|EXPAND_SUM
case|:
return|return
name|MEMORY_USE_RO
return|;
break|break;
case|case
name|EXPAND_MEMORY_USE_WO
case|:
return|return
name|MEMORY_USE_WO
return|;
break|break;
case|case
name|EXPAND_MEMORY_USE_RW
case|:
return|return
name|MEMORY_USE_RW
return|;
break|break;
case|case
name|EXPAND_MEMORY_USE_DONT
case|:
comment|/* EXPAND_CONST_ADDRESS and EXPAND_INITIALIZER are converted into 	 MEMORY_USE_DONT, because they are modifiers to a call of 	 expand_expr in the ADDR_EXPR case of expand_expr.  */
case|case
name|EXPAND_CONST_ADDRESS
case|:
case|case
name|EXPAND_INITIALIZER
case|:
return|return
name|MEMORY_USE_DONT
return|;
case|case
name|EXPAND_MEMORY_USE_BAD
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an rtx VALUE that may contain additions and multiplications,    return an equivalent value that just refers to a register or memory.    This is done by generating instructions to perform the arithmetic    and returning a pseudo-register containing the value.     The returned value may be a REG, SUBREG, MEM or constant.  */
end_comment

begin_function
name|rtx
name|force_operand
parameter_list|(
name|value
parameter_list|,
name|target
parameter_list|)
name|rtx
name|value
decl_stmt|,
name|target
decl_stmt|;
block|{
specifier|register
name|optab
name|binoptab
init|=
literal|0
decl_stmt|;
comment|/* Use a temporary to force order of execution of calls to      `force_operand'.  */
name|rtx
name|tmp
decl_stmt|;
specifier|register
name|rtx
name|op2
decl_stmt|;
comment|/* Use subtarget as the target for operand 0 of a binary operation.  */
specifier|register
name|rtx
name|subtarget
init|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
literal|0
operator|)
decl_stmt|;
comment|/* Check for a PIC address load.  */
if|if
condition|(
name|flag_pic
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|subtarget
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|subtarget
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|subtarget
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PLUS
condition|)
name|binoptab
operator|=
name|add_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MINUS
condition|)
name|binoptab
operator|=
name|sub_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|op2
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|op2
operator|!=
name|subtarget
operator|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
return|return
name|expand_mult
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|force_operand
argument_list|(
name|op2
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|binoptab
condition|)
block|{
name|op2
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|op2
operator|!=
name|subtarget
operator|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|binoptab
operator|==
name|sub_optab
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|binoptab
operator|=
name|add_optab
expr_stmt|;
name|op2
operator|=
name|negate_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
comment|/* Check for an addition with OP2 a constant integer and our first 	 operand a PLUS of a virtual register and something else.  In that 	 case, we want to emit the sum of the virtual register and the 	 constant first and then add the other value.  This allows virtual 	 register instantiation to simply modify the constant rather than 	 creating another one around this addition.  */
if|if
condition|(
name|binoptab
operator|==
name|add_optab
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|rtx
name|temp
init|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|binoptab
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op2
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
return|return
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|binoptab
argument_list|,
name|temp
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
block|}
name|tmp
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|binoptab
argument_list|,
name|tmp
argument_list|,
name|force_operand
argument_list|(
name|op2
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
comment|/* We give UNSIGNEDP = 0 to expand_binop 	 because the only operations we are expanding here are signed ones.  */
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of expand_expr:    save the non-copied parts (LIST) of an expr (LHS), and return a list    which can restore these values to their previous values,    should something modify their storage.  */
end_comment

begin_function
specifier|static
name|tree
name|save_noncopied_parts
parameter_list|(
name|lhs
parameter_list|,
name|list
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
name|tree
name|parts
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|parts
operator|=
name|chainon
argument_list|(
name|parts
argument_list|,
name|save_noncopied_parts
argument_list|(
name|lhs
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|part
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|part_type
init|=
name|TREE_TYPE
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|tree
name|to_be_saved
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|part_type
argument_list|,
name|lhs
argument_list|,
name|part
argument_list|)
decl_stmt|;
name|rtx
name|target
init|=
name|assign_temp
argument_list|(
name|part_type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|part_type
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|target
operator|=
name|change_address
argument_list|(
name|target
argument_list|,
name|TYPE_MODE
argument_list|(
name|part_type
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|parts
operator|=
name|tree_cons
argument_list|(
name|to_be_saved
argument_list|,
name|build
argument_list|(
name|RTL_EXPR
argument_list|,
name|part_type
argument_list|,
name|NULL_TREE
argument_list|,
operator|(
name|tree
operator|)
name|target
argument_list|)
argument_list|,
name|parts
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parts
argument_list|)
argument_list|,
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|parts
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|parts
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of expand_expr:    record the non-copied parts (LIST) of an expr (LHS), and return a list    which specifies the initial values of these parts.  */
end_comment

begin_function
specifier|static
name|tree
name|init_noncopied_parts
parameter_list|(
name|lhs
parameter_list|,
name|list
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
name|tree
name|parts
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|parts
operator|=
name|chainon
argument_list|(
name|parts
argument_list|,
name|init_noncopied_parts
argument_list|(
name|lhs
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|tree
name|part
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|part_type
init|=
name|TREE_TYPE
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|tree
name|to_be_initialized
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|part_type
argument_list|,
name|lhs
argument_list|,
name|part
argument_list|)
decl_stmt|;
name|parts
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|to_be_initialized
argument_list|,
name|parts
argument_list|)
expr_stmt|;
block|}
return|return
name|parts
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of expand_expr: return nonzero iff there is no way that    EXP can reference X, which is being modified.  TOP_P is nonzero if this    call is going to be used to determine whether we need a temporary    for EXP, as opposed to a recursive call to this function.     It is always safe for this routine to return zero since it merely    searches for optimization opportunities.  */
end_comment

begin_function
specifier|static
name|int
name|safe_from_p
parameter_list|(
name|x
parameter_list|,
name|exp
parameter_list|,
name|top_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|int
name|top_p
decl_stmt|;
block|{
name|rtx
name|exp_rtl
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nops
decl_stmt|;
specifier|static
name|int
name|save_expr_count
decl_stmt|;
specifier|static
name|int
name|save_expr_size
init|=
literal|0
decl_stmt|;
specifier|static
name|tree
modifier|*
name|save_expr_rewritten
decl_stmt|;
specifier|static
name|tree
name|save_expr_trees
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
comment|/* If EXP has varying size, we MUST use a target since we currently 	 have no way of allocating temporaries of variable size 	 (except for arrays that have TYPE_ARRAY_MAX_SIZE set). 	 So we assume here that something at a higher level has prevented a 	 clash.  This is somewhat bogus, but the best we can do.  Only 	 do this when X is BLKmode and when we are at the top level.  */
operator|||
operator|(
name|top_p
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|||
name|TYPE_ARRAY_MAX_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_ARRAY_MAX_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|top_p
operator|&&
name|save_expr_size
operator|==
literal|0
condition|)
block|{
name|int
name|rtn
decl_stmt|;
name|save_expr_count
operator|=
literal|0
expr_stmt|;
name|save_expr_size
operator|=
sizeof|sizeof
argument_list|(
name|save_expr_trees
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|save_expr_trees
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|save_expr_rewritten
operator|=
operator|&
name|save_expr_trees
index|[
literal|0
index|]
expr_stmt|;
name|rtn
operator|=
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|save_expr_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|save_expr_trees
index|[
name|i
index|]
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|save_expr_trees
index|[
name|i
index|]
argument_list|,
name|SAVE_EXPR
argument_list|)
expr_stmt|;
block|}
name|save_expr_size
operator|=
literal|0
expr_stmt|;
return|return
name|rtn
return|;
block|}
comment|/* If this is a subreg of a hard register, declare it unsafe, otherwise,      find the underlying pseudo.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
comment|/* If X is a location in the outgoing argument area, it is always safe.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
operator|)
operator|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
name|exp_rtl
operator|=
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
return|return
literal|1
return|;
case|case
literal|'x'
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
condition|)
return|return
operator|(
operator|(
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|||
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_VALUE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|||
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
comment|/* An already-visited SAVE_EXPR? */
else|else
return|return
literal|0
return|;
case|case
literal|'1'
case|:
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|'2'
case|:
case|case
literal|'<'
case|:
return|return
operator|(
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
literal|'e'
case|:
case|case
literal|'r'
case|:
comment|/* Now do code-specific tests.  EXP_RTL is set to any rtx we find in 	 the expression.  If it is set, we conflict iff we are that rtx or 	 both are in memory.  Otherwise, we check all operands of the 	 expression recursively.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
return|return
operator|(
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
return|;
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CALL_EXPR
case|:
name|exp_rtl
operator|=
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp_rtl
operator|==
literal|0
condition|)
block|{
comment|/* Assume that the call will clobber all hard registers and 		 all of memory.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
name|RTL_EXPR
case|:
comment|/* If a sequence exists, we would have to scan every instruction 	     in the sequence to see if it was safe.  This is probably not 	     worthwhile.  */
if|if
condition|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
condition|)
return|return
literal|0
return|;
name|exp_rtl
operator|=
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|exp_rtl
operator|=
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEANUP_POINT_EXPR
case|:
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SAVE_EXPR
case|:
name|exp_rtl
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp_rtl
condition|)
break|break;
comment|/* This SAVE_EXPR might appear many times in the top-level 	     safe_from_p() expression, and if it has a complex 	     subexpression, examining it multiple times could result 	     in a combinatorial explosion.  E.g. on an Alpha 	     running at least 200MHz, a Fortran test case compiled with 	     optimization took about 28 minutes to compile -- even though 	     it was only a few lines long, and the complicated line causing 	     so much time to be spent in the earlier version of safe_from_p() 	     had only 293 or so unique nodes.  	     So, turn this SAVE_EXPR into an ERROR_MARK for now, but remember 	     where it is so we can turn it back in the top-level safe_from_p() 	     when we're done.  */
comment|/* For now, don't bother re-sizing the array. */
if|if
condition|(
name|save_expr_count
operator|>=
name|save_expr_size
condition|)
return|return
literal|0
return|;
name|save_expr_rewritten
index|[
name|save_expr_count
operator|++
index|]
operator|=
name|exp
expr_stmt|;
name|nops
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|SAVE_EXPR
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|operand
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|==
name|NULL_TREE
condition|)
continue|continue;
name|TREE_SET_CODE
argument_list|(
name|exp
argument_list|,
name|ERROR_MARK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|TREE_SET_CODE
argument_list|(
name|exp
argument_list|,
name|SAVE_EXPR
argument_list|)
expr_stmt|;
block|}
name|TREE_SET_CODE
argument_list|(
name|exp
argument_list|,
name|ERROR_MARK
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|BIND_EXPR
case|:
comment|/* The only operand we look at is operand 1.  The rest aren't 	     part of the expression.  */
return|return
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|METHOD_CALL_EXPR
case|:
comment|/* This takes a rtx argument, but shouldn't appear here.  */
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
comment|/* If we have an rtx, we do not need to scan our operands.  */
if|if
condition|(
name|exp_rtl
condition|)
break|break;
name|nops
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|safe_from_p
argument_list|(
name|x
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* If we have an rtl, find any enclosed object.  Then see if we conflict      with it.  */
if|if
condition|(
name|exp_rtl
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp_rtl
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|exp_rtl
operator|=
name|SUBREG_REG
argument_list|(
name|exp_rtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp_rtl
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|exp_rtl
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
comment|/* If the rtl is X, then it is not safe.  Otherwise, it is unless both 	 are memory and EXP is not readonly.  */
return|return
operator|!
operator|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|exp_rtl
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|exp_rtl
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/* If we reach here, it is safe.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of expand_expr: return nonzero iff EXP is an    expression whose type is statically determinable.  */
end_comment

begin_function
specifier|static
name|int
name|fixed_type_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CALL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TARGET_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ARRAY_REF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of expand_expr: return rtx if EXP is a    variable or parameter; else return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|var_rtx
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|PARM_DECL
case|:
case|case
name|VAR_DECL
case|:
return|return
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAX_INTEGER_COMPUTATION_MODE
end_ifdef

begin_function
name|void
name|check_max_integer_computation_mode
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* We must allow conversions of constants to MAX_INTEGER_COMPUTATION_MODE.  */
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return;
comment|/* First check the type of the overall operation.   We need only look at      unary, binary and relational operations.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|fatal
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
block|}
comment|/* Check operand of a unary op.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|fatal
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
block|}
comment|/* Check operands of a binary/comparison op.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|fatal
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|fatal
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* expand_expr: generate code for computing expression EXP.    An rtx for the computed value is returned.  The value is never null.    In the case of a void EXP, const0_rtx is returned.     The value may be stored in TARGET if TARGET is nonzero.    TARGET is just a suggestion; callers must assume that    the rtx returned may not be the same as TARGET.     If TARGET is CONST0_RTX, it means that the value will be ignored.     If TMODE is not VOIDmode, it suggests generating the    result in mode TMODE.  But this is done only when convenient.    Otherwise, TMODE is ignored and the value generated in its natural mode.    TMODE is just a suggestion; callers must assume that    the rtx returned may not have mode TMODE.     Note that TARGET may have neither TMODE nor MODE.  In that case, it    probably will not be used.     If MODIFIER is EXPAND_SUM then when EXP is an addition    we can return an rtx of the form (MULT (REG ...) (CONST_INT ...))    or a nest of (PLUS ...) and (MINUS ...) where the terms are    products as above, or REG or MEM, or constant.    Ordinarily in such cases we would output mul or add instructions    and then return a pseudo reg containing the sum.     EXPAND_INITIALIZER is much like EXPAND_SUM except that    it also marks a label as absolutely required (it can't be dead).    It also makes a ZERO_EXTEND or SIGN_EXTEND instead of emitting extend insns.    This is used for outputting expressions used in initializers.     EXPAND_CONST_ADDRESS says that it is okay to return a MEM    with a constant address even if that address is not normally legitimate.    EXPAND_INITIALIZER and EXPAND_SUM also have this effect.  */
end_comment

begin_function
name|rtx
name|expand_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
comment|/* Chain of pending expressions for PLACEHOLDER_EXPR to replace.      This is static so it will be accessible to our recursive callees.  */
specifier|static
name|tree
name|placeholder_list
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|temp
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|optab
name|this_optab
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|,
name|original_target
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|tree
name|context
decl_stmt|;
comment|/* Used by check-memory-usage to make modifier read only.  */
name|enum
name|expand_modifier
name|ro_modifier
decl_stmt|;
comment|/* Handle ERROR_MARK before anybody tries to access its type. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
name|op0
operator|=
name|CONST0_RTX
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
literal|0
condition|)
return|return
name|op0
return|;
return|return
name|const0_rtx
return|;
block|}
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Use subtarget as the target for operand 0 of a binary operation.  */
name|subtarget
operator|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
literal|0
operator|)
expr_stmt|;
name|original_target
operator|=
name|target
expr_stmt|;
name|ignore
operator|=
operator|(
name|target
operator|==
name|const0_rtx
operator|||
operator|(
operator|(
name|code
operator|==
name|NON_LVALUE_EXPR
operator|||
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|REFERENCE_EXPR
operator|||
name|code
operator|==
name|COND_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|)
operator|)
expr_stmt|;
comment|/* Make a read-only version of the modifier.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_NORMAL
operator|||
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
name|ro_modifier
operator|=
name|modifier
expr_stmt|;
else|else
name|ro_modifier
operator|=
name|EXPAND_NORMAL
expr_stmt|;
comment|/* Don't use hard regs as subtargets, because the combiner      can only handle pseudo regs.  */
if|if
condition|(
name|subtarget
operator|&&
name|REGNO
argument_list|(
name|subtarget
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* Avoid subtargets inside loops,      since they hide some invariant expressions.  */
if|if
condition|(
name|preserve_subexpressions_p
argument_list|()
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* If we are going to ignore this result, we need only do something      if there is a side-effect somewhere in the expression.  If there      is, short-circuit the most common cases here.  Note that we must      not call expand_expr with anything but const0_rtx in case this      is an initial expansion of a size that contains a PLACEHOLDER_EXPR.  */
if|if
condition|(
name|ignore
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* Ensure we reference a volatile object even if value is ignored.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|ro_modifier
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
comment|/* If the second operand has no side effects, just evaluate 	   the first.  */
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|ro_modifier
argument_list|)
return|;
name|target
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAX_INTEGER_COMPUTATION_MODE
if|if
condition|(
name|target
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|BIT_FIELD_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|mode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|fatal
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|BIT_FIELD_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|CALL_EXPR
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|tmode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|tmode
operator|>
name|MAX_INTEGER_COMPUTATION_MODE
condition|)
name|fatal
argument_list|(
literal|"unsupported wide integer operation"
argument_list|)
expr_stmt|;
name|check_max_integer_computation_mode
argument_list|(
name|exp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If will do cse, generate all results into pseudo registers      since 1) that allows cse to find more things      and 2) otherwise cse could produce an insn the machine      cannot support.  */
if|if
condition|(
operator|!
name|cse_not_expected
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|target
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|target
operator|=
name|subtarget
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_DECL
case|:
block|{
name|tree
name|function
init|=
name|decl_function_context
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Handle using a label in a containing function.  */
if|if
condition|(
name|function
operator|!=
name|current_function_decl
operator|&&
name|function
operator|!=
name|inline_function_decl
operator|&&
name|function
operator|!=
literal|0
condition|)
block|{
name|struct
name|function
modifier|*
name|p
init|=
name|find_function_data
argument_list|(
name|function
argument_list|)
decl_stmt|;
comment|/* Allocate in the memory associated with the function 	       that the label is in.  */
name|push_obstacks
argument_list|(
name|p
operator|->
name|function_obstack
argument_list|,
name|p
operator|->
name|function_maybepermanent_obstack
argument_list|)
expr_stmt|;
name|p
operator|->
name|forced_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|label_rtx
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
operator|->
name|forced_labels
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
name|forced_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|label_rtx
argument_list|(
name|exp
argument_list|)
argument_list|,
name|forced_labels
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label_rtx
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|!=
name|current_function_decl
operator|&&
name|function
operator|!=
name|inline_function_decl
operator|&&
name|function
operator|!=
literal|0
condition|)
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|exp
argument_list|,
literal|"prior parameter's size depends on `%s'"
argument_list|)
expr_stmt|;
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
comment|/* ... fall through ...  */
case|case
name|VAR_DECL
case|:
comment|/* If a static var's type was incomplete when the decl was written, 	 but the type is complete now, lay out the decl now.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|layout_decl
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* Although static-storage variables start off initialized, according to 	 ANSI C, a memcpy could overwrite them with uninitialized values.  So 	 we check them too.  This also lets us check for read-only variables 	 accessed via a non-const declaration, in case it won't be detected 	 any other way (e.g., in an embedded system or OS kernel without 	 memory protection).  	 Aggregates are not checked here; they're handled elsewhere.  */
if|if
condition|(
name|current_function_check_memory_usage
operator|&&
name|code
operator|==
name|VAR_DECL
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|memory_use_mode
name|memory_usage
decl_stmt|;
name|memory_usage
operator|=
name|get_memory_usage_from_modifier
argument_list|(
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_usage
operator|!=
name|MEMORY_USE_DONT
condition|)
name|emit_library_call
argument_list|(
name|chkr_check_addr_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|memory_usage
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ... fall through ...  */
case|case
name|FUNCTION_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ensure variable marked as used even if it doesn't go through 	 a parser.  If it hasn't be used yet, write out an external 	 definition.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Show we haven't gotten RTL for this yet.  */
name|temp
operator|=
literal|0
expr_stmt|;
comment|/* Handle variables inherited from containing functions.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* We treat inline_function_decl as an alias for the current function 	 because that is the inline function whose vars, types, etc. 	 are being merged into the current function. 	 See expand_inline_function.  */
if|if
condition|(
name|context
operator|!=
literal|0
operator|&&
name|context
operator|!=
name|current_function_decl
operator|&&
name|context
operator|!=
name|inline_function_decl
comment|/* If var is static, we don't need a static chain to access it.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|;
comment|/* Mark as non-local and addressable.  */
name|DECL_NONLOCAL
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mark_addressable
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MEM
condition|)
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|fix_lexical_addr
argument_list|(
name|addr
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|change_address
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* This is the case of an array whose size is to be determined 	 from its initializer, while the initializer is still being parsed. 	 See expand_decl.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|temp
operator|=
name|change_address
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If DECL_RTL is memory, we are in the normal case and either 	 the address is not valid or it is not a register and -fforce-addr 	 is specified, get the address into a register.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
operator|)
condition|)
name|temp
operator|=
name|change_address
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we got something, return it.  But first, set the alignment 	 the address is a register.  */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|exp
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* If the mode of DECL_RTL does not match that of the decl, it 	 must be a promoted value.  We return a SUBREG of the wanted mode, 	 but mark it so that we know that it was already extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|mode
condition|)
block|{
comment|/* Get the signedness used for this variable.  Ensure we get the 	     same mode we got when the variable was declared.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|temp
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
return|return
name|expand_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_MEMORY_USE_BAD
argument_list|)
return|;
case|case
name|REAL_CST
case|:
comment|/* If optimized, generate immediate CONST_DOUBLE 	 which will be turned into memory by reload if necessary.        	 We used to force a register so that loop.c could see it.  But 	 this does not allow gen_* patterns to perform optimizations with 	 the constants.  It also produces two insns in cases like "x = 1.0;". 	 On most machines, floating-point constants are not permitted in 	 many insns, so we'd end up copying it to a register in any case.  	 Now, we do the copying in expand_binop, if appropriate.  */
return|return
name|immed_real_const
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
case|case
name|STRING_CST
case|:
if|if
condition|(
operator|!
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
condition|)
name|output_constant_def
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* TREE_CST_RTL probably contains a constant address. 	 On RISC machines where a constant address isn't valid, 	 make some insns to get that address into a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
operator|)
condition|)
return|return
name|change_address
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|EXPR_WITH_FILE_LOCATION
case|:
block|{
name|rtx
name|to_return
decl_stmt|;
name|char
modifier|*
name|saved_input_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|saved_lineno
init|=
name|lineno
decl_stmt|;
name|input_filename
operator|=
name|EXPR_WFL_FILENAME
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|EXPR_WFL_LINENO
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_WFL_EMIT_LINE_NOTE
argument_list|(
name|exp
argument_list|)
condition|)
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* Possibly avoid switching back and force here */
name|to_return
operator|=
name|expand_expr
argument_list|(
name|EXPR_WFL_NODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|saved_input_filename
expr_stmt|;
name|lineno
operator|=
name|saved_lineno
expr_stmt|;
return|return
name|to_return
return|;
block|}
case|case
name|SAVE_EXPR
case|:
name|context
operator|=
name|decl_function_context
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If this SAVE_EXPR was at global context, assume we are an 	 initialization function and move it into our context.  */
if|if
condition|(
name|context
operator|==
literal|0
condition|)
name|SAVE_EXPR_CONTEXT
argument_list|(
name|exp
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* We treat inline_function_decl as an alias for the current function 	 because that is the inline function whose vars, types, etc. 	 are being merged into the current function. 	 See expand_inline_function.  */
if|if
condition|(
name|context
operator|==
name|current_function_decl
operator|||
name|context
operator|==
name|inline_function_decl
condition|)
name|context
operator|=
literal|0
expr_stmt|;
comment|/* If this is non-local, handle it.  */
if|if
condition|(
name|context
condition|)
block|{
comment|/* The following call just exists to abort if the context is 	     not of a containing function.  */
name|find_function_data
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|temp
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|put_var_into_stack
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|change_address
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|,
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|temp
operator|=
name|const0_rtx
expr_stmt|;
else|else
name|temp
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
condition|)
name|save_expr_regs
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|save_expr_regs
argument_list|)
expr_stmt|;
comment|/* If the mode of TEMP does not match that of the expression, it 	     must be a promoted value.  We pass store_expr a SUBREG of the 	     wanted mode but mark it so that we know that it was already 	     extended.  Note that `unsignedp' was modified above in 	     this case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|mode
condition|)
block|{
name|temp
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|temp
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_MEMORY_USE_BAD
argument_list|)
expr_stmt|;
else|else
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the mode of SAVE_EXPR_RTL does not match that of the expression, it 	 must be a promoted value.  We return a SUBREG of the wanted mode, 	 but mark it so that we know that it was already extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|mode
condition|)
block|{
comment|/* Compute the signedness and make the proper SUBREG.  */
name|promote_mode
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|temp
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|UNSAVE_EXPR
case|:
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|unsave_expr_now
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|PLACEHOLDER_EXPR
case|:
block|{
name|tree
name|placeholder_expr
decl_stmt|;
comment|/* If there is an object on the head of the placeholder list, 	   see if some object in it of type TYPE or a pointer to it.  For 	   further information, see tree.def.  */
for|for
control|(
name|placeholder_expr
operator|=
name|placeholder_list
init|;
name|placeholder_expr
operator|!=
literal|0
condition|;
name|placeholder_expr
operator|=
name|TREE_CHAIN
argument_list|(
name|placeholder_expr
argument_list|)
control|)
block|{
name|tree
name|need_type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|object
init|=
literal|0
decl_stmt|;
name|tree
name|old_list
init|=
name|placeholder_list
decl_stmt|;
name|tree
name|elt
decl_stmt|;
comment|/* Find the outermost reference that is of the type we want. 	       If none, see if any object has a type that is a pointer to  	       the type we want.  */
for|for
control|(
name|elt
operator|=
name|TREE_PURPOSE
argument_list|(
name|placeholder_expr
argument_list|)
init|;
name|elt
operator|!=
literal|0
operator|&&
name|object
operator|==
literal|0
condition|;
name|elt
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COND_EXPR
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|1
argument_list|)
else|:
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'e'
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
else|:
literal|0
operator|)
control|)
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
name|need_type
condition|)
name|object
operator|=
name|elt
expr_stmt|;
for|for
control|(
name|elt
operator|=
name|TREE_PURPOSE
argument_list|(
name|placeholder_expr
argument_list|)
init|;
name|elt
operator|!=
literal|0
operator|&&
name|object
operator|==
literal|0
condition|;
name|elt
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|COND_EXPR
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|1
argument_list|)
else|:
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
literal|'e'
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
else|:
literal|0
operator|)
control|)
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
operator|==
name|need_type
operator|)
condition|)
name|object
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|need_type
argument_list|,
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|!=
literal|0
condition|)
block|{
comment|/* Expand this object skipping the list entries before 		   it was found in case it is also a PLACEHOLDER_EXPR. 		   In that case, we want to translate it using subsequent 		   entries.  */
name|placeholder_list
operator|=
name|TREE_CHAIN
argument_list|(
name|placeholder_expr
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|object
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
name|placeholder_list
operator|=
name|old_list
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
block|}
comment|/* We can't find the object or there was a missing WITH_RECORD_EXPR.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|WITH_RECORD_EXPR
case|:
comment|/* Put the object on the placeholder list, expand our first operand, 	 and pop the list.  */
name|placeholder_list
operator|=
name|tree_cons
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|placeholder_list
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
name|placeholder_list
operator|=
name|TREE_CHAIN
argument_list|(
name|placeholder_list
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|GOTO_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|expand_goto
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expand_computed_goto
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|EXIT_EXPR
case|:
name|expand_exit_loop_if_false
argument_list|(
name|NULL_PTR
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|LABELED_BLOCK_EXPR
case|:
if|if
condition|(
name|LABELED_BLOCK_BODY
argument_list|(
name|exp
argument_list|)
condition|)
name|expand_expr_stmt
argument_list|(
name|LABELED_BLOCK_BODY
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label_rtx
argument_list|(
name|LABELED_BLOCK_LABEL
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|EXIT_BLOCK_EXPR
case|:
if|if
condition|(
name|EXIT_BLOCK_RETURN
argument_list|(
name|exp
argument_list|)
condition|)
name|sorry
argument_list|(
literal|"returned value in block_exit_expr"
argument_list|)
expr_stmt|;
name|expand_goto
argument_list|(
name|LABELED_BLOCK_LABEL
argument_list|(
name|EXIT_BLOCK_LABELED_BLOCK
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|LOOP_EXPR
case|:
name|push_temp_slots
argument_list|()
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BIND_EXPR
case|:
block|{
name|tree
name|vars
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|vars_need_expansion
init|=
literal|0
decl_stmt|;
comment|/* Need to open a binding contour here because 	   if there are any cleanups they must be contained here.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark the corresponding BLOCK for output in its proper place.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|insert_block
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If VARS have not yet been expanded, expand them now.  */
while|while
condition|(
name|vars
condition|)
block|{
if|if
condition|(
name|DECL_RTL
argument_list|(
name|vars
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vars_need_expansion
operator|=
literal|1
expr_stmt|;
name|expand_decl
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
name|expand_decl_init
argument_list|(
name|vars
argument_list|)
expr_stmt|;
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|RTL_EXPR
case|:
if|if
condition|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
operator|==
name|const0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|exp
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
block|}
name|preserve_rtl_expr_result
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|free_temps_for_rtl_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
comment|/* If we don't need the result, just ensure we evaluate any 	 subexpressions.  */
if|if
condition|(
name|ignore
condition|)
block|{
name|tree
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_MEMORY_USE_BAD
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* All elts simple constants => refer to a constant in memory.  But 	 if this is a non-BLKmode mode, let it store a field at a time 	 since that should make a CONST_INT or CONST_DOUBLE when we 	 fold.  Likewise, if we have a target we can use, it is best to 	 store directly into the target unless the type is large enough 	 that memcpy will be used.  If we are making an initializer and 	 all operands are constant, put it in memory as well.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|&&
operator|!
operator|(
name|target
operator|!=
literal|0
operator|&&
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
operator|!
name|MOVE_BY_PIECES_P
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
operator|)
operator|&&
operator|!
name|mostly_zeros_p
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|&&
name|TREE_CONSTANT
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|constructor
init|=
name|output_constant_def
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
operator|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|constructor
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|constructor
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|constructor
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
operator|)
condition|)
name|constructor
operator|=
name|change_address
argument_list|(
name|constructor
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|constructor
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|constructor
return|;
block|}
else|else
block|{
comment|/* Handle calls that pass values in multiple non-contiguous 	     locations.  The Irix 6 ABI has examples of this.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|target
operator|=
name|copy_rtx
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|store_constructor
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|exp1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|exp2
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|tree
name|string
init|=
name|string_constant
argument_list|(
name|exp1
argument_list|,
operator|&
name|index
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Try to optimize reads from const strings.  */
if|if
condition|(
name|string
operator|&&
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_INT_CST_HIGH
argument_list|(
name|index
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
operator|)
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|string
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
operator|&&
name|modifier
operator|!=
name|EXPAND_MEMORY_USE_WO
condition|)
return|return
name|GEN_INT
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
index|[
name|i
index|]
argument_list|)
return|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|exp1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_check_memory_usage
operator|&&
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|memory_use_mode
name|memory_usage
decl_stmt|;
name|memory_usage
operator|=
name|get_memory_usage_from_modifier
argument_list|(
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_usage
operator|!=
name|MEMORY_USE_DONT
condition|)
block|{
name|in_check_memory_usage
operator|=
literal|1
expr_stmt|;
name|emit_library_call
argument_list|(
name|chkr_check_addr_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|op0
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|memory_usage
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|in_check_memory_usage
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|temp
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|exp1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|exp2
operator|=
name|TREE_OPERAND
argument_list|(
name|exp1
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp2
argument_list|)
argument_list|)
operator|)
condition|)
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|temp
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator||
name|flag_volatile
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|temp
argument_list|)
operator|=
name|get_alias_set
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* It is incorrect to set RTX_UNCHANGING_P from TREE_READONLY 	   here, because, in C and C++, the fact that a location is accessed 	   through a pointer to const does not mean that the value there can 	   never change.  Languages where it can never change should 	   also set TREE_STATIC.  */
name|RTX_UNCHANGING_P
argument_list|(
name|temp
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|{
name|tree
name|array
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|low_bound
init|=
name|domain
condition|?
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
else|:
name|integer_zero_node
decl_stmt|;
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|index_type
init|=
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
comment|/* Optimize the special-case of a zero lower bound.  	   We convert the low_bound to sizetype to avoid some problems 	   with constant folding.  (E.g. suppose the lower bound is 1, 	   and its mode is QI.  Without the conversion,  (ARRAY 	   +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1)) 	   +INDEX), which becomes (ARRAY+255+INDEX).  Oops!)  	   But sizetype isn't quite right either (especially if 	   the lowbound is negative).  FIXME */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|low_bound
argument_list|)
condition|)
name|index
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|index
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|low_bound
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fold an expression like: "foo"[2]. 	   This is not done in fold so it won't happen inside&. 	   Don't fold if this is for wide characters since it's too 	   difficult to do correctly and this is a very rare case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_INT_CST_HIGH
argument_list|(
name|index
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
operator|)
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|array
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
condition|)
return|return
name|GEN_INT
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|array
argument_list|)
index|[
name|i
index|]
argument_list|)
return|;
comment|/* If this is a constant index into a constant array, 	   just get the value from the array.  Handle both the cases when 	   we have an explicit constructor and when our operand is a variable 	   that was declared const.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|index
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|elem
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
name|i
operator|--
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|ro_modifier
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|optimize
operator|>=
literal|1
operator|&&
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|tree
name|elem
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
decl_stmt|;
while|while
condition|(
name|elem
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elem
argument_list|)
argument_list|,
name|index
argument_list|)
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
return|return
name|expand_expr
argument_list|(
name|fold
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|ro_modifier
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|index
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|init
argument_list|)
operator|)
condition|)
return|return
operator|(
name|GEN_INT
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|init
argument_list|)
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
index|]
argument_list|)
operator|)
return|;
block|}
block|}
block|}
comment|/* ... fall through ... */
case|case
name|COMPONENT_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
comment|/* If the operand is a CONSTRUCTOR, we can just extract the 	 appropriate field if it is present.  Don't do this if we have 	 already written the data since we want to refer to that copy 	 and varasm.c assumes that's what we'll do.  */
if|if
condition|(
name|code
operator|!=
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_CST_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
comment|/* We can normally use the value of the field in the 		   CONSTRUCTOR.  However, if this is a bitfield in 		   an integral mode that we can fit in a HOST_WIDE_INT, 		   we must mask only the number of bits in the bitfield, 		   since this is done implicitly by the constructor.  If 		   the bitfield does not meet either of those conditions, 		   we can't do this optimization.  */
operator|&&
operator|(
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|DECL_MODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|DECL_MODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
operator|)
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|bitsize
init|=
name|DECL_FIELD_SIZE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|op1
operator|=
name|GEN_INT
argument_list|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_and
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|machine_mode
name|imode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|count
init|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|imode
argument_list|)
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|imode
argument_list|,
name|op0
argument_list|,
name|count
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|imode
argument_list|,
name|op0
argument_list|,
name|count
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|op0
return|;
block|}
block|}
block|{
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|tree
name|tem
init|=
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode1
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|alignment
argument_list|)
decl_stmt|;
comment|/* If we got back the original object, something is wrong.  Perhaps 	   we are evaluating an expression too early.  In any event, don't 	   infinitely recurse.  */
if|if
condition|(
name|tem
operator|==
name|exp
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If TEM's type is a union of variable size, pass TARGET to the inner 	   computation, since it will need a temporary and TARGET is known 	   to have to do.  This occurs in unchecked conversion in Ada.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|tem
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|?
name|target
else|:
name|NULL_RTX
operator|)
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|?
name|modifier
else|:
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* If this is a constant, put it into a register if it is a 	   legitimate constant and memory if it isn't.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset_rtx
init|=
name|expand_expr
argument_list|(
name|offset
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|ptr_mode
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|offset_rtx
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
else|#
directive|else
name|offset_rtx
operator|=
name|convert_to_mode
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* A constant address in TO_RTX can have VOIDmode, we must not try 	       to call force_reg for that case.  Avoid that case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|bitsize
operator|&&
operator|(
name|bitpos
operator|%
name|bitsize
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bitsize
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|alignment
operator|*
name|BITS_PER_UNIT
operator|)
operator|==
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode1
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|op0
operator|=
name|temp
expr_stmt|;
else|else
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bitpos
operator|=
literal|0
expr_stmt|;
block|}
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|ptr_mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Don't forget about volatility even if this is a bitfield.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|volatilep
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|copy_rtx
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check the access.  */
if|if
condition|(
name|current_function_check_memory_usage
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|enum
name|memory_use_mode
name|memory_usage
decl_stmt|;
name|memory_usage
operator|=
name|get_memory_usage_from_modifier
argument_list|(
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_usage
operator|!=
name|MEMORY_USE_DONT
condition|)
block|{
name|rtx
name|to
decl_stmt|;
name|int
name|size
decl_stmt|;
name|to
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|)
operator|+
name|bitsize
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
expr_stmt|;
comment|/* Check the access right of the pointer.  */
if|if
condition|(
name|size
operator|>
name|BITS_PER_UNIT
condition|)
name|emit_library_call
argument_list|(
name|chkr_check_addr_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|to
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|memory_usage
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* In cases where an aligned union has an unaligned object 	   as a field, we might be extracting a BLKmode value from 	   an integer-mode (e.g., SImode) object.  Handle this case 	   by doing the extract into an object as wide as the field 	   (which we know to be the width of a basic mode), then 	   storing into memory, and changing the mode to BLKmode. 	   If we ultimately want the address (EXPAND_CONST_ADDRESS or 	   EXPAND_INITIALIZER), then we must not copy to a temporary.  */
if|if
condition|(
name|mode1
operator|==
name|VOIDmode
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|modifier
operator|!=
name|EXPAND_CONST_ADDRESS
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|&&
operator|(
operator|(
name|mode1
operator|!=
name|BLKmode
operator|&&
operator|!
name|direct_load
index|[
operator|(
name|int
operator|)
name|mode1
index|]
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_COMPLEX_FLOAT
operator|)
comment|/* If the field isn't aligned enough to fetch as a memref, 		       fetch it as a bit field.  */
operator|||
operator|(
name|SLOW_UNALIGNED_ACCESS
operator|&&
operator|(
operator|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|ext_mode
init|=
name|mode
decl_stmt|;
if|if
condition|(
name|ext_mode
operator|==
name|BLKmode
condition|)
name|ext_mode
operator|=
name|mode_for_size
argument_list|(
name|bitsize
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* In this case, BITPOS must start at a byte boundary and 		   TARGET, if specified, must be a MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|||
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
operator|)
operator|||
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|bitsize
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
name|op0
operator|=
name|validize_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|op0
operator|=
name|extract_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
name|target
argument_list|,
name|ext_mode
argument_list|,
name|ext_mode
argument_list|,
name|alignment
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the result is a record type and BITSIZE is narrower than 	       the mode of OP0, an integral mode, and this is a big endian 	       machine, we must put the field into the high-order bits.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|BYTES_BIG_ENDIAN
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|bitsize
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|op0
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|-
name|bitsize
argument_list|)
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|rtx
name|new
init|=
name|assign_stack_temp
argument_list|(
name|ext_mode
argument_list|,
name|bitsize
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|new
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|copy_rtx
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|op0
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|op0
return|;
block|}
comment|/* If the result is BLKmode, use that to access the object 	   now as well.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|mode1
operator|=
name|BLKmode
expr_stmt|;
comment|/* Get a reference to just this component.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|||
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode1
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bitpos
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|MEM_ALIAS_SET
argument_list|(
name|op0
argument_list|)
operator|=
name|get_alias_set
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
operator||=
name|volatilep
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|mode1
operator|||
name|mode1
operator|==
name|BLKmode
operator|||
name|mode1
operator|==
name|tmode
operator|||
name|modifier
operator|==
name|EXPAND_CONST_ADDRESS
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
return|return
name|op0
return|;
elseif|else
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Intended for a reference to a buffer of a file-object in Pascal. 	 But it's not certain that a special tree code will really be 	 necessary for these.  INDIRECT_REF might work for them.  */
case|case
name|BUFFER_REF
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|IN_EXPR
case|:
block|{
comment|/* Pascal set IN expression.  	   Algorithm: 	       rlo       = set_low - (set_low%bits_per_word); 	       the_word  = set [ (index - rlo)/bits_per_word ]; 	       bit_index = index % bits_per_word; 	       bitmask   = 1<< bit_index; 	       return !!(the_word& bitmask);  */
name|tree
name|set
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|iunsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|set_type
init|=
name|TREE_TYPE
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|tree
name|set_low_bound
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|set_type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|set_high_bound
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|set_type
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|index_val
init|=
name|expand_expr
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|lo_r
init|=
name|expand_expr
argument_list|(
name|set_low_bound
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|hi_r
init|=
name|expand_expr
argument_list|(
name|set_high_bound
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|setval
init|=
name|expand_expr
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|setaddr
init|=
name|XEXP
argument_list|(
name|setval
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|index_mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|rlow
decl_stmt|;
name|rtx
name|diff
decl_stmt|,
name|quo
decl_stmt|,
name|rem
decl_stmt|,
name|addr
decl_stmt|,
name|bit
decl_stmt|,
name|result
decl_stmt|;
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If domain is empty, answer is no.  Likewise if index is constant 	   and out of bounds.  */
if|if
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|set_high_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|set_low_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|set_high_bound
argument_list|,
name|set_low_bound
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|set_low_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|index
argument_list|,
name|set_low_bound
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|set_high_bound
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|set_high_bound
argument_list|,
name|index
argument_list|)
operator|)
operator|)
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
comment|/* If we get here, we have to generate the code for both cases 	   (in range and out of range).  */
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|index_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|lo_r
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index_val
argument_list|,
name|lo_r
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|index_val
argument_list|)
argument_list|,
name|iunsignedp
argument_list|,
literal|0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|index_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|hi_r
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|index_val
argument_list|,
name|hi_r
argument_list|,
name|GT
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|index_val
argument_list|)
argument_list|,
name|iunsignedp
argument_list|,
literal|0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate the element number of bit zero in the first word 	   of the set.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|lo_r
argument_list|)
operator|==
name|CONST_INT
condition|)
name|rlow
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|lo_r
argument_list|)
operator|&
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
else|else
name|rlow
operator|=
name|expand_binop
argument_list|(
name|index_mode
argument_list|,
name|and_optab
argument_list|,
name|lo_r
argument_list|,
name|GEN_INT
argument_list|(
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|BITS_PER_UNIT
operator|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|diff
operator|=
name|expand_binop
argument_list|(
name|index_mode
argument_list|,
name|sub_optab
argument_list|,
name|index_val
argument_list|,
name|rlow
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|quo
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|index_mode
argument_list|,
name|diff
argument_list|,
name|GEN_INT
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|)
expr_stmt|;
name|rem
operator|=
name|expand_divmod
argument_list|(
literal|1
argument_list|,
name|TRUNC_MOD_EXPR
argument_list|,
name|index_mode
argument_list|,
name|index_val
argument_list|,
name|GEN_INT
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|byte_mode
argument_list|,
name|expand_binop
argument_list|(
name|index_mode
argument_list|,
name|add_optab
argument_list|,
name|diff
argument_list|,
name|setaddr
argument_list|,
name|NULL_RTX
argument_list|,
name|iunsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract the bit we want to examine */
name|bit
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|byte_mode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|byte_mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|,
name|rem
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|expand_binop
argument_list|(
name|byte_mode
argument_list|,
name|and_optab
argument_list|,
name|bit
argument_list|,
name|const1_rtx
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|byte_mode
condition|?
name|target
else|:
literal|0
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|target
condition|)
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Output the code to handle the out-of-range case.  */
name|emit_jump
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|WITH_CLEANUP_EXPR
case|:
if|if
condition|(
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* That's it for this cleanup.  */
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|RTL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|CLEANUP_POINT_EXPR
case|:
block|{
comment|/* Start a new binding layer that will keep track of all cleanup 	   actions to be performed.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|target_temp_slot_level
operator|=
name|temp_slot_level
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
comment|/* If we're going to use this value, load it up now.  */
if|if
condition|(
operator|!
name|ignore
condition|)
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|op0
return|;
case|case
name|CALL_EXPR
case|:
comment|/* Check for a built-in function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|subtarget
argument_list|,
name|tmode
argument_list|,
name|ignore
argument_list|)
return|;
comment|/* If this call was expanded already by preexpand_calls, 	 just return the result we got.  */
if|if
condition|(
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
return|;
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|REFERENCE_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
comment|/* Store data into beginning of memory target.  */
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|change_address
argument_list|(
name|target
argument_list|,
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
comment|/* Store this field into a union of the proper type.  */
name|store_field
argument_list|(
name|target
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Return the entire union.  */
return|return
name|target
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
comment|/* If the signedness of the conversion differs and OP0 is 	     a promoted SUBREG, clear that indication since we now 	     have to do the proper extension.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|unsignedp
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op0
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|op0
return|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|op0
return|;
comment|/* If OP0 is a constant, just convert it into the proper mode.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
return|return
name|gen_rtx_fmt_e
argument_list|(
name|unsignedp
condition|?
name|ZERO_EXTEND
else|:
name|SIGN_EXTEND
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|)
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|PLUS_EXPR
case|:
comment|/* We come here from MINUS_EXPR when the second operand is a          constant.  */
name|plus_expr
label|:
name|this_optab
operator|=
name|add_optab
expr_stmt|;
comment|/* If we are adding a constant, an RTL_EXPR that is sp, fp, or ap, and 	 something else, make sure we add the register to the constant and 	 then to the other thing.  This case can occur during strength 	 reduction and doing it this way will produce better code if the 	 frame pointer or argument pointer is eliminated.  	 fold-const.c will ensure that the constant is always in the inner 	 PLUS_EXPR, so the only case we need to do anything about is if 	 sp, ap, or fp is our second argument, in which case we must swap 	 the innermost first argument and our second argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RTL_EXPR
operator|&&
operator|(
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|||
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* If the result is to be ptr_mode and we are adding an integer to 	 something, we might be forming a constant.  So try to use 	 plus_constant.  If it produces a sum and we can't accept it, 	 use force_operand.  This allows P =&ARR[const] to generate 	 efficient code on machines where a SYMBOL_REF is not a valid 	 address.  	 If this is an EXPAND_SUM call, always return the sum.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|||
name|mode
operator|==
name|ptr_mode
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
name|op1
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
name|op1
operator|=
name|force_operand
argument_list|(
name|op1
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|op1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_INT
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
comment|/* Don't go to both_summands if modifier 		     says it's not right to return a PLUS.  */
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
goto|goto
name|binop2
goto|;
goto|goto
name|both_summands
goto|;
block|}
name|op0
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
condition|)
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
block|}
comment|/* No sense saving up arithmetic to be done 	 if it's all in the wrong mode to form part of an address. 	 And force_operand won't know whether to sign-extend or 	 zero-extend.  */
if|if
condition|(
operator|(
name|modifier
operator|!=
name|EXPAND_SUM
operator|&&
name|modifier
operator|!=
name|EXPAND_INITIALIZER
operator|)
operator|||
name|mode
operator|!=
name|ptr_mode
condition|)
goto|goto
name|binop
goto|;
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
name|both_summands
label|:
comment|/* Make sure any term that's a sum with a constant comes last.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|temp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If adding to a sum including a constant, 	 associate it to put the constant outside.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant_term
init|=
name|const0_rtx
decl_stmt|;
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|op0
operator|=
name|temp
expr_stmt|;
comment|/* Ensure that MULT comes first if there is one.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MULT
condition|)
name|op0
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* Let's also eliminate constants from op0 if possible.  */
name|op0
operator|=
name|eliminate_constant_term
argument_list|(
name|op0
argument_list|,
operator|&
name|constant_term
argument_list|)
expr_stmt|;
comment|/* CONSTANT_TERM and XEXP (op1, 1) are known to be constant, so 	     their sum should be a constant.  Form it into OP1, since the  	     result we want will then be OP0 + OP1.  */
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|constant_term
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|op1
operator|=
name|temp
expr_stmt|;
else|else
name|op1
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|constant_term
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Put a constant term last and put a multiplication first.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MULT
condition|)
name|temp
operator|=
name|op1
operator|,
name|op1
operator|=
name|op0
operator|,
name|op0
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
condition|?
name|temp
else|:
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
comment|/* For initializers, we are allowed to return a MINUS of two 	 symbolic constants.  Here we handle all cases when both operands 	 are constant.  */
comment|/* Handle difference of two symbolic constants, 	 for the sake of an initializer.  */
if|if
condition|(
operator|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
operator|)
operator|&&
name|really_constant_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|really_constant_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|ro_modifier
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|ro_modifier
argument_list|)
decl_stmt|;
comment|/* If the last operand is a CONST_INT, use plus_constant of 	     the negated constant.  Else make the MINUS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|op0
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
comment|/* Convert A - const to A + (-const).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|negated
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Deal with the case where we can't negate the constant 	     in TYPE.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_OVERFLOW
argument_list|(
name|negated
argument_list|)
condition|)
block|{
name|tree
name|newtype
init|=
name|signed_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|newop0
init|=
name|convert
argument_list|(
name|newtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newop1
init|=
name|convert
argument_list|(
name|newtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newneg
init|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|newtype
argument_list|,
name|newop1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_OVERFLOW
argument_list|(
name|newneg
argument_list|)
condition|)
return|return
name|expand_expr
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|newtype
argument_list|,
name|newop0
argument_list|,
name|newneg
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|ro_modifier
argument_list|)
return|;
block|}
else|else
block|{
name|exp
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negated
argument_list|)
expr_stmt|;
goto|goto
name|plus_expr
goto|;
block|}
block|}
name|this_optab
operator|=
name|sub_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|MULT_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If first operand is constant, swap them. 	 Thus the following special case checks need only 	 check the second operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
specifier|register
name|tree
name|t1
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|t1
expr_stmt|;
block|}
comment|/* Attempt to return something suitable for generating an 	 indexed address, for machines that support that.  */
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|&&
name|mode
operator|==
name|ptr_mode
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
comment|/* Apply distributive law if OP0 is x+c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* Check for multiplying things that have been extended 	 from a narrower type.  If this machine supports multiplying 	 in that narrower type with a result in the desired type, 	 do it that way, and avoid the explicit type-conversion.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
comment|/* Don't use a widening multiply if a shift will do.  */
operator|&&
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|||
name|exact_log2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* If both operands are extended, they must either both 		  be zero-extended or both be sign-extended.  */
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|innermode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|optab
name|other_optab
init|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|?
name|smul_widen_optab
else|:
name|umul_widen_optab
operator|)
decl_stmt|;
name|this_optab
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE_WIDER_MODE
argument_list|(
name|innermode
argument_list|)
condition|)
block|{
if|if
condition|(
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|binop2
goto|;
block|}
elseif|else
if|if
condition|(
name|other_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|innermode
operator|==
name|word_mode
condition|)
block|{
name|rtx
name|htem
decl_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|other_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|htem
operator|=
name|expand_mult_highpart_adjust
argument_list|(
name|innermode
argument_list|,
name|gen_highpart
argument_list|(
name|innermode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|gen_highpart
argument_list|(
name|innermode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|innermode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|htem
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* Possible optimization: compute the dividend with EXPAND_SUM 	 then if the divisor is constant can optimize the case 	 where some terms of the dividend have coeffs divisible by it.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
case|case
name|RDIV_EXPR
case|:
name|this_optab
operator|=
name|flodiv_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_divmod
argument_list|(
literal|1
argument_list|,
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Not used for C.  */
case|case
name|FIX_TRUNC_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|expand_fix
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|FLOAT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* expand_float can't figure out what to do if FROM has VOIDmode. 	 So give it the correct mode.  With -O, cse will optimize this.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|expand_float
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|NEGATE_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|ABS_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle complex values specially.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
return|return
name|expand_complex_abs
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
comment|/* Unsigned abs is simply the operand.  Testing here means we don't 	 risk generating incorrect code below.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|op0
return|;
return|return
name|expand_abs
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
name|target
operator|=
name|original_target
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* First try to do it with a special MIN or MAX instruction. 	 If that does not win, use a conditional jump to select the proper 	 value.  */
name|this_optab
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
operator|(
name|code
operator|==
name|MIN_EXPR
condition|?
name|umin_optab
else|:
name|umax_optab
operator|)
else|:
operator|(
name|code
operator|==
name|MIN_EXPR
condition|?
name|smin_optab
else|:
name|smax_optab
operator|)
operator|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* At this point, a MEM target is no longer useful; we will get better 	 code without it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|op0
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* If this mode is an integer too wide to compare properly, 	 compare word by word.  Rely on cse to optimize constant cases.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|MAX_EXPR
condition|)
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|,
name|target
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|op0
argument_list|)
expr_stmt|;
else|else
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|NULL_RTX
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|MAX_EXPR
condition|)
name|temp
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|?
name|compare_from_rtx
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|GEU
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
else|:
name|compare_from_rtx
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|GE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|?
name|compare_from_rtx
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|LEU
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
else|:
name|compare_from_rtx
argument_list|(
name|target
argument_list|,
name|op1
argument_list|,
name|LE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|const0_rtx
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|!=
name|const_true_rtx
condition|)
block|{
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|temp
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|temp
argument_list|)
index|]
call|)
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|BIT_NOT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|FFS_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|ffs_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
comment|/* ??? Can optimize bitwise operations with one arg constant. 	 Can optimize (a bitwise1 n) bitwise2 (a bitwise3 b) 	 and (a bitwise1 b) bitwise2 b (etc) 	 but that is probably not worth while.  */
comment|/* BIT_AND_EXPR is for bitwise anding.  TRUTH_AND_EXPR is for anding two 	 boolean values when we want in all cases to compute both of them.  In 	 general it is fastest to do TRUTH_AND_EXPR by computing both operands 	 as actual zero-or-1 values and then bitwise anding.  In cases where 	 there cannot be any side effects, better code would be made by 	 treating TRUTH_AND_EXPR like TRUTH_ANDIF_EXPR; but the question is 	 how to recognize those cases.  */
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
name|this_optab
operator|=
name|and_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
name|this_optab
operator|=
name|ior_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
name|this_optab
operator|=
name|xor_optab
expr_stmt|;
goto|goto
name|binop
goto|;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
comment|/* Could determine the answer when only additive constants differ.  Also, 	 the addition of one can be handled by changing the condition.  */
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|do_store_flag
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* For foo != 0, load foo, and if it is nonzero load 1 instead.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|original_target
operator|&&
name|GET_CODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|original_target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|original_target
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|temp
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* If no set-flag instruction, must generate a conditional 	 store into a temporary variable.  Drop through 	 and handle this like&& and ||.  */
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
if|if
condition|(
operator|!
name|ignore
operator|&&
operator|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
comment|/* Make sure we don't have a hard reg (such as function's return 		 value) live across basic blocks, if not optimizing.  */
operator|||
operator|(
operator|!
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
operator|!=
name|VOIDmode
condition|?
name|tmode
else|:
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|emit_clr_insn
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|exp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|emit_0_to_1_insn
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|ignore
condition|?
name|const0_rtx
else|:
name|target
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The parser is careful to generate TRUTH_NOT_EXPR 	 only with operands that are always zero or one.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
case|case
name|COMPOUND_EXPR
case|:
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|ignore
condition|?
name|const0_rtx
else|:
name|target
operator|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* If we would have a "singleton" (see below) were it not for a 	 conversion in each arm, bring that conversion back out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|true
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|false
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|true
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|operand_equal_p
argument_list|(
name|false
argument_list|,
name|TREE_OPERAND
argument_list|(
name|true
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|false
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|operand_equal_p
argument_list|(
name|true
argument_list|,
name|TREE_OPERAND
argument_list|(
name|false
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|true
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|operand_equal_p
argument_list|(
name|false
argument_list|,
name|TREE_OPERAND
argument_list|(
name|true
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|false
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|operand_equal_p
argument_list|(
name|true
argument_list|,
name|TREE_OPERAND
argument_list|(
name|false
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|expand_expr
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|true
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
block|{
comment|/* Note that COND_EXPRs whose type is a structure or union 	   are required to be constructed to contain assignments of 	   a temporary variable, so that we can evaluate them here 	   for side effect only.  If type is void, we must do likewise.  */
comment|/* If an arm of the branch requires a cleanup, 	   only that cleanup is performed.  */
name|tree
name|singleton
init|=
literal|0
decl_stmt|;
name|tree
name|binary_op
init|=
literal|0
decl_stmt|,
name|unary_op
init|=
literal|0
decl_stmt|;
comment|/* If this is (A ? 1 : 0) and A is a condition, just evaluate it and 	   convert it to our mode, if necessary.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|ignore
condition|)
block|{
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|ro_modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* Check for X ? A + B : A.  If we have this, we can copy A to the 	   output and conditionally add B.  Similarly for unary operations. 	   Don't do this if X has side-effects because those side effects 	   might affect A or B and the "?" operation is a sequence point in 	   ANSI.  (operand_equal_p tests for side effects.)  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|,
name|binary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|,
name|binary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|,
name|unary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|singleton
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|,
name|unary_op
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* If we are not to produce a result, we have no target.  Otherwise, 	   if a target was specified use it; it will not be used as an 	   intermediate target unless it is safe.  If no target, use a  	   temporary.  */
if|if
condition|(
name|ignore
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|original_target
operator|&&
operator|(
name|safe_from_p
argument_list|(
name|original_target
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|singleton
operator|&&
name|GET_CODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|original_target
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|original_target
operator|==
name|var_rtx
argument_list|(
name|singleton
argument_list|)
operator|)
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|mode
ifdef|#
directive|ifdef
name|HAVE_conditional_move
operator|&&
operator|(
operator|!
name|can_conditionally_move_p
argument_list|(
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|REG
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|original_target
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|original_target
argument_list|)
operator|)
condition|)
name|temp
operator|=
name|original_target
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|temp
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we had X ? A + C : A, with C a constant power of 2, and we can 	   do the test of X as a store-flag operation, do this as 	   A + ((X != 0)<< log C).  Similarly for other simple binary 	   operators.  Only do for C == 1 if BRANCH_COST is low.  */
if|if
condition|(
name|temp
operator|&&
name|singleton
operator|&&
name|binary_op
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|MINUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|BIT_XOR_EXPR
operator|)
operator|&&
operator|(
name|BRANCH_COST
operator|>=
literal|3
condition|?
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|rtx
name|result
decl_stmt|;
name|optab
name|boptab
init|=
operator|(
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|PLUS_EXPR
condition|?
name|add_optab
else|:
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|MINUS_EXPR
condition|?
name|sub_optab
else|:
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|?
name|ior_optab
else|:
name|xor_optab
operator|)
decl_stmt|;
comment|/* If we had X ? A : A + 1, do this as A + (X == 0).  	       We have to invert the truth value here and then put it 	       back later if do_store_flag fails.  We cannot simply copy 	       TREE_OPERAND (exp, 0) to another variable and modify that 	       because invert_truthvalue can modify the tree pointed to 	       by its argument.  */
if|if
condition|(
name|singleton
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|do_store_flag
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|singleton
argument_list|,
literal|1
argument_list|)
condition|?
name|temp
else|:
name|NULL_RTX
operator|)
argument_list|,
name|mode
argument_list|,
name|BRANCH_COST
operator|<=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
operator|&&
operator|!
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|result
argument_list|,
name|build_int_2
argument_list|(
name|tree_log2
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|singleton
argument_list|,
literal|1
argument_list|)
condition|?
name|temp
else|:
name|NULL_RTX
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|op1
operator|=
name|expand_expr
argument_list|(
name|singleton
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|boptab
argument_list|,
name|op1
argument_list|,
name|result
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|singleton
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|op0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|singleton
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
comment|/* If the target conflicts with the other operand of the 		   binary op, we can't use it.  Also, we can't use the target 		   if it is a hard register, because evaluating the condition 		   might clobber it.  */
if|if
condition|(
operator|(
name|binary_op
operator|&&
operator|!
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|singleton
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_expr
argument_list|(
name|singleton
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|singleton
operator|==
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|jumpif
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
else|else
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
if|if
condition|(
name|binary_op
operator|&&
name|temp
operator|==
literal|0
condition|)
comment|/* Just touch the other operand.  */
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|binary_op
condition|)
name|store_expr
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|binary_op
argument_list|)
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|temp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|binary_op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|store_expr
argument_list|(
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|unary_op
argument_list|)
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
block|}
comment|/* Check for A op 0 ? A : FOO and A op 0 ? FOO : A where OP is any 	   comparison operator.  If we have one of these cases, set the 	   output to A, branch on A (cse will merge these two references), 	   then set the output to FOO.  */
elseif|else
if|if
condition|(
name|temp
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SAVE_EXPR
operator|)
operator|&&
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jumpif
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|SAVE_EXPR
operator|)
operator|&&
name|safe_from_p
argument_list|(
name|temp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jumpifnot
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|store_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
return|return
name|temp
return|;
block|}
case|case
name|TARGET_EXPR
case|:
block|{
comment|/* Something needs to be initialized, but we didn't know 	   where that thing was when building the tree.  For example, 	   it could be the return value of a function, or a parameter 	   to a function which lays down in the stack, or a temporary 	   variable which must be passed by reference.  	   We guarantee that the expression will either be constructed 	   or copied into our original target.  */
name|tree
name|slot
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cleanups
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|exp1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|slot
argument_list|)
operator|!=
name|VAR_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ignore
condition|)
name|target
operator|=
name|original_target
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|target
operator|=
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* If we have already expanded the slot, so don't do 		   it again.  (mrs)  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|target
return|;
block|}
else|else
block|{
name|target
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* All temp slots at this level must not conflict.  */
name|preserve_temp_slots
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|TREE_ADDRESSABLE
argument_list|(
name|slot
argument_list|)
operator|=
literal|0
expr_stmt|;
name|mark_addressable
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
comment|/* Since SLOT is not known to the called function 		   to belong to its stack frame, we must build an explicit 		   cleanup.  This case occurs when we must build up a reference 		   to pass the reference as an argument.  In this case, 		   it is very likely that such a reference need not be 		   built here.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
name|maybe_build_cleanup
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|cleanups
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This case does occur, when expanding a parameter which 	       needs to be constructed on the stack.  The target 	       is the actual stack address that we want to initialize. 	       The function we call will perform the cleanup in this case.  */
comment|/* If we have already assigned it space, use that space, 	       not target that we were passed in, as our target 	       parameter is only a hint.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|target
operator|=
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* If we have already expanded the slot, so don't do                    it again.  (mrs)  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|target
return|;
block|}
else|else
block|{
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|=
name|target
expr_stmt|;
comment|/* If we must have an addressable slot, then make sure that 		   the RTL that we just stored in slot is OK.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|TREE_ADDRESSABLE
argument_list|(
name|slot
argument_list|)
operator|=
literal|0
expr_stmt|;
name|mark_addressable
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|exp1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|3
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Mark it as expanded.  */
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_USED
argument_list|(
name|slot
argument_list|)
operator|=
literal|1
expr_stmt|;
name|store_expr
argument_list|(
name|exp1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanups
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|INIT_EXPR
case|:
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|noncopied_parts
init|=
literal|0
decl_stmt|;
name|tree
name|lhs_type
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|temp
operator|=
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
operator|!
name|ignore
argument_list|,
name|original_target
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|lhs_type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|fixed_type_p
argument_list|(
name|rhs
argument_list|)
condition|)
name|noncopied_parts
operator|=
name|init_noncopied_parts
argument_list|(
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|lhs_type
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|noncopied_parts
operator|!=
literal|0
condition|)
block|{
name|expand_assignment
argument_list|(
name|TREE_VALUE
argument_list|(
name|noncopied_parts
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|noncopied_parts
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|noncopied_parts
operator|=
name|TREE_CHAIN
argument_list|(
name|noncopied_parts
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
case|case
name|MODIFY_EXPR
case|:
block|{
comment|/* If lhs is complex, expand calls in rhs before computing it. 	   That's so we don't compute a pointer and save it over a call. 	   If lhs is simple, compute it first so we can give it as a 	   target if the rhs is just a call.  This avoids an extra temp and copy 	   and that prevents a partial-subsumption which makes bad code. 	   Actually we could treat component_ref's of vars like vars.  */
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|noncopied_parts
init|=
literal|0
decl_stmt|;
name|tree
name|lhs_type
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|RESULT_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Check for |= or&= of a bitfield of size one into another bitfield 	   of size 1.  In this case, (unless we need the result of the 	   assignment) we can do this more efficiently with a 	   test followed by an assignment, if necessary.  	   ??? At this point, we can't get a BIT_FIELD_REF here.  But if 	   things change so we do, this code should be enhanced to 	   support it.  */
if|if
condition|(
name|ignore
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_IOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|lhs
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|?
name|label
else|:
literal|0
argument_list|,
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|?
name|label
else|:
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|lhs_type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|fixed_type_p
argument_list|(
name|lhs
argument_list|)
operator|&&
name|fixed_type_p
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
name|noncopied_parts
operator|=
name|save_noncopied_parts
argument_list|(
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|lhs_type
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_assignment
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
operator|!
name|ignore
argument_list|,
name|original_target
operator|!=
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|noncopied_parts
operator|!=
literal|0
condition|)
block|{
name|expand_assignment
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|noncopied_parts
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|noncopied_parts
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|noncopied_parts
operator|=
name|TREE_CHAIN
argument_list|(
name|noncopied_parts
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
case|case
name|RETURN_EXPR
case|:
if|if
condition|(
operator|!
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
name|expand_null_return
argument_list|()
expr_stmt|;
else|else
name|expand_return
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
return|return
name|expand_increment
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Faster to treat as pre-increment if result is not used.  */
return|return
name|expand_increment
argument_list|(
name|exp
argument_list|,
operator|!
name|ignore
argument_list|,
name|ignore
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
comment|/* If nonzero, TEMP will be set to the address of something that might 	 be a MEM corresponding to a stack slot.  */
name|temp
operator|=
literal|0
expr_stmt|;
comment|/* Are we taking the address of a nested function?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|decl_function_context
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|op0
operator|=
name|trampoline_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
comment|/* If we are taking the address of something erroneous, just 	 return a zero.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|const0_rtx
return|;
else|else
block|{
comment|/* We make sure to pass const0_rtx down if we came in with 	     ignore set, to avoid doing the cleanups twice for something.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ignore
condition|?
name|const0_rtx
else|:
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|?
name|modifier
else|:
name|EXPAND_CONST_ADDRESS
operator|)
argument_list|)
expr_stmt|;
comment|/* If we are going to ignore the result, OP0 will have been set 	     to const0_rtx, so just return it.  Don't get confused and 	     think we are taking the address of the constant.  */
if|if
condition|(
name|ignore
condition|)
return|return
name|op0
return|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We would like the object in memory.  If it is a constant, 	     we can have it be statically allocated into memory.  For 	     a non-constant (REG, SUBREG or CONCAT), we need to allocate some 	     memory and store the value into it.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|force_const_mem
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|mark_temp_addr_taken
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONCAT
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
comment|/* If this object is in a register, it must be not 		 be BLKmode.  */
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|memloc
init|=
name|assign_temp
argument_list|(
name|inner_type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|mark_temp_addr_taken
argument_list|(
name|memloc
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|memloc
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|memloc
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
name|EXPAND_SUM
operator|||
name|modifier
operator|==
name|EXPAND_INITIALIZER
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|==
name|ptr_mode
condition|)
name|temp
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|temp
return|;
block|}
name|op0
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_force_addr
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|op0
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|op0
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* If we might have had a temp slot, add an equivalent address 	 for it.  */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|update_temp_slot_address
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|Pmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|==
name|ptr_mode
condition|)
name|op0
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|op0
return|;
case|case
name|ENTRY_VALUE_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* COMPLEX type for Extended Pascal& Fortran  */
case|case
name|COMPLEX_EXPR
case|:
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
comment|/* Get the rtx code of the operands.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Move the real (op0) and imaginary (op1) parts to their location.  */
name|emit_move_insn
argument_list|(
name|gen_realpart
argument_list|(
name|mode
argument_list|,
name|target
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_imagpart
argument_list|(
name|mode
argument_list|,
name|target
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Complex construction should appear as a single unit.  */
comment|/* If TARGET is a CONCAT, we got insns like RD = RS, ID = IS, 	   each with a separate pseudo as destination. 	   It's not correct for flow to treat them as a unit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|CONCAT
condition|)
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|REALPART_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_realpart
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
case|case
name|IMAGPART_EXPR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_imagpart
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
return|;
case|case
name|CONJ_EXPR
case|:
block|{
name|enum
name|machine_mode
name|partmode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|imag_t
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Store the realpart and the negated imagpart to target.  */
name|emit_move_insn
argument_list|(
name|gen_realpart
argument_list|(
name|partmode
argument_list|,
name|target
argument_list|)
argument_list|,
name|gen_realpart
argument_list|(
name|partmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|imag_t
operator|=
name|gen_imagpart
argument_list|(
name|partmode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|partmode
argument_list|,
name|neg_optab
argument_list|,
name|gen_imagpart
argument_list|(
name|partmode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|imag_t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|imag_t
condition|)
name|emit_move_insn
argument_list|(
name|imag_t
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Conjugate should appear as a single unit  	   If TARGET is a CONCAT, we got insns like RD = RS, ID = - IS, 	   each with a separate pseudo as destination. 	   It's not correct for flow to treat them as a unit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|CONCAT
condition|)
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
case|case
name|TRY_CATCH_EXPR
case|:
block|{
name|tree
name|handler
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_eh_region_end
argument_list|(
name|handler
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
case|case
name|TRY_FINALLY_EXPR
case|:
block|{
name|tree
name|try_block
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|finally_block
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|finally_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|done_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|return_link
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|tree
name|cleanup
init|=
name|build
argument_list|(
name|GOTO_SUBROUTINE_EXPR
argument_list|,
name|void_type_node
argument_list|,
operator|(
name|tree
operator|)
name|finally_label
argument_list|,
operator|(
name|tree
operator|)
name|return_link
argument_list|)
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|cleanup
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Start a new binding layer that will keep track of all cleanup 	   actions to be performed.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|target_temp_slot_level
operator|=
name|temp_slot_level
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|try_block
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|done_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|finally_label
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|finally_block
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|return_link
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|done_label
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
case|case
name|GOTO_SUBROUTINE_EXPR
case|:
block|{
name|rtx
name|subr
init|=
operator|(
name|rtx
operator|)
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|return_link
init|=
operator|*
operator|(
name|rtx
operator|*
operator|)
operator|&
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|return_address
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_move_insn
argument_list|(
name|return_link
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|return_address
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|subr
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|return_address
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
case|case
name|POPDCC_EXPR
case|:
block|{
name|rtx
name|dcc
init|=
name|get_dynamic_cleanup_chain
argument_list|()
decl_stmt|;
name|emit_move_insn
argument_list|(
name|dcc
argument_list|,
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|dcc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
case|case
name|POPDHC_EXPR
case|:
block|{
name|rtx
name|dhc
init|=
name|get_dynamic_handler_chain
argument_list|()
decl_stmt|;
name|emit_move_insn
argument_list|(
name|dhc
argument_list|,
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|dhc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
default|default:
return|return
call|(
modifier|*
name|lang_expand_expr
call|)
argument_list|(
name|exp
argument_list|,
name|original_target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
comment|/* Here to do an ordinary binary operator, generating an instruction      from the optab already placed in `this_optab'.  */
name|binop
label|:
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binop2
label|:
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the alignment in bits of EXP, a pointer valued expression.    But don't return more than MAX_ALIGN no matter what.    The alignment returned is, by default, the alignment of the thing that    EXP points to (if it is not a POINTER_TYPE, 0 is returned).     Otherwise, look at the expression to see if we can do better, i.e., if the    expression is actually pointing at an object whose alignment is tighter.  */
end_comment

begin_function
specifier|static
name|int
name|get_pointer_alignment
parameter_list|(
name|exp
parameter_list|,
name|max_align
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|unsigned
name|max_align
decl_stmt|;
block|{
name|unsigned
name|align
decl_stmt|,
name|inner
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|max_align
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|align
return|;
name|inner
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|inner
argument_list|,
name|max_align
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
comment|/* If sum of pointer + int, restrict our maximum alignment to that 	     imposed by the integer.  If not, we can't do any better than 	     ALIGN.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|align
return|;
while|while
condition|(
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|&
operator|(
name|max_align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|max_align
operator|>>=
literal|1
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* See what we are pointing at and look at its alignment.  */
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|align
operator|=
name|FUNCTION_BOUNDARY
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|exp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'c'
condition|)
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|MIN
argument_list|(
name|align
argument_list|,
name|max_align
argument_list|)
return|;
default|default:
return|return
name|align
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the tree node and offset if a given argument corresponds to    a string constant.  */
end_comment

begin_function
specifier|static
name|tree
name|string_constant
parameter_list|(
name|arg
parameter_list|,
name|ptr_offset
parameter_list|)
name|tree
name|arg
decl_stmt|;
name|tree
modifier|*
name|ptr_offset
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
operator|*
name|ptr_offset
operator|=
name|integer_zero_node
expr_stmt|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
operator|*
name|ptr_offset
operator|=
name|arg1
expr_stmt|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
operator|*
name|ptr_offset
operator|=
name|arg0
expr_stmt|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the length of a C string.  TREE_STRING_LENGTH is not the right    way, because it could contain a zero byte in the middle.    TREE_STRING_LENGTH is the size of the character array, not the string.     Unfortunately, string_constant can't access the values of const char    arrays with initializers, so neither can we do so here.  */
end_comment

begin_function
specifier|static
name|tree
name|c_strlen
parameter_list|(
name|src
parameter_list|)
name|tree
name|src
decl_stmt|;
block|{
name|tree
name|offset_node
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|max
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|src
operator|=
name|string_constant
argument_list|(
name|src
argument_list|,
operator|&
name|offset_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|max
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_node
operator|&&
name|TREE_CODE
argument_list|(
name|offset_node
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* If the string has an internal zero byte (e.g., "foo\0bar"), we can't 	 compute the offset to the following null if we don't know where to 	 start searching for it.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We don't know the starting offset, but we do know that the string 	 has no internal zero bytes.  We can assume that the offset falls 	 within the bounds of the string; otherwise, the programmer deserves 	 what he gets.  Subtract the offset from the length of the string, 	 and return that.  */
comment|/* This would perhaps not be valid if we were dealing with named          arrays in addition to literal string constants.  */
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size_int
argument_list|(
name|max
argument_list|)
argument_list|,
name|offset_node
argument_list|)
return|;
block|}
comment|/* We have a known offset into the string.  Start searching there for      a null character.  */
if|if
condition|(
name|offset_node
operator|==
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Did we get a long long offset?  If so, punt.  */
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|offset_node
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|offset_node
argument_list|)
expr_stmt|;
block|}
comment|/* If the offset is known to be out of bounds, warn, and call strlen at      runtime.  */
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>
name|max
condition|)
block|{
name|warning
argument_list|(
literal|"offset outside bounds of constant string"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Use strlen to search for the first zero byte.  Since any strings      constructed with build_string will have nulls appended, we win even      if we get handed something like (char[4])"abcd".       Since OFFSET is our starting index into the string, no further      calculation is needed.  */
return|return
name|size_int
argument_list|(
name|strlen
argument_list|(
name|ptr
operator|+
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|expand_builtin_return_addr
parameter_list|(
name|fndecl_code
parameter_list|,
name|count
parameter_list|,
name|tem
parameter_list|)
name|enum
name|built_in_function
name|fndecl_code
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Some machines need special handling before we can access      arbitrary frames.  For example, on the sparc, we must first flush      all register windows to the stack.  */
ifdef|#
directive|ifdef
name|SETUP_FRAME_ADDRESSES
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|SETUP_FRAME_ADDRESSES
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* On the sparc, the return address is not in the frame, it is in a      register.  There is no way to access it off of the current frame      pointer, but it can be accessed off the previous frame pointer by      reading the value from the register window save area.  */
ifdef|#
directive|ifdef
name|RETURN_ADDR_IN_PREVIOUS_FRAME
if|if
condition|(
name|fndecl_code
operator|==
name|BUILT_IN_RETURN_ADDRESS
condition|)
name|count
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* Scan back COUNT frames to the specified frame.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Assume the dynamic chain pointer is in the word that the 	 frame address points to, unless otherwise specified.  */
ifdef|#
directive|ifdef
name|DYNAMIC_CHAIN_ADDRESS
name|tem
operator|=
name|DYNAMIC_CHAIN_ADDRESS
argument_list|(
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tem
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|copy_to_reg
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For __builtin_frame_address, return what we've got.  */
if|if
condition|(
name|fndecl_code
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
return|return
name|tem
return|;
comment|/* For __builtin_return_address, Get the return address from that      frame.  */
ifdef|#
directive|ifdef
name|RETURN_ADDR_RTX
name|tem
operator|=
name|RETURN_ADDR_RTX
argument_list|(
name|count
argument_list|,
name|tem
argument_list|)
expr_stmt|;
else|#
directive|else
name|tem
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|tem
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Construct the leading half of a __builtin_setjmp call.  Control will    return to RECEIVER_LABEL.  This is used directly by sjlj exception    handling code.  */
end_comment

begin_function
name|void
name|expand_builtin_setjmp_setup
parameter_list|(
name|buf_addr
parameter_list|,
name|receiver_label
parameter_list|)
name|rtx
name|buf_addr
decl_stmt|;
name|rtx
name|receiver_label
decl_stmt|;
block|{
name|enum
name|machine_mode
name|sa_mode
init|=
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
decl_stmt|;
name|rtx
name|stack_save
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|buf_addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf_addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* We store the frame pointer and the address of receiver_label in      the buffer and use the rest of it for the stack save area, which      is machine-dependent.  */
ifndef|#
directive|ifndef
name|BUILTIN_SETJMP_FRAME_VALUE
define|#
directive|define
name|BUILTIN_SETJMP_FRAME_VALUE
value|virtual_stack_vars_rtx
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
argument_list|,
name|BUILTIN_SETJMP_FRAME_VALUE
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|receiver_label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stack_save
operator|=
name|gen_rtx_MEM
argument_list|(
name|sa_mode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|stack_save
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* If there is further processing to do, do it.  */
ifdef|#
directive|ifdef
name|HAVE_builtin_setjmp_setup
if|if
condition|(
name|HAVE_builtin_setjmp_setup
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_setjmp_setup
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Tell optimize_save_area_alloca that extra work is going to      need to go on during alloca.  */
name|current_function_calls_setjmp
operator|=
literal|1
expr_stmt|;
comment|/* Set this so all the registers get saved in our frame; we need to be      able to copy the saved values for any registers from frames we unwind. */
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct the trailing part of a __builtin_setjmp call.    This is used directly by sjlj exception handling code.  */
end_comment

begin_function
name|void
name|expand_builtin_setjmp_receiver
parameter_list|(
name|receiver_label
parameter_list|)
name|rtx
name|receiver_label
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Clobber the FP when we get here, so we have to make sure it's      marked as used by this function.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the static chain as clobbered here so life information      doesn't get messed up for it.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|static_chain_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now put in the code to restore the frame pointer, and argument      pointer, if needed.  The code below is from expand_end_bindings      in stmt.c; see detailed documentation there.  */
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto
if|if
condition|(
operator|!
name|HAVE_nonlocal_goto
condition|)
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
name|size_t
name|i
decl_stmt|;
specifier|static
struct|struct
name|elims
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|elim_regs
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|elim_regs
operator|/
sizeof|sizeof
name|elim_regs
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elim_regs
index|[
name|i
index|]
operator|.
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|elim_regs
index|[
name|i
index|]
operator|.
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
break|break;
if|if
condition|(
name|i
operator|==
sizeof|sizeof
name|elim_regs
operator|/
sizeof|sizeof
name|elim_regs
index|[
literal|0
index|]
condition|)
endif|#
directive|endif
block|{
comment|/* Now restore our arg pointer from the address at which it 	     was saved in our stack frame. 	     If there hasn't be space allocated for it yet, make 	     some now.  */
if|if
condition|(
name|arg_pointer_save_area
operator|==
literal|0
condition|)
name|arg_pointer_save_area
operator|=
name|assign_stack_local
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|copy_to_reg
argument_list|(
name|arg_pointer_save_area
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_builtin_setjmp_receiver
if|if
condition|(
name|HAVE_builtin_setjmp_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_setjmp_receiver
argument_list|(
name|receiver_label
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_nonlocal_goto_receiver
if|if
condition|(
name|HAVE_nonlocal_goto_receiver
condition|)
name|emit_insn
argument_list|(
name|gen_nonlocal_goto_receiver
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
empty_stmt|;
comment|/* Nothing */
block|}
comment|/* @@@ This is a kludge.  Not all machine descriptions define a blockage      insn, but we must not allow the code we just generated to be reordered      by scheduling.  Specifically, the update of the frame pointer must      happen immediately, not later.  So emit an ASM_INPUT to act as blockage      insn.  */
name|emit_insn
argument_list|(
name|gen_rtx_ASM_INPUT
argument_list|(
name|VOIDmode
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __builtin_setjmp is passed a pointer to an array of five words (not    all will be used on all machines).  It operates similarly to the C    library function of the same name, but is more efficient.  Much of    the code below (and for longjmp) is copied from the handling of    non-local gotos.     NOTE: This is intended for use by GNAT and the exception handling    scheme in the compiler and will only work in the method used by    them.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_setjmp
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|buf_addr
decl_stmt|,
name|next_lab
decl_stmt|,
name|cont_lab
decl_stmt|;
if|if
condition|(
name|arglist
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|buf_addr
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next_lab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|cont_lab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|expand_builtin_setjmp_setup
argument_list|(
name|buf_addr
argument_list|,
name|next_lab
argument_list|)
expr_stmt|;
comment|/* Set TARGET to zero and branch to the continue label.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|cont_lab
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|next_lab
argument_list|)
expr_stmt|;
name|expand_builtin_setjmp_receiver
argument_list|(
name|next_lab
argument_list|)
expr_stmt|;
comment|/* Set TARGET to one.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cont_lab
argument_list|)
expr_stmt|;
comment|/* Tell flow about the strange goings on.  Putting `next_lab' on      `nonlocal_goto_handler_labels' to indicates that function      calls may traverse the arc back to this label.  */
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
name|nonlocal_goto_handler_labels
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|next_lab
argument_list|,
name|nonlocal_goto_handler_labels
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
name|void
name|expand_builtin_longjmp
parameter_list|(
name|buf_addr
parameter_list|,
name|value
parameter_list|)
name|rtx
name|buf_addr
decl_stmt|,
name|value
decl_stmt|;
block|{
name|rtx
name|fp
decl_stmt|,
name|lab
decl_stmt|,
name|stack
decl_stmt|;
name|enum
name|machine_mode
name|sa_mode
init|=
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|buf_addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf_addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
comment|/* We used to store value in static_chain_rtx, but that fails if pointers      are smaller than integers.  We instead require that the user must pass      a second argument of 1, because that is what builtin_setjmp will      return.  This also makes EH slightly more efficient, since we are no      longer copying around a value that we don't care about.  */
if|if
condition|(
name|value
operator|!=
name|const1_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_builtin_longjmp
if|if
condition|(
name|HAVE_builtin_longjmp
condition|)
name|emit_insn
argument_list|(
name|gen_builtin_longjmp
argument_list|(
name|buf_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|fp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|buf_addr
argument_list|)
expr_stmt|;
name|lab
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|=
name|gen_rtx_MEM
argument_list|(
name|sa_mode
argument_list|,
name|plus_constant
argument_list|(
name|buf_addr
argument_list|,
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pick up FP, label, and SP from the block and jump.  This code is 	 from expand_goto in stmt.c; see there for detailed comments.  */
if|#
directive|if
name|HAVE_nonlocal_goto
if|if
condition|(
name|HAVE_nonlocal_goto
condition|)
comment|/* We have to pass a value to the nonlocal_goto pattern that will 	   get copied into the static_chain pointer, but it does not matter 	   what that value is, because builtin_setjmp does not use it.  */
name|emit_insn
argument_list|(
name|gen_nonlocal_goto
argument_list|(
name|value
argument_list|,
name|fp
argument_list|,
name|stack
argument_list|,
name|lab
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|lab
operator|=
name|copy_to_reg
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|stack
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|rtx
name|get_memory_rtx
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|rtx
name|mem
decl_stmt|;
name|int
name|is_aggregate
decl_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_SUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Figure out the type of the object pointed to.  Set MEM_IN_STRUCT_P      if the value is the address of a structure or if the expression is      cast to a pointer to structure type.  */
name|is_aggregate
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|tree
name|cast_type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cast_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|cast_type
argument_list|)
argument_list|)
condition|)
block|{
name|is_aggregate
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_aggregate
operator|==
literal|0
condition|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
comment|/* If this is the address of an object, check whether the 	   object is an array.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|is_aggregate
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|MEM_SET_IN_STRUCT_P
argument_list|(
name|mem
argument_list|,
name|is_aggregate
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_define
define|#
directive|define
name|CALLED_AS_BUILT_IN
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), "__builtin_", 10))
end_define

begin_function
specifier|static
name|rtx
name|expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|,
name|mode
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|ignore
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|lab1
decl_stmt|,
name|insns
decl_stmt|;
name|enum
name|machine_mode
name|value_mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|optab
name|builtin_optab
decl_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_FABS
case|:
comment|/* build_function_call changes these into ABS_EXPR.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|BUILT_IN_SIN
case|:
case|case
name|BUILT_IN_COS
case|:
comment|/* Treat these like sqrt, but only if the user asks for them.  */
if|if
condition|(
operator|!
name|flag_fast_math
condition|)
break|break;
case|case
name|BUILT_IN_FSQRT
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be wrong type if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
break|break;
comment|/* Stabilize and compute the argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
name|exp
operator|=
name|copy_node
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|copy_node
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|arglist
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
operator|=
name|save_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a suitable register to place result in.  */
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_SIN
case|:
name|builtin_optab
operator|=
name|sin_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_COS
case|:
name|builtin_optab
operator|=
name|cos_optab
expr_stmt|;
break|break;
case|case
name|BUILT_IN_FSQRT
case|:
name|builtin_optab
operator|=
name|sqrt_optab
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Compute into TARGET. 	 Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builtin_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we were unable to expand via the builtin, stop the 	 sequence (without outputting the insns) and break, causing 	 a call to the library function.  */
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Check the results by default.  But if flag_fast_math is turned on, 	 then assume sqrt will always be called with valid arguments.  */
if|if
condition|(
name|flag_errno_math
operator|&&
operator|!
name|flag_fast_math
condition|)
block|{
comment|/* Don't define the builtin FP instructions 	     if your machine is not IEEE.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|lab1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Test the result; if it is NaN, set errno=EDOM because 	     the argument was not in the domain.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_EDOM
block|{
ifdef|#
directive|ifdef
name|GEN_ERRNO_RTX
name|rtx
name|errno_rtx
init|=
name|GEN_ERRNO_RTX
decl_stmt|;
else|#
directive|else
name|rtx
name|errno_rtx
init|=
name|gen_rtx_MEM
argument_list|(
name|word_mode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"errno"
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|errno_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_EDOM
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* We can't set errno=EDOM directly; let the library call do it. 	     Pop the arguments right away in case the call gets deleted.  */
name|NO_DEFER_POP
expr_stmt|;
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
endif|#
directive|endif
name|emit_label
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
block|}
comment|/* Output the entire sequence.  */
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|BUILT_IN_FMOD
case|:
break|break;
comment|/* __builtin_apply_args returns block of memory allocated on 	 the stack into which is stored the arg pointer, structure 	 value address, static chain, and all the registers that might 	 possibly be used in performing a function call.  The code is 	 moved to the start of the function so the incoming values are 	 saved.  */
case|case
name|BUILT_IN_APPLY_ARGS
case|:
comment|/* Don't do __builtin_apply_args more than once in a function. 	 Save the result of the first call and reuse it.  */
if|if
condition|(
name|apply_args_value
operator|!=
literal|0
condition|)
return|return
name|apply_args_value
return|;
block|{
comment|/* When this function is called, it means that registers must be 	   saved on entry to this function.  So we migrate the 	   call to the first insn of this function.  */
name|rtx
name|temp
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|expand_builtin_apply_args
argument_list|()
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|apply_args_value
operator|=
name|temp
expr_stmt|;
comment|/* Put the sequence after the NOTE that starts the function. 	   If this is inside a SEQUENCE, make the outer-level insn 	   chain current, so the code is placed at the start of the 	   function.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|NEXT_INSN
argument_list|(
name|get_insns
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* __builtin_apply (FUNCTION, ARGUMENTS, ARGSIZE) invokes 	 FUNCTION with a copy of the parameters described by 	 ARGUMENTS, and ARGSIZE.  It returns a block of memory 	 allocated on the stack into which is stored all the registers 	 that might possibly be used for returning the result of a 	 function.  ARGUMENTS is the value returned by 	 __builtin_apply_args.  ARGSIZE is the number of bytes of 	 arguments that must be copied.  ??? How should this value be 	 computed?  We'll also need a safe worst case value for varargs 	 functions.  */
case|case
name|BUILT_IN_APPLY
case|:
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
name|const0_rtx
return|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|t
operator|=
name|arglist
operator|,
name|i
operator|=
literal|0
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
name|i
operator|++
control|)
name|ops
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_builtin_apply
argument_list|(
name|ops
index|[
literal|0
index|]
argument_list|,
name|ops
index|[
literal|1
index|]
argument_list|,
name|ops
index|[
literal|2
index|]
argument_list|)
return|;
block|}
comment|/* __builtin_return (RESULT) causes the function to return the 	 value described by RESULT.  RESULT is address of the block of 	 memory returned by __builtin_apply.  */
case|case
name|BUILT_IN_RETURN
case|:
if|if
condition|(
name|arglist
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|expand_builtin_return
argument_list|(
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_SAVEREGS
case|:
comment|/* Don't do __builtin_saveregs more than once in a function. 	 Save the result of the first call and reuse it.  */
if|if
condition|(
name|saveregs_value
operator|!=
literal|0
condition|)
return|return
name|saveregs_value
return|;
block|{
comment|/* When this function is called, it means that registers must be 	   saved on entry to this function.  So we migrate the 	   call to the first insn of this function.  */
name|rtx
name|temp
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* Now really call the function.  `expand_call' does not call 	   expand_builtin, so there is no danger of infinite recursion here.  */
name|start_sequence
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPAND_BUILTIN_SAVEREGS
comment|/* Do whatever the machine needs done in this case.  */
name|temp
operator|=
name|EXPAND_BUILTIN_SAVEREGS
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* The register where the function returns its value 	   is likely to have something else in it, such as an argument. 	   So preserve that register around the call.  */
if|if
condition|(
name|value_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|rtx
name|valreg
init|=
name|hard_libcall_value
argument_list|(
name|value_mode
argument_list|)
decl_stmt|;
name|rtx
name|saved_valreg
init|=
name|gen_reg_rtx
argument_list|(
name|value_mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|saved_valreg
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|valreg
argument_list|,
name|saved_valreg
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Generate the call, putting the value in a pseudo.  */
name|temp
operator|=
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|saveregs_value
operator|=
name|temp
expr_stmt|;
comment|/* Put the sequence after the NOTE that starts the function. 	   If this is inside a SEQUENCE, make the outer-level insn 	   chain current, so the code is placed at the start of the 	   function.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|NEXT_INSN
argument_list|(
name|get_insns
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
comment|/* __builtin_args_info (N) returns word N of the arg space info 	 for the current function.  The number and meanings of words 	 is controlled by the definition of CUMULATIVE_ARGS.  */
case|case
name|BUILT_IN_ARGS_INFO
case|:
block|{
name|int
name|nwords
init|=
sizeof|sizeof
argument_list|(
name|CUMULATIVE_ARGS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|int
modifier|*
name|word_ptr
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|current_function_args_info
decl_stmt|;
if|#
directive|if
literal|0
comment|/* These are used by the code below that is if 0'ed away */
block|int i; 	tree type, elts, result;
endif|#
directive|endif
if|if
condition|(
sizeof|sizeof
argument_list|(
name|CUMULATIVE_ARGS
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"CUMULATIVE_ARGS type defined badly; see %s, line %d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|!=
literal|0
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"argument of `__builtin_args_info' must be constant"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|wordnum
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|wordnum
operator|<
literal|0
operator|||
name|wordnum
operator|>=
name|nwords
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|arg
argument_list|)
condition|)
name|error
argument_list|(
literal|"argument of `__builtin_args_info' out of range"
argument_list|)
expr_stmt|;
else|else
return|return
name|GEN_INT
argument_list|(
name|word_ptr
index|[
name|wordnum
index|]
argument_list|)
return|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"missing argument in `__builtin_args_info'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
if|#
directive|if
literal|0
block|for (i = 0; i< nwords; i++) 	  elts = tree_cons (NULL_TREE, build_int_2 (word_ptr[i], 0));  	type = build_array_type (integer_type_node, 				 build_index_type (build_int_2 (nwords, 0))); 	result = build (CONSTRUCTOR, type, NULL_TREE, nreverse (elts)); 	TREE_CONSTANT (result) = 1; 	TREE_STATIC (result) = 1; 	result = build (INDIRECT_REF, build_pointer_type (type), result); 	TREE_CONSTANT (result) = 1; 	return expand_expr (result, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_BAD);
endif|#
directive|endif
block|}
comment|/* Return the address of the first anonymous stack arg.  */
case|case
name|BUILT_IN_NEXT_ARG
case|:
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
operator|)
operator|&&
operator|!
name|current_function_varargs
condition|)
block|{
name|error
argument_list|(
literal|"`va_start' used in function with fixed args"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|arglist
condition|)
block|{
name|tree
name|last_parm
init|=
name|tree_last
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
comment|/* Strip off all nops for the sake of the comparison.  This 	       is not quite the same as STRIP_NOPS.  It does more.   	       We must also strip off INDIRECT_EXPR for C++ reference 	       parameters.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|last_parm
condition|)
name|warning
argument_list|(
literal|"second parameter of `va_start' not last named argument"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|current_function_varargs
condition|)
comment|/* Evidently an out of date version of<stdarg.h>; can't validate 	     va_start's second argument, but can still work as intended.  */
name|warning
argument_list|(
literal|"`__builtin_next_arg' called without an argument"
argument_list|)
expr_stmt|;
block|}
return|return
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|current_function_internal_arg_pointer
argument_list|,
name|current_function_arg_offset_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
case|case
name|BUILT_IN_CLASSIFY_TYPE
case|:
if|if
condition|(
name|arglist
operator|!=
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|void_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|integer_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|CHAR_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|char_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|enumeral_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|boolean_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|pointer_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|reference_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|OFFSET_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|offset_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|real_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|complex_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|function_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|METHOD_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|method_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|record_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|QUAL_UNION_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|union_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|GEN_INT
argument_list|(
name|string_type_class
argument_list|)
return|;
else|else
return|return
name|GEN_INT
argument_list|(
name|array_type_class
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|SET_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|set_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|FILE_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|file_type_class
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|LANG_TYPE
condition|)
return|return
name|GEN_INT
argument_list|(
name|lang_type_class
argument_list|)
return|;
block|}
return|return
name|GEN_INT
argument_list|(
name|no_type_class
argument_list|)
return|;
case|case
name|BUILT_IN_CONSTANT_P
case|:
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
return|return
name|const0_rtx
return|;
else|else
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* We return 1 for a numeric type that's known to be a constant 	     value at compile-time or for an aggregate type that's a 	     literal constant.  */
name|STRIP_NOPS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* If we know this is a constant, emit the constant of one.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
operator|)
condition|)
return|return
name|const1_rtx
return|;
comment|/* If we aren't going to be running CSE or this expression 	     has side effects, show we don't know it to be a constant. 	     Likewise if it's a pointer or aggregate type since in those 	     case we only want literals, since those are only optimized 	     when generating RTL, not later.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg
argument_list|)
operator|||
name|cse_not_expected
operator|||
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
comment|/* Otherwise, emit (constant_p_rtx (ARG)) and let CSE get a 	     chance to see if it can deduce whether ARG is constant.  */
name|tmp
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_CONSTANT_P_RTX
argument_list|(
name|value_mode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
case|case
name|BUILT_IN_FRAME_ADDRESS
case|:
comment|/* The argument must be a nonnegative integer constant. 	 It counts the number of frames to scan up the stack. 	 The value is the address of that frame.  */
case|case
name|BUILT_IN_RETURN_ADDRESS
case|:
comment|/* The argument must be a nonnegative integer constant. 	 It counts the number of frames to scan up the stack. 	 The value is the return address saved in that frame.  */
if|if
condition|(
name|arglist
operator|==
literal|0
condition|)
comment|/* Warning about missing arg was already issued.  */
return|return
name|const0_rtx
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|tree_int_cst_sgn
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
name|error
argument_list|(
literal|"invalid arg to `__builtin_frame_address'"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid arg to `__builtin_return_address'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
else|else
block|{
name|rtx
name|tem
init|=
name|expand_builtin_return_addr
argument_list|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
decl_stmt|;
comment|/* Some ports cannot access arbitrary stack frames.  */
if|if
condition|(
name|tem
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
name|warning
argument_list|(
literal|"unsupported arg to `__builtin_frame_address'"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"unsupported arg to `__builtin_return_address'"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* For __builtin_frame_address, return what we've got.  */
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_FRAME_ADDRESS
condition|)
return|return
name|tem
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
comment|/* Returns the address of the area where the structure is returned.        0 otherwise.  */
case|case
name|BUILT_IN_AGGREGATE_INCOMING_ADDRESS
case|:
if|if
condition|(
name|arglist
operator|!=
literal|0
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|const0_rtx
return|;
else|else
return|return
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_ALLOCA
case|:
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-integer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
break|break;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate the desired space.  */
return|return
name|allocate_dynamic_stack_space
argument_list|(
name|op0
argument_list|,
name|target
argument_list|,
name|BITS_PER_UNIT
argument_list|)
return|;
case|case
name|BUILT_IN_FFS
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-integer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
break|break;
comment|/* Compute the argument.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute ffs, into TARGET if possible. 	 Set TARGET to wherever the result comes back.  */
name|target
operator|=
name|expand_unop
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ffs_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|target
return|;
case|case
name|BUILT_IN_STRLEN
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
break|break;
else|else
block|{
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|c_strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|src_rtx
decl_stmt|,
name|char_rtx
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|value_mode
decl_stmt|,
name|char_mode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
comment|/* If the length is known, just return it.  */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
return|return
name|expand_expr
argument_list|(
name|len
argument_list|,
name|target
argument_list|,
name|mode
argument_list|,
name|EXPAND_MEMORY_USE_BAD
argument_list|)
return|;
comment|/* If SRC is not a pointer type, don't do this operation inline.  */
if|if
condition|(
name|align
operator|==
literal|0
condition|)
break|break;
comment|/* Call a function if we can't compute strlen in the right mode.  */
while|while
condition|(
name|insn_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|icode
operator|=
name|strlen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|insn_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
break|break;
name|insn_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn_mode
operator|==
name|VOIDmode
condition|)
break|break;
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
comment|/* Make sure the operands are acceptable to the predicates.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|result
argument_list|,
name|insn_mode
argument_list|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
name|src_rtx
operator|=
name|memory_address
argument_list|(
name|BLKmode
argument_list|,
name|expand_expr
argument_list|(
name|src
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|src_rtx
argument_list|,
name|Pmode
argument_list|)
condition|)
name|src_rtx
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|src_rtx
argument_list|)
expr_stmt|;
comment|/* Check the string is readable and has an end.  */
if|if
condition|(
name|current_function_check_memory_usage
condition|)
name|emit_library_call
argument_list|(
name|chkr_check_str_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|2
argument_list|,
name|src_rtx
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_RO
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|char_rtx
operator|=
name|const0_rtx
expr_stmt|;
name|char_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|char_rtx
argument_list|,
name|char_mode
argument_list|)
condition|)
name|char_rtx
operator|=
name|copy_to_mode_reg
argument_list|(
name|char_mode
argument_list|,
name|char_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|result
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|src_rtx
argument_list|)
argument_list|,
name|char_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|value_mode
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|convert_to_mode
argument_list|(
name|value_mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
return|;
block|}
case|case
name|BUILT_IN_STRCPY
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
break|break;
else|else
block|{
name|tree
name|len
init|=
name|c_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|len
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Drops in.  */
case|case
name|BUILT_IN_MEMCPY
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|)
condition|)
break|break;
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|src_align
init|=
name|get_pointer_alignment
argument_list|(
name|src
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|,
name|src_mem
decl_stmt|,
name|dest_addr
decl_stmt|,
name|len_rtx
decl_stmt|;
comment|/* If either SRC or DEST is not a pointer type, don't do 	     this operation in-line.  */
if|if
condition|(
name|src_align
operator|==
literal|0
operator|||
name|dest_align
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_STRCPY
condition|)
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|src_mem
operator|=
name|get_memory_rtx
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|len_rtx
operator|=
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Just copy the rights of SRC to the rights of DEST.  */
if|if
condition|(
name|current_function_check_memory_usage
condition|)
name|emit_library_call
argument_list|(
name|chkr_copy_bitmap_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|src_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|len_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy word part most expediently.  */
name|dest_addr
operator|=
name|emit_block_move
argument_list|(
name|dest_mem
argument_list|,
name|src_mem
argument_list|,
name|len_rtx
argument_list|,
name|MIN
argument_list|(
name|src_align
argument_list|,
name|dest_align
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_addr
operator|==
literal|0
condition|)
name|dest_addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|dest_addr
return|;
block|}
case|case
name|BUILT_IN_MEMSET
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|)
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|INTEGER_TYPE
operator|!=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
break|break;
else|else
block|{
name|tree
name|dest
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|dest_align
init|=
name|get_pointer_alignment
argument_list|(
name|dest
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|,
name|dest_addr
decl_stmt|,
name|len_rtx
decl_stmt|;
comment|/* If DEST is not a pointer type, don't do this  	     operation in-line.  */
if|if
condition|(
name|dest_align
operator|==
literal|0
condition|)
break|break;
comment|/* If the arguments have side-effects, then we can only evaluate 	     them at most once.  The following code evaluates them twice if 	     they are not constants because we break out to expand_call 	     in that case.  They can't be constants if they have side-effects 	     so we can check for that first.  Alternatively, we could call 	     save_expr to make multiple evaluation safe.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|len
argument_list|)
condition|)
break|break;
comment|/* If VAL is not 0, don't do this operation in-line. */
if|if
condition|(
name|expand_expr
argument_list|(
name|val
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
operator|!=
name|const0_rtx
condition|)
break|break;
comment|/* If LEN does not expand to a constant, don't do this 	     operation in-line.  */
name|len_rtx
operator|=
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|len_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
break|break;
name|dest_mem
operator|=
name|get_memory_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* Just check DST is writable and mark it as readable.  */
if|if
condition|(
name|current_function_check_memory_usage
condition|)
name|emit_library_call
argument_list|(
name|chkr_check_addr_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|len_rtx
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_WO
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|clear_storage
argument_list|(
name|dest_mem
argument_list|,
name|len_rtx
argument_list|,
name|dest_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_addr
operator|==
literal|0
condition|)
name|dest_addr
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dest_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|dest_addr
return|;
block|}
comment|/* These comparison functions need an instruction that returns an actual    index.  An ordinary compare that just sets the condition codes    is not enough.  */
ifdef|#
directive|ifdef
name|HAVE_cmpstrsi
case|case
name|BUILT_IN_STRCMP
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
comment|/* If we need to check memory accesses, call the library function.  */
if|if
condition|(
name|current_function_check_memory_usage
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|HAVE_cmpstrsi
condition|)
break|break;
block|{
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
decl_stmt|,
name|len2
decl_stmt|;
name|len
operator|=
name|c_strlen
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|len
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_one_node
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len2
operator|=
name|c_strlen
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
condition|)
name|len2
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_one_node
argument_list|,
name|len2
argument_list|)
expr_stmt|;
comment|/* If we don't have a constant length for the first, use the length 	   of the second, if we know it.  We don't require a constant for 	   this case; some cost analysis could be done if both are available 	   but neither is constant.  For now, assume they're equally cheap.  	   If both strings have constant lengths, use the smaller.  This 	   could arise if optimization results in strcpy being called with 	   two fixed strings, or if the code was machine-generated.  We should 	   add some code to the `memcmp' handler below to deal with such 	   situations, someday.  */
if|if
condition|(
operator|!
name|len
operator|||
name|TREE_CODE
argument_list|(
name|len
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|len2
condition|)
name|len
operator|=
name|len2
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|len2
operator|&&
name|TREE_CODE
argument_list|(
name|len2
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|len2
argument_list|,
name|len
argument_list|)
condition|)
name|len
operator|=
name|len2
expr_stmt|;
block|}
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Drops in.  */
case|case
name|BUILT_IN_MEMCMP
case|:
comment|/* If not optimizing, call the library function.  */
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
break|break;
comment|/* If we need to check memory accesses, call the library function.  */
if|if
condition|(
name|current_function_check_memory_usage
condition|)
break|break;
if|if
condition|(
name|arglist
operator|==
literal|0
comment|/* Arg could be non-pointer if user redeclared this fcn wrong.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|HAVE_cmpstrsi
condition|)
break|break;
block|{
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|len
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|int
name|arg1_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg1
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|arg2_align
init|=
name|get_pointer_alignment
argument_list|(
name|arg2
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_cmpstrsi
index|]
index|[
literal|0
index|]
decl_stmt|;
comment|/* If we don't have POINTER_TYPE, call the function.  */
if|if
condition|(
name|arg1_align
operator|==
literal|0
operator|||
name|arg2_align
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_STRCMP
condition|)
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Make a place to write the result of the instruction.  */
name|result
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|insn_mode
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpstrsi
argument_list|(
name|result
argument_list|,
name|get_memory_rtx
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|get_memory_rtx
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|len
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|arg1_align
argument_list|,
name|arg2_align
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the value in the proper mode for this function.  */
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
operator|==
name|mode
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|#
directive|else
case|case
name|BUILT_IN_STRCMP
case|:
case|case
name|BUILT_IN_MEMCMP
case|:
break|break;
endif|#
directive|endif
case|case
name|BUILT_IN_SETJMP
case|:
name|target
operator|=
name|expand_builtin_setjmp
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
comment|/* __builtin_longjmp is passed a pointer to an array of five words. 	 It's similar to the C library longjmp function but works with 	 __builtin_setjmp above.  */
case|case
name|BUILT_IN_LONGJMP
case|:
if|if
condition|(
name|arglist
operator|==
literal|0
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
break|break;
else|else
block|{
name|rtx
name|buf_addr
init|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|value
init|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|const1_rtx
condition|)
block|{
name|error
argument_list|(
literal|"__builtin_longjmp second argument must be 1"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|expand_builtin_longjmp
argument_list|(
name|buf_addr
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
case|case
name|BUILT_IN_TRAP
case|:
ifdef|#
directive|ifdef
name|HAVE_trap
if|if
condition|(
name|HAVE_trap
condition|)
name|emit_insn
argument_list|(
name|gen_trap
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|error
argument_list|(
literal|"__builtin_trap not supported by this target"
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
comment|/* Various hooks for the DWARF 2 __throw routine.  */
case|case
name|BUILT_IN_UNWIND_INIT
case|:
name|expand_builtin_unwind_init
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|BUILT_IN_DWARF_CFA
case|:
return|return
name|virtual_cfa_rtx
return|;
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
case|case
name|BUILT_IN_DWARF_FP_REGNUM
case|:
return|return
name|expand_builtin_dwarf_fp_regnum
argument_list|()
return|;
case|case
name|BUILT_IN_DWARF_REG_SIZE
case|:
return|return
name|expand_builtin_dwarf_reg_size
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|target
argument_list|)
return|;
endif|#
directive|endif
case|case
name|BUILT_IN_FROB_RETURN_ADDR
case|:
return|return
name|expand_builtin_frob_return_addr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_EXTRACT_RETURN_ADDR
case|:
return|return
name|expand_builtin_extract_return_addr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
case|case
name|BUILT_IN_EH_RETURN
case|:
name|expand_builtin_eh_return
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
default|default:
comment|/* just do library call, if unknown builtin */
name|error
argument_list|(
literal|"built-in function `%s' not currently supported"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The switch statement above can drop through to cause the function      to be called normally.  */
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Built-in functions to perform an untyped call and return.  */
end_comment

begin_comment
comment|/* For each register that may be used for calling a function, this    gives a mode used to copy the register's value.  VOIDmode indicates    the register is not used for calling a function.  If the machine    has register windows, this gives only the outbound registers.    INCOMING_REGNO gives the corresponding inbound register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|apply_args_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register that may be used for returning values, this gives    a mode used to copy the register's value.  VOIDmode indicates the    register is not used for returning values.  If the machine has    register windows, this gives only the outbound registers.    INCOMING_REGNO gives the corresponding inbound register.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|apply_result_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register that may be used for calling a function, this    gives the offset of that register into the block returned by    __builtin_apply_args.  0 indicates that the register is not    used for calling a function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apply_args_reg_offset
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the offset of register REGNO into the block returned by     __builtin_apply_args.  This is not declared static, since it is    needed in objc-act.c.  */
end_comment

begin_function
name|int
name|apply_args_register_offset
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|apply_args_size
argument_list|()
expr_stmt|;
comment|/* Arguments are always put in outgoing registers (in the argument      block) if such make sense.  */
ifdef|#
directive|ifdef
name|OUTGOING_REGNO
name|regno
operator|=
name|OUTGOING_REGNO
argument_list|(
name|regno
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|apply_args_reg_offset
index|[
name|regno
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the size required for the block returned by __builtin_apply_args,    and initialize apply_args_mode.  */
end_comment

begin_function
specifier|static
name|int
name|apply_args_size
parameter_list|()
block|{
specifier|static
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The values computed by this function never change.  */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
comment|/* The first value is the incoming arg-pointer.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* The second value is the structure value address unless this is 	 passed as an "invisible" first argument.  */
if|if
condition|(
name|struct_value_rtx
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* Search for the proper mode for copying this register's 	       value.  I'm not sure this is right, but it works so far.  */
name|enum
name|machine_mode
name|best_mode
init|=
name|VOIDmode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|==
literal|1
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
name|mode
operator|=
name|best_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|apply_args_reg_offset
index|[
name|regno
index|]
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|apply_args_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
name|apply_args_mode
index|[
name|regno
index|]
operator|=
name|VOIDmode
expr_stmt|;
name|apply_args_reg_offset
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size required for the block returned by __builtin_apply,    and initialize apply_result_mode.  */
end_comment

begin_function
specifier|static
name|int
name|apply_result_size
parameter_list|()
block|{
specifier|static
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The values computed by this function never change.  */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* Search for the proper mode for copying this register's 	       value.  I'm not sure this is right, but it works so far.  */
name|enum
name|machine_mode
name|best_mode
init|=
name|VOIDmode
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|TImode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|best_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
name|best_mode
operator|=
name|mode
expr_stmt|;
name|mode
operator|=
name|best_mode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|apply_result_mode
index|[
name|regno
index|]
operator|=
name|mode
expr_stmt|;
block|}
else|else
name|apply_result_mode
index|[
name|regno
index|]
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Allow targets that use untyped_call and untyped_return to override 	 the size so that machine-specific information can be stored here.  */
ifdef|#
directive|ifdef
name|APPLY_RESULT_SIZE
name|size
operator|=
name|APPLY_RESULT_SIZE
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|size
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_untyped_call
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_untyped_return
argument_list|)
end_if

begin_comment
comment|/* Create a vector describing the result block RESULT.  If SAVEP is true,    the result block is used to save the values; otherwise it is used to    restore the values.  */
end_comment

begin_function
specifier|static
name|rtx
name|result_vector
parameter_list|(
name|savep
parameter_list|,
name|result
parameter_list|)
name|int
name|savep
decl_stmt|;
name|rtx
name|result
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|size
decl_stmt|,
name|align
decl_stmt|,
name|nelts
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
modifier|*
name|savevec
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|size
operator|=
name|nelts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|savep
condition|?
name|regno
else|:
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|change_address
argument_list|(
name|result
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|savevec
index|[
name|nelts
operator|++
index|]
operator|=
operator|(
name|savep
condition|?
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
else|:
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
operator|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|nelts
argument_list|,
name|savevec
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_untyped_call or HAVE_untyped_return */
end_comment

begin_comment
comment|/* Save the state required to perform an untyped call with the same    arguments as were passed to the current function.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply_args
parameter_list|()
block|{
name|rtx
name|registers
decl_stmt|;
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Create a block where the arg-pointer, structure value address,      and argument registers can be saved.  */
name|registers
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|apply_args_size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Walk past the arg-pointer and structure value address.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value_rtx
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save each register used in calling a function to the block.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_args_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|tem
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* For reg-stack.c's stack register household. 	   Compare with a similar piece of code in function.c.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|registers
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|registers
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Save the arg pointer to the block.  */
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|registers
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|registers
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save the structure value address unless this is passed as an      "invisible" first argument.  */
if|if
condition|(
name|struct_value_incoming_rtx
condition|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|registers
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|registers
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|struct_value_incoming_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* Return the address of the block.  */
return|return
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|registers
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform an untyped call and save the state required to perform an    untyped return of whatever value was returned by the given function.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_builtin_apply
parameter_list|(
name|function
parameter_list|,
name|arguments
parameter_list|,
name|argsize
parameter_list|)
name|rtx
name|function
decl_stmt|,
name|arguments
decl_stmt|,
name|argsize
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|incoming_args
decl_stmt|,
name|result
decl_stmt|,
name|reg
decl_stmt|,
name|dest
decl_stmt|,
name|call_insn
decl_stmt|;
name|rtx
name|old_stack_level
init|=
literal|0
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
comment|/* Create a block where the return registers can be saved.  */
name|result
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|apply_result_size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* ??? The argsize value should be adjusted here.  */
comment|/* Fetch the arg pointer from the ARGUMENTS block.  */
name|incoming_args
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|incoming_args
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|incoming_args
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|sub_optab
argument_list|,
name|incoming_args
argument_list|,
name|argsize
argument_list|,
name|incoming_args
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Perform postincrements before actually calling the function.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Push a new argument block and copy the arguments.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Save the stack with nonlocal if available */
ifdef|#
directive|ifdef
name|HAVE_save_stack_nonlocal
if|if
condition|(
name|HAVE_save_stack_nonlocal
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_stack_save
argument_list|(
name|SAVE_BLOCK
argument_list|,
operator|&
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Push a block of memory onto the stack to store the memory arguments.      Save the address in a register, and copy the memory arguments.  ??? I      haven't figured out how the calling convention macros effect this,      but it's likely that the source and/or destination addresses in      the block copy will need updating in machine specific ways.  */
name|dest
operator|=
name|allocate_dynamic_stack_space
argument_list|(
name|argsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|dest
argument_list|)
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|incoming_args
argument_list|)
argument_list|,
name|argsize
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Refer to the argument block.  */
name|apply_args_size
argument_list|()
expr_stmt|;
name|arguments
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
comment|/* Walk past the arg-pointer and structure value address.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value_rtx
condition|)
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Restore each of the registers previously saved.  Make USE insns      for each of these registers for use in making the call.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_args_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|change_address
argument_list|(
name|arguments
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|arguments
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the structure value address unless this is passed as an      "invisible" first argument.  */
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_value_rtx
condition|)
block|{
name|rtx
name|value
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|value
argument_list|,
name|change_address
argument_list|(
name|arguments
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|arguments
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|struct_value_rtx
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|struct_value_rtx
argument_list|)
operator|==
name|REG
condition|)
name|use_reg
argument_list|(
operator|&
name|call_fusage
argument_list|,
name|struct_value_rtx
argument_list|)
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* All arguments and registers used for the call are set up by now!  */
name|function
operator|=
name|prepare_call_address
argument_list|(
name|function
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|call_fusage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ensure address is valid.  SYMBOL_REF is already valid, so no need,      and we don't want to load it into a register as an optimization,      because prepare_call_address already did it if it should be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|function
operator|=
name|memory_address
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* Generate the actual call instruction and save the return value.  */
ifdef|#
directive|ifdef
name|HAVE_untyped_call
if|if
condition|(
name|HAVE_untyped_call
condition|)
name|emit_call_insn
argument_list|(
name|gen_untyped_call
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
argument_list|,
name|result
argument_list|,
name|result_vector
argument_list|(
literal|1
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_call_value
if|if
condition|(
name|HAVE_call_value
condition|)
block|{
name|rtx
name|valreg
init|=
literal|0
decl_stmt|;
comment|/* Locate the unique return register.  It is not possible to 	 express a call that sets more than one return register using 	 call_value; use untyped_call for that.  In fact, untyped_call 	 only needs to save the return registers in the given block.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|valreg
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* HAVE_untyped_call required.  */
name|valreg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|emit_call_insn
argument_list|(
name|gen_call_value
argument_list|(
name|valreg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|function
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|result
argument_list|,
name|GET_MODE
argument_list|(
name|valreg
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|valreg
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the CALL insn we just emitted.  */
for|for
control|(
name|call_insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|call_insn
operator|&&
name|GET_CODE
argument_list|(
name|call_insn
argument_list|)
operator|!=
name|CALL_INSN
condition|;
name|call_insn
operator|=
name|PREV_INSN
argument_list|(
name|call_insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|call_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Put the register usage information on the CALL.  If there is already      some usage information, put ours at the end.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
init|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
empty_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
block|}
else|else
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call_insn
argument_list|)
operator|=
name|call_fusage
expr_stmt|;
comment|/* Restore the stack.  */
ifdef|#
directive|ifdef
name|HAVE_save_stack_nonlocal
if|if
condition|(
name|HAVE_save_stack_nonlocal
condition|)
name|emit_stack_restore
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit_stack_restore
argument_list|(
name|SAVE_BLOCK
argument_list|,
name|old_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Return the address of the result block.  */
return|return
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform an untyped return.  */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_return
parameter_list|(
name|result
parameter_list|)
name|rtx
name|result
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|call_fusage
init|=
literal|0
decl_stmt|;
name|apply_result_size
argument_list|()
expr_stmt|;
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|result
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_untyped_return
if|if
condition|(
name|HAVE_untyped_return
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_untyped_return
argument_list|(
name|result
argument_list|,
name|result_vector
argument_list|(
literal|0
argument_list|,
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Restore the return value and note that each value is used.  */
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|mode
operator|=
name|apply_result_mode
index|[
name|regno
index|]
operator|)
operator|!=
name|VOIDmode
condition|)
block|{
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
operator|!=
literal|0
condition|)
name|size
operator|=
name|CEIL
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|*
name|align
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|INCOMING_REGNO
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|change_address
argument_list|(
name|result
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|call_fusage
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|call_fusage
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Put the USE insns before the return.  */
name|emit_insns
argument_list|(
name|call_fusage
argument_list|)
expr_stmt|;
comment|/* Return whatever values was restored by jumping directly to the end      of the function.  */
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand code for a post- or pre- increment or decrement    and return the RTX for the result.    POST is 1 for postinc/decrements and 0 for preinc/decrements.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_increment
parameter_list|(
name|exp
parameter_list|,
name|post
parameter_list|,
name|ignore
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
name|int
name|post
decl_stmt|,
name|ignore
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
specifier|register
name|rtx
name|temp
decl_stmt|,
name|value
decl_stmt|;
specifier|register
name|tree
name|incremented
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|optab
name|this_optab
init|=
name|add_optab
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|op0_is_copy
init|=
literal|0
decl_stmt|;
name|int
name|single_insn
init|=
literal|0
decl_stmt|;
comment|/* 1 means we can't store into OP0 directly,      because it is a subreg narrower than a word,      and we don't dare clobber the rest of the word.  */
name|int
name|bad_subreg
init|=
literal|0
decl_stmt|;
comment|/* Stabilize any component ref that might need to be      evaluated more than once below.  */
if|if
condition|(
operator|!
name|post
operator|||
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incremented
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|INDIRECT_REF
operator|||
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incremented
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|incremented
operator|=
name|stabilize_reference
argument_list|(
name|incremented
argument_list|)
expr_stmt|;
comment|/* Nested *INCREMENT_EXPRs can happen in C++.  We must force innermost      ones into save exprs so that they don't accidentally get evaluated      more than once by the code below.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|PREINCREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|PREDECREMENT_EXPR
condition|)
name|incremented
operator|=
name|save_expr
argument_list|(
name|incremented
argument_list|)
expr_stmt|;
comment|/* Compute the operands as RTX.      Note whether OP0 is the actual lvalue or a copy of it:      I believe it is a copy iff it is a register or subreg      and insns were generated in computing it.   */
name|temp
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|incremented
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_MEMORY_USE_RW
argument_list|)
expr_stmt|;
comment|/* If OP0 is a SUBREG made for a promoted variable, we cannot increment      in place but instead must do sign- or zero-extension during assignment,      so we copy it into a new register and let the code below use it as      a copy.       Note that we can safely modify this SUBREG since it is know not to be      shared (it was made by the expand_expr call above).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
if|if
condition|(
name|post
condition|)
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
operator|=
name|copy_to_reg
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bad_subreg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
block|{
comment|/* We cannot increment this SUBREG in place.  If we are 	 post-incrementing, get a copy of the old value.  Otherwise, 	 just mark that we cannot increment in place.  */
if|if
condition|(
name|post
condition|)
name|op0
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
else|else
name|bad_subreg
operator|=
literal|1
expr_stmt|;
block|}
name|op0_is_copy
operator|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|temp
operator|!=
name|get_last_insn
argument_list|()
operator|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_MEMORY_USE_BAD
argument_list|)
expr_stmt|;
comment|/* Decide whether incrementing or decrementing.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PREDECREMENT_EXPR
condition|)
name|this_optab
operator|=
name|sub_optab
expr_stmt|;
comment|/* Convert decrement by a constant into a negative increment.  */
if|if
condition|(
name|this_optab
operator|==
name|sub_optab
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op1
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|this_optab
operator|=
name|add_optab
expr_stmt|;
block|}
comment|/* For a preincrement, see if we can do this with a single instruction.  */
if|if
condition|(
operator|!
name|post
condition|)
block|{
name|icode
operator|=
operator|(
name|int
operator|)
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
operator|(
name|int
operator|)
name|CODE_FOR_nothing
comment|/* Make sure that OP0 is valid for operands 0 and 1 	     of the insn we want to queue.  */
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|single_insn
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If OP0 is not the actual lvalue, but rather a copy in a register,      then we cannot just increment OP0.  We must therefore contrive to      increment the original value.  Then, for postincrement, we can return      OP0 since it is a copy of the old value.  For preincrement, expand here      unless we can do it with a single insn.       Likewise if storing directly into OP0 would clobber high bits      we need to preserve (bad_subreg).  */
if|if
condition|(
name|op0_is_copy
operator|||
operator|(
operator|!
name|post
operator|&&
operator|!
name|single_insn
operator|)
operator|||
name|bad_subreg
condition|)
block|{
comment|/* This is the easiest way to increment the value wherever it is. 	 Problems with multiple evaluation of INCREMENTED are prevented 	 because either (1) it is a component_ref or preincrement, 	 in which case it was stabilized above, or (2) it is an array_ref 	 with constant index in an array in a register, which is 	 safe to reevaluate.  */
name|tree
name|newexp
init|=
name|build
argument_list|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PREDECREMENT_EXPR
operator|)
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|incremented
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|incremented
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|newexp
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|incremented
argument_list|)
argument_list|,
name|newexp
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|TREE_OPERAND
argument_list|(
name|incremented
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|expand_assignment
argument_list|(
name|incremented
argument_list|,
name|newexp
argument_list|,
operator|!
name|post
operator|&&
operator|!
name|ignore
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|post
condition|?
name|op0
else|:
name|temp
return|;
block|}
if|if
condition|(
name|post
condition|)
block|{
comment|/* We have a true reference to the value in OP0. 	 If there is an insn to add or subtract in this mode, queue it. 	 Queueing the increment insn avoids the register shuffling 	 that often results if we must increment now and first save 	 the old value for subsequent use.  */
if|#
directive|if
literal|0
comment|/* Turned off to avoid making extra insn for indexed memref.  */
block|op0 = stabilize (op0);
endif|#
directive|endif
name|icode
operator|=
operator|(
name|int
operator|)
name|this_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
operator|(
name|int
operator|)
name|CODE_FOR_nothing
comment|/* Make sure that OP0 is valid for operands 0 and 1 	     of the insn we want to queue.  */
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|enqueue_insn
argument_list|(
name|op0
argument_list|,
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|icode
operator|!=
operator|(
name|int
operator|)
name|CODE_FOR_nothing
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|addr
init|=
operator|(
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
condition|?
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|,
name|result
decl_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|temp
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* The increment queue is LIFO, thus we have to `queue' 	     the instructions in reverse order.  */
name|enqueue_insn
argument_list|(
name|op0
argument_list|,
name|gen_move_insn
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|enqueue_insn
argument_list|(
name|temp
argument_list|,
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/* Preincrement, or we can't increment with one simple insn.  */
if|if
condition|(
name|post
condition|)
comment|/* Save a copy of the value before inc or dec, to return it later.  */
name|temp
operator|=
name|value
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
else|else
comment|/* Arrange to return the incremented value.  */
comment|/* Copy the rtx because expand_binop will protect from the queue,        and the results of that would be invalid for us to return        if our caller does emit_queue before using our result.  */
name|temp
operator|=
name|copy_rtx
argument_list|(
name|value
operator|=
name|op0
argument_list|)
expr_stmt|;
comment|/* Increment however we can.  */
name|op1
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|this_optab
argument_list|,
name|value
argument_list|,
name|op1
argument_list|,
name|current_function_check_memory_usage
condition|?
name|NULL_RTX
else|:
name|op0
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Make sure the value is stored into OP0.  */
if|if
condition|(
name|op1
operator|!=
name|op0
condition|)
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand all function calls contained within EXP, innermost ones first.    But don't look within expressions that have sequence points.    For each CALL_EXPR, record the rtx for its value    in the CALL_EXPR_RTL field.  */
end_comment

begin_function
specifier|static
name|void
name|preexpand_calls
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|int
name|nops
decl_stmt|,
name|i
decl_stmt|;
name|int
name|type
init|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|do_preexpand_calls
condition|)
return|return;
comment|/* Only expressions and references can contain calls.  */
if|if
condition|(
name|type
operator|!=
literal|'e'
operator|&&
name|type
operator|!=
literal|'<'
operator|&&
name|type
operator|!=
literal|'1'
operator|&&
name|type
operator|!=
literal|'2'
operator|&&
name|type
operator|!=
literal|'r'
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
comment|/* Do nothing if already expanded.  */
if|if
condition|(
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
comment|/* Do nothing if the call returns a variable-sized object.  */
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
comment|/* Do nothing to built-in functions.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
name|CALL_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|expand_call
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|COND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
comment|/* If we find one of these, then we can be sure 	 the adjust will be done for it (since it makes jumps). 	 Do it now, so that if this is inside an argument 	 of a function, we don't get the stack adjustment 	 after some other args have already been pushed.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
return|return;
case|case
name|BLOCK
case|:
case|case
name|RTL_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|CLEANUP_POINT_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
return|return;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
return|return;
default|default:
break|break;
block|}
name|nops
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|type
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|'e'
operator|||
name|type
operator|==
literal|'<'
operator|||
name|type
operator|==
literal|'1'
operator|||
name|type
operator|==
literal|'2'
operator|||
name|type
operator|==
literal|'r'
condition|)
name|preexpand_calls
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* At the start of a function, record that we have no previously-pushed    arguments waiting to be popped.  */
end_comment

begin_function
name|void
name|init_pending_stack_adjust
parameter_list|()
block|{
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When exiting from function, if safe, clear out any pending stack adjust    so the adjustment won't get done.     Note, if the current function calls alloca, then it must have a    frame pointer regardless of the value of flag_omit_frame_pointer.  */
end_comment

begin_function
name|void
name|clear_pending_stack_adjust
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
operator|(
operator|!
name|flag_omit_frame_pointer
operator|||
name|current_function_calls_alloca
operator|)
operator|&&
name|EXIT_IGNORE_STACK
operator|&&
operator|!
operator|(
name|DECL_INLINE
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
name|flag_no_inline
operator|)
operator|&&
operator|!
name|flag_inline_functions
condition|)
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Pop any previously-pushed arguments that have not been popped yet.  */
end_comment

begin_function
name|void
name|do_pending_stack_adjust
parameter_list|()
block|{
if|if
condition|(
name|inhibit_defer_pop
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pending_stack_adjust
operator|!=
literal|0
condition|)
name|adjust_stack
argument_list|(
name|GEN_INT
argument_list|(
name|pending_stack_adjust
argument_list|)
argument_list|)
expr_stmt|;
name|pending_stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand conditional expressions.  */
end_comment

begin_comment
comment|/* Generate code to evaluate EXP and jump to LABEL if the value is zero.    LABEL is an rtx of code CODE_LABEL, in this function and all the    functions here.  */
end_comment

begin_function
name|void
name|jumpifnot
parameter_list|(
name|exp
parameter_list|,
name|label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|do_jump
argument_list|(
name|exp
argument_list|,
name|label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */
end_comment

begin_function
name|void
name|jumpif
parameter_list|(
name|exp
parameter_list|,
name|label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|do_jump
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if    the result is zero, or IF_TRUE_LABEL if the result is one.    Either of IF_FALSE_LABEL and IF_TRUE_LABEL may be zero,    meaning fall through in that case.     do_jump always does any pending stack adjust except when it does not    actually perform a jump.  An example where there is no jump    is when EXP is `(foo (), 0)' and IF_FALSE_LABEL is null.     This function is responsible for optimizing cases such as&&, || and comparison operators in EXP.  */
end_comment

begin_function
name|void
name|do_jump
parameter_list|(
name|exp
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* Some cases need to create a label to jump to      in order to properly fall through.      These cases set DROP_THROUGH_LABEL nonzero.  */
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|comparison
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
ifdef|#
directive|ifdef
name|MAX_INTEGER_COMPUTATION_MODE
name|check_max_integer_computation_mode
argument_list|(
name|exp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_queue
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|INTEGER_CST
case|:
name|temp
operator|=
name|integer_zerop
argument_list|(
name|exp
argument_list|)
condition|?
name|if_false_label
else|:
name|if_true_label
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|emit_jump
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* This is not true with #pragma weak  */
block|case ADDR_EXPR:
comment|/* The address of something can never be zero.  */
block|if (if_true_label) 	emit_jump (if_true_label);       break;
endif|#
directive|endif
case|case
name|NOP_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
condition|)
goto|goto
name|normal
goto|;
case|case
name|CONVERT_EXPR
case|:
comment|/* If we are narrowing the operand, we have to do the compare in the 	 narrower mode.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|normal
goto|;
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|REFERENCE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
comment|/* These cannot change zero->non-zero or vice versa.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* This is never less insns than evaluating the PLUS_EXPR followed by 	 a test and can be longer if the test is eliminated.  */
block|case PLUS_EXPR:
comment|/* Reduce to minus.  */
block|exp = build (MINUS_EXPR, TREE_TYPE (exp), 		   TREE_OPERAND (exp, 0), 		   fold (build1 (NEGATE_EXPR, TREE_TYPE (TREE_OPERAND (exp, 1)), 				 TREE_OPERAND (exp, 1))));
comment|/* Process as MINUS.  */
endif|#
directive|endif
case|case
name|MINUS_EXPR
case|:
comment|/* Non-zero iff operands of minus differ.  */
name|comparison
operator|=
name|compare
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
comment|/* If we are AND'ing with a small constant, do this comparison in the 	 smallest type that fits.  If the machine doesn't have comparisons 	 that small, it will be converted back to the wider comparison. 	 This helps if we are testing the sign bit of a narrower object. 	 combine can't do this for us because it can't know whether a 	 ZERO_EXTRACT or a compare in a smaller mode exists, but we do.  */
if|if
condition|(
operator|!
name|SLOW_BYTE_ACCESS
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|i
operator|=
name|floor_log2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|mode
operator|=
name|mode_for_size
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|BLKmode
operator|&&
operator|(
name|type
operator|=
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|do_jump
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|normal
goto|;
case|case
name|TRUTH_NOT_EXPR
case|:
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
if|if
condition|(
name|if_false_label
operator|==
literal|0
condition|)
name|if_false_label
operator|=
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
if|if
condition|(
name|if_true_label
operator|==
literal|0
condition|)
name|if_true_label
operator|=
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|push_temp_slots
argument_list|()
expr_stmt|;
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
name|emit_queue
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
case|case
name|ARRAY_REF
case|:
block|{
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|,
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
name|int
name|alignment
decl_stmt|;
comment|/* Get description of this reference.  We don't actually care 	   about the underlying object here.  */
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|alignment
argument_list|)
expr_stmt|;
name|type
operator|=
name|type_for_size
argument_list|(
name|bitsize
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLOW_BYTE_ACCESS
operator|&&
name|type
operator|!=
literal|0
operator|&&
name|bitsize
operator|>=
literal|0
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|do_jump
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|normal
goto|;
block|}
case|case
name|COND_EXPR
case|:
comment|/* Do (a ? 1 : 0) and (a ? 0 : 1) as special cases.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|rtx
name|label1
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|start_cleanup_deferral
argument_list|()
expr_stmt|;
comment|/* Now the THEN-expression.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_false_label
condition|?
name|if_false_label
else|:
name|drop_through_label
argument_list|,
name|if_true_label
condition|?
name|if_true_label
else|:
name|drop_through_label
argument_list|)
expr_stmt|;
comment|/* In case the do_jump just above never jumps.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label1
argument_list|)
expr_stmt|;
comment|/* Now the ELSE-expression.  */
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|if_false_label
condition|?
name|if_false_label
else|:
name|drop_through_label
argument_list|,
name|if_true_label
condition|?
name|if_true_label
else|:
name|drop_through_label
argument_list|)
expr_stmt|;
name|end_cleanup_deferral
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
block|{
name|tree
name|exp0
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|exp1
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|do_jump
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_equality
argument_list|(
name|exp
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|EQ
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NE_EXPR
case|:
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
block|{
name|tree
name|exp0
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|exp1
init|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|do_jump
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|exp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|do_jump
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_equality
argument_list|(
name|exp
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|NE
argument_list|,
name|NE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LT_EXPR
case|:
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|LT
argument_list|,
name|LTU
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|LE
argument_list|,
name|LEU
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|GT
argument_list|,
name|GTU
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|do_jump_by_parts_greater
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
else|else
name|comparison
operator|=
name|compare
argument_list|(
name|exp
argument_list|,
name|GE
argument_list|,
name|GEU
argument_list|)
expr_stmt|;
break|break;
default|default:
name|normal
label|:
name|temp
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is not needed any more and causes poor code since it causes 	 comparisons and tests from non-SI objects to have different code 	 sequences.  */
comment|/* Copy to register to avoid generating bad insns by cse 	 from (set (mem ...) (arithop))  (set (cc0) (mem ...)).  */
block|if (!cse_not_expected&& GET_CODE (temp) == MEM) 	temp = copy_to_reg (temp);
endif|#
directive|endif
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|comparison
operator|=
operator|(
name|temp
operator|==
name|const0_rtx
condition|?
name|const0_rtx
else|:
name|const_true_rtx
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|comparison
operator|=
name|const_true_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
condition|)
comment|/* Note swapping the labels gives us not-equal.  */
name|do_jump_by_parts_equality_rtx
argument_list|(
name|temp
argument_list|,
name|if_true_label
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|comparison
operator|=
name|compare_from_rtx
argument_list|(
name|temp
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|,
name|NE
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Do any postincrements in the expression that was tested.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* If COMPARISON is nonzero here, it is an rtx that can be substituted      straight into a conditional jump instruction as the jump condition.      Otherwise, all the work has been done already.  */
if|if
condition|(
name|comparison
operator|==
name|const_true_rtx
condition|)
block|{
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comparison
operator|==
name|const0_rtx
condition|)
block|{
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comparison
condition|)
name|do_jump_for_compare
argument_list|(
name|comparison
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
block|{
comment|/* If do_jump produces code that might be jumped around, 	 do any stack adjusts from that code, before the place 	 where control merges in.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a comparison expression EXP for values too wide to be compared    with one insn, test the comparison and jump to the appropriate label.    The code of EXP is ignored; we always test GT if SWAP is 0,    and LT if SWAP is 1.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_by_parts_greater
parameter_list|(
name|exp
parameter_list|,
name|swap
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|swap
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
name|swap
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
operator|!
name|swap
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nwords
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|if_true_label
operator|||
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|if_true_label
condition|)
name|if_true_label
operator|=
name|drop_through_label
expr_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|if_false_label
operator|=
name|drop_through_label
expr_stmt|;
comment|/* Compare a word at a time, high order first.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|comp
decl_stmt|;
name|rtx
name|op0_word
decl_stmt|,
name|op1_word
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* All but high-order word must be compared as unsigned.  */
name|comp
operator|=
name|compare_from_rtx
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
operator|(
name|unsignedp
operator|||
name|i
operator|>
literal|0
operator|)
condition|?
name|GTU
else|:
name|GT
argument_list|,
name|unsignedp
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|NULL_RTX
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
comment|/* Consider lower words only if these are equal.  */
name|comp
operator|=
name|compare_from_rtx
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
name|NE
argument_list|,
name|unsignedp
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare OP0 with OP1, word at a time, in mode MODE.    UNSIGNEDP says to do unsigned comparison.    Jump to IF_TRUE_LABEL if OP0 is greater, IF_FALSE_LABEL otherwise.  */
end_comment

begin_function
name|void
name|do_jump_by_parts_greater_rtx
parameter_list|(
name|mode
parameter_list|,
name|unsignedp
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|int
name|nwords
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|if_true_label
operator|||
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|if_true_label
condition|)
name|if_true_label
operator|=
name|drop_through_label
expr_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|if_false_label
operator|=
name|drop_through_label
expr_stmt|;
comment|/* Compare a word at a time, high order first.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|comp
decl_stmt|;
name|rtx
name|op0_word
decl_stmt|,
name|op1_word
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0_word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op1_word
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|nwords
operator|-
literal|1
operator|-
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* All but high-order word must be compared as unsigned.  */
name|comp
operator|=
name|compare_from_rtx
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
operator|(
name|unsignedp
operator|||
name|i
operator|>
literal|0
operator|)
condition|?
name|GTU
else|:
name|GT
argument_list|,
name|unsignedp
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|NULL_RTX
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
comment|/* Consider lower words only if these are equal.  */
name|comp
operator|=
name|compare_from_rtx
argument_list|(
name|op0_word
argument_list|,
name|op1_word
argument_list|,
name|NE
argument_list|,
name|unsignedp
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|NULL_RTX
argument_list|,
name|if_false_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an EQ_EXPR expression EXP for values too wide to be compared    with one insn, test the comparison and jump to the appropriate label.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_by_parts_equality
parameter_list|(
name|exp
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nwords
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|if_false_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|comp
init|=
name|compare_from_rtx
argument_list|(
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Jump according to whether OP0 is 0.    We assume that OP0 has an integer mode that is too wide    for the available compare insns.  */
end_comment

begin_function
name|void
name|do_jump_by_parts_equality_rtx
parameter_list|(
name|op0
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|rtx
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
name|int
name|nwords
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|rtx
name|part
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|drop_through_label
init|=
literal|0
decl_stmt|;
comment|/* The fastest way of doing this comparison on almost any machine is to      "or" all the words and compare the result.  If all have to be loaded      from memory and this is a very wide item, it's possible this may      be slower, but that's highly unlikely.  */
name|part
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|part
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nwords
operator|&&
name|part
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|part
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|part
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|,
name|part
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|!=
literal|0
condition|)
block|{
name|rtx
name|comp
init|=
name|compare_from_rtx
argument_list|(
name|part
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|1
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|==
name|const0_rtx
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
else|else
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|if_false_label
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we couldn't do the "or" simply, do this with a series of compares.  */
if|if
condition|(
operator|!
name|if_false_label
condition|)
name|drop_through_label
operator|=
name|if_false_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|comp
init|=
name|compare_from_rtx
argument_list|(
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|1
argument_list|,
name|word_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|==
name|const_true_rtx
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp
operator|!=
name|const0_rtx
condition|)
name|do_jump_for_compare
argument_list|(
name|comp
argument_list|,
name|if_false_label
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_true_label
condition|)
name|emit_jump
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_through_label
condition|)
name|emit_label
argument_list|(
name|drop_through_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a comparison expression in rtl form, output conditional branches to    IF_TRUE_LABEL, IF_FALSE_LABEL, or both.  */
end_comment

begin_function
specifier|static
name|void
name|do_jump_for_compare
parameter_list|(
name|comparison
parameter_list|,
name|if_false_label
parameter_list|,
name|if_true_label
parameter_list|)
name|rtx
name|comparison
decl_stmt|,
name|if_false_label
decl_stmt|,
name|if_true_label
decl_stmt|;
block|{
if|if
condition|(
name|if_true_label
condition|)
block|{
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
call|)
argument_list|(
name|if_true_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|if_false_label
condition|)
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|if_false_label
condition|)
block|{
name|rtx
name|first
init|=
name|get_last_insn
argument_list|()
decl_stmt|,
name|insn
decl_stmt|,
name|branch
decl_stmt|;
name|int
name|br_count
decl_stmt|;
comment|/* Output the branch with the opposite condition.  Then try to invert 	 what is generated.  If more than one insn is a branch, or if the 	 branch is not the last insn written, abort. If we can't invert 	 the branch, emit make a true label, redirect this jump to that, 	 emit a jump to the false label and define the true label.  */
comment|/* ??? Note that we wouldn't have to do any of this nonsense if 	 we passed both labels into a combined compare-and-branch.  	 Ah well, jump threading does a good job of repairing the damage.  */
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
index|]
call|)
argument_list|(
name|if_false_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Here we get the first insn that was just emitted.  It used to be the 	 case that, on some machines, emitting the branch would discard 	 the previous compare insn and emit a replacement.  This isn't 	 done anymore, but abort if we see that FIRST is deleted.  */
if|if
condition|(
name|first
operator|==
literal|0
condition|)
name|first
operator|=
name|get_insns
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|first
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* Look for multiple branches in this sequence, as might be generated 	 for a multi-word integer comparison.  */
name|br_count
operator|=
literal|0
expr_stmt|;
name|branch
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|branch
operator|=
name|insn
expr_stmt|;
name|br_count
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* If we've got one branch at the end of the sequence, 	 we can try to reverse it.  */
if|if
condition|(
name|br_count
operator|==
literal|1
operator|&&
name|NEXT_INSN
argument_list|(
name|branch
argument_list|)
operator|==
name|NULL_RTX
condition|)
block|{
name|rtx
name|insn_label
decl_stmt|;
name|insn_label
operator|=
name|XEXP
argument_list|(
name|condjump_label
argument_list|(
name|branch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|branch
argument_list|)
operator|=
name|insn_label
expr_stmt|;
if|if
condition|(
name|insn_label
operator|!=
name|if_false_label
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|invert_jump
argument_list|(
name|branch
argument_list|,
name|if_false_label
argument_list|)
condition|)
return|return;
block|}
comment|/* Multiple branches, or reversion failed.  Convert to branches 	 around an unconditional jump.  */
name|if_true_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|insn_label
decl_stmt|;
name|insn_label
operator|=
name|XEXP
argument_list|(
name|condjump_label
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|insn_label
expr_stmt|;
if|if
condition|(
name|insn_label
operator|==
name|if_false_label
condition|)
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|if_true_label
argument_list|)
expr_stmt|;
block|}
name|emit_jump
argument_list|(
name|if_false_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|if_true_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code for a comparison expression EXP    (including code to compute the values to be compared)    and set (CC0) according to the result.    SIGNED_CODE should be the rtx operation for this comparison for    signed data; UNSIGNED_CODE, likewise for use if data is unsigned.     We force a stack adjustment unless there are currently    things pushed on the stack that aren't yet used.  */
end_comment

begin_function
specifier|static
name|rtx
name|compare
parameter_list|(
name|exp
parameter_list|,
name|signed_code
parameter_list|,
name|unsigned_code
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
name|enum
name|rtx_code
name|signed_code
decl_stmt|,
name|unsigned_code
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
comment|/* Don't crash if the comparison was erroneous.  */
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|op0
return|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|code
operator|=
name|unsignedp
condition|?
name|unsigned_code
else|:
name|signed_code
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_canonicalize_funcptr_for_compare
comment|/* If function pointers need to be "canonicalized" before they can      be reliably compared, then canonicalize them.  */
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|rtx
name|new_op0
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_canonicalize_funcptr_for_compare
argument_list|(
name|new_op0
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|new_op0
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|rtx
name|new_op1
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_canonicalize_funcptr_for_compare
argument_list|(
name|new_op1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|new_op1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|expr_size
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|NULL_RTX
operator|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like compare but expects the values to compare as two rtx's.    The decision as to signed or unsigned comparison must be made by the caller.     If MODE is BLKmode, SIZE is an RTX giving the size of the objects being    compared.     If ALIGN is non-zero, it is the alignment of this type; if zero, the    size of MODE should be used.  */
end_comment

begin_function
name|rtx
name|compare_from_rtx
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|code
parameter_list|,
name|unsignedp
parameter_list|,
name|mode
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If one operand is constant, make it the second one.  Only do this      if the other operand is not constant as well.  */
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_force_mem
condition|)
block|{
name|op0
operator|=
name|force_not_mem
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_not_mem
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|tem
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
if|#
directive|if
literal|0
comment|/* There's no need to do this now that combine.c can eliminate lots of      sign extensions.  This can be less efficient in certain cases on other      machines.  */
comment|/* If this is a signed equality comparison, we can do it as an      unsigned comparison since zero-extension is cheaper than sign      extension and comparisons with zero are done as unsigned.  This is      the case even on machines that can do fast sign extension, since      zero-extension is easier to combine with other operations than      sign-extension is.  If we are comparing against a constant, we must      convert it to what it would look like unsigned.  */
block|if ((code == EQ || code == NE)&& ! unsignedp&& GET_MODE_BITSIZE (GET_MODE (op0))<= HOST_BITS_PER_WIDE_INT)     {       if (GET_CODE (op1) == CONST_INT&& (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0))) != INTVAL (op1)) 	op1 = GEN_INT (INTVAL (op1)& GET_MODE_MASK (GET_MODE (op0)));       unsignedp = 1;     }
endif|#
directive|endif
name|emit_cmp_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|cc0_rtx
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to calculate EXP using a store-flag instruction    and return an rtx for the result.  EXP is either a comparison    or a TRUTH_NOT_EXPR whose operand is a comparison.     If TARGET is nonzero, store the result there if convenient.     If ONLY_CHEAP is non-zero, only do this if it is likely to be very    cheap.     Return zero if there is no suitable set-flag instruction    available on this machine.     Once expand_expr has been called on the arguments of the comparison,    we are committed to doing the store flag, since it is not safe to    re-evaluate the expression.  We emit the store-flag insn by calling    emit_store_flag, but only expand the arguments if we have a reason    to believe that emit_store_flag will be successful.  If we think that    it will, but it isn't, we have to simulate the store-flag with a    set/jump/set sequence.  */
end_comment

begin_function
specifier|static
name|rtx
name|do_store_flag
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|,
name|only_cheap
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|only_cheap
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|enum
name|machine_mode
name|operand_mode
decl_stmt|;
name|int
name|invert
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|subtarget
init|=
name|target
decl_stmt|;
name|rtx
name|result
decl_stmt|,
name|label
decl_stmt|;
comment|/* If this is a TRUTH_NOT_EXPR, set a flag indicating we must invert the      result at the end.  We can't simply invert the test since it would      have already been inverted if it were valid.  This case occurs for      some floating-point comparisons.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|invert
operator|=
literal|1
operator|,
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|operand_mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* We won't bother with BLKmode store-flag operations because it would mean      passing a lot of information to emit_store_flag.  */
if|if
condition|(
name|operand_mode
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
comment|/* We won't bother with store-flag operations involving function pointers      when function pointers must be canonicalized before comparisons.  */
ifdef|#
directive|ifdef
name|HAVE_canonicalize_funcptr_for_compare
if|if
condition|(
name|HAVE_canonicalize_funcptr_for_compare
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* Get the rtx comparison code to use.  We know that EXP is a comparison      operation of some type.  Some comparisons against 1 and -1 can be      converted to comparisons with zero.  Do so here so that the tests      below will be aware that we have a comparison with zero.   These      tests will not catch constants in the first operand, but constants      are rarely passed as the first operand.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|unsignedp
condition|?
name|LEU
else|:
name|LE
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|LTU
else|:
name|LT
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|LT
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|LEU
else|:
name|LE
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
if|if
condition|(
operator|!
name|unsignedp
operator|&&
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|GE
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|GTU
else|:
name|GT
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|integer_zero_node
operator|,
name|code
operator|=
name|unsignedp
condition|?
name|GTU
else|:
name|GT
expr_stmt|;
else|else
name|code
operator|=
name|unsignedp
condition|?
name|GEU
else|:
name|GE
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Put a constant second.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tem
operator|=
name|arg0
expr_stmt|;
name|arg0
operator|=
name|arg1
expr_stmt|;
name|arg1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* If this is an equality or inequality test of a single bit, we can      do this by shifting the bit being tested to the low-order bit and      masking the result with the constant 1.  If the condition was EQ,      we xor it with 1.  This does not require an scc insn and is faster      than an scc insn even if we have it.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|bitnum
init|=
name|tree_log2
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|ops_unsignedp
decl_stmt|;
comment|/* If INNER is a right shift of a constant and it plus BITNUM does 	 not overflow, adjust BITNUM and INNER.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|RSHIFT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|bitnum
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|bitnum
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we are going to be able to omit the AND below, we must do our 	 operations as unsigned.  If we must use the AND, we have a choice. 	 Normally unsigned is faster, but for some machines signed is.  */
name|ops_unsignedp
operator|=
operator|(
name|bitnum
operator|==
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
condition|?
literal|1
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
else|:
operator|(
name|LOAD_EXTEND_OP
argument_list|(
name|operand_mode
argument_list|)
operator|==
name|SIGN_EXTEND
condition|?
literal|0
else|:
literal|1
operator|)
else|#
directive|else
else|:
literal|1
endif|#
directive|endif
block|)
function|;
end_function

begin_if
if|if
condition|(
name|subtarget
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|subtarget
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|subtarget
argument_list|)
operator|!=
name|operand_mode
operator|||
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|inner
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|op0
operator|=
name|expand_expr
argument_list|(
name|inner
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bitnum
operator|!=
literal|0
condition|)
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|bitnum
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|ops_unsignedp
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|ops_unsignedp
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|&&
operator|!
name|invert
operator|)
operator|||
operator|(
name|code
operator|==
name|NE
operator|&&
name|invert
operator|)
condition|)
name|op0
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|,
name|ops_unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Put the AND last so it can combine with more things.  */
end_comment

begin_if
if|if
condition|(
name|bitnum
operator|!=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
literal|1
condition|)
name|op0
operator|=
name|expand_and
argument_list|(
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|op0
return|;
end_return

begin_comment
unit|}
comment|/* Now see if we are likely to be able to do this.  Return if not.  */
end_comment

begin_expr_stmt
unit|if
operator|(
operator|!
name|can_compare_p
argument_list|(
name|operand_mode
argument_list|)
operator|)
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_expr_stmt
name|icode
operator|=
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|||
operator|(
name|only_cheap
operator|&&
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|0
index|]
operator|!=
name|mode
operator|)
condition|)
block|{
comment|/* We can only do this if it is one of the special cases that 	 can be handled without an scc insn.  */
if|if
condition|(
operator|(
name|code
operator|==
name|LT
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|only_cheap
operator|&&
name|code
operator|==
name|GE
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|BRANCH_COST
operator|>=
literal|0
operator|&&
operator|!
name|only_cheap
operator|&&
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
operator|&&
operator|(
operator|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|operand_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|operand_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
block|}
end_if

begin_expr_stmt
name|preexpand_calls
argument_list|(
name|exp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|subtarget
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|subtarget
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|subtarget
argument_list|)
operator|!=
name|operand_mode
operator|||
operator|!
name|safe_from_p
argument_list|(
name|subtarget
argument_list|,
name|arg1
argument_list|,
literal|1
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|subtarget
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Pass copies of OP0 and OP1 in case they contain a QUEUED.  This is safe      because, if the emit_store_flag does anything it will succeed and      OP0 and OP1 will not be used subsequently.  */
end_comment

begin_expr_stmt
name|result
operator|=
name|emit_store_flag
argument_list|(
name|target
argument_list|,
name|code
argument_list|,
name|queued_subexp_p
argument_list|(
name|op0
argument_list|)
condition|?
name|copy_rtx
argument_list|(
name|op0
argument_list|)
else|:
name|op0
argument_list|,
name|queued_subexp_p
argument_list|(
name|op1
argument_list|)
condition|?
name|copy_rtx
argument_list|(
name|op1
argument_list|)
else|:
name|op1
argument_list|,
name|operand_mode
argument_list|,
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|result
condition|)
block|{
if|if
condition|(
name|invert
condition|)
name|result
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_if

begin_comment
comment|/* If this failed, we have to do this with set/compare/jump/set code.  */
end_comment

begin_if
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|invert
condition|?
name|const0_rtx
else|:
name|const1_rtx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|result
operator|=
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|operand_mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
operator|(
name|result
operator|==
name|const0_rtx
operator|&&
operator|!
name|invert
operator|)
operator|||
operator|(
name|result
operator|!=
name|const0_rtx
operator|&&
name|invert
operator|)
operator|)
condition|?
name|const0_rtx
else|:
name|const1_rtx
operator|)
return|;
end_if

begin_expr_stmt
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
call|)
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|invert
condition|?
name|const1_rtx
else|:
name|const0_rtx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|target
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* Generate a tablejump instruction (used for switch statements).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_tablejump
end_ifdef

begin_comment
comment|/* INDEX is the value being switched on, with the lowest value    in the table already subtracted.    MODE is its expected mode (needed if INDEX is constant).    RANGE is the length of the jump table.    TABLE_LABEL is a CODE_LABEL rtx for the table itself.     DEFAULT_LABEL is a CODE_LABEL rtx to jump to if the    index value is out of range.  */
end_comment

begin_macro
unit|void
name|do_tablejump
argument_list|(
argument|index
argument_list|,
argument|mode
argument_list|,
argument|range
argument_list|,
argument|table_label
argument_list|,
argument|default_label
argument_list|)
end_macro

begin_decl_stmt
name|rtx
name|index
decl_stmt|,
name|range
decl_stmt|,
name|table_label
decl_stmt|,
name|default_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|rtx
name|temp
decl_stmt|,
name|vector
decl_stmt|;
comment|/* Do an unsigned comparison (in the proper mode) between the index      expression and the value which represents the length of the range.      Since we just finished subtracting the lower bound of the range      from the index expression, this comparison allows us to simultaneously      check that the original index expression value is both greater than      or equal to the minimum value of the range and less than or equal to      the maximum value of the range.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|index
argument_list|,
name|range
argument_list|,
name|GTU
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|default_label
argument_list|)
expr_stmt|;
comment|/* If index is in range, it must fit in Pmode.      Convert to Pmode so we can index with it.  */
if|if
condition|(
name|mode
operator|!=
name|Pmode
condition|)
name|index
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't let a MEM slip thru, because then INDEX that comes      out of PIC_CASE_VECTOR_ADDRESS won't be a valid address,      and break_out_memory_refs will go to work on it and mess it up.  */
ifdef|#
directive|ifdef
name|PIC_CASE_VECTOR_ADDRESS
if|if
condition|(
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|REG
condition|)
name|index
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If flag_force_addr were to affect this address      it could interfere with the tricky assumptions made      about addresses that contain label-refs,      which may be valid only very near the tablejump itself.  */
comment|/* ??? The only correct use of CASE_VECTOR_MODE is the one inside the      GET_MODE_SIZE, because this indicates how large insns are.  The other      uses should all be Pmode, because they are addresses.  This code      could fail if addresses and insns are not the same size.  */
name|index
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|index
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|CASE_VECTOR_MODE
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|table_label
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC_CASE_VECTOR_ADDRESS
if|if
condition|(
name|flag_pic
condition|)
name|index
operator|=
name|PIC_CASE_VECTOR_ADDRESS
argument_list|(
name|index
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|index
operator|=
name|memory_address_noforce
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|CASE_VECTOR_MODE
argument_list|)
expr_stmt|;
name|vector
operator|=
name|gen_rtx_MEM
argument_list|(
name|CASE_VECTOR_MODE
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|vector
argument_list|)
operator|=
literal|1
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|vector
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_tablejump
argument_list|(
name|temp
argument_list|,
name|table_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are generating PIC code or if the table is PC-relative, the      table and JUMP_INSN must be adjacent, so don't output a BARRIER.  */
if|if
condition|(
operator|!
name|CASE_VECTOR_PC_RELATIVE
operator|&&
operator|!
name|flag_pic
condition|)
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_tablejump */
end_comment

end_unit

