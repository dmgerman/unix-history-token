begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Data references and dependences detectors.    Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Sebastian Pop<pop@cri.ensmp.fr>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This pass walks a given loop structure searching for array    references.  The information about the array accesses is recorded    in DATA_REFERENCE structures.         The basic test for determining the dependences is:     given two access functions chrec1 and chrec2 to a same array, and     x and y two vectors from the iteration domain, the same element of     the array is accessed twice at iterations x and y if and only if:    |             chrec1 (x) == chrec2 (y).        The goals of this analysis are:        - to determine the independence: the relation between two      independent accesses is qualified with the chrec_known (this      information allows a loop parallelization),          - when two data references access the same data, to qualify the      dependence relation with classic dependence representations:              - distance vectors        - direction vectors        - loop carried level dependence        - polyhedron dependence      or with the chains of recurrences based representation,          - to define a knowledge base for storing the data dependence       information,          - to define an interface to access this data.            Definitions:        - subscript: given two array accesses a subscript is the tuple    composed of the access functions for a given dimension.  Example:    Given A[f1][f2][f3] and B[g1][g2][g3], there are three subscripts:    (f1, g1), (f2, g2), (f3, g3).     - Diophantine equation: an equation whose coefficients and    solutions are integer constants, for example the equation     |   3*x + 2*y = 1    has an integer solution x = 1 and y = -1.          References:        - "Advanced Compilation for High Performance Computing" by Randy    Allen and Ken Kennedy.    http://citeseer.ist.psu.edu/goff91practical.html         - "Loop Transformations for Restructuring Compilers - The Foundations"     by Utpal Banerjee.      */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/* These RTL headers are needed for basic-block.h.  */
end_comment

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-data-ref.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_struct
specifier|static
struct|struct
name|datadep_stats
block|{
name|int
name|num_dependence_tests
decl_stmt|;
name|int
name|num_dependence_dependent
decl_stmt|;
name|int
name|num_dependence_independent
decl_stmt|;
name|int
name|num_dependence_undetermined
decl_stmt|;
name|int
name|num_subscript_tests
decl_stmt|;
name|int
name|num_subscript_undetermined
decl_stmt|;
name|int
name|num_same_subscript_function
decl_stmt|;
name|int
name|num_ziv
decl_stmt|;
name|int
name|num_ziv_independent
decl_stmt|;
name|int
name|num_ziv_dependent
decl_stmt|;
name|int
name|num_ziv_unimplemented
decl_stmt|;
name|int
name|num_siv
decl_stmt|;
name|int
name|num_siv_independent
decl_stmt|;
name|int
name|num_siv_dependent
decl_stmt|;
name|int
name|num_siv_unimplemented
decl_stmt|;
name|int
name|num_miv
decl_stmt|;
name|int
name|num_miv_independent
decl_stmt|;
name|int
name|num_miv_dependent
decl_stmt|;
name|int
name|num_miv_unimplemented
decl_stmt|;
block|}
name|dependence_stats
struct|;
end_struct

begin_function_decl
specifier|static
name|tree
name|object_analysis
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|struct
name|data_reference
modifier|*
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|struct
name|ptr_info_def
modifier|*
modifier|*
parameter_list|,
name|subvar_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|data_reference
modifier|*
name|init_data_ref
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|struct
name|ptr_info_def
modifier|*
parameter_list|,
name|enum
name|data_ref_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|subscript_dependence_tester_1
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
parameter_list|,
name|struct
name|data_reference
modifier|*
parameter_list|,
name|struct
name|data_reference
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Determine if PTR and DECL may alias, the result is put in ALIASED.    Return FALSE if there is no symbol memory tag for PTR.  */
end_comment

begin_function
specifier|static
name|bool
name|ptr_decl_may_alias_p
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|tree
name|decl
parameter_list|,
name|struct
name|data_reference
modifier|*
name|ptr_dr
parameter_list|,
name|bool
modifier|*
name|aliased
parameter_list|)
block|{
name|tree
name|tag
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|DR_PTR_INFO
argument_list|(
name|ptr_dr
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|DECL_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
condition|)
name|tag
operator|=
name|pi
operator|->
name|name_mem_tag
expr_stmt|;
if|if
condition|(
operator|!
name|tag
condition|)
name|tag
operator|=
name|get_var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
if|if
condition|(
operator|!
name|tag
condition|)
name|tag
operator|=
name|DR_MEMTAG
argument_list|(
name|ptr_dr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag
condition|)
return|return
name|false
return|;
operator|*
name|aliased
operator|=
name|is_aliased_with
argument_list|(
name|tag
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine if two pointers may alias, the result is put in ALIASED.    Return FALSE if there is no symbol memory tag for one of the pointers.  */
end_comment

begin_function
specifier|static
name|bool
name|ptr_ptr_may_alias_p
parameter_list|(
name|tree
name|ptr_a
parameter_list|,
name|tree
name|ptr_b
parameter_list|,
name|struct
name|data_reference
modifier|*
name|dra
parameter_list|,
name|struct
name|data_reference
modifier|*
name|drb
parameter_list|,
name|bool
modifier|*
name|aliased
parameter_list|)
block|{
name|tree
name|tag_a
init|=
name|NULL_TREE
decl_stmt|,
name|tag_b
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi_a
init|=
name|DR_PTR_INFO
argument_list|(
name|dra
argument_list|)
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi_b
init|=
name|DR_PTR_INFO
argument_list|(
name|drb
argument_list|)
decl_stmt|;
if|if
condition|(
name|pi_a
operator|&&
name|pi_a
operator|->
name|name_mem_tag
operator|&&
name|pi_b
operator|&&
name|pi_b
operator|->
name|name_mem_tag
condition|)
block|{
name|tag_a
operator|=
name|pi_a
operator|->
name|name_mem_tag
expr_stmt|;
name|tag_b
operator|=
name|pi_b
operator|->
name|name_mem_tag
expr_stmt|;
block|}
else|else
block|{
name|tag_a
operator|=
name|get_var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ptr_a
argument_list|)
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
if|if
condition|(
operator|!
name|tag_a
condition|)
name|tag_a
operator|=
name|DR_MEMTAG
argument_list|(
name|dra
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag_a
condition|)
return|return
name|false
return|;
name|tag_b
operator|=
name|get_var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ptr_b
argument_list|)
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
if|if
condition|(
operator|!
name|tag_b
condition|)
name|tag_b
operator|=
name|DR_MEMTAG
argument_list|(
name|drb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag_b
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|tag_a
operator|==
name|tag_b
condition|)
operator|*
name|aliased
operator|=
name|true
expr_stmt|;
else|else
operator|*
name|aliased
operator|=
name|may_aliases_intersect
argument_list|(
name|tag_a
argument_list|,
name|tag_b
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine if BASE_A and BASE_B may alias, the result is put in ALIASED.    Return FALSE if there is no symbol memory tag for one of the symbols.  */
end_comment

begin_function
specifier|static
name|bool
name|may_alias_p
parameter_list|(
name|tree
name|base_a
parameter_list|,
name|tree
name|base_b
parameter_list|,
name|struct
name|data_reference
modifier|*
name|dra
parameter_list|,
name|struct
name|data_reference
modifier|*
name|drb
parameter_list|,
name|bool
modifier|*
name|aliased
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|ADDR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
operator|*
name|aliased
operator|=
operator|(
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|ptr_decl_may_alias_p
argument_list|(
name|base_b
argument_list|,
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|drb
argument_list|,
name|aliased
argument_list|)
return|;
else|else
return|return
name|ptr_decl_may_alias_p
argument_list|(
name|base_a
argument_list|,
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dra
argument_list|,
name|aliased
argument_list|)
return|;
block|}
return|return
name|ptr_ptr_may_alias_p
argument_list|(
name|base_a
argument_list|,
name|base_b
argument_list|,
name|dra
argument_list|,
name|drb
argument_list|,
name|aliased
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if a pointer (BASE_A) and a record/union access (BASE_B)    are not aliased. Return TRUE if they differ.  */
end_comment

begin_function
specifier|static
name|bool
name|record_ptr_differ_p
parameter_list|(
name|struct
name|data_reference
modifier|*
name|dra
parameter_list|,
name|struct
name|data_reference
modifier|*
name|drb
parameter_list|)
block|{
name|bool
name|aliased
decl_stmt|;
name|tree
name|base_a
init|=
name|DR_BASE_OBJECT
argument_list|(
name|dra
argument_list|)
decl_stmt|;
name|tree
name|base_b
init|=
name|DR_BASE_OBJECT
argument_list|(
name|drb
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|!=
name|COMPONENT_REF
condition|)
return|return
name|false
return|;
comment|/* Peel COMPONENT_REFs to get to the base. Do not peel INDIRECT_REFs.      For a.b.c.d[i] we will get a, and for a.b->c.d[i] we will get a.b.        Probably will be unnecessary with struct alias analysis.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|base_b
operator|=
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compare a record/union access (b.c[i] or p->c[i]) and a pointer      ((*q)[i]).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|ptr_decl_may_alias_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|base_b
argument_list|,
name|dra
argument_list|,
operator|&
name|aliased
argument_list|)
operator|&&
operator|!
name|aliased
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
operator|(
name|ptr_ptr_may_alias_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dra
argument_list|,
name|drb
argument_list|,
operator|&
name|aliased
argument_list|)
operator|&&
operator|!
name|aliased
operator|)
operator|)
operator|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determine if two record/union accesses are aliased. Return TRUE if they     differ.  */
end_comment

begin_function
specifier|static
name|bool
name|record_record_differ_p
parameter_list|(
name|struct
name|data_reference
modifier|*
name|dra
parameter_list|,
name|struct
name|data_reference
modifier|*
name|drb
parameter_list|)
block|{
name|bool
name|aliased
decl_stmt|;
name|tree
name|base_a
init|=
name|DR_BASE_OBJECT
argument_list|(
name|dra
argument_list|)
decl_stmt|;
name|tree
name|base_b
init|=
name|DR_BASE_OBJECT
argument_list|(
name|drb
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|!=
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|!=
name|COMPONENT_REF
condition|)
return|return
name|false
return|;
comment|/* Peel COMPONENT_REFs to get to the base. Do not peel INDIRECT_REFs.      For a.b.c.d[i] we will get a, and for a.b->c.d[i] we will get a.b.        Probably will be unnecessary with struct alias analysis.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|base_b
operator|=
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|base_a
operator|=
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|ptr_ptr_may_alias_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dra
argument_list|,
name|drb
argument_list|,
operator|&
name|aliased
argument_list|)
operator|&&
operator|!
name|aliased
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determine if an array access (BASE_A) and a record/union access (BASE_B)    are not aliased. Return TRUE if they differ.  */
end_comment

begin_function
specifier|static
name|bool
name|record_array_differ_p
parameter_list|(
name|struct
name|data_reference
modifier|*
name|dra
parameter_list|,
name|struct
name|data_reference
modifier|*
name|drb
parameter_list|)
block|{
name|bool
name|aliased
decl_stmt|;
name|tree
name|base_a
init|=
name|DR_BASE_OBJECT
argument_list|(
name|dra
argument_list|)
decl_stmt|;
name|tree
name|base_b
init|=
name|DR_BASE_OBJECT
argument_list|(
name|drb
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|!=
name|COMPONENT_REF
condition|)
return|return
name|false
return|;
comment|/* Peel COMPONENT_REFs to get to the base. Do not peel INDIRECT_REFs.      For a.b.c.d[i] we will get a, and for a.b->c.d[i] we will get a.b.        Probably will be unnecessary with struct alias analysis.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|base_b
operator|=
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compare a record/union access (b.c[i] or p->c[i]) and an array access       (a[i]). In case of p->c[i] use alias analysis to verify that p is not      pointing to a.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|VAR_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
operator|(
name|ptr_decl_may_alias_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|base_a
argument_list|,
name|drb
argument_list|,
operator|&
name|aliased
argument_list|)
operator|&&
operator|!
name|aliased
operator|)
operator|)
operator|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determine if an array access (BASE_A) and a pointer (BASE_B)    are not aliased. Return TRUE if they differ.  */
end_comment

begin_function
specifier|static
name|bool
name|array_ptr_differ_p
parameter_list|(
name|tree
name|base_a
parameter_list|,
name|tree
name|base_b
parameter_list|,
name|struct
name|data_reference
modifier|*
name|drb
parameter_list|)
block|{
name|bool
name|aliased
decl_stmt|;
comment|/* In case one of the bases is a pointer (a[i] and (*p)[i]), we check with the      help of alias analysis that p is not pointing to a.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
operator|(
name|ptr_decl_may_alias_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|base_a
argument_list|,
name|drb
argument_list|,
operator|&
name|aliased
argument_list|)
operator|&&
operator|!
name|aliased
operator|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* This is the simplest data dependence test: determines whether the    data references A and B access the same array/region.  Returns    false when the property is not computable at compile time.    Otherwise return true, and DIFFER_P will record the result. This    utility will not be necessary when alias_sets_conflict_p will be    less conservative.  */
end_comment

begin_function
specifier|static
name|bool
name|base_object_differ_p
parameter_list|(
name|struct
name|data_reference
modifier|*
name|a
parameter_list|,
name|struct
name|data_reference
modifier|*
name|b
parameter_list|,
name|bool
modifier|*
name|differ_p
parameter_list|)
block|{
name|tree
name|base_a
init|=
name|DR_BASE_OBJECT
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|tree
name|base_b
init|=
name|DR_BASE_OBJECT
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|bool
name|aliased
decl_stmt|;
if|if
condition|(
operator|!
name|base_a
operator|||
operator|!
name|base_b
condition|)
return|return
name|false
return|;
comment|/* Determine if same base.  Example: for the array accesses      a[i], b[i] or pointer accesses *a, *b, bases are a, b.  */
if|if
condition|(
name|base_a
operator|==
name|base_b
condition|)
block|{
operator|*
name|differ_p
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* For pointer based accesses, (*p)[i], (*q)[j], the bases are (*p)      and (*q)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|differ_p
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Record/union based accesses - s.a[i], t.b[j]. bases are s.a,t.b.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|1
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|differ_p
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Determine if different bases.  */
comment|/* At this point we know that base_a != base_b.  However, pointer      accesses of the form x=(*p) and y=(*q), whose bases are p and q,      may still be pointing to the same base. In SSAed GIMPLE p and q will      be SSA_NAMES in this case.  Therefore, here we check if they are      really two different declarations.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
operator|*
name|differ_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* In case one of the bases is a pointer (a[i] and (*p)[i]), we check with the      help of alias analysis that p is not pointing to a.  */
if|if
condition|(
name|array_ptr_differ_p
argument_list|(
name|base_a
argument_list|,
name|base_b
argument_list|,
name|b
argument_list|)
operator|||
name|array_ptr_differ_p
argument_list|(
name|base_b
argument_list|,
name|base_a
argument_list|,
name|a
argument_list|)
condition|)
block|{
operator|*
name|differ_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If the bases are pointers ((*q)[i] and (*p)[i]), we check with the      help of alias analysis they don't point to the same bases.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
operator|(
name|may_alias_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|aliased
argument_list|)
operator|&&
operator|!
name|aliased
operator|)
condition|)
block|{
operator|*
name|differ_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Compare two record/union bases s.a and t.b: s != t or (a != b and      s and t are not unions).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base_a
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|base_b
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
operator|!=
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_OPERAND
argument_list|(
name|base_a
argument_list|,
literal|1
argument_list|)
operator|!=
name|TREE_OPERAND
argument_list|(
name|base_b
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
condition|)
block|{
operator|*
name|differ_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Compare a record/union access (b.c[i] or p->c[i]) and a pointer      ((*q)[i]).  */
if|if
condition|(
name|record_ptr_differ_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|||
name|record_ptr_differ_p
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
condition|)
block|{
operator|*
name|differ_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Compare a record/union access (b.c[i] or p->c[i]) and an array access       (a[i]). In case of p->c[i] use alias analysis to verify that p is not      pointing to a.  */
if|if
condition|(
name|record_array_differ_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|||
name|record_array_differ_p
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
condition|)
block|{
operator|*
name|differ_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Compare two record/union accesses (b.c[i] or p->c[i]).  */
if|if
condition|(
name|record_record_differ_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
block|{
operator|*
name|differ_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Function base_addr_differ_p.     This is the simplest data dependence test: determines whether the    data references DRA and DRB access the same array/region.  Returns    false when the property is not computable at compile time.    Otherwise return true, and DIFFER_P will record the result.     The algorithm:       1. if (both DRA and DRB are represented as arrays)           compare DRA.BASE_OBJECT and DRB.BASE_OBJECT    2. else if (both DRA and DRB are represented as pointers)           try to prove that DRA.FIRST_LOCATION == DRB.FIRST_LOCATION    3. else if (DRA and DRB are represented differently or 2. fails)           only try to prove that the bases are surely different */
end_comment

begin_function
specifier|static
name|bool
name|base_addr_differ_p
parameter_list|(
name|struct
name|data_reference
modifier|*
name|dra
parameter_list|,
name|struct
name|data_reference
modifier|*
name|drb
parameter_list|,
name|bool
modifier|*
name|differ_p
parameter_list|)
block|{
name|tree
name|addr_a
init|=
name|DR_BASE_ADDRESS
argument_list|(
name|dra
argument_list|)
decl_stmt|;
name|tree
name|addr_b
init|=
name|DR_BASE_ADDRESS
argument_list|(
name|drb
argument_list|)
decl_stmt|;
name|tree
name|type_a
decl_stmt|,
name|type_b
decl_stmt|;
name|bool
name|aliased
decl_stmt|;
if|if
condition|(
operator|!
name|addr_a
operator|||
operator|!
name|addr_b
condition|)
return|return
name|false
return|;
name|type_a
operator|=
name|TREE_TYPE
argument_list|(
name|addr_a
argument_list|)
expr_stmt|;
name|type_b
operator|=
name|TREE_TYPE
argument_list|(
name|addr_b
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|POINTER_TYPE_P
argument_list|(
name|type_a
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|type_b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1. if (both DRA and DRB are represented as arrays)             compare DRA.BASE_OBJECT and DRB.BASE_OBJECT.  */
if|if
condition|(
name|DR_TYPE
argument_list|(
name|dra
argument_list|)
operator|==
name|ARRAY_REF_TYPE
operator|&&
name|DR_TYPE
argument_list|(
name|drb
argument_list|)
operator|==
name|ARRAY_REF_TYPE
condition|)
return|return
name|base_object_differ_p
argument_list|(
name|dra
argument_list|,
name|drb
argument_list|,
name|differ_p
argument_list|)
return|;
comment|/* 2. else if (both DRA and DRB are represented as pointers) 	    try to prove that DRA.FIRST_LOCATION == DRB.FIRST_LOCATION.  */
comment|/* If base addresses are the same, we check the offsets, since the access of       the data-ref is described by {base addr + offset} and its access function,      i.e., in order to decide whether the bases of data-refs are the same we       compare both base addresses and offsets.  */
if|if
condition|(
name|DR_TYPE
argument_list|(
name|dra
argument_list|)
operator|==
name|POINTER_REF_TYPE
operator|&&
name|DR_TYPE
argument_list|(
name|drb
argument_list|)
operator|==
name|POINTER_REF_TYPE
operator|&&
operator|(
name|addr_a
operator|==
name|addr_b
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|addr_a
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|addr_b
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|addr_a
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|addr_b
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Compare offsets.  */
name|tree
name|offset_a
init|=
name|DR_OFFSET
argument_list|(
name|dra
argument_list|)
decl_stmt|;
name|tree
name|offset_b
init|=
name|DR_OFFSET
argument_list|(
name|drb
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|offset_a
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|offset_b
argument_list|)
expr_stmt|;
comment|/* FORNOW: we only compare offsets that are MULT_EXPR, i.e., we don't handle 	 PLUS_EXPR.  */
if|if
condition|(
name|offset_a
operator|==
name|offset_b
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|offset_a
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|offset_b
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|offset_a
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|offset_b
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|offset_a
argument_list|,
literal|1
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|offset_b
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
operator|*
name|differ_p
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/*  3. else if (DRA and DRB are represented differently or 2. fails)                only try to prove that the bases are surely different.  */
comment|/* Apply alias analysis.  */
if|if
condition|(
name|may_alias_p
argument_list|(
name|addr_a
argument_list|,
name|addr_b
argument_list|,
name|dra
argument_list|,
name|drb
argument_list|,
operator|&
name|aliased
argument_list|)
operator|&&
operator|!
name|aliased
condition|)
block|{
operator|*
name|differ_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* An instruction writing through a restricted pointer is "independent" of any       instruction reading or writing through a different pointer, in the same       block/scope.  */
elseif|else
if|if
condition|(
operator|(
name|TYPE_RESTRICT
argument_list|(
name|type_a
argument_list|)
operator|&&
operator|!
name|DR_IS_READ
argument_list|(
name|dra
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_RESTRICT
argument_list|(
name|type_b
argument_list|)
operator|&&
operator|!
name|DR_IS_READ
argument_list|(
name|drb
argument_list|)
operator|)
condition|)
block|{
operator|*
name|differ_p
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff A divides B.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|tree_fold_divides_p
parameter_list|(
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|)
block|{
comment|/* Determines whether (A == gcd (A, B)).  */
return|return
name|tree_int_cst_equal
argument_list|(
name|a
argument_list|,
name|tree_fold_gcd
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff A divides B.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|int_divides_p
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
name|b
operator|%
name|a
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dump into FILE all the data references from DATAREFS.  */
end_comment

begin_decl_stmt
name|void
name|dump_data_references
argument_list|(
name|FILE
operator|*
name|file
argument_list|,
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
name|dump_data_reference
argument_list|(
name|file
argument_list|,
name|dr
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Dump into FILE all the dependence relations from DDRS.  */
end_comment

begin_decl_stmt
name|void
name|dump_data_dependence_relations
argument_list|(
name|FILE
operator|*
name|file
argument_list|,
name|VEC
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|)
operator|*
name|ddrs
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|data_dependence_relation
modifier|*
name|ddr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ddr_p
argument_list|,
name|ddrs
argument_list|,
name|i
argument_list|,
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
name|dump_data_dependence_relation
argument_list|(
name|file
argument_list|,
name|ddr
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Dump function for a DATA_REFERENCE structure.  */
end_comment

begin_function
name|void
name|dump_data_reference
parameter_list|(
name|FILE
modifier|*
name|outf
parameter_list|,
name|struct
name|data_reference
modifier|*
name|dr
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"(Data Ref: \n  stmt: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|outf
argument_list|,
name|DR_STMT
argument_list|(
name|dr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  ref: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|outf
argument_list|,
name|DR_REF
argument_list|(
name|dr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  base_object: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|outf
argument_list|,
name|DR_BASE_OBJECT
argument_list|(
name|dr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DR_NUM_DIMENSIONS
argument_list|(
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  Access function %d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|outf
argument_list|,
name|DR_ACCESS_FN
argument_list|(
name|dr
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump function for a SUBSCRIPT structure.  */
end_comment

begin_function
name|void
name|dump_subscript
parameter_list|(
name|FILE
modifier|*
name|outf
parameter_list|,
name|struct
name|subscript
modifier|*
name|subscript
parameter_list|)
block|{
name|tree
name|chrec
init|=
name|SUB_CONFLICTS_IN_A
argument_list|(
name|subscript
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"\n (subscript \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  iterations_that_access_an_element_twice_in_A: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|outf
argument_list|,
name|chrec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chrec
operator|==
name|chrec_known
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"    (no dependence)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|chrec
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"    (don't know)\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|last_iteration
init|=
name|SUB_LAST_CONFLICT
argument_list|(
name|subscript
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  last_conflict: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|outf
argument_list|,
name|last_iteration
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|chrec
operator|=
name|SUB_CONFLICTS_IN_B
argument_list|(
name|subscript
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  iterations_that_access_an_element_twice_in_B: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|outf
argument_list|,
name|chrec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chrec
operator|==
name|chrec_known
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"    (no dependence)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|chrec
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"    (don't know)\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|last_iteration
init|=
name|SUB_LAST_CONFLICT
argument_list|(
name|subscript
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  last_conflict: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|outf
argument_list|,
name|last_iteration
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  (Subscript distance: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|outf
argument_list|,
name|SUB_DISTANCE
argument_list|(
name|subscript
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  )\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|" )\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the classic direction vector DIRV to OUTF.  */
end_comment

begin_function
name|void
name|print_direction_vector
parameter_list|(
name|FILE
modifier|*
name|outf
parameter_list|,
name|lambda_vector
name|dirv
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|eq
decl_stmt|;
for|for
control|(
name|eq
operator|=
literal|0
init|;
name|eq
operator|<
name|length
condition|;
name|eq
operator|++
control|)
block|{
name|enum
name|data_dependence_direction
name|dir
init|=
name|dirv
index|[
name|eq
index|]
decl_stmt|;
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|dir_positive
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"    +"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_negative
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"    -"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_equal
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"    ="
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_positive_or_equal
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"   +="
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_positive_or_negative
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"   +-"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_negative_or_equal
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"   -="
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_star
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"    *"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"indep"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a vector of direction vectors.  */
end_comment

begin_decl_stmt
name|void
name|print_dir_vectors
argument_list|(
name|FILE
operator|*
name|outf
argument_list|,
name|VEC
argument_list|(
name|lambda_vector
argument_list|,
name|heap
argument_list|)
operator|*
name|dir_vects
argument_list|,
name|int
name|length
argument_list|)
block|{
name|unsigned
name|j
decl_stmt|;
name|lambda_vector
name|v
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|lambda_vector
argument_list|,
name|dir_vects
argument_list|,
name|j
argument_list|,
name|v
argument_list|)
condition|;
name|j
operator|++
control|)
name|print_direction_vector
argument_list|(
name|outf
argument_list|,
name|v
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print a vector of distance vectors.  */
end_comment

begin_decl_stmt
name|void
name|print_dist_vectors
argument_list|(
name|FILE
operator|*
name|outf
argument_list|,
name|VEC
argument_list|(
name|lambda_vector
argument_list|,
name|heap
argument_list|)
operator|*
name|dist_vects
argument_list|,
name|int
name|length
argument_list|)
block|{
name|unsigned
name|j
decl_stmt|;
name|lambda_vector
name|v
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|lambda_vector
argument_list|,
name|dist_vects
argument_list|,
name|j
argument_list|,
name|v
argument_list|)
condition|;
name|j
operator|++
control|)
name|print_lambda_vector
argument_list|(
name|outf
argument_list|,
name|v
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Debug version.  */
end_comment

begin_function
name|void
name|debug_data_dependence_relation
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
name|dump_data_dependence_relation
argument_list|(
name|stderr
argument_list|,
name|ddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump function for a DATA_DEPENDENCE_RELATION structure.  */
end_comment

begin_function
name|void
name|dump_data_dependence_relation
parameter_list|(
name|FILE
modifier|*
name|outf
parameter_list|,
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
name|struct
name|data_reference
modifier|*
name|dra
decl_stmt|,
modifier|*
name|drb
decl_stmt|;
name|dra
operator|=
name|DDR_A
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
name|drb
operator|=
name|DDR_B
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"(Data Dep: \n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|chrec_dont_know
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"    (don't know)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|chrec_known
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"    (no dependence)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loopi
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DDR_NUM_SUBSCRIPTS
argument_list|(
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  access_fn_A: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|outf
argument_list|,
name|DR_ACCESS_FN
argument_list|(
name|dra
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  access_fn_B: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|outf
argument_list|,
name|DR_ACCESS_FN
argument_list|(
name|drb
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dump_subscript
argument_list|(
name|outf
argument_list|,
name|DDR_SUBSCRIPT
argument_list|(
name|ddr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  loop nest: ("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|loop_p
argument_list|,
name|DDR_LOOP_NEST
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|i
argument_list|,
name|loopi
argument_list|)
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%d "
argument_list|,
name|loopi
operator|->
name|num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DDR_NUM_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  distance_vector: "
argument_list|)
expr_stmt|;
name|print_lambda_vector
argument_list|(
name|outf
argument_list|,
name|DDR_DIST_VECT
argument_list|(
name|ddr
argument_list|,
name|i
argument_list|)
argument_list|,
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DDR_NUM_DIR_VECTS
argument_list|(
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"  direction_vector: "
argument_list|)
expr_stmt|;
name|print_direction_vector
argument_list|(
name|outf
argument_list|,
name|DDR_DIR_VECT
argument_list|(
name|ddr
argument_list|,
name|i
argument_list|)
argument_list|,
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump function for a DATA_DEPENDENCE_DIRECTION structure.  */
end_comment

begin_function
name|void
name|dump_data_dependence_direction
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|enum
name|data_dependence_direction
name|dir
parameter_list|)
block|{
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|dir_positive
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_negative
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_equal
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_positive_or_negative
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+-"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_positive_or_equal
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+="
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_negative_or_equal
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-="
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_star
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Dumps the distance and direction vectors in FILE.  DDRS contains    the dependence relations, and VECT_SIZE is the size of the    dependence vectors, or in other words the number of loops in the    considered nest.  */
end_comment

begin_decl_stmt
name|void
name|dump_dist_dir_vectors
argument_list|(
name|FILE
operator|*
name|file
argument_list|,
name|VEC
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|)
operator|*
name|ddrs
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|data_dependence_relation
modifier|*
name|ddr
decl_stmt|;
name|lambda_vector
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ddr_p
argument_list|,
name|ddrs
argument_list|,
name|i
argument_list|,
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DDR_AFFINE_P
argument_list|(
name|ddr
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|lambda_vector
argument_list|,
name|DDR_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|j
argument_list|,
name|v
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"DISTANCE_V ("
argument_list|)
expr_stmt|;
name|print_lambda_vector
argument_list|(
name|file
argument_list|,
name|v
argument_list|,
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|lambda_vector
argument_list|,
name|DDR_DIR_VECTS
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|j
argument_list|,
name|v
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"DIRECTION_V ("
argument_list|)
expr_stmt|;
name|print_direction_vector
argument_list|(
name|file
argument_list|,
name|v
argument_list|,
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Dumps the data dependence relations DDRS in FILE.  */
end_comment

begin_decl_stmt
name|void
name|dump_ddrs
argument_list|(
name|FILE
operator|*
name|file
argument_list|,
name|VEC
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|)
operator|*
name|ddrs
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|data_dependence_relation
modifier|*
name|ddr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ddr_p
argument_list|,
name|ddrs
argument_list|,
name|i
argument_list|,
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
name|dump_data_dependence_relation
argument_list|(
name|file
argument_list|,
name|ddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Estimate the number of iterations from the size of the data and the    access functions.  */
end_comment

begin_function
specifier|static
name|void
name|estimate_niter_from_size_of_data
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|opnd0
parameter_list|,
name|tree
name|access_fn
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|estimation
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|array_size
decl_stmt|,
name|data_size
decl_stmt|,
name|element_size
decl_stmt|;
name|tree
name|init
decl_stmt|,
name|step
decl_stmt|;
name|init
operator|=
name|initial_condition
argument_list|(
name|access_fn
argument_list|)
expr_stmt|;
name|step
operator|=
name|evolution_part_in_loop_num
argument_list|(
name|access_fn
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|array_size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|opnd0
argument_list|)
argument_list|)
expr_stmt|;
name|element_size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|opnd0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_size
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|array_size
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|element_size
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return;
name|data_size
operator|=
name|fold_build2
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|array_size
argument_list|,
name|element_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|step
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|i_plus_s
init|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|init
argument_list|,
name|step
argument_list|)
decl_stmt|;
name|tree
name|sign
init|=
name|fold_binary
argument_list|(
name|GT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|i_plus_s
argument_list|,
name|init
argument_list|)
decl_stmt|;
if|if
condition|(
name|sign
operator|==
name|boolean_true_node
condition|)
name|estimation
operator|=
name|fold_build2
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|data_size
argument_list|,
name|init
argument_list|)
argument_list|,
name|step
argument_list|)
expr_stmt|;
comment|/* When the step is negative, as in PR23386: (init = 3, step = 	 0ffffffff, data_size = 100), we have to compute the 	 estimation as ceil_div (init, 0 - step) + 1.  */
elseif|else
if|if
condition|(
name|sign
operator|==
name|boolean_false_node
condition|)
name|estimation
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|fold_build2
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|init
argument_list|,
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|unsigned_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|step
argument_list|)
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|estimation
condition|)
name|record_estimate
argument_list|(
name|loop
argument_list|,
name|estimation
argument_list|,
name|boolean_true_node
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given an ARRAY_REF node REF, records its access functions.    Example: given A[i][3], record in ACCESS_FNS the opnd1 function,    i.e. the constant "3", then recursively call the function on opnd0,    i.e. the ARRAY_REF "A[i]".      If ESTIMATE_ONLY is true, we just set the estimated number of loop    iterations, we don't store the access function.    The function returns the base name: "A".  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|analyze_array_indexes
argument_list|(
expr|struct
name|loop
operator|*
name|loop
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|access_fns
argument_list|,
name|tree
name|ref
argument_list|,
name|tree
name|stmt
argument_list|,
name|bool
name|estimate_only
argument_list|)
block|{
name|tree
name|opnd0
decl_stmt|,
name|opnd1
decl_stmt|;
name|tree
name|access_fn
decl_stmt|;
name|opnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opnd1
operator|=
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The detection of the evolution function for this data access is      postponed until the dependence test.  This lazy strategy avoids      the computation of access functions that are of no interest for      the optimizers.  */
name|access_fn
operator|=
name|instantiate_parameters
argument_list|(
name|loop
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|opnd1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|estimate_only
operator|&&
name|chrec_contains_undetermined
argument_list|(
name|loop
operator|->
name|estimated_nb_iterations
argument_list|)
condition|)
name|estimate_niter_from_size_of_data
argument_list|(
name|loop
argument_list|,
name|opnd0
argument_list|,
name|access_fn
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|estimate_only
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|access_fns
argument_list|,
name|access_fn
argument_list|)
expr_stmt|;
comment|/* Recursively record other array access functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|opnd0
argument_list|)
operator|==
name|ARRAY_REF
condition|)
return|return
name|analyze_array_indexes
argument_list|(
name|loop
argument_list|,
name|access_fns
argument_list|,
name|opnd0
argument_list|,
name|stmt
argument_list|,
name|estimate_only
argument_list|)
return|;
comment|/* Return the base name of the data access.  */
else|else
return|return
name|opnd0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* For an array reference REF contained in STMT, attempt to bound the    number of iterations in the loop containing STMT  */
end_comment

begin_function
name|void
name|estimate_iters_using_array
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|ref
parameter_list|)
block|{
name|analyze_array_indexes
argument_list|(
name|loop_containing_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|ref
argument_list|,
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a data reference REF contained in the statement STMT, initialize    a DATA_REFERENCE structure, and return it.  IS_READ flag has to be    set to true when REF is in the right hand side of an    assignment.  */
end_comment

begin_function
name|struct
name|data_reference
modifier|*
name|analyze_array
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|ref
parameter_list|,
name|bool
name|is_read
parameter_list|)
block|{
name|struct
name|data_reference
modifier|*
name|res
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|acc_fns
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(analyze_array \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (ref = "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|XNEW
argument_list|(
expr|struct
name|data_reference
argument_list|)
expr_stmt|;
name|DR_STMT
argument_list|(
name|res
argument_list|)
operator|=
name|stmt
expr_stmt|;
name|DR_REF
argument_list|(
name|res
argument_list|)
operator|=
name|ref
expr_stmt|;
name|acc_fns
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DR_BASE_OBJECT
argument_list|(
name|res
argument_list|)
operator|=
name|analyze_array_indexes
argument_list|(
name|loop_containing_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|,
operator|&
name|acc_fns
argument_list|,
name|ref
argument_list|,
name|stmt
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|DR_TYPE
argument_list|(
name|res
argument_list|)
operator|=
name|ARRAY_REF_TYPE
expr_stmt|;
name|DR_SET_ACCESS_FNS
argument_list|(
name|res
argument_list|,
name|acc_fns
argument_list|)
expr_stmt|;
name|DR_IS_READ
argument_list|(
name|res
argument_list|)
operator|=
name|is_read
expr_stmt|;
name|DR_BASE_ADDRESS
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_OFFSET
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_INIT
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_STEP
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_OFFSET_MISALIGNMENT
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_MEMTAG
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_PTR_INFO
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Analyze an indirect memory reference, REF, that comes from STMT.    IS_READ is true if this is an indirect load, and false if it is    an indirect store.    Return a new data reference structure representing the indirect_ref, or    NULL if we cannot describe the access function.  */
end_comment

begin_function
specifier|static
name|struct
name|data_reference
modifier|*
name|analyze_indirect_ref
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|ref
parameter_list|,
name|bool
name|is_read
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|loop_containing_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|ptr_ref
init|=
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|access_fn
init|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|ptr_ref
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|initial_condition_in_loop_num
argument_list|(
name|access_fn
argument_list|,
name|loop
operator|->
name|num
argument_list|)
decl_stmt|;
name|tree
name|base_address
init|=
name|NULL_TREE
decl_stmt|,
name|evolution
decl_stmt|,
name|step
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|ptr_info
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptr_ref
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|ptr_info
operator|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr_ref
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_fn
operator|==
name|chrec_dont_know
operator|||
operator|!
name|init
operator|||
name|init
operator|==
name|chrec_dont_know
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nBad access function of ptr: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nAccess function of ptr: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|access_fn
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|expr_invariant_in_loop_p
argument_list|(
name|loop
argument_list|,
name|init
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\ninitial condition is not loop invariant.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base_address
operator|=
name|init
expr_stmt|;
name|evolution
operator|=
name|evolution_part_in_loop_num
argument_list|(
name|access_fn
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|evolution
operator|!=
name|chrec_dont_know
condition|)
block|{
if|if
condition|(
operator|!
name|evolution
condition|)
name|step
operator|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|evolution
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|step
operator|=
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|evolution
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nnon constant step for ptr access.\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nunknown evolution of ptr.\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|init_data_ref
argument_list|(
name|stmt
argument_list|,
name|ref
argument_list|,
name|NULL_TREE
argument_list|,
name|access_fn
argument_list|,
name|is_read
argument_list|,
name|base_address
argument_list|,
name|NULL_TREE
argument_list|,
name|step
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|ptr_info
argument_list|,
name|POINTER_REF_TYPE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For a data reference REF contained in the statement STMT, initialize    a DATA_REFERENCE structure, and return it.  */
end_comment

begin_function
name|struct
name|data_reference
modifier|*
name|init_data_ref
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|ref
parameter_list|,
name|tree
name|base
parameter_list|,
name|tree
name|access_fn
parameter_list|,
name|bool
name|is_read
parameter_list|,
name|tree
name|base_address
parameter_list|,
name|tree
name|init_offset
parameter_list|,
name|tree
name|step
parameter_list|,
name|tree
name|misalign
parameter_list|,
name|tree
name|memtag
parameter_list|,
name|struct
name|ptr_info_def
modifier|*
name|ptr_info
parameter_list|,
name|enum
name|data_ref_type
name|type
parameter_list|)
block|{
name|struct
name|data_reference
modifier|*
name|res
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|acc_fns
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(init_data_ref \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (ref = "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|XNEW
argument_list|(
expr|struct
name|data_reference
argument_list|)
expr_stmt|;
name|DR_STMT
argument_list|(
name|res
argument_list|)
operator|=
name|stmt
expr_stmt|;
name|DR_REF
argument_list|(
name|res
argument_list|)
operator|=
name|ref
expr_stmt|;
name|DR_BASE_OBJECT
argument_list|(
name|res
argument_list|)
operator|=
name|base
expr_stmt|;
name|DR_TYPE
argument_list|(
name|res
argument_list|)
operator|=
name|type
expr_stmt|;
name|acc_fns
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DR_SET_ACCESS_FNS
argument_list|(
name|res
argument_list|,
name|acc_fns
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|DR_ACCESS_FNS
argument_list|(
name|res
argument_list|)
argument_list|,
name|access_fn
argument_list|)
expr_stmt|;
name|DR_IS_READ
argument_list|(
name|res
argument_list|)
operator|=
name|is_read
expr_stmt|;
name|DR_BASE_ADDRESS
argument_list|(
name|res
argument_list|)
operator|=
name|base_address
expr_stmt|;
name|DR_OFFSET
argument_list|(
name|res
argument_list|)
operator|=
name|init_offset
expr_stmt|;
name|DR_INIT
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_STEP
argument_list|(
name|res
argument_list|)
operator|=
name|step
expr_stmt|;
name|DR_OFFSET_MISALIGNMENT
argument_list|(
name|res
argument_list|)
operator|=
name|misalign
expr_stmt|;
name|DR_MEMTAG
argument_list|(
name|res
argument_list|)
operator|=
name|memtag
expr_stmt|;
name|DR_PTR_INFO
argument_list|(
name|res
argument_list|)
operator|=
name|ptr_info
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Function strip_conversions     Strip conversions that don't narrow the mode.  */
end_comment

begin_function
specifier|static
name|tree
name|strip_conversion
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|to
decl_stmt|,
name|ti
decl_stmt|,
name|oprnd0
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ti
operator|=
name|TREE_TYPE
argument_list|(
name|oprnd0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|to
argument_list|)
operator|||
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|ti
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|ti
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|expr
operator|=
name|oprnd0
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function analyze_offset_expr     Given an offset expression EXPR received from get_inner_reference, analyze    it and create an expression for INITIAL_OFFSET by substituting the variables     of EXPR with initial_condition of the corresponding access_fn in the loop.     E.g.,        for i          for (j = 3; j< N; j++)             a[j].b[i][j] = 0; 	     For a[j].b[i][j], EXPR will be 'i * C_i + j * C_j + C'. 'i' cannot be     substituted, since its access_fn in the inner loop is i. 'j' will be     substituted with 3. An INITIAL_OFFSET will be 'i * C_i + C`', where    C` =  3 * C_j + C.     Compute MISALIGN (the misalignment of the data reference initial access from    its base). Misalignment can be calculated only if all the variables can be     substituted with constants, otherwise, we record maximum possible alignment    in ALIGNED_TO. In the above example, since 'i' cannot be substituted, MISALIGN     will be NULL_TREE, and the biggest divider of C_i (a power of 2) will be     recorded in ALIGNED_TO.     STEP is an evolution of the data reference in this loop in bytes.    In the above example, STEP is C_j.     Return FALSE, if the analysis fails, e.g., there is no access_fn for a     variable. In this case, all the outputs (INITIAL_OFFSET, MISALIGN, ALIGNED_TO    and STEP) are NULL_TREEs. Otherwise, return TRUE.  */
end_comment

begin_function
specifier|static
name|bool
name|analyze_offset_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
modifier|*
name|initial_offset
parameter_list|,
name|tree
modifier|*
name|misalign
parameter_list|,
name|tree
modifier|*
name|aligned_to
parameter_list|,
name|tree
modifier|*
name|step
parameter_list|)
block|{
name|tree
name|oprnd0
decl_stmt|;
name|tree
name|oprnd1
decl_stmt|;
name|tree
name|left_offset
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|tree
name|right_offset
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|tree
name|left_misalign
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|tree
name|right_misalign
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|tree
name|left_step
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|tree
name|right_step
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|init
decl_stmt|,
name|evolution
decl_stmt|;
name|tree
name|left_aligned_to
init|=
name|NULL_TREE
decl_stmt|,
name|right_aligned_to
init|=
name|NULL_TREE
decl_stmt|;
operator|*
name|step
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|misalign
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|aligned_to
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|initial_offset
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Strip conversions that don't narrow the mode.  */
name|expr
operator|=
name|strip_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|false
return|;
comment|/* Stop conditions:      1. Constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
operator|*
name|initial_offset
operator|=
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
operator|*
name|misalign
operator|=
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
operator|*
name|step
operator|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* 2. Variable. Try to substitute with initial_condition of the corresponding      access_fn in the current loop.  */
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|tree
name|access_fn
init|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|access_fn
operator|==
name|chrec_dont_know
condition|)
comment|/* No access_fn.  */
return|return
name|false
return|;
name|init
operator|=
name|initial_condition_in_loop_num
argument_list|(
name|access_fn
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expr_invariant_in_loop_p
argument_list|(
name|loop
argument_list|,
name|init
argument_list|)
condition|)
comment|/* Not enough information: may be not loop invariant.   	   E.g., for a[b[i]], we get a[D], where D=b[i]. EXPR is D, its  	   initial_condition is D, but it depends on i - loop's induction 	   variable.  */
return|return
name|false
return|;
name|evolution
operator|=
name|evolution_part_in_loop_num
argument_list|(
name|access_fn
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|evolution
operator|&&
name|TREE_CODE
argument_list|(
name|evolution
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
comment|/* Evolution is not constant.  */
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|INTEGER_CST
condition|)
operator|*
name|misalign
operator|=
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
comment|/* Not constant, misalignment cannot be calculated.  */
operator|*
name|misalign
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|initial_offset
operator|=
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|init
argument_list|)
expr_stmt|;
operator|*
name|step
operator|=
name|evolution
condition|?
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|evolution
argument_list|)
else|:
name|ssize_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Recursive computation.  */
if|if
condition|(
operator|!
name|BINARY_CLASS_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* We expect to get binary expressions (PLUS/MINUS and MULT).  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nNot binary expression "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|expr
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oprnd1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|analyze_offset_expr
argument_list|(
name|oprnd0
argument_list|,
name|loop
argument_list|,
operator|&
name|left_offset
argument_list|,
operator|&
name|left_misalign
argument_list|,
operator|&
name|left_aligned_to
argument_list|,
operator|&
name|left_step
argument_list|)
operator|||
operator|!
name|analyze_offset_expr
argument_list|(
name|oprnd1
argument_list|,
name|loop
argument_list|,
operator|&
name|right_offset
argument_list|,
operator|&
name|right_misalign
argument_list|,
operator|&
name|right_aligned_to
argument_list|,
operator|&
name|right_step
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The type of the operation: plus, minus or mult.  */
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|right_offset
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
comment|/* RIGHT_OFFSET can be not constant. For example, for arrays of variable  	   sized types.  	   FORNOW: We don't support such cases.  */
return|return
name|false
return|;
comment|/* Strip conversions that don't narrow the mode.  */
name|left_offset
operator|=
name|strip_conversion
argument_list|(
name|left_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|left_offset
condition|)
return|return
name|false
return|;
comment|/* Misalignment computation.  */
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|left_offset
argument_list|)
condition|)
block|{
comment|/* If the left side contains variables that can't be substituted with  	     constants, the misalignment is unknown. However, if the right side  	     is a multiple of some alignment, we know that the expression is 	     aligned to it. Therefore, we record such maximum possible value. 	   */
operator|*
name|misalign
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|aligned_to
operator|=
name|ssize_int
argument_list|(
name|highest_pow2_factor
argument_list|(
name|right_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The left operand was successfully substituted with constant.  */
if|if
condition|(
name|left_misalign
condition|)
block|{
comment|/* In case of EXPR '(i * C1 + j) * C2', LEFT_MISALIGN is  		 NULL_TREE.  */
operator|*
name|misalign
operator|=
name|size_binop
argument_list|(
name|code
argument_list|,
name|left_misalign
argument_list|,
name|right_misalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|left_aligned_to
operator|&&
name|right_aligned_to
condition|)
operator|*
name|aligned_to
operator|=
name|size_binop
argument_list|(
name|MIN_EXPR
argument_list|,
name|left_aligned_to
argument_list|,
name|right_aligned_to
argument_list|)
expr_stmt|;
else|else
operator|*
name|aligned_to
operator|=
name|left_aligned_to
condition|?
name|left_aligned_to
else|:
name|right_aligned_to
expr_stmt|;
block|}
else|else
operator|*
name|misalign
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Step calculation.  */
comment|/* Multiply the step by the right operand.  */
operator|*
name|step
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|left_step
argument_list|,
name|right_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
comment|/* Combine the recursive calculations for step and misalignment.  */
operator|*
name|step
operator|=
name|size_binop
argument_list|(
name|code
argument_list|,
name|left_step
argument_list|,
name|right_step
argument_list|)
expr_stmt|;
comment|/* Unknown alignment.  */
if|if
condition|(
operator|(
operator|!
name|left_misalign
operator|&&
operator|!
name|left_aligned_to
operator|)
operator|||
operator|(
operator|!
name|right_misalign
operator|&&
operator|!
name|right_aligned_to
operator|)
condition|)
block|{
operator|*
name|misalign
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|aligned_to
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|left_misalign
operator|&&
name|right_misalign
condition|)
operator|*
name|misalign
operator|=
name|size_binop
argument_list|(
name|code
argument_list|,
name|left_misalign
argument_list|,
name|right_misalign
argument_list|)
expr_stmt|;
else|else
operator|*
name|misalign
operator|=
name|left_misalign
condition|?
name|left_misalign
else|:
name|right_misalign
expr_stmt|;
if|if
condition|(
name|left_aligned_to
operator|&&
name|right_aligned_to
condition|)
operator|*
name|aligned_to
operator|=
name|size_binop
argument_list|(
name|MIN_EXPR
argument_list|,
name|left_aligned_to
argument_list|,
name|right_aligned_to
argument_list|)
expr_stmt|;
else|else
operator|*
name|aligned_to
operator|=
name|left_aligned_to
condition|?
name|left_aligned_to
else|:
name|right_aligned_to
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Compute offset.  */
operator|*
name|initial_offset
operator|=
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|fold_build2
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|left_offset
argument_list|)
argument_list|,
name|left_offset
argument_list|,
name|right_offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function address_analysis     Return the BASE of the address expression EXPR.    Also compute the OFFSET from BASE, MISALIGN and STEP.     Input:    EXPR - the address expression that is being analyzed    STMT - the statement that contains EXPR or its original memory reference    IS_READ - TRUE if STMT reads from EXPR, FALSE if writes to EXPR    DR - data_reference struct for the original memory reference     Output:    BASE (returned value) - the base of the data reference EXPR.    INITIAL_OFFSET - initial offset of EXPR from BASE (an expression)    MISALIGN - offset of EXPR from BASE in bytes (a constant) or NULL_TREE if the               computation is impossible     ALIGNED_TO - maximum alignment of EXPR or NULL_TREE if MISALIGN can be                  calculated (doesn't depend on variables)    STEP - evolution of EXPR in the loop      If something unexpected is encountered (an unsupported form of data-ref),    then NULL_TREE is returned.    */
end_comment

begin_function
specifier|static
name|tree
name|address_analysis
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|bool
name|is_read
parameter_list|,
name|struct
name|data_reference
modifier|*
name|dr
parameter_list|,
name|tree
modifier|*
name|offset
parameter_list|,
name|tree
modifier|*
name|misalign
parameter_list|,
name|tree
modifier|*
name|aligned_to
parameter_list|,
name|tree
modifier|*
name|step
parameter_list|)
block|{
name|tree
name|oprnd0
decl_stmt|,
name|oprnd1
decl_stmt|,
name|base_address
decl_stmt|,
name|offset_expr
decl_stmt|,
name|base_addr0
decl_stmt|,
name|base_addr1
decl_stmt|;
name|tree
name|address_offset
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|address_misalign
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|tree
name|dummy
decl_stmt|,
name|address_aligned_to
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|dummy1
decl_stmt|;
name|subvar_t
name|dummy2
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
comment|/* EXPR is of form {base +/- offset} (or {offset +/- base}).  */
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oprnd1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|oprnd0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|oprnd1
argument_list|)
expr_stmt|;
comment|/* Recursively try to find the base of the address contained in EXPR. 	 For offset, the returned base will be NULL.  */
name|base_addr0
operator|=
name|address_analysis
argument_list|(
name|oprnd0
argument_list|,
name|stmt
argument_list|,
name|is_read
argument_list|,
name|dr
argument_list|,
operator|&
name|address_offset
argument_list|,
operator|&
name|address_misalign
argument_list|,
operator|&
name|address_aligned_to
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|base_addr1
operator|=
name|address_analysis
argument_list|(
name|oprnd1
argument_list|,
name|stmt
argument_list|,
name|is_read
argument_list|,
name|dr
argument_list|,
operator|&
name|address_offset
argument_list|,
operator|&
name|address_misalign
argument_list|,
operator|&
name|address_aligned_to
argument_list|,
name|step
argument_list|)
expr_stmt|;
comment|/* We support cases where only one of the operands contains an  	 address.  */
if|if
condition|(
operator|(
name|base_addr0
operator|&&
name|base_addr1
operator|)
operator|||
operator|(
operator|!
name|base_addr0
operator|&&
operator|!
name|base_addr1
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\neither more than one address or no addresses in expr "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|expr
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* To revert STRIP_NOPS.  */
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oprnd1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset_expr
operator|=
name|base_addr0
condition|?
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|oprnd1
argument_list|)
else|:
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|oprnd0
argument_list|)
expr_stmt|;
comment|/* EXPR is of form {base +/- offset} (or {offset +/- base}). If offset is  	 a number, we can add it to the misalignment value calculated for base, 	 otherwise, misalignment is NULL.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|offset_expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|address_misalign
condition|)
block|{
operator|*
name|misalign
operator|=
name|size_binop
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|address_misalign
argument_list|,
name|offset_expr
argument_list|)
expr_stmt|;
operator|*
name|aligned_to
operator|=
name|address_aligned_to
expr_stmt|;
block|}
else|else
block|{
operator|*
name|misalign
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|aligned_to
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Combine offset (from EXPR {base + offset}) with the offset calculated 	 for base.  */
operator|*
name|offset
operator|=
name|size_binop
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|address_offset
argument_list|,
name|offset_expr
argument_list|)
expr_stmt|;
return|return
name|base_addr0
condition|?
name|base_addr0
else|:
name|base_addr1
return|;
case|case
name|ADDR_EXPR
case|:
name|base_address
operator|=
name|object_analysis
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|stmt
argument_list|,
name|is_read
argument_list|,
operator|&
name|dr
argument_list|,
name|offset
argument_list|,
name|misalign
argument_list|,
name|aligned_to
argument_list|,
name|step
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|)
expr_stmt|;
return|return
name|base_address
return|;
case|case
name|SSA_NAME
case|:
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nnot pointer SSA_NAME "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|expr
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
operator|*
name|aligned_to
operator|=
name|ssize_int
argument_list|(
name|TYPE_ALIGN_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|misalign
operator|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|step
operator|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Function object_analysis     Create a data-reference structure DR for MEMREF.    Return the BASE of the data reference MEMREF if the analysis is possible.    Also compute the INITIAL_OFFSET from BASE, MISALIGN and STEP.    E.g., for EXPR a.b[i] + 4B, BASE is a, and OFFSET is the overall offset      'a.b[i] + 4B' from a (can be an expression), MISALIGN is an OFFSET     instantiated with initial_conditions of access_functions of variables,     and STEP is the evolution of the DR_REF in this loop.        Function get_inner_reference is used for the above in case of ARRAY_REF and    COMPONENT_REF.     The structure of the function is as follows:    Part 1:    Case 1. For handled_component_p refs            1.1 build data-reference structure for MEMREF           1.2 call get_inner_reference             1.2.1 analyze offset expr received from get_inner_reference           (fall through with BASE)    Case 2. For declarations            2.1 set MEMTAG    Case 3. For INDIRECT_REFs            3.1 build data-reference structure for MEMREF 	  3.2 analyze evolution and initial condition of MEMREF 	  3.3 set data-reference structure for MEMREF           3.4 call address_analysis to analyze INIT of the access function 	  3.5 extract memory tag     Part 2:    Combine the results of object and address analysis to calculate     INITIAL_OFFSET, STEP and misalignment info.        Input:    MEMREF - the memory reference that is being analyzed    STMT - the statement that contains MEMREF    IS_READ - TRUE if STMT reads from MEMREF, FALSE if writes to MEMREF        Output:    BASE_ADDRESS (returned value) - the base address of the data reference MEMREF                                    E.g, if MEMREF is a.b[k].c[i][j] the returned 			           base is&a.    DR - data_reference struct for MEMREF    INITIAL_OFFSET - initial offset of MEMREF from BASE (an expression)    MISALIGN - offset of MEMREF from BASE in bytes (a constant) modulo alignment of                ALIGNMENT or NULL_TREE if the computation is impossible    ALIGNED_TO - maximum alignment of EXPR or NULL_TREE if MISALIGN can be                  calculated (doesn't depend on variables)    STEP - evolution of the DR_REF in the loop    MEMTAG - memory tag for aliasing purposes    PTR_INFO - NULL or points-to aliasing info from a pointer SSA_NAME    SUBVARS - Sub-variables of the variable     If the analysis of MEMREF evolution in the loop fails, NULL_TREE is returned,     but DR can be created anyway.     */
end_comment

begin_function
specifier|static
name|tree
name|object_analysis
parameter_list|(
name|tree
name|memref
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|bool
name|is_read
parameter_list|,
name|struct
name|data_reference
modifier|*
modifier|*
name|dr
parameter_list|,
name|tree
modifier|*
name|offset
parameter_list|,
name|tree
modifier|*
name|misalign
parameter_list|,
name|tree
modifier|*
name|aligned_to
parameter_list|,
name|tree
modifier|*
name|step
parameter_list|,
name|tree
modifier|*
name|memtag
parameter_list|,
name|struct
name|ptr_info_def
modifier|*
modifier|*
name|ptr_info
parameter_list|,
name|subvar_t
modifier|*
name|subvars
parameter_list|)
block|{
name|tree
name|base
init|=
name|NULL_TREE
decl_stmt|,
name|base_address
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|object_offset
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|object_misalign
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|tree
name|object_step
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|address_step
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|tree
name|address_offset
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|address_misalign
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|pbitsize
decl_stmt|,
name|pbitpos
decl_stmt|;
name|tree
name|poffset
decl_stmt|,
name|bit_pos_in_bytes
decl_stmt|;
name|enum
name|machine_mode
name|pmode
decl_stmt|;
name|int
name|punsignedp
decl_stmt|,
name|pvolatilep
decl_stmt|;
name|tree
name|ptr_step
init|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|ptr_init
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|loop_containing_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|ptr_dr
init|=
name|NULL
decl_stmt|;
name|tree
name|object_aligned_to
init|=
name|NULL_TREE
decl_stmt|,
name|address_aligned_to
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|comp_ref
init|=
name|NULL_TREE
decl_stmt|;
operator|*
name|ptr_info
operator|=
name|NULL
expr_stmt|;
comment|/* Part 1:  */
comment|/* Case 1. handled_component_p refs.  */
if|if
condition|(
name|handled_component_p
argument_list|(
name|memref
argument_list|)
condition|)
block|{
comment|/* 1.1 build data-reference structure for MEMREF.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|dr
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|memref
argument_list|)
operator|==
name|ARRAY_REF
condition|)
operator|*
name|dr
operator|=
name|analyze_array
argument_list|(
name|stmt
argument_list|,
name|memref
argument_list|,
name|is_read
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|memref
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|comp_ref
operator|=
name|memref
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\ndata-ref of unsupported type "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|memref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
block|}
comment|/* 1.2 call get_inner_reference.  */
comment|/* Find the base and the offset from it.  */
name|base
operator|=
name|get_inner_reference
argument_list|(
name|memref
argument_list|,
operator|&
name|pbitsize
argument_list|,
operator|&
name|pbitpos
argument_list|,
operator|&
name|poffset
argument_list|,
operator|&
name|pmode
argument_list|,
operator|&
name|punsignedp
argument_list|,
operator|&
name|pvolatilep
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nfailed to get inner ref for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|memref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* 1.2.1 analyze offset expr received from get_inner_reference.  */
if|if
condition|(
name|poffset
operator|&&
operator|!
name|analyze_offset_expr
argument_list|(
name|poffset
argument_list|,
name|loop
argument_list|,
operator|&
name|object_offset
argument_list|,
operator|&
name|object_misalign
argument_list|,
operator|&
name|object_aligned_to
argument_list|,
operator|&
name|object_step
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nfailed to compute offset or step for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|memref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* Add bit position to OFFSET and MISALIGN.  */
name|bit_pos_in_bytes
operator|=
name|ssize_int
argument_list|(
name|pbitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Check that there is no remainder in bits.  */
if|if
condition|(
name|pbitpos
operator|%
name|BITS_PER_UNIT
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nbit offset alignment.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|object_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|bit_pos_in_bytes
argument_list|,
name|object_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|object_misalign
condition|)
name|object_misalign
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|object_misalign
argument_list|,
name|bit_pos_in_bytes
argument_list|)
expr_stmt|;
name|memref
operator|=
name|base
expr_stmt|;
comment|/* To continue analysis of BASE.  */
comment|/* fall through  */
block|}
comment|/*  Part 1: Case 2. Declarations.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|memref
argument_list|)
condition|)
block|{
comment|/* We expect to get a decl only if we already have a DR, or with  	 COMPONENT_REFs of type 'a[i].b'.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|dr
operator|)
condition|)
block|{
if|if
condition|(
name|comp_ref
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|comp_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
operator|*
name|dr
operator|=
name|analyze_array
argument_list|(
name|stmt
argument_list|,
name|TREE_OPERAND
argument_list|(
name|comp_ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|is_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|DR_NUM_DIMENSIONS
argument_list|(
operator|*
name|dr
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n multidimensional component ref "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|comp_ref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nunhandled decl "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|memref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
block|}
comment|/* TODO: if during the analysis of INDIRECT_REF we get to an object, put  	 the object in BASE_OBJECT field if we can prove that this is O.K.,  	 i.e., the data-ref access is bounded by the bounds of the BASE_OBJECT. 	 (e.g., if the object is an array base 'a', where 'a[N]', we must prove 	 that every access with 'p' (the original INDIRECT_REF based on '&a') 	 in the loop is within the array boundaries - from a[0] to a[N-1]). 	 Otherwise, our alias analysis can be incorrect. 	 Even if an access function based on BASE_OBJECT can't be build, update 	 BASE_OBJECT field to enable us to prove that two data-refs are  	 different (without access function, distance analysis is impossible).       */
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|memref
argument_list|)
operator|&&
name|var_can_have_subvars
argument_list|(
name|memref
argument_list|)
condition|)
operator|*
name|subvars
operator|=
name|get_subvars_for_var
argument_list|(
name|memref
argument_list|)
expr_stmt|;
name|base_address
operator|=
name|build_fold_addr_expr
argument_list|(
name|memref
argument_list|)
expr_stmt|;
comment|/* 2.1 set MEMTAG.  */
operator|*
name|memtag
operator|=
name|memref
expr_stmt|;
block|}
comment|/* Part 1:  Case 3. INDIRECT_REFs.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|memref
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|tree
name|ptr_ref
init|=
name|TREE_OPERAND
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptr_ref
argument_list|)
operator|==
name|SSA_NAME
condition|)
operator|*
name|ptr_info
operator|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr_ref
argument_list|)
expr_stmt|;
comment|/* 3.1 build data-reference structure for MEMREF.  */
name|ptr_dr
operator|=
name|analyze_indirect_ref
argument_list|(
name|stmt
argument_list|,
name|memref
argument_list|,
name|is_read
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr_dr
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nfailed to create dr for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|memref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* 3.2 analyze evolution and initial condition of MEMREF.  */
name|ptr_step
operator|=
name|DR_STEP
argument_list|(
name|ptr_dr
argument_list|)
expr_stmt|;
name|ptr_init
operator|=
name|DR_BASE_ADDRESS
argument_list|(
name|ptr_dr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr_init
operator|||
operator|!
name|ptr_step
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr_init
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|dr
operator|=
operator|(
operator|*
name|dr
operator|)
condition|?
operator|*
name|dr
else|:
name|ptr_dr
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nbad pointer access "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|memref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|ptr_step
argument_list|)
operator|&&
operator|!
operator|(
operator|*
name|dr
operator|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nptr is loop invariant.\n"
argument_list|)
expr_stmt|;
operator|*
name|dr
operator|=
name|ptr_dr
expr_stmt|;
return|return
name|NULL_TREE
return|;
comment|/* If there exists DR for MEMREF, we are analyzing the base of 	     handled component (PTR_INIT), which not necessary has evolution in  	     the loop.  */
block|}
name|object_step
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|object_step
argument_list|,
name|ptr_step
argument_list|)
expr_stmt|;
comment|/* 3.3 set data-reference structure for MEMREF.  */
if|if
condition|(
operator|!
operator|*
name|dr
condition|)
operator|*
name|dr
operator|=
name|ptr_dr
expr_stmt|;
comment|/* 3.4 call address_analysis to analyze INIT of the access  	 function.  */
name|base_address
operator|=
name|address_analysis
argument_list|(
name|ptr_init
argument_list|,
name|stmt
argument_list|,
name|is_read
argument_list|,
operator|*
name|dr
argument_list|,
operator|&
name|address_offset
argument_list|,
operator|&
name|address_misalign
argument_list|,
operator|&
name|address_aligned_to
argument_list|,
operator|&
name|address_step
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_address
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nfailed to analyze address "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|ptr_init
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* 3.5 extract memory tag.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|base_address
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
operator|*
name|memtag
operator|=
name|get_var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|base_address
argument_list|)
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|memtag
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
operator|*
name|memtag
operator|=
name|get_var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
operator|*
name|memtag
operator|=
name|TREE_OPERAND
argument_list|(
name|base_address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nno memtag for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|memref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|memtag
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|base_address
condition|)
block|{
comment|/* MEMREF cannot be analyzed.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\ndata-ref of unsupported type "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|memref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|comp_ref
condition|)
name|DR_REF
argument_list|(
operator|*
name|dr
argument_list|)
operator|=
name|comp_ref
expr_stmt|;
if|if
condition|(
name|SSA_VAR_P
argument_list|(
operator|*
name|memtag
argument_list|)
operator|&&
name|var_can_have_subvars
argument_list|(
operator|*
name|memtag
argument_list|)
condition|)
operator|*
name|subvars
operator|=
name|get_subvars_for_var
argument_list|(
operator|*
name|memtag
argument_list|)
expr_stmt|;
comment|/* Part 2: Combine the results of object and address analysis to calculate       INITIAL_OFFSET, STEP and misalignment info.  */
operator|*
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|object_offset
argument_list|,
name|address_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|object_misalign
operator|&&
operator|!
name|object_aligned_to
operator|)
operator|||
operator|(
operator|!
name|address_misalign
operator|&&
operator|!
name|address_aligned_to
operator|)
condition|)
block|{
operator|*
name|misalign
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|aligned_to
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|object_misalign
operator|&&
name|address_misalign
condition|)
operator|*
name|misalign
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|object_misalign
argument_list|,
name|address_misalign
argument_list|)
expr_stmt|;
else|else
operator|*
name|misalign
operator|=
name|object_misalign
condition|?
name|object_misalign
else|:
name|address_misalign
expr_stmt|;
if|if
condition|(
name|object_aligned_to
operator|&&
name|address_aligned_to
condition|)
operator|*
name|aligned_to
operator|=
name|size_binop
argument_list|(
name|MIN_EXPR
argument_list|,
name|object_aligned_to
argument_list|,
name|address_aligned_to
argument_list|)
expr_stmt|;
else|else
operator|*
name|aligned_to
operator|=
name|object_aligned_to
condition|?
name|object_aligned_to
else|:
name|address_aligned_to
expr_stmt|;
block|}
operator|*
name|step
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|object_step
argument_list|,
name|address_step
argument_list|)
expr_stmt|;
return|return
name|base_address
return|;
block|}
end_function

begin_comment
comment|/* Function analyze_offset.        Extract INVARIANT and CONSTANT parts from OFFSET.   */
end_comment

begin_function
specifier|static
name|bool
name|analyze_offset
parameter_list|(
name|tree
name|offset
parameter_list|,
name|tree
modifier|*
name|invariant
parameter_list|,
name|tree
modifier|*
name|constant
parameter_list|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|constant_0
decl_stmt|,
name|constant_1
decl_stmt|,
name|invariant_0
decl_stmt|,
name|invariant_1
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
decl_stmt|;
operator|*
name|invariant
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|constant
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Not PLUS/MINUS expression - recursion stop condition.  */
if|if
condition|(
name|code
operator|!=
name|PLUS_EXPR
operator|&&
name|code
operator|!=
name|MINUS_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|INTEGER_CST
condition|)
operator|*
name|constant
operator|=
name|offset
expr_stmt|;
else|else
operator|*
name|invariant
operator|=
name|offset
expr_stmt|;
return|return
name|true
return|;
block|}
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Recursive call with the operands.  */
if|if
condition|(
operator|!
name|analyze_offset
argument_list|(
name|op0
argument_list|,
operator|&
name|invariant_0
argument_list|,
operator|&
name|constant_0
argument_list|)
operator|||
operator|!
name|analyze_offset
argument_list|(
name|op1
argument_list|,
operator|&
name|invariant_1
argument_list|,
operator|&
name|constant_1
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Combine the results. Add negation to the subtrahend in case of      subtraction.  */
if|if
condition|(
name|constant_0
operator|&&
name|constant_1
condition|)
return|return
name|false
return|;
operator|*
name|constant
operator|=
name|constant_0
condition|?
name|constant_0
else|:
name|constant_1
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|constant_1
condition|)
operator|*
name|constant
operator|=
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|constant
argument_list|)
argument_list|,
operator|*
name|constant
argument_list|)
expr_stmt|;
if|if
condition|(
name|invariant_0
operator|&&
name|invariant_1
condition|)
operator|*
name|invariant
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|invariant_0
argument_list|)
argument_list|,
name|invariant_0
argument_list|,
name|invariant_1
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|invariant
operator|=
name|invariant_0
condition|?
name|invariant_0
else|:
name|invariant_1
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|invariant_1
condition|)
operator|*
name|invariant
operator|=
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|invariant
argument_list|)
argument_list|,
operator|*
name|invariant
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Free the memory used by the data reference DR.  */
end_comment

begin_function
specifier|static
name|void
name|free_data_ref
parameter_list|(
name|data_reference_p
name|dr
parameter_list|)
block|{
name|DR_FREE_ACCESS_FNS
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function create_data_ref.        Create a data-reference structure for MEMREF. Set its DR_BASE_ADDRESS,    DR_OFFSET, DR_INIT, DR_STEP, DR_OFFSET_MISALIGNMENT, DR_ALIGNED_TO,    DR_MEMTAG, and DR_POINTSTO_INFO fields.      Input:    MEMREF - the memory reference that is being analyzed    STMT - the statement that contains MEMREF    IS_READ - TRUE if STMT reads from MEMREF, FALSE if writes to MEMREF     Output:    DR (returned value) - data_reference struct for MEMREF */
end_comment

begin_function
specifier|static
name|struct
name|data_reference
modifier|*
name|create_data_ref
parameter_list|(
name|tree
name|memref
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|bool
name|is_read
parameter_list|)
block|{
name|struct
name|data_reference
modifier|*
name|dr
init|=
name|NULL
decl_stmt|;
name|tree
name|base_address
decl_stmt|,
name|offset
decl_stmt|,
name|step
decl_stmt|,
name|misalign
decl_stmt|,
name|memtag
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|loop_containing_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|invariant
init|=
name|NULL_TREE
decl_stmt|,
name|constant
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type_size
decl_stmt|,
name|init_cond
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|ptr_info
decl_stmt|;
name|subvar_t
name|subvars
init|=
name|NULL
decl_stmt|;
name|tree
name|aligned_to
decl_stmt|,
name|type
init|=
name|NULL_TREE
decl_stmt|,
name|orig_offset
decl_stmt|;
if|if
condition|(
operator|!
name|memref
condition|)
return|return
name|NULL
return|;
name|base_address
operator|=
name|object_analysis
argument_list|(
name|memref
argument_list|,
name|stmt
argument_list|,
name|is_read
argument_list|,
operator|&
name|dr
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|misalign
argument_list|,
operator|&
name|aligned_to
argument_list|,
operator|&
name|step
argument_list|,
operator|&
name|memtag
argument_list|,
operator|&
name|ptr_info
argument_list|,
operator|&
name|subvars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dr
operator|||
operator|!
name|base_address
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\ncreate_data_ref: failed to create a dr for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|memref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|DR_BASE_ADDRESS
argument_list|(
name|dr
argument_list|)
operator|=
name|base_address
expr_stmt|;
name|DR_OFFSET
argument_list|(
name|dr
argument_list|)
operator|=
name|offset
expr_stmt|;
name|DR_INIT
argument_list|(
name|dr
argument_list|)
operator|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|DR_STEP
argument_list|(
name|dr
argument_list|)
operator|=
name|step
expr_stmt|;
name|DR_OFFSET_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|=
name|misalign
expr_stmt|;
name|DR_ALIGNED_TO
argument_list|(
name|dr
argument_list|)
operator|=
name|aligned_to
expr_stmt|;
name|DR_MEMTAG
argument_list|(
name|dr
argument_list|)
operator|=
name|memtag
expr_stmt|;
name|DR_PTR_INFO
argument_list|(
name|dr
argument_list|)
operator|=
name|ptr_info
expr_stmt|;
name|DR_SUBVARS
argument_list|(
name|dr
argument_list|)
operator|=
name|subvars
expr_stmt|;
name|type_size
operator|=
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|DR_REF
argument_list|(
name|dr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract CONSTANT and INVARIANT from OFFSET.  */
comment|/* Remove cast from OFFSET and restore it for INVARIANT part.  */
name|orig_offset
operator|=
name|offset
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
name|orig_offset
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|orig_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|analyze_offset
argument_list|(
name|offset
argument_list|,
operator|&
name|invariant
argument_list|,
operator|&
name|constant
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\ncreate_data_ref: failed to analyze dr's"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" offset for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|memref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|type
operator|&&
name|invariant
condition|)
name|invariant
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|invariant
argument_list|)
expr_stmt|;
comment|/* Put CONSTANT part of OFFSET in DR_INIT and INVARIANT in DR_OFFSET field      of DR.  */
if|if
condition|(
name|constant
condition|)
block|{
name|DR_INIT
argument_list|(
name|dr
argument_list|)
operator|=
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|constant
argument_list|)
expr_stmt|;
name|init_cond
operator|=
name|fold_build2
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|constant
argument_list|)
argument_list|,
name|constant
argument_list|,
name|type_size
argument_list|)
expr_stmt|;
block|}
else|else
name|DR_INIT
argument_list|(
name|dr
argument_list|)
operator|=
name|init_cond
operator|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|invariant
condition|)
name|DR_OFFSET
argument_list|(
name|dr
argument_list|)
operator|=
name|invariant
expr_stmt|;
else|else
name|DR_OFFSET
argument_list|(
name|dr
argument_list|)
operator|=
name|ssize_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Change the access function for INIDIRECT_REFs, according to       DR_BASE_ADDRESS.  Analyze OFFSET calculated in object_analysis. OFFSET is       an expression that can contain loop invariant expressions and constants.      We put the constant part in the initial condition of the access function      (for data dependence tests), and in DR_INIT of the data-ref. The loop      invariant part is put in DR_OFFSET.       The evolution part of the access function is STEP calculated in      object_analysis divided by the size of data type.   */
if|if
condition|(
operator|!
name|DR_BASE_OBJECT
argument_list|(
name|dr
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|memref
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DR_NUM_DIMENSIONS
argument_list|(
name|dr
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
name|tree
name|access_fn
decl_stmt|;
name|tree
name|new_step
decl_stmt|;
comment|/* Update access function.  */
name|access_fn
operator|=
name|DR_ACCESS_FN
argument_list|(
name|dr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|access_fn
argument_list|)
condition|)
block|{
name|free_data_ref
argument_list|(
name|dr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|new_step
operator|=
name|size_binop
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|fold_convert
argument_list|(
name|ssizetype
argument_list|,
name|step
argument_list|)
argument_list|,
name|type_size
argument_list|)
expr_stmt|;
name|init_cond
operator|=
name|chrec_convert
argument_list|(
name|chrec_type
argument_list|(
name|access_fn
argument_list|)
argument_list|,
name|init_cond
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|new_step
operator|=
name|chrec_convert
argument_list|(
name|chrec_type
argument_list|(
name|access_fn
argument_list|)
argument_list|,
name|new_step
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|init_cond
argument_list|)
operator|||
name|automatically_generated_chrec_p
argument_list|(
name|new_step
argument_list|)
condition|)
block|{
name|free_data_ref
argument_list|(
name|dr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|access_fn
operator|=
name|chrec_replace_initial_condition
argument_list|(
name|access_fn
argument_list|,
name|init_cond
argument_list|)
expr_stmt|;
name|access_fn
operator|=
name|reset_evolution_in_loop
argument_list|(
name|loop
operator|->
name|num
argument_list|,
name|access_fn
argument_list|,
name|new_step
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|DR_ACCESS_FNS
argument_list|(
name|dr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|access_fn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|DR_PTR_INFO
argument_list|(
name|dr
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nCreated dr for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|memref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\tbase_address: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|DR_BASE_ADDRESS
argument_list|(
name|dr
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\toffset from base address: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|DR_OFFSET
argument_list|(
name|dr
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\tconstant offset from base address: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|DR_INIT
argument_list|(
name|dr
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\tbase_object: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|DR_BASE_OBJECT
argument_list|(
name|dr
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\tstep: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|DR_STEP
argument_list|(
name|dr
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"B\n\tmisalignment from base: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|DR_OFFSET_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|DR_OFFSET_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"B"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DR_ALIGNED_TO
argument_list|(
name|dr
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\taligned to: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|DR_ALIGNED_TO
argument_list|(
name|dr
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\tmemtag: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|DR_MEMTAG
argument_list|(
name|dr
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|&&
name|pi
operator|->
name|name_mem_tag
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\tnametag: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|pi
operator|->
name|name_mem_tag
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dr
return|;
block|}
end_function

begin_comment
comment|/* Returns true when all the functions of a tree_vec CHREC are the    same.  */
end_comment

begin_function
specifier|static
name|bool
name|all_chrecs_equal_p
parameter_list|(
name|tree
name|chrec
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|chrec
argument_list|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|eq_evolutions_p
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|chrec
argument_list|,
name|j
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|chrec
argument_list|,
name|j
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine for each subscript in the data dependence relation DDR    the distance.  */
end_comment

begin_function
specifier|static
name|void
name|compute_subscript_distance
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DDR_NUM_SUBSCRIPTS
argument_list|(
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|conflicts_a
decl_stmt|,
name|conflicts_b
decl_stmt|,
name|difference
decl_stmt|;
name|struct
name|subscript
modifier|*
name|subscript
decl_stmt|;
name|subscript
operator|=
name|DDR_SUBSCRIPT
argument_list|(
name|ddr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|conflicts_a
operator|=
name|SUB_CONFLICTS_IN_A
argument_list|(
name|subscript
argument_list|)
expr_stmt|;
name|conflicts_b
operator|=
name|SUB_CONFLICTS_IN_B
argument_list|(
name|subscript
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conflicts_a
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
if|if
condition|(
operator|!
name|all_chrecs_equal_p
argument_list|(
name|conflicts_a
argument_list|)
condition|)
block|{
name|SUB_DISTANCE
argument_list|(
name|subscript
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
return|return;
block|}
else|else
name|conflicts_a
operator|=
name|TREE_VEC_ELT
argument_list|(
name|conflicts_a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conflicts_b
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
if|if
condition|(
operator|!
name|all_chrecs_equal_p
argument_list|(
name|conflicts_b
argument_list|)
condition|)
block|{
name|SUB_DISTANCE
argument_list|(
name|subscript
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
return|return;
block|}
else|else
name|conflicts_b
operator|=
name|TREE_VEC_ELT
argument_list|(
name|conflicts_b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|conflicts_b
operator|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|conflicts_b
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|conflicts_a
operator|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|conflicts_a
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|difference
operator|=
name|chrec_fold_minus
argument_list|(
name|integer_type_node
argument_list|,
name|conflicts_b
argument_list|,
name|conflicts_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|evolution_function_is_constant_p
argument_list|(
name|difference
argument_list|)
condition|)
name|SUB_DISTANCE
argument_list|(
name|subscript
argument_list|)
operator|=
name|difference
expr_stmt|;
else|else
name|SUB_DISTANCE
argument_list|(
name|subscript
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Initialize a data dependence relation between data accesses A and    B.  NB_LOOPS is the number of loops surrounding the references: the    size of the classic distance/direction vectors.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|data_dependence_relation
modifier|*
name|initialize_data_dependence_relation
argument_list|(
expr|struct
name|data_reference
operator|*
name|a
argument_list|,
expr|struct
name|data_reference
operator|*
name|b
argument_list|,
name|VEC
argument_list|(
name|loop_p
argument_list|,
name|heap
argument_list|)
operator|*
name|loop_nest
argument_list|)
block|{
name|struct
name|data_dependence_relation
modifier|*
name|res
decl_stmt|;
name|bool
name|differ_p
decl_stmt|,
name|known_dependence
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|res
operator|=
name|XNEW
argument_list|(
expr|struct
name|data_dependence_relation
argument_list|)
expr_stmt|;
name|DDR_A
argument_list|(
name|res
argument_list|)
operator|=
name|a
expr_stmt|;
name|DDR_B
argument_list|(
name|res
argument_list|)
operator|=
name|b
expr_stmt|;
name|DDR_LOOP_NEST
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
operator|||
name|b
operator|==
name|NULL
condition|)
block|{
name|DDR_ARE_DEPENDENT
argument_list|(
name|res
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* When A and B are arrays and their dimensions differ, we directly      initialize the relation to "there is no dependence": chrec_known.  */
if|if
condition|(
name|DR_BASE_OBJECT
argument_list|(
name|a
argument_list|)
operator|&&
name|DR_BASE_OBJECT
argument_list|(
name|b
argument_list|)
operator|&&
name|DR_NUM_DIMENSIONS
argument_list|(
name|a
argument_list|)
operator|!=
name|DR_NUM_DIMENSIONS
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|DDR_ARE_DEPENDENT
argument_list|(
name|res
argument_list|)
operator|=
name|chrec_known
expr_stmt|;
return|return
name|res
return|;
block|}
if|if
condition|(
name|DR_BASE_ADDRESS
argument_list|(
name|a
argument_list|)
operator|&&
name|DR_BASE_ADDRESS
argument_list|(
name|b
argument_list|)
condition|)
name|known_dependence
operator|=
name|base_addr_differ_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|differ_p
argument_list|)
expr_stmt|;
else|else
name|known_dependence
operator|=
name|base_object_differ_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|differ_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|known_dependence
condition|)
block|{
comment|/* Can't determine whether the data-refs access the same memory  	 region.  */
name|DDR_ARE_DEPENDENT
argument_list|(
name|res
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
return|return
name|res
return|;
block|}
if|if
condition|(
name|differ_p
condition|)
block|{
name|DDR_ARE_DEPENDENT
argument_list|(
name|res
argument_list|)
operator|=
name|chrec_known
expr_stmt|;
return|return
name|res
return|;
block|}
name|DDR_AFFINE_P
argument_list|(
name|res
argument_list|)
operator|=
name|true
expr_stmt|;
name|DDR_ARE_DEPENDENT
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DDR_SUBSCRIPTS
argument_list|(
name|res
argument_list|)
operator|=
name|VEC_alloc
argument_list|(
name|subscript_p
argument_list|,
name|heap
argument_list|,
name|DR_NUM_DIMENSIONS
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|DDR_LOOP_NEST
argument_list|(
name|res
argument_list|)
operator|=
name|loop_nest
expr_stmt|;
name|DDR_DIR_VECTS
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DDR_DIST_VECTS
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DR_NUM_DIMENSIONS
argument_list|(
name|a
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|subscript
modifier|*
name|subscript
decl_stmt|;
name|subscript
operator|=
name|XNEW
argument_list|(
expr|struct
name|subscript
argument_list|)
expr_stmt|;
name|SUB_CONFLICTS_IN_A
argument_list|(
name|subscript
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
name|SUB_CONFLICTS_IN_B
argument_list|(
name|subscript
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
name|SUB_LAST_CONFLICT
argument_list|(
name|subscript
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
name|SUB_DISTANCE
argument_list|(
name|subscript
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|subscript_p
argument_list|,
name|heap
argument_list|,
name|DDR_SUBSCRIPTS
argument_list|(
name|res
argument_list|)
argument_list|,
name|subscript
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Set DDR_ARE_DEPENDENT to CHREC and finalize the subscript overlap    description.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|finalize_ddr_dependent
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|,
name|tree
name|chrec
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(dependence classified: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|chrec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|=
name|chrec
expr_stmt|;
name|VEC_free
argument_list|(
name|subscript_p
argument_list|,
name|heap
argument_list|,
name|DDR_SUBSCRIPTS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The dependence relation DDR cannot be represented by a distance    vector.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|non_affine_dependence_relation
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(Dependence relation cannot be represented by distance vector.) \n"
argument_list|)
expr_stmt|;
name|DDR_AFFINE_P
argument_list|(
name|ddr
argument_list|)
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This section contains the classic Banerjee tests.  */
end_comment

begin_comment
comment|/* Returns true iff CHREC_A and CHREC_B are not dependent on any index    variables, i.e., if the ZIV (Zero Index Variable) test is true.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|ziv_subscript_p
parameter_list|(
name|tree
name|chrec_a
parameter_list|,
name|tree
name|chrec_b
parameter_list|)
block|{
return|return
operator|(
name|evolution_function_is_constant_p
argument_list|(
name|chrec_a
argument_list|)
operator|&&
name|evolution_function_is_constant_p
argument_list|(
name|chrec_b
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff CHREC_A and CHREC_B are dependent on an index    variable, i.e., if the SIV (Single Index Variable) test is true.  */
end_comment

begin_function
specifier|static
name|bool
name|siv_subscript_p
parameter_list|(
name|tree
name|chrec_a
parameter_list|,
name|tree
name|chrec_b
parameter_list|)
block|{
if|if
condition|(
operator|(
name|evolution_function_is_constant_p
argument_list|(
name|chrec_a
argument_list|)
operator|&&
name|evolution_function_is_univariate_p
argument_list|(
name|chrec_b
argument_list|)
operator|)
operator|||
operator|(
name|evolution_function_is_constant_p
argument_list|(
name|chrec_b
argument_list|)
operator|&&
name|evolution_function_is_univariate_p
argument_list|(
name|chrec_a
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|evolution_function_is_univariate_p
argument_list|(
name|chrec_a
argument_list|)
operator|&&
name|evolution_function_is_univariate_p
argument_list|(
name|chrec_b
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec_a
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec_b
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|chrec_a
argument_list|)
operator|!=
name|CHREC_VARIABLE
argument_list|(
name|chrec_b
argument_list|)
condition|)
return|return
name|false
return|;
default|default:
return|return
name|true
return|;
block|}
default|default:
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Analyze a ZIV (Zero Index Variable) subscript.  *OVERLAPS_A and    *OVERLAPS_B are initialized to the functions that describe the    relation between the elements accessed twice by CHREC_A and    CHREC_B.  For k>= 0, the following property is verified:     CHREC_A (*OVERLAPS_A (k)) = CHREC_B (*OVERLAPS_B (k)).  */
end_comment

begin_function
specifier|static
name|void
name|analyze_ziv_subscript
parameter_list|(
name|tree
name|chrec_a
parameter_list|,
name|tree
name|chrec_b
parameter_list|,
name|tree
modifier|*
name|overlaps_a
parameter_list|,
name|tree
modifier|*
name|overlaps_b
parameter_list|,
name|tree
modifier|*
name|last_conflicts
parameter_list|)
block|{
name|tree
name|difference
decl_stmt|;
name|dependence_stats
operator|.
name|num_ziv
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(analyze_ziv_subscript \n"
argument_list|)
expr_stmt|;
name|chrec_a
operator|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|chrec_a
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chrec_b
operator|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|chrec_b
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|difference
operator|=
name|chrec_fold_minus
argument_list|(
name|integer_type_node
argument_list|,
name|chrec_a
argument_list|,
name|chrec_b
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|difference
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|difference
argument_list|)
condition|)
block|{
comment|/* The difference is equal to zero: the accessed index 	     overlaps for each iteration in the loop.  */
operator|*
name|overlaps_a
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
name|dependence_stats
operator|.
name|num_ziv_dependent
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* The accesses do not overlap.  */
operator|*
name|overlaps_a
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
name|dependence_stats
operator|.
name|num_ziv_independent
operator|++
expr_stmt|;
block|}
break|break;
default|default:
comment|/* We're not sure whether the indexes overlap.  For the moment,  	 conservatively answer "don't know".  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"ziv test failed: difference is non-integer.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
name|dependence_stats
operator|.
name|num_ziv_unimplemented
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the real or estimated number of iterations for LOOPNUM, whichever is    available. Return the number of iterations as a tree, or NULL_TREE if    we don't know.  */
end_comment

begin_function
specifier|static
name|tree
name|get_number_of_iters_for_loop
parameter_list|(
name|int
name|loopnum
parameter_list|)
block|{
name|tree
name|numiter
init|=
name|number_of_iterations_in_loop
argument_list|(
name|current_loops
operator|->
name|parray
index|[
name|loopnum
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|numiter
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|numiter
operator|=
name|current_loops
operator|->
name|parray
index|[
name|loopnum
index|]
operator|->
name|estimated_nb_iterations
expr_stmt|;
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|numiter
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|numiter
return|;
block|}
end_function

begin_comment
comment|/* Analyze a SIV (Single Index Variable) subscript where CHREC_A is a    constant, and CHREC_B is an affine function.  *OVERLAPS_A and    *OVERLAPS_B are initialized to the functions that describe the    relation between the elements accessed twice by CHREC_A and    CHREC_B.  For k>= 0, the following property is verified:     CHREC_A (*OVERLAPS_A (k)) = CHREC_B (*OVERLAPS_B (k)).  */
end_comment

begin_function
specifier|static
name|void
name|analyze_siv_subscript_cst_affine
parameter_list|(
name|tree
name|chrec_a
parameter_list|,
name|tree
name|chrec_b
parameter_list|,
name|tree
modifier|*
name|overlaps_a
parameter_list|,
name|tree
modifier|*
name|overlaps_b
parameter_list|,
name|tree
modifier|*
name|last_conflicts
parameter_list|)
block|{
name|bool
name|value0
decl_stmt|,
name|value1
decl_stmt|,
name|value2
decl_stmt|;
name|tree
name|difference
decl_stmt|;
name|chrec_a
operator|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|chrec_a
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chrec_b
operator|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|chrec_b
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|difference
operator|=
name|chrec_fold_minus
argument_list|(
name|integer_type_node
argument_list|,
name|initial_condition
argument_list|(
name|chrec_b
argument_list|)
argument_list|,
name|chrec_a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chrec_is_positive
argument_list|(
name|initial_condition
argument_list|(
name|difference
argument_list|)
argument_list|,
operator|&
name|value0
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"siv test failed: chrec is not positive.\n"
argument_list|)
expr_stmt|;
name|dependence_stats
operator|.
name|num_siv_unimplemented
operator|++
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|value0
operator|==
name|false
condition|)
block|{
if|if
condition|(
operator|!
name|chrec_is_positive
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec_b
argument_list|)
argument_list|,
operator|&
name|value1
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"siv test failed: chrec not positive.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
name|dependence_stats
operator|.
name|num_siv_unimplemented
operator|++
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|value1
operator|==
name|true
condition|)
block|{
comment|/* Example:   		     chrec_a = 12 		     chrec_b = {10, +, 1} 		  */
if|if
condition|(
name|tree_fold_divides_p
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec_b
argument_list|)
argument_list|,
name|difference
argument_list|)
condition|)
block|{
name|tree
name|numiter
decl_stmt|;
name|int
name|loopnum
init|=
name|CHREC_VARIABLE
argument_list|(
name|chrec_b
argument_list|)
decl_stmt|;
operator|*
name|overlaps_a
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|fold_build2
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|fold_build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|difference
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|chrec_b
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_one_node
expr_stmt|;
comment|/* Perform weak-zero siv test to see if overlap is 			 outside the loop bounds.  */
name|numiter
operator|=
name|get_number_of_iters_for_loop
argument_list|(
name|loopnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|numiter
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|overlaps_b
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|numiter
argument_list|,
operator|*
name|overlaps_b
argument_list|)
condition|)
block|{
operator|*
name|overlaps_a
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
name|dependence_stats
operator|.
name|num_siv_independent
operator|++
expr_stmt|;
return|return;
block|}
name|dependence_stats
operator|.
name|num_siv_dependent
operator|++
expr_stmt|;
return|return;
block|}
comment|/* When the step does not divide the difference, there are 		     no overlaps.  */
else|else
block|{
operator|*
name|overlaps_a
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
name|dependence_stats
operator|.
name|num_siv_independent
operator|++
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* Example:   		     chrec_a = 12 		     chrec_b = {10, +, -1} 		      		     In this case, chrec_a will not overlap with chrec_b.  */
operator|*
name|overlaps_a
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
name|dependence_stats
operator|.
name|num_siv_independent
operator|++
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|chrec_is_positive
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec_b
argument_list|)
argument_list|,
operator|&
name|value2
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"siv test failed: chrec not positive.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
name|dependence_stats
operator|.
name|num_siv_unimplemented
operator|++
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|value2
operator|==
name|false
condition|)
block|{
comment|/* Example:   		     chrec_a = 3 		     chrec_b = {10, +, -1} 		  */
if|if
condition|(
name|tree_fold_divides_p
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec_b
argument_list|)
argument_list|,
name|difference
argument_list|)
condition|)
block|{
name|tree
name|numiter
decl_stmt|;
name|int
name|loopnum
init|=
name|CHREC_VARIABLE
argument_list|(
name|chrec_b
argument_list|)
decl_stmt|;
operator|*
name|overlaps_a
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|fold_build2
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|difference
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|chrec_b
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_one_node
expr_stmt|;
comment|/* Perform weak-zero siv test to see if overlap is 			 outside the loop bounds.  */
name|numiter
operator|=
name|get_number_of_iters_for_loop
argument_list|(
name|loopnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|numiter
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|overlaps_b
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|numiter
argument_list|,
operator|*
name|overlaps_b
argument_list|)
condition|)
block|{
operator|*
name|overlaps_a
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
name|dependence_stats
operator|.
name|num_siv_independent
operator|++
expr_stmt|;
return|return;
block|}
name|dependence_stats
operator|.
name|num_siv_dependent
operator|++
expr_stmt|;
return|return;
block|}
comment|/* When the step does not divide the difference, there 		     are no overlaps.  */
else|else
block|{
operator|*
name|overlaps_a
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
name|dependence_stats
operator|.
name|num_siv_independent
operator|++
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* Example:   		     chrec_a = 3   		     chrec_b = {4, +, 1} 		  		     In this case, chrec_a will not overlap with chrec_b.  */
operator|*
name|overlaps_a
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
name|dependence_stats
operator|.
name|num_siv_independent
operator|++
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper recursive function for initializing the matrix A.  Returns    the initial value of CHREC.  */
end_comment

begin_function
specifier|static
name|int
name|initialize_matrix_A
parameter_list|(
name|lambda_matrix
name|A
parameter_list|,
name|tree
name|chrec
parameter_list|,
name|unsigned
name|index
parameter_list|,
name|int
name|mult
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|!=
name|POLYNOMIAL_CHREC
condition|)
return|return
name|int_cst_value
argument_list|(
name|chrec
argument_list|)
return|;
name|A
index|[
name|index
index|]
index|[
literal|0
index|]
operator|=
name|mult
operator|*
name|int_cst_value
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|initialize_matrix_A
argument_list|(
name|A
argument_list|,
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|mult
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FLOOR_DIV
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) / (y))
end_define

begin_comment
comment|/* Solves the special case of the Diophantine equation:     | {0, +, STEP_A}_x (OVERLAPS_A) = {0, +, STEP_B}_y (OVERLAPS_B)     Computes the descriptions OVERLAPS_A and OVERLAPS_B.  NITER is the    number of iterations that loops X and Y run.  The overlaps will be    constructed as evolutions in dimension DIM.  */
end_comment

begin_function
specifier|static
name|void
name|compute_overlap_steps_for_affine_univar
parameter_list|(
name|int
name|niter
parameter_list|,
name|int
name|step_a
parameter_list|,
name|int
name|step_b
parameter_list|,
name|tree
modifier|*
name|overlaps_a
parameter_list|,
name|tree
modifier|*
name|overlaps_b
parameter_list|,
name|tree
modifier|*
name|last_conflicts
parameter_list|,
name|int
name|dim
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|step_a
operator|>
literal|0
operator|&&
name|step_b
operator|>
literal|0
operator|)
operator|||
operator|(
name|step_a
operator|<
literal|0
operator|&&
name|step_b
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|step_overlaps_a
decl_stmt|,
name|step_overlaps_b
decl_stmt|;
name|int
name|gcd_steps_a_b
decl_stmt|,
name|last_conflict
decl_stmt|,
name|tau2
decl_stmt|;
name|gcd_steps_a_b
operator|=
name|gcd
argument_list|(
name|step_a
argument_list|,
name|step_b
argument_list|)
expr_stmt|;
name|step_overlaps_a
operator|=
name|step_b
operator|/
name|gcd_steps_a_b
expr_stmt|;
name|step_overlaps_b
operator|=
name|step_a
operator|/
name|gcd_steps_a_b
expr_stmt|;
name|tau2
operator|=
name|FLOOR_DIV
argument_list|(
name|niter
argument_list|,
name|step_overlaps_a
argument_list|)
expr_stmt|;
name|tau2
operator|=
name|MIN
argument_list|(
name|tau2
argument_list|,
name|FLOOR_DIV
argument_list|(
name|niter
argument_list|,
name|step_overlaps_b
argument_list|)
argument_list|)
expr_stmt|;
name|last_conflict
operator|=
name|tau2
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|build_polynomial_chrec
argument_list|(
name|dim
argument_list|,
name|integer_zero_node
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|step_overlaps_a
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|build_polynomial_chrec
argument_list|(
name|dim
argument_list|,
name|integer_zero_node
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|step_overlaps_b
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|last_conflict
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|overlaps_a
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Solves the special case of a Diophantine equation where CHREC_A is    an affine bivariate function, and CHREC_B is an affine univariate    function.  For example,      | {{0, +, 1}_x, +, 1335}_y = {0, +, 1336}_z        has the following overlapping functions:      | x (t, u, v) = {{0, +, 1336}_t, +, 1}_v    | y (t, u, v) = {{0, +, 1336}_u, +, 1}_v    | z (t, u, v) = {{{0, +, 1}_t, +, 1335}_u, +, 1}_v     FORNOW: This is a specialized implementation for a case occurring in    a common benchmark.  Implement the general algorithm.  */
end_comment

begin_function
specifier|static
name|void
name|compute_overlap_steps_for_affine_1_2
parameter_list|(
name|tree
name|chrec_a
parameter_list|,
name|tree
name|chrec_b
parameter_list|,
name|tree
modifier|*
name|overlaps_a
parameter_list|,
name|tree
modifier|*
name|overlaps_b
parameter_list|,
name|tree
modifier|*
name|last_conflicts
parameter_list|)
block|{
name|bool
name|xz_p
decl_stmt|,
name|yz_p
decl_stmt|,
name|xyz_p
decl_stmt|;
name|int
name|step_x
decl_stmt|,
name|step_y
decl_stmt|,
name|step_z
decl_stmt|;
name|int
name|niter_x
decl_stmt|,
name|niter_y
decl_stmt|,
name|niter_z
decl_stmt|,
name|niter
decl_stmt|;
name|tree
name|numiter_x
decl_stmt|,
name|numiter_y
decl_stmt|,
name|numiter_z
decl_stmt|;
name|tree
name|overlaps_a_xz
decl_stmt|,
name|overlaps_b_xz
decl_stmt|,
name|last_conflicts_xz
decl_stmt|;
name|tree
name|overlaps_a_yz
decl_stmt|,
name|overlaps_b_yz
decl_stmt|,
name|last_conflicts_yz
decl_stmt|;
name|tree
name|overlaps_a_xyz
decl_stmt|,
name|overlaps_b_xyz
decl_stmt|,
name|last_conflicts_xyz
decl_stmt|;
name|step_x
operator|=
name|int_cst_value
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec_a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|step_y
operator|=
name|int_cst_value
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec_a
argument_list|)
argument_list|)
expr_stmt|;
name|step_z
operator|=
name|int_cst_value
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec_b
argument_list|)
argument_list|)
expr_stmt|;
name|numiter_x
operator|=
name|get_number_of_iters_for_loop
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec_a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|numiter_y
operator|=
name|get_number_of_iters_for_loop
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec_a
argument_list|)
argument_list|)
expr_stmt|;
name|numiter_z
operator|=
name|get_number_of_iters_for_loop
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec_b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numiter_x
operator|==
name|NULL_TREE
operator|||
name|numiter_y
operator|==
name|NULL_TREE
operator|||
name|numiter_z
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"overlap steps test failed: no iteration counts.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
return|return;
block|}
name|niter_x
operator|=
name|int_cst_value
argument_list|(
name|numiter_x
argument_list|)
expr_stmt|;
name|niter_y
operator|=
name|int_cst_value
argument_list|(
name|numiter_y
argument_list|)
expr_stmt|;
name|niter_z
operator|=
name|int_cst_value
argument_list|(
name|numiter_z
argument_list|)
expr_stmt|;
name|niter
operator|=
name|MIN
argument_list|(
name|niter_x
argument_list|,
name|niter_z
argument_list|)
expr_stmt|;
name|compute_overlap_steps_for_affine_univar
argument_list|(
name|niter
argument_list|,
name|step_x
argument_list|,
name|step_z
argument_list|,
operator|&
name|overlaps_a_xz
argument_list|,
operator|&
name|overlaps_b_xz
argument_list|,
operator|&
name|last_conflicts_xz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|niter
operator|=
name|MIN
argument_list|(
name|niter_y
argument_list|,
name|niter_z
argument_list|)
expr_stmt|;
name|compute_overlap_steps_for_affine_univar
argument_list|(
name|niter
argument_list|,
name|step_y
argument_list|,
name|step_z
argument_list|,
operator|&
name|overlaps_a_yz
argument_list|,
operator|&
name|overlaps_b_yz
argument_list|,
operator|&
name|last_conflicts_yz
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|niter
operator|=
name|MIN
argument_list|(
name|niter_x
argument_list|,
name|niter_z
argument_list|)
expr_stmt|;
name|niter
operator|=
name|MIN
argument_list|(
name|niter_y
argument_list|,
name|niter
argument_list|)
expr_stmt|;
name|compute_overlap_steps_for_affine_univar
argument_list|(
name|niter
argument_list|,
name|step_x
operator|+
name|step_y
argument_list|,
name|step_z
argument_list|,
operator|&
name|overlaps_a_xyz
argument_list|,
operator|&
name|overlaps_b_xyz
argument_list|,
operator|&
name|last_conflicts_xyz
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|xz_p
operator|=
operator|!
name|integer_zerop
argument_list|(
name|last_conflicts_xz
argument_list|)
expr_stmt|;
name|yz_p
operator|=
operator|!
name|integer_zerop
argument_list|(
name|last_conflicts_yz
argument_list|)
expr_stmt|;
name|xyz_p
operator|=
operator|!
name|integer_zerop
argument_list|(
name|last_conflicts_xyz
argument_list|)
expr_stmt|;
if|if
condition|(
name|xz_p
operator|||
name|yz_p
operator|||
name|xyz_p
condition|)
block|{
operator|*
name|overlaps_a
operator|=
name|make_tree_vec
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
operator|*
name|overlaps_a
argument_list|,
literal|0
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
operator|*
name|overlaps_a
argument_list|,
literal|1
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|xz_p
condition|)
block|{
name|tree
name|t0
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|TREE_VEC_ELT
argument_list|(
operator|*
name|overlaps_a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|t1
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|overlaps_a_xz
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
operator|*
name|overlaps_b
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|t3
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|overlaps_b_xz
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|TREE_VEC_ELT
argument_list|(
operator|*
name|overlaps_a
argument_list|,
literal|0
argument_list|)
operator|=
name|chrec_fold_plus
argument_list|(
name|integer_type_node
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|)
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_fold_plus
argument_list|(
name|integer_type_node
argument_list|,
name|t2
argument_list|,
name|t3
argument_list|)
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|last_conflicts_xz
expr_stmt|;
block|}
if|if
condition|(
name|yz_p
condition|)
block|{
name|tree
name|t0
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|TREE_VEC_ELT
argument_list|(
operator|*
name|overlaps_a
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|t1
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|overlaps_a_yz
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
operator|*
name|overlaps_b
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|t3
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|overlaps_b_yz
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|TREE_VEC_ELT
argument_list|(
operator|*
name|overlaps_a
argument_list|,
literal|1
argument_list|)
operator|=
name|chrec_fold_plus
argument_list|(
name|integer_type_node
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|)
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_fold_plus
argument_list|(
name|integer_type_node
argument_list|,
name|t2
argument_list|,
name|t3
argument_list|)
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|last_conflicts_yz
expr_stmt|;
block|}
if|if
condition|(
name|xyz_p
condition|)
block|{
name|tree
name|t0
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|TREE_VEC_ELT
argument_list|(
operator|*
name|overlaps_a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|t1
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|overlaps_a_xyz
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|TREE_VEC_ELT
argument_list|(
operator|*
name|overlaps_a
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|t3
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|overlaps_a_xyz
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|t4
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
operator|*
name|overlaps_b
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|t5
init|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|overlaps_b_xyz
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|TREE_VEC_ELT
argument_list|(
operator|*
name|overlaps_a
argument_list|,
literal|0
argument_list|)
operator|=
name|chrec_fold_plus
argument_list|(
name|integer_type_node
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
operator|*
name|overlaps_a
argument_list|,
literal|1
argument_list|)
operator|=
name|chrec_fold_plus
argument_list|(
name|integer_type_node
argument_list|,
name|t2
argument_list|,
name|t3
argument_list|)
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_fold_plus
argument_list|(
name|integer_type_node
argument_list|,
name|t4
argument_list|,
name|t5
argument_list|)
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|last_conflicts_xyz
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|overlaps_a
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determines the overlapping elements due to accesses CHREC_A and    CHREC_B, that are affine functions.  This function cannot handle    symbolic evolution functions, ie. when initial conditions are    parameters, because it uses lambda matrices of integers.  */
end_comment

begin_function
specifier|static
name|void
name|analyze_subscript_affine_affine
parameter_list|(
name|tree
name|chrec_a
parameter_list|,
name|tree
name|chrec_b
parameter_list|,
name|tree
modifier|*
name|overlaps_a
parameter_list|,
name|tree
modifier|*
name|overlaps_b
parameter_list|,
name|tree
modifier|*
name|last_conflicts
parameter_list|)
block|{
name|unsigned
name|nb_vars_a
decl_stmt|,
name|nb_vars_b
decl_stmt|,
name|dim
decl_stmt|;
name|int
name|init_a
decl_stmt|,
name|init_b
decl_stmt|,
name|gamma
decl_stmt|,
name|gcd_alpha_beta
decl_stmt|;
name|int
name|tau1
decl_stmt|,
name|tau2
decl_stmt|;
name|lambda_matrix
name|A
decl_stmt|,
name|U
decl_stmt|,
name|S
decl_stmt|;
if|if
condition|(
name|eq_evolutions_p
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|)
condition|)
block|{
comment|/* The accessed index overlaps for each iteration in the 	 loop.  */
operator|*
name|overlaps_a
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(analyze_subscript_affine_affine \n"
argument_list|)
expr_stmt|;
comment|/* For determining the initial intersection, we have to solve a      Diophantine equation.  This is the most time consuming part.            For answering to the question: "Is there a dependence?" we have      to prove that there exists a solution to the Diophantine      equation, and that the solution is in the iteration domain,      i.e. the solution is positive or zero, and that the solution      happens before the upper bound loop.nb_iterations.  Otherwise      there is no dependence.  This function outputs a description of      the iterations that hold the intersections.  */
name|nb_vars_a
operator|=
name|nb_vars_in_chrec
argument_list|(
name|chrec_a
argument_list|)
expr_stmt|;
name|nb_vars_b
operator|=
name|nb_vars_in_chrec
argument_list|(
name|chrec_b
argument_list|)
expr_stmt|;
name|dim
operator|=
name|nb_vars_a
operator|+
name|nb_vars_b
expr_stmt|;
name|U
operator|=
name|lambda_matrix_new
argument_list|(
name|dim
argument_list|,
name|dim
argument_list|)
expr_stmt|;
name|A
operator|=
name|lambda_matrix_new
argument_list|(
name|dim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|S
operator|=
name|lambda_matrix_new
argument_list|(
name|dim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init_a
operator|=
name|initialize_matrix_A
argument_list|(
name|A
argument_list|,
name|chrec_a
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init_b
operator|=
name|initialize_matrix_A
argument_list|(
name|A
argument_list|,
name|chrec_b
argument_list|,
name|nb_vars_a
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gamma
operator|=
name|init_b
operator|-
name|init_a
expr_stmt|;
comment|/* Don't do all the hard work of solving the Diophantine equation      when we already know the solution: for example,       | {3, +, 1}_1      | {3, +, 4}_2      | gamma = 3 - 3 = 0.      Then the first overlap occurs during the first iterations:       | {3, +, 1}_1 ({0, +, 4}_x) = {3, +, 4}_2 ({0, +, 1}_x)   */
if|if
condition|(
name|gamma
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nb_vars_a
operator|==
literal|1
operator|&&
name|nb_vars_b
operator|==
literal|1
condition|)
block|{
name|int
name|step_a
decl_stmt|,
name|step_b
decl_stmt|;
name|int
name|niter
decl_stmt|,
name|niter_a
decl_stmt|,
name|niter_b
decl_stmt|;
name|tree
name|numiter_a
decl_stmt|,
name|numiter_b
decl_stmt|;
name|numiter_a
operator|=
name|get_number_of_iters_for_loop
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec_a
argument_list|)
argument_list|)
expr_stmt|;
name|numiter_b
operator|=
name|get_number_of_iters_for_loop
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec_b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numiter_a
operator|==
name|NULL_TREE
operator|||
name|numiter_b
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"affine-affine test failed: missing iteration counts.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
goto|goto
name|end_analyze_subs_aa
goto|;
block|}
name|niter_a
operator|=
name|int_cst_value
argument_list|(
name|numiter_a
argument_list|)
expr_stmt|;
name|niter_b
operator|=
name|int_cst_value
argument_list|(
name|numiter_b
argument_list|)
expr_stmt|;
name|niter
operator|=
name|MIN
argument_list|(
name|niter_a
argument_list|,
name|niter_b
argument_list|)
expr_stmt|;
name|step_a
operator|=
name|int_cst_value
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec_a
argument_list|)
argument_list|)
expr_stmt|;
name|step_b
operator|=
name|int_cst_value
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec_b
argument_list|)
argument_list|)
expr_stmt|;
name|compute_overlap_steps_for_affine_univar
argument_list|(
name|niter
argument_list|,
name|step_a
argument_list|,
name|step_b
argument_list|,
name|overlaps_a
argument_list|,
name|overlaps_b
argument_list|,
name|last_conflicts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nb_vars_a
operator|==
literal|2
operator|&&
name|nb_vars_b
operator|==
literal|1
condition|)
name|compute_overlap_steps_for_affine_1_2
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|,
name|overlaps_a
argument_list|,
name|overlaps_b
argument_list|,
name|last_conflicts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nb_vars_a
operator|==
literal|1
operator|&&
name|nb_vars_b
operator|==
literal|2
condition|)
name|compute_overlap_steps_for_affine_1_2
argument_list|(
name|chrec_b
argument_list|,
name|chrec_a
argument_list|,
name|overlaps_b
argument_list|,
name|overlaps_a
argument_list|,
name|last_conflicts
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"affine-affine test failed: too many variables.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
goto|goto
name|end_analyze_subs_aa
goto|;
block|}
comment|/* U.A = S */
name|lambda_matrix_right_hermite
argument_list|(
name|A
argument_list|,
name|dim
argument_list|,
literal|1
argument_list|,
name|S
argument_list|,
name|U
argument_list|)
expr_stmt|;
if|if
condition|(
name|S
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|<
literal|0
condition|)
block|{
name|S
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
name|lambda_matrix_row_negate
argument_list|(
name|U
argument_list|,
name|dim
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gcd_alpha_beta
operator|=
name|S
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* Something went wrong: for example in {1, +, 0}_5 vs. {0, +, 0}_5,      but that is a quite strange case.  Instead of ICEing, answer      don't know.  */
if|if
condition|(
name|gcd_alpha_beta
operator|==
literal|0
condition|)
block|{
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
goto|goto
name|end_analyze_subs_aa
goto|;
block|}
comment|/* The classic "gcd-test".  */
if|if
condition|(
operator|!
name|int_divides_p
argument_list|(
name|gcd_alpha_beta
argument_list|,
name|gamma
argument_list|)
condition|)
block|{
comment|/* The "gcd-test" has determined that there is no integer 	 solution, i.e. there is no dependence.  */
operator|*
name|overlaps_a
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
comment|/* Both access functions are univariate.  This includes SIV and MIV cases.  */
elseif|else
if|if
condition|(
name|nb_vars_a
operator|==
literal|1
operator|&&
name|nb_vars_b
operator|==
literal|1
condition|)
block|{
comment|/* Both functions should have the same evolution sign.  */
if|if
condition|(
operator|(
operator|(
name|A
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|>
literal|0
operator|&&
operator|-
name|A
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|>
literal|0
operator|)
operator|||
operator|(
name|A
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|<
literal|0
operator|&&
operator|-
name|A
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* The solutions are given by: 	     |  	     | [GAMMA/GCD_ALPHA_BETA  t].[u11 u12]  = [x0] 	     |                           [u21 u22]    [y0] 	  	     For a given integer t.  Using the following variables, 	  	     | i0 = u11 * gamma / gcd_alpha_beta 	     | j0 = u12 * gamma / gcd_alpha_beta 	     | i1 = u21 	     | j1 = u22 	  	     the solutions are: 	  	     | x0 = i0 + i1 * t,  	     | y0 = j0 + j1 * t.  */
name|int
name|i0
decl_stmt|,
name|j0
decl_stmt|,
name|i1
decl_stmt|,
name|j1
decl_stmt|;
comment|/* X0 and Y0 are the first iterations for which there is a 	     dependence.  X0, Y0 are two solutions of the Diophantine 	     equation: chrec_a (X0) = chrec_b (Y0).  */
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|;
name|int
name|niter
decl_stmt|,
name|niter_a
decl_stmt|,
name|niter_b
decl_stmt|;
name|tree
name|numiter_a
decl_stmt|,
name|numiter_b
decl_stmt|;
name|numiter_a
operator|=
name|get_number_of_iters_for_loop
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec_a
argument_list|)
argument_list|)
expr_stmt|;
name|numiter_b
operator|=
name|get_number_of_iters_for_loop
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec_b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numiter_a
operator|==
name|NULL_TREE
operator|||
name|numiter_b
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"affine-affine test failed: missing iteration counts.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
goto|goto
name|end_analyze_subs_aa
goto|;
block|}
name|niter_a
operator|=
name|int_cst_value
argument_list|(
name|numiter_a
argument_list|)
expr_stmt|;
name|niter_b
operator|=
name|int_cst_value
argument_list|(
name|numiter_b
argument_list|)
expr_stmt|;
name|niter
operator|=
name|MIN
argument_list|(
name|niter_a
argument_list|,
name|niter_b
argument_list|)
expr_stmt|;
name|i0
operator|=
name|U
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|gamma
operator|/
name|gcd_alpha_beta
expr_stmt|;
name|j0
operator|=
name|U
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|gamma
operator|/
name|gcd_alpha_beta
expr_stmt|;
name|i1
operator|=
name|U
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|j1
operator|=
name|U
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i1
operator|==
literal|0
operator|&&
name|i0
operator|<
literal|0
operator|)
operator|||
operator|(
name|j1
operator|==
literal|0
operator|&&
name|j0
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* There is no solution.   		 FIXME: The case "i0> nb_iterations, j0> nb_iterations"  		 falls in here, but for the moment we don't look at the  		 upper bound of the iteration domain.  */
operator|*
name|overlaps_a
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i1
operator|>
literal|0
condition|)
block|{
name|tau1
operator|=
name|CEIL
argument_list|(
operator|-
name|i0
argument_list|,
name|i1
argument_list|)
expr_stmt|;
name|tau2
operator|=
name|FLOOR_DIV
argument_list|(
name|niter
operator|-
name|i0
argument_list|,
name|i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|j1
operator|>
literal|0
condition|)
block|{
name|int
name|last_conflict
decl_stmt|,
name|min_multiple
decl_stmt|;
name|tau1
operator|=
name|MAX
argument_list|(
name|tau1
argument_list|,
name|CEIL
argument_list|(
operator|-
name|j0
argument_list|,
name|j1
argument_list|)
argument_list|)
expr_stmt|;
name|tau2
operator|=
name|MIN
argument_list|(
name|tau2
argument_list|,
name|FLOOR_DIV
argument_list|(
name|niter
operator|-
name|j0
argument_list|,
name|j1
argument_list|)
argument_list|)
expr_stmt|;
name|x0
operator|=
name|i1
operator|*
name|tau1
operator|+
name|i0
expr_stmt|;
name|y0
operator|=
name|j1
operator|*
name|tau1
operator|+
name|j0
expr_stmt|;
comment|/* At this point (x0, y0) is one of the 			 solutions to the Diophantine equation.  The 			 next step has to compute the smallest 			 positive solution: the first conflicts.  */
name|min_multiple
operator|=
name|MIN
argument_list|(
name|x0
operator|/
name|i1
argument_list|,
name|y0
operator|/
name|j1
argument_list|)
expr_stmt|;
name|x0
operator|-=
name|i1
operator|*
name|min_multiple
expr_stmt|;
name|y0
operator|-=
name|j1
operator|*
name|min_multiple
expr_stmt|;
name|tau1
operator|=
operator|(
name|x0
operator|-
name|i0
operator|)
operator|/
name|i1
expr_stmt|;
name|last_conflict
operator|=
name|tau2
operator|-
name|tau1
expr_stmt|;
comment|/* If the overlap occurs outside of the bounds of the 			 loop, there is no dependence.  */
if|if
condition|(
name|x0
operator|>
name|niter
operator|||
name|y0
operator|>
name|niter
condition|)
block|{
operator|*
name|overlaps_a
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
block|{
operator|*
name|overlaps_a
operator|=
name|build_polynomial_chrec
argument_list|(
literal|1
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|x0
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|i1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|build_polynomial_chrec
argument_list|(
literal|1
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|y0
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|j1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|last_conflict
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* FIXME: For the moment, the upper bound of the 			 iteration domain for j is not checked.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"affine-affine test failed: unimplemented.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* FIXME: For the moment, the upper bound of the 		     iteration domain for i is not checked.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"affine-affine test failed: unimplemented.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"affine-affine test failed: unimplemented.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"affine-affine test failed: unimplemented.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
name|end_analyze_subs_aa
label|:
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (overlaps_a = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
operator|*
name|overlaps_a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n  (overlaps_b = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
operator|*
name|overlaps_b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true when analyze_subscript_affine_affine can be used for    determining the dependence relation between chrec_a and chrec_b,    that contain symbols.  This function modifies chrec_a and chrec_b    such that the analysis result is the same, and such that they don't    contain symbols, and then can safely be passed to the analyzer.       Example: The analysis of the following tuples of evolutions produce    the same results: {x+1, +, 1}_1 vs. {x+3, +, 1}_1, and {-2, +, 1}_1    vs. {0, +, 1}_1        {x+1, +, 1}_1 ({2, +, 1}_1) = {x+3, +, 1}_1 ({0, +, 1}_1)    {-2, +, 1}_1 ({2, +, 1}_1) = {0, +, 1}_1 ({0, +, 1}_1) */
end_comment

begin_function
specifier|static
name|bool
name|can_use_analyze_subscript_affine_affine
parameter_list|(
name|tree
modifier|*
name|chrec_a
parameter_list|,
name|tree
modifier|*
name|chrec_b
parameter_list|)
block|{
name|tree
name|diff
decl_stmt|,
name|type
decl_stmt|,
name|left_a
decl_stmt|,
name|left_b
decl_stmt|,
name|right_b
decl_stmt|;
if|if
condition|(
name|chrec_contains_symbols
argument_list|(
name|CHREC_RIGHT
argument_list|(
operator|*
name|chrec_a
argument_list|)
argument_list|)
operator|||
name|chrec_contains_symbols
argument_list|(
name|CHREC_RIGHT
argument_list|(
operator|*
name|chrec_b
argument_list|)
argument_list|)
condition|)
comment|/* FIXME: For the moment not handled.  Might be refined later.  */
return|return
name|false
return|;
name|type
operator|=
name|chrec_type
argument_list|(
operator|*
name|chrec_a
argument_list|)
expr_stmt|;
name|left_a
operator|=
name|CHREC_LEFT
argument_list|(
operator|*
name|chrec_a
argument_list|)
expr_stmt|;
name|left_b
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
operator|*
name|chrec_b
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|diff
operator|=
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|left_a
argument_list|,
name|left_b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|evolution_function_is_constant_p
argument_list|(
name|diff
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"can_use_subscript_aff_aff_for_symbolic \n"
argument_list|)
expr_stmt|;
operator|*
name|chrec_a
operator|=
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
operator|*
name|chrec_a
argument_list|)
argument_list|,
name|diff
argument_list|,
name|CHREC_RIGHT
argument_list|(
operator|*
name|chrec_a
argument_list|)
argument_list|)
expr_stmt|;
name|right_b
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
operator|*
name|chrec_b
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
operator|*
name|chrec_b
operator|=
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
operator|*
name|chrec_b
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|right_b
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Analyze a SIV (Single Index Variable) subscript.  *OVERLAPS_A and    *OVERLAPS_B are initialized to the functions that describe the    relation between the elements accessed twice by CHREC_A and    CHREC_B.  For k>= 0, the following property is verified:     CHREC_A (*OVERLAPS_A (k)) = CHREC_B (*OVERLAPS_B (k)).  */
end_comment

begin_function
specifier|static
name|void
name|analyze_siv_subscript
parameter_list|(
name|tree
name|chrec_a
parameter_list|,
name|tree
name|chrec_b
parameter_list|,
name|tree
modifier|*
name|overlaps_a
parameter_list|,
name|tree
modifier|*
name|overlaps_b
parameter_list|,
name|tree
modifier|*
name|last_conflicts
parameter_list|)
block|{
name|dependence_stats
operator|.
name|num_siv
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(analyze_siv_subscript \n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|evolution_function_is_constant_p
argument_list|(
name|chrec_a
argument_list|)
operator|&&
name|evolution_function_is_affine_p
argument_list|(
name|chrec_b
argument_list|)
condition|)
name|analyze_siv_subscript_cst_affine
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|,
name|overlaps_a
argument_list|,
name|overlaps_b
argument_list|,
name|last_conflicts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|evolution_function_is_affine_p
argument_list|(
name|chrec_a
argument_list|)
operator|&&
name|evolution_function_is_constant_p
argument_list|(
name|chrec_b
argument_list|)
condition|)
name|analyze_siv_subscript_cst_affine
argument_list|(
name|chrec_b
argument_list|,
name|chrec_a
argument_list|,
name|overlaps_b
argument_list|,
name|overlaps_a
argument_list|,
name|last_conflicts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|evolution_function_is_affine_p
argument_list|(
name|chrec_a
argument_list|)
operator|&&
name|evolution_function_is_affine_p
argument_list|(
name|chrec_b
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|chrec_contains_symbols
argument_list|(
name|chrec_a
argument_list|)
operator|&&
operator|!
name|chrec_contains_symbols
argument_list|(
name|chrec_b
argument_list|)
condition|)
block|{
name|analyze_subscript_affine_affine
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|,
name|overlaps_a
argument_list|,
name|overlaps_b
argument_list|,
name|last_conflicts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|overlaps_a
operator|==
name|chrec_dont_know
operator|||
operator|*
name|overlaps_b
operator|==
name|chrec_dont_know
condition|)
name|dependence_stats
operator|.
name|num_siv_unimplemented
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|overlaps_a
operator|==
name|chrec_known
operator|||
operator|*
name|overlaps_b
operator|==
name|chrec_known
condition|)
name|dependence_stats
operator|.
name|num_siv_independent
operator|++
expr_stmt|;
else|else
name|dependence_stats
operator|.
name|num_siv_dependent
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|can_use_analyze_subscript_affine_affine
argument_list|(
operator|&
name|chrec_a
argument_list|,
operator|&
name|chrec_b
argument_list|)
condition|)
block|{
name|analyze_subscript_affine_affine
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|,
name|overlaps_a
argument_list|,
name|overlaps_b
argument_list|,
name|last_conflicts
argument_list|)
expr_stmt|;
comment|/* FIXME: The number of iterations is a symbolic expression. 	     Compute it properly.  */
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
if|if
condition|(
operator|*
name|overlaps_a
operator|==
name|chrec_dont_know
operator|||
operator|*
name|overlaps_b
operator|==
name|chrec_dont_know
condition|)
name|dependence_stats
operator|.
name|num_siv_unimplemented
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|overlaps_a
operator|==
name|chrec_known
operator|||
operator|*
name|overlaps_b
operator|==
name|chrec_known
condition|)
name|dependence_stats
operator|.
name|num_siv_independent
operator|++
expr_stmt|;
else|else
name|dependence_stats
operator|.
name|num_siv_dependent
operator|++
expr_stmt|;
block|}
else|else
goto|goto
name|siv_subscript_dontknow
goto|;
block|}
else|else
block|{
name|siv_subscript_dontknow
label|:
empty_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"siv test failed: unimplemented.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
name|dependence_stats
operator|.
name|num_siv_unimplemented
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true when the property can be computed.  RES should contain    true when calling the first time this function, then it is set to    false when one of the evolution steps of an affine CHREC does not    divide the constant CST.  */
end_comment

begin_function
specifier|static
name|bool
name|chrec_steps_divide_constant_p
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|tree
name|cst
parameter_list|,
name|bool
modifier|*
name|res
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
if|if
condition|(
name|evolution_function_is_constant_p
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|tree_fold_divides_p
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|cst
argument_list|)
condition|)
comment|/* Keep RES to true, and iterate on other dimensions.  */
return|return
name|chrec_steps_divide_constant_p
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|cst
argument_list|,
name|res
argument_list|)
return|;
operator|*
name|res
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
comment|/* When the step is a parameter the result is undetermined.  */
return|return
name|false
return|;
default|default:
comment|/* On the initial condition, return true.  */
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Analyze a MIV (Multiple Index Variable) subscript.  *OVERLAPS_A and    *OVERLAPS_B are initialized to the functions that describe the    relation between the elements accessed twice by CHREC_A and    CHREC_B.  For k>= 0, the following property is verified:     CHREC_A (*OVERLAPS_A (k)) = CHREC_B (*OVERLAPS_B (k)).  */
end_comment

begin_function
specifier|static
name|void
name|analyze_miv_subscript
parameter_list|(
name|tree
name|chrec_a
parameter_list|,
name|tree
name|chrec_b
parameter_list|,
name|tree
modifier|*
name|overlaps_a
parameter_list|,
name|tree
modifier|*
name|overlaps_b
parameter_list|,
name|tree
modifier|*
name|last_conflicts
parameter_list|)
block|{
comment|/* FIXME:  This is a MIV subscript, not yet handled.      Example: (A[{1, +, 1}_1] vs. A[{1, +, 1}_2]) that comes from       (A[i] vs. A[j]).              In the SIV test we had to solve a Diophantine equation with two      variables.  In the MIV case we have to solve a Diophantine      equation with 2*n variables (if the subscript uses n IVs).   */
name|bool
name|divide_p
init|=
name|true
decl_stmt|;
name|tree
name|difference
decl_stmt|;
name|dependence_stats
operator|.
name|num_miv
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(analyze_miv_subscript \n"
argument_list|)
expr_stmt|;
name|chrec_a
operator|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|chrec_a
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chrec_b
operator|=
name|chrec_convert
argument_list|(
name|integer_type_node
argument_list|,
name|chrec_b
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|difference
operator|=
name|chrec_fold_minus
argument_list|(
name|integer_type_node
argument_list|,
name|chrec_a
argument_list|,
name|chrec_b
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq_evolutions_p
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|)
condition|)
block|{
comment|/* Access functions are the same: all the elements are accessed 	 in the same order.  */
operator|*
name|overlaps_a
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|get_number_of_iters_for_loop
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec_a
argument_list|)
argument_list|)
expr_stmt|;
name|dependence_stats
operator|.
name|num_miv_dependent
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evolution_function_is_constant_p
argument_list|(
name|difference
argument_list|)
comment|/* For the moment, the following is verified: 	      evolution_function_is_affine_multivariate_p (chrec_a) */
operator|&&
name|chrec_steps_divide_constant_p
argument_list|(
name|chrec_a
argument_list|,
name|difference
argument_list|,
operator|&
name|divide_p
argument_list|)
operator|&&
operator|!
name|divide_p
condition|)
block|{
comment|/* testsuite/.../ssa-chrec-33.c 	 {{21, +, 2}_1, +, -2}_2  vs.  {{20, +, 2}_1, +, -2}_2  	  	 The difference is 1, and the evolution steps are equal to 2, 	 consequently there are no overlapping elements.  */
operator|*
name|overlaps_a
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_known
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|integer_zero_node
expr_stmt|;
name|dependence_stats
operator|.
name|num_miv_independent
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evolution_function_is_affine_multivariate_p
argument_list|(
name|chrec_a
argument_list|)
operator|&&
operator|!
name|chrec_contains_symbols
argument_list|(
name|chrec_a
argument_list|)
operator|&&
name|evolution_function_is_affine_multivariate_p
argument_list|(
name|chrec_b
argument_list|)
operator|&&
operator|!
name|chrec_contains_symbols
argument_list|(
name|chrec_b
argument_list|)
condition|)
block|{
comment|/* testsuite/.../ssa-chrec-35.c 	 {0, +, 1}_2  vs.  {0, +, 1}_3 	 the overlapping elements are respectively located at iterations: 	 {0, +, 1}_x and {0, +, 1}_x,  	 in other words, we have the equality:  	 {0, +, 1}_2 ({0, +, 1}_x) = {0, +, 1}_3 ({0, +, 1}_x) 	  	 Other examples:  	 {{0, +, 1}_1, +, 2}_2 ({0, +, 1}_x, {0, +, 1}_y) =  	 {0, +, 1}_1 ({{0, +, 1}_x, +, 2}_y)  	 {{0, +, 2}_1, +, 3}_2 ({0, +, 1}_y, {0, +, 1}_x) =  	 {{0, +, 3}_1, +, 2}_2 ({0, +, 1}_x, {0, +, 1}_y)       */
name|analyze_subscript_affine_affine
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|,
name|overlaps_a
argument_list|,
name|overlaps_b
argument_list|,
name|last_conflicts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|overlaps_a
operator|==
name|chrec_dont_know
operator|||
operator|*
name|overlaps_b
operator|==
name|chrec_dont_know
condition|)
name|dependence_stats
operator|.
name|num_miv_unimplemented
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|overlaps_a
operator|==
name|chrec_known
operator|||
operator|*
name|overlaps_b
operator|==
name|chrec_known
condition|)
name|dependence_stats
operator|.
name|num_miv_independent
operator|++
expr_stmt|;
else|else
name|dependence_stats
operator|.
name|num_miv_dependent
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* When the analysis is too difficult, answer "don't know".  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"analyze_miv_subscript test failed: unimplemented.\n"
argument_list|)
expr_stmt|;
operator|*
name|overlaps_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlaps_b
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
name|dependence_stats
operator|.
name|num_miv_unimplemented
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determines the iterations for which CHREC_A is equal to CHREC_B.    OVERLAP_ITERATIONS_A and OVERLAP_ITERATIONS_B are initialized with    two functions that describe the iterations that contain conflicting    elements.        Remark: For an integer k>= 0, the following equality is true:        CHREC_A (OVERLAP_ITERATIONS_A (k)) == CHREC_B (OVERLAP_ITERATIONS_B (k)). */
end_comment

begin_function
specifier|static
name|void
name|analyze_overlapping_iterations
parameter_list|(
name|tree
name|chrec_a
parameter_list|,
name|tree
name|chrec_b
parameter_list|,
name|tree
modifier|*
name|overlap_iterations_a
parameter_list|,
name|tree
modifier|*
name|overlap_iterations_b
parameter_list|,
name|tree
modifier|*
name|last_conflicts
parameter_list|)
block|{
name|dependence_stats
operator|.
name|num_subscript_tests
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(analyze_overlapping_iterations \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (chrec_a = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|chrec_a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n  (chrec_b = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|chrec_b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chrec_a
operator|==
name|NULL_TREE
operator|||
name|chrec_b
operator|==
name|NULL_TREE
operator|||
name|chrec_contains_undetermined
argument_list|(
name|chrec_a
argument_list|)
operator|||
name|chrec_contains_undetermined
argument_list|(
name|chrec_b
argument_list|)
condition|)
block|{
name|dependence_stats
operator|.
name|num_subscript_undetermined
operator|++
expr_stmt|;
operator|*
name|overlap_iterations_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlap_iterations_b
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
comment|/* If they are the same chrec, and are affine, they overlap       on every iteration.  */
elseif|else
if|if
condition|(
name|eq_evolutions_p
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|)
operator|&&
name|evolution_function_is_affine_multivariate_p
argument_list|(
name|chrec_a
argument_list|)
condition|)
block|{
name|dependence_stats
operator|.
name|num_same_subscript_function
operator|++
expr_stmt|;
operator|*
name|overlap_iterations_a
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|overlap_iterations_b
operator|=
name|integer_zero_node
expr_stmt|;
operator|*
name|last_conflicts
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
comment|/* If they aren't the same, and aren't affine, we can't do anything      yet. */
elseif|else
if|if
condition|(
operator|(
name|chrec_contains_symbols
argument_list|(
name|chrec_a
argument_list|)
operator|||
name|chrec_contains_symbols
argument_list|(
name|chrec_b
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|evolution_function_is_affine_multivariate_p
argument_list|(
name|chrec_a
argument_list|)
operator|||
operator|!
name|evolution_function_is_affine_multivariate_p
argument_list|(
name|chrec_b
argument_list|)
operator|)
condition|)
block|{
name|dependence_stats
operator|.
name|num_subscript_undetermined
operator|++
expr_stmt|;
operator|*
name|overlap_iterations_a
operator|=
name|chrec_dont_know
expr_stmt|;
operator|*
name|overlap_iterations_b
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ziv_subscript_p
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|)
condition|)
name|analyze_ziv_subscript
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|,
name|overlap_iterations_a
argument_list|,
name|overlap_iterations_b
argument_list|,
name|last_conflicts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|siv_subscript_p
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|)
condition|)
name|analyze_siv_subscript
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|,
name|overlap_iterations_a
argument_list|,
name|overlap_iterations_b
argument_list|,
name|last_conflicts
argument_list|)
expr_stmt|;
else|else
name|analyze_miv_subscript
argument_list|(
name|chrec_a
argument_list|,
name|chrec_b
argument_list|,
name|overlap_iterations_a
argument_list|,
name|overlap_iterations_b
argument_list|,
name|last_conflicts
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (overlap_iterations_a = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
operator|*
name|overlap_iterations_a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n  (overlap_iterations_b = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
operator|*
name|overlap_iterations_b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function for uniquely inserting distance vectors.  */
end_comment

begin_function
specifier|static
name|void
name|save_dist_v
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|,
name|lambda_vector
name|dist_v
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|lambda_vector
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|lambda_vector
argument_list|,
name|DDR_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|i
argument_list|,
name|v
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lambda_vector_equal
argument_list|(
name|v
argument_list|,
name|dist_v
argument_list|,
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
condition|)
return|return;
name|VEC_safe_push
argument_list|(
name|lambda_vector
argument_list|,
name|heap
argument_list|,
name|DDR_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|dist_v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for uniquely inserting direction vectors.  */
end_comment

begin_function
specifier|static
name|void
name|save_dir_v
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|,
name|lambda_vector
name|dir_v
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|lambda_vector
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|lambda_vector
argument_list|,
name|DDR_DIR_VECTS
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|i
argument_list|,
name|v
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lambda_vector_equal
argument_list|(
name|v
argument_list|,
name|dir_v
argument_list|,
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
condition|)
return|return;
name|VEC_safe_push
argument_list|(
name|lambda_vector
argument_list|,
name|heap
argument_list|,
name|DDR_DIR_VECTS
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|dir_v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a distance of 1 on all the loops outer than INDEX.  If we    haven't yet determined a distance for this outer loop, push a new    distance vector composed of the previous distance, and a distance    of 1 for this outer loop.  Example:     | loop_1    |   loop_2    |     A[10]    |   endloop_2    | endloop_1     Saved vectors are of the form (dist_in_1, dist_in_2).  First, we    save (0, 1), then we have to save (1, 0).  */
end_comment

begin_function
specifier|static
name|void
name|add_outer_distances
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|,
name|lambda_vector
name|dist_v
parameter_list|,
name|int
name|index
parameter_list|)
block|{
comment|/* For each outer loop where init_v is not set, the accesses are      in dependence of distance 1 in the loop.  */
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
block|{
name|lambda_vector
name|save_v
init|=
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
decl_stmt|;
name|lambda_vector_copy
argument_list|(
name|dist_v
argument_list|,
name|save_v
argument_list|,
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|save_v
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
name|save_dist_v
argument_list|(
name|ddr
argument_list|,
name|save_v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return false when fail to represent the data dependence as a    distance vector.  INIT_B is set to true when a component has been    added to the distance vector DIST_V.  INDEX_CARRY is then set to    the index in DIST_V that carries the dependence.  */
end_comment

begin_function
specifier|static
name|bool
name|build_classic_dist_vector_1
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|,
name|struct
name|data_reference
modifier|*
name|ddr_a
parameter_list|,
name|struct
name|data_reference
modifier|*
name|ddr_b
parameter_list|,
name|lambda_vector
name|dist_v
parameter_list|,
name|bool
modifier|*
name|init_b
parameter_list|,
name|int
modifier|*
name|index_carry
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|lambda_vector
name|init_v
init|=
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DDR_NUM_SUBSCRIPTS
argument_list|(
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|access_fn_a
decl_stmt|,
name|access_fn_b
decl_stmt|;
name|struct
name|subscript
modifier|*
name|subscript
init|=
name|DDR_SUBSCRIPT
argument_list|(
name|ddr
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|SUB_DISTANCE
argument_list|(
name|subscript
argument_list|)
argument_list|)
condition|)
block|{
name|non_affine_dependence_relation
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|access_fn_a
operator|=
name|DR_ACCESS_FN
argument_list|(
name|ddr_a
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|access_fn_b
operator|=
name|DR_ACCESS_FN
argument_list|(
name|ddr_b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|access_fn_a
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
operator|&&
name|TREE_CODE
argument_list|(
name|access_fn_b
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
condition|)
block|{
name|int
name|dist
decl_stmt|,
name|index
decl_stmt|;
name|int
name|index_a
init|=
name|index_in_loop_nest
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|access_fn_a
argument_list|)
argument_list|,
name|DDR_LOOP_NEST
argument_list|(
name|ddr
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|index_b
init|=
name|index_in_loop_nest
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|access_fn_b
argument_list|)
argument_list|,
name|DDR_LOOP_NEST
argument_list|(
name|ddr
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The dependence is carried by the outermost loop.  Example: 	     | loop_1 	     |   A[{4, +, 1}_1] 	     |   loop_2 	     |     A[{5, +, 1}_2] 	     |   endloop_2 	     | endloop_1 	     In this case, the dependence is carried by loop_1.  */
name|index
operator|=
name|index_a
operator|<
name|index_b
condition|?
name|index_a
else|:
name|index_b
expr_stmt|;
operator|*
name|index_carry
operator|=
name|MIN
argument_list|(
name|index
argument_list|,
operator|*
name|index_carry
argument_list|)
expr_stmt|;
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|SUB_DISTANCE
argument_list|(
name|subscript
argument_list|)
argument_list|)
condition|)
block|{
name|non_affine_dependence_relation
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|dist
operator|=
name|int_cst_value
argument_list|(
name|SUB_DISTANCE
argument_list|(
name|subscript
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is the subscript coupling test.  If we have already 	     recorded a distance for this loop (a distance coming from 	     another subscript), it should be the same.  For example, 	     in the following code, there is no dependence:  	     | loop i = 0, N, 1 	     |   T[i+1][i] = ... 	     |   ... = T[i][i] 	     | endloop 	  */
if|if
condition|(
name|init_v
index|[
name|index
index|]
operator|!=
literal|0
operator|&&
name|dist_v
index|[
name|index
index|]
operator|!=
name|dist
condition|)
block|{
name|finalize_ddr_dependent
argument_list|(
name|ddr
argument_list|,
name|chrec_known
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|dist_v
index|[
name|index
index|]
operator|=
name|dist
expr_stmt|;
name|init_v
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
operator|*
name|init_b
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* This can be for example an affine vs. constant dependence 	     (T[i] vs. T[3]) that is not an affine dependence and is 	     not representable as a distance vector.  */
name|non_affine_dependence_relation
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true when the DDR contains two data references that have the    same access functions.  */
end_comment

begin_function
specifier|static
name|bool
name|same_access_functions
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DDR_NUM_SUBSCRIPTS
argument_list|(
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|eq_evolutions_p
argument_list|(
name|DR_ACCESS_FN
argument_list|(
name|DDR_A
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|,
name|DR_ACCESS_FN
argument_list|(
name|DDR_B
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Helper function for the case where DDR_A and DDR_B are the same    multivariate access function.  */
end_comment

begin_function
specifier|static
name|void
name|add_multivariate_self_dist
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|,
name|tree
name|c_2
parameter_list|)
block|{
name|int
name|x_1
decl_stmt|,
name|x_2
decl_stmt|;
name|tree
name|c_1
init|=
name|CHREC_LEFT
argument_list|(
name|c_2
argument_list|)
decl_stmt|;
name|tree
name|c_0
init|=
name|CHREC_LEFT
argument_list|(
name|c_1
argument_list|)
decl_stmt|;
name|lambda_vector
name|dist_v
decl_stmt|;
comment|/* Polynomials with more than 2 variables are not handled yet.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|c_0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
return|return;
block|}
name|x_2
operator|=
name|index_in_loop_nest
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|c_2
argument_list|)
argument_list|,
name|DDR_LOOP_NEST
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|x_1
operator|=
name|index_in_loop_nest
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|c_1
argument_list|)
argument_list|,
name|DDR_LOOP_NEST
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For "{{0, +, 2}_1, +, 3}_2" the distance vector is (3, -2).  */
name|dist_v
operator|=
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|dist_v
index|[
name|x_1
index|]
operator|=
name|int_cst_value
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|c_2
argument_list|)
argument_list|)
expr_stmt|;
name|dist_v
index|[
name|x_2
index|]
operator|=
operator|-
name|int_cst_value
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|c_1
argument_list|)
argument_list|)
expr_stmt|;
name|save_dist_v
argument_list|(
name|ddr
argument_list|,
name|dist_v
argument_list|)
expr_stmt|;
name|add_outer_distances
argument_list|(
name|ddr
argument_list|,
name|dist_v
argument_list|,
name|x_1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for the case where DDR_A and DDR_B are the same    access functions.  */
end_comment

begin_function
specifier|static
name|void
name|add_other_self_distances
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
name|lambda_vector
name|dist_v
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|index_carry
init|=
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DDR_NUM_SUBSCRIPTS
argument_list|(
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|access_fun
init|=
name|DR_ACCESS_FN
argument_list|(
name|DDR_A
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|access_fun
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
condition|)
block|{
if|if
condition|(
operator|!
name|evolution_function_is_univariate_p
argument_list|(
name|access_fun
argument_list|)
condition|)
block|{
if|if
condition|(
name|DDR_NUM_SUBSCRIPTS
argument_list|(
name|ddr
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
return|return;
block|}
name|add_multivariate_self_dist
argument_list|(
name|ddr
argument_list|,
name|DR_ACCESS_FN
argument_list|(
name|DDR_A
argument_list|(
name|ddr
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|index_carry
operator|=
name|MIN
argument_list|(
name|index_carry
argument_list|,
name|index_in_loop_nest
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|access_fun
argument_list|)
argument_list|,
name|DDR_LOOP_NEST
argument_list|(
name|ddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dist_v
operator|=
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|add_outer_distances
argument_list|(
name|ddr
argument_list|,
name|dist_v
argument_list|,
name|index_carry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the classic per loop distance vector.  DDR is the data    dependence relation to build a vector from.  Return false when fail    to represent the data dependence as a distance vector.  */
end_comment

begin_function
specifier|static
name|bool
name|build_classic_dist_vector
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
name|bool
name|init_b
init|=
name|false
decl_stmt|;
name|int
name|index_carry
init|=
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
decl_stmt|;
name|lambda_vector
name|dist_v
decl_stmt|;
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|same_access_functions
argument_list|(
name|ddr
argument_list|)
condition|)
block|{
comment|/* Save the 0 vector.  */
name|dist_v
operator|=
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|save_dist_v
argument_list|(
name|ddr
argument_list|,
name|dist_v
argument_list|)
expr_stmt|;
if|if
condition|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
operator|>
literal|1
condition|)
name|add_other_self_distances
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|dist_v
operator|=
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|build_classic_dist_vector_1
argument_list|(
name|ddr
argument_list|,
name|DDR_A
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|DDR_B
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|dist_v
argument_list|,
operator|&
name|init_b
argument_list|,
operator|&
name|index_carry
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Save the distance vector if we initialized one.  */
if|if
condition|(
name|init_b
condition|)
block|{
comment|/* Verify a basic constraint: classic distance vectors should 	 always be lexicographically positive.  	 Data references are collected in the order of execution of 	 the program, thus for the following loop  	 | for (i = 1; i< 100; i++) 	 |   for (j = 1; j< 100; j++) 	 |     { 	 |       t = T[j+1][i-1];  // A 	 |       T[j][i] = t + 2;  // B 	 |     }  	 references are collected following the direction of the wind: 	 A then B.  The data dependence tests are performed also 	 following this order, such that we're looking at the distance 	 separating the elements accessed by A from the elements later 	 accessed by B.  But in this example, the distance returned by 	 test_dep (A, B) is lexicographically negative (-1, 1), that 	 means that the access A occurs later than B with respect to 	 the outer loop, ie. we're actually looking upwind.  In this 	 case we solve test_dep (B, A) looking downwind to the 	 lexicographically positive solution, that returns the 	 distance vector (1, -1).  */
if|if
condition|(
operator|!
name|lambda_vector_lexico_pos
argument_list|(
name|dist_v
argument_list|,
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
condition|)
block|{
name|lambda_vector
name|save_v
init|=
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
decl_stmt|;
name|subscript_dependence_tester_1
argument_list|(
name|ddr
argument_list|,
name|DDR_B
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|DDR_A
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|compute_subscript_distance
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
name|build_classic_dist_vector_1
argument_list|(
name|ddr
argument_list|,
name|DDR_B
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|DDR_A
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|save_v
argument_list|,
operator|&
name|init_b
argument_list|,
operator|&
name|index_carry
argument_list|)
expr_stmt|;
name|save_dist_v
argument_list|(
name|ddr
argument_list|,
name|save_v
argument_list|)
expr_stmt|;
comment|/* In this case there is a dependence forward for all the 	     outer loops:  	     | for (k = 1; k< 100; k++) 	     |  for (i = 1; i< 100; i++) 	     |   for (j = 1; j< 100; j++) 	     |     { 	     |       t = T[j+1][i-1];  // A 	     |       T[j][i] = t + 2;  // B 	     |     }  	     the vectors are:  	     (0,  1, -1) 	     (1,  1, -1) 	     (1, -1,  1) 	  */
if|if
condition|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
operator|>
literal|1
condition|)
block|{
name|add_outer_distances
argument_list|(
name|ddr
argument_list|,
name|save_v
argument_list|,
name|index_carry
argument_list|)
expr_stmt|;
name|add_outer_distances
argument_list|(
name|ddr
argument_list|,
name|dist_v
argument_list|,
name|index_carry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lambda_vector
name|save_v
init|=
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
decl_stmt|;
name|lambda_vector_copy
argument_list|(
name|dist_v
argument_list|,
name|save_v
argument_list|,
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|save_dist_v
argument_list|(
name|ddr
argument_list|,
name|save_v
argument_list|)
expr_stmt|;
if|if
condition|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
operator|>
literal|1
condition|)
block|{
name|lambda_vector
name|opposite_v
init|=
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
decl_stmt|;
name|subscript_dependence_tester_1
argument_list|(
name|ddr
argument_list|,
name|DDR_B
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|DDR_A
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|compute_subscript_distance
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
name|build_classic_dist_vector_1
argument_list|(
name|ddr
argument_list|,
name|DDR_B
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|DDR_A
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|opposite_v
argument_list|,
operator|&
name|init_b
argument_list|,
operator|&
name|index_carry
argument_list|)
expr_stmt|;
name|add_outer_distances
argument_list|(
name|ddr
argument_list|,
name|dist_v
argument_list|,
name|index_carry
argument_list|)
expr_stmt|;
name|add_outer_distances
argument_list|(
name|ddr
argument_list|,
name|opposite_v
argument_list|,
name|index_carry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* There is a distance of 1 on all the outer loops: Example: 	 there is a dependence of distance 1 on loop_1 for the array A.  	 | loop_1 	 |   A[5] = ... 	 | endloop       */
name|add_outer_distances
argument_list|(
name|ddr
argument_list|,
name|dist_v
argument_list|,
name|lambda_vector_first_nz
argument_list|(
name|dist_v
argument_list|,
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(build_classic_dist_vector\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DDR_NUM_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  dist_vector = ("
argument_list|)
expr_stmt|;
name|print_lambda_vector
argument_list|(
name|dump_file
argument_list|,
name|DDR_DIST_VECT
argument_list|(
name|ddr
argument_list|,
name|i
argument_list|)
argument_list|,
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  )\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the direction for a given distance.    FIXME: Computing dir this way is suboptimal, since dir can catch    cases that dist is unable to represent.  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|data_dependence_direction
name|dir_from_dist
parameter_list|(
name|int
name|dist
parameter_list|)
block|{
if|if
condition|(
name|dist
operator|>
literal|0
condition|)
return|return
name|dir_positive
return|;
elseif|else
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
return|return
name|dir_negative
return|;
else|else
return|return
name|dir_equal
return|;
block|}
end_function

begin_comment
comment|/* Compute the classic per loop direction vector.  DDR is the data    dependence relation to build a vector from.  */
end_comment

begin_function
specifier|static
name|void
name|build_classic_dir_vector
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lambda_vector
name|dist_v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|lambda_vector
argument_list|,
name|DDR_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|i
argument_list|,
name|dist_v
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|lambda_vector
name|dir_v
init|=
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
condition|;
name|j
operator|++
control|)
name|dir_v
index|[
name|j
index|]
operator|=
name|dir_from_dist
argument_list|(
name|dist_v
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|save_dir_v
argument_list|(
name|ddr
argument_list|,
name|dir_v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function.  Returns true when there is a dependence between    data references DRA and DRB.  */
end_comment

begin_function
specifier|static
name|bool
name|subscript_dependence_tester_1
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|,
name|struct
name|data_reference
modifier|*
name|dra
parameter_list|,
name|struct
name|data_reference
modifier|*
name|drb
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|tree
name|last_conflicts
decl_stmt|;
name|struct
name|subscript
modifier|*
name|subscript
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|subscript_p
argument_list|,
name|DDR_SUBSCRIPTS
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|i
argument_list|,
name|subscript
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|overlaps_a
decl_stmt|,
name|overlaps_b
decl_stmt|;
name|analyze_overlapping_iterations
argument_list|(
name|DR_ACCESS_FN
argument_list|(
name|dra
argument_list|,
name|i
argument_list|)
argument_list|,
name|DR_ACCESS_FN
argument_list|(
name|drb
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|overlaps_a
argument_list|,
operator|&
name|overlaps_b
argument_list|,
operator|&
name|last_conflicts
argument_list|)
expr_stmt|;
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|overlaps_a
argument_list|)
operator|||
name|chrec_contains_undetermined
argument_list|(
name|overlaps_b
argument_list|)
condition|)
block|{
name|finalize_ddr_dependent
argument_list|(
name|ddr
argument_list|,
name|chrec_dont_know
argument_list|)
expr_stmt|;
name|dependence_stats
operator|.
name|num_dependence_undetermined
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|overlaps_a
operator|==
name|chrec_known
operator|||
name|overlaps_b
operator|==
name|chrec_known
condition|)
block|{
name|finalize_ddr_dependent
argument_list|(
name|ddr
argument_list|,
name|chrec_known
argument_list|)
expr_stmt|;
name|dependence_stats
operator|.
name|num_dependence_independent
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|SUB_CONFLICTS_IN_A
argument_list|(
name|subscript
argument_list|)
operator|=
name|overlaps_a
expr_stmt|;
name|SUB_CONFLICTS_IN_B
argument_list|(
name|subscript
argument_list|)
operator|=
name|overlaps_b
expr_stmt|;
name|SUB_LAST_CONFLICT
argument_list|(
name|subscript
argument_list|)
operator|=
name|last_conflicts
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Computes the conflicting iterations, and initialize DDR.  */
end_comment

begin_function
specifier|static
name|void
name|subscript_dependence_tester
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(subscript_dependence_tester \n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subscript_dependence_tester_1
argument_list|(
name|ddr
argument_list|,
name|DDR_A
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|DDR_B
argument_list|(
name|ddr
argument_list|)
argument_list|)
condition|)
name|dependence_stats
operator|.
name|num_dependence_dependent
operator|++
expr_stmt|;
name|compute_subscript_distance
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|build_classic_dist_vector
argument_list|(
name|ddr
argument_list|)
condition|)
name|build_classic_dir_vector
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true when all the access functions of A are affine or    constant.  */
end_comment

begin_function
specifier|static
name|bool
name|access_functions_are_affine_or_constant_p
parameter_list|(
name|struct
name|data_reference
modifier|*
name|a
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|fns
operator|=
name|DR_ACCESS_FNS_ADDR
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|tree
name|t
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
operator|*
name|fns
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|evolution_function_is_constant_p
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|evolution_function_is_affine_multivariate_p
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This computes the affine dependence relation between A and B.    CHREC_KNOWN is used for representing the independence between two    accesses, while CHREC_DONT_KNOW is used for representing the unknown    relation.        Note that it is possible to stop the computation of the dependence    relation the first time we detect a CHREC_KNOWN element for a given    subscript.  */
end_comment

begin_function
specifier|static
name|void
name|compute_affine_dependence
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
name|struct
name|data_reference
modifier|*
name|dra
init|=
name|DDR_A
argument_list|(
name|ddr
argument_list|)
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|drb
init|=
name|DDR_B
argument_list|(
name|ddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(compute_affine_dependence\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (stmt_a = \n"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|DR_STMT
argument_list|(
name|dra
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n  (stmt_b = \n"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|DR_STMT
argument_list|(
name|drb
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Analyze only when the dependence relation is not yet known.  */
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|dependence_stats
operator|.
name|num_dependence_tests
operator|++
expr_stmt|;
if|if
condition|(
name|access_functions_are_affine_or_constant_p
argument_list|(
name|dra
argument_list|)
operator|&&
name|access_functions_are_affine_or_constant_p
argument_list|(
name|drb
argument_list|)
condition|)
name|subscript_dependence_tester
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
comment|/* As a last case, if the dependence cannot be determined, or if 	 the dependence is considered too difficult to determine, answer 	 "don't know".  */
else|else
block|{
name|dependence_stats
operator|.
name|num_dependence_undetermined
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Data ref a:\n"
argument_list|)
expr_stmt|;
name|dump_data_reference
argument_list|(
name|dump_file
argument_list|,
name|dra
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Data ref b:\n"
argument_list|)
expr_stmt|;
name|dump_data_reference
argument_list|(
name|dump_file
argument_list|,
name|drb
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"affine dependence test not usable: access function not affine or constant.\n"
argument_list|)
expr_stmt|;
block|}
name|finalize_ddr_dependent
argument_list|(
name|ddr
argument_list|,
name|chrec_dont_know
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This computes the dependence relation for the same data    reference into DDR.  */
end_comment

begin_function
specifier|static
name|void
name|compute_self_dependence
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|subscript
modifier|*
name|subscript
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|subscript_p
argument_list|,
name|DDR_SUBSCRIPTS
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|i
argument_list|,
name|subscript
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* The accessed index overlaps for each iteration.  */
name|SUB_CONFLICTS_IN_A
argument_list|(
name|subscript
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|SUB_CONFLICTS_IN_B
argument_list|(
name|subscript
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|SUB_LAST_CONFLICT
argument_list|(
name|subscript
argument_list|)
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
comment|/* The distance vector is the zero vector.  */
name|save_dist_v
argument_list|(
name|ddr
argument_list|,
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|save_dir_v
argument_list|(
name|ddr
argument_list|,
name|lambda_vector_new
argument_list|(
name|DDR_NB_LOOPS
argument_list|(
name|ddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute in DEPENDENCE_RELATIONS the data dependence graph for all    the data references in DATAREFS, in the LOOP_NEST.  When    COMPUTE_SELF_AND_RR is FALSE, don't compute read-read and self    relations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|compute_all_dependences
argument_list|(
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
argument_list|,
name|VEC
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|dependence_relations
argument_list|,
name|VEC
argument_list|(
name|loop_p
argument_list|,
name|heap
argument_list|)
operator|*
name|loop_nest
argument_list|,
name|bool
name|compute_self_and_rr
argument_list|)
block|{
name|struct
name|data_dependence_relation
modifier|*
name|ddr
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|a
argument_list|)
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|j
argument_list|,
name|b
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|DR_IS_READ
argument_list|(
name|a
argument_list|)
operator|||
operator|!
name|DR_IS_READ
argument_list|(
name|b
argument_list|)
operator|||
name|compute_self_and_rr
condition|)
block|{
name|ddr
operator|=
name|initialize_data_dependence_relation
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|loop_nest
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|,
operator|*
name|dependence_relations
argument_list|,
name|ddr
argument_list|)
expr_stmt|;
name|compute_affine_dependence
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compute_self_and_rr
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|a
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ddr
operator|=
name|initialize_data_dependence_relation
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|loop_nest
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|,
operator|*
name|dependence_relations
argument_list|,
name|ddr
argument_list|)
expr_stmt|;
name|compute_self_dependence
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Search the data references in LOOP, and record the information into    DATAREFS.  Returns chrec_dont_know when failing to analyze a    difficult case, returns NULL_TREE otherwise.        TODO: This function should be made smarter so that it can handle address    arithmetic as if they were array accesses, etc.  */
end_comment

begin_decl_stmt
name|tree
name|find_data_references_in_loop
argument_list|(
expr|struct
name|loop
operator|*
name|loop
argument_list|,
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|datarefs
argument_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
modifier|*
name|bbs
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
decl_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
comment|/* ASM_EXPR and CALL_EXPR may embed arbitrary side effects. 	     Calls have side-effects, except those to const or pure 	     functions.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|!
operator|(
name|call_expr_flags
argument_list|(
name|stmt
argument_list|)
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|ASM_EXPR
operator|&&
name|ASM_VOLATILE_P
argument_list|(
name|stmt
argument_list|)
operator|)
condition|)
goto|goto
name|insert_dont_know_node
goto|;
if|if
condition|(
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_ALL_VIRTUALS
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
block|{
name|bool
name|one_inserted
init|=
name|false
decl_stmt|;
name|tree
name|opnd0
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|opnd1
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|opnd0
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|opnd0
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|opnd0
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|dr
operator|=
name|create_data_ref
argument_list|(
name|opnd0
argument_list|,
name|stmt
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|,
operator|*
name|datarefs
argument_list|,
name|dr
argument_list|)
expr_stmt|;
name|one_inserted
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|opnd1
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|opnd1
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|opnd1
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|dr
operator|=
name|create_data_ref
argument_list|(
name|opnd1
argument_list|,
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|,
operator|*
name|datarefs
argument_list|,
name|dr
argument_list|)
expr_stmt|;
name|one_inserted
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|one_inserted
condition|)
goto|goto
name|insert_dont_know_node
goto|;
break|break;
block|}
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|args
decl_stmt|;
name|bool
name|one_inserted
init|=
name|false
decl_stmt|;
for|for
control|(
name|args
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|dr
operator|=
name|create_data_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|,
operator|*
name|datarefs
argument_list|,
name|dr
argument_list|)
expr_stmt|;
name|one_inserted
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|one_inserted
condition|)
goto|goto
name|insert_dont_know_node
goto|;
break|break;
block|}
default|default:
block|{
name|struct
name|data_reference
modifier|*
name|res
decl_stmt|;
name|insert_dont_know_node
label|:
empty_stmt|;
name|res
operator|=
name|XNEW
argument_list|(
expr|struct
name|data_reference
argument_list|)
expr_stmt|;
name|DR_STMT
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_REF
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_BASE_OBJECT
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DR_TYPE
argument_list|(
name|res
argument_list|)
operator|=
name|ARRAY_REF_TYPE
expr_stmt|;
name|DR_SET_ACCESS_FNS
argument_list|(
name|res
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DR_BASE_OBJECT
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DR_IS_READ
argument_list|(
name|res
argument_list|)
operator|=
name|false
expr_stmt|;
name|DR_BASE_ADDRESS
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_OFFSET
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_INIT
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_STEP
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_OFFSET_MISALIGNMENT
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_MEMTAG
argument_list|(
name|res
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DR_PTR_INFO
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|,
operator|*
name|datarefs
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|chrec_dont_know
return|;
block|}
block|}
comment|/* When there are no defs in the loop, the loop is parallel.  */
if|if
condition|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VIRTUAL_DEFS
argument_list|)
condition|)
name|loop
operator|->
name|parallel_p
operator|=
name|false
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Recursive helper function.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|find_loop_nest_1
argument_list|(
expr|struct
name|loop
operator|*
name|loop
argument_list|,
name|VEC
argument_list|(
name|loop_p
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|loop_nest
argument_list|)
block|{
comment|/* Inner loops of the nest should not contain siblings.  Example:      when there are two consecutive loops,       | loop_0      |   loop_1      |     A[{0, +, 1}_1]      |   endloop_1      |   loop_2      |     A[{0, +, 1}_2]      |   endloop_2      | endloop_0       the dependence relation cannot be captured by the distance      abstraction.  */
if|if
condition|(
name|loop
operator|->
name|next
condition|)
return|return
name|false
return|;
name|VEC_safe_push
argument_list|(
name|loop_p
argument_list|,
name|heap
argument_list|,
operator|*
name|loop_nest
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
return|return
name|find_loop_nest_1
argument_list|(
name|loop
operator|->
name|inner
argument_list|,
name|loop_nest
argument_list|)
return|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return false when the LOOP is not well nested.  Otherwise return    true and insert in LOOP_NEST the loops of the nest.  LOOP_NEST will    contain the loops from the outermost to the innermost, as they will    appear in the classic distance vector.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|find_loop_nest
argument_list|(
expr|struct
name|loop
operator|*
name|loop
argument_list|,
name|VEC
argument_list|(
name|loop_p
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|loop_nest
argument_list|)
block|{
name|VEC_safe_push
argument_list|(
name|loop_p
argument_list|,
name|heap
argument_list|,
operator|*
name|loop_nest
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
return|return
name|find_loop_nest_1
argument_list|(
name|loop
operator|->
name|inner
argument_list|,
name|loop_nest
argument_list|)
return|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Given a loop nest LOOP, the following vectors are returned:    DATAREFS is initialized to all the array elements contained in this loop,     DEPENDENCE_RELATIONS contains the relations between the data references.      Compute read-read and self relations if     COMPUTE_SELF_AND_READ_READ_DEPENDENCES is TRUE.  */
end_comment

begin_decl_stmt
name|void
name|compute_data_dependences_for_loop
argument_list|(
expr|struct
name|loop
operator|*
name|loop
argument_list|,
name|bool
name|compute_self_and_read_read_dependences
argument_list|,
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|datarefs
argument_list|,
name|VEC
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|dependence_relations
argument_list|)
block|{
name|struct
name|loop
modifier|*
name|loop_nest
init|=
name|loop
decl_stmt|;
name|VEC
argument_list|(
name|loop_p
argument_list|,
name|heap
argument_list|)
operator|*
name|vloops
operator|=
name|VEC_alloc
argument_list|(
name|loop_p
argument_list|,
name|heap
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dependence_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dependence_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the loop nest is not well formed, or one of the data references       is not computable, give up without spending time to compute other      dependences.  */
if|if
condition|(
operator|!
name|loop_nest
operator|||
operator|!
name|find_loop_nest
argument_list|(
name|loop_nest
argument_list|,
operator|&
name|vloops
argument_list|)
operator|||
name|find_data_references_in_loop
argument_list|(
name|loop
argument_list|,
name|datarefs
argument_list|)
operator|==
name|chrec_dont_know
condition|)
block|{
name|struct
name|data_dependence_relation
modifier|*
name|ddr
decl_stmt|;
comment|/* Insert a single relation into dependence_relations: 	 chrec_dont_know.  */
name|ddr
operator|=
name|initialize_data_dependence_relation
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|vloops
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|,
operator|*
name|dependence_relations
argument_list|,
name|ddr
argument_list|)
expr_stmt|;
block|}
else|else
name|compute_all_dependences
argument_list|(
operator|*
name|datarefs
argument_list|,
name|dependence_relations
argument_list|,
name|vloops
argument_list|,
name|compute_self_and_read_read_dependences
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Dependence tester statistics:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of dependence tests: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_dependence_tests
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of dependence tests classified dependent: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_dependence_dependent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of dependence tests classified independent: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_dependence_independent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of undetermined dependence tests: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_dependence_undetermined
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of subscript tests: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_subscript_tests
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of undetermined subscript tests: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_subscript_undetermined
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of same subscript function: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_same_subscript_function
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of ziv tests: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_ziv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of ziv tests returning dependent: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_ziv_dependent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of ziv tests returning independent: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_ziv_independent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of ziv tests unimplemented: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_ziv_unimplemented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of siv tests: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_siv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of siv tests returning dependent: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_siv_dependent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of siv tests returning independent: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_siv_independent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of siv tests unimplemented: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_siv_unimplemented
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of miv tests: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_miv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of miv tests returning dependent: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_miv_dependent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of miv tests returning independent: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_miv_independent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of miv tests unimplemented: %d\n"
argument_list|,
name|dependence_stats
operator|.
name|num_miv_unimplemented
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Entry point (for testing only).  Analyze all the data references    and the dependence relations.     The data references are computed first.          A relation on these nodes is represented by a complete graph.  Some    of the relations could be of no interest, thus the relations can be    computed on demand.        In the following function we compute all the relations.  This is    just a first implementation that is here for:    - for showing how to ask for the dependence relations,     - for the debugging the whole dependence graph,    - for the dejagnu testcases and maintenance.        It is possible to ask only for a part of the graph, avoiding to    compute the whole dependence graph.  The computed dependences are    stored in a knowledge base (KB) such that later queries don't    recompute the same information.  The implementation of this KB is    transparent to the optimizer, and thus the KB can be changed with a    more efficient implementation, or the KB could be disabled.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void  analyze_all_data_dependences (struct loops *loops) {   unsigned int i;   int nb_data_refs = 10;   VEC (data_reference_p, heap) *datarefs =      VEC_alloc (data_reference_p, heap, nb_data_refs);   VEC (ddr_p, heap) *dependence_relations =      VEC_alloc (ddr_p, heap, nb_data_refs * nb_data_refs);
comment|/* Compute DDs on the whole function.  */
end_comment

begin_endif
unit|compute_data_dependences_for_loop (loops->parray[0], false,&datarefs,&dependence_relations);    if (dump_file)     {       dump_data_dependence_relations (dump_file, dependence_relations);       fprintf (dump_file, "\n\n");        if (dump_flags& TDF_DETAILS) 	dump_dist_dir_vectors (dump_file, dependence_relations);        if (dump_flags& TDF_STATS) 	{ 	  unsigned nb_top_relations = 0; 	  unsigned nb_bot_relations = 0; 	  unsigned nb_basename_differ = 0; 	  unsigned nb_chrec_relations = 0; 	  struct data_dependence_relation *ddr;  	  for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++) 	    { 	      if (chrec_contains_undetermined (DDR_ARE_DEPENDENT (ddr))) 		nb_top_relations++; 	   	      else if (DDR_ARE_DEPENDENT (ddr) == chrec_known) 		{ 		  struct data_reference *a = DDR_A (ddr); 		  struct data_reference *b = DDR_B (ddr); 		  bool differ_p;	 	       		  if ((DR_BASE_OBJECT (a)&& DR_BASE_OBJECT (b)&& DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b)) 		      || (base_object_differ_p (a, b,&differ_p)&& differ_p)) 		    nb_basename_differ++; 		  else 		    nb_bot_relations++; 		} 	   	      else  		nb_chrec_relations++; 	    }        	  gather_stats_on_scev_database (); 	}     }    free_dependence_relations (dependence_relations);   free_data_refs (datarefs); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Free the memory used by a data dependence relation DDR.  */
end_comment

begin_function
name|void
name|free_dependence_relation
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|)
block|{
if|if
condition|(
name|ddr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DDR_SUBSCRIPTS
argument_list|(
name|ddr
argument_list|)
condition|)
name|VEC_free
argument_list|(
name|subscript_p
argument_list|,
name|heap
argument_list|,
name|DDR_SUBSCRIPTS
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the memory used by the data dependence relations from    DEPENDENCE_RELATIONS.  */
end_comment

begin_decl_stmt
name|void
name|free_dependence_relations
argument_list|(
name|VEC
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|)
operator|*
name|dependence_relations
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|data_dependence_relation
modifier|*
name|ddr
decl_stmt|;
name|VEC
argument_list|(
name|loop_p
argument_list|,
name|heap
argument_list|)
operator|*
name|loop_nest
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ddr_p
argument_list|,
name|dependence_relations
argument_list|,
name|i
argument_list|,
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ddr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|loop_nest
operator|==
name|NULL
condition|)
name|loop_nest
operator|=
name|DDR_LOOP_NEST
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|DDR_LOOP_NEST
argument_list|(
name|ddr
argument_list|)
operator|==
name|NULL
operator|||
name|DDR_LOOP_NEST
argument_list|(
name|ddr
argument_list|)
operator|==
name|loop_nest
argument_list|)
expr_stmt|;
name|free_dependence_relation
argument_list|(
name|ddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop_nest
condition|)
name|VEC_free
argument_list|(
name|loop_p
argument_list|,
name|heap
argument_list|,
name|loop_nest
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|,
name|dependence_relations
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Free the memory used by the data references from DATAREFS.  */
end_comment

begin_decl_stmt
name|void
name|free_data_refs
argument_list|(
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
name|free_data_ref
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|,
name|datarefs
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

end_unit

