begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Some code common to C and ObjC front ends.    Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_function_decl
specifier|static
name|bool
name|c_tree_printer
parameter_list|(
name|pretty_printer
modifier|*
parameter_list|,
name|text_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|start_cdtor
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_cdtor
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|c_missing_noreturn_ok_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* A missing noreturn is not ok for freestanding implementations and      ok for the `main' function in hosted implementations.  */
return|return
name|flag_hosted
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We want to inline `extern inline' functions even if this would    violate inlining limits.  Some glibc and linux constructs depend on    such functions always being inlined when optimizing.  */
end_comment

begin_function
name|int
name|c_disregard_inline_limits
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"always_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
return|return
operator|(
operator|!
name|flag_really_no_inline
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|c_cannot_inline_tree_fn
parameter_list|(
name|tree
modifier|*
name|fnp
parameter_list|)
block|{
name|tree
name|fn
init|=
operator|*
name|fnp
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|bool
name|do_warning
init|=
operator|(
name|warn_inline
operator|&&
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|fn
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|flag_really_no_inline
operator|&&
name|lookup_attribute
argument_list|(
literal|"always_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|do_warning
condition|)
name|warning
argument_list|(
literal|"%Jfunction '%F' can never be inlined because it "
literal|"is suppressed using -fno-inline"
argument_list|,
name|fn
argument_list|,
name|fn
argument_list|)
expr_stmt|;
goto|goto
name|cannot_inline
goto|;
block|}
comment|/* Don't auto-inline anything that might not be bound within      this unit of translation.  */
if|if
condition|(
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_warning
condition|)
name|warning
argument_list|(
literal|"%Jfunction '%F' can never be inlined because it might not "
literal|"be bound within this unit of translation"
argument_list|,
name|fn
argument_list|,
name|fn
argument_list|)
expr_stmt|;
goto|goto
name|cannot_inline
goto|;
block|}
if|if
condition|(
operator|!
name|function_attribute_inlinable_p
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_warning
condition|)
name|warning
argument_list|(
literal|"%Jfunction '%F' can never be inlined because it uses "
literal|"attributes conflicting with inlining"
argument_list|,
name|fn
argument_list|,
name|fn
argument_list|)
expr_stmt|;
goto|goto
name|cannot_inline
goto|;
block|}
comment|/* If a function has pending sizes, we must not defer its      compilation, and we can't inline it as a tree.  */
if|if
condition|(
name|fn
operator|==
name|current_function_decl
condition|)
block|{
name|t
operator|=
name|get_pending_sizes
argument_list|()
expr_stmt|;
name|put_pending_sizes
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|do_warning
condition|)
name|warning
argument_list|(
literal|"%Jfunction '%F' can never be inlined because it has "
literal|"pending sizes"
argument_list|,
name|fn
argument_list|,
name|fn
argument_list|)
expr_stmt|;
goto|goto
name|cannot_inline
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|DECL_FILE_SCOPE_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* If a nested function has pending sizes, we may have already          saved them.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|fn
argument_list|)
operator|->
name|pending_sizes
condition|)
block|{
if|if
condition|(
name|do_warning
condition|)
name|warning
argument_list|(
literal|"%Jnested function '%F' can never be inlined because it "
literal|"has possibly saved pending sizes"
argument_list|,
name|fn
argument_list|,
name|fn
argument_list|)
expr_stmt|;
goto|goto
name|cannot_inline
goto|;
block|}
block|}
return|return
literal|0
return|;
name|cannot_inline
label|:
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Called from check_global_declarations.  */
end_comment

begin_function
name|bool
name|c_warn_unused_global_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Initialization common to C and Objective-C front ends.  */
end_comment

begin_function
name|bool
name|c_objc_common_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|enum
name|tree_code
name|stmt_codes
index|[]
init|=
block|{
name|c_common_stmt_codes
block|}
decl_stmt|;
name|INIT_STATEMENT_CODES
argument_list|(
name|stmt_codes
argument_list|)
expr_stmt|;
name|c_init_decl_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|c_common_init
argument_list|()
operator|==
name|false
condition|)
return|return
name|false
return|;
name|lang_expand_decl_stmt
operator|=
name|c_expand_decl_stmt
expr_stmt|;
comment|/* These were not defined in the Objective-C front end, but I'm      putting them here anyway.  The diagnostic format decoder might      want an enhanced ObjC implementation.  */
name|diagnostic_format_decoder
argument_list|(
name|global_dc
argument_list|)
operator|=
operator|&
name|c_tree_printer
expr_stmt|;
name|lang_missing_noreturn_ok_p
operator|=
operator|&
name|c_missing_noreturn_ok_p
expr_stmt|;
comment|/* If still unspecified, make it match -std=c99      (allowing for -pedantic-errors).  */
if|if
condition|(
name|mesg_implicit_function_declaration
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|flag_isoc99
condition|)
name|mesg_implicit_function_declaration
operator|=
name|flag_pedantic_errors
condition|?
literal|2
else|:
literal|1
expr_stmt|;
else|else
name|mesg_implicit_function_declaration
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|start_cdtor
parameter_list|(
name|int
name|method_type
parameter_list|)
block|{
name|tree
name|fnname
init|=
name|get_file_function_name
argument_list|(
name|method_type
argument_list|)
decl_stmt|;
name|tree
name|void_list_node_1
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
decl_stmt|;
name|tree
name|body
decl_stmt|;
name|start_function
argument_list|(
name|void_list_node_1
argument_list|,
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|fnname
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|void_list_node_1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|current_function_cannot_inline
operator|=
literal|"static constructors and destructors cannot be inlined"
expr_stmt|;
name|body
operator|=
name|c_begin_compound_stmt
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|1
argument_list|,
comment|/*partial_p=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|body
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|finish_cdtor
parameter_list|(
name|tree
name|body
parameter_list|)
block|{
name|tree
name|scope
decl_stmt|;
name|tree
name|block
decl_stmt|;
name|scope
operator|=
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|0
argument_list|,
comment|/*partial_p=*/
literal|0
argument_list|)
expr_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|scope
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_VALUE
argument_list|(
name|scope
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|body
argument_list|,
name|COMPOUND_BODY
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|finish_function
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at end of parsing, but before end-of-file processing.  */
end_comment

begin_function
name|void
name|c_objc_common_finish_file
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|pch_file
condition|)
name|c_common_write_pch
argument_list|()
expr_stmt|;
comment|/* If multiple translation units were built, copy information between      them based on linkage rules.  */
name|merge_translation_unit_decls
argument_list|()
expr_stmt|;
name|cgraph_finalize_compilation_unit
argument_list|()
expr_stmt|;
name|cgraph_optimize
argument_list|()
expr_stmt|;
if|if
condition|(
name|static_ctors
condition|)
block|{
name|tree
name|body
init|=
name|start_cdtor
argument_list|(
literal|'I'
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|static_ctors
condition|;
name|static_ctors
operator|=
name|TREE_CHAIN
argument_list|(
name|static_ctors
argument_list|)
control|)
name|c_expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|TREE_VALUE
argument_list|(
name|static_ctors
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|finish_cdtor
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|static_dtors
condition|)
block|{
name|tree
name|body
init|=
name|start_cdtor
argument_list|(
literal|'D'
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|static_dtors
condition|;
name|static_dtors
operator|=
name|TREE_CHAIN
argument_list|(
name|static_dtors
argument_list|)
control|)
name|c_expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|TREE_VALUE
argument_list|(
name|static_dtors
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|finish_cdtor
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|dump_begin
argument_list|(
name|TDI_all
argument_list|,
operator|&
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
name|dump_node
argument_list|(
name|getdecls
argument_list|()
argument_list|,
name|flags
operator|&
operator|~
name|TDF_SLIM
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|dump_end
argument_list|(
name|TDI_all
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called during diagnostic message formatting process to print a    source-level entity onto BUFFER.  The meaning of the format specifiers    is as follows:    %D: a general decl,    %E: An expression,    %F: a function declaration,    %T: a type.     These format specifiers form a subset of the format specifiers set used    by the C++ front-end.    Please notice when called, the `%' part was already skipped by the    diagnostic machinery.  */
end_comment

begin_function
specifier|static
name|bool
name|c_tree_printer
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|text_info
modifier|*
name|text
parameter_list|)
block|{
name|tree
name|t
init|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|tree
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|n
init|=
literal|"({anonymous})"
decl_stmt|;
switch|switch
condition|(
operator|*
name|text
operator|->
name|format_spec
condition|)
block|{
case|case
literal|'D'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|n
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|n
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|n
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|n
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
return|return
name|false
return|;
break|break;
default|default:
return|return
name|false
return|;
block|}
name|pp_string
argument_list|(
name|pp
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

end_unit

