begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Some code common to C and ObjC front ends.    Copyright (C) 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|c_tree_printer
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|inline_forbidden_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_deferred_fns
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|start_cdtor
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_cdtor
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|varray_type
name|deferred_fns
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|c_missing_noreturn_ok_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* A missing noreturn is not ok for freestanding implementations and      ok for the `main' function in hosted implementations.  */
return|return
name|flag_hosted
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We want to inline `extern inline' functions even if this would    violate inlining limits.  Some glibc and linux constructs depend on    such functions always being inlined when optimizing.  */
end_comment

begin_function
name|int
name|c_disregard_inline_limits
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"always_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
return|return
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|inline_forbidden_p
parameter_list|(
name|nodep
parameter_list|,
name|walk_subtrees
parameter_list|,
name|fn
parameter_list|)
name|tree
modifier|*
name|nodep
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|fn
decl_stmt|;
block|{
name|tree
name|node
init|=
operator|*
name|nodep
decl_stmt|;
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
name|t
operator|=
name|get_callee_fndecl
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
break|break;
comment|/* We cannot inline functions that call setjmp.  */
if|if
condition|(
name|setjmp_call_p
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|node
return|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* We cannot inline functions that take a variable number of 	     arguments.  */
case|case
name|BUILT_IN_VARARGS_START
case|:
case|case
name|BUILT_IN_STDARG_START
case|:
if|#
directive|if
literal|0
comment|/* Functions that need information about the address of the              caller can't (shouldn't?) be inlined.  */
block|case BUILT_IN_RETURN_ADDRESS:
endif|#
directive|endif
return|return
name|node
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|DECL_STMT
case|:
comment|/* We cannot inline functions that contain other functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|node
return|;
break|break;
case|case
name|GOTO_STMT
case|:
case|case
name|GOTO_EXPR
case|:
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We will not inline a function which uses computed goto.  The 	 addresses of its local labels, which may be tucked into 	 global storage, are of course not constant across 	 instantiations, which causes unexpected behaviour.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
return|return
name|node
return|;
comment|/* We cannot inline a nested function that jumps to a nonlocal          label.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LABEL_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|fn
condition|)
return|return
name|node
return|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
comment|/* We cannot inline a function of the form  	   void F (int i) { struct S { int ar[i]; } s; }  	 Attempting to do so produces a catch-22 in tree-inline.c. 	 If walk_tree examines the TYPE_FIELDS chain of RECORD_TYPE/ 	 UNION_TYPE nodes, then it goes into infinite recursion on a 	 structure containing a pointer to its own type.  If it doesn't, 	 then the type node for S doesn't get adjusted properly when 	 F is inlined, and we abort in find_function_data.  */
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|node
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|variably_modified_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|node
return|;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|int
name|c_cannot_inline_tree_fn
parameter_list|(
name|fnp
parameter_list|)
name|tree
modifier|*
name|fnp
decl_stmt|;
block|{
name|tree
name|fn
init|=
operator|*
name|fnp
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|flag_really_no_inline
operator|&&
name|lookup_attribute
argument_list|(
literal|"always_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* Don't auto-inline anything that might not be bound within       this unit of translation.  */
if|if
condition|(
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|flag_pic
operator|&&
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|function_attribute_inlinable_p
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If a function has pending sizes, we must not defer its      compilation, and we can't inline it as a tree.  */
if|if
condition|(
name|fn
operator|==
name|current_function_decl
condition|)
block|{
name|t
operator|=
name|get_pending_sizes
argument_list|()
expr_stmt|;
name|put_pending_sizes
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* If a nested function has pending sizes, we may have already          saved them.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|fn
argument_list|)
operator|->
name|pending_sizes
condition|)
block|{
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* We rely on the fact that this function is called upfront, 	 just before we start expanding a function.  If FN is active 	 (i.e., it's the current_function_decl or a parent thereof), 	 we have to walk FN's saved tree.  Otherwise, we can safely 	 assume we have done it before and, if we didn't mark it as 	 uninlinable (in which case we wouldn't have been called), it 	 is inlinable.  Unfortunately, this strategy doesn't work for 	 nested functions, because they're only expanded as part of 	 their enclosing functions, so the inlinability test comes in 	 late.  */
name|t
operator|=
name|current_function_decl
expr_stmt|;
while|while
condition|(
name|t
operator|&&
name|t
operator|!=
name|fn
condition|)
name|t
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|walk_tree
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|inline_forbidden_p
argument_list|,
name|fn
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Initialization common to C and Objective-C front ends.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|c_objc_common_init
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|c_init_decl_processing
argument_list|()
expr_stmt|;
name|filename
operator|=
name|c_common_init
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|add_c_tree_codes
argument_list|()
expr_stmt|;
name|save_lang_status
operator|=
operator|&
name|push_c_function_context
expr_stmt|;
name|restore_lang_status
operator|=
operator|&
name|pop_c_function_context
expr_stmt|;
name|mark_lang_status
operator|=
operator|&
name|mark_c_function_context
expr_stmt|;
name|lang_expand_expr
operator|=
name|c_expand_expr
expr_stmt|;
name|lang_expand_decl_stmt
operator|=
name|c_expand_decl_stmt
expr_stmt|;
comment|/* These were not defined in the Objective-C front end, but I'm      putting them here anyway.  The diagnostic format decoder might      want an enhanced ObjC implementation.  */
name|diagnostic_format_decoder
argument_list|(
name|global_dc
argument_list|)
operator|=
operator|&
name|c_tree_printer
expr_stmt|;
name|lang_missing_noreturn_ok_p
operator|=
operator|&
name|c_missing_noreturn_ok_p
expr_stmt|;
comment|/* If still unspecified, make it match -std=c99      (allowing for -pedantic-errors).  */
if|if
condition|(
name|mesg_implicit_function_declaration
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|flag_isoc99
condition|)
name|mesg_implicit_function_declaration
operator|=
name|flag_pedantic_errors
condition|?
literal|2
else|:
literal|1
expr_stmt|;
else|else
name|mesg_implicit_function_declaration
operator|=
literal|0
expr_stmt|;
block|}
name|VARRAY_TREE_INIT
argument_list|(
name|deferred_fns
argument_list|,
literal|32
argument_list|,
literal|"deferred_fns"
argument_list|)
expr_stmt|;
name|ggc_add_tree_varray_root
argument_list|(
operator|&
name|deferred_fns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_comment
comment|/* Register a function tree, so that its optimization and conversion    to RTL is only done at the end of the compilation.  */
end_comment

begin_function
name|int
name|defer_fn
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
name|VARRAY_PUSH_TREE
argument_list|(
name|deferred_fns
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand deferred functions for C and ObjC.  */
end_comment

begin_function
specifier|static
name|void
name|expand_deferred_fns
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|deferred_fns
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|decl
init|=
name|VARRAY_TREE
argument_list|(
name|deferred_fns
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* For static inline functions, delay the decision whether to 	     emit them or not until wrapup_global_declarations.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|c_expand_deferred_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
name|VARRAY_FREE
argument_list|(
name|deferred_fns
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|start_cdtor
parameter_list|(
name|method_type
parameter_list|)
name|int
name|method_type
decl_stmt|;
block|{
name|tree
name|fnname
init|=
name|get_file_function_name
argument_list|(
name|method_type
argument_list|)
decl_stmt|;
name|tree
name|void_list_node_1
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
decl_stmt|;
name|tree
name|body
decl_stmt|;
name|start_function
argument_list|(
name|void_list_node_1
argument_list|,
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|fnname
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|void_list_node_1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|current_function_cannot_inline
operator|=
literal|"static constructors and destructors cannot be inlined"
expr_stmt|;
name|body
operator|=
name|c_begin_compound_stmt
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|1
argument_list|,
comment|/*partial_p=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|body
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|finish_cdtor
parameter_list|(
name|body
parameter_list|)
name|tree
name|body
decl_stmt|;
block|{
name|tree
name|scope
decl_stmt|;
name|tree
name|block
decl_stmt|;
name|scope
operator|=
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|0
argument_list|,
comment|/*partial_p=*/
literal|0
argument_list|)
expr_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|scope
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_VALUE
argument_list|(
name|scope
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|body
argument_list|,
name|COMPOUND_BODY
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|finish_function
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at end of parsing, but before end-of-file processing.  */
end_comment

begin_function
name|void
name|c_objc_common_finish_file
parameter_list|()
block|{
name|expand_deferred_fns
argument_list|()
expr_stmt|;
if|if
condition|(
name|static_ctors
condition|)
block|{
name|tree
name|body
init|=
name|start_cdtor
argument_list|(
literal|'I'
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|static_ctors
condition|;
name|static_ctors
operator|=
name|TREE_CHAIN
argument_list|(
name|static_ctors
argument_list|)
control|)
name|c_expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|TREE_VALUE
argument_list|(
name|static_ctors
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|finish_cdtor
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|static_dtors
condition|)
block|{
name|tree
name|body
init|=
name|start_cdtor
argument_list|(
literal|'D'
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|static_dtors
condition|;
name|static_dtors
operator|=
name|TREE_CHAIN
argument_list|(
name|static_dtors
argument_list|)
control|)
name|c_expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|TREE_VALUE
argument_list|(
name|static_dtors
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|finish_cdtor
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|dump_begin
argument_list|(
name|TDI_all
argument_list|,
operator|&
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
name|dump_node
argument_list|(
name|getdecls
argument_list|()
argument_list|,
name|flags
operator|&
operator|~
name|TDF_SLIM
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|dump_end
argument_list|(
name|TDI_all
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called during diagnostic message formatting process to print a    source-level entity onto BUFFER.  The meaning of the format specifiers    is as follows:    %D: a general decl,    %F: a function declaration,    %T: a type.     These format specifiers form a subset of the format specifiers set used    by the C++ front-end.    Please notice when called, the `%' part was already skipped by the    diagnostic machinery.  */
end_comment

begin_function
specifier|static
name|int
name|c_tree_printer
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|tree
name|t
init|=
name|va_arg
argument_list|(
name|output_buffer_format_args
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|tree
argument_list|)
decl_stmt|;
switch|switch
condition|(
operator|*
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
case|case
literal|'D'
case|:
case|case
literal|'F'
case|:
case|case
literal|'T'
case|:
block|{
specifier|const
name|char
modifier|*
name|n
init|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|?
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
else|:
literal|"({anonymous})"
decl_stmt|;
name|output_add_string
argument_list|(
name|buffer
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

end_unit

